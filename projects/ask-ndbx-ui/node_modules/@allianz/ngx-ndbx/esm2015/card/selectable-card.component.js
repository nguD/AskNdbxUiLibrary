/**
 * @fileoverview added by tsickle
 * Generated from: card/selectable-card.component.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import { ChangeDetectionStrategy, ChangeDetectorRef, ContentChildren, EventEmitter, forwardRef, Input, Optional, Output, QueryList, Self, } from '@angular/core';
import { Component } from '@angular/core';
import { Subject } from 'rxjs';
import { coerceBooleanProperty } from '@angular/cdk/coercion';
import { ErrorStateMatcher } from '@allianz/ngx-ndbx/utils';
import { FormGroupDirective, NgControl, NgForm } from '@angular/forms';
import { SelectableCard } from './selectable-card';
import { NxSelectableCardChangeEvent } from './selectable-card-change-event';
import { NxErrorComponent } from '@allianz/ngx-ndbx/base';
/** @type {?} */
let nextId = 0;
export class NxSelectableCardComponent extends SelectableCard {
    /**
     * @param {?} _changeDetectorRef
     * @param {?} _errorStateMatcher
     * @param {?} ngControl
     * @param {?} _parentForm
     * @param {?} _parentFormGroup
     */
    constructor(_changeDetectorRef, _errorStateMatcher, ngControl, _parentForm, _parentFormGroup) {
        super();
        this._changeDetectorRef = _changeDetectorRef;
        this._errorStateMatcher = _errorStateMatcher;
        this.ngControl = ngControl;
        this._parentForm = _parentForm;
        this._parentFormGroup = _parentFormGroup;
        this._id = (nextId++).toString();
        this._checked = false;
        this._disabled = false;
        this._negative = false;
        this._tabindex = '0';
        /**
         * \@docs-private
         */
        this._errorListIds = '';
        /**
         * \@docs-private
         */
        this.errorState = false;
        /**
         * \@docs-private
         */
        this.stateChanges = new Subject();
        /**
         * An event is dispatched each time the selectable card value is changed
         */
        this.selectionChange = new EventEmitter();
        /**
         * An event is dispatched each time the selectable card value is changed
         */
        this.checkedChange = new EventEmitter();
        /**
         * \@docs-private
         */
        this.onChangeCallback = (/**
         * @param {?} _
         * @return {?}
         */
        (_) => { });
        this.onTouchedCallback = (/**
         * @param {?} _
         * @return {?}
         */
        (_) => { });
        if (this.ngControl) {
            // Note: we provide the value accessor through here, instead of
            // the `providers` to avoid running into a circular import.
            this.ngControl.valueAccessor = this;
        }
    }
    /**
     * Id of the selectable card.
     *
     * If not set, the selectable card gets an incremented value by default.
     * @param {?} value
     * @return {?}
     */
    set id(value) {
        if (value !== this._id) {
            this._id = value;
            this._changeDetectorRef.markForCheck();
        }
    }
    /**
     * @return {?}
     */
    get id() {
        return `nx-selectable-card-${this._id}`;
    }
    /**
     * Whether the selectable card  is checked.
     * @param {?} value
     * @return {?}
     */
    set checked(value) {
        /** @type {?} */
        const newValue = coerceBooleanProperty(value);
        if (newValue !== this._checked) {
            this._checked = newValue;
            this._changeDetectorRef.markForCheck();
        }
    }
    /**
     * @return {?}
     */
    get checked() {
        return this._checked;
    }
    /**
     * The value attribute of the native input element
     * @return {?}
     */
    get value() {
        return this._value;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set value(value) {
        if (value) {
            this._value = value;
        }
        this._changeDetectorRef.markForCheck();
    }
    /**
     * Whether the selectable card is disabled.
     * @param {?} value
     * @return {?}
     */
    set disabled(value) {
        /** @type {?} */
        const newValue = coerceBooleanProperty(value);
        if (newValue !== this._disabled) {
            this._disabled = newValue;
            this._changeDetectorRef.markForCheck();
        }
    }
    /**
     * @return {?}
     */
    get disabled() {
        return this._disabled || null;
    }
    /**
     * Whether the selectable card is negative.
     * @param {?} value
     * @return {?}
     */
    set negative(value) {
        /** @type {?} */
        const newValue = coerceBooleanProperty(value);
        if (newValue !== this._negative) {
            this._negative = newValue;
            this._changeDetectorRef.markForCheck();
        }
    }
    /**
     * @return {?}
     */
    get negative() {
        return this._negative || null;
    }
    /**
     * Whether the selectable card is required.
     * @return {?}
     */
    get required() {
        return this._required;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set required(value) {
        this._required = coerceBooleanProperty(value);
    }
    /**
     * Name of the selectable card.
     * @return {?}
     */
    get name() {
        return this._name;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set name(value) {
        this._name = value;
    }
    /**
     * The tabIndex of the element
     * @return {?}
     */
    get tabindex() {
        if (this.disabled) {
            return '-1';
        }
        return this._tabindex;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set tabindex(value) {
        this._tabindex = value;
    }
    /**
     * @return {?}
     */
    ngAfterContentInit() {
        this._errorList.changes.subscribe((/**
         * @param {?} value
         * @return {?}
         */
        (value) => {
            this._errorListIds = value.map((/**
             * @param {?} errorItem
             * @return {?}
             */
            (errorItem) => {
                return errorItem.id;
            })).join(' ');
            this._changeDetectorRef.markForCheck();
        }));
        this._errorListIds = this._errorList.map((/**
         * @param {?} errorItem
         * @return {?}
         */
        (errorItem) => {
            return errorItem.id;
        })).join(' ');
    }
    /**
     * @param {?} fn
     * @return {?}
     */
    registerOnChange(fn) {
        this.onChangeCallback = fn;
    }
    /**
     * @param {?} onTouched
     * @return {?}
     */
    registerOnTouched(onTouched) {
        this.onTouchedCallback = onTouched;
    }
    /**
     * @param {?} isDisabled
     * @return {?}
     */
    setDisabledState(isDisabled) {
        this.disabled = isDisabled;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    writeValue(value) {
        this.checked = !!value;
    }
    /**
     * @return {?}
     */
    ngDoCheck() {
        if (this.ngControl) {
            // We need to re-evaluate this on every change detection cycle, because there are some
            // error triggers that we can't subscribe to (e.g. parent form submissions). This means
            // that whatever logic is in here has to be super lean or we risk destroying the performance.
            this.updateErrorState();
        }
    }
    /**
     * \@docs-private
     * @return {?}
     */
    updateErrorState() {
        /** @type {?} */
        const oldState = this.errorState;
        /** @type {?} */
        const parent = this._parentFormGroup || this._parentForm;
        /** @type {?} */
        const control = this.ngControl ? (/** @type {?} */ (this.ngControl.control)) : null;
        /** @type {?} */
        const newState = this._errorStateMatcher.isErrorState(control, parent);
        if (newState !== oldState) {
            this.errorState = newState;
            this.stateChanges.next();
        }
    }
    /**
     * Toggles the checked state of the selectable card .
     * @return {?}
     */
    toggle() {
        if (!this.disabled) {
            this.checked = !this.checked;
        }
    }
    /**
     * \@docs-private
     * @param {?} event
     * @return {?}
     */
    _onInputClick(event) {
        // We have to stop propagation for click events on the visual hidden input element.
        // By default, when a user clicks on a label element, a generated click event will be
        // stop the propagation of the native click on the checkbox input so that a click is not triggered twice
        // Preventing bubbling for the second event will solve that issue.
        event.stopPropagation();
        if (!this.disabled) {
            this.toggle();
            this._emitChangeEvent();
        }
    }
    /**
     * \@docs-private
     * @param {?} event
     * @return {?}
     */
    _onInteractionEvent(event) {
        // We always have to stop propagation on the change event.
        // Otherwise the change event, from the input element, will bubble up and
        // emit its event object to the `change` output.
        event.stopPropagation();
    }
    /**
     * \@docs-private
     * @private
     * @return {?}
     */
    _emitChangeEvent() {
        /** @type {?} */
        const event = new NxSelectableCardChangeEvent(this.checked, this.value, this);
        this.onChangeCallback(this.checked);
        this.selectionChange.emit(event);
        this.checkedChange.emit(this.checked);
    }
}
NxSelectableCardComponent.decorators = [
    { type: Component, args: [{
                selector: 'nx-selectable-card',
                template: "<input #input\n       type=\"checkbox\"\n       [checked]=\"checked\"\n       [value]=\"value || null\"\n       [attr.disabled]=\"disabled\"\n       (change)=\"_onInteractionEvent($event)\"\n       (blur)=\"onTouchedCallback($event)\"\n       [attr.id]=\"id\"\n       [attr.name]=\"name\"\n       (click)=\"_onInputClick($event)\"\n       [required]=\"required\"\n       [attr.aria-required]=\"required\"\n       [attr.tabindex]=\"tabindex\"\n       [attr.aria-invalid]=\"errorState\"\n       [attr.aria-describedby]=\"_errorListIds || null\"\n>\n\n<label [attr.for]=\"id\" [class.is-disabled]=\"disabled\">\n  <ng-container *ngTemplateOutlet=\"selectableCardContent\"></ng-container>\n</label>\n\n<ng-content *ngIf=\"errorState\" select=\"nx-error\"></ng-content>\n\n<ng-template #selectableCardContent>\n  <nx-icon name=\"check-circle\" size=\"s\" class=\"checked-icon\"></nx-icon>\n  <div class=\"nx-selectable-card--headline\">\n    <ng-content select=\"nx-card-header\"></ng-content>\n  </div>\n  <div class=\"nx-selectable-card--content\">\n    <ng-content></ng-content>\n  </div>\n  <div class=\"nx-selectable-card--footer\">\n    <ng-content select=\"nx-card-footer\"></ng-content>\n  </div>\n</ng-template>\n",
                changeDetection: ChangeDetectionStrategy.OnPush,
                providers: [{ provide: SelectableCard, useExisting: forwardRef((/**
                         * @return {?}
                         */
                        () => NxSelectableCardComponent)) }],
                host: {
                    '[class.is-checked]': 'checked',
                    '[class.is-disabled]': 'disabled',
                    '[class.has-error]': 'errorState',
                    '[attr.aria-invalid]': 'errorState',
                    '[attr.role]': '"checkbox"',
                    '[attr.aria-checked]': 'checked'
                },
                styles: [":host{display:block}:host input{position:absolute;height:0;width:0;overflow:hidden;opacity:0}:host label{border:1px solid #999;border:var(--selectable-card-border-width,1px) solid var(--selectable-card-border-color,#999);display:block;position:relative;padding:16px;cursor:pointer;width:100%;margin-bottom:8px;border-radius:4px;border-radius:var(--selectable-card-border-radius,4px);background:#fff;background:var(--selectable-card-background-color,#fff)}:host:focus{outline:0}:host::-moz-focus-inner{border:0}:host input:checked+label{background:#f5f5f5;background:var(--selectable-card-background-selected-color,#f5f5f5);border-color:#414141;border-color:var(--selectable-card-border-selected-color,#414141)}:host input:checked+label ::ng-deep nx-icon.checked-icon{display:block}:host label:active,:host label:hover{background:#f5f5f5;background:var(--selectable-card-background-hover-color,#f5f5f5);border-color:#414141;border-color:var(--selectable-card-border-hover-color,#414141)}:host input:checked+label:hover{background:#ececec;background:var(--selectable-card-background-selected-hover-color,#ececec)}:host ::ng-deep nx-icon.checked-icon{position:absolute;right:8px;top:8px;display:none}:host(.is-disabled) label{border-color:#ececec;border-color:var(--selectable-card-border-disabled-color,#ececec);cursor:not-allowed}:host(.is-disabled) label:hover{background:#fff;background:var(--selectable-card-background-disabled-color,#fff)}:host(.is-disabled) input:checked+label{background:#f5f5f5;background:var(--selectable-card-background-disabled-selected-color,#f5f5f5);border-color:#c2c2c2;border-color:var(--selectable-card-border-disabled-selected-color,#c2c2c2)}:host(.is-disabled) input:checked+label ::ng-deep nx-icon.checked-icon{display:block;color:#c2c2c2;color:var(--selectable-card-icon-diabled-color,#c2c2c2)}:host(.has-error) input:checked+label,:host(.has-error) input:checked+label:hover,:host(.has-error) label,:host(.has-error) label:hover{border-color:#dc3149;border-color:var(--selectable-card-border-error-color,#dc3149)}:host-context([data-whatinput=keyboard]) :host:focus label,:host-context([data-whatinput=keyboard]) input:focus+label{box-shadow:0 0 0 2px #fff,0 0 0 6px #009de6;box-shadow:var(--focus-box-shadow,0 0 0 2px #fff,0 0 0 6px #009de6)}@media screen and (-ms-high-contrast:active){:host-context([data-whatinput=keyboard]) :host:focus label,:host-context([data-whatinput=keyboard]) input:focus+label{box-shadow:0 0 0 2px background,0 0 0 6px windowText}:host label{border-color:buttonText}:host input:checked+label{border-width:3px;padding:14px;border-color:highlight}:host(.is-disabled) input:checked+label,:host(.is-disabled) label{border-color:GrayText;color:GrayText}:host(.is-disabled) input:checked+label ::ng-deep nx-icon.checked-icon,:host(.is-disabled) label ::ng-deep nx-icon.checked-icon{color:GrayText}}"]
            }] }
];
/** @nocollapse */
NxSelectableCardComponent.ctorParameters = () => [
    { type: ChangeDetectorRef },
    { type: ErrorStateMatcher },
    { type: NgControl, decorators: [{ type: Self }, { type: Optional }] },
    { type: NgForm, decorators: [{ type: Optional }] },
    { type: FormGroupDirective, decorators: [{ type: Optional }] }
];
NxSelectableCardComponent.propDecorators = {
    _errorList: [{ type: ContentChildren, args: [NxErrorComponent,] }],
    selectionChange: [{ type: Output }],
    checkedChange: [{ type: Output }],
    id: [{ type: Input }],
    checked: [{ type: Input }],
    value: [{ type: Input }],
    disabled: [{ type: Input }],
    negative: [{ type: Input }],
    required: [{ type: Input }],
    name: [{ type: Input }],
    tabindex: [{ type: Input }]
};
if (false) {
    /**
     * @type {?}
     * @private
     */
    NxSelectableCardComponent.prototype._id;
    /**
     * @type {?}
     * @private
     */
    NxSelectableCardComponent.prototype._checked;
    /**
     * @type {?}
     * @private
     */
    NxSelectableCardComponent.prototype._disabled;
    /**
     * @type {?}
     * @private
     */
    NxSelectableCardComponent.prototype._value;
    /**
     * @type {?}
     * @private
     */
    NxSelectableCardComponent.prototype._name;
    /**
     * @type {?}
     * @private
     */
    NxSelectableCardComponent.prototype._negative;
    /**
     * @type {?}
     * @private
     */
    NxSelectableCardComponent.prototype._tabindex;
    /**
     * @type {?}
     * @private
     */
    NxSelectableCardComponent.prototype._required;
    /**
     * \@docs-private
     * @type {?}
     */
    NxSelectableCardComponent.prototype._errorListIds;
    /**
     * \@docs-private
     * @type {?}
     */
    NxSelectableCardComponent.prototype._errorList;
    /**
     * \@docs-private
     * @type {?}
     */
    NxSelectableCardComponent.prototype.errorState;
    /**
     * \@docs-private
     * @type {?}
     */
    NxSelectableCardComponent.prototype.stateChanges;
    /**
     * An event is dispatched each time the selectable card value is changed
     * @type {?}
     */
    NxSelectableCardComponent.prototype.selectionChange;
    /**
     * An event is dispatched each time the selectable card value is changed
     * @type {?}
     */
    NxSelectableCardComponent.prototype.checkedChange;
    /**
     * \@docs-private
     * @type {?}
     */
    NxSelectableCardComponent.prototype.onChangeCallback;
    /** @type {?} */
    NxSelectableCardComponent.prototype.onTouchedCallback;
    /**
     * @type {?}
     * @private
     */
    NxSelectableCardComponent.prototype._changeDetectorRef;
    /**
     * @type {?}
     * @private
     */
    NxSelectableCardComponent.prototype._errorStateMatcher;
    /** @type {?} */
    NxSelectableCardComponent.prototype.ngControl;
    /**
     * @type {?}
     * @private
     */
    NxSelectableCardComponent.prototype._parentForm;
    /**
     * @type {?}
     * @private
     */
    NxSelectableCardComponent.prototype._parentFormGroup;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic2VsZWN0YWJsZS1jYXJkLmNvbXBvbmVudC5qcyIsInNvdXJjZVJvb3QiOiJuZzovL0BhbGxpYW56L25neC1uZGJ4LyIsInNvdXJjZXMiOlsiY2FyZC9zZWxlY3RhYmxlLWNhcmQuY29tcG9uZW50LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7O0FBQUEsT0FBTyxFQUVMLHVCQUF1QixFQUN2QixpQkFBaUIsRUFDakIsZUFBZSxFQUVmLFlBQVksRUFDWixVQUFVLEVBQ1YsS0FBSyxFQUNMLFFBQVEsRUFDUixNQUFNLEVBQ04sU0FBUyxFQUNULElBQUksR0FDTCxNQUFNLGVBQWUsQ0FBQztBQUN2QixPQUFPLEVBQUUsU0FBUyxFQUFFLE1BQU0sZUFBZSxDQUFDO0FBQzFDLE9BQU8sRUFBRSxPQUFPLEVBQUUsTUFBTSxNQUFNLENBQUM7QUFDL0IsT0FBTyxFQUFFLHFCQUFxQixFQUFFLE1BQU0sdUJBQXVCLENBQUM7QUFDOUQsT0FBTyxFQUFFLGlCQUFpQixFQUFFLE1BQU0seUJBQXlCLENBQUM7QUFFNUQsT0FBTyxFQUdMLGtCQUFrQixFQUNsQixTQUFTLEVBQ1QsTUFBTSxFQUNQLE1BQU0sZ0JBQWdCLENBQUM7QUFDeEIsT0FBTyxFQUFFLGNBQWMsRUFBRSxNQUFNLG1CQUFtQixDQUFDO0FBQ25ELE9BQU8sRUFBRSwyQkFBMkIsRUFBRSxNQUFNLGdDQUFnQyxDQUFDO0FBQzdFLE9BQU8sRUFBRSxnQkFBZ0IsRUFBRSxNQUFNLHdCQUF3QixDQUFDOztJQUV0RCxNQUFNLEdBQUcsQ0FBQztBQWtCZCxNQUFNLE9BQU8seUJBQTBCLFNBQVEsY0FBYzs7Ozs7Ozs7SUF1STNELFlBQW9CLGtCQUFxQyxFQUNyQyxrQkFBcUMsRUFDbEIsU0FBb0IsRUFDM0IsV0FBbUIsRUFDbkIsZ0JBQW9DO1FBRWxFLEtBQUssRUFBRSxDQUFDO1FBTlUsdUJBQWtCLEdBQWxCLGtCQUFrQixDQUFtQjtRQUNyQyx1QkFBa0IsR0FBbEIsa0JBQWtCLENBQW1CO1FBQ2xCLGNBQVMs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aW1wb3J0IHtcbiAgQWZ0ZXJDb250ZW50SW5pdCxcbiAgQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3ksXG4gIENoYW5nZURldGVjdG9yUmVmLFxuICBDb250ZW50Q2hpbGRyZW4sXG4gIERvQ2hlY2ssXG4gIEV2ZW50RW1pdHRlcixcbiAgZm9yd2FyZFJlZixcbiAgSW5wdXQsXG4gIE9wdGlvbmFsLFxuICBPdXRwdXQsXG4gIFF1ZXJ5TGlzdCxcbiAgU2VsZixcbn0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBDb21wb25lbnQgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IFN1YmplY3QgfSBmcm9tICdyeGpzJztcbmltcG9ydCB7IGNvZXJjZUJvb2xlYW5Qcm9wZXJ0eSB9IGZyb20gJ0Bhbmd1bGFyL2Nkay9jb2VyY2lvbic7XG5pbXBvcnQgeyBFcnJvclN0YXRlTWF0Y2hlciB9IGZyb20gJ0BhbGxpYW56L25neC1uZGJ4L3V0aWxzJztcblxuaW1wb3J0IHtcbiAgQ29udHJvbFZhbHVlQWNjZXNzb3IsXG4gIEZvcm1Db250cm9sLFxuICBGb3JtR3JvdXBEaXJlY3RpdmUsXG4gIE5nQ29udHJvbCxcbiAgTmdGb3JtXG59IGZyb20gJ0Bhbmd1bGFyL2Zvcm1zJztcbmltcG9ydCB7IFNlbGVjdGFibGVDYXJkIH0gZnJvbSAnLi9zZWxlY3RhYmxlLWNhcmQnO1xuaW1wb3J0IHsgTnhTZWxlY3RhYmxlQ2FyZENoYW5nZUV2ZW50IH0gZnJvbSAnLi9zZWxlY3RhYmxlLWNhcmQtY2hhbmdlLWV2ZW50JztcbmltcG9ydCB7IE54RXJyb3JDb21wb25lbnQgfSBmcm9tICdAYWxsaWFuei9uZ3gtbmRieC9iYXNlJztcblxubGV0IG5leHRJZCA9IDA7XG5cbkBDb21wb25lbnQoe1xuICBzZWxlY3RvcjogJ254LXNlbGVjdGFibGUtY2FyZCcsXG4gIHRlbXBsYXRlVXJsOiAnLi9zZWxlY3RhYmxlLWNhcmQuY29tcG9uZW50Lmh0bWwnLFxuICBjaGFuZ2VEZXRlY3Rpb246IENoYW5nZURldGVjdGlvblN0cmF0ZWd5Lk9uUHVzaCxcbiAgc3R5bGVVcmxzOiBbJy4vc2VsZWN0YWJsZS1jYXJkLmNvbXBvbmVudC5zY3NzJ10sXG4gIHByb3ZpZGVyczogW3twcm92aWRlOiBTZWxlY3RhYmxlQ2FyZCwgdXNlRXhpc3Rpbmc6IGZvcndhcmRSZWYoKCkgPT4gTnhTZWxlY3RhYmxlQ2FyZENvbXBvbmVudCl9XSxcbiAgaG9zdDoge1xuICAgICdbY2xhc3MuaXMtY2hlY2tlZF0nOiAnY2hlY2tlZCcsXG4gICAgJ1tjbGFzcy5pcy1kaXNhYmxlZF0nOiAnZGlzYWJsZWQnLFxuICAgICdbY2xhc3MuaGFzLWVycm9yXSc6ICdlcnJvclN0YXRlJyxcbiAgICAnW2F0dHIuYXJpYS1pbnZhbGlkXSc6ICdlcnJvclN0YXRlJyxcbiAgICAnW2F0dHIucm9sZV0nOiAnXCJjaGVja2JveFwiJyxcbiAgICAnW2F0dHIuYXJpYS1jaGVja2VkXSc6ICdjaGVja2VkJ1xuICB9XG59KVxuXG5leHBvcnQgY2xhc3MgTnhTZWxlY3RhYmxlQ2FyZENvbXBvbmVudCBleHRlbmRzIFNlbGVjdGFibGVDYXJkIGltcGxlbWVudHMgQ29udHJvbFZhbHVlQWNjZXNzb3IsIERvQ2hlY2ssIEFmdGVyQ29udGVudEluaXQge1xuICBwcml2YXRlIF9pZDogc3RyaW5nID0gKG5leHRJZCsrKS50b1N0cmluZygpO1xuICBwcml2YXRlIF9jaGVja2VkID0gZmFsc2U7XG4gIHByaXZhdGUgX2Rpc2FibGVkOiBib29sZWFuID0gZmFsc2U7XG4gIHByaXZhdGUgX3ZhbHVlOiBzdHJpbmc7XG4gIHByaXZhdGUgX25hbWU6IHN0cmluZztcbiAgcHJpdmF0ZSBfbmVnYXRpdmU6IGJvb2xlYW4gPSBmYWxzZTtcbiAgcHJpdmF0ZSBfdGFiaW5kZXg6IHN0cmluZyA9ICcwJztcbiAgcHJpdmF0ZSBfcmVxdWlyZWQ6IGJvb2xlYW47XG4gIC8qKiBAZG9jcy1wcml2YXRlICovXG4gIF9lcnJvckxpc3RJZHM6IHN0cmluZyA9ICcnO1xuXG4gIC8qKiBAZG9jcy1wcml2YXRlICovXG4gIEBDb250ZW50Q2hpbGRyZW4oTnhFcnJvckNvbXBvbmVudCkgX2Vycm9yTGlzdDogUXVlcnlMaXN0PE54RXJyb3JDb21wb25lbnQ+O1xuXG4gIC8qKiBAZG9jcy1wcml2YXRlICovXG4gIGVycm9yU3RhdGU6IGJvb2xlYW4gPSBmYWxzZTtcblxuICAvKiogQGRvY3MtcHJpdmF0ZSAqL1xuICBzdGF0ZUNoYW5nZXMgPSBuZXcgU3ViamVjdDx2b2lkPigpO1xuXG4gIC8qKiBBbiBldmVudCBpcyBkaXNwYXRjaGVkIGVhY2ggdGltZSB0aGUgc2VsZWN0YWJsZSBjYXJkIHZhbHVlIGlzIGNoYW5nZWQgKi9cbiAgQE91dHB1dCgpXG4gIHNlbGVjdGlvbkNoYW5nZTogRXZlbnRFbWl0dGVyPE54U2VsZWN0YWJsZUNhcmRDaGFuZ2VFdmVudD4gPSBuZXcgRXZlbnRFbWl0dGVyPE54U2VsZWN0YWJsZUNhcmRDaGFuZ2VFdmVudD4oKTtcblxuICAvKiogQW4gZXZlbnQgaXMgZGlzcGF0Y2hlZCBlYWNoIHRpbWUgdGhlIHNlbGVjdGFibGUgY2FyZCB2YWx1ZSBpcyBjaGFuZ2VkICovXG4gIEBPdXRwdXQoKSBjaGVja2VkQ2hhbmdlID0gbmV3IEV2ZW50RW1pdHRlcjxib29sZWFuPigpO1xuXG4gIC8qKlxuICAgKiBJZCBvZiB0aGUgc2VsZWN0YWJsZSBjYXJkLlxuICAgKlxuICAgKiBJZiBub3Qgc2V0LCB0aGUgc2VsZWN0YWJsZSBjYXJkIGdldHMgYW4gaW5jcmVtZW50ZWQgdmFsdWUgYnkgZGVmYXVsdC5cbiAgICovXG4gIEBJbnB1dCgpXG4gIHNldCBpZCh2YWx1ZTogc3RyaW5nKSB7XG4gICAgaWYgKHZhbHVlICE9PSB0aGlzLl9pZCkge1xuICAgICAgdGhpcy5faWQgPSB2YWx1ZTtcbiAgICAgIHRoaXMuX2NoYW5nZURldGVjdG9yUmVmLm1hcmtGb3JDaGVjaygpO1xuICAgIH1cbiAgfVxuXG4gIGdldCBpZCgpIHtcbiAgICByZXR1cm4gYG54LXNlbGVjdGFibGUtY2FyZC0ke3RoaXMuX2lkfWA7XG4gIH1cblxuICAvKiogV2hldGhlciB0aGUgc2VsZWN0YWJsZSBjYXJkICBpcyBjaGVja2VkLiAqL1xuICBASW5wdXQoKVxuICBzZXQgY2hlY2tlZCh2YWx1ZTogYm9vbGVhbikge1xuICAgIGNvbnN0IG5ld1ZhbHVlID0gY29lcmNlQm9vbGVhblByb3BlcnR5KHZhbHVlKTtcbiAgICBpZiAobmV3VmFsdWUgIT09IHRoaXMuX2NoZWNrZWQpIHtcbiAgICAgIHRoaXMuX2NoZWNrZWQgPSBuZXdWYWx1ZTtcbiAgICAgIHRoaXMuX2NoYW5nZURldGVjdG9yUmVmLm1hcmtGb3JDaGVjaygpO1xuICAgIH1cbiAgfVxuXG4gIGdldCBjaGVja2VkKCkge1xuICAgIHJldHVybiB0aGlzLl9jaGVja2VkO1xuICB9XG5cbiAgLyoqIFRoZSB2YWx1ZSBhdHRyaWJ1dGUgb2YgdGhlIG5hdGl2ZSBpbnB1dCBlbGVtZW50ICAqL1xuICBASW5wdXQoKVxuICBnZXQgdmFsdWUoKTogc3RyaW5nIHtcbiAgICByZXR1cm4gdGhpcy5fdmFsdWU7XG4gIH1cblxuICBzZXQgdmFsdWUodmFsdWU6IHN0cmluZykge1xuICAgIGlmICh2YWx1ZSkge1xuICAgICAgdGhpcy5fdmFsdWUgPSB2YWx1ZTtcbiAgICB9XG5cbiAgICB0aGlzLl9jaGFuZ2VEZXRlY3RvclJlZi5tYXJrRm9yQ2hlY2soKTtcbiAgfVxuXG4gIC8qKiBXaGV0aGVyIHRoZSBzZWxlY3RhYmxlIGNhcmQgaXMgZGlzYWJsZWQuICovXG4gIEBJbnB1dCgpXG4gIHNldCBkaXNhYmxlZCh2YWx1ZTogYm9vbGVhbikge1xuICAgIGNvbnN0IG5ld1ZhbHVlID0gY29lcmNlQm9vbGVhblByb3BlcnR5KHZhbHVlKTtcbiAgICBpZiAobmV3VmFsdWUgIT09IHRoaXMuX2Rpc2FibGVkKSB7XG4gICAgICB0aGlzLl9kaXNhYmxlZCA9IG5ld1ZhbHVlO1xuICAgICAgdGhpcy5fY2hhbmdlRGV0ZWN0b3JSZWYubWFya0ZvckNoZWNrKCk7XG4gICAgfVxuICB9XG5cbiAgZ2V0IGRpc2FibGVkKCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0aGlzLl9kaXNhYmxlZCB8fCBudWxsO1xuICB9XG5cbiAgLyoqIFdoZXRoZXIgdGhlIHNlbGVjdGFibGUgY2FyZCBpcyBuZWdhdGl2ZS4gKi9cbiAgQElucHV0KClcbiAgc2V0IG5lZ2F0aXZlKHZhbHVlOiBib29sZWFuKSB7XG4gICAgY29uc3QgbmV3VmFsdWUgPSBjb2VyY2VCb29sZWFuUHJvcGVydHkodmFsdWUpO1xuICAgIGlmIChuZXdWYWx1ZSAhPT0gdGhpcy5fbmVnYXRpdmUpIHtcbiAgICAgIHRoaXMuX25lZ2F0aXZlID0gbmV3VmFsdWU7XG4gICAgICB0aGlzLl9jaGFuZ2VEZXRlY3RvclJlZi5tYXJrRm9yQ2hlY2soKTtcbiAgICB9XG4gIH1cblxuICBnZXQgbmVnYXRpdmUoKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRoaXMuX25lZ2F0aXZlIHx8IG51bGw7XG4gIH1cblxuICAvKiogV2hldGhlciB0aGUgc2VsZWN0YWJsZSBjYXJkIGlzIHJlcXVpcmVkLiAqL1xuICBASW5wdXQoKVxuICBnZXQgcmVxdWlyZWQoKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRoaXMuX3JlcXVpcmVkO1xuICB9XG5cbiAgc2V0IHJlcXVpcmVkKHZhbHVlOiBib29sZWFuKSB7XG4gICAgdGhpcy5fcmVxdWlyZWQgPSBjb2VyY2VCb29sZWFuUHJvcGVydHkodmFsdWUpO1xuICB9XG5cbiAgLyoqIE5hbWUgb2YgdGhlIHNlbGVjdGFibGUgY2FyZC4gKi9cbiAgQElucHV0KClcbiAgZ2V0IG5hbWUoKTogc3RyaW5nIHtcbiAgICByZXR1cm4gdGhpcy5fbmFtZTtcbiAgfVxuXG4gIHNldCBuYW1lKHZhbHVlOiBzdHJpbmcpIHtcbiAgICB0aGlzLl9uYW1lID0gdmFsdWU7XG4gIH1cblxuICAvKiogVGhlIHRhYkluZGV4IG9mIHRoZSBlbGVtZW50ICovXG4gIEBJbnB1dCgpXG4gIGdldCB0YWJpbmRleCgpOiBzdHJpbmcge1xuICAgIGlmICh0aGlzLmRpc2FibGVkKSB7XG4gICAgICByZXR1cm4gJy0xJztcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5fdGFiaW5kZXg7XG4gIH1cblxuICBzZXQgdGFiaW5kZXgodmFsdWU6IHN0cmluZykge1xuICAgIHRoaXMuX3RhYmluZGV4ID0gdmFsdWU7XG4gIH1cblxuICBjb25zdHJ1Y3Rvcihwcml2YXRlIF9jaGFuZ2VEZXRlY3RvclJlZjogQ2hhbmdlRGV0ZWN0b3JSZWYsXG4gICAgICAgICAgICAgIHByaXZhdGUgX2Vycm9yU3RhdGVNYXRjaGVyOiBFcnJvclN0YXRlTWF0Y2hlcixcbiAgICAgICAgICAgICAgQFNlbGYoKSBAT3B0aW9uYWwoKSBwdWJsaWMgbmdDb250cm9sOiBOZ0NvbnRyb2wsXG4gICAgICAgICAgICAgIEBPcHRpb25hbCgpIHByaXZhdGUgX3BhcmVudEZvcm06IE5nRm9ybSxcbiAgICAgICAgICAgICAgQE9wdGlvbmFsKCkgcHJpdmF0ZSBfcGFyZW50Rm9ybUdyb3VwOiBGb3JtR3JvdXBEaXJlY3RpdmVcbiAgKSB7XG4gICAgc3VwZXIoKTtcblxuICAgIGlmICh0aGlzLm5nQ29udHJvbCkge1xuICAgICAgLy8gTm90ZTogd2UgcHJvdmlkZSB0aGUgdmFsdWUgYWNjZXNzb3IgdGhyb3VnaCBoZXJlLCBpbnN0ZWFkIG9mXG4gICAgICAvLyB0aGUgYHByb3ZpZGVyc2AgdG8gYXZvaWQgcnVubmluZyBpbnRvIGEgY2lyY3VsYXIgaW1wb3J0LlxuICAgICAgdGhpcy5uZ0NvbnRyb2wudmFsdWVBY2Nlc3NvciA9IHRoaXM7XG4gICAgfVxuICB9XG5cbiAgbmdBZnRlckNvbnRlbnRJbml0KCkge1xuICAgIHRoaXMuX2Vycm9yTGlzdC5jaGFuZ2VzLnN1YnNjcmliZSgodmFsdWUpID0+IHtcbiAgICAgIHRoaXMuX2Vycm9yTGlzdElkcyA9IHZhbHVlLm1hcCgoZXJyb3JJdGVtOiBOeEVycm9yQ29tcG9uZW50KSA9PiB7XG4gICAgICAgIHJldHVybiBlcnJvckl0ZW0uaWQ7XG4gICAgICB9KS5qb2luKCcgJyk7XG4gICAgICB0aGlzLl9jaGFuZ2VEZXRlY3RvclJlZi5tYXJrRm9yQ2hlY2soKTtcbiAgICB9KTtcblxuICAgIHRoaXMuX2Vycm9yTGlzdElkcyA9IHRoaXMuX2Vycm9yTGlzdC5tYXAoKGVycm9ySXRlbTogTnhFcnJvckNvbXBvbmVudCkgPT4ge1xuICAgICAgcmV0dXJuIGVycm9ySXRlbS5pZDtcbiAgICB9KS5qb2luKCcgJyk7XG4gIH1cblxuICAvKiogQGRvY3MtcHJpdmF0ZSAqL1xuICBvbkNoYW5nZUNhbGxiYWNrID0gKF86IGFueSkgPT4ge307XG5cbiAgcmVnaXN0ZXJPbkNoYW5nZShmbjogYW55KTogdm9pZCB7XG4gICAgdGhpcy5vbkNoYW5nZUNhbGxiYWNrID0gZm47XG4gIH1cblxuICBvblRvdWNoZWRDYWxsYmFjayA9IChfOiBhbnkpID0+IHt9O1xuXG4gIHJlZ2lzdGVyT25Ub3VjaGVkKG9uVG91Y2hlZDogYW55KTogdm9pZCB7XG4gICAgdGhpcy5vblRvdWNoZWRDYWxsYmFjayA9IG9uVG91Y2hlZDtcbiAgfVxuXG4gIHNldERpc2FibGVkU3RhdGU/KGlzRGlzYWJsZWQ6IGJvb2xlYW4pOiB2b2lkIHtcbiAgICB0aGlzLmRpc2FibGVkID0gaXNEaXNhYmxlZDtcbiAgfVxuXG4gIHdyaXRlVmFsdWUodmFsdWU6IGFueSk6IHZvaWQge1xuICAgIHRoaXMuY2hlY2tlZCA9ICEhdmFsdWU7XG4gIH1cblxuICBuZ0RvQ2hlY2soKSB7XG4gICAgaWYgKHRoaXMubmdDb250cm9sKSB7XG4gICAgICAvLyBXZSBuZWVkIHRvIHJlLWV2YWx1YXRlIHRoaXMgb24gZXZlcnkgY2hhbmdlIGRldGVjdGlvbiBjeWNsZSwgYmVjYXVzZSB0aGVyZSBhcmUgc29tZVxuICAgICAgLy8gZXJyb3IgdHJpZ2dlcnMgdGhhdCB3ZSBjYW4ndCBzdWJzY3JpYmUgdG8gKGUuZy4gcGFyZW50IGZvcm0gc3VibWlzc2lvbnMpLiBUaGlzIG1lYW5zXG4gICAgICAvLyB0aGF0IHdoYXRldmVyIGxvZ2ljIGlzIGluIGhlcmUgaGFzIHRvIGJlIHN1cGVyIGxlYW4gb3Igd2UgcmlzayBkZXN0cm95aW5nIHRoZSBwZXJmb3JtYW5jZS5cbiAgICAgIHRoaXMudXBkYXRlRXJyb3JTdGF0ZSgpO1xuICAgIH1cbiAgfVxuXG4gIC8qKiBAZG9jcy1wcml2YXRlICovXG4gIHVwZGF0ZUVycm9yU3RhdGUoKSB7XG4gICAgY29uc3Qgb2xkU3RhdGUgPSB0aGlzLmVycm9yU3RhdGU7XG4gICAgY29uc3QgcGFyZW50ID0gdGhpcy5fcGFyZW50Rm9ybUdyb3VwIHx8IHRoaXMuX3BhcmVudEZvcm07XG4gICAgY29uc3QgY29udHJvbCA9IHRoaXMubmdDb250cm9sID8gdGhpcy5uZ0NvbnRyb2wuY29udHJvbCBhcyBGb3JtQ29udHJvbCA6IG51bGw7XG4gICAgY29uc3QgbmV3U3RhdGUgPSB0aGlzLl9lcnJvclN0YXRlTWF0Y2hlci5pc0Vycm9yU3RhdGUoY29udHJvbCwgcGFyZW50KTtcblxuICAgIGlmIChuZXdTdGF0ZSAhPT0gb2xkU3RhdGUpIHtcbiAgICAgIHRoaXMuZXJyb3JTdGF0ZSA9IG5ld1N0YXRlO1xuICAgICAgdGhpcy5zdGF0ZUNoYW5nZXMubmV4dCgpO1xuICAgIH1cbiAgfVxuXG4gIC8qKiBUb2dnbGVzIHRoZSBjaGVja2VkIHN0YXRlIG9mIHRoZSBzZWxlY3RhYmxlIGNhcmQgLiAqL1xuICBwdWJsaWMgdG9nZ2xlKCkge1xuICAgIGlmICghdGhpcy5kaXNhYmxlZCkge1xuICAgICAgdGhpcy5jaGVja2VkID0gIXRoaXMuY2hlY2tlZDtcbiAgICB9XG4gIH1cblxuICAvKiogQGRvY3MtcHJpdmF0ZSAqL1xuICBfb25JbnB1dENsaWNrKGV2ZW50OiBFdmVudCk6IHZvaWQge1xuICAgIC8vIFdlIGhhdmUgdG8gc3RvcCBwcm9wYWdhdGlvbiBmb3IgY2xpY2sgZXZlbnRzIG9uIHRoZSB2aXN1YWwgaGlkZGVuIGlucHV0IGVsZW1lbnQuXG4gICAgLy8gQnkgZGVmYXVsdCwgd2hlbiBhIHVzZXIgY2xpY2tzIG9uIGEgbGFiZWwgZWxlbWVudCwgYSBnZW5lcmF0ZWQgY2xpY2sgZXZlbnQgd2lsbCBiZVxuICAgIC8vIHN0b3AgdGhlIHByb3BhZ2F0aW9uIG9mIHRoZSBuYXRpdmUgY2xpY2sgb24gdGhlIGNoZWNrYm94IGlucHV0IHNvIHRoYXQgYSBjbGljayBpcyBub3QgdHJpZ2dlcmVkIHR3aWNlXG4gICAgLy8gUHJldmVudGluZyBidWJibGluZyBmb3IgdGhlIHNlY29uZCBldmVudCB3aWxsIHNvbHZlIHRoYXQgaXNzdWUuXG4gICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgaWYgKCF0aGlzLmRpc2FibGVkKSB7XG4gICAgICB0aGlzLnRvZ2dsZSgpO1xuICAgICAgdGhpcy5fZW1pdENoYW5nZUV2ZW50KCk7XG4gICAgfVxuICB9XG5cbiAgLyoqIEBkb2NzLXByaXZhdGUgKi9cbiAgX29uSW50ZXJhY3Rpb25FdmVudChldmVudDogRXZlbnQpIHtcbiAgICAvLyBXZSBhbHdheXMgaGF2ZSB0byBzdG9wIHByb3BhZ2F0aW9uIG9uIHRoZSBjaGFuZ2UgZXZlbnQuXG4gICAgLy8gT3RoZXJ3aXNlIHRoZSBjaGFuZ2UgZXZlbnQsIGZyb20gdGhlIGlucHV0IGVsZW1lbnQsIHdpbGwgYnViYmxlIHVwIGFuZFxuICAgIC8vIGVtaXQgaXRzIGV2ZW50IG9iamVjdCB0byB0aGUgYGNoYW5nZWAgb3V0cHV0LlxuICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICB9XG5cbiAgLyoqIEBkb2NzLXByaXZhdGUgKi9cbiAgcHJpdmF0ZSBfZW1pdENoYW5nZUV2ZW50KCkge1xuICAgIGNvbnN0IGV2ZW50ID0gbmV3IE54U2VsZWN0YWJsZUNhcmRDaGFuZ2VFdmVudCh0aGlzLmNoZWNrZWQsIHRoaXMudmFsdWUsIHRoaXMpO1xuICAgIHRoaXMub25DaGFuZ2VDYWxsYmFjayh0aGlzLmNoZWNrZWQpO1xuICAgIHRoaXMuc2VsZWN0aW9uQ2hhbmdlLmVtaXQoZXZlbnQpO1xuICAgIHRoaXMuY2hlY2tlZENoYW5nZS5lbWl0KHRoaXMuY2hlY2tlZCk7XG4gIH1cbn1cbiJdfQ==