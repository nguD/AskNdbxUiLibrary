/**
 * @fileoverview added by tsickle
 * Generated from: progress-stepper.component.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import { DOCUMENT } from '@angular/common';
import { CdkStep, CdkStepper } from '@angular/cdk/stepper';
import { ChangeDetectionStrategy, Component, ContentChildren, Directive, forwardRef, Inject, Input, QueryList, SkipSelf, ElementRef, ChangeDetectorRef } from '@angular/core';
import { takeUntil, takeWhile } from 'rxjs/operators';
import { ErrorStateMatcher } from '@allianz/ngx-ndbx/utils';
import { Subject } from 'rxjs';
import { Directionality } from '@angular/cdk/bidi';
// tslint:disable:use-input-property-decorator
// We need to reference steps in stepper and stepper in steps. To prevent circular depenedency errors
// Provide both components in a single file. Otherwise we would have to introduce interface/abstract classes
// shared between both implementations.
export class NxStepComponent extends CdkStep {
    /**
     * @param {?} stepper
     * @param {?} _errorStateMatcher
     */
    constructor(stepper, _errorStateMatcher) {
        super(stepper);
        this.stepper = stepper;
        this._errorStateMatcher = _errorStateMatcher;
        this._destroyed = new Subject();
        this._interacted = false;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set stepControl(value) {
        this._stepControl = value;
        // If a step control changes its state, the stepper needs to update.
        if (this._stepControl) {
            this._stepControl.statusChanges
                .pipe(takeUntil(this._destroyed), takeWhile((/**
             * @return {?}
             */
            () => this._stepControl === value)))
                .subscribe((/**
             * @return {?}
             */
            () => {
                this.stepper._stateChanged();
            }));
        }
    }
    /**
     * The top level abstract control of the step.
     * @return {?}
     */
    get stepControl() {
        return this._stepControl;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set interacted(value) {
        this._interacted = value;
        if (this.stepper) {
            this.stepper._stateChanged();
        }
    }
    /**
     * Whether the user has seen the expanded step content or not.
     * @return {?}
     */
    get interacted() {
        return this._interacted;
    }
    /**
     * Custom error state matcher that checks for validity of the step form.
     * @param {?} control
     * @param {?} form
     * @return {?}
     */
    isErrorState(control, form) {
        /** @type {?} */
        const originalErrorState = this._errorStateMatcher.isErrorState(control, form);
        // Checks for the validity of a step form that is not submitted or touched,
        // e.g when the user directly clicks the "next" button or directly on the step
        /** @type {?} */
        const customErrorState = !!(control && control.invalid && this.interacted);
        return originalErrorState || customErrorState;
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this._destroyed.next(true);
        this._destroyed.complete();
    }
}
NxStepComponent.decorators = [
    { type: Component, args: [{
                selector: 'nx-step',
                template: "<ng-template><ng-content></ng-content></ng-template>\n",
                exportAs: 'nxStep',
                providers: [{ provide: ErrorStateMatcher, useExisting: NxStepComponent }],
                preserveWhitespaces: false,
                changeDetection: ChangeDetectionStrategy.OnPush
            }] }
];
/** @nocollapse */
NxStepComponent.ctorParameters = () => [
    { type: NxProgressStepperDirective, decorators: [{ type: Inject, args: [forwardRef((/**
                     * @return {?}
                     */
                    () => NxProgressStepperDirective)),] }] },
    { type: ErrorStateMatcher, decorators: [{ type: SkipSelf }] }
];
if (false) {
    /** @type {?} */
    NxStepComponent.prototype._destroyed;
    /**
     * @type {?}
     * @private
     */
    NxStepComponent.prototype._stepControl;
    /**
     * @type {?}
     * @private
     */
    NxStepComponent.prototype._interacted;
    /**
     * @type {?}
     * @private
     */
    NxStepComponent.prototype.stepper;
    /**
     * @type {?}
     * @private
     */
    NxStepComponent.prototype._errorStateMatcher;
}
/**
 * \@docs-private
 */
export class NxProgressStepperDirective extends CdkStepper {
    /**
     * @param {?} _cdRef
     * @param {?} _dir
     * @param {?} _elementRef
     * @param {?=} _document
     */
    constructor(_cdRef, _dir, _elementRef, _document) {
        super(_dir, _cdRef, _elementRef, _document);
        this._cdRef = _cdRef;
        this._stepHeader = new QueryList();
    }
    /**
     * @return {?}
     */
    ngAfterContentInit() {
        // Mark the component for change detection whenever the content children query changes
        this._steps.changes
            .pipe(takeUntil(this._destroyed))
            .subscribe((/**
         * @return {?}
         */
        () => {
            this._stateChanged();
        }));
        // If a step control changes its state, the stepper needs to update.
        this._steps.filter((/**
         * @param {?} s
         * @return {?}
         */
        s => !!s.stepControl))
            .forEach((/**
         * @param {?} step
         * @return {?}
         */
        step => {
            step.stepControl.statusChanges
                .pipe(takeUntil(step._destroyed))
                .subscribe((/**
             * @return {?}
             */
            () => {
                this._stateChanged();
            }));
        }));
        // we need to defer change detection that the nxStepperNext and NxStepperPrevious buttons
        // can run change detection again, because they are initialized before the stepper content
        Promise.resolve().then((/**
         * @return {?}
         */
        () => {
            this._cdRef.detectChanges();
        }));
    }
    /**
     * \@docs-private
     * @return {?}
     */
    get hasPrevious() {
        return (this.selectedIndex - 1) >= 0;
    }
    /**
     * \@docs-private
     * @return {?}
     */
    get hasNext() {
        return (this.selectedIndex + 1) < this.count;
    }
    /**
     * \@docs-private
     * @return {?}
     */
    get count() {
        return this._steps ? this._steps.length : 0;
    }
    /**
     * \@docs-private
     * @return {?}
     */
    get currentStep() {
        if (this.count === 0 || this.selectedIndex === -1) {
            return null;
        }
        /** @type {?} */
        const steps = this._steps.toArray();
        return steps[this.selectedIndex];
    }
    /**
     * \@docs-private
     * @return {?}
     */
    get nextStep() {
        if (this.selectedIndex + 1 >= this._steps.length) {
            return null;
        }
        return this._steps.toArray()[this.selectedIndex + 1];
    }
    /**
     * \@docs-private
     * @return {?}
     */
    get steps() {
        return this._steps;
    }
    /**
     * \@docs-private
     * @return {?}
     */
    get currentLabel() {
        /** @type {?} */
        const step = this.currentStep;
        /** @type {?} */
        const label = step.stepLabel || step.label;
        return `${this.currentStepLabel} ${this.selectedIndex + 1}/${this.count}: ${label}`;
    }
}
NxProgressStepperDirective.decorators = [
    { type: Directive, args: [{
                selector: '[nxProgressStepper]',
                exportAs: 'nxProgressStepper',
            },] }
];
/** @nocollapse */
NxProgressStepperDirective.ctorParameters = () => [
    { type: ChangeDetectorRef },
    { type: Directionality },
    { type: ElementRef },
    { type: undefined, decorators: [{ type: Inject, args: [DOCUMENT,] }] }
];
NxProgressStepperDirective.propDecorators = {
    _steps: [{ type: ContentChildren, args: [NxStepComponent, { descendants: true },] }],
    currentStepLabel: [{ type: Input }],
    title: [{ type: Input }]
};
if (false) {
    /** @type {?} */
    NxProgressStepperDirective.prototype._steps;
    /** @type {?} */
    NxProgressStepperDirective.prototype._stepHeader;
    /**
     * Sets the label on the left side showing the current step label. Used for mobile viewports.
     * @type {?}
     */
    NxProgressStepperDirective.prototype.currentStepLabel;
    /**
     * Sets the title to be rendered above the progress bar.
     * \@deletion-target 10.0.0
     * @deprecated Use `nx-label` instead
     * @type {?}
     */
    NxProgressStepperDirective.prototype.title;
    /**
     * @type {?}
     * @private
     */
    NxProgressStepperDirective.prototype._cdRef;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicHJvZ3Jlc3Mtc3RlcHBlci5jb21wb25lbnQuanMiLCJzb3VyY2VSb290Ijoibmc6Ly9AYWxsaWFuei9uZ3gtbmRieC9wcm9ncmVzcy1zdGVwcGVyLyIsInNvdXJjZXMiOlsicHJvZ3Jlc3Mtc3RlcHBlci5jb21wb25lbnQudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQSxPQUFPLEVBQUUsUUFBUSxFQUFFLE1BQU0saUJBQWlCLENBQUM7QUFDM0MsT0FBTyxFQUFFLE9BQU8sRUFBRSxVQUFVLEVBQUUsTUFBTSxzQkFBc0IsQ0FBQztBQUMzRCxPQUFPLEVBRUwsdUJBQXVCLEVBQ3ZCLFNBQVMsRUFDVCxlQUFlLEVBQ2YsU0FBUyxFQUNULFVBQVUsRUFDVixNQUFNLEVBQ04sS0FBSyxFQUNMLFNBQVMsRUFDVCxRQUFRLEVBRVIsVUFBVSxFQUNWLGlCQUFpQixFQUNsQixNQUFNLGVBQWUsQ0FBQztBQUN2QixPQUFPLEVBQUUsU0FBUyxFQUFFLFNBQVMsRUFBRSxNQUFNLGdCQUFnQixDQUFDO0FBQ3RELE9BQU8sRUFBRSxpQkFBaUIsRUFBRSxNQUFNLHlCQUF5QixDQUFDO0FBRTVELE9BQU8sRUFBRSxPQUFPLEVBQWdCLE1BQU0sTUFBTSxDQUFDO0FBQzdDLE9BQU8sRUFBRSxjQUFjLEVBQUUsTUFBTSxtQkFBbUIsQ0FBQzs7Ozs7QUFnQm5ELE1BQU0sT0FBTyxlQUFnQixTQUFRLE9BQU87Ozs7O0lBRzFDLFlBQ2tFLE9BQW1DLEVBQzdFLGtCQUFxQztRQUMzRCxLQUFLLENBQUMsT0FBTyxDQUFDLENBQUM7UUFGaUQsWUFBTyxHQUFQLE9BQU8sQ0FBNEI7UUFDN0UsdUJBQWtCLEdBQWxCLGtCQUFrQixDQUFtQjtRQUo3RCxlQUFVLEdBQXFCLElBQUksT0FBTyxFQUFFLENBQUM7UUF5Q3JDLGdCQUFXLEdBQVksS0FBSyxDQUFDO0lBbkNyQyxDQUFDOzs7OztJQUVELElBQUksV0FBVyxDQUFDLEtBQVU7UUFDeEIsSUFBSSxDQUFDLFlBQVksR0FBRyxL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QUNuQyxPQUFPLEtBQUssQ0FBQyxJQUFJLENBQUMsYUFBYSxDQUFDLENBQUM7SUFDbkMsQ0FBQzs7Ozs7SUFHRCxJQUFJLFFBQVE7UUFDVixJQUFJLElBQUksQ0FBQyxhQUFhLEdBQUcsQ0FBQyxJQUFJLElBQUksQ0FBQyxNQUFNLENBQUMsTUFBTSxFQUFFO1lBQ2hELE9BQU8sSUFBSSxDQUFDO1NBQ2I7UUFFRCxPQUFPLElBQUksQ0FBQyxNQUFNLENBQUMsT0FBTyxFQUFFLENBQUMsSUFBSSxDQUFDLGFBQWEsR0FBRyxDQUFDLENBQUMsQ0FBQztJQUN2RCxDQUFDOzs7OztJQUdELElBQUksS0FBSztRQUNQLE9BQU8sSUFBSSxDQUFDLE1BQU0sQ0FBQztJQUNyQixDQUFDOzs7OztJQUdELElBQUksWUFBWTs7Y0FDUixJQUFJLEdBQUcsSUFBSSxDQUFDLFdBQVc7O2NBQ3ZCLEtBQUssR0FBRyxJQUFJLENBQUMsU0FBUyxJQUFJLElBQUksQ0FBQyxLQUFLO1FBRTFDLE9BQU8sR0FBRyxJQUFJLENBQUMsZ0JBQWdCLElBQUksSUFBSSxDQUFDLGFBQWEsR0FBRyxDQUFDLElBQUksSUFBSSxDQUFDLEtBQUssS0FBSyxLQUFLLEVBQUUsQ0FBQztJQUN0RixDQUFDOzs7WUFoR0YsU0FBUyxTQUFDO2dCQUNULFFBQVEsRUFBRSxxQkFBcUI7Z0JBQy9CLFFBQVEsRUFBRSxtQkFBbUI7YUFDOUI7Ozs7WUF0RkMsaUJBQWlCO1lBTVYsY0FBYztZQVByQixVQUFVOzRDQTBHUCxNQUFNLFNBQUMsUUFBUTs7O3FCQWZqQixlQUFlLFNBQUMsZUFBZSxFQUFFLEVBQUUsV0FBVyxFQUFFLElBQUksRUFBRTsrQkFJdEQsS0FBSztvQkFLTCxLQUFLOzs7O0lBVE4sNENBQTRGOztJQUM1RixpREFBK0M7Ozs7O0lBRy9DLHNEQUFrQzs7Ozs7OztJQUtsQywyQ0FBdUI7Ozs7O0lBR3JCLDRDQUFpQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IERPQ1VNRU5UIH0gZnJvbSAnQGFuZ3VsYXIvY29tbW9uJztcbmltcG9ydCB7IENka1N0ZXAsIENka1N0ZXBwZXIgfSBmcm9tICdAYW5ndWxhci9jZGsvc3RlcHBlcic7XG5pbXBvcnQge1xuICBBZnRlckNvbnRlbnRJbml0LFxuICBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneSxcbiAgQ29tcG9uZW50LFxuICBDb250ZW50Q2hpbGRyZW4sXG4gIERpcmVjdGl2ZSxcbiAgZm9yd2FyZFJlZixcbiAgSW5qZWN0LFxuICBJbnB1dCxcbiAgUXVlcnlMaXN0LFxuICBTa2lwU2VsZixcbiAgT25EZXN0cm95LFxuICBFbGVtZW50UmVmLFxuICBDaGFuZ2VEZXRlY3RvclJlZlxufSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IHRha2VVbnRpbCwgdGFrZVdoaWxlIH0gZnJvbSAncnhqcy9vcGVyYXRvcnMnO1xuaW1wb3J0IHsgRXJyb3JTdGF0ZU1hdGNoZXIgfSBmcm9tICdAYWxsaWFuei9uZ3gtbmRieC91dGlscyc7XG5pbXBvcnQgeyBGb3JtQ29udHJvbCwgRm9ybUdyb3VwRGlyZWN0aXZlLCBOZ0Zvcm0gfSBmcm9tICdAYW5ndWxhci9mb3Jtcyc7XG5pbXBvcnQgeyBTdWJqZWN0LCBTdWJzY3JpcHRpb24gfSBmcm9tICdyeGpzJztcbmltcG9ydCB7IERpcmVjdGlvbmFsaXR5IH0gZnJvbSAnQGFuZ3VsYXIvY2RrL2JpZGknO1xuXG4vLyB0c2xpbnQ6ZGlzYWJsZTp1c2UtaW5wdXQtcHJvcGVydHktZGVjb3JhdG9yXG5cbi8vIFdlIG5lZWQgdG8gcmVmZXJlbmNlIHN0ZXBzIGluIHN0ZXBwZXIgYW5kIHN0ZXBwZXIgaW4gc3RlcHMuIFRvIHByZXZlbnQgY2lyY3VsYXIgZGVwZW5lZGVuY3kgZXJyb3JzXG4vLyBQcm92aWRlIGJvdGggY29tcG9uZW50cyBpbiBhIHNpbmdsZSBmaWxlLiBPdGhlcndpc2Ugd2Ugd291bGQgaGF2ZSB0byBpbnRyb2R1Y2UgaW50ZXJmYWNlL2Fic3RyYWN0IGNsYXNzZXNcbi8vIHNoYXJlZCBiZXR3ZWVuIGJvdGggaW1wbGVtZW50YXRpb25zLlxuXG5AQ29tcG9uZW50KHtcbiAgc2VsZWN0b3I6ICdueC1zdGVwJyxcbiAgdGVtcGxhdGVVcmw6ICdwcm9ncmVzcy1zdGVwcGVyLmNvbXBvbmVudC5odG1sJyxcbiAgZXhwb3J0QXM6ICdueFN0ZXAnLFxuICBwcm92aWRlcnM6IFt7cHJvdmlkZTogRXJyb3JTdGF0ZU1hdGNoZXIsIHVzZUV4aXN0aW5nOiBOeFN0ZXBDb21wb25lbnR9XSxcbiAgcHJlc2VydmVXaGl0ZXNwYWNlczogZmFsc2UsXG4gIGNoYW5nZURldGVjdGlvbjogQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuT25QdXNoLFxufSlcbmV4cG9ydCBjbGFzcyBOeFN0ZXBDb21wb25lbnQgZXh0ZW5kcyBDZGtTdGVwIGltcGxlbWVudHMgRXJyb3JTdGF0ZU1hdGNoZXIsIE9uRGVzdHJveSB7XG4gIF9kZXN0cm95ZWQ6IFN1YmplY3Q8Ym9vbGVhbj4gPSBuZXcgU3ViamVjdCgpO1xuXG4gIGNvbnN0cnVjdG9yKFxuICAgICAgQEluamVjdChmb3J3YXJkUmVmKCgpID0+IE54UHJvZ3Jlc3NTdGVwcGVyRGlyZWN0aXZlKSkgcHJpdmF0ZSBzdGVwcGVyOiBOeFByb2dyZXNzU3RlcHBlckRpcmVjdGl2ZSxcbiAgICAgIEBTa2lwU2VsZigpIHByaXZhdGUgX2Vycm9yU3RhdGVNYXRjaGVyOiBFcnJvclN0YXRlTWF0Y2hlcikge1xuICAgIHN1cGVyKHN0ZXBwZXIpO1xuICB9XG5cbiAgc2V0IHN0ZXBDb250cm9sKHZhbHVlOiBhbnkpIHtcbiAgICB0aGlzLl9zdGVwQ29udHJvbCA9IHZhbHVlO1xuXG4gICAgLy8gSWYgYSBzdGVwIGNvbnRyb2wgY2hhbmdlcyBpdHMgc3RhdGUsIHRoZSBzdGVwcGVyIG5lZWRzIHRvIHVwZGF0ZS5cbiAgICBpZiAodGhpcy5fc3RlcENvbnRyb2wpIHtcbiAgICAgIHRoaXMuX3N0ZXBDb250cm9sLnN0YXR1c0NoYW5nZXNcbiAgICAgICAgLnBpcGUoXG4gICAgICAgICAgdGFrZVVudGlsKHRoaXMuX2Rlc3Ryb3llZCksXG4gICAgICAgICAgdGFrZVdoaWxlKCgpID0+IHRoaXMuX3N0ZXBDb250cm9sID09PSB2YWx1ZSlcbiAgICAgICAgKVxuICAgICAgICAuc3Vic2NyaWJlKCgpID0+IHtcbiAgICAgICAgICB0aGlzLnN0ZXBwZXIuX3N0YXRlQ2hhbmdlZCgpO1xuICAgICAgICB9KTtcbiAgICB9XG4gIH1cbiAgLyoqIFRoZSB0b3AgbGV2ZWwgYWJzdHJhY3QgY29udHJvbCBvZiB0aGUgc3RlcC4gKi9cbiAgZ2V0IHN0ZXBDb250cm9sKCkge1xuICAgIHJldHVybiB0aGlzLl9zdGVwQ29udHJvbDtcbiAgfVxuICBwcml2YXRlIF9zdGVwQ29udHJvbDogYW55O1xuXG4gIHNldCBpbnRlcmFjdGVkKHZhbHVlOiBib29sZWFuKSB7XG4gICAgdGhpcy5faW50ZXJhY3RlZCA9IHZhbHVlO1xuXG4gICAgaWYgKHRoaXMuc3RlcHBlcikge1xuICAgICAgdGhpcy5zdGVwcGVyLl9zdGF0ZUNoYW5nZWQoKTtcbiAgICB9XG4gIH1cblxuICAvKiogV2hldGhlciB0aGUgdXNlciBoYXMgc2VlbiB0aGUgZXhwYW5kZWQgc3RlcCBjb250ZW50IG9yIG5vdC4gKi9cbiAgZ2V0IGludGVyYWN0ZWQoKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRoaXMuX2ludGVyYWN0ZWQ7XG4gIH1cbiAgcHJpdmF0ZSBfaW50ZXJhY3RlZDogYm9vbGVhbiA9IGZhbHNlO1xuXG4gIC8qKiBDdXN0b20gZXJyb3Igc3RhdGUgbWF0Y2hlciB0aGF0IGNoZWNrcyBmb3IgdmFsaWRpdHkgb2YgdGhlIHN0ZXAgZm9ybS4gKi9cbiAgaXNFcnJvclN0YXRlKGNvbnRyb2w6IEZvcm1Db250cm9sIHwgbnVsbCwgZm9ybTogRm9ybUdyb3VwRGlyZWN0aXZlIHwgTmdGb3JtIHwgbnVsbCk6IGJvb2xlYW4ge1xuICAgIGNvbnN0IG9yaWdpbmFsRXJyb3JTdGF0ZSA9IHRoaXMuX2Vycm9yU3RhdGVNYXRjaGVyLmlzRXJyb3JTdGF0ZShjb250cm9sLCBmb3JtKTtcblxuICAgIC8vIENoZWNrcyBmb3IgdGhlIHZhbGlkaXR5IG9mIGEgc3RlcCBmb3JtIHRoYXQgaXMgbm90IHN1Ym1pdHRlZCBvciB0b3VjaGVkLFxuICAgIC8vIGUuZyB3aGVuIHRoZSB1c2VyIGRpcmVjdGx5IGNsaWNrcyB0aGUgXCJuZXh0XCIgYnV0dG9uIG9yIGRpcmVjdGx5IG9uIHRoZSBzdGVwXG4gICAgY29uc3QgY3VzdG9tRXJyb3JTdGF0ZSA9ICEhKGNvbnRyb2wgJiYgY29udHJvbC5pbnZhbGlkICYmIHRoaXMuaW50ZXJhY3RlZCk7XG4gICAgcmV0dXJuIG9yaWdpbmFsRXJyb3JTdGF0ZSB8fCBjdXN0b21FcnJvclN0YXRlO1xuICB9XG5cbiAgbmdPbkRlc3Ryb3koKSB7XG4gICAgdGhpcy5fZGVzdHJveWVkLm5leHQodHJ1ZSk7XG4gICAgdGhpcy5fZGVzdHJveWVkLmNvbXBsZXRlKCk7XG4gIH1cbn1cblxuLyoqIEBkb2NzLXByaXZhdGUgKi9cbkBEaXJlY3RpdmUoe1xuICBzZWxlY3RvcjogJ1tueFByb2dyZXNzU3RlcHBlcl0nLFxuICBleHBvcnRBczogJ254UHJvZ3Jlc3NTdGVwcGVyJyxcbn0pXG5leHBvcnQgY2xhc3MgTnhQcm9ncmVzc1N0ZXBwZXJEaXJlY3RpdmUgZXh0ZW5kcyBDZGtTdGVwcGVyIGltcGxlbWVudHMgQWZ0ZXJDb250ZW50SW5pdCB7XG4gIC8vIERvIG5vdCBpbml0aWFsaXplIHdpdGggYW4gZW1wdHkgUXVlcnlMaXN0IG9yIHRoZSBoYXNOZXh0KCkgZnVuY3Rpb24gcHJvZHVjZXNcbiAgLy8gd3JvbmcgcmVzdWx0cyBvbiBpbml0XG4gIEBDb250ZW50Q2hpbGRyZW4oTnhTdGVwQ29tcG9uZW50LCB7IGRlc2NlbmRhbnRzOiB0cnVlIH0pIF9zdGVwczogUXVlcnlMaXN0PE54U3RlcENvbXBvbmVudD47XG4gIF9zdGVwSGVhZGVyOiBRdWVyeUxpc3Q8bnVsbD4gPSBuZXcgUXVlcnlMaXN0KCk7XG5cbiAgLyoqIFNldHMgdGhlIGxhYmVsIG9uIHRoZSBsZWZ0IHNpZGUgc2hvd2luZyB0aGUgY3VycmVudCBzdGVwIGxhYmVsLiBVc2VkIGZvciBtb2JpbGUgdmlld3BvcnRzLiAqL1xuICBASW5wdXQoKSBjdXJyZW50U3RlcExhYmVsOiBzdHJpbmc7XG5cbiAgLyoqIFNldHMgdGhlIHRpdGxlIHRvIGJlIHJlbmRlcmVkIGFib3ZlIHRoZSBwcm9ncmVzcyBiYXIuXG4gICAqIEBkZWxldGlvbi10YXJnZXQgMTAuMC4wXG4gICAqIEBkZXByZWNhdGVkIFVzZSBgbngtbGFiZWxgIGluc3RlYWQgKi9cbiAgQElucHV0KCkgdGl0bGU6IHN0cmluZztcblxuICBjb25zdHJ1Y3RvcihcbiAgICBwcml2YXRlIF9jZFJlZjogQ2hhbmdlRGV0ZWN0b3JSZWYsXG4gICAgX2RpcjogRGlyZWN0aW9uYWxpdHksXG4gICAgX2VsZW1lbnRSZWY6IEVsZW1lbnRSZWY8SFRNTEVsZW1lbnQ+LFxuICAgIEBJbmplY3QoRE9DVU1FTlQpIF9kb2N1bWVudD86IGFueSkge1xuICAgICAgc3VwZXIoX2RpciwgX2NkUmVmLCBfZWxlbWVudFJlZiwgX2RvY3VtZW50KTtcbiAgICB9XG5cbiAgbmdBZnRlckNvbnRlbnRJbml0KCkge1xuICAgIC8vIE1hcmsgdGhlIGNvbXBvbmVudCBmb3IgY2hhbmdlIGRldGVjdGlvbiB3aGVuZXZlciB0aGUgY29udGVudCBjaGlsZHJlbiBxdWVyeSBjaGFuZ2VzXG4gICAgdGhpcy5fc3RlcHMuY2hhbmdlc1xuICAgICAgLnBpcGUodGFrZVVudGlsKHRoaXMuX2Rlc3Ryb3llZCkpXG4gICAgICAuc3Vic2NyaWJlKCgpID0+IHtcbiAgICAgICAgdGhpcy5fc3RhdGVDaGFuZ2VkKCk7XG4gICAgICB9KTtcblxuICAgIC8vIElmIGEgc3RlcCBjb250cm9sIGNoYW5nZXMgaXRzIHN0YXRlLCB0aGUgc3RlcHBlciBuZWVkcyB0byB1cGRhdGUuXG4gICAgdGhpcy5fc3RlcHMuZmlsdGVyKHMgPT4gISFzLnN0ZXBDb250cm9sKVxuICAgICAgLmZvckVhY2goc3RlcCA9PiB7XG4gICAgICAgIHN0ZXAuc3RlcENvbnRyb2wuc3RhdHVzQ2hhbmdlc1xuICAgICAgICAgIC5waXBlKHRha2VVbnRpbChzdGVwLl9kZXN0cm95ZWQpKVxuICAgICAgICAgIC5zdWJzY3JpYmUoKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5fc3RhdGVDaGFuZ2VkKCk7XG4gICAgICAgICAgfSk7XG4gICAgICB9KTtcblxuICAgIC8vIHdlIG5lZWQgdG8gZGVmZXIgY2hhbmdlIGRldGVjdGlvbiB0aGF0IHRoZSBueFN0ZXBwZXJOZXh0IGFuZCBOeFN0ZXBwZXJQcmV2aW91cyBidXR0b25zXG4gICAgLy8gY2FuIHJ1biBjaGFuZ2UgZGV0ZWN0aW9uIGFnYWluLCBiZWNhdXNlIHRoZXkgYXJlIGluaXRpYWxpemVkIGJlZm9yZSB0aGUgc3RlcHBlciBjb250ZW50XG4gICAgUHJvbWlzZS5yZXNvbHZlKCkudGhlbigoKSA9PiB7XG4gICAgICB0aGlzLl9jZFJlZi5kZXRlY3RDaGFuZ2VzKCk7XG4gICAgfSk7XG4gIH1cblxuICAvKiogQGRvY3MtcHJpdmF0ZSAqL1xuICBnZXQgaGFzUHJldmlvdXMoKSB7XG4gICAgcmV0dXJuICh0aGlzLnNlbGVjdGVkSW5kZXggLSAxKSA+PSAwO1xuICB9XG5cbiAgLyoqIEBkb2NzLXByaXZhdGUgKi9cbiAgZ2V0IGhhc05leHQoKSB7XG4gICAgcmV0dXJuICh0aGlzLnNlbGVjdGVkSW5kZXggKyAxKSA8IHRoaXMuY291bnQ7XG4gIH1cblxuICAvKiogQGRvY3MtcHJpdmF0ZSAqL1xuICBnZXQgY291bnQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3N0ZXBzID8gdGhpcy5fc3RlcHMubGVuZ3RoIDogMDtcbiAgfVxuXG4gIC8qKiBAZG9jcy1wcml2YXRlICovXG4gIGdldCBjdXJyZW50U3RlcCgpOiBOeFN0ZXBDb21wb25lbnQgfCBudWxsIHtcbiAgICBpZiAodGhpcy5jb3VudCA9PT0gMCB8fCB0aGlzLnNlbGVjdGVkSW5kZXggPT09IC0xKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBjb25zdCBzdGVwcyA9IHRoaXMuX3N0ZXBzLnRvQXJyYXkoKTtcbiAgICByZXR1cm4gc3RlcHNbdGhpcy5zZWxlY3RlZEluZGV4XTtcbiAgfVxuXG4gIC8qKiBAZG9jcy1wcml2YXRlICovXG4gIGdldCBuZXh0U3RlcCgpOiBOeFN0ZXBDb21wb25lbnQgfCBudWxsIHtcbiAgICBpZiAodGhpcy5zZWxlY3RlZEluZGV4ICsgMSA+PSB0aGlzLl9zdGVwcy5sZW5ndGgpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLl9zdGVwcy50b0FycmF5KClbdGhpcy5zZWxlY3RlZEluZGV4ICsgMV07XG4gIH1cblxuICAvKiogQGRvY3MtcHJpdmF0ZSAqL1xuICBnZXQgc3RlcHMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3N0ZXBzO1xuICB9XG5cbiAgLyoqIEBkb2NzLXByaXZhdGUgKi9cbiAgZ2V0IGN1cnJlbnRMYWJlbCgpIHtcbiAgICBjb25zdCBzdGVwID0gdGhpcy5jdXJyZW50U3RlcDtcbiAgICBjb25zdCBsYWJlbCA9IHN0ZXAuc3RlcExhYmVsIHx8IHN0ZXAubGFiZWw7XG5cbiAgICByZXR1cm4gYCR7dGhpcy5jdXJyZW50U3RlcExhYmVsfSAke3RoaXMuc2VsZWN0ZWRJbmRleCArIDF9LyR7dGhpcy5jb3VudH06ICR7bGFiZWx9YDtcbiAgfVxufVxuIl19