/**
 * @fileoverview added by tsickle
 * Generated from: buttons.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import { CdkStepper, CdkStepperNext, CdkStepperPrevious } from '@angular/cdk/stepper';
import { ChangeDetectorRef, Directive } from '@angular/core';
import { NxProgressStepperDirective } from './progress-stepper.component';
// tslint:disable:use-input-property-decorator
export class NxStepperNextDirective extends CdkStepperNext {
    /**
     * @param {?} _stepper
     * @param {?} changeDetectorRef
     */
    constructor(_stepper, changeDetectorRef) {
        super(_stepper);
        this.changeDetectorRef = changeDetectorRef;
        /**
         * \@docs-private
         */
        this.disabled = false;
    }
    /**
     * Implemented to prevent changed after checked error after stepper init.
     * When the stepper initializes the directive is checked first before
     * the stepper can check its content thus it doesn't know about it's children yet
     * so _stepper.hasNext returns false and disables the buttons. In the same CD cycle
     * after the stepper has checked its contents the button needs to be enabled resulting
     * in the error.
     * @return {?}
     */
    ngDoCheck() {
        /** @type {?} */
        const stepper = (/** @type {?} */ ((/** @type {?} */ (this._stepper))));
        if (this.disabled !== !stepper.hasNext) {
            this.disabled = !stepper.hasNext;
            this.changeDetectorRef.markForCheck();
        }
    }
}
NxStepperNextDirective.decorators = [
    { type: Directive, args: [{
                selector: 'button[nxStepperNext]',
                host: {
                    '[type]': 'type',
                    '[disabled]': 'disabled'
                },
                inputs: ['type'],
                providers: [{ provide: CdkStepper, useExisting: NxProgressStepperDirective }]
            },] }
];
/** @nocollapse */
NxStepperNextDirective.ctorParameters = () => [
    { type: CdkStepper },
    { type: ChangeDetectorRef }
];
if (false) {
    /**
     * \@docs-private
     * @type {?}
     */
    NxStepperNextDirective.prototype.disabled;
    /**
     * @type {?}
     * @private
     */
    NxStepperNextDirective.prototype.changeDetectorRef;
}
export class NxStepperPreviousDirective extends CdkStepperPrevious {
    /**
     * @param {?} _stepper
     */
    constructor(_stepper) {
        super(_stepper);
    }
    /**
     * @return {?}
     */
    get stepper() {
        return (/** @type {?} */ (this._stepper));
    }
}
NxStepperPreviousDirective.decorators = [
    { type: Directive, args: [{
                selector: 'button[nxStepperPrevious]',
                host: {
                    '[type]': 'type',
                    '[disabled]': '!stepper.hasPrevious'
                },
                inputs: ['type'],
                providers: [{ provide: CdkStepper, useExisting: NxProgressStepperDirective }]
            },] }
];
/** @nocollapse */
NxStepperPreviousDirective.ctorParameters = () => [
    { type: CdkStepper }
];
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYnV0dG9ucy5qcyIsInNvdXJjZVJvb3QiOiJuZzovL0BhbGxpYW56L25neC1uZGJ4L3Byb2dyZXNzLXN0ZXBwZXIvIiwic291cmNlcyI6WyJidXR0b25zLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7O0FBQUEsT0FBTyxFQUFFLFVBQVUsRUFBRSxjQUFjLEVBQUUsa0JBQWtCLEVBQUUsTUFBTSxzQkFBc0IsQ0FBQztBQUN0RixPQUFPLEVBQUUsaUJBQWlCLEVBQUUsU0FBUyxFQUFXLE1BQU0sZUFBZSxDQUFDO0FBRXRFLE9BQU8sRUFBRSwwQkFBMEIsRUFBRSxNQUFNLDhCQUE4QixDQUFDOztBQWExRSxNQUFNLE9BQU8sc0JBQXVCLFNBQVEsY0FBYzs7Ozs7SUFLeEQsWUFBWSxRQUFvQixFQUFVLGlCQUFvQztRQUM1RSxLQUFLLENBQUMsUUFBUSxDQUFDLENBQUM7UUFEd0Isc0JBQWlCLEdBQWpCLGlCQUFpQixDQUFtQjs7OztRQUY5RSxhQUFRLEdBQUcsS0FBSyxDQUFDO0lBSWpCLENBQUM7Ozs7Ozs7Ozs7SUFVRCxTQUFTOztjQUNELE9BQU8sR0FBRyxtQkFBQSxtQkFBQSxJQUFJLENBQUMsUUFBUSxFQUFPLEVBQThCO1FBQ2xFLElBQUksSUFBSSxDQUFDLFFBQVEsS0FBSyxDQUFDLE9BQU8sQ0FBQyxPQUFPLEVBQUU7WUFDdEMsSUFBSSxDQUFDLFFBQVEsR0FBRyxDQUFDLE9BQU8sQ0FBQyxPQUFPLENBQUM7WUFDakMsSUFBSSxDQUFDLGlCQUFpQixDQUFDLFlBQVksRUFBRSxDQUFDO1NBQ3ZDO0lBQ0gsQ0FBQzs7O1lBaENGLFNBQVMsU0FBQztnQkFDVCxRQUFRLEVBQUUsdUJBQXVCO2dCQUNqQyxJQUFJLEVBQUU7b0JBQ0osUUFBUSxFQUFFLE1BQU07b0JBQ2hCLFlBQVksRUFBRSxVQUFVO2lCQUN6QjtnQkFDRCxNQUFNLEVBQUUsQ0FBQyxNQUFNLENBQUM7Z0JBQ2hCLFNBQVMsRUFBRSxDQUFDLEVBQUMsT0FBTyxFQUFFLFVBQVUsRUFBRSxXQUFXLEVBQUUsMEJBQTBCLEVBQUMsQ0FBQzthQUM1RTs7OztZQWZRLFVBQVU7WUFDVixpQkFBaUI7Ozs7Ozs7SUFrQnhCLDBDQUFpQjs7Ozs7SUFFaUIsbURBQTRDOztBQThCaEYsTUFBTSxPQUFPLDBCQUEyQixTQUFRLGtCQUFrQjs7OztJQUNoRSxZQUFZLFFBQW9CO1FBQzlCLEtBQUssQ0FBQyxRQUFRLENBQUMsQ0FBQztJQUNsQixDQUFDOzs7O0lBRUQsSUFBSSxPQUFPO1FBQ1QsT0FBTyxtQkFBQSxJQUFJLENBQUMsUUFBUSxFQUE4QixDQUFDO0lBQ3JELENBQUM7OztZQWhCRixTQUFTLFNBQUM7Z0JBQ1QsUUFBUSxFQUFFLDJCQUEyQjtnQkFDckMsSUFBSSxFQUFFO29CQUNKLFFBQVEsRUFBRSxNQUFNO29CQUNoQixZQUFZLEVBQUUsc0JBQXNCO2lCQUNyQztnQkFDRCxNQUFNLEVBQUUsQ0FBQyxNQUFNLENBQUM7Z0JBQ2hCLFNBQVMsRUFBRSxDQUFDLEVBQUMsT0FBTyxFQUFFLFVBQVUsRUFBRSxXQUFXLEVBQUUsMEJBQTBCLEVBQUMsQ0FBQzthQUM1RTs7OztZQWxEUSxVQUFVIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQ2RrU3RlcHBlciwgQ2RrU3RlcHBlck5leHQsIENka1N0ZXBwZXJQcmV2aW91cyB9IGZyb20gJ0Bhbmd1bGFyL2Nkay9zdGVwcGVyJztcbmltcG9ydCB7IENoYW5nZURldGVjdG9yUmVmLCBEaXJlY3RpdmUsIERvQ2hlY2sgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcblxuaW1wb3J0IHsgTnhQcm9ncmVzc1N0ZXBwZXJEaXJlY3RpdmUgfSBmcm9tICcuL3Byb2dyZXNzLXN0ZXBwZXIuY29tcG9uZW50JztcblxuLy8gdHNsaW50OmRpc2FibGU6dXNlLWlucHV0LXByb3BlcnR5LWRlY29yYXRvclxuXG5ARGlyZWN0aXZlKHtcbiAgc2VsZWN0b3I6ICdidXR0b25bbnhTdGVwcGVyTmV4dF0nLFxuICBob3N0OiB7XG4gICAgJ1t0eXBlXSc6ICd0eXBlJyxcbiAgICAnW2Rpc2FibGVkXSc6ICdkaXNhYmxlZCdcbiAgfSxcbiAgaW5wdXRzOiBbJ3R5cGUnXSxcbiAgcHJvdmlkZXJzOiBbe3Byb3ZpZGU6IENka1N0ZXBwZXIsIHVzZUV4aXN0aW5nOiBOeFByb2dyZXNzU3RlcHBlckRpcmVjdGl2ZX1dXG59KVxuZXhwb3J0IGNsYXNzIE54U3RlcHBlck5leHREaXJlY3RpdmUgZXh0ZW5kcyBDZGtTdGVwcGVyTmV4dCBpbXBsZW1lbnRzIERvQ2hlY2sge1xuXG4gIC8qKiBAZG9jcy1wcml2YXRlICovXG4gIGRpc2FibGVkID0gZmFsc2U7XG5cbiAgY29uc3RydWN0b3IoX3N0ZXBwZXI6IENka1N0ZXBwZXIsIHByaXZhdGUgY2hhbmdlRGV0ZWN0b3JSZWY6IENoYW5nZURldGVjdG9yUmVmKSB7XG4gICAgc3VwZXIoX3N0ZXBwZXIpO1xuICB9XG5cbiAgLyoqXG4gICAqIEltcGxlbWVudGVkIHRvIHByZXZlbnQgY2hhbmdlZCBhZnRlciBjaGVja2VkIGVycm9yIGFmdGVyIHN0ZXBwZXIgaW5pdC5cbiAgICogV2hlbiB0aGUgc3RlcHBlciBpbml0aWFsaXplcyB0aGUgZGlyZWN0aXZlIGlzIGNoZWNrZWQgZmlyc3QgYmVmb3JlXG4gICAqIHRoZSBzdGVwcGVyIGNhbiBjaGVjayBpdHMgY29udGVudCB0aHVzIGl0IGRvZXNuJ3Qga25vdyBhYm91dCBpdCdzIGNoaWxkcmVuIHlldFxuICAgKiBzbyBfc3RlcHBlci5oYXNOZXh0IHJldHVybnMgZmFsc2UgYW5kIGRpc2FibGVzIHRoZSBidXR0b25zLiBJbiB0aGUgc2FtZSBDRCBjeWNsZVxuICAgKiBhZnRlciB0aGUgc3RlcHBlciBoYXMgY2hlY2tlZCBpdHMgY29udGVudHMgdGhlIGJ1dHRvbiBuZWVkcyB0byBiZSBlbmFibGVkIHJlc3VsdGluZ1xuICAgKiBpbiB0aGUgZXJyb3IuXG4gICAqL1xuICBuZ0RvQ2hlY2soKSB7XG4gICAgY29uc3Qgc3RlcHBlciA9IHRoaXMuX3N0ZXBwZXIgYXMgYW55IGFzIE54UHJvZ3Jlc3NTdGVwcGVyRGlyZWN0aXZlO1xuICAgIGlmICh0aGlzLmRpc2FibGVkICE9PSAhc3RlcHBlci5oYXNOZXh0KSB7XG4gICAgICB0aGlzLmRpc2FibGVkID0gIXN0ZXBwZXIuaGFzTmV4dDtcbiAgICAgIHRoaXMuY2hhbmdlRGV0ZWN0b3JSZWYubWFya0ZvckNoZWNrKCk7XG4gICAgfVxuICB9XG59XG5cbkBEaXJlY3RpdmUoe1xuICBzZWxlY3RvcjogJ2J1dHRvbltueFN0ZXBwZXJQcmV2aW91c10nLFxuICBob3N0OiB7XG4gICAgJ1t0eXBlXSc6ICd0eXBlJyxcbiAgICAnW2Rpc2FibGVkXSc6ICchc3RlcHBlci5oYXNQcmV2aW91cydcbiAgfSxcbiAgaW5wdXRzOiBbJ3R5cGUnXSxcbiAgcHJvdmlkZXJzOiBbe3Byb3ZpZGU6IENka1N0ZXBwZXIsIHVzZUV4aXN0aW5nOiBOeFByb2dyZXNzU3RlcHBlckRpcmVjdGl2ZX1dXG59KVxuZXhwb3J0IGNsYXNzIE54U3RlcHBlclByZXZpb3VzRGlyZWN0aXZlIGV4dGVuZHMgQ2RrU3RlcHBlclByZXZpb3VzIHtcbiAgY29uc3RydWN0b3IoX3N0ZXBwZXI6IENka1N0ZXBwZXIpIHtcbiAgICBzdXBlcihfc3RlcHBlcik7XG4gIH1cblxuICBnZXQgc3RlcHBlcigpOiBOeFByb2dyZXNzU3RlcHBlckRpcmVjdGl2ZSB7XG4gICAgcmV0dXJuIHRoaXMuX3N0ZXBwZXIgYXMgTnhQcm9ncmVzc1N0ZXBwZXJEaXJlY3RpdmU7XG4gIH1cblxufVxuIl19