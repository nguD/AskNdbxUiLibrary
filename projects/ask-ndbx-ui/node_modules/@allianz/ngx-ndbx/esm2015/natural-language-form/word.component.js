/**
 * @fileoverview added by tsickle
 * Generated from: natural-language-form/word.component.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import { NxFormfieldControl, NxFormfieldErrorDirective } from '@allianz/ngx-ndbx/formfield';
import { getFontShorthand } from '@allianz/ngx-ndbx/utils';
import { Overlay, OverlayConfig, OverlayPositionBuilder } from '@angular/cdk/overlay';
import { ChangeDetectionStrategy, ChangeDetectorRef, Component, ContentChild, ContentChildren, ElementRef, HostBinding, Input, QueryList, Renderer2, ViewChild, ViewContainerRef } from '@angular/core';
import { startWith } from 'rxjs/operators';
import { Subject, Subscription } from 'rxjs';
import { NxPopoverComponent } from '@allianz/ngx-ndbx/popover';
import { NxDropdownComponent } from '@allianz/ngx-ndbx/dropdown';
import { TemplatePortal } from '@angular/cdk/portal';
export class NxWordComponent {
    /**
     * @param {?} elementRef
     * @param {?} _changeDetectorRef
     * @param {?} _renderer
     * @param {?} _overlay
     * @param {?} _viewContainerRef
     * @param {?} _overlayPositionBuilder
     */
    constructor(elementRef, _changeDetectorRef, _renderer, _overlay, _viewContainerRef, _overlayPositionBuilder) {
        this.elementRef = elementRef;
        this._changeDetectorRef = _changeDetectorRef;
        this._renderer = _renderer;
        this._overlay = _overlay;
        this._viewContainerRef = _viewContainerRef;
        this._overlayPositionBuilder = _overlayPositionBuilder;
        this.subscription = Subscription.EMPTY;
        this.subscriptionValues = Subscription.EMPTY;
        /**
         * \@docs-private
         */
        this.inputChanges = new Subject();
        this._hasErrors = false;
        /**
         * \@docs-private
         */
        this.currentTextWidth = 0;
        // this will apply different min-widths to our component through our styles
        /**
         * Provide a hint for a minimal width. The actual size will be determined for inputs for each change.
         */
        this.size = 'regular';
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.setupErrorPopover();
    }
    /**
     * @return {?}
     */
    ngAfterContentInit() {
        this._validateControlChild();
        this.subscription = this._control.stateChanges.pipe(startWith(null)).subscribe((/**
         * @return {?}
         */
        () => {
            this._hasErrors = this._control.errorState;
            this.updateErrorPopoverState();
            this._changeDetectorRef.markForCheck();
        }));
        // if we have a ngcontrol available stick to its valueChanges subject
        if (this._control.ngControl) {
            this.subscriptionValues = this._control.ngControl.valueChanges.subscribe((/**
             * @param {?} value
             * @return {?}
             */
            value => {
                this.updateCurrentTextWidth();
                this.inputChanges.next();
            }));
            // in any other case it is a bre input and input changes are signaled through simple state changes
        }
        else {
            this.subscriptionValues = this._control.stateChanges.subscribe((/**
             * @param {?} value
             * @return {?}
             */
            value => {
                this.updateCurrentTextWidth();
                this.inputChanges.next();
            }));
        }
        this._control.setAriaLabel(this.label);
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this.subscription.unsubscribe();
    }
    /**
     * \@docs-private
     * Calculate the width of the full text given by the input,
     * that value is bound to this component so it can grow.
     * The involved input is known to have a width of 100% an will fit the additional space given
     * which completes the auto growing behavior.
     * @return {?}
     */
    updateCurrentTextWidth() {
        // provide the canvas only lazy
        if (!this.measureCanvas) {
            this.measureCanvas = this._renderer.createElement('canvas');
        }
        /** @type {?} */
        const ctx = this.measureCanvas.getContext('2d');
        /** @type {?} */
        const inputRef = this._control.elementRef;
        /** @type {?} */
        const styles = window.getComputedStyle(inputRef.nativeElement);
        ctx.font = getFontShorthand(styles);
        /** @type {?} */
        const metrics = ctx.measureText(this._control.value);
        // add 1px (cursor width) to prevent jumping of the text on blur.
        /** @type {?} */
        const newWidth = metrics.width + parseInt(styles.paddingRight, 10) + parseInt(styles.paddingLeft, 10) + 1;
        // This should be injected via @Host to get an exact reference to NxNaturalLanguageFormComponent
        // Works as promised as long as there is not other tag around the word. Not expected but possible.
        /** @type {?} */
        const parent = this.elementRef.nativeElement.parentElement;
        /** @type {?} */
        const parentMeasurement = parent.getBoundingClientRect();
        // Limit to own given minimal width
        this.currentTextWidth = Math.max(parseInt(styles.minWidth, 10), newWidth);
        // Limit to container width
        this.currentTextWidth = Math.min(this.currentTextWidth, parentMeasurement.width);
        if (this._overlayRef.hasAttached()) {
            this._overlayState.positionStrategy.apply();
        }
    }
    /**
     * \@docs-private
     * @return {?}
     */
    repositionError() {
        if (this._overlayRef.hasAttached()) {
            this._overlayState.positionStrategy.apply();
        }
    }
    // Fail if the required control is missing.
    /**
     * @protected
     * @return {?}
     */
    _validateControlChild() {
        if (!this._control) {
            throw new Error('NxWordComponent requires an NxFormfieldControl compatible input.');
        }
    }
    /**
     * \@docs-private
     * @return {?}
     */
    getConnectedOverlayOrigin() {
        return this.elementRef;
    }
    /**
     * \@docs-private
     * @return {?}
     */
    get isFocused() {
        return this._control.focused;
    }
    /**
     * \@docs-private
     * @return {?}
     */
    get isFilled() {
        return !this._control.empty;
    }
    /**
     * \@docs-private
     * @return {?}
     */
    get hasDropdown() {
        return Boolean(this._dropdown);
    }
    /**
     * @return {?}
     */
    updateErrorPopoverState() {
        if (this._hasErrors && this._errorChildren.length > 0) {
            this.showPopover();
        }
        else {
            this.hidePopover();
        }
    }
    /**
     * @return {?}
     */
    setupErrorPopover() {
        /** @type {?} */
        const positionStrategy = this._overlayPositionBuilder
            .flexibleConnectedTo(this.elementRef)
            .withLockedPosition(true)
            .withFlexibleDimensions(false)
            .withPush(true)
            .withPositions([{
                originX: 'center',
                originY: 'top',
                overlayX: 'center',
                overlayY: 'bottom'
            },
            {
                originX: 'center',
                originY: 'bottom',
                overlayX: 'center',
                overlayY: 'top'
            }])
            .withDefaultOffsetY(-8);
        this._overlayState = new OverlayConfig();
        this._overlayState.positionStrategy = positionStrategy;
        this._overlayState.scrollStrategy = this._overlay.scrollStrategies.reposition();
        this._overlayRef = this._overlay.create(this._overlayState);
        ((/** @type {?} */ (this._overlayState.positionStrategy))).positionChanges.subscribe((/**
         * @param {?} change
         * @return {?}
         */
        change => {
            /** @type {?} */
            const pair = change.connectionPair;
            this.positionArrow(pair);
            // These position changes arrive too late,
            // We have to trigger the change detection manually
            // as it's detached from any render hierarchy
            // and only updated by the overlay when attached.
            if (this._embeddedViewRef && !this._embeddedViewRef.destroyed) {
                this._embeddedViewRef.detectChanges();
            }
        }));
    }
    /**
     * @private
     * @param {?} pair
     * @return {?}
     */
    positionArrow(pair) {
        /** @type {?} */
        const parentElementPositionX = this.elementRef.nativeElement.getBoundingClientRect().left;
        /** @type {?} */
        const parentElementWidth = this.elementRef.nativeElement.getBoundingClientRect().width / 2;
        /** @type {?} */
        const parentElementLeftOffset = this._overlayRef.overlayElement.parentElement.offsetLeft;
        /** @type {?} */
        const overlayElementLeftOffset = this._overlayRef.overlayElement.offsetLeft;
        // calculation for x position of the parent element. In this case, overlay left offset is the one thing to consider.
        /** @type {?} */
        const targetPosition = (parentElementPositionX + parentElementWidth) - (parentElementLeftOffset + overlayElementLeftOffset);
        if (pair.originY === 'top' && pair.overlayY === 'bottom') {
            this._popover.direction = 'top';
        }
        else {
            this._popover.direction = 'bottom';
        }
        this._popover.arrowStyle = { left: targetPosition + 'px' };
    }
    /**
     * @return {?}
     */
    showPopover() {
        if (!this._overlayRef.hasAttached()) {
            /** @type {?} */
            const tooltipPortal = new TemplatePortal(this._popover.templateRef, this._viewContainerRef);
            this._embeddedViewRef = this._overlayRef.attach(tooltipPortal);
        }
    }
    /**
     * @return {?}
     */
    hidePopover() {
        this._overlayRef.detach();
    }
}
NxWordComponent.decorators = [
    { type: Component, args: [{
                selector: 'nx-word',
                template: "<div>\n  <!-- We only allow formfield controls here -->\n  <div *ngIf=\"!hasDropdown\" class=\"nx-word__inner-wrapper\">\n    <ng-content select=\"[nxInput]\"></ng-content>\n  </div>\n  <ng-content select=\"nx-dropdown\"></ng-content>\n</div>\n\n<nx-popover #popover>\n  <ng-content select=\"[nxError]\"></ng-content>\n</nx-popover>",
                host: {
                    '[class.size-short]': 'size == "short"',
                    '[class.size-regular]': 'size == "regular"',
                    '[class.size-long]': 'size == "long"',
                    '[class.has-error]': '_hasErrors',
                    '[class.is-focused]': 'isFocused',
                    '[class.is-filled]': 'isFilled',
                    '[class.has-dropdown]': 'hasDropdown',
                },
                changeDetection: ChangeDetectionStrategy.OnPush,
                styles: [":host{display:inline-block;position:relative;font-weight:400;text-align:center;-webkit-hyphens:none;-ms-hyphens:none;hyphens:none;width:100%;margin:0 4px}:host .nx-word__inner-wrapper{border-bottom:2px solid #d9d9d9}:host.size-short{min-width:80px}:host.size-regular{min-width:152px}:host.size-long{min-width:360px}@media (max-width:991px){:host.size-long{min-width:280px}}@media (max-width:703px){:host.size-long{min-width:248px}}:host ::ng-deep .c-input{display:inline-block;text-align:inherit;font-size:inherit;line-height:inherit;background:0 0;color:inherit;border:none;outline:0;margin:0;width:100%;max-width:100%;height:auto;box-shadow:none;padding:0 8px}:host ::ng-deep .c-input.is-focused{outline:0;box-shadow:none}:host ::ng-deep .c-input.is-filled,:host ::ng-deep .c-input.is-focused{color:#006192;color:var(--natural-language-form-active-color,#006192);font-weight:400}:host ::ng-deep .c-input.is-disabled{cursor:not-allowed}:host ::ng-deep .c-input::-ms-clear{display:none}:host ::ng-deep nx-dropdown{position:relative;border-bottom:2px solid #d9d9d9}:host ::ng-deep nx-dropdown .nx-dropdown__container{font-size:inherit;margin-bottom:-2px}:host ::ng-deep nx-dropdown.has-focus,:host ::ng-deep nx-dropdown.is-filled{color:#006192;color:var(--natural-language-form-active-color,#006192);border-color:#007ab3;border-color:var(--natural-language-form-active-border-color,#007ab3)}:host ::ng-deep nx-dropdown .nx-dropdown__icon{line-height:inherit}:host ::ng-deep .nx-word__input-wrapper{width:100%}:host(.is-filled) .nx-word__inner-wrapper,:host(.is-focused) .nx-word__inner-wrapper{border-color:#007ab3;border-color:var(--natural-language-form-active-border-color,#007ab3)}:host(.has-error) .nx-word__inner-wrapper{border-color:#dc3149;border-color:var(--natural-language-form-error-border-color,#dc3149)}:host.has-error ::ng-deep nx-dropdown{color:#dc3149;color:var(--natural-language-form-error-color,#dc3149);border-color:#dc3149;border-color:var(--natural-language-form-error-border-color,#dc3149)}:host.has-error ::ng-deep .c-input.has-error{color:#dc3149;color:var(--natural-language-form-error-color,#dc3149)}:host-context(.is-negative) ::ng-deep .nx-dropdown,:host-context(.is-negative) ::ng-deep nx-dropdown,:host-context(.is-negative) ::ng-deep nx-dropdown.is-filled{border-color:#fff;color:#fff}:host-context(.is-negative) ::ng-deep .c-input,:host-context(.is-negative) ::ng-deep .c-input.has-error{color:#fff}:host-context(.is-negative) .nx-word__inner-wrapper{border-color:#fff}.nx-word__inner-wrapper{height:52px;height:var(--natural-language-form-large-line-height,52px)}@media (max-width:991px){:host ::ng-deep nx-dropdown .nx-dropdown__container{font-size:26px}.nx-word__inner-wrapper{height:36px;height:var(--natural-language-form-small-line-height,36px)}}:host-context(.nx-natural-language-form--small) .nx-word__inner-wrapper{height:36px;height:var(--natural-language-form-small-line-height,36px)}@media screen and (-ms-high-contrast:active){.nx-word__inner-wrapper,::ng-deep nx-dropdown{border-bottom-color:buttonText}}"]
            }] }
];
/** @nocollapse */
NxWordComponent.ctorParameters = () => [
    { type: ElementRef },
    { type: ChangeDetectorRef },
    { type: Renderer2 },
    { type: Overlay },
    { type: ViewContainerRef },
    { type: OverlayPositionBuilder }
];
NxWordComponent.propDecorators = {
    _control: [{ type: ContentChild, args: [NxFormfieldControl, { static: false },] }],
    _errorChildren: [{ type: ContentChildren, args: [NxFormfieldErrorDirective,] }],
    _popover: [{ type: ViewChild, args: ['popover', { static: true },] }],
    _dropdown: [{ type: ContentChild, args: [NxDropdownComponent, { static: false },] }],
    currentTextWidth: [{ type: HostBinding, args: ['style.width.px',] }],
    size: [{ type: Input, args: ['nxSize',] }],
    label: [{ type: Input, args: ['nxLabel',] }]
};
if (false) {
    /**
     * @type {?}
     * @private
     */
    NxWordComponent.prototype.subscription;
    /**
     * @type {?}
     * @private
     */
    NxWordComponent.prototype.subscriptionValues;
    /**
     * @type {?}
     * @private
     */
    NxWordComponent.prototype.measureCanvas;
    /**
     * \@docs-private
     * @type {?}
     */
    NxWordComponent.prototype.inputChanges;
    /** @type {?} */
    NxWordComponent.prototype._hasErrors;
    /**
     * @type {?}
     * @private
     */
    NxWordComponent.prototype._overlayRef;
    /**
     * @type {?}
     * @private
     */
    NxWordComponent.prototype._embeddedViewRef;
    /**
     * @type {?}
     * @private
     */
    NxWordComponent.prototype._overlayState;
    /** @type {?} */
    NxWordComponent.prototype._control;
    /** @type {?} */
    NxWordComponent.prototype._errorChildren;
    /** @type {?} */
    NxWordComponent.prototype._popover;
    /** @type {?} */
    NxWordComponent.prototype._dropdown;
    /**
     * \@docs-private
     * @type {?}
     */
    NxWordComponent.prototype.currentTextWidth;
    /**
     * Provide a hint for a minimal width. The actual size will be determined for inputs for each change.
     * @type {?}
     */
    NxWordComponent.prototype.size;
    /**
     * A word doesn't have a set place to show labels.
     * In order to be accessible, you have to provide a label with this property.
     * It will be attached to the given input through `aria-label`.
     * @type {?}
     */
    NxWordComponent.prototype.label;
    /**
     * \@docs-private
     * @type {?}
     */
    NxWordComponent.prototype.elementRef;
    /**
     * @type {?}
     * @private
     */
    NxWordComponent.prototype._changeDetectorRef;
    /**
     * @type {?}
     * @private
     */
    NxWordComponent.prototype._renderer;
    /**
     * @type {?}
     * @private
     */
    NxWordComponent.prototype._overlay;
    /**
     * @type {?}
     * @private
     */
    NxWordComponent.prototype._viewContainerRef;
    /**
     * @type {?}
     * @private
     */
    NxWordComponent.prototype._overlayPositionBuilder;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoid29yZC5jb21wb25lbnQuanMiLCJzb3VyY2VSb290Ijoibmc6Ly9AYWxsaWFuei9uZ3gtbmRieC8iLCJzb3VyY2VzIjpbIm5hdHVyYWwtbGFuZ3VhZ2UtZm9ybS93b3JkLmNvbXBvbmVudC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7OztBQUFBLE9BQU8sRUFBRSxrQkFBa0IsRUFBRSx5QkFBeUIsRUFBRSxNQUFNLDZCQUE2QixDQUFDO0FBQzVGLE9BQU8sRUFBRSxnQkFBZ0IsRUFBRSxNQUFNLHlCQUF5QixDQUFDO0FBQzNELE9BQU8sRUFBRSxPQUFPLEVBQUUsYUFBYSxFQUFFLHNCQUFzQixFQUNrQixNQUFNLHNCQUFzQixDQUFDO0FBQ3RHLE9BQU8sRUFFTCx1QkFBdUIsRUFDdkIsaUJBQWlCLEVBQ2pCLFNBQVMsRUFDVCxZQUFZLEVBQ1osZUFBZSxFQUNmLFVBQVUsRUFDVixXQUFXLEVBQ1gsS0FBSyxFQUVMLFNBQVMsRUFDVCxTQUFTLEVBQ1QsU0FBUyxFQUNULGdCQUFnQixFQUdqQixNQUFNLGVBQWUsQ0FBQztBQUN2QixPQUFPLEVBQUUsU0FBUyxFQUFFLE1BQU0sZ0JBQWdCLENBQUM7QUFDM0MsT0FBTyxFQUFFLE9BQU8sRUFBSSxZQUFZLEVBQUUsTUFBTSxNQUFNLENBQUM7QUFFL0MsT0FBTyxFQUFFLGtCQUFrQixFQUFFLE1BQU0sMkJBQTJCLENBQUM7QUFDL0QsT0FBTyxFQUFFLG1CQUFtQixFQUFFLE1BQU0sNEJBQTRCLENBQUM7QUFDakUsT0FBTyxFQUFFLGNBQWMsRUFBRSxNQUFNLHFCQUFxQixDQUFDO0FBd0JyRCxNQUFNLE9BQU8sZUFBZTs7Ozs7Ozs7O0lBaUMxQixZQUVTLFVBQXNCLEVBQ3JCLGtCQUFxQyxFQUNyQyxTQUFvQixFQUNwQixRQUFpQixFQUNqQixpQkFBbUMsRUFDbkMsdUJBQStDO1FBTGhELGVBQVUsR0FBVixVQUFVLENBQVk7UUFDckIsdUJBQWtCLEdBQWxCLGtCQUFrQixDQUFtQjtRQUNyQyxjQUFTLEdBQVQs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QWUsU0FBQyx5QkFBeUI7dUJBQ3pDLFNBQVMsU0FBQyxTQUFTLEVBQUUsRUFBRSxNQUFNLEVBQUUsSUFBSSxFQUFFO3dCQUNyQyxZQUFZLFNBQUMsbUJBQW1CLEVBQUUsRUFBQyxNQUFNLEVBQUUsS0FBSyxFQUFDOytCQUdqRCxXQUFXLFNBQUMsZ0JBQWdCO21CQUs1QixLQUFLLFNBQUMsUUFBUTtvQkFPZCxLQUFLLFNBQUMsU0FBUzs7Ozs7OztJQTlCaEIsdUNBQXdEOzs7OztJQUN4RCw2Q0FBOEQ7Ozs7O0lBQzlELHdDQUF5Qzs7Ozs7SUFHekMsdUNBQWtDOztJQUVsQyxxQ0FBNEI7Ozs7O0lBQzVCLHNDQUFnQzs7Ozs7SUFDaEMsMkNBQStDOzs7OztJQUMvQyx3Q0FBcUM7O0lBRXJDLG1DQUFxRjs7SUFDckYseUNBQWlHOztJQUNqRyxtQ0FBcUU7O0lBQ3JFLG9DQUFtRjs7Ozs7SUFHbkYsMkNBQzZCOzs7OztJQUk3QiwrQkFBeUM7Ozs7Ozs7SUFPekMsZ0NBQWdDOzs7OztJQUk5QixxQ0FBNkI7Ozs7O0lBQzdCLDZDQUE2Qzs7Ozs7SUFDN0Msb0NBQTRCOzs7OztJQUM1QixtQ0FBeUI7Ozs7O0lBQ3pCLDRDQUEyQzs7Ozs7SUFDM0Msa0RBQXVEIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgTnhGb3JtZmllbGRDb250cm9sLCBOeEZvcm1maWVsZEVycm9yRGlyZWN0aXZlIH0gZnJvbSAnQGFsbGlhbnovbmd4LW5kYngvZm9ybWZpZWxkJztcbmltcG9ydCB7IGdldEZvbnRTaG9ydGhhbmQgfSBmcm9tICdAYWxsaWFuei9uZ3gtbmRieC91dGlscyc7XG5pbXBvcnQgeyBPdmVybGF5LCBPdmVybGF5Q29uZmlnLCBPdmVybGF5UG9zaXRpb25CdWlsZGVyLFxuICBPdmVybGF5UmVmLCBGbGV4aWJsZUNvbm5lY3RlZFBvc2l0aW9uU3RyYXRlZ3ksIENvbm5lY3Rpb25Qb3NpdGlvblBhaXIgfSBmcm9tICdAYW5ndWxhci9jZGsvb3ZlcmxheSc7XG5pbXBvcnQge1xuICBBZnRlckNvbnRlbnRJbml0LFxuICBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneSxcbiAgQ2hhbmdlRGV0ZWN0b3JSZWYsXG4gIENvbXBvbmVudCxcbiAgQ29udGVudENoaWxkLFxuICBDb250ZW50Q2hpbGRyZW4sXG4gIEVsZW1lbnRSZWYsXG4gIEhvc3RCaW5kaW5nLFxuICBJbnB1dCxcbiAgT25EZXN0cm95LFxuICBRdWVyeUxpc3QsXG4gIFJlbmRlcmVyMixcbiAgVmlld0NoaWxkLFxuICBWaWV3Q29udGFpbmVyUmVmLFxuICBFbWJlZGRlZFZpZXdSZWYsXG4gIE9uSW5pdFxufSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IHN0YXJ0V2l0aCB9IGZyb20gJ3J4anMvb3BlcmF0b3JzJztcbmltcG9ydCB7IFN1YmplY3QgLCAgU3Vic2NyaXB0aW9uIH0gZnJvbSAncnhqcyc7XG5cbmltcG9ydCB7IE54UG9wb3ZlckNvbXBvbmVudCB9IGZyb20gJ0BhbGxpYW56L25neC1uZGJ4L3BvcG92ZXInO1xuaW1wb3J0IHsgTnhEcm9wZG93bkNvbXBvbmVudCB9IGZyb20gJ0BhbGxpYW56L25neC1uZGJ4L2Ryb3Bkb3duJztcbmltcG9ydCB7IFRlbXBsYXRlUG9ydGFsIH0gZnJvbSAnQGFuZ3VsYXIvY2RrL3BvcnRhbCc7XG5cbi8qKiBUeXBlIHRvIGRldGVybWluZSB0aGUgbWluaW1hbCB3aWR0aCBvZiBhIHdvcmQuICovXG5leHBvcnQgdHlwZSBTSVpFUyA9ICdyZWd1bGFyJyB8ICdzaG9ydCcgfCAnbG9uZyc7XG5cbkBDb21wb25lbnQoe1xuICBzZWxlY3RvcjogJ254LXdvcmQnLFxuICB0ZW1wbGF0ZVVybDogJ3dvcmQuY29tcG9uZW50Lmh0bWwnLFxuICBzdHlsZVVybHM6IFtcbiAgICAnd29yZC5jb21wb25lbnQuc2NzcydcbiAgXSxcbiAgaG9zdDoge1xuICAgICdbY2xhc3Muc2l6ZS1zaG9ydF0nOiAnc2l6ZSA9PSBcInNob3J0XCInLFxuICAgICdbY2xhc3Muc2l6ZS1yZWd1bGFyXSc6ICdzaXplID09IFwicmVndWxhclwiJyxcbiAgICAnW2NsYXNzLnNpemUtbG9uZ10nOiAnc2l6ZSA9PSBcImxvbmdcIicsXG4gICAgJ1tjbGFzcy5oYXMtZXJyb3JdJzogJ19oYXNFcnJvcnMnLFxuICAgICdbY2xhc3MuaXMtZm9jdXNlZF0nOiAnaXNGb2N1c2VkJyxcbiAgICAnW2NsYXNzLmlzLWZpbGxlZF0nOiAnaXNGaWxsZWQnLFxuICAgICdbY2xhc3MuaGFzLWRyb3Bkb3duXSc6ICdoYXNEcm9wZG93bicsXG5cbiAgfSxcbiAgY2hhbmdlRGV0ZWN0aW9uOiBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5PblB1c2gsXG59KVxuXG5leHBvcnQgY2xhc3MgTnhXb3JkQ29tcG9uZW50IGltcGxlbWVudHMgQWZ0ZXJDb250ZW50SW5pdCwgT25EZXN0cm95LCBPbkluaXQge1xuICBwcml2YXRlIHN1YnNjcmlwdGlvbjogU3Vic2NyaXB0aW9uID0gU3Vic2NyaXB0aW9uLkVNUFRZO1xuICBwcml2YXRlIHN1YnNjcmlwdGlvblZhbHVlczogU3Vic2NyaXB0aW9uID0gU3Vic2NyaXB0aW9uLkVNUFRZO1xuICBwcml2YXRlIG1lYXN1cmVDYW52YXM6IEhUTUxDYW52YXNFbGVtZW50O1xuXG4gIC8qKiBAZG9jcy1wcml2YXRlICovXG4gIGlucHV0Q2hhbmdlcyA9IG5ldyBTdWJqZWN0PGFueT4oKTtcblxuICBfaGFzRXJyb3JzOiBib29sZWFuID0gZmFsc2U7XG4gIHByaXZhdGUgX292ZXJsYXlSZWY6IE92ZXJsYXlSZWY7XG4gIHByaXZhdGUgX2VtYmVkZGVkVmlld1JlZjogRW1iZWRkZWRWaWV3UmVmPGFueT47XG4gIHByaXZhdGUgX292ZXJsYXlTdGF0ZTogT3ZlcmxheUNvbmZpZztcblxuICBAQ29udGVudENoaWxkKE54Rm9ybWZpZWxkQ29udHJvbCwge3N0YXRpYzogZmFsc2V9KSBfY29udHJvbDogTnhGb3JtZmllbGRDb250cm9sPGFueT47XG4gIEBDb250ZW50Q2hpbGRyZW4oTnhGb3JtZmllbGRFcnJvckRpcmVjdGl2ZSkgX2Vycm9yQ2hpbGRyZW46IFF1ZXJ5TGlzdDxOeEZvcm1maWVsZEVycm9yRGlyZWN0aXZlPjtcbiAgQFZpZXdDaGlsZCgncG9wb3ZlcicsIHsgc3RhdGljOiB0cnVlIH0pIF9wb3BvdmVyOiBOeFBvcG92ZXJDb21wb25lbnQ7XG4gIEBDb250ZW50Q2hpbGQoTnhEcm9wZG93bkNvbXBvbmVudCwge3N0YXRpYzogZmFsc2V9KSBfZHJvcGRvd246IE54RHJvcGRvd25Db21wb25lbnQ7XG5cbiAgLyoqIEBkb2NzLXByaXZhdGUgKi9cbiAgQEhvc3RCaW5kaW5nKCdzdHlsZS53aWR0aC5weCcpXG4gIGN1cnJlbnRUZXh0V2lkdGg6IG51bWJlciA9IDA7XG5cbiAgLy8gdGhpcyB3aWxsIGFwcGx5IGRpZmZlcmVudCBtaW4td2lkdGhzIHRvIG91ciBjb21wb25lbnQgdGhyb3VnaCBvdXIgc3R5bGVzXG4gIC8qKiBQcm92aWRlIGEgaGludCBmb3IgYSBtaW5pbWFsIHdpZHRoLiBUaGUgYWN0dWFsIHNpemUgd2lsbCBiZSBkZXRlcm1pbmVkIGZvciBpbnB1dHMgZm9yIGVhY2ggY2hhbmdlLiAqL1xuICBASW5wdXQoJ254U2l6ZScpIHNpemU6IFNJWkVTID0gJ3JlZ3VsYXInO1xuXG4gIC8qKlxuICAgKiBBIHdvcmQgZG9lc24ndCBoYXZlIGEgc2V0IHBsYWNlIHRvIHNob3cgbGFiZWxzLlxuICAgKiBJbiBvcmRlciB0byBiZSBhY2Nlc3NpYmxlLCB5b3UgaGF2ZSB0byBwcm92aWRlIGEgbGFiZWwgd2l0aCB0aGlzIHByb3BlcnR5LlxuICAgKiBJdCB3aWxsIGJlIGF0dGFjaGVkIHRvIHRoZSBnaXZlbiBpbnB1dCB0aHJvdWdoIGBhcmlhLWxhYmVsYC5cbiAgICovXG4gIEBJbnB1dCgnbnhMYWJlbCcpIGxhYmVsOiBzdHJpbmc7XG5cbiAgY29uc3RydWN0b3IoXG4gICAgLyoqIEBkb2NzLXByaXZhdGUgKi9cbiAgICBwdWJsaWMgZWxlbWVudFJlZjogRWxlbWVudFJlZixcbiAgICBwcml2YXRlIF9jaGFuZ2VEZXRlY3RvclJlZjogQ2hhbmdlRGV0ZWN0b3JSZWYsXG4gICAgcHJpdmF0ZSBfcmVuZGVyZXI6IFJlbmRlcmVyMixcbiAgICBwcml2YXRlIF9vdmVybGF5OiBPdmVybGF5LFxuICAgIHByaXZhdGUgX3ZpZXdDb250YWluZXJSZWY6IFZpZXdDb250YWluZXJSZWYsXG4gICAgcHJpdmF0ZSBfb3ZlcmxheVBvc2l0aW9uQnVpbGRlcjogT3ZlcmxheVBvc2l0aW9uQnVpbGRlclxuICApIHsgfVxuXG4gIG5nT25Jbml0KCkge1xuICAgIHRoaXMuc2V0dXBFcnJvclBvcG92ZXIoKTtcbiAgfVxuXG4gIG5nQWZ0ZXJDb250ZW50SW5pdCgpIHtcbiAgICB0aGlzLl92YWxpZGF0ZUNvbnRyb2xDaGlsZCgpO1xuICAgIHRoaXMuc3Vic2NyaXB0aW9uID0gdGhpcy5fY29udHJvbC5zdGF0ZUNoYW5nZXMucGlwZShzdGFydFdpdGgobnVsbCkpLnN1YnNjcmliZSgoKSA9PiB7XG4gICAgICB0aGlzLl9oYXNFcnJvcnMgPSB0aGlzLl9jb250cm9sLmVycm9yU3RhdGU7XG4gICAgICB0aGlzLnVwZGF0ZUVycm9yUG9wb3ZlclN0YXRlKCk7XG4gICAgICB0aGlzLl9jaGFuZ2VEZXRlY3RvclJlZi5tYXJrRm9yQ2hlY2soKTtcbiAgICB9KTtcblxuICAgIC8vIGlmIHdlIGhhdmUgYSBuZ2NvbnRyb2wgYXZhaWxhYmxlIHN0aWNrIHRvIGl0cyB2YWx1ZUNoYW5nZXMgc3ViamVjdFxuICAgIGlmICh0aGlzLl9jb250cm9sLm5nQ29udHJvbCkge1xuICAgICAgdGhpcy5zdWJzY3JpcHRpb25WYWx1ZXMgPSB0aGlzLl9jb250cm9sLm5nQ29udHJvbC52YWx1ZUNoYW5nZXMuc3Vic2NyaWJlKHZhbHVlID0+IHtcbiAgICAgICAgdGhpcy51cGRhdGVDdXJyZW50VGV4dFdpZHRoKCk7XG4gICAgICAgIHRoaXMuaW5wdXRDaGFuZ2VzLm5leHQoKTtcbiAgICAgIH0pO1xuICAgIC8vIGluIGFueSBvdGhlciBjYXNlIGl0IGlzIGEgYnJlIGlucHV0IGFuZCBpbnB1dCBjaGFuZ2VzIGFyZSBzaWduYWxlZCB0aHJvdWdoIHNpbXBsZSBzdGF0ZSBjaGFuZ2VzXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuc3Vic2NyaXB0aW9uVmFsdWVzID0gdGhpcy5fY29udHJvbC5zdGF0ZUNoYW5nZXMuc3Vic2NyaWJlKHZhbHVlID0+IHtcbiAgICAgICAgdGhpcy51cGRhdGVDdXJyZW50VGV4dFdpZHRoKCk7XG4gICAgICAgIHRoaXMuaW5wdXRDaGFuZ2VzLm5leHQoKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHRoaXMuX2NvbnRyb2wuc2V0QXJpYUxhYmVsKHRoaXMubGFiZWwpO1xuICB9XG5cbiAgbmdPbkRlc3Ryb3koKSB7XG4gICAgdGhpcy5zdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcbiAgfVxuXG4gIC8qKlxuICAgIEBkb2NzLXByaXZhdGVcbiAgICBDYWxjdWxhdGUgdGhlIHdpZHRoIG9mIHRoZSBmdWxsIHRleHQgZ2l2ZW4gYnkgdGhlIGlucHV0LFxuICAgIHRoYXQgdmFsdWUgaXMgYm91bmQgdG8gdGhpcyBjb21wb25lbnQgc28gaXQgY2FuIGdyb3cuXG5cbiAgICBUaGUgaW52b2x2ZWQgaW5wdXQgaXMga25vd24gdG8gaGF2ZSBhIHdpZHRoIG9mIDEwMCUgYW4gd2lsbCBmaXQgdGhlIGFkZGl0aW9uYWwgc3BhY2UgZ2l2ZW5cbiAgICB3aGljaCBjb21wbGV0ZXMgdGhlIGF1dG8gZ3Jvd2luZyBiZWhhdmlvci5cbiAgKi9cbiAgdXBkYXRlQ3VycmVudFRleHRXaWR0aCgpIHtcbiAgICAvLyBwcm92aWRlIHRoZSBjYW52YXMgb25seSBsYXp5XG4gICAgaWYgKCF0aGlzLm1lYXN1cmVDYW52YXMpIHtcbiAgICAgIHRoaXMubWVhc3VyZUNhbnZhcyA9IHRoaXMuX3JlbmRlcmVyLmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xuICAgIH1cblxuICAgIGNvbnN0IGN0eCA9IHRoaXMubWVhc3VyZUNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuICAgIGNvbnN0IGlucHV0UmVmID0gdGhpcy5fY29udHJvbC5lbGVtZW50UmVmO1xuICAgIGNvbnN0IHN0eWxlcyA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGlucHV0UmVmLm5hdGl2ZUVsZW1lbnQpO1xuICAgIGN0eC5mb250ID0gZ2V0Rm9udFNob3J0aGFuZChzdHlsZXMpO1xuXG4gICAgY29uc3QgbWV0cmljcyA9IGN0eC5tZWFzdXJlVGV4dCh0aGlzLl9jb250cm9sLnZhbHVlKTtcbiAgICAvLyBhZGQgMXB4IChjdXJzb3Igd2lkdGgpIHRvIHByZXZlbnQganVtcGluZyBvZiB0aGUgdGV4dCBvbiBibHVyLlxuICAgIGNvbnN0IG5ld1dpZHRoID0gbWV0cmljcy53aWR0aCArIHBhcnNlSW50KHN0eWxlcy5wYWRkaW5nUmlnaHQsIDEwKSArIHBhcnNlSW50KHN0eWxlcy5wYWRkaW5nTGVmdCwgMTApICsgMTtcblxuICAgIC8vIFRoaXMgc2hvdWxkIGJlIGluamVjdGVkIHZpYSBASG9zdCB0byBnZXQgYW4gZXhhY3QgcmVmZXJlbmNlIHRvIE54TmF0dXJhbExhbmd1YWdlRm9ybUNvbXBvbmVudFxuICAgIC8vIFdvcmtzIGFzIHByb21pc2VkIGFzIGxvbmcgYXMgdGhlcmUgaXMgbm90IG90aGVyIHRhZyBhcm91bmQgdGhlIHdvcmQuIE5vdCBleHBlY3RlZCBidXQgcG9zc2libGUuXG4gICAgY29uc3QgcGFyZW50OiBIVE1MRWxlbWVudCA9IHRoaXMuZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50LnBhcmVudEVsZW1lbnQ7XG4gICAgY29uc3QgcGFyZW50TWVhc3VyZW1lbnQgPSBwYXJlbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG5cbiAgICAvLyBMaW1pdCB0byBvd24gZ2l2ZW4gbWluaW1hbCB3aWR0aFxuICAgIHRoaXMuY3VycmVudFRleHRXaWR0aCA9IE1hdGgubWF4KHBhcnNlSW50KHN0eWxlcy5taW5XaWR0aCwgMTApLCBuZXdXaWR0aCk7XG5cbiAgICAvLyBMaW1pdCB0byBjb250YWluZXIgd2lkdGhcbiAgICB0aGlzLmN1cnJlbnRUZXh0V2lkdGggPSBNYXRoLm1pbih0aGlzLmN1cnJlbnRUZXh0V2lkdGgsIHBhcmVudE1lYXN1cmVtZW50LndpZHRoKTtcblxuICAgIGlmICh0aGlzLl9vdmVybGF5UmVmLmhhc0F0dGFjaGVkKCkpIHtcbiAgICAgIHRoaXMuX292ZXJsYXlTdGF0ZS5wb3NpdGlvblN0cmF0ZWd5LmFwcGx5KCk7XG4gICAgfVxuICB9XG5cbiAgLyoqIEBkb2NzLXByaXZhdGUgKi9cbiAgcmVwb3NpdGlvbkVycm9yKCkge1xuICAgIGlmICh0aGlzLl9vdmVybGF5UmVmLmhhc0F0dGFjaGVkKCkpIHtcbiAgICAgIHRoaXMuX292ZXJsYXlTdGF0ZS5wb3NpdGlvblN0cmF0ZWd5LmFwcGx5KCk7XG4gICAgfVxuICB9XG5cbiAgLy8gRmFpbCBpZiB0aGUgcmVxdWlyZWQgY29udHJvbCBpcyBtaXNzaW5nLlxuICBwcm90ZWN0ZWQgX3ZhbGlkYXRlQ29udHJvbENoaWxkKCkge1xuICAgIGlmICghdGhpcy5fY29udHJvbCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdOeFdvcmRDb21wb25lbnQgcmVxdWlyZXMgYW4gTnhGb3JtZmllbGRDb250cm9sIGNvbXBhdGlibGUgaW5wdXQuJyk7XG4gICAgfVxuICB9XG5cbiAgLyoqIEBkb2NzLXByaXZhdGUgKi9cbiAgZ2V0Q29ubmVjdGVkT3ZlcmxheU9yaWdpbigpOiBFbGVtZW50UmVmIHtcbiAgICByZXR1cm4gdGhpcy5lbGVtZW50UmVmO1xuICB9XG5cbiAgLyoqIEBkb2NzLXByaXZhdGUgKi9cbiAgZ2V0IGlzRm9jdXNlZCgpOiBib29sZWFuIHtcbiAgICByZXR1cm4gdGhpcy5fY29udHJvbC5mb2N1c2VkO1xuICB9XG5cbiAgLyoqIEBkb2NzLXByaXZhdGUgKi9cbiAgZ2V0IGlzRmlsbGVkKCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiAhdGhpcy5fY29udHJvbC5lbXB0eTtcbiAgfVxuXG4gIC8qKiBAZG9jcy1wcml2YXRlICovXG4gIGdldCBoYXNEcm9wZG93bigpOiBib29sZWFuIHtcbiAgICByZXR1cm4gQm9vbGVhbih0aGlzLl9kcm9wZG93bik7XG4gIH1cblxuICB1cGRhdGVFcnJvclBvcG92ZXJTdGF0ZSgpIHtcbiAgICBpZiAodGhpcy5faGFzRXJyb3JzICYmIHRoaXMuX2Vycm9yQ2hpbGRyZW4ubGVuZ3RoID4gMCkge1xuICAgICAgICB0aGlzLnNob3dQb3BvdmVyKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmhpZGVQb3BvdmVyKCk7XG4gICAgfVxuICB9XG5cbiAgc2V0dXBFcnJvclBvcG92ZXIoKSB7XG4gICAgY29uc3QgcG9zaXRpb25TdHJhdGVneSA9IHRoaXMuX292ZXJsYXlQb3NpdGlvbkJ1aWxkZXJcbiAgICAgIC5mbGV4aWJsZUNvbm5lY3RlZFRvKHRoaXMuZWxlbWVudFJlZilcbiAgICAgIC53aXRoTG9ja2VkUG9zaXRpb24odHJ1ZSlcbiAgICAgIC53aXRoRmxleGlibGVEaW1lbnNpb25zKGZhbHNlKVxuICAgICAgLndpdGhQdXNoKHRydWUpXG4gICAgICAud2l0aFBvc2l0aW9ucyhbe1xuICAgICAgICBvcmlnaW5YOiAnY2VudGVyJyxcbiAgICAgICAgb3JpZ2luWTogJ3RvcCcsXG4gICAgICAgIG92ZXJsYXlYOiAnY2VudGVyJyxcbiAgICAgICAgb3ZlcmxheVk6ICdib3R0b20nXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBvcmlnaW5YOiAnY2VudGVyJyxcbiAgICAgICAgb3JpZ2luWTogJ2JvdHRvbScsXG4gICAgICAgIG92ZXJsYXlYOiAnY2VudGVyJyxcbiAgICAgICAgb3ZlcmxheVk6ICd0b3AnXG4gICAgICB9XSlcbiAgICAgIC53aXRoRGVmYXVsdE9mZnNldFkoLTgpO1xuXG4gICAgdGhpcy5fb3ZlcmxheVN0YXRlID0gbmV3IE92ZXJsYXlDb25maWcoKTtcbiAgICB0aGlzLl9vdmVybGF5U3RhdGUucG9zaXRpb25TdHJhdGVneSA9IHBvc2l0aW9uU3RyYXRlZ3k7XG4gICAgdGhpcy5fb3ZlcmxheVN0YXRlLnNjcm9sbFN0cmF0ZWd5ID0gdGhpcy5fb3ZlcmxheS5zY3JvbGxTdHJhdGVnaWVzLnJlcG9zaXRpb24oKTtcbiAgICB0aGlzLl9vdmVybGF5UmVmID0gdGhpcy5fb3ZlcmxheS5jcmVhdGUodGhpcy5fb3ZlcmxheVN0YXRlKTtcblxuICAgICh0aGlzLl9vdmVybGF5U3RhdGUucG9zaXRpb25TdHJhdGVneSBhcyBGbGV4aWJsZUNvbm5lY3RlZFBvc2l0aW9uU3RyYXRlZ3kpLnBvc2l0aW9uQ2hhbmdlcy5zdWJzY3JpYmUoY2hhbmdlID0+IHtcbiAgICAgIGNvbnN0IHBhaXIgPSBjaGFuZ2UuY29ubmVjdGlvblBhaXI7XG4gICAgICB0aGlzLnBvc2l0aW9uQXJyb3cocGFpcik7XG5cbiAgICAgIC8vIFRoZXNlIHBvc2l0aW9uIGNoYW5nZXMgYXJyaXZlIHRvbyBsYXRlLFxuICAgICAgLy8gV2UgaGF2ZSB0byB0cmlnZ2VyIHRoZSBjaGFuZ2UgZGV0ZWN0aW9uIG1hbnVhbGx5XG4gICAgICAvLyBhcyBpdCdzIGRldGFjaGVkIGZyb20gYW55IHJlbmRlciBoaWVyYXJjaHlcbiAgICAgIC8vIGFuZCBvbmx5IHVwZGF0ZWQgYnkgdGhlIG92ZXJsYXkgd2hlbiBhdHRhY2hlZC5cbiAgICAgIGlmICh0aGlzLl9lbWJlZGRlZFZpZXdSZWYgJiYgIXRoaXMuX2VtYmVkZGVkVmlld1JlZi5kZXN0cm95ZWQpIHtcbiAgICAgICAgdGhpcy5fZW1iZWRkZWRWaWV3UmVmLmRldGVjdENoYW5nZXMoKTtcbiAgICAgIH1cbiAgICB9XG4gICAgKTtcbiAgfVxuXG4gIHByaXZhdGUgcG9zaXRpb25BcnJvdyhwYWlyOiBDb25uZWN0aW9uUG9zaXRpb25QYWlyKSB7XG4gICAgY29uc3QgcGFyZW50RWxlbWVudFBvc2l0aW9uWCA9IHRoaXMuZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmxlZnQ7XG4gICAgY29uc3QgcGFyZW50RWxlbWVudFdpZHRoID0gdGhpcy5lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkud2lkdGggLyAyO1xuICAgIGNvbnN0IHBhcmVudEVsZW1lbnRMZWZ0T2Zmc2V0ID0gdGhpcy5fb3ZlcmxheVJlZi5vdmVybGF5RWxlbWVudC5wYXJlbnRFbGVtZW50Lm9mZnNldExlZnQ7XG4gICAgY29uc3Qgb3ZlcmxheUVsZW1lbnRMZWZ0T2Zmc2V0ID0gdGhpcy5fb3ZlcmxheVJlZi5vdmVybGF5RWxlbWVudC5vZmZzZXRMZWZ0O1xuXG4gICAgLy8gY2FsY3VsYXRpb24gZm9yIHggcG9zaXRpb24gb2YgdGhlIHBhcmVudCBlbGVtZW50LiBJbiB0aGlzIGNhc2UsIG92ZXJsYXkgbGVmdCBvZmZzZXQgaXMgdGhlIG9uZSB0aGluZyB0byBjb25zaWRlci5cbiAgICBjb25zdCB0YXJnZXRQb3NpdGlvbiA9IChwYXJlbnRFbGVtZW50UG9zaXRpb25YICsgcGFyZW50RWxlbWVudFdpZHRoKSAtIChwYXJlbnRFbGVtZW50TGVmdE9mZnNldCArIG92ZXJsYXlFbGVtZW50TGVmdE9mZnNldCk7XG5cbiAgICBpZiAocGFpci5vcmlnaW5ZID09PSAndG9wJyAmJiBwYWlyLm92ZXJsYXlZID09PSAnYm90dG9tJykge1xuICAgICAgdGhpcy5fcG9wb3Zlci5kaXJlY3Rpb24gPSAndG9wJztcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fcG9wb3Zlci5kaXJlY3Rpb24gPSAnYm90dG9tJztcbiAgICB9XG5cbiAgICB0aGlzLl9wb3BvdmVyLmFycm93U3R5bGUgPSB7bGVmdDogdGFyZ2V0UG9zaXRpb24gKyAncHgnfTtcbiAgfVxuXG4gIHNob3dQb3BvdmVyKCkge1xuICAgIGlmICghdGhpcy5fb3ZlcmxheVJlZi5oYXNBdHRhY2hlZCgpKSB7XG4gICAgICBjb25zdCB0b29sdGlwUG9ydGFsID0gbmV3IFRlbXBsYXRlUG9ydGFsKHRoaXMuX3BvcG92ZXIudGVtcGxhdGVSZWYsIHRoaXMuX3ZpZXdDb250YWluZXJSZWYpO1xuICAgICAgdGhpcy5fZW1iZWRkZWRWaWV3UmVmID0gdGhpcy5fb3ZlcmxheVJlZi5hdHRhY2godG9vbHRpcFBvcnRhbCk7XG4gICAgfVxuICB9XG5cbiAgaGlkZVBvcG92ZXIoKSB7XG4gICAgdGhpcy5fb3ZlcmxheVJlZi5kZXRhY2goKTtcbiAgfVxufVxuIl19