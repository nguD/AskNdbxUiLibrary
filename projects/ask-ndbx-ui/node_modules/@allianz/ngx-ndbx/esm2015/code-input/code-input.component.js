/**
 * @fileoverview added by tsickle
 * Generated from: code-input.component.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import { ChangeDetectionStrategy, Component, Input, ChangeDetectorRef, ElementRef, Self, Optional } from '@angular/core';
import { NgControl, NgForm, FormGroupDirective } from '@angular/forms';
import { NxCodeInputIntl } from './code-input-intl';
import { ErrorStateMatcher } from '@allianz/ngx-ndbx/utils';
import { BACKSPACE, LEFT_ARROW, RIGHT_ARROW, SPACE, DOWN_ARROW, UP_ARROW } from '@angular/cdk/keycodes';
import { coerceBooleanProperty } from '@angular/cdk/coercion';
/** @type {?} */
const DEFAULT_INPUT_LENGTH = 6;
/** @type {?} */
const TAG_NAME_INPUT = 'INPUT';
/** @type {?} */
const AUTO_UPPERCASE = 'upper';
/** @type {?} */
const AUTO_LOWERCASE = 'lower';
/** @type {?} */
const INPUT_FIELD_GAP = 'nx-code-input--field-with-gap';
export class NxCodeInputComponent {
    /**
     * @param {?} _changeDetectorRef
     * @param {?} _el
     * @param {?} _control
     * @param {?} _intl
     * @param {?} _errorStateMatcher
     * @param {?} _parentForm
     * @param {?} _parentFormGroup
     */
    constructor(_changeDetectorRef, _el, _control, _intl, _errorStateMatcher, _parentForm, _parentFormGroup) {
        this._changeDetectorRef = _changeDetectorRef;
        this._el = _el;
        this._control = _control;
        this._intl = _intl;
        this._errorStateMatcher = _errorStateMatcher;
        this._parentForm = _parentForm;
        this._parentFormGroup = _parentFormGroup;
        /**
         * Whether the current input of the component has an error.
         */
        this.errorState = false;
        this._codeLength = DEFAULT_INPUT_LENGTH;
        this._type = 'text';
        this._isUpDown = false;
        this._tabindex = 0;
        /**
         * The user input in array form
         */
        this._keyCode = new Array(DEFAULT_INPUT_LENGTH);
        this._focused = false;
        this._negative = false;
        this._disabled = false;
        /**
         * \@docs-private
         */
        this.propagateChange = (/**
         * @param {?} _
         * @return {?}
         */
        (_) => {
        });
        /**
         * \@docs-private
         */
        this.propagateTouch = (/**
         * @param {?} _
         * @return {?}
         */
        (_) => {
        });
        if (this._control) {
            // Note: we provide the value accessor through here, instead of
            // the `providers` to avoid running into a circular import.
            this._control.valueAccessor = this;
        }
    }
    /**
     * The length of the code input. Default: 6.
     * @param {?} value
     * @return {?}
     */
    set codeLength(value) {
        this._codeLength = value;
        this.setInputLength();
        this._changeDetectorRef.markForCheck();
    }
    /**
     * @return {?}
     */
    get codeLength() {
        return this._codeLength;
    }
    /**
     * The type of HTML input
     * @param {?} value
     * @return {?}
     */
    set type(value) {
        this._type = value;
        this._changeDetectorRef.markForCheck();
    }
    /**
     * @return {?}
     */
    get type() {
        return this._type;
    }
    /**
     * Sets the tabindex of the contained input elements.
     * @param {?} value
     * @return {?}
     */
    set tabindex(value) {
        this._tabindex = value;
        this._changeDetectorRef.markForCheck();
    }
    /**
     * @return {?}
     */
    get tabindex() {
        return this._tabindex;
    }
    /**
     * Whether the form should auto capitalize or lowercase (optional).
     * @param {?} value
     * @return {?}
     */
    set convertTo(value) {
        this._convertTo = value;
        this._changeDetectorRef.markForCheck();
    }
    /**
     * @return {?}
     */
    get convertTo() {
        return this._convertTo;
    }
    /**
     * Whether the code input uses the negative set of styling.
     * @param {?} value
     * @return {?}
     */
    set negative(value) {
        /** @type {?} */
        const newValue = coerceBooleanProperty(value);
        if (this._negative !== newValue) {
            this._negative = newValue;
            this._changeDetectorRef.markForCheck();
        }
    }
    /**
     * @return {?}
     */
    get negative() {
        return this._negative;
    }
    /**
     * Whether the code input is disabled.
     * @param {?} value
     * @return {?}
     */
    set disabled(value) {
        /** @type {?} */
        const newValue = coerceBooleanProperty(value);
        if (this._disabled !== newValue) {
            this._disabled = newValue;
            this._changeDetectorRef.markForCheck();
        }
    }
    /**
     * @return {?}
     */
    get disabled() {
        return this._disabled;
    }
    /**
     * @return {?}
     */
    ngDoCheck() {
        if (this._control) {
            // We need to re-evaluate this on every change detection cycle, because there are some
            // error triggers that we can't subscribe to (e.g. parent form submissions). This means
            // that whatever logic is in here has to be super lean or we risk destroying the performance.
            this.updateErrorState();
        }
    }
    /**
     * Sets the length of the input fields.
     * @return {?}
     */
    setInputLength() {
        if (this.codeLength) {
            this._keyCode = new Array(this.codeLength);
        }
        else {
            this._keyCode = new Array(DEFAULT_INPUT_LENGTH);
        }
    }
    /**
     * Converts to upper or lowercase when enabled.
     * @param {?} value
     * @return {?}
     */
    _convertLetterSize(value) {
        if (value === 'ÃŸ') {
            return value;
        }
        if (typeof value === 'string') {
            if (this.convertTo === AUTO_UPPERCASE) {
                return value.toUpperCase();
            }
            else if (this.convertTo === AUTO_LOWERCASE) {
                return value.toLowerCase();
            }
            return value;
        }
    }
    /**
     * Reacts to keydown event.
     * @param {?} event
     * @return {?}
     */
    _keydownAction(event) {
        /** @type {?} */
        const previousInputField = event.target.previousElementSibling;
        /** @type {?} */
        const nextInputField = event.target.nextElementSibling;
        switch (event.keyCode) {
            case SPACE:
                return false;
            case BACKSPACE:
                if (event.target.value === '') {
                    if (previousInputField && previousInputField.tagName === TAG_NAME_INPUT) {
                        this.selectInput(previousInputField);
                    }
                }
                break;
            case LEFT_ARROW:
                if (previousInputField && previousInputField.tagName === TAG_NAME_INPUT) {
                    event.preventDefault();
                    this.selectInput(previousInputField);
                }
                break;
            case RIGHT_ARROW:
                if (nextInputField && nextInputField.tagName === TAG_NAME_INPUT) {
                    this.selectInput(nextInputField);
                }
                event.preventDefault();
                break;
            case DOWN_ARROW:
                this._isUpDown = true;
                if (this._type === 'number' && (event.target.value === '' || event.target.value === '0')) {
                    event.preventDefault();
                }
                break;
            case UP_ARROW:
                this._isUpDown = true;
                if (this._type === 'number' && event.target.value === '9') {
                    event.preventDefault();
                }
                break;
            default:
                break;
        }
    }
    /**
     * Selects the value on click of an input field.
     * @param {?} event
     * @return {?}
     */
    _selectText(event) {
        this.selectInput(event.target);
    }
    /**
     * Automatically focuses and selects the next input on key input.
     * @param {?} event
     * @return {?}
     */
    _selectNextInput(event) {
        event.target.value = this._convertLetterSize(event.target.value.slice(0, 1));
        /** @type {?} */
        const currentIndex = this._getFocusedInputIndex(event);
        // save in model with uppercase if needed
        this._keyCode[currentIndex] = event.target.value;
        this.propagateChange(this._keyCode.join(''));
        // don't jump to next input if the user uses UP/DOWn arrow (native behaviour)
        /** @type {?} */
        const focusNextInput = !(this._isUpDown && this.type === 'number');
        if (event.target.value && focusNextInput) {
            /** @type {?} */
            const nextInputField = event.target.nextSibling;
            if (nextInputField !== null && nextInputField.tagName === TAG_NAME_INPUT) {
                nextInputField.focus();
                if (nextInputField.value !== '') {
                    this.selectInput(nextInputField);
                }
            }
        }
        this._isUpDown = false;
    }
    /**
     * Paste event to distribute content in input fields.
     * @param {?} event
     * @return {?}
     */
    _pasteClipboard(event) {
        /** @type {?} */
        let copiedText = (event.clipboardData || ((/** @type {?} */ (window))).clipboardData).getData('text');
        /** @type {?} */
        let copiedTextIndex = 0;
        /** @type {?} */
        const inputIndex = this._getFocusedInputIndex(event);
        copiedText = this.type === 'number' ? this._formatNumberInput(copiedText) : copiedText;
        for (let i = inputIndex; i < this.codeLength; i++) {
            this._keyCode[i] = this._convertLetterSize(copiedText[copiedTextIndex]);
            copiedTextIndex++;
        }
        this.propagateChange(this._keyCode.join(''));
        if (inputIndex + copiedText.length < this.codeLength) {
            this._el.nativeElement.children.item(inputIndex + copiedText.length).focus();
        }
        else {
            this._el.nativeElement.children.item(this.codeLength - 1).focus();
        }
        event.preventDefault();
    }
    /**
     * Returns the index of the code input, which is currently focused.
     * @private
     * @param {?} event
     * @return {?}
     */
    _getFocusedInputIndex(event) {
        /** @type {?} */
        let inputIndex;
        for (let i = 0; i < this._el.nativeElement.children.length; i++) {
            if (event.srcElement === this._el.nativeElement.children.item(i)) {
                inputIndex = i;
            }
        }
        return inputIndex;
    }
    /**
     * Removes all characters from the input except for numbers [0-9].
     * @private
     * @param {?} copiedText
     * @return {?}
     */
    _formatNumberInput(copiedText) {
        /** @type {?} */
        let formattedInput = '';
        for (let i = 0; i < copiedText.length; i++) {
            if (copiedText[i].match(/[0-9]{1}$/)) {
                formattedInput += copiedText[i];
            }
        }
        return formattedInput;
    }
    /**
     * Triggers when an input field is blurred.
     * @return {?}
     */
    _onBlur() {
        this._focused = false;
        setTimeout((/**
         * @return {?}
         */
        () => {
            if (!this._focused) {
                this.propagateTouch(this._keyCode.join(''));
            }
            this._changeDetectorRef.markForCheck();
        }));
    }
    /**
     * Sets _focused state and makes valid.
     * @return {?}
     */
    _setFocusState() {
        this._focused = true;
    }
    /**
     * Disables the code input. Part of the ControlValueAccessor interface required
     * to integrate with Angular's core forms API.
     *
     * @param {?} isDisabled Sets whether the component is disabled.
     * @return {?}
     */
    setDisabledState(isDisabled) {
        this.disabled = isDisabled;
        this._changeDetectorRef.markForCheck();
    }
    /**
     * Sets initial value, used by ControlValueAccessor.
     * @param {?} value
     * @return {?}
     */
    writeValue(value) {
        if (value) {
            /** @type {?} */
            const valueAsArray = value.split('').slice(0, this.codeLength);
            for (let i = 0; i < this.codeLength; i++) {
                this._keyCode[i] = valueAsArray[i];
            }
        }
        else {
            this.setInputLength();
        }
        this._changeDetectorRef.markForCheck();
    }
    /**
     * @param {?} index
     * @param {?} item
     * @return {?}
     */
    _trackByKeyCode(index, item) {
        return index;
    }
    /**
     * Adds a gap to input fields when appropriate.
     * @param {?} index
     * @return {?}
     */
    _inputGap(index) {
        switch (this.codeLength) {
            case 4:
            case 6:
            case 8:
                if (index === this.codeLength / 2) {
                    return INPUT_FIELD_GAP;
                }
                break;
            default:
                return;
        }
    }
    /**
     * @param {?} fn
     * @return {?}
     */
    registerOnChange(fn) {
        this.propagateChange = fn;
    }
    /**
     * @param {?} fn
     * @return {?}
     */
    registerOnTouched(fn) {
        this.propagateTouch = fn;
    }
    /**
     * \@docs-private
     * @return {?}
     */
    updateErrorState() {
        /** @type {?} */
        const oldState = this.errorState;
        /** @type {?} */
        const parent = this._parentFormGroup || this._parentForm;
        /** @type {?} */
        const control = this._control ? (/** @type {?} */ (this._control.control)) : null;
        /** @type {?} */
        const newState = this._errorStateMatcher.isErrorState(control, parent);
        if (newState !== oldState) {
            this.errorState = newState;
        }
    }
    /**
     * @param {?} keyIndex
     * @return {?}
     */
    getAriaLabel(keyIndex) {
        return `${this._intl.inputFieldAriaLabel} ${keyIndex + 1} ${this._intl.ofLabel} ${this._keyCode.length}`;
    }
    /**
     * \@docs-private
     * Workaround preventing the selection error because the `setSelectionRange` is not supported on input['type=number']
     *
     * @param {?} input
     * @return {?}
     */
    selectInput(input) {
        input.focus();
        try {
            input.setSelectionRange(0, input.value.length);
        }
        catch (err) {
            if (err instanceof DOMException && err.name === 'InvalidStateError') {
                // setSelectionRange does not apply
            }
            else {
                throw err;
            }
        }
    }
}
NxCodeInputComponent.decorators = [
    { type: Component, args: [{
                selector: 'nx-code-input',
                template: "<input\n        class=\"nx-code-input__field\"\n        maxlength=\"1\"\n        *ngFor=\"let key of _keyCode; index as i; trackBy: _trackByKeyCode;\"\n        [(ngModel)]=\"_keyCode[i]\"\n        [ngClass]=\"_inputGap(i)\"\n        [attr.aria-label]=\"getAriaLabel(i)\"\n        [attr.type]=\"type\"\n        (input)=\"_selectNextInput($event)\"\n        (paste)=\"_pasteClipboard($event)\"\n        (blur)=\"_onBlur()\"\n        (focus)=\"_setFocusState()\"\n        (click)=\"_selectText($event)\"\n        (keydown)=\"_keydownAction($event)\"\n        [attr.tabindex]=\"tabindex\"\n        [attr.disabled]=\"disabled ? '' : null\"\n />\n",
                host: {
                    '[class.nx-code-input]': 'true',
                    '[class.has-error]': 'errorState',
                    '[class.is-negative]': 'negative',
                    '[class.is-disabled]': 'disabled',
                    '[attr.tabindex]': '-1'
                },
                changeDetection: ChangeDetectionStrategy.OnPush,
                styles: [":host{display:block}:host .nx-code-input__field{font-size:26px;font-size:var(--code-input-font-size,26px);line-height:32px;line-height:var(--code-input-line-height,32px);font-weight:600;font-weight:var(--code-input-font-weight,600);letter-spacing:.3px;letter-spacing:var(--code-input-letter-spacing,.3px);color:#414141;color:var(--code-input-color,#414141);margin:0 4px;text-align:center;border:0;outline:0;caret-color:#007ab3;caret-color:var(--code-input-active-color,#007ab3);box-shadow:inset 0 -1px 0 0 #414141;box-shadow:inset 0 -1px 0 0 var(--code-input-color,#414141);width:32px;border-radius:0;padding:0;background:0 0;box-sizing:border-box}:host .nx-code-input__field:focus{margin-bottom:-1px;color:#007ab3;color:var(--code-input-active-color,#007ab3);box-shadow:inset 0 -2px 0 0 #007ab3;box-shadow:inset 0 -2px 0 0 var(--code-input-active-color,#007ab3)}:host .nx-code-input__field:first-child{margin-left:0}:host .nx-code-input__field:last-child{margin-right:0}:host .nx-code-input--field-with-gap{margin-left:20px}:host:focus{outline:0}:host.is-negative .nx-code-input__field{caret-color:#fff;box-shadow:inset 0 -1px 0 0 #fff;color:#fff}:host.is-negative .nx-code-input__field:focus{box-shadow:inset 0 -2px 0 0 #fff}:host.has-error:not(.is-negative) .nx-code-input__field{margin-bottom:-1px;font-weight:700;color:#dc3149;color:var(--code-input-error-color,#dc3149);box-shadow:inset 0 -1px 0 0 #dc3149;box-shadow:inset 0 -1px 0 0 var(--code-input-error-color,#dc3149)}:host.has-error:not(.is-negative) .nx-code-input__field:focus{box-shadow:inset 0 -2px 0 0 #dc3149;box-shadow:inset 0 -2px 0 0 var(--code-input-error-color,#dc3149)}:host.has-error.is-negative .nx-code-input__field{font-weight:700}:host.is-disabled{cursor:not-allowed}:host.is-disabled .nx-code-input__field{cursor:not-allowed;color:#c2c2c2;color:var(--code-input-disabled-color,#c2c2c2);box-shadow:inset 0 -1px 0 0 nx-theme-color(code-input-disabled-color);box-shadow:inset 0 -1px 0 0 var(--code-input-disabled-color,#c2c2c2)}:host.is-disabled.is-negative .nx-code-input__field{color:rgba(194,194,194,.4);box-shadow:inset 0 -1px 0 0 rgba(194,194,194,.4)}input[type=number]::-webkit-inner-spin-button,input[type=number]::-webkit-outer-spin-button{-webkit-appearance:none;margin:0}input[type=number]{-moz-appearance:textfield}@media screen and (-ms-high-contrast:active){.nx-code-input__field{box-shadow:inset 0 -1px 0 0 buttonText}.nx-code-input__field:focus{box-shadow:inset 0 -2px 0 0 buttonText}:host.is-disabled .nx-code-input__field{color:GrayText;box-shadow:inset 0 -1px 0 0 GrayText;opacity:1}}"]
            }] }
];
/** @nocollapse */
NxCodeInputComponent.ctorParameters = () => [
    { type: ChangeDetectorRef },
    { type: ElementRef },
    { type: NgControl, decorators: [{ type: Self }, { type: Optional }] },
    { type: NxCodeInputIntl },
    { type: ErrorStateMatcher },
    { type: NgForm, decorators: [{ type: Optional }] },
    { type: FormGroupDirective, decorators: [{ type: Optional }] }
];
NxCodeInputComponent.propDecorators = {
    codeLength: [{ type: Input, args: ['length',] }],
    type: [{ type: Input }],
    tabindex: [{ type: Input }],
    convertTo: [{ type: Input, args: ['nxConvertTo',] }],
    negative: [{ type: Input }],
    disabled: [{ type: Input }]
};
if (false) {
    /**
     * Whether the current input of the component has an error.
     * @type {?}
     */
    NxCodeInputComponent.prototype.errorState;
    /**
     * @type {?}
     * @private
     */
    NxCodeInputComponent.prototype._codeLength;
    /**
     * @type {?}
     * @private
     */
    NxCodeInputComponent.prototype._type;
    /**
     * @type {?}
     * @private
     */
    NxCodeInputComponent.prototype._isUpDown;
    /**
     * @type {?}
     * @private
     */
    NxCodeInputComponent.prototype._tabindex;
    /**
     * @type {?}
     * @private
     */
    NxCodeInputComponent.prototype._convertTo;
    /**
     * The user input in array form
     * @type {?}
     */
    NxCodeInputComponent.prototype._keyCode;
    /**
     * @type {?}
     * @private
     */
    NxCodeInputComponent.prototype._focused;
    /**
     * @type {?}
     * @private
     */
    NxCodeInputComponent.prototype._negative;
    /**
     * @type {?}
     * @private
     */
    NxCodeInputComponent.prototype._disabled;
    /**
     * \@docs-private
     * @type {?}
     */
    NxCodeInputComponent.prototype.propagateChange;
    /**
     * \@docs-private
     * @type {?}
     */
    NxCodeInputComponent.prototype.propagateTouch;
    /**
     * @type {?}
     * @private
     */
    NxCodeInputComponent.prototype._changeDetectorRef;
    /**
     * @type {?}
     * @private
     */
    NxCodeInputComponent.prototype._el;
    /** @type {?} */
    NxCodeInputComponent.prototype._control;
    /** @type {?} */
    NxCodeInputComponent.prototype._intl;
    /**
     * @type {?}
     * @private
     */
    NxCodeInputComponent.prototype._errorStateMatcher;
    /**
     * @type {?}
     * @private
     */
    NxCodeInputComponent.prototype._parentForm;
    /**
     * @type {?}
     * @private
     */
    NxCodeInputComponent.prototype._parentFormGroup;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY29kZS1pbnB1dC5jb21wb25lbnQuanMiLCJzb3VyY2VSb290Ijoibmc6Ly9AYWxsaWFuei9uZ3gtbmRieC9jb2RlLWlucHV0LyIsInNvdXJjZXMiOlsiY29kZS1pbnB1dC5jb21wb25lbnQudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQSxPQUFPLEVBQ0wsdUJBQXVCLEVBQ3ZCLFNBQVMsRUFDVCxLQUFLLEVBQ0wsaUJBQWlCLEVBQ2pCLFVBQVUsRUFDVixJQUFJLEVBQ0osUUFBUSxFQUVULE1BQU0sZUFBZSxDQUFDO0FBQ3ZCLE9BQU8sRUFBd0IsU0FBUyxFQUFFLE1BQU0sRUFBRSxrQkFBa0IsRUFBZSxNQUFNLGdCQUFnQixDQUFDO0FBQzFHLE9BQU8sRUFBRSxlQUFlLEVBQUUsTUFBTSxtQkFBbUIsQ0FBQztBQUNwRCxPQUFPLEVBQUUsaUJBQWlCLEVBQUUsTUFBTSx5QkFBeUIsQ0FBQztBQUM1RCxPQUFPLEVBQUUsU0FBUyxFQUFFLFVBQVUsRUFBRSxXQUFXLEVBQUUsS0FBSyxFQUFFLFVBQVUsRUFBRSxRQUFRLEVBQUUsTUFBTSx1QkFBdUIsQ0FBQztBQUN4RyxPQUFPLEVBQUUscUJBQXFCLEVBQUUsTUFBTSx1QkFBdUIsQ0FBQzs7TUFFeEQsb0JBQW9CLEdBQUcsQ0FBQzs7TUFDeEIsY0FBYyxHQUFHLE9BQU87O01BQ3hCLGNBQWMsR0FBRyxPQUFPOztNQUN4QixjQUFjLEdBQUcsT0FBTzs7TUFDeEIsZUFBZSxHQUFHLCtCQUErQjtBQWtCdkQsTUFBTSxPQUFPLG9CQUFvQjs7Ozs7Ozs7OztJQXFGL0IsWUFDVSxrQkFBcUMsRUFDckMsR0FBZSxFQUNJLFFBQW1CLEVBQ3ZDLEtBQXNCLEVBQ3JCLGtCQUFxQyxFQUN6QixXQUFtQixFQUNuQixnQkFBb0M7UUFOaEQsdUJBQWtCLEdBQWxCLGtCQUFrQixDQUFtQjtRQUNyQyxRQUFHLEdBQUgsR0FBRyxDQUFZO1FBQ0ksYUFBUSxHQUFSLFFBQVEsQ0FBVztRQUN2QyxVQUFLLEdBQUwsS0FB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Q3BDO2lCQUFNO2dCQUNMLE1BQU0sR0FBRyxDQUFDO2FBQ1g7U0FDRjtJQUNILENBQUM7OztZQWpZRCxTQUFTLFNBQUM7Z0JBQ1QsUUFBUSxFQUFFLGVBQWU7Z0JBQ3pCLDZvQkFBd0M7Z0JBSXhDLElBQUksRUFBRTtvQkFDSix1QkFBdUIsRUFBRSxNQUFNO29CQUMvQixtQkFBbUIsRUFBRSxZQUFZO29CQUNqQyxxQkFBcUIsRUFBRSxVQUFVO29CQUNqQyxxQkFBcUIsRUFBRSxVQUFVO29CQUNqQyxpQkFBaUIsRUFBRSxJQUFJO2lCQUN4QjtnQkFDRCxlQUFlLEVBQUUsdUJBQXVCLENBQUMsTUFBTTs7YUFDaEQ7Ozs7WUFqQ0MsaUJBQWlCO1lBQ2pCLFVBQVU7WUFLbUIsU0FBUyx1QkFvSG5DLElBQUksWUFBSSxRQUFRO1lBbkhaLGVBQWU7WUFDZixpQkFBaUI7WUFGZ0IsTUFBTSx1QkF1SDNDLFFBQVE7WUF2SHFDLGtCQUFrQix1QkF3SC9ELFFBQVE7Ozt5QkF0RlYsS0FBSyxTQUFDLFFBQVE7bUJBWWQsS0FBSzt1QkFZTCxLQUFLO3dCQVdMLEtBQUssU0FBQyxhQUFhO3VCQWVuQixLQUFLO3VCQWVMLEtBQUs7Ozs7Ozs7SUFwRU4sMENBQTRCOzs7OztJQVk1QiwyQ0FBbUQ7Ozs7O0lBV25ELHFDQUErQjs7Ozs7SUFDL0IseUNBQW1DOzs7OztJQVduQyx5Q0FBOEI7Ozs7O0lBVzlCLDBDQUF1Qzs7Ozs7SUFHdkMsd0NBQXFEOzs7OztJQUNyRCx3Q0FBa0M7Ozs7O0lBZWxDLHlDQUFtQzs7Ozs7SUFlbkMseUNBQW1DOzs7OztJQWtQbkMsK0NBQ0M7Ozs7O0lBR0QsOENBQ0M7Ozs7O0lBcFBDLGtEQUE2Qzs7Ozs7SUFDN0MsbUNBQXVCOztJQUN2Qix3Q0FBOEM7O0lBQzlDLHFDQUE2Qjs7Ozs7SUFDN0Isa0RBQTZDOzs7OztJQUM3QywyQ0FBdUM7Ozs7O0lBQ3ZDLGdEQUF3RCIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7XG4gIENoYW5nZURldGVjdGlvblN0cmF0ZWd5LFxuICBDb21wb25lbnQsXG4gIElucHV0LFxuICBDaGFuZ2VEZXRlY3RvclJlZixcbiAgRWxlbWVudFJlZixcbiAgU2VsZixcbiAgT3B0aW9uYWwsXG4gIERvQ2hlY2tcbn0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBDb250cm9sVmFsdWVBY2Nlc3NvciwgTmdDb250cm9sLCBOZ0Zvcm0sIEZvcm1Hcm91cERpcmVjdGl2ZSwgRm9ybUNvbnRyb2wgfSBmcm9tICdAYW5ndWxhci9mb3Jtcyc7XG5pbXBvcnQgeyBOeENvZGVJbnB1dEludGwgfSBmcm9tICcuL2NvZGUtaW5wdXQtaW50bCc7XG5pbXBvcnQgeyBFcnJvclN0YXRlTWF0Y2hlciB9IGZyb20gJ0BhbGxpYW56L25neC1uZGJ4L3V0aWxzJztcbmltcG9ydCB7IEJBQ0tTUEFDRSwgTEVGVF9BUlJPVywgUklHSFRfQVJST1csIFNQQUNFLCBET1dOX0FSUk9XLCBVUF9BUlJPVyB9IGZyb20gJ0Bhbmd1bGFyL2Nkay9rZXljb2Rlcyc7XG5pbXBvcnQgeyBjb2VyY2VCb29sZWFuUHJvcGVydHkgfSBmcm9tICdAYW5ndWxhci9jZGsvY29lcmNpb24nO1xuXG5jb25zdCBERUZBVUxUX0lOUFVUX0xFTkdUSCA9IDY7XG5jb25zdCBUQUdfTkFNRV9JTlBVVCA9ICdJTlBVVCc7XG5jb25zdCBBVVRPX1VQUEVSQ0FTRSA9ICd1cHBlcic7XG5jb25zdCBBVVRPX0xPV0VSQ0FTRSA9ICdsb3dlcic7XG5jb25zdCBJTlBVVF9GSUVMRF9HQVAgPSAnbngtY29kZS1pbnB1dC0tZmllbGQtd2l0aC1nYXAnO1xuZXhwb3J0IHR5cGUgTnhDb252ZXJzaW9uVHlwZXMgPSAnbG93ZXInIHwgJ3VwcGVyJztcblxuQENvbXBvbmVudCh7XG4gIHNlbGVjdG9yOiAnbngtY29kZS1pbnB1dCcsXG4gIHRlbXBsYXRlVXJsOiAnY29kZS1pbnB1dC5jb21wb25lbnQuaHRtbCcsXG4gIHN0eWxlVXJsczogW1xuICAgICdjb2RlLWlucHV0LnNjc3MnXG4gIF0sXG4gIGhvc3Q6IHtcbiAgICAnW2NsYXNzLm54LWNvZGUtaW5wdXRdJzogJ3RydWUnLFxuICAgICdbY2xhc3MuaGFzLWVycm9yXSc6ICdlcnJvclN0YXRlJyxcbiAgICAnW2NsYXNzLmlzLW5lZ2F0aXZlXSc6ICduZWdhdGl2ZScsXG4gICAgJ1tjbGFzcy5pcy1kaXNhYmxlZF0nOiAnZGlzYWJsZWQnLFxuICAgICdbYXR0ci50YWJpbmRleF0nOiAnLTEnXG4gIH0sXG4gIGNoYW5nZURldGVjdGlvbjogQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuT25QdXNoXG59KVxuZXhwb3J0IGNsYXNzIE54Q29kZUlucHV0Q29tcG9uZW50IGltcGxlbWVudHMgQ29udHJvbFZhbHVlQWNjZXNzb3IsIERvQ2hlY2sge1xuXG4gIC8qKiBXaGV0aGVyIHRoZSBjdXJyZW50IGlucHV0IG9mIHRoZSBjb21wb25lbnQgaGFzIGFuIGVycm9yLiAqL1xuICBlcnJvclN0YXRlOiBib29sZWFuID0gZmFsc2U7XG5cbiAgLyoqIFRoZSBsZW5ndGggb2YgdGhlIGNvZGUgaW5wdXQuIERlZmF1bHQ6IDYuICovXG4gIEBJbnB1dCgnbGVuZ3RoJylcbiAgc2V0IGNvZGVMZW5ndGgodmFsdWU6IG51bWJlcikge1xuICAgIHRoaXMuX2NvZGVMZW5ndGggPSB2YWx1ZTtcbiAgICB0aGlzLnNldElucHV0TGVuZ3RoKCk7XG4gICAgdGhpcy5fY2hhbmdlRGV0ZWN0b3JSZWYubWFya0ZvckNoZWNrKCk7XG4gIH1cbiAgZ2V0IGNvZGVMZW5ndGgoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2NvZGVMZW5ndGg7XG4gIH1cbiAgcHJpdmF0ZSBfY29kZUxlbmd0aDogbnVtYmVyID0gREVGQVVMVF9JTlBVVF9MRU5HVEg7XG5cbiAgLyoqIFRoZSB0eXBlIG9mIEhUTUwgaW5wdXQgKi9cbiAgQElucHV0KClcbiAgc2V0IHR5cGUodmFsdWU6IHN0cmluZykge1xuICAgIHRoaXMuX3R5cGUgPSB2YWx1ZTtcbiAgICB0aGlzLl9jaGFuZ2VEZXRlY3RvclJlZi5tYXJrRm9yQ2hlY2soKTtcbiAgfVxuICBnZXQgdHlwZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fdHlwZTtcbiAgfVxuICBwcml2YXRlIF90eXBlOiBzdHJpbmcgPSAndGV4dCc7XG4gIHByaXZhdGUgX2lzVXBEb3duOiBib29sZWFuID0gZmFsc2U7XG5cbiAgLyoqIFNldHMgdGhlIHRhYmluZGV4IG9mIHRoZSBjb250YWluZWQgaW5wdXQgZWxlbWVudHMuICovXG4gIEBJbnB1dCgpXG4gIHNldCB0YWJpbmRleCh2YWx1ZTogbnVtYmVyKSB7XG4gICAgdGhpcy5fdGFiaW5kZXggPSB2YWx1ZTtcbiAgICB0aGlzLl9jaGFuZ2VEZXRlY3RvclJlZi5tYXJrRm9yQ2hlY2soKTtcbiAgfVxuICBnZXQgdGFiaW5kZXgoKTogbnVtYmVyIHtcbiAgICByZXR1cm4gdGhpcy5fdGFiaW5kZXg7XG4gIH1cbiAgcHJpdmF0ZSBfdGFiaW5kZXg6IG51bWJlciA9IDA7XG5cbiAgLyoqIFdoZXRoZXIgdGhlIGZvcm0gc2hvdWxkIGF1dG8gY2FwaXRhbGl6ZSBvciBsb3dlcmNhc2UgKG9wdGlvbmFsKS4gKi9cbiAgQElucHV0KCdueENvbnZlcnRUbycpXG4gIHNldCBjb252ZXJ0VG8odmFsdWU6IE54Q29udmVyc2lvblR5cGVzKSB7XG4gICAgdGhpcy5fY29udmVydFRvID0gdmFsdWU7XG4gICAgdGhpcy5fY2hhbmdlRGV0ZWN0b3JSZWYubWFya0ZvckNoZWNrKCk7XG4gIH1cbiAgZ2V0IGNvbnZlcnRUbygpIHtcbiAgICByZXR1cm4gdGhpcy5fY29udmVydFRvO1xuICB9XG4gIHByaXZhdGUgX2NvbnZlcnRUbz86IE54Q29udmVyc2lvblR5cGVzO1xuXG4gIC8qKiBUaGUgdXNlciBpbnB1dCBpbiBhcnJheSBmb3JtICovXG4gIF9rZXlDb2RlOiBzdHJpbmdbXSA9IG5ldyBBcnJheShERUZBVUxUX0lOUFVUX0xFTkdUSCk7XG4gIHByaXZhdGUgX2ZvY3VzZWQ6IGJvb2xlYW4gPSBmYWxzZTtcblxuICAvKiogV2hldGhlciB0aGUgY29kZSBpbnB1dCB1c2VzIHRoZSBuZWdhdGl2ZSBzZXQgb2Ygc3R5bGluZy4gKi9cbiAgQElucHV0KClcbiAgc2V0IG5lZ2F0aXZlKHZhbHVlOiBib29sZWFuKSB7XG4gICAgY29uc3QgbmV3VmFsdWUgPSBjb2VyY2VCb29sZWFuUHJvcGVydHkodmFsdWUpO1xuICAgIGlmICh0aGlzLl9uZWdhdGl2ZSAhPT0gbmV3VmFsdWUpIHtcbiAgICAgIHRoaXMuX25lZ2F0aXZlID0gbmV3VmFsdWU7XG4gICAgICB0aGlzLl9jaGFuZ2VEZXRlY3RvclJlZi5tYXJrRm9yQ2hlY2soKTtcbiAgICB9XG4gIH1cbiAgZ2V0IG5lZ2F0aXZlKCkge1xuICAgIHJldHVybiB0aGlzLl9uZWdhdGl2ZTtcbiAgfVxuXG4gIHByaXZhdGUgX25lZ2F0aXZlOiBib29sZWFuID0gZmFsc2U7XG5cbiAgLyoqIFdoZXRoZXIgdGhlIGNvZGUgaW5wdXQgaXMgZGlzYWJsZWQuICovXG4gIEBJbnB1dCgpXG4gIHNldCBkaXNhYmxlZCh2YWx1ZTogYm9vbGVhbikge1xuICAgIGNvbnN0IG5ld1ZhbHVlID0gY29lcmNlQm9vbGVhblByb3BlcnR5KHZhbHVlKTtcbiAgICBpZiAodGhpcy5fZGlzYWJsZWQgIT09IG5ld1ZhbHVlKSB7XG4gICAgICB0aGlzLl9kaXNhYmxlZCA9IG5ld1ZhbHVlO1xuICAgICAgdGhpcy5fY2hhbmdlRGV0ZWN0b3JSZWYubWFya0ZvckNoZWNrKCk7XG4gICAgfVxuICB9XG4gIGdldCBkaXNhYmxlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5fZGlzYWJsZWQ7XG4gIH1cblxuICBwcml2YXRlIF9kaXNhYmxlZDogYm9vbGVhbiA9IGZhbHNlO1xuXG4gIGNvbnN0cnVjdG9yKFxuICAgIHByaXZhdGUgX2NoYW5nZURldGVjdG9yUmVmOiBDaGFuZ2VEZXRlY3RvclJlZixcbiAgICBwcml2YXRlIF9lbDogRWxlbWVudFJlZixcbiAgICBAU2VsZigpIEBPcHRpb25hbCgpIHB1YmxpYyBfY29udHJvbDogTmdDb250cm9sLFxuICAgIHB1YmxpYyBfaW50bDogTnhDb2RlSW5wdXRJbnRsLFxuICAgIHByaXZhdGUgX2Vycm9yU3RhdGVNYXRjaGVyOiBFcnJvclN0YXRlTWF0Y2hlcixcbiAgICBAT3B0aW9uYWwoKSBwcml2YXRlIF9wYXJlbnRGb3JtOiBOZ0Zvcm0sXG4gICAgQE9wdGlvbmFsKCkgcHJpdmF0ZSBfcGFyZW50Rm9ybUdyb3VwOiBGb3JtR3JvdXBEaXJlY3RpdmUpIHtcbiAgICBpZiAodGhpcy5fY29udHJvbCkge1xuICAgICAgLy8gTm90ZTogd2UgcHJvdmlkZSB0aGUgdmFsdWUgYWNjZXNzb3IgdGhyb3VnaCBoZXJlLCBpbnN0ZWFkIG9mXG4gICAgICAvLyB0aGUgYHByb3ZpZGVyc2AgdG8gYXZvaWQgcnVubmluZyBpbnRvIGEgY2lyY3VsYXIgaW1wb3J0LlxuICAgICAgdGhpcy5fY29udHJvbC52YWx1ZUFjY2Vzc29yID0gdGhpcztcbiAgICB9XG4gIH1cblxuICBuZ0RvQ2hlY2soKSB7XG4gICAgaWYgKHRoaXMuX2NvbnRyb2wpIHtcbiAgICAgIC8vIFdlIG5lZWQgdG8gcmUtZXZhbHVhdGUgdGhpcyBvbiBldmVyeSBjaGFuZ2UgZGV0ZWN0aW9uIGN5Y2xlLCBiZWNhdXNlIHRoZXJlIGFyZSBzb21lXG4gICAgICAvLyBlcnJvciB0cmlnZ2VycyB0aGF0IHdlIGNhbid0IHN1YnNjcmliZSB0byAoZS5nLiBwYXJlbnQgZm9ybSBzdWJtaXNzaW9ucykuIFRoaXMgbWVhbnNcbiAgICAgIC8vIHRoYXQgd2hhdGV2ZXIgbG9naWMgaXMgaW4gaGVyZSBoYXMgdG8gYmUgc3VwZXIgbGVhbiBvciB3ZSByaXNrIGRlc3Ryb3lpbmcgdGhlIHBlcmZvcm1hbmNlLlxuICAgICAgdGhpcy51cGRhdGVFcnJvclN0YXRlKCk7XG4gICAgfVxuICB9XG5cbiAgLyoqIFNldHMgdGhlIGxlbmd0aCBvZiB0aGUgaW5wdXQgZmllbGRzLiAqL1xuICBzZXRJbnB1dExlbmd0aCgpOiB2b2lkIHtcbiAgICBpZiAodGhpcy5jb2RlTGVuZ3RoKSB7XG4gICAgICB0aGlzLl9rZXlDb2RlID0gbmV3IEFycmF5KHRoaXMuY29kZUxlbmd0aCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX2tleUNvZGUgPSBuZXcgQXJyYXkoREVGQVVMVF9JTlBVVF9MRU5HVEgpO1xuICAgIH1cbiAgfVxuXG4gIC8qKiBDb252ZXJ0cyB0byB1cHBlciBvciBsb3dlcmNhc2Ugd2hlbiBlbmFibGVkLiAqL1xuICBfY29udmVydExldHRlclNpemUodmFsdWU6IGFueSk6IHN0cmluZyB7XG4gICAgaWYgKHZhbHVlID09PSAnw58nKSB7XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGlmICh0aGlzLmNvbnZlcnRUbyA9PT0gQVVUT19VUFBFUkNBU0UpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlLnRvVXBwZXJDYXNlKCk7XG4gICAgICB9IGVsc2UgaWYgKHRoaXMuY29udmVydFRvID09PSBBVVRPX0xPV0VSQ0FTRSkge1xuICAgICAgICByZXR1cm4gdmFsdWUudG9Mb3dlckNhc2UoKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgfVxuXG4gIC8qKiBSZWFjdHMgdG8ga2V5ZG93biBldmVudC4gKi9cbiAgX2tleWRvd25BY3Rpb24oZXZlbnQpOiB2b2lkIHwgZmFsc2Uge1xuICAgIGNvbnN0IHByZXZpb3VzSW5wdXRGaWVsZDogSFRNTElucHV0RWxlbWVudCA9IGV2ZW50LnRhcmdldC5wcmV2aW91c0VsZW1lbnRTaWJsaW5nO1xuICAgIGNvbnN0IG5leHRJbnB1dEZpZWxkOiBIVE1MSW5wdXRFbGVtZW50ID0gZXZlbnQudGFyZ2V0Lm5leHRFbGVtZW50U2libGluZztcblxuICAgIHN3aXRjaCAoZXZlbnQua2V5Q29kZSkge1xuICAgICAgY2FzZSBTUEFDRTpcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuXG4gICAgICBjYXNlIEJBQ0tTUEFDRTpcbiAgICAgICAgaWYgKGV2ZW50LnRhcmdldC52YWx1ZSA9PT0gJycpIHtcbiAgICAgICAgICBpZiAocHJldmlvdXNJbnB1dEZpZWxkICYmIHByZXZpb3VzSW5wdXRGaWVsZC50YWdOYW1lID09PSBUQUdfTkFNRV9JTlBVVCkge1xuICAgICAgICAgICAgdGhpcy5zZWxlY3RJbnB1dChwcmV2aW91c0lucHV0RmllbGQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSBMRUZUX0FSUk9XOlxuICAgICAgICBpZiAocHJldmlvdXNJbnB1dEZpZWxkICYmIHByZXZpb3VzSW5wdXRGaWVsZC50YWdOYW1lID09PSBUQUdfTkFNRV9JTlBVVCkge1xuICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgdGhpcy5zZWxlY3RJbnB1dChwcmV2aW91c0lucHV0RmllbGQpO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIFJJR0hUX0FSUk9XOlxuICAgICAgICBpZiAobmV4dElucHV0RmllbGQgJiYgbmV4dElucHV0RmllbGQudGFnTmFtZSA9PT0gVEFHX05BTUVfSU5QVVQpIHtcbiAgICAgICAgICB0aGlzLnNlbGVjdElucHV0KG5leHRJbnB1dEZpZWxkKTtcbiAgICAgICAgfVxuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSBET1dOX0FSUk9XOlxuICAgICAgICB0aGlzLl9pc1VwRG93biA9IHRydWU7XG4gICAgICAgIGlmICh0aGlzLl90eXBlID09PSAnbnVtYmVyJyAmJiAoZXZlbnQudGFyZ2V0LnZhbHVlID09PSAnJyB8fCBldmVudC50YXJnZXQudmFsdWUgPT09ICcwJykpIHtcbiAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIFVQX0FSUk9XOlxuICAgICAgICB0aGlzLl9pc1VwRG93biA9IHRydWU7XG4gICAgICAgIGlmICh0aGlzLl90eXBlID09PSAnbnVtYmVyJyAmJiBldmVudC50YXJnZXQudmFsdWUgPT09ICc5Jykge1xuICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIC8qKiBTZWxlY3RzIHRoZSB2YWx1ZSBvbiBjbGljayBvZiBhbiBpbnB1dCBmaWVsZC4gKi9cbiAgX3NlbGVjdFRleHQoZXZlbnQpOiB2b2lkIHtcbiAgICB0aGlzLnNlbGVjdElucHV0KGV2ZW50LnRhcmdldCk7XG4gIH1cblxuICAvKiogQXV0b21hdGljYWxseSBmb2N1c2VzIGFuZCBzZWxlY3RzIHRoZSBuZXh0IGlucHV0IG9uIGtleSBpbnB1dC4gKi9cbiAgX3NlbGVjdE5leHRJbnB1dChldmVudCk6IHZvaWQge1xuICAgIGV2ZW50LnRhcmdldC52YWx1ZSA9IHRoaXMuX2NvbnZlcnRMZXR0ZXJTaXplKGV2ZW50LnRhcmdldC52YWx1ZS5zbGljZSgwLCAxKSk7XG4gICAgY29uc3QgY3VycmVudEluZGV4ID0gdGhpcy5fZ2V0Rm9jdXNlZElucHV0SW5kZXgoZXZlbnQpO1xuICAgIC8vIHNhdmUgaW4gbW9kZWwgd2l0aCB1cHBlcmNhc2UgaWYgbmVlZGVkXG4gICAgdGhpcy5fa2V5Q29kZVtjdXJyZW50SW5kZXhdID0gZXZlbnQudGFyZ2V0LnZhbHVlO1xuICAgIHRoaXMucHJvcGFnYXRlQ2hhbmdlKHRoaXMuX2tleUNvZGUuam9pbignJykpO1xuXG4gICAgLy8gZG9uJ3QganVtcCB0byBuZXh0IGlucHV0IGlmIHRoZSB1c2VyIHVzZXMgVVAvRE9XbiBhcnJvdyAobmF0aXZlIGJlaGF2aW91cilcbiAgICBjb25zdCBmb2N1c05leHRJbnB1dCA9ICEodGhpcy5faXNVcERvd24gJiYgdGhpcy50eXBlID09PSAnbnVtYmVyJyk7XG5cbiAgICBpZiAoZXZlbnQudGFyZ2V0LnZhbHVlICYmIGZvY3VzTmV4dElucHV0KSB7XG4gICAgICBjb25zdCBuZXh0SW5wdXRGaWVsZCA9IGV2ZW50LnRhcmdldC5uZXh0U2libGluZztcblxuICAgICAgaWYgKG5leHRJbnB1dEZpZWxkICE9PSBudWxsICYmIG5leHRJbnB1dEZpZWxkLnRhZ05hbWUgPT09IFRBR19OQU1FX0lOUFVUKSB7XG4gICAgICAgIG5leHRJbnB1dEZpZWxkLmZvY3VzKCk7XG4gICAgICAgIGlmIChuZXh0SW5wdXRGaWVsZC52YWx1ZSAhPT0gJycpIHtcbiAgICAgICAgICB0aGlzLnNlbGVjdElucHV0KG5leHRJbnB1dEZpZWxkKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMuX2lzVXBEb3duID0gZmFsc2U7XG4gIH1cblxuICAvKiogUGFzdGUgZXZlbnQgdG8gZGlzdHJpYnV0ZSBjb250ZW50IGluIGlucHV0IGZpZWxkcy4gKi9cbiAgX3Bhc3RlQ2xpcGJvYXJkKGV2ZW50KTogdm9pZCB7XG4gICAgbGV0IGNvcGllZFRleHQgPSAoZXZlbnQuY2xpcGJvYXJkRGF0YSB8fCAoPGFueT4gd2luZG93KS5jbGlwYm9hcmREYXRhKS5nZXREYXRhKCd0ZXh0Jyk7XG4gICAgbGV0IGNvcGllZFRleHRJbmRleCA9IDA7XG4gICAgY29uc3QgaW5wdXRJbmRleCA9IHRoaXMuX2dldEZvY3VzZWRJbnB1dEluZGV4KGV2ZW50KTtcblxuICAgIGNvcGllZFRleHQgPSB0aGlzLnR5cGUgPT09ICdudW1iZXInID8gdGhpcy5fZm9ybWF0TnVtYmVySW5wdXQoY29waWVkVGV4dCkgOiBjb3BpZWRUZXh0O1xuXG4gICAgZm9yIChsZXQgaSA9IGlucHV0SW5kZXg7IGkgPCB0aGlzLmNvZGVMZW5ndGg7IGkrKykge1xuICAgICAgdGhpcy5fa2V5Q29kZVtpXSA9IHRoaXMuX2NvbnZlcnRMZXR0ZXJTaXplKGNvcGllZFRleHRbY29waWVkVGV4dEluZGV4XSk7XG4gICAgICBjb3BpZWRUZXh0SW5kZXgrKztcbiAgICB9XG5cbiAgICB0aGlzLnByb3BhZ2F0ZUNoYW5nZSh0aGlzLl9rZXlDb2RlLmpvaW4oJycpKTtcblxuICAgIGlmIChpbnB1dEluZGV4ICsgY29waWVkVGV4dC5sZW5ndGggPCB0aGlzLmNvZGVMZW5ndGgpIHtcbiAgICAgIHRoaXMuX2VsLm5hdGl2ZUVsZW1lbnQuY2hpbGRyZW4uaXRlbShpbnB1dEluZGV4ICsgY29waWVkVGV4dC5sZW5ndGgpLmZvY3VzKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX2VsLm5hdGl2ZUVsZW1lbnQuY2hpbGRyZW4uaXRlbSh0aGlzLmNvZGVMZW5ndGggLSAxKS5mb2N1cygpO1xuICAgIH1cblxuICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gIH1cblxuICAvKiogUmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIGNvZGUgaW5wdXQsIHdoaWNoIGlzIGN1cnJlbnRseSBmb2N1c2VkLiAqL1xuICBwcml2YXRlIF9nZXRGb2N1c2VkSW5wdXRJbmRleChldmVudCkge1xuICAgIGxldCBpbnB1dEluZGV4O1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5fZWwubmF0aXZlRWxlbWVudC5jaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKGV2ZW50LnNyY0VsZW1lbnQgPT09IHRoaXMuX2VsLm5hdGl2ZUVsZW1lbnQuY2hpbGRyZW4uaXRlbShpKSkge1xuICAgICAgICBpbnB1dEluZGV4ID0gaTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGlucHV0SW5kZXg7XG4gIH1cblxuICAvKiogUmVtb3ZlcyBhbGwgY2hhcmFjdGVycyBmcm9tIHRoZSBpbnB1dCBleGNlcHQgZm9yIG51bWJlcnMgWzAtOV0uICovXG4gIHByaXZhdGUgX2Zvcm1hdE51bWJlcklucHV0KGNvcGllZFRleHQ6IHN0cmluZykge1xuICAgIGxldCBmb3JtYXR0ZWRJbnB1dCA9ICcnO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY29waWVkVGV4dC5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKGNvcGllZFRleHRbaV0ubWF0Y2goL1swLTldezF9JC8pKSB7XG4gICAgICAgIGZvcm1hdHRlZElucHV0ICs9IGNvcGllZFRleHRbaV07XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGZvcm1hdHRlZElucHV0O1xuICB9XG5cbiAgLyoqIFRyaWdnZXJzIHdoZW4gYW4gaW5wdXQgZmllbGQgaXMgYmx1cnJlZC4gKi9cbiAgX29uQmx1cigpOiB2b2lkIHtcbiAgICB0aGlzLl9mb2N1c2VkID0gZmFsc2U7XG4gICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICBpZiAoIXRoaXMuX2ZvY3VzZWQpIHtcbiAgICAgICAgdGhpcy5wcm9wYWdhdGVUb3VjaCh0aGlzLl9rZXlDb2RlLmpvaW4oJycpKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX2NoYW5nZURldGVjdG9yUmVmLm1hcmtGb3JDaGVjaygpO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqIFNldHMgX2ZvY3VzZWQgc3RhdGUgYW5kIG1ha2VzIHZhbGlkLiAqL1xuICBfc2V0Rm9jdXNTdGF0ZSgpOiB2b2lkIHtcbiAgICB0aGlzLl9mb2N1c2VkID0gdHJ1ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEaXNhYmxlcyB0aGUgY29kZSBpbnB1dC4gUGFydCBvZiB0aGUgQ29udHJvbFZhbHVlQWNjZXNzb3IgaW50ZXJmYWNlIHJlcXVpcmVkXG4gICAqIHRvIGludGVncmF0ZSB3aXRoIEFuZ3VsYXIncyBjb3JlIGZvcm1zIEFQSS5cbiAgICpcbiAgICogQHBhcmFtIGlzRGlzYWJsZWQgU2V0cyB3aGV0aGVyIHRoZSBjb21wb25lbnQgaXMgZGlzYWJsZWQuXG4gICAqL1xuICBzZXREaXNhYmxlZFN0YXRlKGlzRGlzYWJsZWQ6IGJvb2xlYW4pOiB2b2lkIHtcbiAgICB0aGlzLmRpc2FibGVkID0gaXNEaXNhYmxlZDtcbiAgICB0aGlzLl9jaGFuZ2VEZXRlY3RvclJlZi5tYXJrRm9yQ2hlY2soKTtcbiAgfVxuXG4gIC8qKiBTZXRzIGluaXRpYWwgdmFsdWUsIHVzZWQgYnkgQ29udHJvbFZhbHVlQWNjZXNzb3IuICovXG4gIHdyaXRlVmFsdWUodmFsdWU6IHN0cmluZyk6IHZvaWQge1xuICAgIGlmICh2YWx1ZSkge1xuICAgICAgY29uc3QgdmFsdWVBc0FycmF5ID0gdmFsdWUuc3BsaXQoJycpLnNsaWNlKDAsIHRoaXMuY29kZUxlbmd0aCk7XG5cbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5jb2RlTGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdGhpcy5fa2V5Q29kZVtpXSA9IHZhbHVlQXNBcnJheVtpXTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5zZXRJbnB1dExlbmd0aCgpO1xuICAgIH1cblxuICAgIHRoaXMuX2NoYW5nZURldGVjdG9yUmVmLm1hcmtGb3JDaGVjaygpO1xuICB9XG5cbiAgX3RyYWNrQnlLZXlDb2RlKGluZGV4OiBudW1iZXIsIGl0ZW06IHN0cmluZyk6IG51bWJlciB7XG4gICAgcmV0dXJuIGluZGV4O1xuICB9XG5cbiAgLyoqIEFkZHMgYSBnYXAgdG8gaW5wdXQgZmllbGRzIHdoZW4gYXBwcm9wcmlhdGUuICovXG4gIF9pbnB1dEdhcChpbmRleCk6IHN0cmluZyB7XG4gICAgc3dpdGNoICh0aGlzLmNvZGVMZW5ndGgpIHtcbiAgICAgIGNhc2UgNDpcbiAgICAgIGNhc2UgNjpcbiAgICAgIGNhc2UgODpcbiAgICAgICAgaWYgKGluZGV4ID09PSB0aGlzLmNvZGVMZW5ndGggLyAyKSB7XG4gICAgICAgICAgcmV0dXJuIElOUFVUX0ZJRUxEX0dBUDtcbiAgICAgICAgfVxuXG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgfVxuXG4gIC8qKiBAZG9jcy1wcml2YXRlICovXG4gIHByb3BhZ2F0ZUNoYW5nZSA9IChfOiBhbnkpID0+IHtcbiAgfVxuXG4gIC8qKiBAZG9jcy1wcml2YXRlICovXG4gIHByb3BhZ2F0ZVRvdWNoID0gKF86IGFueSkgPT4ge1xuICB9XG5cbiAgcmVnaXN0ZXJPbkNoYW5nZShmbjogYW55KSB7XG4gICAgdGhpcy5wcm9wYWdhdGVDaGFuZ2UgPSBmbjtcbiAgfVxuXG4gIHJlZ2lzdGVyT25Ub3VjaGVkKGZuOiBhbnkpIHtcbiAgICB0aGlzLnByb3BhZ2F0ZVRvdWNoID0gZm47XG4gIH1cblxuICAvKiogQGRvY3MtcHJpdmF0ZSAqL1xuICB1cGRhdGVFcnJvclN0YXRlKCkge1xuICAgIGNvbnN0IG9sZFN0YXRlID0gdGhpcy5lcnJvclN0YXRlO1xuICAgIGNvbnN0IHBhcmVudCA9IHRoaXMuX3BhcmVudEZvcm1Hcm91cCB8fCB0aGlzLl9wYXJlbnRGb3JtO1xuICAgIGNvbnN0IGNvbnRyb2wgPSB0aGlzLl9jb250cm9sID8gdGhpcy5fY29udHJvbC5jb250cm9sIGFzIEZvcm1Db250cm9sIDogbnVsbDtcbiAgICBjb25zdCBuZXdTdGF0ZSA9IHRoaXMuX2Vycm9yU3RhdGVNYXRjaGVyLmlzRXJyb3JTdGF0ZShjb250cm9sLCBwYXJlbnQpO1xuXG4gICAgaWYgKG5ld1N0YXRlICE9PSBvbGRTdGF0ZSkge1xuICAgICAgdGhpcy5lcnJvclN0YXRlID0gbmV3U3RhdGU7XG4gICAgfVxuICB9XG5cbiAgZ2V0QXJpYUxhYmVsKGtleUluZGV4OiBudW1iZXIpIHtcbiAgICByZXR1cm4gYCR7dGhpcy5faW50bC5pbnB1dEZpZWxkQXJpYUxhYmVsfSAke2tleUluZGV4ICsgMX0gJHt0aGlzLl9pbnRsLm9mTGFiZWx9ICR7dGhpcy5fa2V5Q29kZS5sZW5ndGh9YDtcbiAgfVxuXG4gLyoqIEBkb2NzLXByaXZhdGVcbiAgKiBXb3JrYXJvdW5kIHByZXZlbnRpbmcgdGhlIHNlbGVjdGlvbiBlcnJvciBiZWNhdXNlIHRoZSBgc2V0U2VsZWN0aW9uUmFuZ2VgIGlzIG5vdCBzdXBwb3J0ZWQgb24gaW5wdXRbJ3R5cGU9bnVtYmVyJ11cbiAgKiAqL1xuIHNlbGVjdElucHV0KGlucHV0OiBIVE1MSW5wdXRFbGVtZW50KSB7XG4gICBpbnB1dC5mb2N1cygpO1xuICAgdHJ5IHtcbiAgICAgaW5wdXQuc2V0U2VsZWN0aW9uUmFuZ2UoMCwgaW5wdXQudmFsdWUubGVuZ3RoKTtcbiAgIH0gY2F0Y2ggKGVycikge1xuICAgICBpZiAoZXJyIGluc3RhbmNlb2YgRE9NRXhjZXB0aW9uICYmIGVyci5uYW1lID09PSAnSW52YWxpZFN0YXRlRXJyb3InKSB7XG4gICAgICAgLy8gc2V0U2VsZWN0aW9uUmFuZ2UgZG9lcyBub3QgYXBwbHlcbiAgICAgfSBlbHNlIHtcbiAgICAgICB0aHJvdyBlcnI7XG4gICAgIH1cbiAgIH1cbiB9XG59XG4iXX0=