/**
 * @fileoverview added by tsickle
 * Generated from: sort-header/sort.directive.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import { Directive, Output, EventEmitter, Input } from '@angular/core';
import { Subject } from 'rxjs';
export class SortEvent {
    /**
     * @param {?} active
     * @param {?} direction
     */
    constructor(active, direction) {
        this.active = active;
        this.direction = direction;
    }
}
if (false) {
    /**
     * The name of the column that is being sorted by.
     * @type {?}
     */
    SortEvent.prototype.active;
    /**
     * The sort direction.
     * @type {?}
     */
    SortEvent.prototype.direction;
}
export class NxSortDirective {
    constructor() {
        this._stateChanges = new Subject();
        this._direction = 'asc';
        /**
         * \@docs-private
         * An event emitted when the active value has changed.
         */
        this.activeChange = new EventEmitter();
        /**
         * \@docs-private
         * An event emitted when the direction value has changed.
         */
        this.directionChange = new EventEmitter();
        /**
         * An event emitted when either the active sort or sort direction changes.
         */
        this.sortChange = new EventEmitter();
    }
    /**
     * Sets the key of the most recently sorted column.
     * @param {?} value
     * @return {?}
     */
    set active(value) {
        if (this._active !== value) {
            this._active = value;
            this.sortChange.emit(new SortEvent(this.active, this.direction));
            this._stateChanges.next();
        }
    }
    /**
     * @return {?}
     */
    get active() {
        return this._active;
    }
    /**
     * Sets the direction of the currently active sorted column. Default: 'asc'.
     * @param {?} value
     * @return {?}
     */
    set direction(value) {
        if (this._direction !== value) {
            this._direction = value;
            this.sortChange.emit(new SortEvent(this.active, this.direction));
            this._stateChanges.next();
        }
    }
    /**
     * @return {?}
     */
    get direction() {
        return this._direction;
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this._stateChanges.complete();
    }
    /**
     * Sets the active sort key and determines the new sort direction.
     * Afterwards the output event `sortChange` is called.
     *
     * If `sortable` is not the key of the active sort header, the initial direction to sort is 'asc'.
     * Otherwise the direction of the sorted column changes.
     * @param {?} sortable
     * @return {?}
     */
    sort(sortable) {
        if (this._active !== sortable) {
            this._active = sortable;
            this.activeChange.emit(this.active);
            this._direction = 'asc';
            this.directionChange.emit(this.direction);
        }
        else if (this._direction === 'asc') {
            this._direction = 'desc';
            this.directionChange.emit(this.direction);
        }
        else {
            this._direction = 'asc';
            this.directionChange.emit(this.direction);
        }
        this.sortChange.emit(new SortEvent(this.active, this.direction));
        this._stateChanges.next();
    }
}
NxSortDirective.decorators = [
    { type: Directive, args: [{
                selector: 'table[nxSort]',
                exportAs: 'NxSortDirective'
            },] }
];
NxSortDirective.propDecorators = {
    active: [{ type: Input }],
    direction: [{ type: Input }],
    activeChange: [{ type: Output }],
    directionChange: [{ type: Output }],
    sortChange: [{ type: Output }]
};
if (false) {
    /** @type {?} */
    NxSortDirective.prototype._stateChanges;
    /**
     * @type {?}
     * @private
     */
    NxSortDirective.prototype._active;
    /**
     * @type {?}
     * @private
     */
    NxSortDirective.prototype._direction;
    /**
     * \@docs-private
     * An event emitted when the active value has changed.
     * @type {?}
     */
    NxSortDirective.prototype.activeChange;
    /**
     * \@docs-private
     * An event emitted when the direction value has changed.
     * @type {?}
     */
    NxSortDirective.prototype.directionChange;
    /**
     * An event emitted when either the active sort or sort direction changes.
     * @type {?}
     */
    NxSortDirective.prototype.sortChange;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic29ydC5kaXJlY3RpdmUuanMiLCJzb3VyY2VSb290Ijoibmc6Ly9AYWxsaWFuei9uZ3gtbmRieC90YWJsZS8iLCJzb3VyY2VzIjpbInNvcnQtaGVhZGVyL3NvcnQuZGlyZWN0aXZlLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7O0FBQUEsT0FBTyxFQUFFLFNBQVMsRUFBRSxNQUFNLEVBQUUsWUFBWSxFQUFFLEtBQUssRUFBYSxNQUFNLGVBQWUsQ0FBQztBQUNsRixPQUFPLEVBQUUsT0FBTyxFQUFFLE1BQU0sTUFBTSxDQUFDO0FBSS9CLE1BQU0sT0FBTyxTQUFTOzs7OztJQU9wQixZQUFZLE1BQU0sRUFBRSxTQUFTO1FBQzNCLElBQUksQ0FBQyxNQUFNLEdBQUcsTUFBTSxDQUFDO1FBQ3JCLElBQUksQ0FBQyxTQUFTLEdBQUcsU0FBUyxDQUFDO0lBQzdCLENBQUM7Q0FDRjs7Ozs7O0lBVEMsMkJBQWU7Ozs7O0lBR2YsOEJBQXlCOztBQVkzQixNQUFNLE9BQU8sZUFBZTtJQUo1QjtRQU1XLGtCQUFhLEdBQUcsSUFBSSxPQUFPLEVBQVEsQ0FBQztRQWlCckMsZUFBVSxHQUFrQixLQUFLLENBQUM7Ozs7O1FBbUJ2QixpQkFBWSxHQUF5QixJQUFJLFlBQVksRUFBVSxDQUFDOzs7OztRQU1oRSxvQkFBZSxHQUFnQyxJQUFJLFlBQVksRUFBaUIsQ0FBQzs7OztRQUdqRixlQUFVLEdBQTRCLElBQUksWUFBWSxFQUFhLENBQUM7SUErQnpGLENBQUM7Ozs7OztJQXZFQyxJQUNJLE1BQU0sQ0FBQyxLQUFhO1FBQ3RCLElBQUksSUFBSSxDQUFDLE9BQU8sS0FBSyxLQUFLLEVBQUU7WUFDMUIsSUFBSSxDQUFDLE9BQU8sR0FBRyxLQUFLLENBQUM7WUFDckIsSUFBSSxDQUFDLFVBQVUsQ0FBQyxJQUFJLENBQUMsSUFBSSxTQUFTLENBQUMsSUFBSSxDQUFDLE1BQU0sRUFBRSxJQUFJLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBQztZQUNqRSxJQUFJLENBQUMsYUFBYSxDQUFDLElBQUksRUFBRSxDQUFDO1NBQzNCO0lBQ0gsQ0FBQzs7OztJQUNELElBQUksTUFBTTtRQUNSLE9BQU8sSUFBSSxDQUFDLE9BQU8sQ0FBQztJQUN0QixDQUFDOzs7Ozs7SUFLRCxJQUNJLFNBQVMsQ0FBQyxLQUFvQjtRQUNoQyxJQUFJLElBQUksQ0FBQyxVQUFVLEtBQUssS0FBSyxFQUFFO1lBQzdCLElBQUksQ0FBQyxVQUFVLEdBQUcsS0FBSyxDQUFDO1lBQ3hCLElBQUksQ0FBQyxVQUFVLENBQUMsSUFBSSxDQUFDLElBQUksU0FBUyxDQUFDLElBQUksQ0FBQyxNQUFNLEVBQUUsSUFBSSxDQUFDLFNBQVMsQ0FBQyxDQUFDLENBQUM7WUFDakUsSUFBSSxDQUFDLGFBQWEsQ0FBQyxJQUFJLEVBQUUsQ0FBQztTQUMzQjtJQUNILENBQUM7Ozs7SUFDRCxJQUFJLFNBQVM7UUFDWCxPQUFPLElBQUksQ0FBQyxVQUFVLENBQUM7SUFDekIsQ0FBQzs7OztJQWlCRCxXQUFXO1FBQ1QsSUFBSSxDQUFDLGFBQWEsQ0FBQyxRQUFRLEVBQUUsQ0FBQztJQUNoQyxDQUFDOzs7Ozs7Ozs7O0lBU0QsSUFBSSxDQUFDLFFBQWdCO1FBQ25CLElBQUksSUFBSSxDQUFDLE9BQU8sS0FBSyxRQUFRLEVBQUU7WUFDN0IsSUFBSSxDQUFDLE9BQU8sR0FBRyxRQUFRLENBQUM7WUFDeEIsSUFBSSxDQUFDLFlBQVksQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxDQUFDO1lBQ3BDLElBQUksQ0FBQyxVQUFVLEdBQUcsS0FBSyxDQUFDO1lBQ3hCLElBQUksQ0FBQyxlQUFlLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxTQUFTLENBQUMsQ0FBQztTQUMzQzthQUFNLElBQUksSUFBSSxDQUFDLFVBQVUsS0FBSyxLQUFLLEVBQUU7WUFDcEMsSUFBSSxDQUFDLFVBQVUsR0FBRyxNQUFNLENBQUM7WUFDekIsSUFBSSxDQUFDLGVBQWUsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxDQUFDO1NBQzNDO2FBQU07WUFDTCxJQUFJLENBQUMsVUFBVSxHQUFHLEtBQUssQ0FBQztZQUN4QixJQUFJLENBQUMsZUFBZSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsU0FBUyxDQUFDLENBQUM7U0FDM0M7UUFFRCxJQUFJLENBQUMsVUFBVSxDQUFDLElBQUksQ0FBQyxJQUFJLFNBQVMsQ0FBQyxJQUFJLENBQUMsTUFBTSxFQUFFLElBQUksQ0FBQyxTQUFTLENBQUMsQ0FBQyxDQUFDO1FBQ2pFLElBQUksQ0FBQyxhQUFhLENBQUMsSUFBSSxFQUFFLENBQUM7SUFDNUIsQ0FBQzs7O1lBaEZGLFNBQVMsU0FBQztnQkFDVCxRQUFRLEVBQUUsZUFBZTtnQkFDekIsUUFBUSxFQUFFLGlCQUFpQjthQUM1Qjs7O3FCQVFFLEtBQUs7d0JBZUwsS0FBSzsyQkFnQkwsTUFBTTs4QkFNTixNQUFNO3lCQUdOLE1BQU07Ozs7SUE3Q1Asd0NBQTZDOzs7OztJQUU3QyxrQ0FBd0I7Ozs7O0lBZXhCLHFDQUEwQzs7Ozs7O0lBbUIxQyx1Q0FBbUY7Ozs7OztJQU1uRiwwQ0FBb0c7Ozs7O0lBR3BHLHFDQUF1RiIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IERpcmVjdGl2ZSwgT3V0cHV0LCBFdmVudEVtaXR0ZXIsIElucHV0LCBPbkRlc3Ryb3kgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IFN1YmplY3QgfSBmcm9tICdyeGpzJztcblxuZXhwb3J0IHR5cGUgU29ydERpcmVjdGlvbiA9ICdhc2MnIHwgJ2Rlc2MnO1xuXG5leHBvcnQgY2xhc3MgU29ydEV2ZW50IHtcbiAgLyoqIFRoZSBuYW1lIG9mIHRoZSBjb2x1bW4gdGhhdCBpcyBiZWluZyBzb3J0ZWQgYnkuICovXG4gIGFjdGl2ZTogc3RyaW5nO1xuXG4gIC8qKiBUaGUgc29ydCBkaXJlY3Rpb24uICovXG4gIGRpcmVjdGlvbjogU29ydERpcmVjdGlvbjtcblxuICBjb25zdHJ1Y3RvcihhY3RpdmUsIGRpcmVjdGlvbikge1xuICAgIHRoaXMuYWN0aXZlID0gYWN0aXZlO1xuICAgIHRoaXMuZGlyZWN0aW9uID0gZGlyZWN0aW9uO1xuICB9XG59XG5cbkBEaXJlY3RpdmUoe1xuICBzZWxlY3RvcjogJ3RhYmxlW254U29ydF0nLFxuICBleHBvcnRBczogJ054U29ydERpcmVjdGl2ZSdcbn0pXG5leHBvcnQgY2xhc3MgTnhTb3J0RGlyZWN0aXZlIGltcGxlbWVudHMgT25EZXN0cm95IHtcblxuICByZWFkb25seSBfc3RhdGVDaGFuZ2VzID0gbmV3IFN1YmplY3Q8dm9pZD4oKTtcblxuICBwcml2YXRlIF9hY3RpdmU6IHN0cmluZztcblxuICAvKiogU2V0cyB0aGUga2V5IG9mIHRoZSBtb3N0IHJlY2VudGx5IHNvcnRlZCBjb2x1bW4uICovXG4gIEBJbnB1dCgpXG4gIHNldCBhY3RpdmUodmFsdWU6IHN0cmluZykge1xuICAgIGlmICh0aGlzLl9hY3RpdmUgIT09IHZhbHVlKSB7XG4gICAgICB0aGlzLl9hY3RpdmUgPSB2YWx1ZTtcbiAgICAgIHRoaXMuc29ydENoYW5nZS5lbWl0KG5ldyBTb3J0RXZlbnQodGhpcy5hY3RpdmUsIHRoaXMuZGlyZWN0aW9uKSk7XG4gICAgICB0aGlzLl9zdGF0ZUNoYW5nZXMubmV4dCgpO1xuICAgIH1cbiAgfVxuICBnZXQgYWN0aXZlKCk6IHN0cmluZyB7XG4gICAgcmV0dXJuIHRoaXMuX2FjdGl2ZTtcbiAgfVxuXG4gIHByaXZhdGUgX2RpcmVjdGlvbjogU29ydERpcmVjdGlvbiA9ICdhc2MnO1xuXG4gIC8qKiBTZXRzIHRoZSBkaXJlY3Rpb24gb2YgdGhlIGN1cnJlbnRseSBhY3RpdmUgc29ydGVkIGNvbHVtbi4gRGVmYXVsdDogJ2FzYycuICovXG4gIEBJbnB1dCgpXG4gIHNldCBkaXJlY3Rpb24odmFsdWU6IFNvcnREaXJlY3Rpb24pIHtcbiAgICBpZiAodGhpcy5fZGlyZWN0aW9uICE9PSB2YWx1ZSkge1xuICAgICAgdGhpcy5fZGlyZWN0aW9uID0gdmFsdWU7XG4gICAgICB0aGlzLnNvcnRDaGFuZ2UuZW1pdChuZXcgU29ydEV2ZW50KHRoaXMuYWN0aXZlLCB0aGlzLmRpcmVjdGlvbikpO1xuICAgICAgdGhpcy5fc3RhdGVDaGFuZ2VzLm5leHQoKTtcbiAgICB9XG4gIH1cbiAgZ2V0IGRpcmVjdGlvbigpOiBTb3J0RGlyZWN0aW9uIHtcbiAgICByZXR1cm4gdGhpcy5fZGlyZWN0aW9uO1xuICB9XG5cbiAgLyoqXG4gICAqIEBkb2NzLXByaXZhdGVcbiAgICogQW4gZXZlbnQgZW1pdHRlZCB3aGVuIHRoZSBhY3RpdmUgdmFsdWUgaGFzIGNoYW5nZWQuXG4gICAqL1xuICBAT3V0cHV0KCkgcmVhZG9ubHkgYWN0aXZlQ2hhbmdlOiBFdmVudEVtaXR0ZXI8c3RyaW5nPiA9IG5ldyBFdmVudEVtaXR0ZXI8c3RyaW5nPigpO1xuXG4gIC8qKlxuICAgKiBAZG9jcy1wcml2YXRlXG4gICAqIEFuIGV2ZW50IGVtaXR0ZWQgd2hlbiB0aGUgZGlyZWN0aW9uIHZhbHVlIGhhcyBjaGFuZ2VkLlxuICAgKi9cbiAgQE91dHB1dCgpIHJlYWRvbmx5IGRpcmVjdGlvbkNoYW5nZTogRXZlbnRFbWl0dGVyPFNvcnREaXJlY3Rpb24+ID0gbmV3IEV2ZW50RW1pdHRlcjxTb3J0RGlyZWN0aW9uPigpO1xuXG4gIC8qKiBBbiBldmVudCBlbWl0dGVkIHdoZW4gZWl0aGVyIHRoZSBhY3RpdmUgc29ydCBvciBzb3J0IGRpcmVjdGlvbiBjaGFuZ2VzLiAqL1xuICBAT3V0cHV0KCkgcmVhZG9ubHkgc29ydENoYW5nZTogRXZlbnRFbWl0dGVyPFNvcnRFdmVudD4gPSBuZXcgRXZlbnRFbWl0dGVyPFNvcnRFdmVudD4oKTtcblxuICBuZ09uRGVzdHJveSgpIHtcbiAgICB0aGlzLl9zdGF0ZUNoYW5nZXMuY29tcGxldGUoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIHRoZSBhY3RpdmUgc29ydCBrZXkgYW5kIGRldGVybWluZXMgdGhlIG5ldyBzb3J0IGRpcmVjdGlvbi5cbiAgICogQWZ0ZXJ3YXJkcyB0aGUgb3V0cHV0IGV2ZW50IGBzb3J0Q2hhbmdlYCBpcyBjYWxsZWQuXG4gICAqXG4gICAqIElmIGBzb3J0YWJsZWAgaXMgbm90IHRoZSBrZXkgb2YgdGhlIGFjdGl2ZSBzb3J0IGhlYWRlciwgdGhlIGluaXRpYWwgZGlyZWN0aW9uIHRvIHNvcnQgaXMgJ2FzYycuXG4gICAqIE90aGVyd2lzZSB0aGUgZGlyZWN0aW9uIG9mIHRoZSBzb3J0ZWQgY29sdW1uIGNoYW5nZXMuXG4gICAqL1xuICBzb3J0KHNvcnRhYmxlOiBzdHJpbmcpOiB2b2lkIHtcbiAgICBpZiAodGhpcy5fYWN0aXZlICE9PSBzb3J0YWJsZSkge1xuICAgICAgdGhpcy5fYWN0aXZlID0gc29ydGFibGU7XG4gICAgICB0aGlzLmFjdGl2ZUNoYW5nZS5lbWl0KHRoaXMuYWN0aXZlKTtcbiAgICAgIHRoaXMuX2RpcmVjdGlvbiA9ICdhc2MnO1xuICAgICAgdGhpcy5kaXJlY3Rpb25DaGFuZ2UuZW1pdCh0aGlzLmRpcmVjdGlvbik7XG4gICAgfSBlbHNlIGlmICh0aGlzLl9kaXJlY3Rpb24gPT09ICdhc2MnKSB7XG4gICAgICB0aGlzLl9kaXJlY3Rpb24gPSAnZGVzYyc7XG4gICAgICB0aGlzLmRpcmVjdGlvbkNoYW5nZS5lbWl0KHRoaXMuZGlyZWN0aW9uKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fZGlyZWN0aW9uID0gJ2FzYyc7XG4gICAgICB0aGlzLmRpcmVjdGlvbkNoYW5nZS5lbWl0KHRoaXMuZGlyZWN0aW9uKTtcbiAgICB9XG5cbiAgICB0aGlzLnNvcnRDaGFuZ2UuZW1pdChuZXcgU29ydEV2ZW50KHRoaXMuYWN0aXZlLCB0aGlzLmRpcmVjdGlvbikpO1xuICAgIHRoaXMuX3N0YXRlQ2hhbmdlcy5uZXh0KCk7XG4gIH1cblxufVxuIl19