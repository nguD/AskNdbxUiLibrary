/**
 * @fileoverview added by tsickle
 * Generated from: copytext/copytext.component.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import { ChangeDetectionStrategy, Component, Input } from '@angular/core';
/** @type {?} */
const DEFAULT_TYPE = 'normal';
export class NxCopytextComponent {
    constructor() {
        /**
         * \@docs-private
         */
        this.type = DEFAULT_TYPE;
        /**
         * \@docs-private
         */
        this.negative = false;
    }
    /**
     * Sets the type and whether the negative set of styling should be used.
     *
     * You can combine the values of type NxCopytextType and 'negative'.
     *
     * Default type: 'normal'
     * @param {?} value
     * @return {?}
     */
    set classNames(value) {
        if (this._classNames === value) {
            return;
        }
        this._classNames = value;
        const [type = null] = this._classNames.match(/small|medium|normal|large/) || [DEFAULT_TYPE];
        this.type = (/** @type {?} */ (type));
        this.negative = !!this._classNames.match(/negative/);
    }
    /**
     * @return {?}
     */
    get classNames() {
        return this._classNames;
    }
}
NxCopytextComponent.decorators = [
    { type: Component, args: [{
                // tslint:disable-next-line:component-selector
                selector: 'p[nxCopytext]',
                template: `<ng-content></ng-content>`,
                changeDetection: ChangeDetectionStrategy.OnPush,
                host: {
                    '[class.nx-copy]': 'true',
                    '[class.nx-copy--small]': 'type === "small"',
                    '[class.nx-copy--medium]': 'type === "medium"',
                    '[class.nx-copy--normal]': 'type === "normal"',
                    '[class.nx-copy--large]': 'type === "large"',
                    '[class.nx-copy--negative]': 'negative',
                },
                styles: [":host{margin:0 0 32px;font-size:16px;font-size:var(--paragraph-03-font-size,16px);line-height:24px;line-height:var(--paragraph-03-line-height,24px);font-weight:400;font-weight:var(--paragraph-03-font-weight,400);letter-spacing:0;letter-spacing:var(--paragraph-03-letter-spacing,0)}:host.nx-copy.nx-copy{font-weight:400}:host(.nx-copy--negative){color:#fff}:host(.nx-copy--small){font-size:12px;font-size:var(--paragraph-05-font-size,12px);line-height:16px;line-height:var(--paragraph-05-line-height,16px);font-weight:600;font-weight:var(--paragraph-05-font-weight,600);letter-spacing:.5px;letter-spacing:var(--paragraph-05-letter-spacing,.5px)}:host(.nx-copy--medium){font-size:14px;font-size:var(--paragraph-04-font-size,14px);line-height:20px;line-height:var(--paragraph-04-line-height,20px);font-weight:600;font-weight:var(--paragraph-04-font-weight,600);letter-spacing:.2px;letter-spacing:var(--paragraph-04-letter-spacing,.2px)}:host(.nx-copy--large){font-size:18px;font-size:var(--paragraph-02-font-size,18px);line-height:24px;line-height:var(--paragraph-02-line-height,24px);font-weight:400;font-weight:var(--paragraph-02-font-weight,400);letter-spacing:.2px;letter-spacing:var(--paragraph-02-letter-spacing,.2px)}"]
            }] }
];
NxCopytextComponent.propDecorators = {
    classNames: [{ type: Input, args: ['nxCopytext',] }]
};
if (false) {
    /**
     * @type {?}
     * @private
     */
    NxCopytextComponent.prototype._classNames;
    /**
     * \@docs-private
     * @type {?}
     */
    NxCopytextComponent.prototype.type;
    /**
     * \@docs-private
     * @type {?}
     */
    NxCopytextComponent.prototype.negative;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY29weXRleHQuY29tcG9uZW50LmpzIiwic291cmNlUm9vdCI6Im5nOi8vQGFsbGlhbnovbmd4LW5kYngvIiwic291cmNlcyI6WyJjb3B5dGV4dC9jb3B5dGV4dC5jb21wb25lbnQudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQSxPQUFPLEVBQUUsdUJBQXVCLEVBQUUsU0FBUyxFQUFFLEtBQUssRUFBRSxNQUFNLGVBQWUsQ0FBQzs7TUFLcEUsWUFBWSxHQUFHLFFBQVE7QUFpQjdCLE1BQU0sT0FBTyxtQkFBbUI7SUFmaEM7Ozs7UUFtQkUsU0FBSSxHQUFtQixZQUFZLENBQUM7Ozs7UUFHcEMsYUFBUSxHQUFZLEtBQUssQ0FBQztJQXlCNUIsQ0FBQzs7Ozs7Ozs7OztJQWhCQyxJQUNJLFVBQVUsQ0FBQyxLQUFhO1FBQzFCLElBQUksSUFBSSxDQUFDLFdBQVcsS0FBSyxLQUFLLEVBQUU7WUFDOUIsT0FBTztTQUNSO1FBQ0QsSUFBSSxDQUFDLFdBQVcsR0FBRyxLQUFLLENBQUM7Y0FDbkIsQ0FBQyxJQUFJLEdBQUcsSUFBSSxDQUFDLEdBQUcsSUFBSSxDQUFDLFdBQVcsQ0FBQyxLQUFLLENBQUMsMkJBQTJCLENBQUMsSUFBSSxDQUFDLFlBQVksQ0FBQztRQUMzRixJQUFJLENBQUMsSUFBSSxHQUFHLG1CQUFBLElBQUksRUFBa0IsQ0FBQztRQUVuQyxJQUFJLENBQUMsUUFBUSxHQUFHLENBQUMsQ0FBQyxJQUFJLENBQUMsV0FBVyxDQUFDLEtBQUssQ0FBQyxVQUFVLENBQUMsQ0FBQztJQUN2RCxDQUFDOzs7O0lBRUQsSUFBSSxVQUFVO1FBQ1osT0FBTyxJQUFJLENBQUMsV0FBVyxDQUFDO0lBQzFCLENBQUM7OztZQTdDRixTQUFTLFNBQUM7O2dCQUVULFFBQVEsRUFBRSxlQUFlO2dCQUV6QixRQUFRLEVBQUUsMkJBQTJCO2dCQUNyQyxlQUFlLEVBQUUsdUJBQXVCLENBQUMsTUFBTTtnQkFDL0MsSUFBSSxFQUFFO29CQUNKLGlCQUFpQixFQUFFLE1BQU07b0JBQ3pCLHdCQUF3QixFQUFFLGtCQUFrQjtvQkFDNUMseUJBQXlCLEVBQUUsbUJBQW1CO29CQUM5Qyx5QkFBeUIsRUFBRSxtQkFBbUI7b0JBQzlDLHdCQUF3QixFQUFFLGtCQUFrQjtvQkFDNUMsMkJBQTJCLEVBQUUsVUFBVTtpQkFDeEM7O2FBQ0Y7Ozt5QkFpQkUsS0FBSyxTQUFDLFlBQVk7Ozs7Ozs7SUFmbkIsMENBQTRCOzs7OztJQUc1QixtQ0FBb0M7Ozs7O0lBR3BDLHVDQUEwQiIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IENoYW5nZURldGVjdGlvblN0cmF0ZWd5LCBDb21wb25lbnQsIElucHV0IH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5cbi8qKiBBIHR5cGUgdGhhdCBzcGVjaWZpZXMgdGhlIGZvbnQgc2l6ZSBvZiBhIGNvcHl0ZXh0LiAqL1xuZXhwb3J0IHR5cGUgTnhDb3B5dGV4dFR5cGUgPSAnc21hbGwnIHwgJ21lZGl1bScgfCAnbm9ybWFsJyB8ICdsYXJnZSc7XG5cbmNvbnN0IERFRkFVTFRfVFlQRSA9ICdub3JtYWwnO1xuXG5AQ29tcG9uZW50KHtcbiAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOmNvbXBvbmVudC1zZWxlY3RvclxuICBzZWxlY3RvcjogJ3BbbnhDb3B5dGV4dF0nLFxuICBzdHlsZVVybHM6IFsnY29weXRleHQuY29tcG9uZW50LnNjc3MnXSxcbiAgdGVtcGxhdGU6IGA8bmctY29udGVudD48L25nLWNvbnRlbnQ+YCxcbiAgY2hhbmdlRGV0ZWN0aW9uOiBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5PblB1c2gsXG4gIGhvc3Q6IHtcbiAgICAnW2NsYXNzLm54LWNvcHldJzogJ3RydWUnLFxuICAgICdbY2xhc3MubngtY29weS0tc21hbGxdJzogJ3R5cGUgPT09IFwic21hbGxcIicsXG4gICAgJ1tjbGFzcy5ueC1jb3B5LS1tZWRpdW1dJzogJ3R5cGUgPT09IFwibWVkaXVtXCInLFxuICAgICdbY2xhc3MubngtY29weS0tbm9ybWFsXSc6ICd0eXBlID09PSBcIm5vcm1hbFwiJyxcbiAgICAnW2NsYXNzLm54LWNvcHktLWxhcmdlXSc6ICd0eXBlID09PSBcImxhcmdlXCInLFxuICAgICdbY2xhc3MubngtY29weS0tbmVnYXRpdmVdJzogJ25lZ2F0aXZlJyxcbiAgfVxufSlcbmV4cG9ydCBjbGFzcyBOeENvcHl0ZXh0Q29tcG9uZW50IHtcbiAgcHJpdmF0ZSBfY2xhc3NOYW1lczogc3RyaW5nO1xuXG4gIC8qKiBAZG9jcy1wcml2YXRlICovXG4gIHR5cGU6IE54Q29weXRleHRUeXBlID0gREVGQVVMVF9UWVBFO1xuXG4gIC8qKiBAZG9jcy1wcml2YXRlICovXG4gIG5lZ2F0aXZlOiBib29sZWFuID0gZmFsc2U7XG5cbiAgLyoqXG4gICAqIFNldHMgdGhlIHR5cGUgYW5kIHdoZXRoZXIgdGhlIG5lZ2F0aXZlIHNldCBvZiBzdHlsaW5nIHNob3VsZCBiZSB1c2VkLlxuICAgKlxuICAgKiBZb3UgY2FuIGNvbWJpbmUgdGhlIHZhbHVlcyBvZiB0eXBlIE54Q29weXRleHRUeXBlIGFuZCAnbmVnYXRpdmUnLlxuICAgKlxuICAgKiBEZWZhdWx0IHR5cGU6ICdub3JtYWwnXG4gICAqL1xuICBASW5wdXQoJ254Q29weXRleHQnKVxuICBzZXQgY2xhc3NOYW1lcyh2YWx1ZTogc3RyaW5nKSB7XG4gICAgaWYgKHRoaXMuX2NsYXNzTmFtZXMgPT09IHZhbHVlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuX2NsYXNzTmFtZXMgPSB2YWx1ZTtcbiAgICBjb25zdCBbdHlwZSA9IG51bGxdID0gdGhpcy5fY2xhc3NOYW1lcy5tYXRjaCgvc21hbGx8bWVkaXVtfG5vcm1hbHxsYXJnZS8pIHx8IFtERUZBVUxUX1RZUEVdO1xuICAgIHRoaXMudHlwZSA9IHR5cGUgYXMgTnhDb3B5dGV4dFR5cGU7XG5cbiAgICB0aGlzLm5lZ2F0aXZlID0gISF0aGlzLl9jbGFzc05hbWVzLm1hdGNoKC9uZWdhdGl2ZS8pO1xuICB9XG5cbiAgZ2V0IGNsYXNzTmFtZXMoKTogc3RyaW5nIHtcbiAgICByZXR1cm4gdGhpcy5fY2xhc3NOYW1lcztcbiAgfVxuXG59XG4iXX0=