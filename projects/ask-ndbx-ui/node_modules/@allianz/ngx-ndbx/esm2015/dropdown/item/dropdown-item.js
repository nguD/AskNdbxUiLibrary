/**
 * @fileoverview added by tsickle
 * Generated from: dropdown/item/dropdown-item.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import { ChangeDetectionStrategy, ChangeDetectorRef, Component, ElementRef, EventEmitter, Inject, Input, Optional, Output, ViewChild, } from '@angular/core';
import { Subject } from 'rxjs';
import { takeUntil } from 'rxjs/operators';
import { NxDropdownControl } from '../dropdown.control';
import { NxDropdownGroupComponent } from './../group/dropdown-group';
export class NxDropdownItemChange {
    /**
     * @param {?} item
     * @param {?=} isUserInput
     */
    constructor(item, isUserInput = false) {
        this.item = item;
        this.isUserInput = isUserInput;
    }
}
if (false) {
    /**
     * Reference to the option that emitted the event.
     * @type {?}
     */
    NxDropdownItemChange.prototype.item;
    /**
     * Whether the change in the option's value was a result of a user action.
     * @type {?}
     */
    NxDropdownItemChange.prototype.isUserInput;
}
/**
 * the unique id counter
 * @type {?}
 */
let nextId = 0;
export class NxDropdownItemComponent {
    /**
     * @param {?} _dropdown
     * @param {?} group
     * @param {?} _changeDetectorRef
     * @param {?} _elementRef
     */
    constructor(_dropdown, group, _changeDetectorRef, _elementRef) {
        this._dropdown = _dropdown;
        this.group = group;
        this._changeDetectorRef = _changeDetectorRef;
        this._elementRef = _elementRef;
        this._hidden = false;
        this._mostRecentViewValue = '';
        this._id = `nx-dropdown-item-${nextId++}`;
        this._selected = false;
        /**
         * Emits whenever the component is destroyed.
         */
        this._destroy = new Subject();
        /**
         * Event emitted when the option is selected or deselected.
         */
        // tslint:disable-next-line:no-output-on-prefix
        this.onSelectionChange = new EventEmitter();
        /**
         * Emits when the state of the option changes and any parents have to be notified.
         */
        this._stateChanges = new Subject();
        ((/** @type {?} */ (this._dropdown))).filterChanges.pipe(takeUntil(this._destroy)).subscribe((/**
         * @param {?} value
         * @return {?}
         */
        (value) => {
            this._showOrHideByFilter(value);
        }));
        // reset the hidden state when dropdown closes that on next open the user is seeing the full list again
        ((/** @type {?} */ (this._dropdown)))._closedStream.pipe(takeUntil(this._destroy)).subscribe((/**
         * @return {?}
         */
        () => {
            this._hidden = false;
        }));
    }
    /**
     * The unique ID of the option.
     * @return {?}
     */
    get id() { return this._id; }
    /**
     * Whether the item is selected.
     * @return {?}
     */
    get selected() {
        return this._selected;
    }
    /**
     * Whether the item is active.
     * @return {?}
     */
    get active() {
        return this._active;
    }
    /**
     * \@docs-private
     * Whether the parent dropdown is in multiselect mode.
     * @return {?}
     */
    get multiselect() {
        return this._dropdown && this._dropdown.isMultiSelect;
    }
    /**
     * @return {?}
     */
    ngAfterViewChecked() {
        // Since the parent dropdown component could be using the item's label to display the selected values
        // and it doesn't have a way of knowing if the item's label has changed
        // we have to check for changes in the DOM ourselves and dispatch an event. These checks are
        // relatively cheap, however we still limit them only to selected options in order to avoid
        // hitting the DOM too often.
        if (this._selected) {
            /** @type {?} */
            const viewValue = this.viewValue;
            if (viewValue !== this._mostRecentViewValue) {
                this._mostRecentViewValue = viewValue;
                this._stateChanges.next();
            }
        }
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this._stateChanges.complete();
        this._destroy.next();
        this._destroy.complete();
    }
    /**
     * @param {?} event
     * @return {?}
     */
    _onClick(event) {
        /* preventDefault to stop triggering the event twice when you click on the checkbox or the label inside the item */
        event.preventDefault();
        event.stopPropagation();
        this._selectViaInteraction();
    }
    /**
     * `Selects the option while indicating the selection came from the user. Used to
     * determine if the select's view -> model callback should be invoked.`
     * @return {?}
     */
    _selectViaInteraction() {
        this._selected = this.multiselect ? !this._selected : true;
        this._changeDetectorRef.markForCheck();
        this._emitSelectionChangeEvent(true);
    }
    /**
     * \@docs-private
     * @return {?}
     */
    show() {
        this._hidden = false;
        this._changeDetectorRef.markForCheck();
    }
    /**
     * \@docs-private
     * @return {?}
     */
    hide() {
        this._hidden = true;
        this._changeDetectorRef.markForCheck();
    }
    /**
     * @private
     * @param {?} search
     * @return {?}
     */
    _showOrHideByFilter(search) {
        /** @type {?} */
        const constraint = ((/** @type {?} */ (this._dropdown))).filterFn(search, this.viewValue);
        this._hidden = constraint ? false : true;
        this._changeDetectorRef.markForCheck();
    }
    /**
     * @return {?}
     */
    get _formattedValue() {
        return ((/** @type {?} */ (this._dropdown))).valueFormatter(this.value);
    }
    /**
     * \@docs-private
     * @return {?}
     */
    get viewValue() {
        return (this._elementRef.nativeElement.textContent || '').trim();
    }
    /**
     * \@docs-private
     * @return {?}
     */
    get elementRef() {
        return this._elementRef;
    }
    /**
     * @return {?}
     */
    select() {
        if (!this._selected) {
            this._selected = true;
            this._changeDetectorRef.markForCheck();
            this._emitSelectionChangeEvent();
        }
    }
    /**
     * \@docs-private
     * @return {?}
     */
    deselect() {
        if (this._selected) {
            this._selected = false;
            this._changeDetectorRef.markForCheck();
            this._emitSelectionChangeEvent();
        }
    }
    /**
     * \@docs-private
     * @return {?}
     */
    focus() {
        this._elementRef.nativeElement.focus();
    }
    /**
     * @private
     * @param {?=} isUserInput
     * @return {?}
     */
    _emitSelectionChangeEvent(isUserInput = false) {
        this.onSelectionChange.emit(new NxDropdownItemChange(this, isUserInput));
    }
    /**
     * \@docs-private
     * @return {?}
     */
    setActiveStyles() {
        this._active = true;
        this._changeDetectorRef.markForCheck();
    }
    /**
     * \@docs-private
     * @return {?}
     */
    setInactiveStyles() {
        this._active = false;
        this._changeDetectorRef.markForCheck();
    }
    /**
     * Returns the list item's text label. Implemented as a part of the ListKeyManagerOption.
     * \@docs-private
     * @return {?}
     */
    getLabel() {
        return this.viewValue;
    }
    /**
     * @param {?} element
     * @return {?}
     */
    _isContentEmpty(element) {
        return element.children.length === 0 && !element.textContent.trim();
    }
    /**
     * @return {?}
     */
    _onLabelChange() {
        // trigger change detection when the label content changes for the case that ng-content was empty before.
        // this is also important when the label comes in deferred, e.g. by a delayed observable,
        // then first the default label derived from the value is shown
        // and after the value from the async observable is ready we need to trigger change detection that the derived label
        // gets hidden again.
        // Notice(!): the event of (cdkObserveContent) is run outside of the ngZone
        // We run detectChanges directly here as markForCheck wasn't enough to always trigger change detection correctly
        this._changeDetectorRef.detectChanges();
    }
}
NxDropdownItemComponent.decorators = [
    { type: Component, args: [{
                selector: 'nx-dropdown-item',
                template: "<div #container class=\"nx-dropdown-results__option\"\n     [ngClass]=\"{'nx-dropdown-results__option--selected': selected}\">\n\n   <nx-checkbox *ngIf=\"multiselect\" [checked]=\"selected\">\n      <ng-container *ngTemplateOutlet=\"contentTemplate\"></ng-container>\n    </nx-checkbox>\n\n    <span *ngIf=\"!multiselect\" class=\"nx-dropdown-results__option-checkicon\">\n       <nx-icon name=\"check\" aria-hidden=\"true\"></nx-icon>\n    </span>\n\n    <ng-container *ngIf=\"!multiselect\">\n      <ng-container *ngTemplateOutlet=\"contentTemplate\"></ng-container>\n    </ng-container>\n</div>\n\n<ng-template #contentTemplate>\n  <div class=\"nx-dropdown-results__option-label\" >\n    <span #content (cdkObserveContent)=\"_onLabelChange()\">\n      <ng-content></ng-content>\n    </span>\n    <ng-container *ngIf=\"_isContentEmpty(content)\">\n      {{_formattedValue}}\n    </ng-container>\n  </div>\n</ng-template>\n",
                changeDetection: ChangeDetectionStrategy.OnPush,
                host: {
                    '[id]': 'id',
                    'role': 'option',
                    '[attr.aria-selected]': 'selected.toString()',
                    '[class.nx-hidden]': '_hidden',
                    '[class.nx-dropdown-item--active]': 'active',
                    '[class.nx-selected]': 'selected',
                    '[class.nx-multiselect]': 'multiselect',
                    '(click)': '_onClick($event)'
                },
                styles: [":host{display:block}:host(.nx-hidden){display:none}:host:first-child .nx-dropdown-results__option{padding-top:16px}:host:last-child .nx-dropdown-results__option{padding-bottom:16px}nx-checkbox{margin-bottom:0}.nx-dropdown-results__option{font-size:20px;font-size:var(--dropdown-item-font-size,20px);line-height:28px;line-height:var(--dropdown-item-line-height,28px);font-weight:400;font-weight:var(--dropdown-item-font-weight,400);letter-spacing:.2px;letter-spacing:var(--dropdown-item-letter-spacing,.2px);padding:8px 32px 8px 8px;cursor:pointer;position:relative;display:flex;max-width:100%;white-space:nowrap}.nx-dropdown-results__option-label{padding:0 12px;margin:0 -12px;color:#414141;color:var(--dropdown-item-text-color,#414141);white-space:pre-line}@media screen and (-ms-high-contrast:active){.nx-dropdown-results__option-label{-ms-high-contrast-adjust:none;color:buttonText;background-color:buttonFace;border-radius:4px}}:host(.nx-multiselect) .nx-dropdown-results__option{display:block;padding-left:32px}:host(.nx-selected):hover .nx-dropdown-results__option-checkicon,:host(.nx-selected):hover .nx-dropdown-results__option-label,:host:hover .nx-dropdown-results__option-label{color:#006192;color:var(--hover-primary,#006192)}@media screen and (-ms-high-contrast:active){:host(.nx-dropdown-item--active):not(.nx-multiselect) .nx-dropdown-results__option-label,:host:hover .nx-dropdown-results__option-label{color:highlightText;background-color:highlight}:host(.nx-dropdown-item--active):not(.nx-multiselect) .nx-dropdown-results__option-checkicon{-ms-high-contrast-adjust:none;color:highlightText;background:highlight;z-index:1}}:host(.nx-selected) .nx-dropdown-results__option-checkicon{opacity:1}:host(.nx-selected) .nx-dropdown-results__option-label{color:#414141;color:var(--dropdown-item-selected-color,#414141)}.nx-dropdown-results__option-checkicon{opacity:0;margin-right:8px;height:28px;height:var(--dropdown-item-line-height,28px);color:#414141;color:var(--dropdown-item-checkmark-color,#414141)}.nx-dropdown-results__option-checkicon nx-icon{line-height:28px;line-height:var(--dropdown-item-line-height,28px);font-size:16px}\n:host-context([data-whatinput=\"keyboard\"] .nx-dropdown__panel-body.is-stable).nx-dropdown-item--active .nx-dropdown-results__option .nx-dropdown-results__option-label {\n  border-radius: 4px;\n  box-shadow: 0 0 0 2px #ffffff, 0 0 0 6px #009DE6;\n  box-shadow: var(--focus-box-shadow, 0 0 0 2px #ffffff, 0 0 0 6px #009DE6); }\n  @media screen and (-ms-high-contrast: active) {\n    :host-context([data-whatinput=\"keyboard\"] .nx-dropdown__panel-body.is-stable).nx-dropdown-item--active .nx-dropdown-results__option .nx-dropdown-results__option-label {\n      box-shadow: 0 0 0 2px background, 0 0 0 6px windowText; } }\n\n\n:host-context([data-whatinput=\"keyboard\"] .nx-dropdown__panel-body.is-stable).nx-multiselect.nx-dropdown-item--active .nx-dropdown-results__option .nx-dropdown-results__option-label {\n  box-shadow: none; }\n  @media screen and (-ms-high-contrast: active) {\n    :host-context([data-whatinput=\"keyboard\"] .nx-dropdown__panel-body.is-stable).nx-multiselect.nx-dropdown-item--active .nx-dropdown-results__option .nx-dropdown-results__option-label {\n      box-shadow: none; } }\n\n:host-context([data-whatinput=\"keyboard\"] .nx-dropdown__panel-body.is-stable).nx-multiselect.nx-dropdown-item--active ::ng-deep .nx-checkbox__label {\n  border-radius: 4px;\n  box-shadow: 0 0 0 2px #ffffff, 0 0 0 6px #009DE6;\n  box-shadow: var(--focus-box-shadow, 0 0 0 2px #ffffff, 0 0 0 6px #009DE6); }\n  @media screen and (-ms-high-contrast: active) {\n    :host-context([data-whatinput=\"keyboard\"] .nx-dropdown__panel-body.is-stable).nx-multiselect.nx-dropdown-item--active ::ng-deep .nx-checkbox__label {\n      box-shadow: 0 0 0 2px background, 0 0 0 6px windowText; } }\n\n:host(.nx-selected.nx-dropdown-item--active) .nx-dropdown-results__option-label{padding-left:24px;margin-left:-24px}:host ::ng-deep .nx-checkbox__label{padding:0 4px;margin:0 -4px}"]
            }] }
];
/** @nocollapse */
NxDropdownItemComponent.ctorParameters = () => [
    { type: NxDropdownControl, decorators: [{ type: Inject, args: [NxDropdownControl,] }] },
    { type: NxDropdownGroupComponent, decorators: [{ type: Optional }] },
    { type: ChangeDetectorRef },
    { type: ElementRef }
];
NxDropdownItemComponent.propDecorators = {
    value: [{ type: Input, args: ['nxValue',] }],
    onSelectionChange: [{ type: Output }],
    containerElement: [{ type: ViewChild, args: ['container', { static: true },] }]
};
if (false) {
    /** @type {?} */
    NxDropdownItemComponent.prototype._hidden;
    /**
     * @type {?}
     * @private
     */
    NxDropdownItemComponent.prototype._mostRecentViewValue;
    /**
     * @type {?}
     * @private
     */
    NxDropdownItemComponent.prototype._id;
    /**
     * The value of the dropdown item.
     * You can't use undefined, null and '' (empty strings)
     * as they are sentinel values signalling empty data.
     * @type {?}
     */
    NxDropdownItemComponent.prototype.value;
    /**
     * @type {?}
     * @private
     */
    NxDropdownItemComponent.prototype._selected;
    /**
     * @type {?}
     * @private
     */
    NxDropdownItemComponent.prototype._active;
    /**
     * Emits whenever the component is destroyed.
     * @type {?}
     * @private
     */
    NxDropdownItemComponent.prototype._destroy;
    /**
     * Event emitted when the option is selected or deselected.
     * @type {?}
     */
    NxDropdownItemComponent.prototype.onSelectionChange;
    /**
     * Emits when the state of the option changes and any parents have to be notified.
     * @type {?}
     */
    NxDropdownItemComponent.prototype._stateChanges;
    /**
     * \@docs-private
     * The wrapping div in the template. Used by dropdown to use the container height for scrolling.
     * @type {?}
     */
    NxDropdownItemComponent.prototype.containerElement;
    /**
     * @type {?}
     * @private
     */
    NxDropdownItemComponent.prototype._dropdown;
    /**
     * \@docs-private
     * @type {?}
     */
    NxDropdownItemComponent.prototype.group;
    /**
     * @type {?}
     * @private
     */
    NxDropdownItemComponent.prototype._changeDetectorRef;
    /**
     * @type {?}
     * @private
     */
    NxDropdownItemComponent.prototype._elementRef;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZHJvcGRvd24taXRlbS5qcyIsInNvdXJjZVJvb3QiOiJuZzovL0BhbGxpYW56L25neC1uZGJ4LyIsInNvdXJjZXMiOlsiZHJvcGRvd24vaXRlbS9kcm9wZG93bi1pdGVtLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7O0FBQ0EsT0FBTyxFQUVMLHVCQUF1QixFQUN2QixpQkFBaUIsRUFDakIsU0FBUyxFQUNULFVBQVUsRUFDVixZQUFZLEVBQ1osTUFBTSxFQUNOLEtBQUssRUFFTCxRQUFRLEVBQ1IsTUFBTSxFQUNOLFNBQVMsR0FDVixNQUFNLGVBQWUsQ0FBQztBQUN2QixPQUFPLEVBQUUsT0FBTyxFQUFFLE1BQU0sTUFBTSxDQUFDO0FBQy9CLE9BQU8sRUFBRSxTQUFTLEVBQUUsTUFBTSxnQkFBZ0IsQ0FBQztBQUczQyxPQUFPLEVBQUUsaUJBQWlCLEVBQUUsTUFBTSxxQkFBcUIsQ0FBQztBQUN4RCxPQUFPLEVBQUUsd0JBQXdCLEVBQUUsTUFBTSwyQkFBMkIsQ0FBQztBQUVyRSxNQUFNLE9BQU8sb0JBQW9COzs7OztJQUUvQixZQUVTLElBQTZCLEVBRTdCLGNBQWMsS0FBSztRQUZuQixTQUFJLEdBQUosSUFBSSxDQUF5QjtRQUU3QixnQkFBVyxHQUFYLFdBQVcsQ0FBUTtJQUFJLENBQUM7Q0FDbEM7Ozs7OztJQUhHLG9DQUFvQzs7Ozs7SUFFcEMsMkNBQTBCOzs7Ozs7SUFJMUIsTUFBTSxHQUFHLENBQUM7QUFvQmQsTUFBTSxPQUFPLHVCQUF1Qjs7Ozs7OztJQXVEbEMsWUFDcUMsU0FBNEIsRUFFMUMsS0FBK0IsRUFDNUMsa0JBQXFDLEVBQ3JDLFdBQXVCO1FBSkksY0FBUyxHQUFULFNBQVMsQ0FBbUI7UUFFMUMsVUFBSyxHQUFMLEtBQUssQ0FBMEI7UUFDNUMsdUJBQWtCLEdBQWxCLGtCQUFrQixDQUFtQjtRQUNyQyxnQkFBVyxHQUFYLFdBQVcsQ0FBWTtRQTNEakMsWUFBTyxHQUFHLEtBQUssQ0FBQztRQUVSLHlCQUFvQixHQUFHLEVBQUUsQ0FB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QUF1QixDQUFDLE1BQU07Z0JBSS9DLElBQUksRUFBRTtvQkFDSixNQUFNLEVBQUUsSUFBSTtvQkFDWixNQUFNLEVBQUUsUUFBUTtvQkFDaEIsc0JBQXNCLEVBQUUscUJBQXFCO29CQUM3QyxtQkFBbUIsRUFBRSxTQUFTO29CQUM5QixrQ0FBa0MsRUFBRSxRQUFRO29CQUM1QyxxQkFBcUIsRUFBRSxVQUFVO29CQUNqQyx3QkFBd0IsRUFBRSxhQUFhO29CQUN2QyxTQUFTLEVBQUUsa0JBQWtCO2lCQUM5Qjs7YUFDRjs7OztZQWhDUSxpQkFBaUIsdUJBeUZyQixNQUFNLFNBQUMsaUJBQWlCO1lBeEZwQix3QkFBd0IsdUJBMEY1QixRQUFRO1lBMUdYLGlCQUFpQjtZQUVqQixVQUFVOzs7b0JBMERULEtBQUssU0FBQyxTQUFTO2dDQWdDZixNQUFNOytCQVNOLFNBQVMsU0FBQyxXQUFXLEVBQUUsRUFBRSxNQUFNLEVBQUUsSUFBSSxFQUFFOzs7O0lBcER4QywwQ0FBZ0I7Ozs7O0lBRWhCLHVEQUFrQzs7Ozs7SUFFbEMsc0NBQTZDOzs7Ozs7O0lBTzdDLHdDQUF3Qjs7Ozs7SUFLeEIsNENBQW1DOzs7OztJQU9uQywwQ0FBeUI7Ozs7OztJQWdCekIsMkNBQWdEOzs7OztJQUloRCxvREFBZ0Y7Ozs7O0lBR2hGLGdEQUE2Qzs7Ozs7O0lBTTdDLG1EQUEyRDs7Ozs7SUFHekQsNENBQStEOzs7OztJQUUvRCx3Q0FBb0Q7Ozs7O0lBQ3BELHFEQUE2Qzs7Ozs7SUFDN0MsOENBQStCIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgSGlnaGxpZ2h0YWJsZSB9IGZyb20gJ0Bhbmd1bGFyL2Nkay9hMTF5JztcbmltcG9ydCB7XG4gIEFmdGVyVmlld0NoZWNrZWQsXG4gIENoYW5nZURldGVjdGlvblN0cmF0ZWd5LFxuICBDaGFuZ2VEZXRlY3RvclJlZixcbiAgQ29tcG9uZW50LFxuICBFbGVtZW50UmVmLFxuICBFdmVudEVtaXR0ZXIsXG4gIEluamVjdCxcbiAgSW5wdXQsXG4gIE9uRGVzdHJveSxcbiAgT3B0aW9uYWwsXG4gIE91dHB1dCxcbiAgVmlld0NoaWxkLFxufSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IFN1YmplY3QgfSBmcm9tICdyeGpzJztcbmltcG9ydCB7IHRha2VVbnRpbCB9IGZyb20gJ3J4anMvb3BlcmF0b3JzJztcblxuaW1wb3J0IHsgTnhEcm9wZG93bkNvbXBvbmVudCB9IGZyb20gJy4uL2Ryb3Bkb3duJztcbmltcG9ydCB7IE54RHJvcGRvd25Db250cm9sIH0gZnJvbSAnLi4vZHJvcGRvd24uY29udHJvbCc7XG5pbXBvcnQgeyBOeERyb3Bkb3duR3JvdXBDb21wb25lbnQgfSBmcm9tICcuLy4uL2dyb3VwL2Ryb3Bkb3duLWdyb3VwJztcblxuZXhwb3J0IGNsYXNzIE54RHJvcGRvd25JdGVtQ2hhbmdlIHtcblxuICBjb25zdHJ1Y3RvcihcbiAgICAvKiogUmVmZXJlbmNlIHRvIHRoZSBvcHRpb24gdGhhdCBlbWl0dGVkIHRoZSBldmVudC4gKi9cbiAgICBwdWJsaWMgaXRlbTogTnhEcm9wZG93bkl0ZW1Db21wb25lbnQsXG4gICAgLyoqIFdoZXRoZXIgdGhlIGNoYW5nZSBpbiB0aGUgb3B0aW9uJ3MgdmFsdWUgd2FzIGEgcmVzdWx0IG9mIGEgdXNlciBhY3Rpb24uICovXG4gICAgcHVibGljIGlzVXNlcklucHV0ID0gZmFsc2UpIHsgfVxufVxuXG4vKiogdGhlIHVuaXF1ZSBpZCBjb3VudGVyICovXG5sZXQgbmV4dElkID0gMDtcblxuQENvbXBvbmVudCh7XG4gIHNlbGVjdG9yOiAnbngtZHJvcGRvd24taXRlbScsXG4gIHRlbXBsYXRlVXJsOiAnZHJvcGRvd24taXRlbS5odG1sJyxcbiAgY2hhbmdlRGV0ZWN0aW9uOiBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5PblB1c2gsXG4gIHN0eWxlVXJsczogW1xuICAgICdkcm9wZG93bi1pdGVtLnNjc3MnXG4gIF0sXG4gIGhvc3Q6IHtcbiAgICAnW2lkXSc6ICdpZCcsXG4gICAgJ3JvbGUnOiAnb3B0aW9uJyxcbiAgICAnW2F0dHIuYXJpYS1zZWxlY3RlZF0nOiAnc2VsZWN0ZWQudG9TdHJpbmcoKScsXG4gICAgJ1tjbGFzcy5ueC1oaWRkZW5dJzogJ19oaWRkZW4nLFxuICAgICdbY2xhc3MubngtZHJvcGRvd24taXRlbS0tYWN0aXZlXSc6ICdhY3RpdmUnLFxuICAgICdbY2xhc3Mubngtc2VsZWN0ZWRdJzogJ3NlbGVjdGVkJyxcbiAgICAnW2NsYXNzLm54LW11bHRpc2VsZWN0XSc6ICdtdWx0aXNlbGVjdCcsXG4gICAgJyhjbGljayknOiAnX29uQ2xpY2soJGV2ZW50KSdcbiAgfVxufSlcbmV4cG9ydCBjbGFzcyBOeERyb3Bkb3duSXRlbUNvbXBvbmVudCBpbXBsZW1lbnRzIEhpZ2hsaWdodGFibGUsIE9uRGVzdHJveSwgQWZ0ZXJWaWV3Q2hlY2tlZCB7XG4gIF9oaWRkZW4gPSBmYWxzZTtcblxuICBwcml2YXRlIF9tb3N0UmVjZW50Vmlld1ZhbHVlID0gJyc7XG5cbiAgcHJpdmF0ZSBfaWQgPSBgbngtZHJvcGRvd24taXRlbS0ke25leHRJZCsrfWA7XG5cbiAgLyoqXG4gICAqIFRoZSB2YWx1ZSBvZiB0aGUgZHJvcGRvd24gaXRlbS5cbiAgICogWW91IGNhbid0IHVzZSB1bmRlZmluZWQsIG51bGwgYW5kICcnIChlbXB0eSBzdHJpbmdzKVxuICAgKiBhcyB0aGV5IGFyZSBzZW50aW5lbCB2YWx1ZXMgc2lnbmFsbGluZyBlbXB0eSBkYXRhLlxuICAgKi9cbiAgQElucHV0KCdueFZhbHVlJykgdmFsdWU7XG5cbiAgLyoqIFRoZSB1bmlxdWUgSUQgb2YgdGhlIG9wdGlvbi4gKi9cbiAgZ2V0IGlkKCk6IHN0cmluZyB7IHJldHVybiB0aGlzLl9pZDsgfVxuXG4gIHByaXZhdGUgX3NlbGVjdGVkOiBib29sZWFuID0gZmFsc2U7XG5cbiAgLyoqIFdoZXRoZXIgdGhlIGl0ZW0gaXMgc2VsZWN0ZWQuICovXG4gIGdldCBzZWxlY3RlZCgpOiBib29sZWFuIHtcbiAgICByZXR1cm4gdGhpcy5fc2VsZWN0ZWQ7XG4gIH1cblxuICBwcml2YXRlIF9hY3RpdmU6IGJvb2xlYW47XG5cbiAgLyoqIFdoZXRoZXIgdGhlIGl0ZW0gaXMgYWN0aXZlLiAqL1xuICBnZXQgYWN0aXZlKCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0aGlzLl9hY3RpdmU7XG4gIH1cblxuICAvKipcbiAgICogQGRvY3MtcHJpdmF0ZVxuICAgKiBXaGV0aGVyIHRoZSBwYXJlbnQgZHJvcGRvd24gaXMgaW4gbXVsdGlzZWxlY3QgbW9kZS5cbiAgICovXG4gIGdldCBtdWx0aXNlbGVjdCgpOiBib29sZWFuIHtcbiAgICByZXR1cm4gdGhpcy5fZHJvcGRvd24gJiYgdGhpcy5fZHJvcGRvd24uaXNNdWx0aVNlbGVjdDtcbiAgfVxuXG4gIC8qKiBFbWl0cyB3aGVuZXZlciB0aGUgY29tcG9uZW50IGlzIGRlc3Ryb3llZC4gKi9cbiAgcHJpdmF0ZSByZWFkb25seSBfZGVzdHJveSA9IG5ldyBTdWJqZWN0PHZvaWQ+KCk7XG5cbiAgLyoqIEV2ZW50IGVtaXR0ZWQgd2hlbiB0aGUgb3B0aW9uIGlzIHNlbGVjdGVkIG9yIGRlc2VsZWN0ZWQuICovXG4gIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTpuby1vdXRwdXQtb24tcHJlZml4XG4gIEBPdXRwdXQoKSByZWFkb25seSBvblNlbGVjdGlvbkNoYW5nZSA9IG5ldyBFdmVudEVtaXR0ZXI8TnhEcm9wZG93bkl0ZW1DaGFuZ2U+KCk7XG5cbiAgLyoqIEVtaXRzIHdoZW4gdGhlIHN0YXRlIG9mIHRoZSBvcHRpb24gY2hhbmdlcyBhbmQgYW55IHBhcmVudHMgaGF2ZSB0byBiZSBub3RpZmllZC4gKi9cbiAgcmVhZG9ubHkgX3N0YXRlQ2hhbmdlcyA9IG5ldyBTdWJqZWN0PHZvaWQ+KCk7XG5cbiAgLyoqXG4gICAqIEBkb2NzLXByaXZhdGVcbiAgICogVGhlIHdyYXBwaW5nIGRpdiBpbiB0aGUgdGVtcGxhdGUuIFVzZWQgYnkgZHJvcGRvd24gdG8gdXNlIHRoZSBjb250YWluZXIgaGVpZ2h0IGZvciBzY3JvbGxpbmcuXG4gICAqL1xuICBAVmlld0NoaWxkKCdjb250YWluZXInLCB7IHN0YXRpYzogdHJ1ZSB9KSBjb250YWluZXJFbGVtZW50O1xuXG4gIGNvbnN0cnVjdG9yKFxuICAgIEBJbmplY3QoTnhEcm9wZG93bkNvbnRyb2wpIHByaXZhdGUgX2Ryb3Bkb3duOiBOeERyb3Bkb3duQ29udHJvbCxcbiAgICAvKiogQGRvY3MtcHJpdmF0ZSAqL1xuICAgIEBPcHRpb25hbCgpIHJlYWRvbmx5IGdyb3VwOiBOeERyb3Bkb3duR3JvdXBDb21wb25lbnQsXG4gICAgcHJpdmF0ZSBfY2hhbmdlRGV0ZWN0b3JSZWY6IENoYW5nZURldGVjdG9yUmVmLFxuICAgIHByaXZhdGUgX2VsZW1lbnRSZWY6IEVsZW1lbnRSZWYpIHtcbiAgICAodGhpcy5fZHJvcGRvd24gYXMgTnhEcm9wZG93bkNvbXBvbmVudCkuZmlsdGVyQ2hhbmdlcy5waXBlKHRha2VVbnRpbCh0aGlzLl9kZXN0cm95KSkuc3Vic2NyaWJlKCh2YWx1ZSkgPT4ge1xuICAgICAgdGhpcy5fc2hvd09ySGlkZUJ5RmlsdGVyKHZhbHVlKTtcbiAgICB9KTtcbiAgICAvLyByZXNldCB0aGUgaGlkZGVuIHN0YXRlIHdoZW4gZHJvcGRvd24gY2xvc2VzIHRoYXQgb24gbmV4dCBvcGVuIHRoZSB1c2VyIGlzIHNlZWluZyB0aGUgZnVsbCBsaXN0IGFnYWluXG4gICAgKHRoaXMuX2Ryb3Bkb3duIGFzIE54RHJvcGRvd25Db21wb25lbnQpLl9jbG9zZWRTdHJlYW0ucGlwZSh0YWtlVW50aWwodGhpcy5fZGVzdHJveSkpLnN1YnNjcmliZSgoKSA9PiB7XG4gICAgICB0aGlzLl9oaWRkZW4gPSBmYWxzZTtcbiAgICB9KTtcbiAgfVxuXG4gIG5nQWZ0ZXJWaWV3Q2hlY2tlZCgpIHtcbiAgICAvLyBTaW5jZSB0aGUgcGFyZW50IGRyb3Bkb3duIGNvbXBvbmVudCBjb3VsZCBiZSB1c2luZyB0aGUgaXRlbSdzIGxhYmVsIHRvIGRpc3BsYXkgdGhlIHNlbGVjdGVkIHZhbHVlc1xuICAgIC8vIGFuZCBpdCBkb2Vzbid0IGhhdmUgYSB3YXkgb2Yga25vd2luZyBpZiB0aGUgaXRlbSdzIGxhYmVsIGhhcyBjaGFuZ2VkXG4gICAgLy8gd2UgaGF2ZSB0byBjaGVjayBmb3IgY2hhbmdlcyBpbiB0aGUgRE9NIG91cnNlbHZlcyBhbmQgZGlzcGF0Y2ggYW4gZXZlbnQuIFRoZXNlIGNoZWNrcyBhcmVcbiAgICAvLyByZWxhdGl2ZWx5IGNoZWFwLCBob3dldmVyIHdlIHN0aWxsIGxpbWl0IHRoZW0gb25seSB0byBzZWxlY3RlZCBvcHRpb25zIGluIG9yZGVyIHRvIGF2b2lkXG4gICAgLy8gaGl0dGluZyB0aGUgRE9NIHRvbyBvZnRlbi5cbiAgICBpZiAodGhpcy5fc2VsZWN0ZWQpIHtcbiAgICAgIGNvbnN0IHZpZXdWYWx1ZSA9IHRoaXMudmlld1ZhbHVlO1xuXG4gICAgICBpZiAodmlld1ZhbHVlICE9PSB0aGlzLl9tb3N0UmVjZW50Vmlld1ZhbHVlKSB7XG4gICAgICAgIHRoaXMuX21vc3RSZWNlbnRWaWV3VmFsdWUgPSB2aWV3VmFsdWU7XG4gICAgICAgIHRoaXMuX3N0YXRlQ2hhbmdlcy5uZXh0KCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgbmdPbkRlc3Ryb3koKSB7XG4gICAgdGhpcy5fc3RhdGVDaGFuZ2VzLmNvbXBsZXRlKCk7XG4gICAgdGhpcy5fZGVzdHJveS5uZXh0KCk7XG4gICAgdGhpcy5fZGVzdHJveS5jb21wbGV0ZSgpO1xuICB9XG5cbiAgX29uQ2xpY2soZXZlbnQpIHtcbiAgICAvKiBwcmV2ZW50RGVmYXVsdCB0byBzdG9wIHRyaWdnZXJpbmcgdGhlIGV2ZW50IHR3aWNlIHdoZW4geW91IGNsaWNrIG9uIHRoZSBjaGVja2JveCBvciB0aGUgbGFiZWwgaW5zaWRlIHRoZSBpdGVtICovXG4gICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICB0aGlzLl9zZWxlY3RWaWFJbnRlcmFjdGlvbigpO1xuICB9XG5cbiAgLyoqXG4gICogYFNlbGVjdHMgdGhlIG9wdGlvbiB3aGlsZSBpbmRpY2F0aW5nIHRoZSBzZWxlY3Rpb24gY2FtZSBmcm9tIHRoZSB1c2VyLiBVc2VkIHRvXG4gICogZGV0ZXJtaW5lIGlmIHRoZSBzZWxlY3QncyB2aWV3IC0+IG1vZGVsIGNhbGxiYWNrIHNob3VsZCBiZSBpbnZva2VkLmBcbiAgKi9cbiAgX3NlbGVjdFZpYUludGVyYWN0aW9uKCk6IHZvaWQge1xuICAgIHRoaXMuX3NlbGVjdGVkID0gdGhpcy5tdWx0aXNlbGVjdCA/ICF0aGlzLl9zZWxlY3RlZCA6IHRydWU7XG4gICAgdGhpcy5fY2hhbmdlRGV0ZWN0b3JSZWYubWFya0ZvckNoZWNrKCk7XG4gICAgdGhpcy5fZW1pdFNlbGVjdGlvbkNoYW5nZUV2ZW50KHRydWUpO1xuICB9XG5cbiAgLyoqIEBkb2NzLXByaXZhdGUgKi9cbiAgc2hvdygpIHtcbiAgICB0aGlzLl9oaWRkZW4gPSBmYWxzZTtcbiAgICB0aGlzLl9jaGFuZ2VEZXRlY3RvclJlZi5tYXJrRm9yQ2hlY2soKTtcbiAgfVxuXG4gIC8qKiBAZG9jcy1wcml2YXRlICovXG4gIGhpZGUoKSB7XG4gICAgdGhpcy5faGlkZGVuID0gdHJ1ZTtcbiAgICB0aGlzLl9jaGFuZ2VEZXRlY3RvclJlZi5tYXJrRm9yQ2hlY2soKTtcbiAgfVxuXG4gIHByaXZhdGUgX3Nob3dPckhpZGVCeUZpbHRlcihzZWFyY2gpIHtcbiAgICBjb25zdCBjb25zdHJhaW50ID0gKHRoaXMuX2Ryb3Bkb3duIGFzIE54RHJvcGRvd25Db21wb25lbnQpLmZpbHRlckZuKHNlYXJjaCwgdGhpcy52aWV3VmFsdWUpO1xuICAgIHRoaXMuX2hpZGRlbiA9IGNvbnN0cmFpbnQgPyBmYWxzZSA6IHRydWU7XG4gICAgdGhpcy5fY2hhbmdlRGV0ZWN0b3JSZWYubWFya0ZvckNoZWNrKCk7XG4gIH1cblxuICBnZXQgX2Zvcm1hdHRlZFZhbHVlKCkge1xuICAgIHJldHVybiAodGhpcy5fZHJvcGRvd24gYXMgTnhEcm9wZG93bkNvbXBvbmVudCkudmFsdWVGb3JtYXR0ZXIodGhpcy52YWx1ZSk7XG4gIH1cblxuICAvKiogQGRvY3MtcHJpdmF0ZSAqL1xuICBnZXQgdmlld1ZhbHVlKCkge1xuICAgIHJldHVybiAodGhpcy5fZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50LnRleHRDb250ZW50IHx8ICcnKS50cmltKCk7XG4gIH1cblxuICAvKiogQGRvY3MtcHJpdmF0ZSAqL1xuICBnZXQgZWxlbWVudFJlZigpIHtcbiAgICByZXR1cm4gdGhpcy5fZWxlbWVudFJlZjtcbiAgfVxuXG4gIHNlbGVjdCgpIHtcbiAgICBpZiAoIXRoaXMuX3NlbGVjdGVkKSB7XG4gICAgICB0aGlzLl9zZWxlY3RlZCA9IHRydWU7XG4gICAgICB0aGlzLl9jaGFuZ2VEZXRlY3RvclJlZi5tYXJrRm9yQ2hlY2soKTtcbiAgICAgIHRoaXMuX2VtaXRTZWxlY3Rpb25DaGFuZ2VFdmVudCgpO1xuICAgIH1cbiAgfVxuXG4gIC8qKiBAZG9jcy1wcml2YXRlICovXG4gIGRlc2VsZWN0KCkge1xuICAgIGlmICh0aGlzLl9zZWxlY3RlZCkge1xuICAgICAgdGhpcy5fc2VsZWN0ZWQgPSBmYWxzZTtcbiAgICAgIHRoaXMuX2NoYW5nZURldGVjdG9yUmVmLm1hcmtGb3JDaGVjaygpO1xuICAgICAgdGhpcy5fZW1pdFNlbGVjdGlvbkNoYW5nZUV2ZW50KCk7XG4gICAgfVxuICB9XG5cbiAgLyoqIEBkb2NzLXByaXZhdGUgKi9cbiAgZm9jdXMoKTogdm9pZCB7XG4gICAgdGhpcy5fZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50LmZvY3VzKCk7XG4gIH1cblxuICBwcml2YXRlIF9lbWl0U2VsZWN0aW9uQ2hhbmdlRXZlbnQoaXNVc2VySW5wdXQ6IGJvb2xlYW4gPSBmYWxzZSkge1xuICAgIHRoaXMub25TZWxlY3Rpb25DaGFuZ2UuZW1pdChuZXcgTnhEcm9wZG93bkl0ZW1DaGFuZ2UodGhpcywgaXNVc2VySW5wdXQpKTtcbiAgfVxuXG4gIC8qKiBAZG9jcy1wcml2YXRlICovXG4gIHNldEFjdGl2ZVN0eWxlcygpOiB2b2lkIHtcbiAgICB0aGlzLl9hY3RpdmUgPSB0cnVlO1xuICAgIHRoaXMuX2NoYW5nZURldGVjdG9yUmVmLm1hcmtGb3JDaGVjaygpO1xuICB9XG5cbiAgLyoqIEBkb2NzLXByaXZhdGUgKi9cbiAgc2V0SW5hY3RpdmVTdHlsZXMoKTogdm9pZCB7XG4gICAgdGhpcy5fYWN0aXZlID0gZmFsc2U7XG4gICAgdGhpcy5fY2hhbmdlRGV0ZWN0b3JSZWYubWFya0ZvckNoZWNrKCk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgbGlzdCBpdGVtJ3MgdGV4dCBsYWJlbC4gSW1wbGVtZW50ZWQgYXMgYSBwYXJ0IG9mIHRoZSBMaXN0S2V5TWFuYWdlck9wdGlvbi5cbiAgICogQGRvY3MtcHJpdmF0ZSAqL1xuICBnZXRMYWJlbCgpOiBzdHJpbmcge1xuICAgIHJldHVybiB0aGlzLnZpZXdWYWx1ZTtcbiAgfVxuXG4gIF9pc0NvbnRlbnRFbXB0eShlbGVtZW50KSB7XG4gICAgcmV0dXJuIGVsZW1lbnQuY2hpbGRyZW4ubGVuZ3RoID09PSAwICYmICFlbGVtZW50LnRleHRDb250ZW50LnRyaW0oKTtcbiAgfVxuXG4gIF9vbkxhYmVsQ2hhbmdlKCkge1xuICAgIC8vIHRyaWdnZXIgY2hhbmdlIGRldGVjdGlvbiB3aGVuIHRoZSBsYWJlbCBjb250ZW50IGNoYW5nZXMgZm9yIHRoZSBjYXNlIHRoYXQgbmctY29udGVudCB3YXMgZW1wdHkgYmVmb3JlLlxuICAgIC8vIHRoaXMgaXMgYWxzbyBpbXBvcnRhbnQgd2hlbiB0aGUgbGFiZWwgY29tZXMgaW4gZGVmZXJyZWQsIGUuZy4gYnkgYSBkZWxheWVkIG9ic2VydmFibGUsXG4gICAgLy8gdGhlbiBmaXJzdCB0aGUgZGVmYXVsdCBsYWJlbCBkZXJpdmVkIGZyb20gdGhlIHZhbHVlIGlzIHNob3duXG4gICAgLy8gYW5kIGFmdGVyIHRoZSB2YWx1ZSBmcm9tIHRoZSBhc3luYyBvYnNlcnZhYmxlIGlzIHJlYWR5IHdlIG5lZWQgdG8gdHJpZ2dlciBjaGFuZ2UgZGV0ZWN0aW9uIHRoYXQgdGhlIGRlcml2ZWQgbGFiZWxcbiAgICAvLyBnZXRzIGhpZGRlbiBhZ2Fpbi5cbiAgICAvLyBOb3RpY2UoISk6IHRoZSBldmVudCBvZiAoY2RrT2JzZXJ2ZUNvbnRlbnQpIGlzIHJ1biBvdXRzaWRlIG9mIHRoZSBuZ1pvbmVcbiAgICAvLyBXZSBydW4gZGV0ZWN0Q2hhbmdlcyBkaXJlY3RseSBoZXJlIGFzIG1hcmtGb3JDaGVjayB3YXNuJ3QgZW5vdWdoIHRvIGFsd2F5cyB0cmlnZ2VyIGNoYW5nZSBkZXRlY3Rpb24gY29ycmVjdGx5XG4gICAgdGhpcy5fY2hhbmdlRGV0ZWN0b3JSZWYuZGV0ZWN0Q2hhbmdlcygpO1xuICB9XG59XG4iXX0=