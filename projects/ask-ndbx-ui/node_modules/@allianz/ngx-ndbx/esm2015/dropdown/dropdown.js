/**
 * @fileoverview added by tsickle
 * Generated from: dropdown/dropdown.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import { NxFormfieldComponent, NxFormfieldControl } from '@allianz/ngx-ndbx/formfield';
import { ActiveDescendantKeyManager } from '@angular/cdk/a11y';
import { SelectionModel } from '@angular/cdk/collections';
import { DOWN_ARROW, END, ENTER, HOME, LEFT_ARROW, RIGHT_ARROW, SPACE, UP_ARROW, SHIFT, TAB } from '@angular/cdk/keycodes';
import { CdkConnectedOverlay } from '@angular/cdk/overlay';
import { Attribute, ChangeDetectionStrategy, ChangeDetectorRef, Component, ContentChildren, ElementRef, EventEmitter, Input, isDevMode, NgZone, Optional, Output, Self, ViewChild, TemplateRef, ContentChild, } from '@angular/core';
import { FormGroupDirective, NgControl, NgForm } from '@angular/forms';
import { defer, merge, Observable, Subject } from 'rxjs';
import { delay, filter, map, startWith, switchMap, take, takeUntil } from 'rxjs/operators';
import { getNxDropdownNonArrayValueError, getNxDropdownNonFunctionValueError } from './dropdown-errors';
import { NxDropdownControl } from './dropdown.control';
import { NxDropdownGroupComponent } from './group/dropdown-group';
import { NxDropdownItemComponent } from './item/dropdown-item';
import { NxDropdownClosedLabelDirective } from './closed-label.directive';
/**
 * Change event object that is emitted when the select value has changed.
 * @template T
 */
export class NxDropdownSelectChange {
    /**
     * @param {?} source
     * @param {?} value
     */
    constructor(source, value) {
        this.source = source;
        this.value = value;
    }
}
if (false) {
    /**
     * Reference to the select that emitted the change event.
     * @type {?}
     */
    NxDropdownSelectChange.prototype.source;
    /**
     * Current value of the select that emitted the event.
     * @type {?}
     */
    NxDropdownSelectChange.prototype.value;
}
/**
 * @return {?}
 */
function getPositions() {
    return [{
            originX: 'start',
            originY: 'top',
            overlayX: 'start',
            overlayY: 'top'
        }, {
            originX: 'start',
            originY: 'center',
            overlayX: 'start',
            overlayY: 'center'
        }, {
            originX: 'start',
            originY: 'bottom',
            overlayX: 'start',
            overlayY: 'bottom'
        }];
}
export class NxDropdownComponent extends NxDropdownControl {
    /**
     * @param {?} _changeDetectorRef
     * @param {?} _elementRef
     * @param {?} _ngZone
     * @param {?} tabIndex
     * @param {?} formFieldComponent
     * @param {?} ngControl
     * @param {?} _parentForm
     * @param {?} _parentFormGroup
     */
    constructor(_changeDetectorRef, _elementRef, _ngZone, tabIndex, formFieldComponent, ngControl, _parentForm, _parentFormGroup) {
        super();
        this._changeDetectorRef = _changeDetectorRef;
        this._elementRef = _elementRef;
        this._ngZone = _ngZone;
        this.formFieldComponent = formFieldComponent;
        this.ngControl = ngControl;
        this._parentForm = _parentForm;
        this._parentFormGroup = _parentFormGroup;
        // The dropdown currently doesn't support readonly of the NxFormfieldControl so we hardcode it here
        this.readonly = false;
        this._disabled = false;
        this._focused = false;
        /**
         * Whether or not the overlay panel is open.
         */
        this._panelOpen = false;
        /**
         * \@docs-private
         */
        this.errorState = false;
        /**
         * \@docs-private
         */
        this.isStable = false;
        /**
         * Name of this control that is used inside the formfield component
         * \@docs-private
         */
        this.controlType = 'nx-dropdown';
        /**
         * The minimal space between the viewport and the overlay
         */
        this._overlayViewportMargin = 16;
        /**
         * \@docs-private
         * Emits when internal state changes to inform formfield about it.
         */
        this.stateChanges = new Subject();
        /**
         * The IDs of child options to be passed to the aria-owns attribute.
         */
        this._optionIds = '';
        this._tabIndex = 0;
        /**
         * \@docs-private
         */
        this.currentFilter = '';
        /**
         * Label to describe the component.
         */
        this._ariaLabel = '';
        this._style = '';
        /**
         * Whether the dropdown should render in its negative style or not.
         */
        this._negative = false;
        /**
         * Whether the dropdown should be shown with an additional filter input.
         */
        this.showFilter = false;
        /**
         * Text displayed as placeholder for the filter.
         */
        this.filterPlaceholder = '';
        /**
         * Event emitted when the select panel has been toggled.
         */
        this.openedChange = new EventEmitter();
        /**
         * Event emitted when the select has been opened.
         */
        this._openedStream = this.openedChange.pipe(filter((/**
         * @param {?} o
         * @return {?}
         */
        o => o)), map((/**
         * @return {?}
         */
        () => { })));
        /**
         * Event emitted when the select has been closed.
         */
        this._closedStream = this.openedChange.pipe(filter((/**
         * @param {?} o
         * @return {?}
         */
        o => !o)), map((/**
         * @return {?}
         */
        () => { })));
        /**
         * Event emitted when the user types in the filter input.
         */
        this.filterChanges = new Subject();
        /**
         * Event that emits whenever the raw value of the select changes. This is here primarily
         * to facilitate the two-way binding for the `value` input.
         * \@docs-private
         */
        this.valueChange = new EventEmitter();
        /**
         * Event emitted when the selected value has been changed.
         */
        this.selectionChange = new EventEmitter();
        /**
         * \@docs-private
         */
        this.optionSelectionChanges = defer((/**
         * @return {?}
         */
        () => {
            if (this.options) {
                return merge(...this.options.map((/**
                 * @param {?} option
                 * @return {?}
                 */
                option => option.onSelectionChange)));
            }
            return this._ngZone.onStable
                .asObservable()
                .pipe(take(1), switchMap((/**
             * @return {?}
             */
            () => this.optionSelectionChanges)));
        }));
        /**
         * Emits whenever the component is destroyed.
         */
        this._destroy = new Subject();
        /**
         * Function that transforms the value into a string.
         * This function is used for displaying and filtering the content
         * ( Default: (value) => value ? value.toString() : null; ).
         */
        this.valueFormatter = (/**
         * @param {?} value
         * @return {?}
         */
        (value) => {
            return value == null ? '' : value.toString();
        });
        /**
         * Comparison function to specify which option is displayed. Defaults to object equality.
         */
        this._compareWith = (/**
         * @param {?} o1
         * @param {?} o2
         * @return {?}
         */
        (o1, o2) => o1 === o2);
        this._filterFn = (/**
         * @param {?} search
         * @param {?} itemValue
         * @return {?}
         */
        (search, itemValue) => {
            return itemValue.toLocaleLowerCase().indexOf(search.toLocaleLowerCase()) >= 0;
        });
        /**
         * `View -> model callback called when value changes`
         */
        this._onChange = (/**
         * @return {?}
         */
        () => { });
        /**
         * `View -> model callback called when select has been touched`
         */
        this._onTouched = (/**
         * @return {?}
         */
        () => { });
        if (this.ngControl) {
            // Note: we provide the value accessor through here, instead of
            // the `providers` to avoid running into a circular import.
            this.ngControl.valueAccessor = this;
        }
        this._positions = getPositions();
        this.tabIndex = parseInt(tabIndex, 10) || 0;
    }
    /**
     * @return {?}
     */
    get tabIndex() { return this.disabled ? -1 : this._tabIndex; }
    /**
     * @param {?} value
     * @return {?}
     */
    set tabIndex(value) {
        // If the specified tabIndex value is null or undefined, fall back to the default value.
        this._tabIndex = value != null ? value : 0;
    }
    /**
     * Selected value
     * @return {?}
     */
    get value() { return this._value; }
    /**
     * @param {?} newValue
     * @return {?}
     */
    set value(newValue) {
        if (newValue !== this._value) {
            this.writeValue(newValue);
            this._value = newValue;
            this._onChange(newValue);
        }
    }
    /**
     * Whether the dropdown is disabled.
     * @return {?}
     */
    get disabled() {
        return this._disabled;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set disabled(value) {
        this._disabled = value;
    }
    /**
     * If set to 'negative', the component is displayed with the negative set of styles.
     * @param {?} value
     * @return {?}
     */
    set styles(value) {
        if (this._style === value) {
            return;
        }
        this._style = value;
        this._negative = !!this._style.match(/negative/);
    }
    /**
     * \@docs-private
     * @return {?}
     */
    get closedDropdownLabel() {
        return this._closedDropdownLabel;
    }
    /**
     * \@docs-private
     * The currently selected option.
     * @return {?}
     */
    get selected() {
        return this.isMultiSelect ? this._selectionModel.selected : this._selectionModel.selected[0];
    }
    /**
     * \@docs-private
     * @return {?}
     */
    get panelOpen() {
        return this._panelOpen;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set panelOpen(value) {
        this._panelOpen = value;
    }
    /**
     * \@docs-private
     * @return {?}
     */
    get label() {
        return this.formFieldComponent ? this.formFieldComponent.label : '';
    }
    /**
     * Function to compare the option values with the selected values. The first argument
     * is a value from an option. The second is a value from the selection. A boolean
     * should be returned.
     * @return {?}
     */
    get compareWith() { return this._compareWith; }
    /**
     * @param {?} fn
     * @return {?}
     */
    set compareWith(fn) {
        if (typeof fn !== 'function') {
            throw getNxDropdownNonFunctionValueError();
        }
        this._compareWith = fn;
        if (this._selectionModel) {
            // A different comparator means the selection could change.
            this._initializeSelection();
        }
    }
    /**
     * Function to be used when the user types into the search filter. The first argument is the user input,
     * the second argument is the dropdown item value. The dropdown items will use this function to set their
     * visibility state.
     * A boolean should be returned.
     * @return {?}
     */
    get filterFn() { return this._filterFn; }
    /**
     * @param {?} fn
     * @return {?}
     */
    set filterFn(fn) {
        if (typeof fn !== 'function') {
            throw getNxDropdownNonFunctionValueError();
        }
        this._filterFn = fn;
    }
    /**
     * \@docs-private
     * Whether the select is focused.
     * @return {?}
     */
    get focused() {
        return this._focused || this.panelOpen;
    }
    /**
     * \@docs-private
     * @return {?}
     */
    get elementRef() {
        return this._elementRef;
    }
    /**
     * @return {?}
     */
    ngDoCheck() {
        if (this.ngControl) {
            this.updateErrorState();
        }
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this._selectionModel = new SelectionModel(this.isMultiSelect);
    }
    /**
     * @return {?}
     */
    ngAfterContentInit() {
        this._closedDropdownLabel =
            this._customClosedDropdownLabel && this._customClosedDropdownLabel.templateRef || this._defaultClosedDropdownLabel;
        this._initKeyManager();
        this._selectionModel.changed.pipe(takeUntil(this._destroy)).subscribe((/**
         * @param {?} event
         * @return {?}
         */
        event => {
            event.added.forEach((/**
             * @param {?} option
             * @return {?}
             */
            option => option.select()));
            event.removed.forEach((/**
             * @param {?} option
             * @return {?}
             */
            option => option.deselect()));
        }));
        this.options.changes.pipe(startWith(null), takeUntil(this._destroy)).subscribe((/**
         * @return {?}
         */
        () => {
            this._resetOptions();
            this._initializeSelection();
        }));
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this._destroy.next();
        this._destroy.complete();
    }
    /**
     * \@docs-private
     * @param {?} control
     * @param {?} form
     * @return {?}
     */
    isErrorState(control, form) {
        return !!(control && control.invalid && (control.touched || (form && form.submitted)));
    }
    /**
     * \@docs-private
     * @return {?}
     */
    updateErrorState() {
        /** @type {?} */
        const oldState = this.errorState;
        /** @type {?} */
        const parent = this._parentFormGroup || this._parentForm;
        /** @type {?} */
        const control = this.ngControl ? (/** @type {?} */ (this.ngControl.control)) : null;
        /** @type {?} */
        const newState = this.isErrorState(control, parent);
        if (newState !== oldState) {
            this.errorState = newState;
            this.stateChanges.next();
        }
    }
    /**
     * Sets up a key manager to listen to keyboard events on the overlay panel.
     * @private
     * @return {?}
     */
    _initKeyManager() {
        this._keyManager = new ActiveDescendantKeyManager(this.options)
            .withTypeAhead()
            .withWrap()
            .withVerticalOrientation()
            .withHorizontalOrientation('ltr')
            .skipPredicate((/**
         * @param {?} item
         * @return {?}
         */
        item => item._hidden));
        this._keyManager.tabOut.pipe(takeUntil(this._destroy)).subscribe((/**
         * @return {?}
         */
        () => {
            // Restore focus to the trigger before closing. Ensures that the focus
            // position won't be lost if the user got focus into the overlay.
            this.closePanel();
        }));
        this._keyManager.change.pipe(takeUntil(this._destroy)).subscribe((/**
         * @return {?}
         */
        () => {
            if (this._panelOpen && this.panel) {
                // Delay the auto scrolling until all items have settled otherwise the item containers might
                // not exist yet
                this._ngZone.onStable
                    .asObservable()
                    .pipe(take(1)).subscribe((/**
                 * @return {?}
                 */
                () => {
                    this._scrollActiveOptionIntoView();
                }));
            }
            else if (!this._panelOpen && !this.isMultiSelect && this._keyManager.activeItem) {
                this._keyManager.activeItem._selectViaInteraction();
            }
        }));
    }
    /**
     * @private
     * @return {?}
     */
    _resetOptions() {
        /** @type {?} */
        const changedOrDestroyed = merge(this.options.changes, this._destroy);
        this.optionSelectionChanges.pipe(takeUntil(changedOrDestroyed)).subscribe((/**
         * @param {?} event
         * @return {?}
         */
        event => {
            this._onSelect(event.item, event.isUserInput);
            if (event.isUserInput && !this.isMultiSelect && this._panelOpen) {
                this.closePanel();
            }
        }));
        // Listen to changes in the internal state of the options and react accordingly.
        // Handles cases like the labels of the selected options changing.
        merge(...this.options.map((/**
         * @param {?} option
         * @return {?}
         */
        option => option._stateChanges)))
            .pipe(takeUntil(changedOrDestroyed))
            .subscribe((/**
         * @return {?}
         */
        () => {
            // defer it for the next cycle to not run in changed after checked errors
            // the combination of dropdown-item notifying parent and when the parent
            // tries to fetch the triggerValue from the child throws these errors
            setTimeout((/**
             * @return {?}
             */
            () => {
                this._changeDetectorRef.markForCheck();
                this.stateChanges.next();
            }));
        }));
        this._setOptionIds();
    }
    /**
     * Records option IDs to pass to the aria-owns property.
     * @private
     * @return {?}
     */
    _setOptionIds() {
        this._optionIds = this.options.map((/**
         * @param {?} option
         * @return {?}
         */
        option => option.id)).join(' ');
    }
    /**
     * Invoked when an option is clicked.
     * @private
     * @param {?} option
     * @param {?} isUserInput
     * @return {?}
     */
    _onSelect(option, isUserInput) {
        /** @type {?} */
        const wasSelected = this._selectionModel.isSelected(option);
        if (option.value == null && !this.isMultiSelect) {
            option.deselect();
            this._selectionModel.clear();
            this._propagateChanges(option.value);
        }
        else {
            option.selected ? this._selectionModel.select(option) : this._selectionModel.deselect(option);
            if (isUserInput) {
                this._keyManager.setActiveItem(option);
            }
            if (this.isMultiSelect) {
                this._sortValues();
            }
        }
        if (wasSelected !== this._selectionModel.isSelected(option)) {
            this._propagateChanges();
        }
        this.stateChanges.next();
    }
    /**
     * @private
     * @return {?}
     */
    _initializeSelection() {
        // Defer setting the value in order to avoid the "Expression
        // has changed after it was checked" errors from Angular.
        Promise.resolve().then((/**
         * @return {?}
         */
        () => {
            this._setSelectionByValue(this.ngControl ? this.ngControl.value : this._value);
        }));
    }
    /**
     * Sets the selected option based on a value. If no option can be
     * found with the designated value, the select trigger is cleared.
     * @private
     * @param {?} value
     * @return {?}
     */
    _setSelectionByValue(value) {
        if (this.isMultiSelect && value) {
            if (!Array.isArray(value)) {
                throw getNxDropdownNonArrayValueError();
            }
            this._selectionModel.clear();
            value.forEach((/**
             * @param {?} currentValue
             * @return {?}
             */
            (currentValue) => this._selectValue(currentValue)));
            this._sortValues();
        }
        else {
            this._selectionModel.clear();
            /** @type {?} */
            const correspondingOption = this._selectValue(value);
            // Shift focus to the active item. Note that we shouldn't do this in multiple
            // mode, because we don't know what option the user interacted with last.
            if (correspondingOption) {
                this._keyManager.setActiveItem(correspondingOption);
            }
        }
        this._changeDetectorRef.markForCheck();
    }
    /**
     * Finds and selects and option based on its value.
     * @private
     * @param {?} value
     * @return {?} Option that has the corresponding value.
     */
    _selectValue(value) {
        /** @type {?} */
        const correspondingOption = this.options.find((/**
         * @param {?} option
         * @return {?}
         */
        (option) => {
            try {
                // Treat null as a special reset value.
                return option.value != null && this._compareWith(option.value, value);
            }
            catch (error) {
                if (isDevMode()) {
                    // Notify developers of errors in their comparator.
                    console.warn(error);
                }
                return false;
            }
        }));
        if (correspondingOption) {
            this._selectionModel.select(correspondingOption);
        }
        return correspondingOption;
    }
    /**
     * Emits change event to set the model value.
     * @private
     * @param {?=} fallbackValue
     * @return {?}
     */
    _propagateChanges(fallbackValue) {
        /** @type {?} */
        let valueToEmit = null;
        if (this.isMultiSelect) {
            valueToEmit = ((/** @type {?} */ (this.selected))).map((/**
             * @param {?} option
             * @return {?}
             */
            option => option.value));
        }
        else {
            valueToEmit = this.selected ? ((/** @type {?} */ (this.selected))).value : fallbackValue;
        }
        this._value = valueToEmit;
        this.valueChange.emit(valueToEmit);
        this._onChange(valueToEmit);
        this.selectionChange.emit(new NxDropdownSelectChange(this, valueToEmit));
        this._changeDetectorRef.markForCheck();
    }
    /**
     * Sorts the selected values in the selected based on their order in the panel.
     * @private
     * @return {?}
     */
    _sortValues() {
        if (this.isMultiSelect) {
            /** @type {?} */
            const options = this.options.toArray();
            this._selectionModel.sort((/**
             * @param {?} a
             * @param {?} b
             * @return {?}
             */
            (a, b) => options.indexOf(a) - options.indexOf(b)));
            this.stateChanges.next();
        }
    }
    /**
     * Adds a offset to the overlay position, so the formfield label and the dropdown panel header are vertically aligned.
     * @private
     * @return {?}
     */
    _updatePositionOffset() {
        /** @type {?} */
        let offset = 0;
        if (this.formFieldComponent !== null) {
            /** @type {?} */
            const formFieldRect = this.formFieldComponent.elementRef.nativeElement.getBoundingClientRect();
            /** @type {?} */
            const dropdownRect = this._elementRef.nativeElement.getBoundingClientRect();
            /** @type {?} */
            const panelHeader = this.overlayDir.overlayRef.overlayElement.querySelector('.nx-dropdown__panel-header');
            /** @type {?} */
            const panelHeaderPaddingTop = panelHeader ? parseInt(getComputedStyle(panelHeader).paddingTop, 10) : 0;
            offset = formFieldRect.top - dropdownRect.top - panelHeaderPaddingTop;
        }
        this._positions[0].offsetY = offset;
    }
    /**
     * Focuses the select element.
     * @return {?}
     */
    focus() {
        this._elementRef.nativeElement.focus();
    }
    /**
     * Opens the panel of the dropdown.
     * @return {?}
     */
    openPanel() {
        if (this.disabled || !this.options || !this.options.length || this._panelOpen) {
            return;
        }
        this._panelOpen = true;
        this._triggerRect = this.trigger.nativeElement.getBoundingClientRect();
        this._keyManager.withHorizontalOrientation(null);
        this._highlightCorrectOption();
        this._changeDetectorRef.markForCheck();
    }
    /**
     * Closes the panel of the dropdown.
     * @return {?}
     */
    closePanel() {
        if (this._panelOpen) {
            this._panelOpen = false;
            this.isStable = false;
            this._keyManager.withHorizontalOrientation('ltr');
            this._changeDetectorRef.markForCheck();
            this._onTouched();
            this.openedChange.emit(false);
            // defer the focus if the dropdown triggers actions that detach
            // a template/view from the DOM to prevent changed after checked errors
            setTimeout((/**
             * @return {?}
             */
            () => this.focus()));
        }
    }
    // calculate inital scrollTop when the dropdown opens
    // scrolls the selected item to the middle of the panel if possible
    /**
     * @private
     * @return {?}
     */
    _calculateScrollTop() {
        // reset the scrolltop to make calculation easier
        this.panelBody.nativeElement.scrollTop = 0;
        if (!this.empty) {
            /** @type {?} */
            const offset = this._getItemOffset(this._keyManager.activeItem);
            /** @type {?} */
            const panelHeight = this.panelBody.nativeElement.offsetHeight;
            /** @type {?} */
            const panelRect = this.panelBody.nativeElement.getBoundingClientRect();
            /** @type {?} */
            const middleOfPanel = panelRect.top + panelHeight / 2;
            if (offset > middleOfPanel) {
                // because we reset the scrollTop to 0 at the top we can simply take the middleOfPanel which is our
                // target position for the item and subtract it from the offset (which is now always relative to the viewport)
                this.panelBody.nativeElement.scrollTop = offset - middleOfPanel;
            }
        }
    }
    /**
     * Scrolls the active option into view.
     * @private
     * @return {?}
     */
    _scrollActiveOptionIntoView() {
        if (!this.panelOpen || !this._keyManager.activeItem) {
            return;
        }
        /** @type {?} */
        const activeItem = this._keyManager.activeItem.containerElement.nativeElement;
        /** @type {?} */
        const panel = this.panelBody.nativeElement;
        /** @type {?} */
        const panelOffset = panel.offsetTop;
        // how much the overlay is repositioned on the page
        /** @type {?} */
        const panelTopScrollPosition = panel.scrollTop;
        /** @type {?} */
        const panelHeight = panel.clientHeight;
        /** @type {?} */
        const itemTop = activeItem.offsetTop - panelOffset;
        /** @type {?} */
        const itemBottom = activeItem.offsetTop - panelOffset + activeItem.getBoundingClientRect().height;
        // item half or less visible on top
        if (itemTop < panelTopScrollPosition) {
            this.panelBody.nativeElement.scrollTop = itemTop;
            // item half or less visible on bottom
        }
        else if (itemBottom > (panelTopScrollPosition + panelHeight)) {
            this.panelBody.nativeElement.scrollTop = itemBottom - panelHeight;
        }
    }
    /**
     * \@docs-private
     * @private
     * @param {?} item
     * @return {?}
     */
    _getItemOffset(item) {
        /** @type {?} */
        const itemRect = item.containerElement.nativeElement.getBoundingClientRect();
        return itemRect.top + (itemRect.height / 2); // get position of the item's center
    }
    /**
     * \@docs-private
     * Formfield Implementation
     * @param {?} ids
     * @return {?}
     */
    setDescribedByIds(ids) {
        this.ariaDescribedby = ids.join(' ');
    }
    /**
     * \@docs-private
     * @param {?} value
     * @return {?}
     */
    setAriaLabel(value) {
        this._ariaLabel = value;
    }
    /**
     * @return {?}
     */
    _getAriaLabel() {
        return this._ariaLabel || (this.formFieldComponent ? this.formFieldComponent.label : null);
    }
    /**
     * @return {?}
     */
    get _isInOutlineField() {
        return this.formFieldComponent !== null
            && this.formFieldComponent.appearance === 'outline';
    }
    /**
     * \@docs-private
     * Whether the select has a value.
     * @return {?}
     */
    get empty() {
        return !this._selectionModel || this._selectionModel.isEmpty();
    }
    /**
     * \@docs-private
     * @return {?}
     */
    get hasValue() {
        return this._selectionModel.hasValue();
    }
    /**
     * \@docs-private
     * @return {?}
     */
    get shouldLabelFloat() {
        return this.focused || !this.empty;
    }
    /** End Formfield */
    /** ControlValueAccessor */
    /**
     * Sets the select's value. Part of the ControlValueAccessor interface
     * required to integrate with Angular's core forms API.
     *
     * @param {?} value New value to be written to the model.
     * @return {?}
     */
    writeValue(value) {
        if (this.options) {
            this._setSelectionByValue(value);
        }
    }
    /**
     * @param {?} fn
     * @return {?}
     */
    registerOnChange(fn) {
        this._onChange = fn;
    }
    /**
     * @param {?} fn
     * @return {?}
     */
    registerOnTouched(fn) {
        this._onTouched = fn;
    }
    /**
     * Disables the select. Part of the ControlValueAccessor interface required
     * to integrate with Angular's core forms API.
     *
     * @param {?} isDisabled Sets whether the component is disabled.
     * @return {?}
     */
    setDisabledState(isDisabled) {
        this.disabled = isDisabled;
        this._changeDetectorRef.markForCheck();
        this.stateChanges.next();
    }
    /**
     * End ControlValueAccessor
     * @param {?} event
     * @return {?}
     */
    _handleKeydown(event) {
        this.panelOpen ? this._handleOpenKeydown(event) : this._handleClosedKeydown(event);
    }
    /**
     * @private
     * @param {?} event
     * @return {?}
     */
    _handleClosedKeydown(event) {
        /** @type {?} */
        const keyCode = event.keyCode;
        /** @type {?} */
        const isArrowKey = keyCode === DOWN_ARROW || keyCode === UP_ARROW ||
            keyCode === LEFT_ARROW || keyCode === RIGHT_ARROW;
        /** @type {?} */
        const isOpenKey = keyCode === ENTER || keyCode === SPACE;
        // Open the select on ALT + arrow key to match the native <select>
        if (isOpenKey || ((this.isMultiSelect || event.altKey) && isArrowKey)) {
            event.preventDefault(); // prevents the page from scrolling down when pressing space
            this.openPanel();
        }
        else if (!this.isMultiSelect && !this.disabled) {
            this._keyManager.onKeydown(event);
        }
    }
    /**
     * @private
     * @param {?} event
     * @return {?}
     */
    _handleOpenKeydown(event) {
        /** @type {?} */
        const keyCode = event.keyCode;
        // if has filter all events other than the listed ones should be ignored or handled in _onFilter()
        if (!([DOWN_ARROW, UP_ARROW, HOME, END, ENTER, LEFT_ARROW, RIGHT_ARROW, SHIFT, SPACE, TAB].indexOf(keyCode) >= 0)
            && this.showFilter) {
            return;
        }
        /** @type {?} */
        const isArrowKey = keyCode === DOWN_ARROW || keyCode === UP_ARROW;
        /** @type {?} */
        const manager = this._keyManager;
        /** @type {?} */
        const allHidden = this.options.map((/**
         * @param {?} option
         * @return {?}
         */
        option => option._hidden)).every((/**
         * @param {?} option
         * @return {?}
         */
        option => Boolean(option)));
        if (keyCode === HOME || keyCode === END) {
            event.preventDefault();
            keyCode === HOME ? manager.setFirstItemActive() : manager.setLastItemActive();
        }
        else if (isArrowKey && event.altKey) {
            // Close the select on ALT + arrow key to match the native <select>
            event.preventDefault();
            this.closePanel();
        }
        else if (keyCode === ENTER && manager.activeItem && !allHidden) {
            event.preventDefault();
            manager.activeItem._selectViaInteraction();
        }
        else if (keyCode === ENTER && allHidden) {
            event.preventDefault();
            this.closePanel();
        }
        else if (!this.showFilter && keyCode === SPACE && manager.activeItem) {
            event.preventDefault();
            manager.activeItem._selectViaInteraction();
        }
        else if (keyCode === TAB) {
            this.closePanel();
        }
        else {
            /** @type {?} */
            const previouslyFocusedIndex = manager.activeItemIndex;
            manager.onKeydown(event);
            this._ngZone.onStable
                .asObservable()
                .pipe(take(1), delay(251) // we need to defer to get the new activeItemIndex. delay > debouncing of the typeAhead
            ).subscribe((/**
             * @return {?}
             */
            () => {
                this.isStable = true;
                this._changeDetectorRef.detectChanges();
            }));
            if (this.isMultiSelect && isArrowKey && event.shiftKey && manager.activeItem &&
                manager.activeItemIndex !== previouslyFocusedIndex) {
                manager.activeItem._selectViaInteraction();
            }
        }
    }
    /**
     * \@docs-private
     * @param {?} value
     * @return {?}
     */
    formatValue(value) {
        return this.valueFormatter(value);
    }
    /**
     * Called when the user types in the filter input
     * @param {?} event
     * @return {?}
     */
    _onFilter(event) {
        event.preventDefault();
        this.currentFilter = event.target.value;
        this.filterChanges.next(event.target.value);
        /** @type {?} */
        const allHidden = this.options.map((/**
         * @param {?} option
         * @return {?}
         */
        option => option._hidden)).every((/**
         * @param {?} option
         * @return {?}
         */
        option => Boolean(option)));
        if (allHidden) {
            this._keyManager.setActiveItem(null);
        }
        else {
            this._keyManager.setFirstItemActive();
        }
    }
    /**
     * \@docs-private
     * The value displayed in the trigger.
     * @return {?}
     */
    get triggerValue() {
        if (this.empty) {
            return '';
        }
        if (this.isMultiSelect) {
            /** @type {?} */
            const selectedOptions = this._selectionModel.selected.map((/**
             * @param {?} option
             * @return {?}
             */
            option => option.viewValue));
            return selectedOptions.join(', ');
        }
        return this._selectionModel.selected[0].viewValue;
    }
    /**
     * Highlights the selected item. If no option is selected, it will highlight
     * the first item instead.
     * @private
     * @return {?}
     */
    _highlightCorrectOption() {
        if (this._keyManager) {
            if (this.empty) {
                this._keyManager.setFirstItemActive();
            }
            else {
                this._keyManager.setActiveItem(this._selectionModel.selected[0]);
            }
        }
    }
    /**
     * Callback that is invoked when the overlay panel has been attached.
     * @return {?}
     */
    _onAttached() {
        this.overlayDir.positionChange.pipe(take(1)).subscribe((/**
         * @return {?}
         */
        () => {
            /** @type {?} */
            const overlayRef = this.overlayDir.overlayRef;
            /** @type {?} */
            const positionStrategy = (/** @type {?} */ (overlayRef.getConfig()
                .positionStrategy));
            this._updatePositionOffset();
            positionStrategy.withPositions(this._positions.slice());
            overlayRef.updatePosition();
            if (this._keyManager.activeItem) {
                this._calculateScrollTop();
            }
            this._changeDetectorRef.markForCheck();
            this.openedChange.emit(true);
            // If there is no item selected, the filter takes the focus.
            if (this.showFilter && !this._value) {
                this.filterInput.nativeElement.focus();
            }
            else {
                this.panelBody.nativeElement.focus();
            }
        }));
    }
    /**
     * @return {?}
     */
    _onFocus() {
        if (!this.disabled) {
            this._focused = true;
            this.stateChanges.next();
        }
    }
    /**
     * Calls the touched callback only if the panel is closed. Otherwise, the trigger will
     * "blur" to the panel when it opens, causing a false positive.
     * @return {?}
     */
    _onBlur() {
        this._focused = false;
        if (this.filterInput && this.showFilter) {
            this._clearFilter();
        }
        if (!this.disabled && !this.panelOpen) {
            this._onTouched();
            this._changeDetectorRef.markForCheck();
            this.stateChanges.next();
        }
    }
    /**
     * \@docs-private
     * @return {?}
     */
    get isFilterEmpty() {
        return this.currentFilter.length === 0;
    }
    /**
     * \@docs-private
     * @return {?}
     */
    _clearFilter() {
        this.filterInput.nativeElement.value = '';
        this.currentFilter = '';
        this.filterChanges.next('');
    }
    /**
     * \@docs-private determines the `aria-activedescendant` to be set on the host.
     * @return {?}
     */
    _getAriaActiveDescendant() {
        if (this.panelOpen && this._keyManager && this._keyManager.activeItem) {
            return this._keyManager.activeItem.id;
        }
        return null;
    }
}
NxDropdownComponent.decorators = [
    { type: Component, args: [{
                selector: 'nx-dropdown',
                template: "\n<!-- input and stuff-->\n<div cdkOverlayOrigin\n    #origin=\"cdkOverlayOrigin\"\n    class=\"nx-dropdown__container\"\n    #trigger>\n  <div class=\"nx-dropdown__rendered\">\n    <ng-container *ngTemplateOutlet=\"closedDropdownLabel\"></ng-container>\n  </div>\n  <div class=\"nx-dropdown__icon\">\n    <nx-icon class=\"nx-dropdown__chevron\" name=\"chevron-down\"></nx-icon>\n  </div>\n</div>\n\n<ng-template #defaultClosedDropdownLabel>\n  <span *ngIf=\"triggerValue\">{{ triggerValue }}</span>\n</ng-template>\n\n<!-- overlay -->\n<ng-template\n  cdkConnectedOverlay\n  cdkConnectedOverlayHasBackdrop\n  cdkConnectedOverlayBackdropClass=\"cdk-overlay-transparent-backdrop\"\n  [cdkConnectedOverlayOrigin]=\"origin\"\n  [cdkConnectedOverlayOpen]=\"panelOpen\"\n  [cdkConnectedOverlayPositions]=\"_positions\"\n  [cdkConnectedOverlayMinWidth]=\"_triggerRect?.width\"\n  [cdkConnectedOverlayFlexibleDimensions]=\"true\"\n  [cdkConnectedOverlayViewportMargin]=\"_overlayViewportMargin\"\n  [cdkConnectedOverlayPush]=\"true\"\n  (backdropClick)=\"closePanel()\"\n  (attach)=\"_onAttached()\"\n  (detach)=\"closePanel()\">\n\n  <div class=\"nx-dropdown__panel\"\n      [class.has-filter]=\"showFilter\"\n      [class.nx-dropdown__panel--in-outline-field]=\"_isInOutlineField\"\n      (keydown)=\"_handleKeydown($event)\"\n      #panel>\n    <div class=\"nx-dropdown__panel-header\" *ngIf=\"label\">\n      {{ label }}\n    </div>\n    <div class=\"nx-dropdown__filter\" *ngIf=\"showFilter\">\n      <input class=\"nx-dropdown__filter-input\"\n             [class.is-filled]=\"!isFilterEmpty\"\n             #filterInput\n             type=\"text\"\n             (input)=\"_onFilter($event)\"\n             [placeholder]=\"filterPlaceholder\"\n      >\n      <span class=\"nx-dropdown__filter-icon\" *ngIf=\"!isFilterEmpty\" (click)=\"_clearFilter()\">\n        <nx-icon name=\"close\"></nx-icon>\n      </span>\n    </div>\n\n    <div class=\"nx-dropdown__panel-body\"\n         tabindex=\"-1\"\n         role=\"listbox\"\n         #panelBody\n         [class.is-stable]=\"isStable\"\n         [attr.aria-activedescendant]=\"_getAriaActiveDescendant()\"\n         [attr.aria-multiselectable]=\"isMultiSelect\"\n    >\n        <ng-content></ng-content>\n      </div>\n  </div>\n</ng-template>\n",
                changeDetection: ChangeDetectionStrategy.OnPush,
                providers: [
                    { provide: NxDropdownControl, useExisting: NxDropdownComponent },
                    { provide: NxFormfieldControl, useExisting: NxDropdownComponent },
                ],
                host: {
                    'role': 'button',
                    '[class.nx-dropdown]': 'true',
                    '[class.is-filled]': 'hasValue',
                    '[class.has-focus]': 'focused',
                    '[class.nx-dropdown--negative]': '_negative',
                    '[class.nx-dropdown--disabled]': 'disabled',
                    '[attr.aria-describedby]': 'ariaDescribedby || null',
                    '[attr.aria-required]': 'required',
                    '[attr.aria-label]': '_getAriaLabel()',
                    'aria-haspopup': 'listbox',
                    '[attr.aria-expanded]': 'panelOpen',
                    '[attr.disabled]': 'disabled || null',
                    '[attr.tabindex]': 'tabIndex',
                    '(keydown)': '_handleKeydown($event)',
                    '(focus)': '_onFocus()',
                    '(blur)': '_onBlur()',
                    '(click)': 'openPanel()'
                },
                styles: [":host{display:block;width:100%}:host:focus{outline:0}:host(.nx-dropdown--negative):focus{font-weight:600}:host(.nx-dropdown--negative){color:#fff}.nx-dropdown__container{display:flex;justify-content:flex-end;align-items:center;height:100%;cursor:pointer}:host(.nx-dropdown--disabled) .nx-dropdown__container{cursor:not-allowed}.nx-dropdown__rendered{flex:1 1 auto;overflow:hidden;text-overflow:ellipsis;white-space:nowrap}.nx-dropdown__panel{box-shadow:0 2px 4px rgba(65,65,65,.5);border-radius:4px;min-width:100%}.nx-dropdown__panel ::ng-deep .nx-checkbox__label{font-size:20px;font-size:var(--dropdown-item-font-size,20px);line-height:28px;line-height:var(--dropdown-item-line-height,28px);font-weight:400;font-weight:var(--dropdown-item-font-weight,400);letter-spacing:.2px;letter-spacing:var(--dropdown-item-letter-spacing,.2px);display:flex;align-items:center}.nx-dropdown__panel:focus{outline:0}.nx-dropdown__panel--in-outline-field .nx-dropdown__panel-header{font-size:16px;font-size:var(--formfield-outline-label-font-size,16px);line-height:24px;line-height:var(--formfield-outline-label-line-height,24px);font-weight:600;font-weight:var(--formfield-outline-label-font-weight,600);letter-spacing:0;letter-spacing:var(--formfield-outline-label-letter-spacing,0)}.nx-dropdown__panel--in-outline-field .nx-dropdown__panel-body{max-height:calc(5 * (24px + 16px) + 16px);max-height:calc(5 * (var(--dropdown-item-outline-line-height,24px) + 16px) + 16px)}.nx-dropdown__panel--in-outline-field ::ng-deep .nx-dropdown-results__group-label{font-size:16px;font-size:var(--formfield-outline-label-font-size,16px);line-height:24px;line-height:var(--formfield-outline-label-line-height,24px);font-weight:var(--formfield-outline-label-font-weight,600);letter-spacing:0;letter-spacing:var(--formfield-outline-label-letter-spacing,0);font-style:normal;font-weight:700}.nx-dropdown__panel--in-outline-field ::ng-deep nx-dropdown-item .nx-dropdown-results__option,.nx-dropdown__panel--in-outline-field ::ng-deep nx-dropdown-item .nx-dropdown-results__option-label{font-size:16px;font-size:var(--dropdown-item-outline-font-size,16px);line-height:24px;line-height:var(--dropdown-item-outline-line-height,24px);font-weight:400;font-weight:var(--dropdown-item-outline-font-weight,400);letter-spacing:0;letter-spacing:var(--dropdown-item-outline-letter-spacing,0)}.nx-dropdown__panel--in-outline-field ::ng-deep nx-dropdown-item .nx-dropdown-results__option-checkicon{height:24px;height:var(--dropdown-item-outline-line-height,24px)}.nx-dropdown__panel--in-outline-field ::ng-deep .nx-dropdown__filter-input{font-size:16px;font-size:var(--formfield-outline-control-font-size,16px);line-height:24px;line-height:var(--formfield-outline-control-line-height,24px);font-weight:400;font-weight:var(--formfield-outline-control-font-weight,400);letter-spacing:0;letter-spacing:var(--formfield-outline-control-letter-spacing,0)}.nx-dropdown__panel--in-outline-field ::ng-deep .nx-dropdown__filter-input:empty{font-weight:300}.nx-dropdown__icon{font-size:24px;font-size:var(--dropdown-chevron-size,24px);line-height:0}.nx-dropdown__chevron{vertical-align:middle}.nx-dropdown__panel-header{font-size:12px;font-size:var(--formfield-label-font-size,12px);line-height:16px;line-height:var(--formfield-label-line-height,16px);font-weight:600;font-weight:var(--formfield-label-font-weight,600);letter-spacing:.5px;letter-spacing:var(--formfield-label-letter-spacing,.5px);color:#414141;color:var(--dropdown-panel-header-text-color,#414141);background-color:#ececec;background-color:var(--dropdown-panel-header-background-color,#ececec);padding:8px 32px;border-top-left-radius:4px;border-top-right-radius:4px;z-index:1}.nx-dropdown__panel-body{background-color:#fff;background-color:var(--dropdown-panel-background-color,#fff);max-height:calc(5 * (28px + 16px) + 16px);max-height:calc(5 * (var(--dropdown-item-line-height,28px) + 16px) + 16px);overflow-y:auto;outline:0}.nx-dropdown__filter{position:relative;padding:16px 32px 12px;background-color:#fff;background-color:var(--dropdown-panel-background-color,#fff)}.nx-dropdown__filter-input{font-size:20px;font-size:var(--formfield-control-font-size,20px);line-height:28px;line-height:var(--formfield-control-line-height,28px);font-weight:var(--formfield-control-font-weight,600);letter-spacing:.2px;letter-spacing:var(--formfield-control-letter-spacing,.2px);border:0;border-bottom:1px solid #767676;border-bottom:1px var(--dropdown-filter-input-border-color,#767676) solid;color:#414141;color:var(--dropdown-filter-input-text-color,#414141);width:100%;outline:0;background-color:transparent;padding:0 24px 3px 0;font-weight:300}.nx-dropdown__filter-input::-ms-clear{display:none}.nx-dropdown__panel.has-filter ::ng-deep nx-dropdown-item:first-of-type .nx-dropdown-results__option{padding-top:12px}.nx-dropdown__filter-icon{position:absolute;height:24px;right:32px;top:calc(16px + 1px);cursor:pointer}.nx-dropdown__filter-icon nx-icon{font-size:24px}.nx-dropdown__filter-input:focus{border-color:#007ab3;border-color:var(--dropdown-filter-input-active-border-color,#007ab3)}.nx-dropdown__filter-input.is-filled:focus{font-weight:600;color:#007ab3;color:var(--dropdown-filter-input-active-text-color,#007ab3);border-color:#007ab3;border-color:var(--dropdown-filter-input-active-border-color,#007ab3)}.nx-dropdown__filter-input.is-filled:focus+.nx-dropdown__filter-icon{color:#007ab3;color:var(--dropdown-filter-input-active-text-color,#007ab3)}@media screen and (-ms-high-contrast:active){.nx-dropdown__panel{box-shadow:0 0 0 1px windowText}.nx-dropdown__panel-header{border-bottom:1px solid windowText}.nx-dropdown__filter-input{border-bottom-color:buttonText}}"]
            }] }
];
/** @nocollapse */
NxDropdownComponent.ctorParameters = () => [
    { type: ChangeDetectorRef },
    { type: ElementRef },
    { type: NgZone },
    { type: String, decorators: [{ type: Attribute, args: ['tabindex',] }] },
    { type: NxFormfieldComponent, decorators: [{ type: Optional }] },
    { type: NgControl, decorators: [{ type: Self }, { type: Optional }] },
    { type: NgForm, decorators: [{ type: Optional }] },
    { type: FormGroupDirective, decorators: [{ type: Optional }] }
];
NxDropdownComponent.propDecorators = {
    tabIndex: [{ type: Input }],
    _ariaLabel: [{ type: Input, args: ['nxAriaLabel',] }],
    value: [{ type: Input, args: ['nxValue',] }],
    disabled: [{ type: Input, args: ['nxDisabled',] }],
    required: [{ type: Input, args: ['nxRequired',] }],
    styles: [{ type: Input, args: ['nxStyle',] }],
    showFilter: [{ type: Input, args: ['nxShowFilter',] }],
    filterPlaceholder: [{ type: Input, args: ['nxFilterPlaceholder',] }],
    openedChange: [{ type: Output }],
    _openedStream: [{ type: Output, args: ['opened',] }],
    _closedStream: [{ type: Output, args: ['closed',] }],
    filterChanges: [{ type: Output, args: ['filterInput',] }],
    valueChange: [{ type: Output, args: ['nxValueChange',] }],
    selectionChange: [{ type: Output }],
    panel: [{ type: ViewChild, args: ['panel', { static: false },] }],
    panelBody: [{ type: ViewChild, args: ['panelBody', { static: false },] }],
    trigger: [{ type: ViewChild, args: ['trigger', { static: true },] }],
    filterInput: [{ type: ViewChild, args: ['filterInput', { static: false },] }],
    overlayDir: [{ type: ViewChild, args: [CdkConnectedOverlay, { static: true },] }],
    options: [{ type: ContentChildren, args: [NxDropdownItemComponent, { descendants: true },] }],
    groups: [{ type: ContentChildren, args: [NxDropdownGroupComponent,] }],
    _customClosedDropdownLabel: [{ type: ContentChild, args: [NxDropdownClosedLabelDirective, { static: false },] }],
    _defaultClosedDropdownLabel: [{ type: ViewChild, args: ['defaultClosedDropdownLabel', { static: true },] }],
    valueFormatter: [{ type: Input, args: ['nxValueFormatter',] }],
    compareWith: [{ type: Input }],
    filterFn: [{ type: Input }]
};
if (false) {
    /** @type {?} */
    NxDropdownComponent.prototype.readonly;
    /**
     * @type {?}
     * @private
     */
    NxDropdownComponent.prototype._selectionModel;
    /**
     * @type {?}
     * @protected
     */
    NxDropdownComponent.prototype._disabled;
    /**
     * @type {?}
     * @private
     */
    NxDropdownComponent.prototype._focused;
    /**
     * Whether or not the overlay panel is open.
     * @type {?}
     * @private
     */
    NxDropdownComponent.prototype._panelOpen;
    /**
     * \@docs-private
     * @type {?}
     */
    NxDropdownComponent.prototype.errorState;
    /**
     * \@docs-private
     * @type {?}
     */
    NxDropdownComponent.prototype.isStable;
    /**
     * Name of this control that is used inside the formfield component
     * \@docs-private
     * @type {?}
     */
    NxDropdownComponent.prototype.controlType;
    /**
     * Holds the value from nxValue.
     * @type {?}
     * @private
     */
    NxDropdownComponent.prototype._value;
    /**
     * The minimal space between the viewport and the overlay
     * @type {?}
     */
    NxDropdownComponent.prototype._overlayViewportMargin;
    /**
     * The last measured value for the trigger's client bounding rect.
     * @type {?}
     */
    NxDropdownComponent.prototype._triggerRect;
    /**
     * Holds the panelWidth after panel was attached.
     * @type {?}
     */
    NxDropdownComponent.prototype._panelWidth;
    /**
     * \@docs-private
     * Emits when internal state changes to inform formfield about it.
     * @type {?}
     */
    NxDropdownComponent.prototype.stateChanges;
    /**
     * The IDs of child options to be passed to the aria-owns attribute.
     * @type {?}
     */
    NxDropdownComponent.prototype._optionIds;
    /**
     * \@docs-private
     * @type {?}
     */
    NxDropdownComponent.prototype.ariaDescribedby;
    /**
     * @type {?}
     * @private
     */
    NxDropdownComponent.prototype._tabIndex;
    /**
     * \@docs-private
     * @type {?}
     */
    NxDropdownComponent.prototype.currentFilter;
    /**
     * Label to describe the component.
     * @type {?}
     */
    NxDropdownComponent.prototype._ariaLabel;
    /**
     * Whether the component is required. This adds an aria-required label to the component.
     * @type {?}
     */
    NxDropdownComponent.prototype.required;
    /**
     * @type {?}
     * @private
     */
    NxDropdownComponent.prototype._style;
    /**
     * Whether the dropdown should render in its negative style or not.
     * @type {?}
     */
    NxDropdownComponent.prototype._negative;
    /**
     * Whether the dropdown should be shown with an additional filter input.
     * @type {?}
     */
    NxDropdownComponent.prototype.showFilter;
    /**
     * Text displayed as placeholder for the filter.
     * @type {?}
     */
    NxDropdownComponent.prototype.filterPlaceholder;
    /**
     * Event emitted when the select panel has been toggled.
     * @type {?}
     */
    NxDropdownComponent.prototype.openedChange;
    /**
     * Event emitted when the select has been opened.
     * @type {?}
     */
    NxDropdownComponent.prototype._openedStream;
    /**
     * Event emitted when the select has been closed.
     * @type {?}
     */
    NxDropdownComponent.prototype._closedStream;
    /**
     * Event emitted when the user types in the filter input.
     * @type {?}
     */
    NxDropdownComponent.prototype.filterChanges;
    /**
     * Event that emits whenever the raw value of the select changes. This is here primarily
     * to facilitate the two-way binding for the `value` input.
     * \@docs-private
     * @type {?}
     */
    NxDropdownComponent.prototype.valueChange;
    /**
     * Event emitted when the selected value has been changed.
     * @type {?}
     */
    NxDropdownComponent.prototype.selectionChange;
    /**
     * \@docs-private
     * @type {?}
     */
    NxDropdownComponent.prototype.optionSelectionChanges;
    /**
     * This position config ensures that the top "start" corner of the overlay
     * is aligned with with the top "start" of the origin by default (overlapping
     * the trigger completely). If the panel cannot fit below the trigger, it
     * will fall back to a position above the trigger.
     * @type {?}
     */
    NxDropdownComponent.prototype._positions;
    /**
     * \@docs-private
     * Panel containing the select options.
     * @type {?}
     */
    NxDropdownComponent.prototype.panel;
    /**
     * \@docs-private
     * @type {?}
     */
    NxDropdownComponent.prototype.panelBody;
    /**
     * \@docs-private
     * @type {?}
     */
    NxDropdownComponent.prototype.trigger;
    /**
     * \@docs-private
     * @type {?}
     */
    NxDropdownComponent.prototype.filterInput;
    /**
     * \@docs-private
     * Overlay pane containing the options.
     * @type {?}
     */
    NxDropdownComponent.prototype.overlayDir;
    /**
     * \@docs-private
     * @type {?}
     */
    NxDropdownComponent.prototype.options;
    /**
     * \@docs-private
     * @type {?}
     */
    NxDropdownComponent.prototype.groups;
    /** @type {?} */
    NxDropdownComponent.prototype._customClosedDropdownLabel;
    /**
     * @type {?}
     * @private
     */
    NxDropdownComponent.prototype._defaultClosedDropdownLabel;
    /**
     * @type {?}
     * @private
     */
    NxDropdownComponent.prototype._closedDropdownLabel;
    /**
     * Emits whenever the component is destroyed.
     * @type {?}
     * @private
     */
    NxDropdownComponent.prototype._destroy;
    /**
     * @type {?}
     * @private
     */
    NxDropdownComponent.prototype._keyManager;
    /**
     * Function that transforms the value into a string.
     * This function is used for displaying and filtering the content
     * ( Default: (value) => value ? value.toString() : null; ).
     * @type {?}
     */
    NxDropdownComponent.prototype.valueFormatter;
    /**
     * Comparison function to specify which option is displayed. Defaults to object equality.
     * @type {?}
     * @private
     */
    NxDropdownComponent.prototype._compareWith;
    /**
     * @type {?}
     * @private
     */
    NxDropdownComponent.prototype._filterFn;
    /**
     * `View -> model callback called when value changes`
     * @type {?}
     */
    NxDropdownComponent.prototype._onChange;
    /**
     * `View -> model callback called when select has been touched`
     * @type {?}
     */
    NxDropdownComponent.prototype._onTouched;
    /**
     * @type {?}
     * @private
     */
    NxDropdownComponent.prototype._changeDetectorRef;
    /**
     * @type {?}
     * @private
     */
    NxDropdownComponent.prototype._elementRef;
    /**
     * @type {?}
     * @private
     */
    NxDropdownComponent.prototype._ngZone;
    /**
     * @type {?}
     * @private
     */
    NxDropdownComponent.prototype.formFieldComponent;
    /**
     * \@docs-private
     * @type {?}
     */
    NxDropdownComponent.prototype.ngControl;
    /**
     * @type {?}
     * @private
     */
    NxDropdownComponent.prototype._parentForm;
    /**
     * @type {?}
     * @private
     */
    NxDropdownComponent.prototype._parentFormGroup;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZHJvcGRvd24uanMiLCJzb3VyY2VSb290Ijoibmc6Ly9AYWxsaWFuei9uZ3gtbmRieC8iLCJzb3VyY2VzIjpbImRyb3Bkb3duL2Ryb3Bkb3duLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7O0FBQUEsT0FBTyxFQUFFLG9CQUFvQixFQUFFLGtCQUFrQixFQUFFLE1BQU0sNkJBQTZCLENBQUM7QUFDdkYsT0FBTyxFQUFFLDBCQUEwQixFQUFFLE1BQU0sbUJBQW1CLENBQUM7QUFDL0QsT0FBTyxFQUFFLGNBQWMsRUFBRSxNQUFNLDBCQUEwQixDQUFDO0FBQzFELE9BQU8sRUFBRSxVQUFVLEVBQUUsR0FBRyxFQUFFLEtBQUssRUFBRSxJQUFJLEVBQUUsVUFBVSxFQUFFLFdBQVcsRUFBRSxLQUFLLEVBQUUsUUFBUSxFQUFFLEtBQUssRUFBRSxHQUFHLEVBQUUsTUFBTSx1QkFBdUIsQ0FBQztBQUMzSCxPQUFPLEVBQUUsbUJBQW1CLEVBQTZELE1BQU0sc0JBQXNCLENBQUM7QUFDdEgsT0FBTyxFQUVMLFNBQVMsRUFDVCx1QkFBdUIsRUFDdkIsaUJBQWlCLEVBQ2pCLFNBQVMsRUFDVCxlQUFlLEVBRWYsVUFBVSxFQUNWLFlBQVksRUFDWixLQUFLLEVBQ0wsU0FBUyxFQUNULE1BQU0sRUFHTixRQUFRLEVBQ1IsTUFBTSxFQUNOLElBQUksRUFDSixTQUFTLEVBQ1QsV0FBVyxFQUNYLFlBQVksR0FDYixNQUFNLGVBQWUsQ0FBQztBQUN2QixPQUFPLEVBQXFDLGtCQUFrQixFQUFFLFNBQVMsRUFBRSxNQUFNLEVBQUUsTUFBTSxnQkFBZ0IsQ0FBQztBQUMxRyxPQUFPLEVBQUUsS0FBSyxFQUFFLEtBQUssRUFBRSxVQUFVLEVBQUUsT0FBTyxFQUFFLE1BQU0sTUFBTSxDQUFDO0FBQ3pELE9BQU8sRUFBQyxLQUFLLEVBQUUsTUFBTSxFQUFFLEdBQUcsRUFBRSxTQUFTLEVBQUUsU0FBUyxFQUFFLElBQUksRUFBRSxTQUFTLEVBQUMsTUFBTSxnQkFBZ0IsQ0FBQztBQUV6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MEI7Ozs7OztJQU0xQiwwQ0FBNEI7Ozs7OztJQUc1QixxQ0FBb0I7Ozs7O0lBR3BCLHFEQUFvQzs7Ozs7SUFHcEMsMkNBQXlCOzs7OztJQUd6QiwwQ0FBb0I7Ozs7OztJQU1wQiwyQ0FBMkM7Ozs7O0lBRzNDLHlDQUF3Qjs7Ozs7SUFHeEIsOENBQXdCOzs7OztJQUV4Qix3Q0FBOEI7Ozs7O0lBRzlCLDRDQUEyQjs7Ozs7SUFVM0IseUNBQThDOzs7OztJQXVCOUMsdUNBQXVDOzs7OztJQUV2QyxxQ0FBNEI7Ozs7O0lBRTVCLHdDQUEyQjs7Ozs7SUFlM0IseUNBQW1EOzs7OztJQUduRCxnREFBNkQ7Ozs7O0lBRzdELDJDQUFxRjs7Ozs7SUFHckYsNENBQ3lEOzs7OztJQUd6RCw0Q0FDMEQ7Ozs7O0lBRzFELDRDQUFpRjs7Ozs7OztJQU9qRiwwQ0FBMkY7Ozs7O0lBRzNGLDhDQUM2Qzs7Ozs7SUFHN0MscURBUUc7Ozs7Ozs7O0lBUUgseUNBQXNDOzs7Ozs7SUFNdEMsb0NBQXlEOzs7OztJQUd6RCx3Q0FBaUU7Ozs7O0lBR2pFLHNDQUE0RDs7Ozs7SUFHNUQsMENBQXFFOzs7Ozs7SUFNckUseUNBQWtGOzs7OztJQUdsRixzQ0FBeUU7Ozs7O0lBR3pFLHFDQUFrRDs7SUFFbEQseURBQzJEOzs7OztJQUUzRCwwREFDc0Q7Ozs7O0lBTXRELG1EQUErQzs7Ozs7O0lBRy9DLHVDQUFnRDs7Ozs7SUFVaEQsMENBQXlFOzs7Ozs7O0lBZXpFLDZDQUVDOzs7Ozs7SUFRRCwyQ0FBdUQ7Ozs7O0lBb0J2RCx3Q0FFQzs7Ozs7SUEwQkQsd0NBQTRDOzs7OztJQUc1Qyx5Q0FBdUI7Ozs7O0lBUXJCLGlEQUE2Qzs7Ozs7SUFDN0MsMENBQStCOzs7OztJQUMvQixzQ0FBdUI7Ozs7O0lBRXZCLGlEQUE0RDs7Ozs7SUFFNUQsd0NBQStDOzs7OztJQUMvQywwQ0FBdUM7Ozs7O0lBQ3ZDLCtDQUF3RCIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IE54Rm9ybWZpZWxkQ29tcG9uZW50LCBOeEZvcm1maWVsZENvbnRyb2wgfSBmcm9tICdAYWxsaWFuei9uZ3gtbmRieC9mb3JtZmllbGQnO1xuaW1wb3J0IHsgQWN0aXZlRGVzY2VuZGFudEtleU1hbmFnZXIgfSBmcm9tICdAYW5ndWxhci9jZGsvYTExeSc7XG5pbXBvcnQgeyBTZWxlY3Rpb25Nb2RlbCB9IGZyb20gJ0Bhbmd1bGFyL2Nkay9jb2xsZWN0aW9ucyc7XG5pbXBvcnQgeyBET1dOX0FSUk9XLCBFTkQsIEVOVEVSLCBIT01FLCBMRUZUX0FSUk9XLCBSSUdIVF9BUlJPVywgU1BBQ0UsIFVQX0FSUk9XLCBTSElGVCwgVEFCIH0gZnJvbSAnQGFuZ3VsYXIvY2RrL2tleWNvZGVzJztcbmltcG9ydCB7IENka0Nvbm5lY3RlZE92ZXJsYXksIENvbm5lY3Rpb25Qb3NpdGlvblBhaXIsIEZsZXhpYmxlQ29ubmVjdGVkUG9zaXRpb25TdHJhdGVneSB9IGZyb20gJ0Bhbmd1bGFyL2Nkay9vdmVybGF5JztcbmltcG9ydCB7XG4gIEFmdGVyQ29udGVudEluaXQsXG4gIEF0dHJpYnV0ZSxcbiAgQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3ksXG4gIENoYW5nZURldGVjdG9yUmVmLFxuICBDb21wb25lbnQsXG4gIENvbnRlbnRDaGlsZHJlbixcbiAgRG9DaGVjayxcbiAgRWxlbWVudFJlZixcbiAgRXZlbnRFbWl0dGVyLFxuICBJbnB1dCxcbiAgaXNEZXZNb2RlLFxuICBOZ1pvbmUsXG4gIE9uRGVzdHJveSxcbiAgT25Jbml0LFxuICBPcHRpb25hbCxcbiAgT3V0cHV0LFxuICBTZWxmLFxuICBWaWV3Q2hpbGQsXG4gIFRlbXBsYXRlUmVmLFxuICBDb250ZW50Q2hpbGQsXG59IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgQ29udHJvbFZhbHVlQWNjZXNzb3IsIEZvcm1Db250cm9sLCBGb3JtR3JvdXBEaXJlY3RpdmUsIE5nQ29udHJvbCwgTmdGb3JtIH0gZnJvbSAnQGFuZ3VsYXIvZm9ybXMnO1xuaW1wb3J0IHsgZGVmZXIsIG1lcmdlLCBPYnNlcnZhYmxlLCBTdWJqZWN0IH0gZnJvbSAncnhqcyc7XG5pbXBvcnQge2RlbGF5LCBmaWx0ZXIsIG1hcCwgc3RhcnRXaXRoLCBzd2l0Y2hNYXAsIHRha2UsIHRha2VVbnRpbH0gZnJvbSAncnhqcy9vcGVyYXRvcnMnO1xuXG5pbXBvcnQgeyBnZXROeERyb3Bkb3duTm9uQXJyYXlWYWx1ZUVycm9yLCBnZXROeERyb3Bkb3duTm9uRnVuY3Rpb25WYWx1ZUVycm9yIH0gZnJvbSAnLi9kcm9wZG93bi1lcnJvcnMnO1xuaW1wb3J0IHsgTnhEcm9wZG93bkNvbnRyb2wgfSBmcm9tICcuL2Ryb3Bkb3duLmNvbnRyb2wnO1xuaW1wb3J0IHsgTnhEcm9wZG93bkdyb3VwQ29tcG9uZW50IH0gZnJvbSAnLi9ncm91cC9kcm9wZG93bi1ncm91cCc7XG5pbXBvcnQgeyBOeERyb3Bkb3duSXRlbUNoYW5nZSwgTnhEcm9wZG93bkl0ZW1Db21wb25lbnQgfSBmcm9tICcuL2l0ZW0vZHJvcGRvd24taXRlbSc7XG5pbXBvcnQgeyBOeERyb3Bkb3duQ2xvc2VkTGFiZWxEaXJlY3RpdmUgfSBmcm9tICcuL2Nsb3NlZC1sYWJlbC5kaXJlY3RpdmUnO1xuXG4vKiogQ2hhbmdlIGV2ZW50IG9iamVjdCB0aGF0IGlzIGVtaXR0ZWQgd2hlbiB0aGUgc2VsZWN0IHZhbHVlIGhhcyBjaGFuZ2VkLiAqL1xuZXhwb3J0IGNsYXNzIE54RHJvcGRvd25TZWxlY3RDaGFuZ2U8VCA9IGFueT4ge1xuICBjb25zdHJ1Y3RvcihcbiAgICAvKiogUmVmZXJlbmNlIHRvIHRoZSBzZWxlY3QgdGhhdCBlbWl0dGVkIHRoZSBjaGFuZ2UgZXZlbnQuICovXG4gICAgcHVibGljIHNvdXJjZTogTnhEcm9wZG93bkNvbXBvbmVudCxcbiAgICAvKiogQ3VycmVudCB2YWx1ZSBvZiB0aGUgc2VsZWN0IHRoYXQgZW1pdHRlZCB0aGUgZXZlbnQuICovXG4gICAgcHVibGljIHZhbHVlOiBUKSB7IH1cbn1cblxuZnVuY3Rpb24gZ2V0UG9zaXRpb25zKCk6IENvbm5lY3Rpb25Qb3NpdGlvblBhaXJbXSB7XG4gIHJldHVybiBbe1xuICAgIG9yaWdpblg6ICdzdGFydCcsXG4gICAgb3JpZ2luWTogJ3RvcCcsXG4gICAgb3ZlcmxheVg6ICdzdGFydCcsXG4gICAgb3ZlcmxheVk6ICd0b3AnXG4gIH0sIHtcbiAgICBvcmlnaW5YOiAnc3RhcnQnLFxuICAgIG9yaWdpblk6ICdjZW50ZXInLFxuICAgIG92ZXJsYXlYOiAnc3RhcnQnLFxuICAgIG92ZXJsYXlZOiAnY2VudGVyJ1xuICB9LCB7XG4gICAgb3JpZ2luWDogJ3N0YXJ0JyxcbiAgICBvcmlnaW5ZOiAnYm90dG9tJyxcbiAgICBvdmVybGF5WDogJ3N0YXJ0JyxcbiAgICBvdmVybGF5WTogJ2JvdHRvbSdcbiAgfV07XG59XG5cbkBDb21wb25lbnQoe1xuICBzZWxlY3RvcjogJ254LWRyb3Bkb3duJyxcbiAgdGVtcGxhdGVVcmw6ICdkcm9wZG93bi5odG1sJyxcbiAgY2hhbmdlRGV0ZWN0aW9uOiBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5PblB1c2gsXG4gIHN0eWxlVXJsczogWydkcm9wZG93bi5zY3NzJ10sXG4gIHByb3ZpZGVyczogW1xuICAgIHsgcHJvdmlkZTogTnhEcm9wZG93bkNvbnRyb2wsIHVzZUV4aXN0aW5nOiBOeERyb3Bkb3duQ29tcG9uZW50IH0sXG4gICAgeyBwcm92aWRlOiBOeEZvcm1maWVsZENvbnRyb2wsIHVzZUV4aXN0aW5nOiBOeERyb3Bkb3duQ29tcG9uZW50IH0sXG4gIF0sXG4gIGhvc3Q6IHtcbiAgICAncm9sZSc6ICdidXR0b24nLFxuICAgICdbY2xhc3MubngtZHJvcGRvd25dJzogJ3RydWUnLFxuICAgICdbY2xhc3MuaXMtZmlsbGVkXSc6ICdoYXNWYWx1ZScsXG4gICAgJ1tjbGFzcy5oYXMtZm9jdXNdJzogJ2ZvY3VzZWQnLFxuICAgICdbY2xhc3MubngtZHJvcGRvd24tLW5lZ2F0aXZlXSc6ICdfbmVnYXRpdmUnLFxuICAgICdbY2xhc3MubngtZHJvcGRvd24tLWRpc2FibGVkXSc6ICdkaXNhYmxlZCcsXG4gICAgJ1thdHRyLmFyaWEtZGVzY3JpYmVkYnldJzogJ2FyaWFEZXNjcmliZWRieSB8fCBudWxsJyxcbiAgICAnW2F0dHIuYXJpYS1yZXF1aXJlZF0nOiAncmVxdWlyZWQnLFxuICAgICdbYXR0ci5hcmlhLWxhYmVsXSc6ICdfZ2V0QXJpYUxhYmVsKCknLFxuICAgICdhcmlhLWhhc3BvcHVwJzogJ2xpc3Rib3gnLFxuICAgICdbYXR0ci5hcmlhLWV4cGFuZGVkXSc6ICdwYW5lbE9wZW4nLFxuICAgICdbYXR0ci5kaXNhYmxlZF0nOiAnZGlzYWJsZWQgfHwgbnVsbCcsXG4gICAgJ1thdHRyLnRhYmluZGV4XSc6ICd0YWJJbmRleCcsXG4gICAgJyhrZXlkb3duKSc6ICdfaGFuZGxlS2V5ZG93bigkZXZlbnQpJyxcbiAgICAnKGZvY3VzKSc6ICdfb25Gb2N1cygpJyxcbiAgICAnKGJsdXIpJzogJ19vbkJsdXIoKScsXG4gICAgJyhjbGljayknOiAnb3BlblBhbmVsKCknXG4gIH1cbn0pXG5leHBvcnQgY2xhc3MgTnhEcm9wZG93bkNvbXBvbmVudCBleHRlbmRzIE54RHJvcGRvd25Db250cm9sIGltcGxlbWVudHMgQ29udHJvbFZhbHVlQWNjZXNzb3IsXG4gIE9uSW5pdCwgQWZ0ZXJDb250ZW50SW5pdCwgT25EZXN0cm95LCBEb0NoZWNrIHtcblxuICAvLyBUaGUgZHJvcGRvd24gY3VycmVudGx5IGRvZXNuJ3Qgc3VwcG9ydCByZWFkb25seSBvZiB0aGUgTnhGb3JtZmllbGRDb250cm9sIHNvIHdlIGhhcmRjb2RlIGl0IGhlcmVcbiAgcmVhZG9ubHkgcmVhZG9ubHk6IGJvb2xlYW4gPSBmYWxzZTtcblxuICBwcml2YXRlIF9zZWxlY3Rpb25Nb2RlbDogU2VsZWN0aW9uTW9kZWw8TnhEcm9wZG93bkl0ZW1Db21wb25lbnQ+O1xuXG4gIHByb3RlY3RlZCBfZGlzYWJsZWQ6IGJvb2xlYW4gPSBmYWxzZTtcblxuICBwcml2YXRlIF9mb2N1c2VkOiBib29sZWFuID0gZmFsc2U7XG5cbiAgLyoqIFdoZXRoZXIgb3Igbm90IHRoZSBvdmVybGF5IHBhbmVsIGlzIG9wZW4uICovXG4gIHByaXZhdGUgX3BhbmVsT3BlbiA9IGZhbHNlO1xuXG4gIC8qKiBAZG9jcy1wcml2YXRlICovXG4gIGVycm9yU3RhdGU6IGJvb2xlYW4gPSBmYWxzZTtcblxuICAvKiogQGRvY3MtcHJpdmF0ZSAqL1xuICBpc1N0YWJsZTogYm9vbGVhbiA9IGZhbHNlO1xuXG4gIC8qKlxuICAgKiBOYW1lIG9mIHRoaXMgY29udHJvbCB0aGF0IGlzIHVzZWQgaW5zaWRlIHRoZSBmb3JtZmllbGQgY29tcG9uZW50XG4gICAqIEBkb2NzLXByaXZhdGVcbiAgICovXG4gIGNvbnRyb2xUeXBlID0gJ254LWRyb3Bkb3duJztcblxuICAvKiogSG9sZHMgdGhlIHZhbHVlIGZyb20gbnhWYWx1ZS4gKi9cbiAgcHJpdmF0ZSBfdmFsdWU6IGFueTtcblxuICAvKiogVGhlIG1pbmltYWwgc3BhY2UgYmV0d2VlbiB0aGUgdmlld3BvcnQgYW5kIHRoZSBvdmVybGF5ICovXG4gIF9vdmVybGF5Vmlld3BvcnRNYXJnaW46IG51bWJlciA9IDE2O1xuXG4gIC8qKiBUaGUgbGFzdCBtZWFzdXJlZCB2YWx1ZSBmb3IgdGhlIHRyaWdnZXIncyBjbGllbnQgYm91bmRpbmcgcmVjdC4gKi9cbiAgX3RyaWdnZXJSZWN0OiBDbGllbnRSZWN0O1xuXG4gIC8qKiBIb2xkcyB0aGUgcGFuZWxXaWR0aCBhZnRlciBwYW5lbCB3YXMgYXR0YWNoZWQuICovXG4gIF9wYW5lbFdpZHRoOiBudW1iZXI7XG5cbiAgLyoqXG4gICAqIEBkb2NzLXByaXZhdGVcbiAgICogRW1pdHMgd2hlbiBpbnRlcm5hbCBzdGF0ZSBjaGFuZ2VzIHRvIGluZm9ybSBmb3JtZmllbGQgYWJvdXQgaXQuXG4gICAqL1xuICByZWFkb25seSBzdGF0ZUNoYW5nZXMgPSBuZXcgU3ViamVjdDxhbnk+KCk7XG5cbiAgLyoqIFRoZSBJRHMgb2YgY2hpbGQgb3B0aW9ucyB0byBiZSBwYXNzZWQgdG8gdGhlIGFyaWEtb3ducyBhdHRyaWJ1dGUuICovXG4gIF9vcHRpb25JZHM6IHN0cmluZyA9ICcnO1xuXG4gIC8qKiBAZG9jcy1wcml2YXRlICovXG4gIGFyaWFEZXNjcmliZWRieTogc3RyaW5nO1xuXG4gIHByaXZhdGUgX3RhYkluZGV4OiBudW1iZXIgPSAwO1xuXG4gIC8qKiBAZG9jcy1wcml2YXRlICovXG4gIGN1cnJlbnRGaWx0ZXI6IHN0cmluZyA9ICcnO1xuXG4gIEBJbnB1dCgpXG4gIGdldCB0YWJJbmRleCgpOiBudW1iZXIgeyByZXR1cm4gdGhpcy5kaXNhYmxlZCA/IC0xIDogdGhpcy5fdGFiSW5kZXg7IH1cbiAgc2V0IHRhYkluZGV4KHZhbHVlOiBudW1iZXIpIHtcbiAgICAvLyBJZiB0aGUgc3BlY2lmaWVkIHRhYkluZGV4IHZhbHVlIGlzIG51bGwgb3IgdW5kZWZpbmVkLCBmYWxsIGJhY2sgdG8gdGhlIGRlZmF1bHQgdmFsdWUuXG4gICAgdGhpcy5fdGFiSW5kZXggPSB2YWx1ZSAhPSBudWxsID8gdmFsdWUgOiAwO1xuICB9XG5cbiAgLyoqIExhYmVsIHRvIGRlc2NyaWJlIHRoZSBjb21wb25lbnQuICovXG4gIEBJbnB1dCgnbnhBcmlhTGFiZWwnKSBfYXJpYUxhYmVsOiBzdHJpbmcgPSAnJztcblxuICAvKiogU2VsZWN0ZWQgdmFsdWUgKi9cbiAgQElucHV0KCdueFZhbHVlJylcbiAgZ2V0IHZhbHVlKCk6IGFueSB7IHJldHVybiB0aGlzLl92YWx1ZTsgfVxuICBzZXQgdmFsdWUobmV3VmFsdWU6IGFueSkge1xuICAgIGlmIChuZXdWYWx1ZSAhPT0gdGhpcy5fdmFsdWUpIHtcbiAgICAgIHRoaXMud3JpdGVWYWx1ZShuZXdWYWx1ZSk7XG4gICAgICB0aGlzLl92YWx1ZSA9IG5ld1ZhbHVlO1xuICAgICAgdGhpcy5fb25DaGFuZ2UobmV3VmFsdWUpO1xuICAgIH1cbiAgfVxuXG4gIC8qKiBXaGV0aGVyIHRoZSBkcm9wZG93biBpcyBkaXNhYmxlZC4gKi9cbiAgQElucHV0KCdueERpc2FibGVkJylcbiAgZ2V0IGRpc2FibGVkKCkge1xuICAgIHJldHVybiB0aGlzLl9kaXNhYmxlZDtcbiAgfVxuICBzZXQgZGlzYWJsZWQodmFsdWU6IGJvb2xlYW4pIHtcbiAgICB0aGlzLl9kaXNhYmxlZCA9IHZhbHVlO1xuICB9XG5cbiAgLyoqIFdoZXRoZXIgdGhlIGNvbXBvbmVudCBpcyByZXF1aXJlZC4gVGhpcyBhZGRzIGFuIGFyaWEtcmVxdWlyZWQgbGFiZWwgdG8gdGhlIGNvbXBvbmVudC4gKi9cbiAgQElucHV0KCdueFJlcXVpcmVkJykgcmVxdWlyZWQ6IGJvb2xlYW47XG5cbiAgcHJpdmF0ZSBfc3R5bGU6IHN0cmluZyA9ICcnO1xuICAvKiogV2hldGhlciB0aGUgZHJvcGRvd24gc2hvdWxkIHJlbmRlciBpbiBpdHMgbmVnYXRpdmUgc3R5bGUgb3Igbm90LiAqL1xuICBfbmVnYXRpdmU6IGJvb2xlYW4gPSBmYWxzZTtcblxuICAvKiogSWYgc2V0IHRvICduZWdhdGl2ZScsIHRoZSBjb21wb25lbnQgaXMgZGlzcGxheWVkIHdpdGggdGhlIG5lZ2F0aXZlIHNldCBvZiBzdHlsZXMuICovXG4gIEBJbnB1dCgnbnhTdHlsZScpXG4gIHNldCBzdHlsZXModmFsdWU6IHN0cmluZykge1xuXG4gICAgaWYgKHRoaXMuX3N0eWxlID09PSB2YWx1ZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuX3N0eWxlID0gdmFsdWU7XG4gICAgdGhpcy5fbmVnYXRpdmUgPSAhIXRoaXMuX3N0eWxlLm1hdGNoKC9uZWdhdGl2ZS8pO1xuICB9XG5cbiAgLyoqIFdoZXRoZXIgdGhlIGRyb3Bkb3duIHNob3VsZCBiZSBzaG93biB3aXRoIGFuIGFkZGl0aW9uYWwgZmlsdGVyIGlucHV0LiAqL1xuICBASW5wdXQoJ254U2hvd0ZpbHRlcicpIHNob3dGaWx0ZXI6IGJvb2xlYW4gPSBmYWxzZTtcblxuICAvKiogVGV4dCBkaXNwbGF5ZWQgYXMgcGxhY2Vob2xkZXIgZm9yIHRoZSBmaWx0ZXIuICovXG4gIEBJbnB1dCgnbnhGaWx0ZXJQbGFjZWhvbGRlcicpIGZpbHRlclBsYWNlaG9sZGVyOiBzdHJpbmcgPSAnJztcblxuICAvKiogRXZlbnQgZW1pdHRlZCB3aGVuIHRoZSBzZWxlY3QgcGFuZWwgaGFzIGJlZW4gdG9nZ2xlZC4gKi9cbiAgQE91dHB1dCgpIHJlYWRvbmx5IG9wZW5lZENoYW5nZTogRXZlbnRFbWl0dGVyPGJvb2xlYW4+ID0gbmV3IEV2ZW50RW1pdHRlcjxib29sZWFuPigpO1xuXG4gIC8qKiBFdmVudCBlbWl0dGVkIHdoZW4gdGhlIHNlbGVjdCBoYXMgYmVlbiBvcGVuZWQuICovXG4gIEBPdXRwdXQoJ29wZW5lZCcpIHJlYWRvbmx5IF9vcGVuZWRTdHJlYW06IE9ic2VydmFibGU8dm9pZD4gPVxuICAgIHRoaXMub3BlbmVkQ2hhbmdlLnBpcGUoZmlsdGVyKG8gPT4gbyksIG1hcCgoKSA9PiB7IH0pKTtcblxuICAvKiogRXZlbnQgZW1pdHRlZCB3aGVuIHRoZSBzZWxlY3QgaGFzIGJlZW4gY2xvc2VkLiAqL1xuICBAT3V0cHV0KCdjbG9zZWQnKSByZWFkb25seSBfY2xvc2VkU3RyZWFtOiBPYnNlcnZhYmxlPHZvaWQ+ID1cbiAgICB0aGlzLm9wZW5lZENoYW5nZS5waXBlKGZpbHRlcihvID0+ICFvKSwgbWFwKCgpID0+IHsgfSkpO1xuXG4gIC8qKiBFdmVudCBlbWl0dGVkIHdoZW4gdGhlIHVzZXIgdHlwZXMgaW4gdGhlIGZpbHRlciBpbnB1dC4gKi9cbiAgQE91dHB1dCgnZmlsdGVySW5wdXQnKSByZWFkb25seSBmaWx0ZXJDaGFuZ2VzOiBTdWJqZWN0PGFueT4gPSBuZXcgU3ViamVjdDxhbnk+KCk7XG5cbiAgLyoqXG4gICAqIEV2ZW50IHRoYXQgZW1pdHMgd2hlbmV2ZXIgdGhlIHJhdyB2YWx1ZSBvZiB0aGUgc2VsZWN0IGNoYW5nZXMuIFRoaXMgaXMgaGVyZSBwcmltYXJpbHlcbiAgICogdG8gZmFjaWxpdGF0ZSB0aGUgdHdvLXdheSBiaW5kaW5nIGZvciB0aGUgYHZhbHVlYCBpbnB1dC5cbiAgICogQGRvY3MtcHJpdmF0ZVxuICAgKi9cbiAgQE91dHB1dCgnbnhWYWx1ZUNoYW5nZScpIHJlYWRvbmx5IHZhbHVlQ2hhbmdlOiBFdmVudEVtaXR0ZXI8YW55PiA9IG5ldyBFdmVudEVtaXR0ZXI8YW55PigpO1xuXG4gIC8qKiBFdmVudCBlbWl0dGVkIHdoZW4gdGhlIHNlbGVjdGVkIHZhbHVlIGhhcyBiZWVuIGNoYW5nZWQuICovXG4gIEBPdXRwdXQoKSByZWFkb25seSBzZWxlY3Rpb25DaGFuZ2U6IEV2ZW50RW1pdHRlcjxOeERyb3Bkb3duU2VsZWN0Q2hhbmdlPiA9XG4gICAgbmV3IEV2ZW50RW1pdHRlcjxOeERyb3Bkb3duU2VsZWN0Q2hhbmdlPigpO1xuXG4gIC8qKiBAZG9jcy1wcml2YXRlICovXG4gIHJlYWRvbmx5IG9wdGlvblNlbGVjdGlvbkNoYW5nZXM6IE9ic2VydmFibGU8TnhEcm9wZG93bkl0ZW1DaGFuZ2U+ID0gZGVmZXI8T2JzZXJ2YWJsZTxOeERyb3Bkb3duSXRlbUNoYW5nZT4+KCgpID0+IHtcbiAgICBpZiAodGhpcy5vcHRpb25zKSB7XG4gICAgICByZXR1cm4gbWVyZ2UoLi4udGhpcy5vcHRpb25zLm1hcChvcHRpb24gPT4gb3B0aW9uLm9uU2VsZWN0aW9uQ2hhbmdlKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuX25nWm9uZS5vblN0YWJsZVxuICAgICAgLmFzT2JzZXJ2YWJsZSgpXG4gICAgICAucGlwZSh0YWtlKDEpLCBzd2l0Y2hNYXAoKCkgPT4gdGhpcy5vcHRpb25TZWxlY3Rpb25DaGFuZ2VzKSk7XG4gIH0pO1xuXG4gIC8qKlxuICAgKiBUaGlzIHBvc2l0aW9uIGNvbmZpZyBlbnN1cmVzIHRoYXQgdGhlIHRvcCBcInN0YXJ0XCIgY29ybmVyIG9mIHRoZSBvdmVybGF5XG4gICAqIGlzIGFsaWduZWQgd2l0aCB3aXRoIHRoZSB0b3AgXCJzdGFydFwiIG9mIHRoZSBvcmlnaW4gYnkgZGVmYXVsdCAob3ZlcmxhcHBpbmdcbiAgICogdGhlIHRyaWdnZXIgY29tcGxldGVseSkuIElmIHRoZSBwYW5lbCBjYW5ub3QgZml0IGJlbG93IHRoZSB0cmlnZ2VyLCBpdFxuICAgKiB3aWxsIGZhbGwgYmFjayB0byBhIHBvc2l0aW9uIGFib3ZlIHRoZSB0cmlnZ2VyLlxuICAgKi9cbiAgX3Bvc2l0aW9uczogIENvbm5lY3Rpb25Qb3NpdGlvblBhaXJbXTtcblxuICAvKipcbiAgICogQGRvY3MtcHJpdmF0ZVxuICAgKiBQYW5lbCBjb250YWluaW5nIHRoZSBzZWxlY3Qgb3B0aW9ucy5cbiAgICovXG4gIEBWaWV3Q2hpbGQoJ3BhbmVsJywgeyBzdGF0aWM6IGZhbHNlIH0pIHBhbmVsOiBFbGVtZW50UmVmO1xuXG4gIC8qKiBAZG9jcy1wcml2YXRlICovXG4gIEBWaWV3Q2hpbGQoJ3BhbmVsQm9keScsIHsgc3RhdGljOiBmYWxzZSB9KSBwYW5lbEJvZHk6IEVsZW1lbnRSZWY7XG5cbiAgLyoqIEBkb2NzLXByaXZhdGUgKi9cbiAgQFZpZXdDaGlsZCgndHJpZ2dlcicsIHsgc3RhdGljOiB0cnVlIH0pIHRyaWdnZXI6IEVsZW1lbnRSZWY7XG5cbiAgLyoqIEBkb2NzLXByaXZhdGUgKi9cbiAgQFZpZXdDaGlsZCgnZmlsdGVySW5wdXQnLCB7IHN0YXRpYzogZmFsc2UgfSkgZmlsdGVySW5wdXQ6IEVsZW1lbnRSZWY7XG5cbiAgLyoqXG4gICAqIEBkb2NzLXByaXZhdGVcbiAgICogT3ZlcmxheSBwYW5lIGNvbnRhaW5pbmcgdGhlIG9wdGlvbnMuXG4gICAqL1xuICBAVmlld0NoaWxkKENka0Nvbm5lY3RlZE92ZXJsYXksIHsgc3RhdGljOiB0cnVlIH0pIG92ZXJsYXlEaXI6IENka0Nvbm5lY3RlZE92ZXJsYXk7XG5cbiAgLyoqIEBkb2NzLXByaXZhdGUgKi9cbiAgQENvbnRlbnRDaGlsZHJlbihOeERyb3Bkb3duSXRlbUNvbXBvbmVudCwgeyBkZXNjZW5kYW50czogdHJ1ZSB9KSBvcHRpb25zO1xuXG4gIC8qKiBAZG9jcy1wcml2YXRlICovXG4gIEBDb250ZW50Q2hpbGRyZW4oTnhEcm9wZG93bkdyb3VwQ29tcG9uZW50KSBncm91cHM7XG5cbiAgQENvbnRlbnRDaGlsZChOeERyb3Bkb3duQ2xvc2VkTGFiZWxEaXJlY3RpdmUsIHtzdGF0aWM6IGZhbHNlfSlcbiAgX2N1c3RvbUNsb3NlZERyb3Bkb3duTGFiZWw6IE54RHJvcGRvd25DbG9zZWRMYWJlbERpcmVjdGl2ZTtcblxuICBAVmlld0NoaWxkKCdkZWZhdWx0Q2xvc2VkRHJvcGRvd25MYWJlbCcsIHsgc3RhdGljOiB0cnVlIH0pXG4gIHByaXZhdGUgX2RlZmF1bHRDbG9zZWREcm9wZG93bkxhYmVsOiBUZW1wbGF0ZVJlZjxhbnk+O1xuXG4gIC8qKiBAZG9jcy1wcml2YXRlICovXG4gIGdldCBjbG9zZWREcm9wZG93bkxhYmVsKCk6IFRlbXBsYXRlUmVmPGFueT4ge1xuICAgIHJldHVybiB0aGlzLl9jbG9zZWREcm9wZG93bkxhYmVsO1xuICB9XG4gIHByaXZhdGUgX2Nsb3NlZERyb3Bkb3duTGFiZWw6IFRlbXBsYXRlUmVmPGFueT47XG5cbiAgLyoqIEVtaXRzIHdoZW5ldmVyIHRoZSBjb21wb25lbnQgaXMgZGVzdHJveWVkLiAqL1xuICBwcml2YXRlIHJlYWRvbmx5IF9kZXN0cm95ID0gbmV3IFN1YmplY3Q8dm9pZD4oKTtcblxuICAvKipcbiAgICogQGRvY3MtcHJpdmF0ZVxuICAgKiBUaGUgY3VycmVudGx5IHNlbGVjdGVkIG9wdGlvbi5cbiAgICovXG4gIGdldCBzZWxlY3RlZCgpOiBOeERyb3Bkb3duSXRlbUNvbXBvbmVudCB8IE54RHJvcGRvd25JdGVtQ29tcG9uZW50W10ge1xuICAgIHJldHVybiB0aGlzLmlzTXVsdGlTZWxlY3QgPyB0aGlzLl9zZWxlY3Rpb25Nb2RlbC5zZWxlY3RlZCA6IHRoaXMuX3NlbGVjdGlvbk1vZGVsLnNlbGVjdGVkWzBdO1xuICB9XG5cbiAgcHJpdmF0ZSBfa2V5TWFuYWdlcjogQWN0aXZlRGVzY2VuZGFudEtleU1hbmFnZXI8TnhEcm9wZG93bkl0ZW1Db21wb25lbnQ+O1xuXG4gIC8qKiBAZG9jcy1wcml2YXRlICovXG4gIGdldCBwYW5lbE9wZW4oKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRoaXMuX3BhbmVsT3BlbjtcbiAgfVxuICBzZXQgcGFuZWxPcGVuKHZhbHVlOiBib29sZWFuKSB7XG4gICAgdGhpcy5fcGFuZWxPcGVuID0gdmFsdWU7XG4gIH1cblxuICAvKipcbiAgICogRnVuY3Rpb24gdGhhdCB0cmFuc2Zvcm1zIHRoZSB2YWx1ZSBpbnRvIGEgc3RyaW5nLlxuICAgKiBUaGlzIGZ1bmN0aW9uIGlzIHVzZWQgZm9yIGRpc3BsYXlpbmcgYW5kIGZpbHRlcmluZyB0aGUgY29udGVudFxuICAgKiAoIERlZmF1bHQ6ICh2YWx1ZSkgPT4gdmFsdWUgPyB2YWx1ZS50b1N0cmluZygpIDogbnVsbDsgKS5cbiAgICovXG4gIEBJbnB1dCgnbnhWYWx1ZUZvcm1hdHRlcicpIHZhbHVlRm9ybWF0dGVyID0gKHZhbHVlKSA9PiB7XG4gICAgcmV0dXJuIHZhbHVlID09IG51bGwgPyAnJyA6IHZhbHVlLnRvU3RyaW5nKCk7XG4gIH1cblxuICAvKiogQGRvY3MtcHJpdmF0ZSAqL1xuICBnZXQgbGFiZWwoKTogc3RyaW5nIHtcbiAgICByZXR1cm4gdGhpcy5mb3JtRmllbGRDb21wb25lbnQgPyB0aGlzLmZvcm1GaWVsZENvbXBvbmVudC5sYWJlbCA6ICcnO1xuICB9XG5cbiAgLyoqIENvbXBhcmlzb24gZnVuY3Rpb24gdG8gc3BlY2lmeSB3aGljaCBvcHRpb24gaXMgZGlzcGxheWVkLiBEZWZhdWx0cyB0byBvYmplY3QgZXF1YWxpdHkuICovXG4gIHByaXZhdGUgX2NvbXBhcmVXaXRoID0gKG8xOiBhbnksIG8yOiBhbnkpID0+IG8xID09PSBvMjtcblxuICAvKipcbiAgICogRnVuY3Rpb24gdG8gY29tcGFyZSB0aGUgb3B0aW9uIHZhbHVlcyB3aXRoIHRoZSBzZWxlY3RlZCB2YWx1ZXMuIFRoZSBmaXJzdCBhcmd1bWVudFxuICAgKiBpcyBhIHZhbHVlIGZyb20gYW4gb3B0aW9uLiBUaGUgc2Vjb25kIGlzIGEgdmFsdWUgZnJvbSB0aGUgc2VsZWN0aW9uLiBBIGJvb2xlYW5cbiAgICogc2hvdWxkIGJlIHJldHVybmVkLlxuICAgKi9cbiAgQElucHV0KClcbiAgZ2V0IGNvbXBhcmVXaXRoKCkgeyByZXR1cm4gdGhpcy5fY29tcGFyZVdpdGg7IH1cbiAgc2V0IGNvbXBhcmVXaXRoKGZuOiAobzE6IGFueSwgbzI6IGFueSkgPT4gYm9vbGVhbikge1xuICAgIGlmICh0eXBlb2YgZm4gIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRocm93IGdldE54RHJvcGRvd25Ob25GdW5jdGlvblZhbHVlRXJyb3IoKTtcbiAgICB9XG4gICAgdGhpcy5fY29tcGFyZVdpdGggPSBmbjtcbiAgICBpZiAodGhpcy5fc2VsZWN0aW9uTW9kZWwpIHtcbiAgICAgIC8vIEEgZGlmZmVyZW50IGNvbXBhcmF0b3IgbWVhbnMgdGhlIHNlbGVjdGlvbiBjb3VsZCBjaGFuZ2UuXG4gICAgICB0aGlzLl9pbml0aWFsaXplU2VsZWN0aW9uKCk7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBfZmlsdGVyRm4gPSAoc2VhcmNoOiBzdHJpbmcsIGl0ZW1WYWx1ZTogc3RyaW5nKSA9PiB7XG4gICAgcmV0dXJuIGl0ZW1WYWx1ZS50b0xvY2FsZUxvd2VyQ2FzZSgpLmluZGV4T2Yoc2VhcmNoLnRvTG9jYWxlTG93ZXJDYXNlKCkpID49IDA7XG4gIH1cblxuICAvKipcbiAgICogRnVuY3Rpb24gdG8gYmUgdXNlZCB3aGVuIHRoZSB1c2VyIHR5cGVzIGludG8gdGhlIHNlYXJjaCBmaWx0ZXIuIFRoZSBmaXJzdCBhcmd1bWVudCBpcyB0aGUgdXNlciBpbnB1dCxcbiAgICogdGhlIHNlY29uZCBhcmd1bWVudCBpcyB0aGUgZHJvcGRvd24gaXRlbSB2YWx1ZS4gVGhlIGRyb3Bkb3duIGl0ZW1zIHdpbGwgdXNlIHRoaXMgZnVuY3Rpb24gdG8gc2V0IHRoZWlyXG4gICAqIHZpc2liaWxpdHkgc3RhdGUuXG4gICAqIEEgYm9vbGVhbiBzaG91bGQgYmUgcmV0dXJuZWQuXG4gICAqL1xuICBASW5wdXQoKVxuICBnZXQgZmlsdGVyRm4oKSB7IHJldHVybiB0aGlzLl9maWx0ZXJGbjsgfVxuICBzZXQgZmlsdGVyRm4oZm46IChzZWFyY2g6IHN0cmluZywgaXRlbVZhbHVlOiBzdHJpbmcpID0+IGJvb2xlYW4pIHtcbiAgICBpZiAodHlwZW9mIGZuICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0aHJvdyBnZXROeERyb3Bkb3duTm9uRnVuY3Rpb25WYWx1ZUVycm9yKCk7XG4gICAgfVxuICAgIHRoaXMuX2ZpbHRlckZuID0gZm47XG4gIH1cblxuICAvKipcbiAgICogQGRvY3MtcHJpdmF0ZVxuICAgKiBXaGV0aGVyIHRoZSBzZWxlY3QgaXMgZm9jdXNlZC5cbiAgICovXG4gIGdldCBmb2N1c2VkKCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0aGlzLl9mb2N1c2VkIHx8IHRoaXMucGFuZWxPcGVuO1xuICB9XG5cbiAgLyoqIGBWaWV3IC0+IG1vZGVsIGNhbGxiYWNrIGNhbGxlZCB3aGVuIHZhbHVlIGNoYW5nZXNgICovXG4gIF9vbkNoYW5nZTogKHZhbHVlOiBhbnkpID0+IHZvaWQgPSAoKSA9PiB7IH07XG5cbiAgLyoqIGBWaWV3IC0+IG1vZGVsIGNhbGxiYWNrIGNhbGxlZCB3aGVuIHNlbGVjdCBoYXMgYmVlbiB0b3VjaGVkYCAqL1xuICBfb25Ub3VjaGVkID0gKCkgPT4geyB9O1xuXG4gIC8qKiBAZG9jcy1wcml2YXRlICovXG4gIGdldCBlbGVtZW50UmVmKCk6IEVsZW1lbnRSZWYge1xuICAgIHJldHVybiB0aGlzLl9lbGVtZW50UmVmO1xuICB9XG5cbiAgY29uc3RydWN0b3IoXG4gICAgcHJpdmF0ZSBfY2hhbmdlRGV0ZWN0b3JSZWY6IENoYW5nZURldGVjdG9yUmVmLFxuICAgIHByaXZhdGUgX2VsZW1lbnRSZWY6IEVsZW1lbnRSZWYsXG4gICAgcHJpdmF0ZSBfbmdab25lOiBOZ1pvbmUsXG4gICAgQEF0dHJpYnV0ZSgndGFiaW5kZXgnKSB0YWJJbmRleDogc3RyaW5nLFxuICAgIEBPcHRpb25hbCgpIHByaXZhdGUgZm9ybUZpZWxkQ29tcG9uZW50OiBOeEZvcm1maWVsZENvbXBvbmVudCxcbiAgICAvKiogQGRvY3MtcHJpdmF0ZSAqL1xuICAgIEBTZWxmKCkgQE9wdGlvbmFsKCkgcHVibGljIG5nQ29udHJvbDogTmdDb250cm9sLFxuICAgIEBPcHRpb25hbCgpIHByaXZhdGUgX3BhcmVudEZvcm06IE5nRm9ybSxcbiAgICBAT3B0aW9uYWwoKSBwcml2YXRlIF9wYXJlbnRGb3JtR3JvdXA6IEZvcm1Hcm91cERpcmVjdGl2ZSkge1xuICAgIHN1cGVyKCk7XG5cbiAgICBpZiAodGhpcy5uZ0NvbnRyb2wpIHtcbiAgICAgIC8vIE5vdGU6IHdlIHByb3ZpZGUgdGhlIHZhbHVlIGFjY2Vzc29yIHRocm91Z2ggaGVyZSwgaW5zdGVhZCBvZlxuICAgICAgLy8gdGhlIGBwcm92aWRlcnNgIHRvIGF2b2lkIHJ1bm5pbmcgaW50byBhIGNpcmN1bGFyIGltcG9ydC5cbiAgICAgIHRoaXMubmdDb250cm9sLnZhbHVlQWNjZXNzb3IgPSB0aGlzO1xuICAgIH1cblxuICAgIHRoaXMuX3Bvc2l0aW9ucyA9IGdldFBvc2l0aW9ucygpO1xuICAgIHRoaXMudGFiSW5kZXggPSBwYXJzZUludCh0YWJJbmRleCwgMTApIHx8IDA7XG4gIH1cblxuICBuZ0RvQ2hlY2soKSB7XG4gICAgaWYgKHRoaXMubmdDb250cm9sKSB7XG4gICAgICB0aGlzLnVwZGF0ZUVycm9yU3RhdGUoKTtcbiAgICB9XG4gIH1cblxuICBuZ09uSW5pdCgpIHtcbiAgICB0aGlzLl9zZWxlY3Rpb25Nb2RlbCA9IG5ldyBTZWxlY3Rpb25Nb2RlbDxOeERyb3Bkb3duSXRlbUNvbXBvbmVudD4odGhpcy5pc011bHRpU2VsZWN0KTtcbiAgfVxuXG4gIG5nQWZ0ZXJDb250ZW50SW5pdCgpIHtcbiAgICB0aGlzLl9jbG9zZWREcm9wZG93bkxhYmVsID1cbiAgICAgIHRoaXMuX2N1c3RvbUNsb3NlZERyb3Bkb3duTGFiZWwgJiYgdGhpcy5fY3VzdG9tQ2xvc2VkRHJvcGRvd25MYWJlbC50ZW1wbGF0ZVJlZiB8fCB0aGlzLl9kZWZhdWx0Q2xvc2VkRHJvcGRvd25MYWJlbDtcbiAgICB0aGlzLl9pbml0S2V5TWFuYWdlcigpO1xuXG4gICAgdGhpcy5fc2VsZWN0aW9uTW9kZWwuY2hhbmdlZC5waXBlKHRha2VVbnRpbCh0aGlzLl9kZXN0cm95KSkuc3Vic2NyaWJlKGV2ZW50ID0+IHtcbiAgICAgIGV2ZW50LmFkZGVkLmZvckVhY2gob3B0aW9uID0+IG9wdGlvbi5zZWxlY3QoKSk7XG4gICAgICBldmVudC5yZW1vdmVkLmZvckVhY2gob3B0aW9uID0+IG9wdGlvbi5kZXNlbGVjdCgpKTtcbiAgICB9KTtcblxuICAgIHRoaXMub3B0aW9ucy5jaGFuZ2VzLnBpcGUoc3RhcnRXaXRoKG51bGwpLCB0YWtlVW50aWwodGhpcy5fZGVzdHJveSkpLnN1YnNjcmliZSgoKSA9PiB7XG4gICAgICB0aGlzLl9yZXNldE9wdGlvbnMoKTtcbiAgICAgIHRoaXMuX2luaXRpYWxpemVTZWxlY3Rpb24oKTtcbiAgICB9KTtcbiAgfVxuXG4gIG5nT25EZXN0cm95KCkge1xuICAgIHRoaXMuX2Rlc3Ryb3kubmV4dCgpO1xuICAgIHRoaXMuX2Rlc3Ryb3kuY29tcGxldGUoKTtcbiAgfVxuXG4gIC8qKiBAZG9jcy1wcml2YXRlICovXG4gIGlzRXJyb3JTdGF0ZShjb250cm9sOiBGb3JtQ29udHJvbCB8IG51bGwsIGZvcm06IEZvcm1Hcm91cERpcmVjdGl2ZSB8IE5nRm9ybSB8IG51bGwpOiBib29sZWFuIHtcbiAgICByZXR1cm4gISEoY29udHJvbCAmJiBjb250cm9sLmludmFsaWQgJiYgKGNvbnRyb2wudG91Y2hlZCB8fCAoZm9ybSAmJiBmb3JtLnN1Ym1pdHRlZCkpKTtcbiAgfVxuXG4gIC8qKiBAZG9jcy1wcml2YXRlICovXG4gIHVwZGF0ZUVycm9yU3RhdGUoKSB7XG4gICAgY29uc3Qgb2xkU3RhdGUgPSB0aGlzLmVycm9yU3RhdGU7XG4gICAgY29uc3QgcGFyZW50ID0gdGhpcy5fcGFyZW50Rm9ybUdyb3VwIHx8IHRoaXMuX3BhcmVudEZvcm07XG4gICAgY29uc3QgY29udHJvbCA9IHRoaXMubmdDb250cm9sID8gdGhpcy5uZ0NvbnRyb2wuY29udHJvbCBhcyBGb3JtQ29udHJvbCA6IG51bGw7XG4gICAgY29uc3QgbmV3U3RhdGUgPSB0aGlzLmlzRXJyb3JTdGF0ZShjb250cm9sLCBwYXJlbnQpO1xuXG4gICAgaWYgKG5ld1N0YXRlICE9PSBvbGRTdGF0ZSkge1xuICAgICAgdGhpcy5lcnJvclN0YXRlID0gbmV3U3RhdGU7XG4gICAgICB0aGlzLnN0YXRlQ2hhbmdlcy5uZXh0KCk7XG4gICAgfVxuICB9XG5cbiAgLyoqIFNldHMgdXAgYSBrZXkgbWFuYWdlciB0byBsaXN0ZW4gdG8ga2V5Ym9hcmQgZXZlbnRzIG9uIHRoZSBvdmVybGF5IHBhbmVsLiAqL1xuICBwcml2YXRlIF9pbml0S2V5TWFuYWdlcigpIHtcbiAgICB0aGlzLl9rZXlNYW5hZ2VyID0gbmV3IEFjdGl2ZURlc2NlbmRhbnRLZXlNYW5hZ2VyPE54RHJvcGRvd25JdGVtQ29tcG9uZW50Pih0aGlzLm9wdGlvbnMpXG4gICAgICAud2l0aFR5cGVBaGVhZCgpXG4gICAgICAud2l0aFdyYXAoKVxuICAgICAgLndpdGhWZXJ0aWNhbE9yaWVudGF0aW9uKClcbiAgICAgIC53aXRoSG9yaXpvbnRhbE9yaWVudGF0aW9uKCdsdHInKVxuICAgICAgLnNraXBQcmVkaWNhdGUoaXRlbSA9PiBpdGVtLl9oaWRkZW4pO1xuXG4gICAgdGhpcy5fa2V5TWFuYWdlci50YWJPdXQucGlwZSh0YWtlVW50aWwodGhpcy5fZGVzdHJveSkpLnN1YnNjcmliZSgoKSA9PiB7XG4gICAgICAvLyBSZXN0b3JlIGZvY3VzIHRvIHRoZSB0cmlnZ2VyIGJlZm9yZSBjbG9zaW5nLiBFbnN1cmVzIHRoYXQgdGhlIGZvY3VzXG4gICAgICAvLyBwb3NpdGlvbiB3b24ndCBiZSBsb3N0IGlmIHRoZSB1c2VyIGdvdCBmb2N1cyBpbnRvIHRoZSBvdmVybGF5LlxuICAgICAgdGhpcy5jbG9zZVBhbmVsKCk7XG4gICAgfSk7XG5cbiAgICB0aGlzLl9rZXlNYW5hZ2VyLmNoYW5nZS5waXBlKHRha2VVbnRpbCh0aGlzLl9kZXN0cm95KSkuc3Vic2NyaWJlKCgpID0+IHtcbiAgICAgIGlmICh0aGlzLl9wYW5lbE9wZW4gJiYgdGhpcy5wYW5lbCkge1xuICAgICAgICAvLyBEZWxheSB0aGUgYXV0byBzY3JvbGxpbmcgdW50aWwgYWxsIGl0ZW1zIGhhdmUgc2V0dGxlZCBvdGhlcndpc2UgdGhlIGl0ZW0gY29udGFpbmVycyBtaWdodFxuICAgICAgICAvLyBub3QgZXhpc3QgeWV0XG4gICAgICAgIHRoaXMuX25nWm9uZS5vblN0YWJsZVxuICAgICAgICAgIC5hc09ic2VydmFibGUoKVxuICAgICAgICAgIC5waXBlKHRha2UoMSkpLnN1YnNjcmliZSgoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLl9zY3JvbGxBY3RpdmVPcHRpb25JbnRvVmlldygpO1xuICAgICAgICAgIH0pO1xuICAgICAgfSBlbHNlIGlmICghdGhpcy5fcGFuZWxPcGVuICYmICF0aGlzLmlzTXVsdGlTZWxlY3QgJiYgdGhpcy5fa2V5TWFuYWdlci5hY3RpdmVJdGVtKSB7XG4gICAgICAgIHRoaXMuX2tleU1hbmFnZXIuYWN0aXZlSXRlbS5fc2VsZWN0VmlhSW50ZXJhY3Rpb24oKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIHByaXZhdGUgX3Jlc2V0T3B0aW9ucygpOiB2b2lkIHtcbiAgICBjb25zdCBjaGFuZ2VkT3JEZXN0cm95ZWQgPSBtZXJnZSh0aGlzLm9wdGlvbnMuY2hhbmdlcywgdGhpcy5fZGVzdHJveSk7XG5cbiAgICB0aGlzLm9wdGlvblNlbGVjdGlvbkNoYW5nZXMucGlwZSh0YWtlVW50aWwoY2hhbmdlZE9yRGVzdHJveWVkKSkuc3Vic2NyaWJlKGV2ZW50ID0+IHtcbiAgICAgIHRoaXMuX29uU2VsZWN0KGV2ZW50Lml0ZW0sIGV2ZW50LmlzVXNlcklucHV0KTtcblxuICAgICAgaWYgKGV2ZW50LmlzVXNlcklucHV0ICYmICF0aGlzLmlzTXVsdGlTZWxlY3QgJiYgdGhpcy5fcGFuZWxPcGVuKSB7XG4gICAgICAgIHRoaXMuY2xvc2VQYW5lbCgpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgLy8gTGlzdGVuIHRvIGNoYW5nZXMgaW4gdGhlIGludGVybmFsIHN0YXRlIG9mIHRoZSBvcHRpb25zIGFuZCByZWFjdCBhY2NvcmRpbmdseS5cbiAgICAvLyBIYW5kbGVzIGNhc2VzIGxpa2UgdGhlIGxhYmVscyBvZiB0aGUgc2VsZWN0ZWQgb3B0aW9ucyBjaGFuZ2luZy5cbiAgICBtZXJnZSguLi50aGlzLm9wdGlvbnMubWFwKG9wdGlvbiA9PiBvcHRpb24uX3N0YXRlQ2hhbmdlcykpXG4gICAgICAucGlwZSh0YWtlVW50aWwoY2hhbmdlZE9yRGVzdHJveWVkKSlcbiAgICAgIC5zdWJzY3JpYmUoKCkgPT4ge1xuICAgICAgICAvLyBkZWZlciBpdCBmb3IgdGhlIG5leHQgY3ljbGUgdG8gbm90IHJ1biBpbiBjaGFuZ2VkIGFmdGVyIGNoZWNrZWQgZXJyb3JzXG4gICAgICAgIC8vIHRoZSBjb21iaW5hdGlvbiBvZiBkcm9wZG93bi1pdGVtIG5vdGlmeWluZyBwYXJlbnQgYW5kIHdoZW4gdGhlIHBhcmVudFxuICAgICAgICAvLyB0cmllcyB0byBmZXRjaCB0aGUgdHJpZ2dlclZhbHVlIGZyb20gdGhlIGNoaWxkIHRocm93cyB0aGVzZSBlcnJvcnNcbiAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgdGhpcy5fY2hhbmdlRGV0ZWN0b3JSZWYubWFya0ZvckNoZWNrKCk7XG4gICAgICAgICAgdGhpcy5zdGF0ZUNoYW5nZXMubmV4dCgpO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuXG4gICAgdGhpcy5fc2V0T3B0aW9uSWRzKCk7XG4gIH1cblxuICAvKiogUmVjb3JkcyBvcHRpb24gSURzIHRvIHBhc3MgdG8gdGhlIGFyaWEtb3ducyBwcm9wZXJ0eS4gKi9cbiAgcHJpdmF0ZSBfc2V0T3B0aW9uSWRzKCkge1xuICAgIHRoaXMuX29wdGlvbklkcyA9IHRoaXMub3B0aW9ucy5tYXAob3B0aW9uID0+IG9wdGlvbi5pZCkuam9pbignICcpO1xuICB9XG5cbiAgLyoqIEludm9rZWQgd2hlbiBhbiBvcHRpb24gaXMgY2xpY2tlZC4gKi9cbiAgcHJpdmF0ZSBfb25TZWxlY3Qob3B0aW9uOiBOeERyb3Bkb3duSXRlbUNvbXBvbmVudCwgaXNVc2VySW5wdXQ6IGJvb2xlYW4pOiB2b2lkIHtcbiAgICBjb25zdCB3YXNTZWxlY3RlZCA9IHRoaXMuX3NlbGVjdGlvbk1vZGVsLmlzU2VsZWN0ZWQob3B0aW9uKTtcblxuICAgIGlmIChvcHRpb24udmFsdWUgPT0gbnVsbCAmJiAhdGhpcy5pc011bHRpU2VsZWN0KSB7XG4gICAgICBvcHRpb24uZGVzZWxlY3QoKTtcbiAgICAgIHRoaXMuX3NlbGVjdGlvbk1vZGVsLmNsZWFyKCk7XG4gICAgICB0aGlzLl9wcm9wYWdhdGVDaGFuZ2VzKG9wdGlvbi52YWx1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG9wdGlvbi5zZWxlY3RlZCA/IHRoaXMuX3NlbGVjdGlvbk1vZGVsLnNlbGVjdChvcHRpb24pIDogdGhpcy5fc2VsZWN0aW9uTW9kZWwuZGVzZWxlY3Qob3B0aW9uKTtcblxuICAgICAgaWYgKGlzVXNlcklucHV0KSB7XG4gICAgICAgIHRoaXMuX2tleU1hbmFnZXIuc2V0QWN0aXZlSXRlbShvcHRpb24pO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5pc011bHRpU2VsZWN0KSB7XG4gICAgICAgIHRoaXMuX3NvcnRWYWx1ZXMoKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAod2FzU2VsZWN0ZWQgIT09IHRoaXMuX3NlbGVjdGlvbk1vZGVsLmlzU2VsZWN0ZWQob3B0aW9uKSkge1xuICAgICAgdGhpcy5fcHJvcGFnYXRlQ2hhbmdlcygpO1xuICAgIH1cblxuICAgIHRoaXMuc3RhdGVDaGFuZ2VzLm5leHQoKTtcbiAgfVxuXG4gIHByaXZhdGUgX2luaXRpYWxpemVTZWxlY3Rpb24oKTogdm9pZCB7XG4gICAgLy8gRGVmZXIgc2V0dGluZyB0aGUgdmFsdWUgaW4gb3JkZXIgdG8gYXZvaWQgdGhlIFwiRXhwcmVzc2lvblxuICAgIC8vIGhhcyBjaGFuZ2VkIGFmdGVyIGl0IHdhcyBjaGVja2VkXCIgZXJyb3JzIGZyb20gQW5ndWxhci5cbiAgICBQcm9taXNlLnJlc29sdmUoKS50aGVuKCgpID0+IHtcbiAgICAgIHRoaXMuX3NldFNlbGVjdGlvbkJ5VmFsdWUodGhpcy5uZ0NvbnRyb2wgPyB0aGlzLm5nQ29udHJvbC52YWx1ZSA6IHRoaXMuX3ZhbHVlKTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIHRoZSBzZWxlY3RlZCBvcHRpb24gYmFzZWQgb24gYSB2YWx1ZS4gSWYgbm8gb3B0aW9uIGNhbiBiZVxuICAgKiBmb3VuZCB3aXRoIHRoZSBkZXNpZ25hdGVkIHZhbHVlLCB0aGUgc2VsZWN0IHRyaWdnZXIgaXMgY2xlYXJlZC5cbiAgICovXG4gIHByaXZhdGUgX3NldFNlbGVjdGlvbkJ5VmFsdWUodmFsdWU6IGFueSB8IGFueVtdKTogdm9pZCB7XG4gICAgaWYgKHRoaXMuaXNNdWx0aVNlbGVjdCAmJiB2YWx1ZSkge1xuICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICB0aHJvdyBnZXROeERyb3Bkb3duTm9uQXJyYXlWYWx1ZUVycm9yKCk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX3NlbGVjdGlvbk1vZGVsLmNsZWFyKCk7XG4gICAgICB2YWx1ZS5mb3JFYWNoKChjdXJyZW50VmFsdWU6IGFueSkgPT4gdGhpcy5fc2VsZWN0VmFsdWUoY3VycmVudFZhbHVlKSk7XG4gICAgICB0aGlzLl9zb3J0VmFsdWVzKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX3NlbGVjdGlvbk1vZGVsLmNsZWFyKCk7XG4gICAgICBjb25zdCBjb3JyZXNwb25kaW5nT3B0aW9uID0gdGhpcy5fc2VsZWN0VmFsdWUodmFsdWUpO1xuICAgICAgLy8gU2hpZnQgZm9jdXMgdG8gdGhlIGFjdGl2ZSBpdGVtLiBOb3RlIHRoYXQgd2Ugc2hvdWxkbid0IGRvIHRoaXMgaW4gbXVsdGlwbGVcbiAgICAgIC8vIG1vZGUsIGJlY2F1c2Ugd2UgZG9uJ3Qga25vdyB3aGF0IG9wdGlvbiB0aGUgdXNlciBpbnRlcmFjdGVkIHdpdGggbGFzdC5cbiAgICAgIGlmIChjb3JyZXNwb25kaW5nT3B0aW9uKSB7XG4gICAgICAgIHRoaXMuX2tleU1hbmFnZXIuc2V0QWN0aXZlSXRlbShjb3JyZXNwb25kaW5nT3B0aW9uKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLl9jaGFuZ2VEZXRlY3RvclJlZi5tYXJrRm9yQ2hlY2soKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBGaW5kcyBhbmQgc2VsZWN0cyBhbmQgb3B0aW9uIGJhc2VkIG9uIGl0cyB2YWx1ZS5cbiAgICogQHJldHVybnMgT3B0aW9uIHRoYXQgaGFzIHRoZSBjb3JyZXNwb25kaW5nIHZhbHVlLlxuICAgKi9cbiAgcHJpdmF0ZSBfc2VsZWN0VmFsdWUodmFsdWU6IGFueSk6IE54RHJvcGRvd25JdGVtQ29tcG9uZW50IHwgdW5kZWZpbmVkIHtcbiAgICBjb25zdCBjb3JyZXNwb25kaW5nT3B0aW9uID0gdGhpcy5vcHRpb25zLmZpbmQoKG9wdGlvbjogTnhEcm9wZG93bkl0ZW1Db21wb25lbnQpID0+IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIC8vIFRyZWF0IG51bGwgYXMgYSBzcGVjaWFsIHJlc2V0IHZhbHVlLlxuICAgICAgICByZXR1cm4gb3B0aW9uLnZhbHVlICE9IG51bGwgJiYgdGhpcy5fY29tcGFyZVdpdGgob3B0aW9uLnZhbHVlLCB2YWx1ZSk7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBpZiAoaXNEZXZNb2RlKCkpIHtcbiAgICAgICAgICAvLyBOb3RpZnkgZGV2ZWxvcGVycyBvZiBlcnJvcnMgaW4gdGhlaXIgY29tcGFyYXRvci5cbiAgICAgICAgICBjb25zb2xlLndhcm4oZXJyb3IpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGlmIChjb3JyZXNwb25kaW5nT3B0aW9uKSB7XG4gICAgICB0aGlzLl9zZWxlY3Rpb25Nb2RlbC5zZWxlY3QoY29ycmVzcG9uZGluZ09wdGlvbik7XG4gICAgfVxuICAgIHJldHVybiBjb3JyZXNwb25kaW5nT3B0aW9uO1xuICB9XG5cbiAgLyoqIEVtaXRzIGNoYW5nZSBldmVudCB0byBzZXQgdGhlIG1vZGVsIHZhbHVlLiAqL1xuICBwcml2YXRlIF9wcm9wYWdhdGVDaGFuZ2VzKGZhbGxiYWNrVmFsdWU/OiBhbnkpOiB2b2lkIHtcbiAgICBsZXQgdmFsdWVUb0VtaXQ6IGFueSA9IG51bGw7XG5cbiAgICBpZiAodGhpcy5pc011bHRpU2VsZWN0KSB7XG4gICAgICB2YWx1ZVRvRW1pdCA9ICh0aGlzLnNlbGVjdGVkIGFzIE54RHJvcGRvd25JdGVtQ29tcG9uZW50W10pLm1hcChvcHRpb24gPT4gb3B0aW9uLnZhbHVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFsdWVUb0VtaXQgPSB0aGlzLnNlbGVjdGVkID8gKHRoaXMuc2VsZWN0ZWQgYXMgTnhEcm9wZG93bkl0ZW1Db21wb25lbnQpLnZhbHVlIDogZmFsbGJhY2tWYWx1ZTtcbiAgICB9XG5cbiAgICB0aGlzLl92YWx1ZSA9IHZhbHVlVG9FbWl0O1xuICAgIHRoaXMudmFsdWVDaGFuZ2UuZW1pdCh2YWx1ZVRvRW1pdCk7XG4gICAgdGhpcy5fb25DaGFuZ2UodmFsdWVUb0VtaXQpO1xuICAgIHRoaXMuc2VsZWN0aW9uQ2hhbmdlLmVtaXQobmV3IE54RHJvcGRvd25TZWxlY3RDaGFuZ2UodGhpcywgdmFsdWVUb0VtaXQpKTtcbiAgICB0aGlzLl9jaGFuZ2VEZXRlY3RvclJlZi5tYXJrRm9yQ2hlY2soKTtcbiAgfVxuXG4gIC8qKiBTb3J0cyB0aGUgc2VsZWN0ZWQgdmFsdWVzIGluIHRoZSBzZWxlY3RlZCBiYXNlZCBvbiB0aGVpciBvcmRlciBpbiB0aGUgcGFuZWwuICovXG4gIHByaXZhdGUgX3NvcnRWYWx1ZXMoKSB7XG4gICAgaWYgKHRoaXMuaXNNdWx0aVNlbGVjdCkge1xuICAgICAgY29uc3Qgb3B0aW9ucyA9IHRoaXMub3B0aW9ucy50b0FycmF5KCk7XG4gICAgICB0aGlzLl9zZWxlY3Rpb25Nb2RlbC5zb3J0KChhLCBiKSA9PiBvcHRpb25zLmluZGV4T2YoYSkgLSBvcHRpb25zLmluZGV4T2YoYikpO1xuICAgICAgdGhpcy5zdGF0ZUNoYW5nZXMubmV4dCgpO1xuICAgIH1cbiAgfVxuXG4gIC8qKiBBZGRzIGEgb2Zmc2V0IHRvIHRoZSBvdmVybGF5IHBvc2l0aW9uLCBzbyB0aGUgZm9ybWZpZWxkIGxhYmVsIGFuZCB0aGUgZHJvcGRvd24gcGFuZWwgaGVhZGVyIGFyZSB2ZXJ0aWNhbGx5IGFsaWduZWQuICovXG4gIHByaXZhdGUgX3VwZGF0ZVBvc2l0aW9uT2Zmc2V0KCkge1xuICAgIGxldCBvZmZzZXQgPSAwO1xuXG4gICAgaWYgKHRoaXMuZm9ybUZpZWxkQ29tcG9uZW50ICE9PSBudWxsKSB7XG4gICAgICBjb25zdCBmb3JtRmllbGRSZWN0ID0gdGhpcy5mb3JtRmllbGRDb21wb25lbnQuZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgY29uc3QgZHJvcGRvd25SZWN0ID0gdGhpcy5fZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgY29uc3QgcGFuZWxIZWFkZXIgPSB0aGlzLm92ZXJsYXlEaXIub3ZlcmxheVJlZi5vdmVybGF5RWxlbWVudC5xdWVyeVNlbGVjdG9yKCcubngtZHJvcGRvd25fX3BhbmVsLWhlYWRlcicpO1xuICAgICAgY29uc3QgcGFuZWxIZWFkZXJQYWRkaW5nVG9wID0gcGFuZWxIZWFkZXIgPyBwYXJzZUludChnZXRDb21wdXRlZFN0eWxlKHBhbmVsSGVhZGVyKS5wYWRkaW5nVG9wLCAxMCkgOiAwO1xuICAgICAgb2Zmc2V0ID0gZm9ybUZpZWxkUmVjdC50b3AgLSBkcm9wZG93blJlY3QudG9wIC0gcGFuZWxIZWFkZXJQYWRkaW5nVG9wO1xuICAgIH1cblxuICAgIHRoaXMuX3Bvc2l0aW9uc1swXS5vZmZzZXRZID0gb2Zmc2V0O1xuICB9XG5cbiAgLyoqIEZvY3VzZXMgdGhlIHNlbGVjdCBlbGVtZW50LiAqL1xuICBmb2N1cygpOiB2b2lkIHtcbiAgICB0aGlzLl9lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQuZm9jdXMoKTtcbiAgfVxuXG4gIC8qKiBPcGVucyB0aGUgcGFuZWwgb2YgdGhlIGRyb3Bkb3duLiAqL1xuICBvcGVuUGFuZWwoKSB7XG4gICAgaWYgKHRoaXMuZGlzYWJsZWQgfHwgIXRoaXMub3B0aW9ucyB8fCAhdGhpcy5vcHRpb25zLmxlbmd0aCB8fCB0aGlzLl9wYW5lbE9wZW4pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5fcGFuZWxPcGVuID0gdHJ1ZTtcbiAgICB0aGlzLl90cmlnZ2VyUmVjdCA9IHRoaXMudHJpZ2dlci5uYXRpdmVFbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIHRoaXMuX2tleU1hbmFnZXIud2l0aEhvcml6b250YWxPcmllbnRhdGlvbihudWxsKTtcbiAgICB0aGlzLl9oaWdobGlnaHRDb3JyZWN0T3B0aW9uKCk7XG4gICAgdGhpcy5fY2hhbmdlRGV0ZWN0b3JSZWYubWFya0ZvckNoZWNrKCk7XG4gIH1cblxuICAvKiogQ2xvc2VzIHRoZSBwYW5lbCBvZiB0aGUgZHJvcGRvd24uICovXG4gIGNsb3NlUGFuZWwoKSB7XG4gICAgaWYgKHRoaXMuX3BhbmVsT3Blbikge1xuICAgICAgdGhpcy5fcGFuZWxPcGVuID0gZmFsc2U7XG4gICAgICB0aGlzLmlzU3RhYmxlID0gZmFsc2U7XG4gICAgICB0aGlzLl9rZXlNYW5hZ2VyLndpdGhIb3Jpem9udGFsT3JpZW50YXRpb24oJ2x0cicpO1xuICAgICAgdGhpcy5fY2hhbmdlRGV0ZWN0b3JSZWYubWFya0ZvckNoZWNrKCk7XG4gICAgICB0aGlzLl9vblRvdWNoZWQoKTtcbiAgICAgIHRoaXMub3BlbmVkQ2hhbmdlLmVtaXQoZmFsc2UpO1xuICAgICAgLy8gZGVmZXIgdGhlIGZvY3VzIGlmIHRoZSBkcm9wZG93biB0cmlnZ2VycyBhY3Rpb25zIHRoYXQgZGV0YWNoXG4gICAgICAvLyBhIHRlbXBsYXRlL3ZpZXcgZnJvbSB0aGUgRE9NIHRvIHByZXZlbnQgY2hhbmdlZCBhZnRlciBjaGVja2VkIGVycm9yc1xuICAgICAgc2V0VGltZW91dCgoKSA9PiB0aGlzLmZvY3VzKCkpO1xuICAgIH1cbiAgfVxuXG4gIC8vIGNhbGN1bGF0ZSBpbml0YWwgc2Nyb2xsVG9wIHdoZW4gdGhlIGRyb3Bkb3duIG9wZW5zXG4gIC8vIHNjcm9sbHMgdGhlIHNlbGVjdGVkIGl0ZW0gdG8gdGhlIG1pZGRsZSBvZiB0aGUgcGFuZWwgaWYgcG9zc2libGVcbiAgcHJpdmF0ZSBfY2FsY3VsYXRlU2Nyb2xsVG9wKCkge1xuICAgIC8vIHJlc2V0IHRoZSBzY3JvbGx0b3AgdG8gbWFrZSBjYWxjdWxhdGlvbiBlYXNpZXJcbiAgICB0aGlzLnBhbmVsQm9keS5uYXRpdmVFbGVtZW50LnNjcm9sbFRvcCA9IDA7XG5cbiAgICBpZiAoIXRoaXMuZW1wdHkpIHtcbiAgICAgIGNvbnN0IG9mZnNldCA9IHRoaXMuX2dldEl0ZW1PZmZzZXQodGhpcy5fa2V5TWFuYWdlci5hY3RpdmVJdGVtKTtcbiAgICAgIGNvbnN0IHBhbmVsSGVpZ2h0ID0gdGhpcy5wYW5lbEJvZHkubmF0aXZlRWxlbWVudC5vZmZzZXRIZWlnaHQ7XG4gICAgICBjb25zdCBwYW5lbFJlY3QgPSB0aGlzLnBhbmVsQm9keS5uYXRpdmVFbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgY29uc3QgbWlkZGxlT2ZQYW5lbCA9IHBhbmVsUmVjdC50b3AgKyBwYW5lbEhlaWdodCAvIDI7XG5cbiAgICAgIGlmIChvZmZzZXQgPiBtaWRkbGVPZlBhbmVsKSB7XG4gICAgICAgIC8vIGJlY2F1c2Ugd2UgcmVzZXQgdGhlIHNjcm9sbFRvcCB0byAwIGF0IHRoZSB0b3Agd2UgY2FuIHNpbXBseSB0YWtlIHRoZSBtaWRkbGVPZlBhbmVsIHdoaWNoIGlzIG91clxuICAgICAgICAvLyB0YXJnZXQgcG9zaXRpb24gZm9yIHRoZSBpdGVtIGFuZCBzdWJ0cmFjdCBpdCBmcm9tIHRoZSBvZmZzZXQgKHdoaWNoIGlzIG5vdyBhbHdheXMgcmVsYXRpdmUgdG8gdGhlIHZpZXdwb3J0KVxuICAgICAgICB0aGlzLnBhbmVsQm9keS5uYXRpdmVFbGVtZW50LnNjcm9sbFRvcCA9IG9mZnNldCAtIG1pZGRsZU9mUGFuZWw7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqIFNjcm9sbHMgdGhlIGFjdGl2ZSBvcHRpb24gaW50byB2aWV3LiAqL1xuICBwcml2YXRlIF9zY3JvbGxBY3RpdmVPcHRpb25JbnRvVmlldygpOiB2b2lkIHtcbiAgICBpZiAoIXRoaXMucGFuZWxPcGVuIHx8ICF0aGlzLl9rZXlNYW5hZ2VyLmFjdGl2ZUl0ZW0pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCBhY3RpdmVJdGVtID0gdGhpcy5fa2V5TWFuYWdlci5hY3RpdmVJdGVtLmNvbnRhaW5lckVsZW1lbnQubmF0aXZlRWxlbWVudDtcbiAgICBjb25zdCBwYW5lbCA9IHRoaXMucGFuZWxCb2R5Lm5hdGl2ZUVsZW1lbnQ7XG4gICAgY29uc3QgcGFuZWxPZmZzZXQgPSBwYW5lbC5vZmZzZXRUb3A7ICAgLy8gaG93IG11Y2ggdGhlIG92ZXJsYXkgaXMgcmVwb3NpdGlvbmVkIG9uIHRoZSBwYWdlXG4gICAgY29uc3QgcGFuZWxUb3BTY3JvbGxQb3NpdGlvbiA9IHBhbmVsLnNjcm9sbFRvcDtcbiAgICBjb25zdCBwYW5lbEhlaWdodCA9IHBhbmVsLmNsaWVudEhlaWdodDtcbiAgICBjb25zdCBpdGVtVG9wID0gYWN0aXZlSXRlbS5vZmZzZXRUb3AgLSBwYW5lbE9mZnNldDtcbiAgICBjb25zdCBpdGVtQm90dG9tID0gYWN0aXZlSXRlbS5vZmZzZXRUb3AgLSBwYW5lbE9mZnNldCArIGFjdGl2ZUl0ZW0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkuaGVpZ2h0O1xuXG4gICAgLy8gaXRlbSBoYWxmIG9yIGxlc3MgdmlzaWJsZSBvbiB0b3BcbiAgICBpZiAoaXRlbVRvcCA8IHBhbmVsVG9wU2Nyb2xsUG9zaXRpb24pIHtcbiAgICAgIHRoaXMucGFuZWxCb2R5Lm5hdGl2ZUVsZW1lbnQuc2Nyb2xsVG9wID0gaXRlbVRvcDtcbiAgICAgIC8vIGl0ZW0gaGFsZiBvciBsZXNzIHZpc2libGUgb24gYm90dG9tXG4gICAgfSBlbHNlIGlmIChpdGVtQm90dG9tID4gKHBhbmVsVG9wU2Nyb2xsUG9zaXRpb24gKyBwYW5lbEhlaWdodCkpIHtcbiAgICAgIHRoaXMucGFuZWxCb2R5Lm5hdGl2ZUVsZW1lbnQuc2Nyb2xsVG9wID0gaXRlbUJvdHRvbSAtIHBhbmVsSGVpZ2h0O1xuICAgIH1cbiAgfVxuXG4gIC8qKiBAZG9jcy1wcml2YXRlICovXG4gIHByaXZhdGUgX2dldEl0ZW1PZmZzZXQoaXRlbSkge1xuICAgIGNvbnN0IGl0ZW1SZWN0ID0gaXRlbS5jb250YWluZXJFbGVtZW50Lm5hdGl2ZUVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG5cbiAgICByZXR1cm4gaXRlbVJlY3QudG9wICsgKGl0ZW1SZWN0LmhlaWdodCAvIDIpOyAvLyBnZXQgcG9zaXRpb24gb2YgdGhlIGl0ZW0ncyBjZW50ZXJcbiAgfVxuXG4gIC8qKlxuICAgKiBAZG9jcy1wcml2YXRlXG4gICAqIEZvcm1maWVsZCBJbXBsZW1lbnRhdGlvblxuICAgKi9cbiAgc2V0RGVzY3JpYmVkQnlJZHMoaWRzOiBzdHJpbmdbXSk6IHZvaWQge1xuICAgIHRoaXMuYXJpYURlc2NyaWJlZGJ5ID0gaWRzLmpvaW4oJyAnKTtcbiAgfVxuXG4gIC8qKiBAZG9jcy1wcml2YXRlICovXG4gIHNldEFyaWFMYWJlbCh2YWx1ZTogc3RyaW5nKSB7XG4gICAgdGhpcy5fYXJpYUxhYmVsID0gdmFsdWU7XG4gIH1cblxuICBfZ2V0QXJpYUxhYmVsKCkge1xuICAgIHJldHVybiB0aGlzLl9hcmlhTGFiZWwgfHwgKHRoaXMuZm9ybUZpZWxkQ29tcG9uZW50ID8gdGhpcy5mb3JtRmllbGRDb21wb25lbnQubGFiZWwgOiBudWxsKTtcbiAgfVxuXG4gIGdldCBfaXNJbk91dGxpbmVGaWVsZCgpOiBib29sZWFuIHtcbiAgICByZXR1cm4gdGhpcy5mb3JtRmllbGRDb21wb25lbnQgIT09IG51bGxcbiAgICAgICYmIHRoaXMuZm9ybUZpZWxkQ29tcG9uZW50LmFwcGVhcmFuY2UgPT09ICdvdXRsaW5lJztcbiAgfVxuXG4gIC8qKlxuICAgKiBAZG9jcy1wcml2YXRlXG4gICAqIFdoZXRoZXIgdGhlIHNlbGVjdCBoYXMgYSB2YWx1ZS5cbiAgICovXG4gIGdldCBlbXB0eSgpOiBib29sZWFuIHtcbiAgICByZXR1cm4gIXRoaXMuX3NlbGVjdGlvbk1vZGVsIHx8IHRoaXMuX3NlbGVjdGlvbk1vZGVsLmlzRW1wdHkoKTtcbiAgfVxuXG4gIC8qKiBAZG9jcy1wcml2YXRlICovXG4gIGdldCBoYXNWYWx1ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fc2VsZWN0aW9uTW9kZWwuaGFzVmFsdWUoKTtcbiAgfVxuXG4gIC8qKiBAZG9jcy1wcml2YXRlICovXG4gIGdldCBzaG91bGRMYWJlbEZsb2F0KCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0aGlzLmZvY3VzZWQgfHwgIXRoaXMuZW1wdHk7XG4gIH1cbiAgLyoqIEVuZCBGb3JtZmllbGQgKi9cblxuICAvKiogQ29udHJvbFZhbHVlQWNjZXNzb3IgKi9cbiAgLyoqXG4gICAqIFNldHMgdGhlIHNlbGVjdCdzIHZhbHVlLiBQYXJ0IG9mIHRoZSBDb250cm9sVmFsdWVBY2Nlc3NvciBpbnRlcmZhY2VcbiAgICogcmVxdWlyZWQgdG8gaW50ZWdyYXRlIHdpdGggQW5ndWxhcidzIGNvcmUgZm9ybXMgQVBJLlxuICAgKlxuICAgKiBAcGFyYW0gdmFsdWUgTmV3IHZhbHVlIHRvIGJlIHdyaXR0ZW4gdG8gdGhlIG1vZGVsLlxuICAgKi9cbiAgd3JpdGVWYWx1ZSh2YWx1ZTogYW55KTogdm9pZCB7XG4gICAgaWYgKHRoaXMub3B0aW9ucykge1xuICAgICAgdGhpcy5fc2V0U2VsZWN0aW9uQnlWYWx1ZSh2YWx1ZSk7XG4gICAgfVxuICB9XG5cbiAgcmVnaXN0ZXJPbkNoYW5nZShmbjogYW55KTogdm9pZCB7XG4gICAgdGhpcy5fb25DaGFuZ2UgPSBmbjtcbiAgfVxuXG4gIHJlZ2lzdGVyT25Ub3VjaGVkKGZuOiAoKSA9PiB2b2lkKTogdm9pZCB7XG4gICAgdGhpcy5fb25Ub3VjaGVkID0gZm47XG4gIH1cblxuICAvKipcbiAgICogRGlzYWJsZXMgdGhlIHNlbGVjdC4gUGFydCBvZiB0aGUgQ29udHJvbFZhbHVlQWNjZXNzb3IgaW50ZXJmYWNlIHJlcXVpcmVkXG4gICAqIHRvIGludGVncmF0ZSB3aXRoIEFuZ3VsYXIncyBjb3JlIGZvcm1zIEFQSS5cbiAgICpcbiAgICogQHBhcmFtIGlzRGlzYWJsZWQgU2V0cyB3aGV0aGVyIHRoZSBjb21wb25lbnQgaXMgZGlzYWJsZWQuXG4gICAqL1xuICBzZXREaXNhYmxlZFN0YXRlKGlzRGlzYWJsZWQ6IGJvb2xlYW4pOiB2b2lkIHtcbiAgICB0aGlzLmRpc2FibGVkID0gaXNEaXNhYmxlZDtcbiAgICB0aGlzLl9jaGFuZ2VEZXRlY3RvclJlZi5tYXJrRm9yQ2hlY2soKTtcbiAgICB0aGlzLnN0YXRlQ2hhbmdlcy5uZXh0KCk7XG4gIH1cbiAgLyoqIEVuZCBDb250cm9sVmFsdWVBY2Nlc3NvciAqL1xuXG4gIF9oYW5kbGVLZXlkb3duKGV2ZW50OiBLZXlib2FyZEV2ZW50KSB7XG4gICAgdGhpcy5wYW5lbE9wZW4gPyB0aGlzLl9oYW5kbGVPcGVuS2V5ZG93bihldmVudCkgOiB0aGlzLl9oYW5kbGVDbG9zZWRLZXlkb3duKGV2ZW50KTtcbiAgfVxuXG4gIHByaXZhdGUgX2hhbmRsZUNsb3NlZEtleWRvd24oZXZlbnQ6IEtleWJvYXJkRXZlbnQpIHtcbiAgICBjb25zdCBrZXlDb2RlID0gZXZlbnQua2V5Q29kZTtcbiAgICBjb25zdCBpc0Fycm93S2V5ID0ga2V5Q29kZSA9PT0gRE9XTl9BUlJPVyB8fCBrZXlDb2RlID09PSBVUF9BUlJPVyB8fFxuICAgICAga2V5Q29kZSA9PT0gTEVGVF9BUlJPVyB8fCBrZXlDb2RlID09PSBSSUdIVF9BUlJPVztcbiAgICBjb25zdCBpc09wZW5LZXkgPSBrZXlDb2RlID09PSBFTlRFUiB8fCBrZXlDb2RlID09PSBTUEFDRTtcblxuICAgIC8vIE9wZW4gdGhlIHNlbGVjdCBvbiBBTFQgKyBhcnJvdyBrZXkgdG8gbWF0Y2ggdGhlIG5hdGl2ZSA8c2VsZWN0PlxuICAgIGlmIChpc09wZW5LZXkgfHwgKCh0aGlzLmlzTXVsdGlTZWxlY3QgfHwgZXZlbnQuYWx0S2V5KSAmJiBpc0Fycm93S2V5KSkge1xuICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTsgLy8gcHJldmVudHMgdGhlIHBhZ2UgZnJvbSBzY3JvbGxpbmcgZG93biB3aGVuIHByZXNzaW5nIHNwYWNlXG4gICAgICB0aGlzLm9wZW5QYW5lbCgpO1xuICAgIH0gZWxzZSBpZiAoIXRoaXMuaXNNdWx0aVNlbGVjdCAmJiAhdGhpcy5kaXNhYmxlZCkge1xuICAgICAgdGhpcy5fa2V5TWFuYWdlci5vbktleWRvd24oZXZlbnQpO1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgX2hhbmRsZU9wZW5LZXlkb3duKGV2ZW50OiBLZXlib2FyZEV2ZW50KSB7XG4gICAgY29uc3Qga2V5Q29kZSA9IGV2ZW50LmtleUNvZGU7XG4gICAgLy8gaWYgaGFzIGZpbHRlciBhbGwgZXZlbnRzIG90aGVyIHRoYW4gdGhlIGxpc3RlZCBvbmVzIHNob3VsZCBiZSBpZ25vcmVkIG9yIGhhbmRsZWQgaW4gX29uRmlsdGVyKClcbiAgICBpZiAoIShbRE9XTl9BUlJPVywgVVBfQVJST1csIEhPTUUsIEVORCwgRU5URVIsIExFRlRfQVJST1csIFJJR0hUX0FSUk9XLCBTSElGVCwgU1BBQ0UsIFRBQl0uaW5kZXhPZihrZXlDb2RlKSA+PSAwKVxuICAgICAgICAgJiYgdGhpcy5zaG93RmlsdGVyKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgaXNBcnJvd0tleSA9IGtleUNvZGUgPT09IERPV05fQVJST1cgfHwga2V5Q29kZSA9PT0gVVBfQVJST1c7XG4gICAgY29uc3QgbWFuYWdlciA9IHRoaXMuX2tleU1hbmFnZXI7XG5cbiAgICBjb25zdCBhbGxIaWRkZW4gPSB0aGlzLm9wdGlvbnMubWFwKG9wdGlvbiA9PiBvcHRpb24uX2hpZGRlbikuZXZlcnkob3B0aW9uID0+IEJvb2xlYW4ob3B0aW9uKSk7XG5cbiAgICBpZiAoa2V5Q29kZSA9PT0gSE9NRSB8fCBrZXlDb2RlID09PSBFTkQpIHtcbiAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICBrZXlDb2RlID09PSBIT01FID8gbWFuYWdlci5zZXRGaXJzdEl0ZW1BY3RpdmUoKSA6IG1hbmFnZXIuc2V0TGFzdEl0ZW1BY3RpdmUoKTtcbiAgICB9IGVsc2UgaWYgKGlzQXJyb3dLZXkgJiYgZXZlbnQuYWx0S2V5KSB7XG4gICAgICAvLyBDbG9zZSB0aGUgc2VsZWN0IG9uIEFMVCArIGFycm93IGtleSB0byBtYXRjaCB0aGUgbmF0aXZlIDxzZWxlY3Q+XG4gICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgdGhpcy5jbG9zZVBhbmVsKCk7XG4gICAgfSBlbHNlIGlmIChrZXlDb2RlID09PSBFTlRFUiAmJiBtYW5hZ2VyLmFjdGl2ZUl0ZW0gJiYgIWFsbEhpZGRlbikge1xuICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcblxuICAgICAgbWFuYWdlci5hY3RpdmVJdGVtLl9zZWxlY3RWaWFJbnRlcmFjdGlvbigpO1xuICAgIH0gZWxzZSBpZiAoa2V5Q29kZSA9PT0gRU5URVIgJiYgYWxsSGlkZGVuKSB7XG4gICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgICB0aGlzLmNsb3NlUGFuZWwoKTtcbiAgICB9IGVsc2UgaWYgKCF0aGlzLnNob3dGaWx0ZXIgJiYga2V5Q29kZSA9PT0gU1BBQ0UgJiYgbWFuYWdlci5hY3RpdmVJdGVtKSB7XG4gICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgbWFuYWdlci5hY3RpdmVJdGVtLl9zZWxlY3RWaWFJbnRlcmFjdGlvbigpO1xuICAgIH0gZWxzZSBpZiAoa2V5Q29kZSA9PT0gVEFCKSB7XG4gICAgICB0aGlzLmNsb3NlUGFuZWwoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgcHJldmlvdXNseUZvY3VzZWRJbmRleCA9IG1hbmFnZXIuYWN0aXZlSXRlbUluZGV4O1xuICAgICAgbWFuYWdlci5vbktleWRvd24oZXZlbnQpO1xuXG4gICAgICB0aGlzLl9uZ1pvbmUub25TdGFibGVcbiAgICAgICAgLmFzT2JzZXJ2YWJsZSgpXG4gICAgICAucGlwZShcbiAgICAgICAgdGFrZSgxKSxcbiAgICAgICAgZGVsYXkoMjUxKSAvLyB3ZSBuZWVkIHRvIGRlZmVyIHRvIGdldCB0aGUgbmV3IGFjdGl2ZUl0ZW1JbmRleC4gZGVsYXkgPiBkZWJvdW5jaW5nIG9mIHRoZSB0eXBlQWhlYWRcbiAgICAgICApLnN1YnNjcmliZSgoKSA9PiB7XG4gICAgICAgICAgdGhpcy5pc1N0YWJsZSA9IHRydWU7XG4gICAgICAgICAgdGhpcy5fY2hhbmdlRGV0ZWN0b3JSZWYuZGV0ZWN0Q2hhbmdlcygpO1xuICAgICAgICB9KTtcblxuICAgICAgaWYgKHRoaXMuaXNNdWx0aVNlbGVjdCAmJiBpc0Fycm93S2V5ICYmIGV2ZW50LnNoaWZ0S2V5ICYmIG1hbmFnZXIuYWN0aXZlSXRlbSAmJlxuICAgICAgICBtYW5hZ2VyLmFjdGl2ZUl0ZW1JbmRleCAhPT0gcHJldmlvdXNseUZvY3VzZWRJbmRleCkge1xuICAgICAgICBtYW5hZ2VyLmFjdGl2ZUl0ZW0uX3NlbGVjdFZpYUludGVyYWN0aW9uKCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqIEBkb2NzLXByaXZhdGUgKi9cbiAgZm9ybWF0VmFsdWUodmFsdWUpOiBzdHJpbmcge1xuICAgIHJldHVybiB0aGlzLnZhbHVlRm9ybWF0dGVyKHZhbHVlKTtcbiAgfVxuXG4gIC8qKiBDYWxsZWQgd2hlbiB0aGUgdXNlciB0eXBlcyBpbiB0aGUgZmlsdGVyIGlucHV0ICovXG4gIF9vbkZpbHRlcihldmVudCkge1xuICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgdGhpcy5jdXJyZW50RmlsdGVyID0gZXZlbnQudGFyZ2V0LnZhbHVlO1xuICAgIHRoaXMuZmlsdGVyQ2hhbmdlcy5uZXh0KGV2ZW50LnRhcmdldC52YWx1ZSk7XG4gICAgY29uc3QgYWxsSGlkZGVuID0gdGhpcy5vcHRpb25zLm1hcChvcHRpb24gPT4gb3B0aW9uLl9oaWRkZW4pLmV2ZXJ5KG9wdGlvbiA9PiBCb29sZWFuKG9wdGlvbikpO1xuICAgIGlmIChhbGxIaWRkZW4pIHtcbiAgICAgIHRoaXMuX2tleU1hbmFnZXIuc2V0QWN0aXZlSXRlbShudWxsKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fa2V5TWFuYWdlci5zZXRGaXJzdEl0ZW1BY3RpdmUoKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQGRvY3MtcHJpdmF0ZVxuICAgKiBUaGUgdmFsdWUgZGlzcGxheWVkIGluIHRoZSB0cmlnZ2VyLlxuICAgKi9cbiAgZ2V0IHRyaWdnZXJWYWx1ZSgpOiBzdHJpbmcge1xuXG4gICAgaWYgKHRoaXMuZW1wdHkpIHtcbiAgICAgIHJldHVybiAnJztcbiAgICB9XG5cbiAgICBpZiAodGhpcy5pc011bHRpU2VsZWN0KSB7XG4gICAgICBjb25zdCBzZWxlY3RlZE9wdGlvbnMgPSB0aGlzLl9zZWxlY3Rpb25Nb2RlbC5zZWxlY3RlZC5tYXAob3B0aW9uID0+IG9wdGlvbi52aWV3VmFsdWUpO1xuXG4gICAgICByZXR1cm4gc2VsZWN0ZWRPcHRpb25zLmpvaW4oJywgJyk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9zZWxlY3Rpb25Nb2RlbC5zZWxlY3RlZFswXS52aWV3VmFsdWU7XG4gIH1cblxuICAvKipcbiAgICogSGlnaGxpZ2h0cyB0aGUgc2VsZWN0ZWQgaXRlbS4gSWYgbm8gb3B0aW9uIGlzIHNlbGVjdGVkLCBpdCB3aWxsIGhpZ2hsaWdodFxuICAgKiB0aGUgZmlyc3QgaXRlbSBpbnN0ZWFkLlxuICAgKi9cbiAgcHJpdmF0ZSBfaGlnaGxpZ2h0Q29ycmVjdE9wdGlvbigpOiB2b2lkIHtcbiAgICBpZiAodGhpcy5fa2V5TWFuYWdlcikge1xuICAgICAgaWYgKHRoaXMuZW1wdHkpIHtcbiAgICAgICAgdGhpcy5fa2V5TWFuYWdlci5zZXRGaXJzdEl0ZW1BY3RpdmUoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX2tleU1hbmFnZXIuc2V0QWN0aXZlSXRlbSh0aGlzLl9zZWxlY3Rpb25Nb2RlbC5zZWxlY3RlZFswXSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENhbGxiYWNrIHRoYXQgaXMgaW52b2tlZCB3aGVuIHRoZSBvdmVybGF5IHBhbmVsIGhhcyBiZWVuIGF0dGFjaGVkLlxuICAgKi9cbiAgX29uQXR0YWNoZWQoKTogdm9pZCB7XG4gICAgdGhpcy5vdmVybGF5RGlyLnBvc2l0aW9uQ2hhbmdlLnBpcGUodGFrZSgxKSkuc3Vic2NyaWJlKCgpID0+IHtcbiAgICAgIGNvbnN0IG92ZXJsYXlSZWYgPSB0aGlzLm92ZXJsYXlEaXIub3ZlcmxheVJlZjtcbiAgICAgIGNvbnN0IHBvc2l0aW9uU3RyYXRlZ3kgPSBvdmVybGF5UmVmLmdldENvbmZpZygpXG4gICAgICAgIC5wb3NpdGlvblN0cmF0ZWd5IGFzIEZsZXhpYmxlQ29ubmVjdGVkUG9zaXRpb25TdHJhdGVneTtcblxuICAgICAgdGhpcy5fdXBkYXRlUG9zaXRpb25PZmZzZXQoKTtcbiAgICAgIHBvc2l0aW9uU3RyYXRlZ3kud2l0aFBvc2l0aW9ucyh0aGlzLl9wb3NpdGlvbnMuc2xpY2UoKSk7XG4gICAgICBvdmVybGF5UmVmLnVwZGF0ZVBvc2l0aW9uKCk7XG5cbiAgICAgIGlmICh0aGlzLl9rZXlNYW5hZ2VyLmFjdGl2ZUl0ZW0pIHtcbiAgICAgICAgdGhpcy5fY2FsY3VsYXRlU2Nyb2xsVG9wKCk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX2NoYW5nZURldGVjdG9yUmVmLm1hcmtGb3JDaGVjaygpO1xuICAgICAgdGhpcy5vcGVuZWRDaGFuZ2UuZW1pdCh0cnVlKTtcblxuICAgICAgLy8gSWYgdGhlcmUgaXMgbm8gaXRlbSBzZWxlY3RlZCwgdGhlIGZpbHRlciB0YWtlcyB0aGUgZm9jdXMuXG4gICAgICBpZiAodGhpcy5zaG93RmlsdGVyICYmICF0aGlzLl92YWx1ZSkge1xuICAgICAgICB0aGlzLmZpbHRlcklucHV0Lm5hdGl2ZUVsZW1lbnQuZm9jdXMoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMucGFuZWxCb2R5Lm5hdGl2ZUVsZW1lbnQuZm9jdXMoKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIF9vbkZvY3VzKCkge1xuICAgIGlmICghdGhpcy5kaXNhYmxlZCkge1xuICAgICAgdGhpcy5fZm9jdXNlZCA9IHRydWU7XG4gICAgICB0aGlzLnN0YXRlQ2hhbmdlcy5uZXh0KCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENhbGxzIHRoZSB0b3VjaGVkIGNhbGxiYWNrIG9ubHkgaWYgdGhlIHBhbmVsIGlzIGNsb3NlZC4gT3RoZXJ3aXNlLCB0aGUgdHJpZ2dlciB3aWxsXG4gICAqIFwiYmx1clwiIHRvIHRoZSBwYW5lbCB3aGVuIGl0IG9wZW5zLCBjYXVzaW5nIGEgZmFsc2UgcG9zaXRpdmUuXG4gICAqL1xuICBfb25CbHVyKCkge1xuICAgIHRoaXMuX2ZvY3VzZWQgPSBmYWxzZTtcblxuICAgIGlmICh0aGlzLmZpbHRlcklucHV0ICYmIHRoaXMuc2hvd0ZpbHRlcikge1xuICAgICAgdGhpcy5fY2xlYXJGaWx0ZXIoKTtcbiAgICB9XG5cbiAgICBpZiAoIXRoaXMuZGlzYWJsZWQgJiYgIXRoaXMucGFuZWxPcGVuKSB7XG4gICAgICB0aGlzLl9vblRvdWNoZWQoKTtcbiAgICAgIHRoaXMuX2NoYW5nZURldGVjdG9yUmVmLm1hcmtGb3JDaGVjaygpO1xuICAgICAgdGhpcy5zdGF0ZUNoYW5nZXMubmV4dCgpO1xuICAgIH1cbiAgfVxuXG4gIC8qKiBAZG9jcy1wcml2YXRlICovXG4gIGdldCBpc0ZpbHRlckVtcHR5KCkge1xuICAgIHJldHVybiB0aGlzLmN1cnJlbnRGaWx0ZXIubGVuZ3RoID09PSAwO1xuICB9XG5cbiAgLyoqIEBkb2NzLXByaXZhdGUgKi9cbiAgX2NsZWFyRmlsdGVyKCkge1xuICAgIHRoaXMuZmlsdGVySW5wdXQubmF0aXZlRWxlbWVudC52YWx1ZSA9ICcnO1xuICAgIHRoaXMuY3VycmVudEZpbHRlciA9ICcnO1xuICAgIHRoaXMuZmlsdGVyQ2hhbmdlcy5uZXh0KCcnKTtcbiAgfVxuXG4gIC8qKiBAZG9jcy1wcml2YXRlIGRldGVybWluZXMgdGhlIGBhcmlhLWFjdGl2ZWRlc2NlbmRhbnRgIHRvIGJlIHNldCBvbiB0aGUgaG9zdC4gKi9cbiAgX2dldEFyaWFBY3RpdmVEZXNjZW5kYW50KCk6IHN0cmluZyB8IG51bGwge1xuICAgIGlmICh0aGlzLnBhbmVsT3BlbiAmJiB0aGlzLl9rZXlNYW5hZ2VyICYmIHRoaXMuX2tleU1hbmFnZXIuYWN0aXZlSXRlbSkge1xuICAgICAgcmV0dXJuIHRoaXMuX2tleU1hbmFnZXIuYWN0aXZlSXRlbS5pZDtcbiAgICB9XG5cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxufVxuIl19