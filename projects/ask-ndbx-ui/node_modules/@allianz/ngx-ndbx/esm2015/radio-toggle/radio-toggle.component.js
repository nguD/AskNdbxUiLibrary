/**
 * @fileoverview added by tsickle
 * Generated from: radio-toggle/radio-toggle.component.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import { coerceBooleanProperty } from '@angular/cdk/coercion';
import { mapClassNames } from '@allianz/ngx-ndbx/utils';
import { ChangeDetectionStrategy, Component, ContentChildren, ElementRef, Input, QueryList, Renderer2, ViewChild, ChangeDetectorRef, Optional, Self } from '@angular/core';
import { FormGroupDirective, NgControl, NgForm } from '@angular/forms';
import { Subject, merge } from 'rxjs';
import { filter, startWith, takeUntil } from 'rxjs/operators';
import { ErrorStateMatcher } from '@allianz/ngx-ndbx/utils';
import { NxRadioToggleButtonBaseComponent } from './radio-toggle-button-base.component';
/** @type {?} */
let nextId = 0;
/** @type {?} */
const MAPPING = {
    'negative': 'nx-radio-toggle--negative',
    'small': 'nx-radio-toggle--small',
};
export class NxRadioToggleComponent {
    /**
     * @param {?} renderer
     * @param {?} _changeDetectorRef
     * @param {?} ngControl
     * @param {?} _errorStateMatcher
     * @param {?} _parentForm
     * @param {?} _parentFormGroup
     */
    constructor(renderer, _changeDetectorRef, ngControl, _errorStateMatcher, _parentForm, _parentFormGroup) {
        this.renderer = renderer;
        this._changeDetectorRef = _changeDetectorRef;
        this.ngControl = ngControl;
        this._errorStateMatcher = _errorStateMatcher;
        this._parentForm = _parentForm;
        this._parentFormGroup = _parentFormGroup;
        this._toggleId = (nextId++).toString();
        this._destroyed = new Subject();
        this._disabled = false;
        /**
         * \@docs-private
         */
        this.errorState = false;
        // emits to signal children to run change detection
        this._disableChange = new Subject();
        /**
         * \@docs-private
         */
        this.toggleButtons = new QueryList();
        this.onTouchedCallback = (/**
         * @return {?}
         */
        () => { });
        this.onChangeCallback = (/**
         * @param {?} option
         * @return {?}
         */
        (option) => { });
        if (this.ngControl) {
            // Note: we provide the value accessor through here, instead of
            // the `providers` to avoid running into a circular import.
            this.ngControl.valueAccessor = this;
        }
    }
    /**
     * Sets the component to the disabled state.
     * @param {?} value
     * @return {?}
     */
    set disabled(value) {
        /** @type {?} */
        const coerced = coerceBooleanProperty(value);
        if (this._disabled !== coerced) {
            this._disabled = coerced;
            this._disableChange.next();
        }
    }
    /**
     * @return {?}
     */
    get disabled() {
        return this._disabled;
    }
    /**
     * Sets the name used for accessibility.
     * @param {?} value
     * @return {?}
     */
    set name(value) {
        if (this._name !== value) {
            this._name = value;
            this._changeDetectorRef.markForCheck();
        }
    }
    /**
     * @return {?}
     */
    get name() {
        return this._name;
    }
    /**
     * @return {?}
     */
    ngAfterViewInit() {
        this.subscribeToToggleButtonsChange();
    }
    /**
     * @return {?}
     */
    ngAfterContentInit() {
        /** @type {?} */
        const changedOrDestroyed = merge(this.toggleButtons.changes, this._destroyed);
        merge(...this.toggleButtons.map((/**
         * @param {?} button
         * @return {?}
         */
        (button) => button.onChecked)))
            .pipe(takeUntil(changedOrDestroyed))
            .subscribe((/**
         * @param {?} change
         * @return {?}
         */
        (change) => {
            this._selection = change.value;
            this.onChangeCallback(this._selection);
        }));
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this._destroyed.next();
        this._destroyed.complete();
        this._disableChange.complete();
    }
    /**
     * @return {?}
     */
    ngDoCheck() {
        if (this.ngControl) {
            // We need to re-evaluate this on every change detection cycle, because there are some
            // error triggers that we can't subscribe to (e.g. parent form submissions). This means
            // that whatever logic is in here has to be super lean or we risk destroying the performance.
            this.updateErrorState();
        }
    }
    /**
     * \@docs-private
     * @return {?}
     */
    subscribeToToggleButtonsChange() {
        this.toggleButtons.changes
            .pipe(startWith(this.toggleButtons), filter((/**
         * @param {?} toggles
         * @return {?}
         */
        toggles => toggles.length > 0)), takeUntil(this._destroyed)).subscribe((/**
         * @param {?} toggles
         * @return {?}
         */
        (toggles) => {
            toggles.forEach((/**
             * @param {?} toggle
             * @return {?}
             */
            toggle => {
                toggle.resetClasses();
                if (toggle.value === this.selection) {
                    // We need to defer the selection for the edge case that the button with the value of this.selection
                    // didn't exist yet but was added afterwards to prevent changed after checked errors
                    setTimeout((/**
                     * @return {?}
                     */
                    () => toggle.select()));
                }
            }));
            toggles.first.setFirstButton();
            toggles.last.setLastButton();
        }));
    }
    /**
     * @param {?} onChangeCallback
     * @return {?}
     */
    registerOnChange(onChangeCallback) {
        this.onChangeCallback = onChangeCallback;
    }
    /**
     * @param {?} onTouchedCallback
     * @return {?}
     */
    registerOnTouched(onTouchedCallback) {
        this.onTouchedCallback = onTouchedCallback;
    }
    /**
     * Preselects the respective options.
     * @param {?} value
     * @return {?}
     */
    writeValue(value) {
        this._selection = value;
        /** @type {?} */
        const correspondingButton = this.toggleButtons.find((/**
         * @param {?} button
         * @return {?}
         */
        (button) => button.value === this._selection));
        if (correspondingButton) {
            ((/** @type {?} */ (correspondingButton))).select();
        }
    }
    /**
     * @param {?} isDisabled
     * @return {?}
     */
    setDisabledState(isDisabled) {
        this.disabled = isDisabled;
    }
    /**
     * \@docs-private
     * @return {?}
     */
    get id() {
        return `nx-radio-toggle-${this._toggleId}`;
    }
    /**
     * Sets the modifiers for the component.
     * @param {?} value
     * @return {?}
     */
    set style(value) {
        /** @type {?} */
        const modifierClasses = mapClassNames(value, [], MAPPING);
        modifierClasses.split(' ')
            .forEach((/**
         * @param {?} className
         * @return {?}
         */
        className => this.renderer.addClass(this.toggleContainer.nativeElement, className)));
    }
    /**
     * \@docs-private
     * @param {?} selection
     * @return {?}
     */
    set selection(selection) {
        this._selection = selection;
        this.onChangeCallback(selection);
    }
    /**
     * @return {?}
     */
    get selection() {
        return this._selection;
    }
    /**
     * \@docs-private
     * @param {?} value
     * @return {?}
     */
    change(value) {
        this.onChangeCallback(value);
        if (this.onTouchedCallback) {
            this.onTouchedCallback();
        }
    }
    /**
     * \@docs-private
     * @return {?}
     */
    updateErrorState() {
        /** @type {?} */
        const oldState = this.errorState;
        /** @type {?} */
        const parent = this._parentFormGroup || this._parentForm;
        /** @type {?} */
        const control = this.ngControl ? (/** @type {?} */ (this.ngControl.control)) : null;
        /** @type {?} */
        const newState = this._errorStateMatcher.isErrorState(control, parent);
        if (newState !== oldState) {
            this.errorState = newState;
        }
    }
}
NxRadioToggleComponent.decorators = [
    { type: Component, args: [{
                selector: 'nx-radio-toggle',
                template: "<div #toggleContainer class=\"nx-radio-toggle\" role=\"radiogroup\" [attr.aria-label]=\"name\">\n   <ng-content></ng-content>\n</div>\n",
                changeDetection: ChangeDetectionStrategy.OnPush,
                styles: [":host{display:block}.nx-radio-toggle{display:flex;height:100%}@media (max-width:703px){.nx-radio-toggle{flex-direction:column;text-align:center;width:100%;justify-content:center;align-items:center}}"]
            }] }
];
/** @nocollapse */
NxRadioToggleComponent.ctorParameters = () => [
    { type: Renderer2 },
    { type: ChangeDetectorRef },
    { type: NgControl, decorators: [{ type: Optional }, { type: Self }] },
    { type: ErrorStateMatcher },
    { type: NgForm, decorators: [{ type: Optional }] },
    { type: FormGroupDirective, decorators: [{ type: Optional }] }
];
NxRadioToggleComponent.propDecorators = {
    disabled: [{ type: Input, args: ['nxDisabled',] }],
    toggleContainer: [{ type: ViewChild, args: ['toggleContainer', { static: true },] }],
    name: [{ type: Input, args: ['nxName',] }],
    toggleButtons: [{ type: ContentChildren, args: [NxRadioToggleButtonBaseComponent,] }],
    writeValue: [{ type: Input, args: ['nxSelection',] }],
    style: [{ type: Input, args: ['nxStyle',] }]
};
if (false) {
    /**
     * @type {?}
     * @private
     */
    NxRadioToggleComponent.prototype._toggleId;
    /**
     * @type {?}
     * @private
     */
    NxRadioToggleComponent.prototype._selection;
    /**
     * @type {?}
     * @private
     */
    NxRadioToggleComponent.prototype._destroyed;
    /**
     * @type {?}
     * @private
     */
    NxRadioToggleComponent.prototype._disabled;
    /**
     * \@docs-private
     * @type {?}
     */
    NxRadioToggleComponent.prototype.errorState;
    /** @type {?} */
    NxRadioToggleComponent.prototype._disableChange;
    /**
     * @type {?}
     * @private
     */
    NxRadioToggleComponent.prototype.toggleContainer;
    /**
     * @type {?}
     * @private
     */
    NxRadioToggleComponent.prototype._name;
    /**
     * \@docs-private
     * @type {?}
     */
    NxRadioToggleComponent.prototype.toggleButtons;
    /**
     * @type {?}
     * @private
     */
    NxRadioToggleComponent.prototype.onTouchedCallback;
    /**
     * @type {?}
     * @private
     */
    NxRadioToggleComponent.prototype.onChangeCallback;
    /**
     * @type {?}
     * @private
     */
    NxRadioToggleComponent.prototype.renderer;
    /**
     * @type {?}
     * @private
     */
    NxRadioToggleComponent.prototype._changeDetectorRef;
    /**
     * \@docs-private
     * @type {?}
     */
    NxRadioToggleComponent.prototype.ngControl;
    /**
     * @type {?}
     * @private
     */
    NxRadioToggleComponent.prototype._errorStateMatcher;
    /**
     * @type {?}
     * @private
     */
    NxRadioToggleComponent.prototype._parentForm;
    /**
     * @type {?}
     * @private
     */
    NxRadioToggleComponent.prototype._parentFormGroup;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicmFkaW8tdG9nZ2xlLmNvbXBvbmVudC5qcyIsInNvdXJjZVJvb3QiOiJuZzovL0BhbGxpYW56L25neC1uZGJ4LyIsInNvdXJjZXMiOlsicmFkaW8tdG9nZ2xlL3JhZGlvLXRvZ2dsZS5jb21wb25lbnQudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQSxPQUFPLEVBQUUscUJBQXFCLEVBQUUsTUFBTSx1QkFBdUIsQ0FBQztBQUM5RCxPQUFPLEVBQUUsYUFBYSxFQUFFLE1BQU0seUJBQXlCLENBQUM7QUFDeEQsT0FBTyxFQUdMLHVCQUF1QixFQUN2QixTQUFTLEVBQ1QsZUFBZSxFQUNmLFVBQVUsRUFDVixLQUFLLEVBRUwsU0FBUyxFQUNULFNBQVMsRUFDVCxTQUFTLEVBQ1QsaUJBQWlCLEVBQ2pCLFFBQVEsRUFDUixJQUFJLEVBRUwsTUFBTSxlQUFlLENBQUM7QUFDdkIsT0FBTyxFQUFxQyxrQkFBa0IsRUFBRSxTQUFTLEVBQUUsTUFBTSxFQUFFLE1BQU0sZ0JBQWdCLENBQUM7QUFDMUcsT0FBTyxFQUFFLE9BQU8sRUFBRSxLQUFLLEVBQUUsTUFBTSxNQUFNLENBQUM7QUFDdEMsT0FBTyxFQUFFLE1BQU0sRUFBRSxTQUFTLEVBQUUsU0FBUyxFQUFFLE1BQU0sZ0JBQWdCLENBQUM7QUFDOUQsT0FBTyxFQUFFLGlCQUFpQixFQUFFLE1BQU0seUJBQXlCLENBQUM7QUFDNUQsT0FBTyxFQUFFLGdDQUFnQyxFQUFFLE1BQU0sc0NBQXNDLENBQUM7O0lBR3BGLE1BQU0sR0FBRyxDQUFDOztNQUVSLE9BQU8sR0FBRztJQUNkLFVBQVUsRUFBRSwyQkFBMkI7SUFDdkMsT0FBTyxFQUFFLHdCQUF3QjtDQUNsQztBQVFELE1BQU0sT0FBTyxzQkFBc0I7Ozs7Ozs7OztJQXNEakMsWUFBb0IsUUFBbUIsRUFDbkIsa0JBQXFDLEVBRWxCLFNBQW9CLEVBQ3ZDLGtCQUFxQyxFQUN6QixXQUFtQixFQUNuQixnQkFBb0M7UUFOaEQsYUFBUSxHQUFSLFFBQVEsQ0FBVztR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bURBQXNDOzs7OztJQUV0QyxrREFBZ0Q7Ozs7O0lBRXBDLDBDQUEyQjs7Ozs7SUFDM0Isb0RBQTZDOzs7OztJQUU3QywyQ0FBK0M7Ozs7O0lBQy9DLG9EQUE2Qzs7Ozs7SUFDN0MsNkNBQXVDOzs7OztJQUN2QyxrREFBd0QiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBjb2VyY2VCb29sZWFuUHJvcGVydHkgfSBmcm9tICdAYW5ndWxhci9jZGsvY29lcmNpb24nO1xuaW1wb3J0IHsgbWFwQ2xhc3NOYW1lcyB9IGZyb20gJ0BhbGxpYW56L25neC1uZGJ4L3V0aWxzJztcbmltcG9ydCB7XG4gIEFmdGVyQ29udGVudEluaXQsXG4gIEFmdGVyVmlld0luaXQsXG4gIENoYW5nZURldGVjdGlvblN0cmF0ZWd5LFxuICBDb21wb25lbnQsXG4gIENvbnRlbnRDaGlsZHJlbixcbiAgRWxlbWVudFJlZixcbiAgSW5wdXQsXG4gIE9uRGVzdHJveSxcbiAgUXVlcnlMaXN0LFxuICBSZW5kZXJlcjIsXG4gIFZpZXdDaGlsZCxcbiAgQ2hhbmdlRGV0ZWN0b3JSZWYsXG4gIE9wdGlvbmFsLFxuICBTZWxmLFxuICBEb0NoZWNrXG59IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgQ29udHJvbFZhbHVlQWNjZXNzb3IsIEZvcm1Db250cm9sLCBGb3JtR3JvdXBEaXJlY3RpdmUsIE5nQ29udHJvbCwgTmdGb3JtIH0gZnJvbSAnQGFuZ3VsYXIvZm9ybXMnO1xuaW1wb3J0IHsgU3ViamVjdCwgbWVyZ2UgfSBmcm9tICdyeGpzJztcbmltcG9ydCB7IGZpbHRlciwgc3RhcnRXaXRoLCB0YWtlVW50aWwgfSBmcm9tICdyeGpzL29wZXJhdG9ycyc7XG5pbXBvcnQgeyBFcnJvclN0YXRlTWF0Y2hlciB9IGZyb20gJ0BhbGxpYW56L25neC1uZGJ4L3V0aWxzJztcbmltcG9ydCB7IE54UmFkaW9Ub2dnbGVCdXR0b25CYXNlQ29tcG9uZW50IH0gZnJvbSAnLi9yYWRpby10b2dnbGUtYnV0dG9uLWJhc2UuY29tcG9uZW50JztcbmltcG9ydCB7IE54UmFkaW9Ub2dnbGVCdXR0b25DaGFuZ2UsIE54UmFkaW9Ub2dnbGVCdXR0b25Db21wb25lbnQgfSBmcm9tICcuL3JhZGlvLXRvZ2dsZS1idXR0b24uY29tcG9uZW50JztcblxubGV0IG5leHRJZCA9IDA7XG5cbmNvbnN0IE1BUFBJTkcgPSB7XG4gICduZWdhdGl2ZSc6ICdueC1yYWRpby10b2dnbGUtLW5lZ2F0aXZlJyxcbiAgJ3NtYWxsJzogJ254LXJhZGlvLXRvZ2dsZS0tc21hbGwnLFxufTtcblxuQENvbXBvbmVudCh7XG4gIHNlbGVjdG9yOiAnbngtcmFkaW8tdG9nZ2xlJyxcbiAgdGVtcGxhdGVVcmw6ICdyYWRpby10b2dnbGUuY29tcG9uZW50Lmh0bWwnLFxuICBjaGFuZ2VEZXRlY3Rpb246IENoYW5nZURldGVjdGlvblN0cmF0ZWd5Lk9uUHVzaCxcbiAgc3R5bGVVcmxzOiBbJ3JhZGlvLXRvZ2dsZS5jb21wb25lbnQuc2NzcyddXG59KVxuZXhwb3J0IGNsYXNzIE54UmFkaW9Ub2dnbGVDb21wb25lbnQgaW1wbGVtZW50cyBDb250cm9sVmFsdWVBY2Nlc3NvciwgQWZ0ZXJWaWV3SW5pdCwgT25EZXN0cm95LFxuICBBZnRlckNvbnRlbnRJbml0LCBEb0NoZWNrICB7XG5cbiAgcHJpdmF0ZSBfdG9nZ2xlSWQ6IHN0cmluZyA9IChuZXh0SWQrKykudG9TdHJpbmcoKTtcblxuICBwcml2YXRlIF9zZWxlY3Rpb246IGFueTtcblxuICBwcml2YXRlIF9kZXN0cm95ZWQ6IFN1YmplY3Q8dm9pZD4gPSBuZXcgU3ViamVjdCgpO1xuXG4gIHByaXZhdGUgX2Rpc2FibGVkOiBib29sZWFuID0gZmFsc2U7XG4gIC8qKiBAZG9jcy1wcml2YXRlICovXG4gIGVycm9yU3RhdGU6IGJvb2xlYW4gPSBmYWxzZTtcbiAgLy8gZW1pdHMgdG8gc2lnbmFsIGNoaWxkcmVuIHRvIHJ1biBjaGFuZ2UgZGV0ZWN0aW9uXG4gIF9kaXNhYmxlQ2hhbmdlID0gbmV3IFN1YmplY3Q8dm9pZD4oKTtcblxuICAvKiogU2V0cyB0aGUgY29tcG9uZW50IHRvIHRoZSBkaXNhYmxlZCBzdGF0ZS4qL1xuICBASW5wdXQoJ254RGlzYWJsZWQnKVxuICBzZXQgZGlzYWJsZWQodmFsdWU6IGJvb2xlYW4pIHtcbiAgICBjb25zdCBjb2VyY2VkID0gY29lcmNlQm9vbGVhblByb3BlcnR5KHZhbHVlKTtcbiAgICBpZiAodGhpcy5fZGlzYWJsZWQgIT09IGNvZXJjZWQpIHtcbiAgICAgIHRoaXMuX2Rpc2FibGVkID0gY29lcmNlZDtcbiAgICAgIHRoaXMuX2Rpc2FibGVDaGFuZ2UubmV4dCgpO1xuICAgIH1cbiAgfVxuXG4gIGdldCBkaXNhYmxlZCgpOiBib29sZWFuIHtcbiAgICByZXR1cm4gdGhpcy5fZGlzYWJsZWQ7XG4gIH1cblxuICBAVmlld0NoaWxkKCd0b2dnbGVDb250YWluZXInLCB7IHN0YXRpYzogdHJ1ZSB9KVxuICBwcml2YXRlIHRvZ2dsZUNvbnRhaW5lcjogRWxlbWVudFJlZjtcblxuICBwcml2YXRlIF9uYW1lOiBzdHJpbmc7XG5cbiAgLyoqIFNldHMgdGhlIG5hbWUgdXNlZCBmb3IgYWNjZXNzaWJpbGl0eS4gKi9cbiAgQElucHV0KCdueE5hbWUnKVxuICBzZXQgbmFtZSh2YWx1ZTogc3RyaW5nKSB7XG4gICAgaWYgKHRoaXMuX25hbWUgIT09IHZhbHVlKSB7XG4gICAgICB0aGlzLl9uYW1lID0gdmFsdWU7XG4gICAgICB0aGlzLl9jaGFuZ2VEZXRlY3RvclJlZi5tYXJrRm9yQ2hlY2soKTtcbiAgICB9XG4gIH1cbiAgZ2V0IG5hbWUoKTogc3RyaW5nIHtcbiAgICByZXR1cm4gdGhpcy5fbmFtZTtcbiAgfVxuXG4gIC8qKiBAZG9jcy1wcml2YXRlICovXG4gIEBDb250ZW50Q2hpbGRyZW4oTnhSYWRpb1RvZ2dsZUJ1dHRvbkJhc2VDb21wb25lbnQpXG4gIHRvZ2dsZUJ1dHRvbnM6IFF1ZXJ5TGlzdDxOeFJhZGlvVG9nZ2xlQnV0dG9uQmFzZUNvbXBvbmVudD4gPSBuZXcgUXVlcnlMaXN0KCk7XG5cbiAgcHJpdmF0ZSBvblRvdWNoZWRDYWxsYmFjayA9ICgpID0+IHsgfTtcblxuICBwcml2YXRlIG9uQ2hhbmdlQ2FsbGJhY2sgPSAob3B0aW9uOiBhbnkpID0+IHsgfTtcblxuICBjb25zdHJ1Y3Rvcihwcml2YXRlIHJlbmRlcmVyOiBSZW5kZXJlcjIsXG4gICAgICAgICAgICAgIHByaXZhdGUgX2NoYW5nZURldGVjdG9yUmVmOiBDaGFuZ2VEZXRlY3RvclJlZixcbiAgICAgICAgICAgICAgLyoqIEBkb2NzLXByaXZhdGUgKi9cbiAgICAgICAgICAgICAgQE9wdGlvbmFsKCkgQFNlbGYoKSBwdWJsaWMgbmdDb250cm9sOiBOZ0NvbnRyb2wsXG4gICAgICAgICAgICAgIHByaXZhdGUgX2Vycm9yU3RhdGVNYXRjaGVyOiBFcnJvclN0YXRlTWF0Y2hlcixcbiAgICAgICAgICAgICAgQE9wdGlvbmFsKCkgcHJpdmF0ZSBfcGFyZW50Rm9ybTogTmdGb3JtLFxuICAgICAgICAgICAgICBAT3B0aW9uYWwoKSBwcml2YXRlIF9wYXJlbnRGb3JtR3JvdXA6IEZvcm1Hcm91cERpcmVjdGl2ZSkge1xuICAgIGlmICh0aGlzLm5nQ29udHJvbCkge1xuICAgICAgLy8gTm90ZTogd2UgcHJvdmlkZSB0aGUgdmFsdWUgYWNjZXNzb3IgdGhyb3VnaCBoZXJlLCBpbnN0ZWFkIG9mXG4gICAgICAvLyB0aGUgYHByb3ZpZGVyc2AgdG8gYXZvaWQgcnVubmluZyBpbnRvIGEgY2lyY3VsYXIgaW1wb3J0LlxuICAgICAgdGhpcy5uZ0NvbnRyb2wudmFsdWVBY2Nlc3NvciA9IHRoaXM7XG4gICAgfVxuICB9XG5cbiAgbmdBZnRlclZpZXdJbml0KCkge1xuICAgIHRoaXMuc3Vic2NyaWJlVG9Ub2dnbGVCdXR0b25zQ2hhbmdlKCk7XG4gIH1cblxuICBuZ0FmdGVyQ29udGVudEluaXQoKSB7XG4gICAgY29uc3QgY2hhbmdlZE9yRGVzdHJveWVkID0gbWVyZ2UodGhpcy50b2dnbGVCdXR0b25zLmNoYW5nZXMsIHRoaXMuX2Rlc3Ryb3llZCk7XG5cbiAgICBtZXJnZSguLi50aGlzLnRvZ2dsZUJ1dHRvbnMubWFwKChidXR0b246IGFueSkgPT4gYnV0dG9uLm9uQ2hlY2tlZCkpXG4gICAgICAucGlwZSh0YWtlVW50aWwoY2hhbmdlZE9yRGVzdHJveWVkKSlcbiAgICAgIC5zdWJzY3JpYmUoKGNoYW5nZTogTnhSYWRpb1RvZ2dsZUJ1dHRvbkNoYW5nZSkgPT4ge1xuICAgICAgICB0aGlzLl9zZWxlY3Rpb24gPSBjaGFuZ2UudmFsdWU7XG4gICAgICAgIHRoaXMub25DaGFuZ2VDYWxsYmFjayh0aGlzLl9zZWxlY3Rpb24pO1xuICAgICAgfSk7XG4gIH1cblxuICBuZ09uRGVzdHJveSgpIHtcbiAgICB0aGlzLl9kZXN0cm95ZWQubmV4dCgpO1xuICAgIHRoaXMuX2Rlc3Ryb3llZC5jb21wbGV0ZSgpO1xuICAgIHRoaXMuX2Rpc2FibGVDaGFuZ2UuY29tcGxldGUoKTtcbiAgfVxuXG4gIG5nRG9DaGVjaygpIHtcbiAgICBpZiAodGhpcy5uZ0NvbnRyb2wpIHtcbiAgICAgIC8vIFdlIG5lZWQgdG8gcmUtZXZhbHVhdGUgdGhpcyBvbiBldmVyeSBjaGFuZ2UgZGV0ZWN0aW9uIGN5Y2xlLCBiZWNhdXNlIHRoZXJlIGFyZSBzb21lXG4gICAgICAvLyBlcnJvciB0cmlnZ2VycyB0aGF0IHdlIGNhbid0IHN1YnNjcmliZSB0byAoZS5nLiBwYXJlbnQgZm9ybSBzdWJtaXNzaW9ucykuIFRoaXMgbWVhbnNcbiAgICAgIC8vIHRoYXQgd2hhdGV2ZXIgbG9naWMgaXMgaW4gaGVyZSBoYXMgdG8gYmUgc3VwZXIgbGVhbiBvciB3ZSByaXNrIGRlc3Ryb3lpbmcgdGhlIHBlcmZvcm1hbmNlLlxuICAgICAgdGhpcy51cGRhdGVFcnJvclN0YXRlKCk7XG4gICAgfVxuICB9XG5cbiAgLyoqIEBkb2NzLXByaXZhdGUgKi9cbiAgc3Vic2NyaWJlVG9Ub2dnbGVCdXR0b25zQ2hhbmdlKCk6IHZvaWQge1xuICAgIHRoaXMudG9nZ2xlQnV0dG9ucy5jaGFuZ2VzXG4gICAgICAucGlwZShcbiAgICAgICAgc3RhcnRXaXRoKHRoaXMudG9nZ2xlQnV0dG9ucyksXG4gICAgICAgIGZpbHRlcih0b2dnbGVzID0+IHRvZ2dsZXMubGVuZ3RoID4gMCksXG4gICAgICAgIHRha2VVbnRpbCh0aGlzLl9kZXN0cm95ZWQpXG4gICAgICApLnN1YnNjcmliZSgodG9nZ2xlcykgPT4ge1xuICAgICAgICB0b2dnbGVzLmZvckVhY2godG9nZ2xlID0+IHtcbiAgICAgICAgICB0b2dnbGUucmVzZXRDbGFzc2VzKCk7XG4gICAgICAgICAgaWYgKHRvZ2dsZS52YWx1ZSA9PT0gdGhpcy5zZWxlY3Rpb24pIHtcbiAgICAgICAgICAgIC8vIFdlIG5lZWQgdG8gZGVmZXIgdGhlIHNlbGVjdGlvbiBmb3IgdGhlIGVkZ2UgY2FzZSB0aGF0IHRoZSBidXR0b24gd2l0aCB0aGUgdmFsdWUgb2YgdGhpcy5zZWxlY3Rpb25cbiAgICAgICAgICAgIC8vIGRpZG4ndCBleGlzdCB5ZXQgYnV0IHdhcyBhZGRlZCBhZnRlcndhcmRzIHRvIHByZXZlbnQgY2hhbmdlZCBhZnRlciBjaGVja2VkIGVycm9yc1xuICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB0b2dnbGUuc2VsZWN0KCkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHRvZ2dsZXMuZmlyc3Quc2V0Rmlyc3RCdXR0b24oKTtcbiAgICAgICAgdG9nZ2xlcy5sYXN0LnNldExhc3RCdXR0b24oKTtcbiAgICAgIH0pO1xuICB9XG5cbiAgcmVnaXN0ZXJPbkNoYW5nZShvbkNoYW5nZUNhbGxiYWNrOiBhbnkpOiB2b2lkIHtcbiAgICB0aGlzLm9uQ2hhbmdlQ2FsbGJhY2sgPSBvbkNoYW5nZUNhbGxiYWNrO1xuICB9XG5cbiAgcmVnaXN0ZXJPblRvdWNoZWQob25Ub3VjaGVkQ2FsbGJhY2s6IGFueSk6IHZvaWQge1xuICAgIHRoaXMub25Ub3VjaGVkQ2FsbGJhY2sgPSBvblRvdWNoZWRDYWxsYmFjaztcbiAgfVxuXG4gIC8qKiBQcmVzZWxlY3RzIHRoZSByZXNwZWN0aXZlIG9wdGlvbnMuICovXG4gIEBJbnB1dCgnbnhTZWxlY3Rpb24nKVxuICB3cml0ZVZhbHVlKHZhbHVlOiBzdHJpbmcpOiB2b2lkIHtcbiAgICB0aGlzLl9zZWxlY3Rpb24gPSB2YWx1ZTtcbiAgICBjb25zdCBjb3JyZXNwb25kaW5nQnV0dG9uID1cbiAgICAgIHRoaXMudG9nZ2xlQnV0dG9ucy5maW5kKChidXR0b246IE54UmFkaW9Ub2dnbGVCdXR0b25Db21wb25lbnQpID0+IGJ1dHRvbi52YWx1ZSA9PT0gdGhpcy5fc2VsZWN0aW9uKTtcbiAgICBpZiAoY29ycmVzcG9uZGluZ0J1dHRvbikge1xuICAgICAgKGNvcnJlc3BvbmRpbmdCdXR0b24gYXMgTnhSYWRpb1RvZ2dsZUJ1dHRvbkNvbXBvbmVudCkuc2VsZWN0KCk7XG4gICAgfVxuICB9XG5cbiAgc2V0RGlzYWJsZWRTdGF0ZShpc0Rpc2FibGVkOiBib29sZWFuKTogdm9pZCB7XG4gICAgdGhpcy5kaXNhYmxlZCA9IGlzRGlzYWJsZWQ7XG4gIH1cblxuICAvKiogQGRvY3MtcHJpdmF0ZSAqL1xuICBnZXQgaWQoKTogc3RyaW5nIHtcbiAgICByZXR1cm4gYG54LXJhZGlvLXRvZ2dsZS0ke3RoaXMuX3RvZ2dsZUlkfWA7XG4gIH1cblxuICAvKiogU2V0cyB0aGUgbW9kaWZpZXJzIGZvciB0aGUgY29tcG9uZW50LiAqL1xuICBASW5wdXQoJ254U3R5bGUnKVxuICBzZXQgc3R5bGUodmFsdWU6IHN0cmluZykge1xuICAgIGNvbnN0IG1vZGlmaWVyQ2xhc3NlcyA9IG1hcENsYXNzTmFtZXModmFsdWUsIFtdLCBNQVBQSU5HKTtcbiAgICBtb2RpZmllckNsYXNzZXMuc3BsaXQoJyAnKVxuICAgICAgLmZvckVhY2goY2xhc3NOYW1lID0+IHRoaXMucmVuZGVyZXIuYWRkQ2xhc3ModGhpcy50b2dnbGVDb250YWluZXIubmF0aXZlRWxlbWVudCwgY2xhc3NOYW1lKSk7XG4gIH1cblxuICAvKiogQGRvY3MtcHJpdmF0ZSAqL1xuICBzZXQgc2VsZWN0aW9uKHNlbGVjdGlvbjogYW55KSB7XG4gICAgdGhpcy5fc2VsZWN0aW9uID0gc2VsZWN0aW9uO1xuICAgIHRoaXMub25DaGFuZ2VDYWxsYmFjayhzZWxlY3Rpb24pO1xuICB9XG5cbiAgZ2V0IHNlbGVjdGlvbigpOiBhbnkge1xuICAgIHJldHVybiB0aGlzLl9zZWxlY3Rpb247XG4gIH1cblxuICAvKiogQGRvY3MtcHJpdmF0ZSAqL1xuICBjaGFuZ2UodmFsdWUpIHtcbiAgICB0aGlzLm9uQ2hhbmdlQ2FsbGJhY2sodmFsdWUpO1xuICAgIGlmICh0aGlzLm9uVG91Y2hlZENhbGxiYWNrKSB7XG4gICAgICB0aGlzLm9uVG91Y2hlZENhbGxiYWNrKCk7XG4gICAgfVxuICB9XG5cbiAgLyoqIEBkb2NzLXByaXZhdGUgKi9cbiAgdXBkYXRlRXJyb3JTdGF0ZSgpIHtcbiAgICBjb25zdCBvbGRTdGF0ZSA9IHRoaXMuZXJyb3JTdGF0ZTtcbiAgICBjb25zdCBwYXJlbnQgPSB0aGlzLl9wYXJlbnRGb3JtR3JvdXAgfHwgdGhpcy5fcGFyZW50Rm9ybTtcbiAgICBjb25zdCBjb250cm9sID0gdGhpcy5uZ0NvbnRyb2wgPyB0aGlzLm5nQ29udHJvbC5jb250cm9sIGFzIEZvcm1Db250cm9sIDogbnVsbDtcbiAgICBjb25zdCBuZXdTdGF0ZSA9IHRoaXMuX2Vycm9yU3RhdGVNYXRjaGVyLmlzRXJyb3JTdGF0ZShjb250cm9sLCBwYXJlbnQpO1xuXG4gICAgaWYgKG5ld1N0YXRlICE9PSBvbGRTdGF0ZSkge1xuICAgICAgdGhpcy5lcnJvclN0YXRlID0gbmV3U3RhdGU7XG4gICAgfVxuICB9XG59XG4iXX0=