/**
 * @fileoverview added by tsickle
 * Generated from: utils.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import { Injectable } from '@angular/core';
import * as i0 from "@angular/core";
/**
 * @param {?} value
 * @return {?}
 */
export function isString(value) {
    return typeof value === 'string';
}
/**
 * @param {?} str
 * @param {?=} length
 * @param {?=} padCharacter
 * @return {?}
 */
export function pad(str, length = 2, padCharacter = '0') {
    if (!isString(str) || str.length >= length) {
        return str;
    }
    while (str.length < length) {
        str = padCharacter + str;
    }
    return str;
}
// DATE -> YYYY-MM-DD
/**
 * @param {?} date
 * @return {?}
 */
export function formatDate(date) {
    /** @type {?} */
    const dateOfBirth = [
        String(date.getFullYear()),
        pad(String(date.getMonth() + 1)),
        pad(String(date.getDate()))
    ].join('-');
    return dateOfBirth;
}
/**
 * @param {?} date
 * @return {?}
 */
export function formatDateHuman(date) {
    /** @type {?} */
    const dateOfBirth = [
        pad(String(date.getDate())),
        pad(String(date.getMonth() + 1)),
        String(date.getFullYear())
    ].join('-');
    return dateOfBirth;
}
/*
  Purpose of this function is to allow a list of short keywords
  expand to longer bem class names with will then be applied to the classname value.

  This function will map a list of keys to values in a MAPPING list.
  Whatever value is found will replace the keyword.
  Every keyword not found will just transfered wiithmout modifying.
*/
/**
 * @param {?} value
 * @param {?=} DEFAULTS
 * @param {?=} MAPPING
 * @return {?}
 */
export function mapClassNames(value, DEFAULTS = [], MAPPING = {}) {
    /** @type {?} */
    let sanitizedList = [...DEFAULTS];
    if (typeof value === 'string') {
        /** @type {?} */
        const mappedClasses = getClassNameList(value, MAPPING);
        sanitizedList = [...sanitizedList, ...mappedClasses];
    }
    return sanitizedList.join(' ').trim();
}
/**
 * @param {?} value
 * @param {?=} MAPPING
 * @return {?}
 */
export function getClassNameList(value, MAPPING = {}) {
    /** @type {?} */
    let mappedClasses = [];
    if (typeof value === 'string') {
        /** @type {?} */
        const classNames = value.split(' ');
        /** @type {?} */
        const keys = Object.keys(MAPPING);
        mappedClasses = classNames.map((/**
         * @param {?} className
         * @return {?}
         */
        className => {
            if (keys.indexOf(className) > -1) {
                return MAPPING[className];
            }
            else {
                return className;
            }
        }));
    }
    return mappedClasses;
}
/**
 * @param {?} renderer
 * @param {?} element
 * @param {?} classes
 * @return {?}
 */
export function appendClasses(renderer, element, classes) {
    if (renderer && element && classes) {
        classes.split(' ').forEach((/**
         * @param {?} item
         * @return {?}
         */
        item => {
            renderer.addClass(element.nativeElement, item);
        }));
    }
}
/**
 * @param {?} renderer
 * @param {?} element
 * @param {?} classes
 * @return {?}
 */
export function removeClasses(renderer, element, classes) {
    if (renderer && element && classes) {
        classes.split(' ').forEach((/**
         * @param {?} item
         * @return {?}
         */
        item => {
            renderer.removeClass(element.nativeElement, item);
        }));
    }
}
// YYYY-MM-DD -> DATE
/**
 * @param {?} dateString
 * @return {?}
 */
export function parseDate(dateString) {
    return new Date(dateString);
}
// Manually compose a font shorthand defintion as it's not
// guaranteed to be given by the computed style object.
/**
 * @param {?} style
 * @return {?}
 */
export function getFontShorthand(style) {
    const { font, fontStyle, fontVariant, fontWeight, fontSize, lineHeight, fontFamily } = style;
    if (font.length > 0) {
        return font;
    }
    return `${fontStyle} ${fontVariant} ${fontWeight} ${fontSize}/${lineHeight} ${fontFamily}`;
}
/**
 * @param {?} number
 * @return {?}
 */
export function numberOfDecimals(number) {
    /** @type {?} */
    const parsed = Number(number);
    if (Number.isNaN(parsed) || Number.isInteger(parsed)) {
        return 0;
    }
    /** @type {?} */
    const match = (parsed.toString()).match(/(?:\.(\d+))?(?:[eE]([+-]?\d+))?$/);
    if (!match[1]) {
        return 0;
    }
    return match[1].length;
}
/**
 * @param {?} value
 * @param {?=} min
 * @param {?=} max
 * @return {?}
 */
export function clamp(value, min = 0, max = 1) {
    return Math.max(min, Math.min(max, value));
}
/**
 * Provider that defines when form controls have an error.
 */
export class ErrorStateMatcher {
    /**
     * @param {?} control
     * @param {?} form
     * @return {?}
     */
    isErrorState(control, form) {
        return !!(control && control.invalid && (control.touched || (form && form.submitted)));
    }
}
ErrorStateMatcher.decorators = [
    { type: Injectable, args: [{ providedIn: 'root' },] }
];
/** @nocollapse */ ErrorStateMatcher.ngInjectableDef = i0.ɵɵdefineInjectable({ factory: function ErrorStateMatcher_Factory() { return new ErrorStateMatcher(); }, token: ErrorStateMatcher, providedIn: "root" });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidXRpbHMuanMiLCJzb3VyY2VSb290Ijoibmc6Ly9AYWxsaWFuei9uZ3gtbmRieC91dGlscy8iLCJzb3VyY2VzIjpbInV0aWxzLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7O0FBQUEsT0FBTyxFQUFjLFVBQVUsRUFBRSxNQUFNLGVBQWUsQ0FBQzs7Ozs7O0FBR3ZELE1BQU0sVUFBVSxRQUFRLENBQUMsS0FBVTtJQUNqQyxPQUFPLE9BQU8sS0FBSyxLQUFLLFFBQVEsQ0FBQztBQUNuQyxDQUFDOzs7Ozs7O0FBRUQsTUFBTSxVQUFVLEdBQUcsQ0FBQyxHQUFXLEVBQUUsU0FBaUIsQ0FBQyxFQUFFLGVBQXVCLEdBQUc7SUFDM0UsSUFBSSxDQUFDLFFBQVEsQ0FBQyxHQUFHLENBQUMsSUFBSSxHQUFHLENBQUMsTUFBTSxJQUFJLE1BQU0sRUFBRTtRQUMxQyxPQUFPLEdBQUcsQ0FBQztLQUNaO0lBQ0QsT0FBTyxHQUFHLENBQUMsTUFBTSxHQUFHLE1BQU0sRUFBRTtRQUMxQixHQUFHLEdBQUcsWUFBWSxHQUFHLEdBQUcsQ0FBQztLQUMxQjtJQUNELE9BQU8sR0FBRyxDQUFDO0FBQ2IsQ0FBQzs7Ozs7O0FBR0gsTUFBTSxVQUFVLFVBQVUsQ0FBQyxJQUFVOztVQUMzQixXQUFXLEdBQUk7UUFDakIsTUFBTSxDQUFFLElBQUksQ0FBQyxXQUFXLEVBQUUsQ0FBQztRQUMzQixHQUFHLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxRQUFRLEVBQUUsR0FBRyxDQUFDLENBQUMsQ0FBQztRQUNoQyxHQUFHLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxPQUFPLEVBQUUsQ0FBQyxDQUFDO0tBQzVCLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQztJQUViLE9BQU8sV0FBVyxDQUFDO0FBQ3ZCLENBQUM7Ozs7O0FBQ0QsTUFBTSxVQUFVLGVBQWUsQ0FBQyxJQUFVOztVQUNoQyxXQUFXLEdBQUk7UUFDakIsR0FBRyxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsT0FBTyxFQUFF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aW1wb3J0IHsgRWxlbWVudFJlZiwgSW5qZWN0YWJsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgUmVuZGVyZXIyIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBGb3JtQ29udHJvbCwgRm9ybUdyb3VwRGlyZWN0aXZlLCBOZ0Zvcm0gfSBmcm9tICdAYW5ndWxhci9mb3Jtcyc7XG5leHBvcnQgZnVuY3Rpb24gaXNTdHJpbmcodmFsdWU6IGFueSkge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHBhZChzdHI6IHN0cmluZywgbGVuZ3RoOiBudW1iZXIgPSAyLCBwYWRDaGFyYWN0ZXI6IHN0cmluZyA9ICcwJyk6IHN0cmluZyB7XG4gICAgaWYgKCFpc1N0cmluZyhzdHIpIHx8IHN0ci5sZW5ndGggPj0gbGVuZ3RoKSB7XG4gICAgICByZXR1cm4gc3RyO1xuICAgIH1cbiAgICB3aGlsZSAoc3RyLmxlbmd0aCA8IGxlbmd0aCkge1xuICAgICAgc3RyID0gcGFkQ2hhcmFjdGVyICsgc3RyO1xuICAgIH1cbiAgICByZXR1cm4gc3RyO1xuICB9XG5cbi8vIERBVEUgLT4gWVlZWS1NTS1ERFxuZXhwb3J0IGZ1bmN0aW9uIGZvcm1hdERhdGUoZGF0ZTogRGF0ZSkge1xuICAgIGNvbnN0IGRhdGVPZkJpcnRoID0gIFtcbiAgICAgICAgU3RyaW5nIChkYXRlLmdldEZ1bGxZZWFyKCkpLFxuICAgICAgICBwYWQoU3RyaW5nKGRhdGUuZ2V0TW9udGgoKSArIDEpKSxcbiAgICAgICAgcGFkKFN0cmluZyhkYXRlLmdldERhdGUoKSkpXG4gICAgICBdLmpvaW4oJy0nKTtcblxuICAgIHJldHVybiBkYXRlT2ZCaXJ0aDtcbn1cbmV4cG9ydCBmdW5jdGlvbiBmb3JtYXREYXRlSHVtYW4oZGF0ZTogRGF0ZSkge1xuICAgIGNvbnN0IGRhdGVPZkJpcnRoID0gIFtcbiAgICAgICAgcGFkKFN0cmluZyhkYXRlLmdldERhdGUoKSkpLFxuICAgICAgICBwYWQoU3RyaW5nKGRhdGUuZ2V0TW9udGgoKSArIDEpKSxcbiAgICAgICAgU3RyaW5nIChkYXRlLmdldEZ1bGxZZWFyKCkpXG4gICAgICBdLmpvaW4oJy0nKTtcblxuICAgIHJldHVybiBkYXRlT2ZCaXJ0aDtcbn1cbi8qXG4gIFB1cnBvc2Ugb2YgdGhpcyBmdW5jdGlvbiBpcyB0byBhbGxvdyBhIGxpc3Qgb2Ygc2hvcnQga2V5d29yZHNcbiAgZXhwYW5kIHRvIGxvbmdlciBiZW0gY2xhc3MgbmFtZXMgd2l0aCB3aWxsIHRoZW4gYmUgYXBwbGllZCB0byB0aGUgY2xhc3NuYW1lIHZhbHVlLlxuXG4gIFRoaXMgZnVuY3Rpb24gd2lsbCBtYXAgYSBsaXN0IG9mIGtleXMgdG8gdmFsdWVzIGluIGEgTUFQUElORyBsaXN0LlxuICBXaGF0ZXZlciB2YWx1ZSBpcyBmb3VuZCB3aWxsIHJlcGxhY2UgdGhlIGtleXdvcmQuXG4gIEV2ZXJ5IGtleXdvcmQgbm90IGZvdW5kIHdpbGwganVzdCB0cmFuc2ZlcmVkIHdpaXRobW91dCBtb2RpZnlpbmcuXG4qL1xuXG5leHBvcnQgZnVuY3Rpb24gbWFwQ2xhc3NOYW1lcyh2YWx1ZSwgREVGQVVMVFMgPSBbXSwgTUFQUElORyA9IHt9KSB7XG4gIGxldCBzYW5pdGl6ZWRMaXN0ID0gWyAuLi5ERUZBVUxUUyBdO1xuXG4gIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgY29uc3QgbWFwcGVkQ2xhc3NlcyA9IGdldENsYXNzTmFtZUxpc3QodmFsdWUsIE1BUFBJTkcpO1xuICAgIHNhbml0aXplZExpc3QgPSBbLi4uc2FuaXRpemVkTGlzdCwgLi4ubWFwcGVkQ2xhc3Nlc107XG4gIH1cblxuICByZXR1cm4gc2FuaXRpemVkTGlzdC5qb2luKCcgJykudHJpbSgpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0Q2xhc3NOYW1lTGlzdCh2YWx1ZSwgTUFQUElORyA9IHt9KSB7XG4gIGxldCBtYXBwZWRDbGFzc2VzID0gW107XG5cbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICBjb25zdCBjbGFzc05hbWVzID0gdmFsdWUuc3BsaXQoJyAnKTtcbiAgICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMoTUFQUElORyk7XG5cbiAgICBtYXBwZWRDbGFzc2VzID0gY2xhc3NOYW1lcy5tYXAoY2xhc3NOYW1lID0+IHtcbiAgICAgIGlmIChrZXlzLmluZGV4T2YoY2xhc3NOYW1lKSA+IC0xKSB7XG4gICAgICAgIHJldHVybiBNQVBQSU5HW2NsYXNzTmFtZV07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gY2xhc3NOYW1lO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgcmV0dXJuIG1hcHBlZENsYXNzZXM7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBhcHBlbmRDbGFzc2VzKHJlbmRlcmVyOiBSZW5kZXJlcjIsIGVsZW1lbnQ6IEVsZW1lbnRSZWYsIGNsYXNzZXM6IHN0cmluZykge1xuICBpZiAocmVuZGVyZXIgJiYgZWxlbWVudCAmJiBjbGFzc2VzKSB7XG4gICAgY2xhc3Nlcy5zcGxpdCgnICcpLmZvckVhY2goaXRlbSA9PiB7XG4gICAgICByZW5kZXJlci5hZGRDbGFzcyhlbGVtZW50Lm5hdGl2ZUVsZW1lbnQsIGl0ZW0pO1xuICAgIH0pO1xuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiByZW1vdmVDbGFzc2VzKHJlbmRlcmVyOiBSZW5kZXJlcjIsIGVsZW1lbnQ6IEVsZW1lbnRSZWYsIGNsYXNzZXM6IHN0cmluZykge1xuICBpZiAocmVuZGVyZXIgJiYgZWxlbWVudCAmJiBjbGFzc2VzKSB7XG4gICAgY2xhc3Nlcy5zcGxpdCgnICcpLmZvckVhY2goaXRlbSA9PiB7XG4gICAgICByZW5kZXJlci5yZW1vdmVDbGFzcyhlbGVtZW50Lm5hdGl2ZUVsZW1lbnQsIGl0ZW0pO1xuICAgIH0pO1xuICB9XG59XG5cbi8vIFlZWVktTU0tREQgLT4gREFURVxuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlRGF0ZShkYXRlU3RyaW5nKSB7XG4gIHJldHVybiBuZXcgRGF0ZShkYXRlU3RyaW5nKTtcbn1cblxuLy8gTWFudWFsbHkgY29tcG9zZSBhIGZvbnQgc2hvcnRoYW5kIGRlZmludGlvbiBhcyBpdCdzIG5vdFxuLy8gZ3VhcmFudGVlZCB0byBiZSBnaXZlbiBieSB0aGUgY29tcHV0ZWQgc3R5bGUgb2JqZWN0LlxuZXhwb3J0IGZ1bmN0aW9uIGdldEZvbnRTaG9ydGhhbmQoc3R5bGU6IENTU1N0eWxlRGVjbGFyYXRpb24pIHtcbiAgY29uc3Qge1xuICAgIGZvbnQsIGZvbnRTdHlsZSwgZm9udFZhcmlhbnQsIGZvbnRXZWlnaHQsIGZvbnRTaXplLCBsaW5lSGVpZ2h0LCBmb250RmFtaWx5XG4gIH0gPSBzdHlsZTtcblxuICBpZiAoZm9udC5sZW5ndGggPiAwKSB7XG4gICAgcmV0dXJuIGZvbnQ7XG4gIH1cblxuICByZXR1cm4gYCR7Zm9udFN0eWxlfSAke2ZvbnRWYXJpYW50fSAke2ZvbnRXZWlnaHR9ICR7Zm9udFNpemV9LyR7bGluZUhlaWdodH0gJHtmb250RmFtaWx5fWA7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBudW1iZXJPZkRlY2ltYWxzKG51bWJlcikge1xuICBjb25zdCBwYXJzZWQgPSBOdW1iZXIobnVtYmVyKTtcbiAgaWYgKE51bWJlci5pc05hTihwYXJzZWQpIHx8IE51bWJlci5pc0ludGVnZXIocGFyc2VkKSkge1xuICAgIHJldHVybiAwO1xuICB9XG4gIGNvbnN0IG1hdGNoID0gKHBhcnNlZC50b1N0cmluZygpKS5tYXRjaCgvKD86XFwuKFxcZCspKT8oPzpbZUVdKFsrLV0/XFxkKykpPyQvKTtcbiAgaWYgKCFtYXRjaFsxXSkge1xuICAgICAgcmV0dXJuIDA7XG4gIH1cbiAgcmV0dXJuIG1hdGNoWzFdLmxlbmd0aDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNsYW1wKHZhbHVlOiBudW1iZXIsIG1pbiA9IDAsIG1heCA9IDEpIHtcbiAgcmV0dXJuIE1hdGgubWF4KG1pbiwgTWF0aC5taW4obWF4LCB2YWx1ZSkpO1xufVxuXG4vKiogUHJvdmlkZXIgdGhhdCBkZWZpbmVzIHdoZW4gZm9ybSBjb250cm9scyBoYXZlIGFuIGVycm9yLiAqL1xuQEluamVjdGFibGUoe3Byb3ZpZGVkSW46ICdyb290J30pXG5leHBvcnQgY2xhc3MgRXJyb3JTdGF0ZU1hdGNoZXIge1xuICBpc0Vycm9yU3RhdGUoY29udHJvbDogRm9ybUNvbnRyb2wgfCBudWxsLCBmb3JtOiBGb3JtR3JvdXBEaXJlY3RpdmUgfCBOZ0Zvcm0gfCBudWxsKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuICEhKGNvbnRyb2wgJiYgY29udHJvbC5pbnZhbGlkICYmIChjb250cm9sLnRvdWNoZWQgfHwgKGZvcm0gJiYgZm9ybS5zdWJtaXR0ZWQpKSk7XG4gIH1cbn1cbiJdfQ==