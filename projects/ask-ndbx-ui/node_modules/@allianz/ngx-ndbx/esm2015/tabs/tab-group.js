/**
 * @fileoverview added by tsickle
 * Generated from: tabs/tab-group.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import { NxTabGroupBase } from './tab-group-base';
import { coerceBooleanProperty, coerceNumberProperty } from '@angular/cdk/coercion';
import { ChangeDetectionStrategy, ChangeDetectorRef, Component, ContentChildren, EventEmitter, HostListener, Input, Output, QueryList, ViewChild, ViewChildren } from '@angular/core';
import { merge, Subscription, Subject } from 'rxjs';
import { NxAccordionDirective } from '@allianz/ngx-ndbx/accordion';
import { NxExpansionPanelComponent } from '@allianz/ngx-ndbx/accordion';
import { NxTabComponent } from './tab';
import { NxTabBodyComponent } from './tab-body';
import { NxTabHeaderComponent } from './tab-header';
export class NxTabChangeEvent {
}
if (false) {
    /**
     * The index of the selected or focused tab.
     * @type {?}
     */
    NxTabChangeEvent.prototype.index;
    /**
     * The component instance of the selected or focused tab.
     * @type {?}
     */
    NxTabChangeEvent.prototype.tab;
}
/** @type {?} */
let nextId = 0;
/** @type {?} */
const MOBILE_BREAKPOINT = 480;
export class NxTabGroupComponent {
    /**
     * @param {?} _changeDetectorRef
     */
    constructor(_changeDetectorRef) {
        this._changeDetectorRef = _changeDetectorRef;
        this._selectedIndex = null;
        this._negative = false;
        this._disabled = false;
        this._indexToSelect = 0;
        this._autoselect = true;
        this._mobileAccordion = true;
        this._showAccordion = false;
        /**
         * An event emitted when the selected tab has changed.
         */
        this.selectedIndexChange = new EventEmitter();
        /**
         * An event emitted when the selected tab has changed.
         */
        this.selectedTabChange = new EventEmitter();
        /**
         * An event emitted when focus has changed within a tab group.
         *
         * **Note:** is not supported in mobile view.
         */
        this.focusChange = new EventEmitter();
        /**
         * Subscription to tabs being added/removed.
         */
        this._tabsSubscription = Subscription.EMPTY;
        /**
         * Subscription to changes in the tab labels.
         */
        this._tabLabelSubscription = Subscription.EMPTY;
        this._disabledTabsCache = [];
        this._appearanceChange = new Subject();
        this._groupId = nextId++;
    }
    /**
     * Sets the selected tab.
     * @return {?}
     */
    get selectedIndex() {
        return this._selectedIndex;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set selectedIndex(value) {
        this._indexToSelect = coerceNumberProperty(value, null);
    }
    /**
     * Whether the negative set of styling should be used.
     * @return {?}
     */
    get negative() {
        return this._negative;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set negative(value) {
        if (value !== this._negative) {
            this._negative = coerceBooleanProperty(value);
        }
    }
    /**
     * Whether the tab group is disabled. Default: false.
     * @return {?}
     */
    get disabled() {
        return this._disabled;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set disabled(value) {
        if (value !== this._disabled) {
            this._disabled = coerceBooleanProperty(value);
        }
    }
    /**
     * Whether the tab should be immediately selected on focus.
     * @return {?}
     */
    get autoselect() {
        return this._autoselect;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set autoselect(value) {
        this._autoselect = coerceBooleanProperty(value);
    }
    /**
     * Whether the tabs should to accordion on mobile viewports.
     * @return {?}
     */
    get mobileAccordion() {
        return this._mobileAccordion;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set mobileAccordion(value) {
        this._mobileAccordion = coerceBooleanProperty(value);
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this._switchAppearance(window.innerWidth);
    }
    /**
     * @return {?}
     */
    ngAfterContentInit() {
        this._subscribeToTabLabels();
        // Subscribe to changes in the amount of tabs, in order to be
        // able to re-render the content as new tabs are added or removed.
        this._tabsSubscription = this.tabs.changes.subscribe((/**
         * @return {?}
         */
        () => {
            /** @type {?} */
            const indexToSelect = this._clampTabIndex(this._indexToSelect);
            // Maintain the previously-selected tab if a new tab is added or removed and there is no
            // explicit change that selects a different tab.
            if (indexToSelect === this._selectedIndex) {
                /** @type {?} */
                const tabs = this.tabs.toArray();
                for (let i = 0; i < tabs.length; i++) {
                    if (tabs[i].isActive) {
                        // Assign both to the `_indexToSelect` and `_selectedIndex` so we don't fire a changed
                        // event, otherwise the consumer may end up in an infinite loop in some edge cases like
                        // adding a tab within the `selectedIndexChange` event.
                        this._indexToSelect = this._selectedIndex = i;
                        break;
                    }
                }
            }
            this._changeDetectorRef.markForCheck();
        }));
    }
    /**
     * After the content is checked, this component knows what tabs have been defined
     * and what the selected index should be.
     * @return {?}
     */
    ngAfterContentChecked() {
        // Don't clamp the `indexToSelect` immediately in the setter because it can happen that
        // the amount of tabs changes before the actual change detection runs.
        /** @type {?} */
        let indexToSelect = this._indexToSelect = this._clampTabIndex(this._indexToSelect);
        // If the active tab is disabled select the next focusable tab
        // if all tabs are disabled, allow selection of disabled active tab.
        if (!this.disabled && this.tabs.toArray()[indexToSelect].disabled) {
            /** @type {?} */
            const nextFocusable = this.tabs.toArray()
                .map((/**
             * @param {?} tab
             * @param {?} index
             * @return {?}
             */
            (tab, index) => ({ tab: tab, index: index })))
                .find((/**
             * @param {?} item
             * @return {?}
             */
            item => !item.tab.disabled));
            indexToSelect = nextFocusable ? nextFocusable.index : indexToSelect;
        }
        // If the index to select was disabled previously leave the selection on the current
        // so that the selection does not jump from one to another tab.
        if (this._disabledTabsCache[this._indexToSelect]) {
            this._indexToSelect = this.selectedIndex;
        }
        // If there is a change in selected index, emit a change event. Should not trigger if
        // the selected index has not yet been initialized.
        if (this._selectedIndex !== indexToSelect) {
            /** @type {?} */
            const isFirstRun = this._selectedIndex == null;
            if (!isFirstRun) {
                this.selectedTabChange.emit(this._createChangeEvent(indexToSelect));
            }
            // Changing these values after change detection has run
            // since the checked content may contain references to them.
            Promise.resolve().then((/**
             * @return {?}
             */
            () => {
                this.tabs.forEach((/**
                 * @param {?} tab
                 * @param {?} index
                 * @return {?}
                 */
                (tab, index) => tab.isActive = index === indexToSelect));
                if (!isFirstRun) {
                    this.selectedIndexChange.emit(indexToSelect);
                }
            }));
        }
        if (this._selectedIndex !== indexToSelect) {
            this._selectedIndex = indexToSelect;
            this._changeDetectorRef.markForCheck();
        }
        // cache the previous disabled status of all tabs
        if (!this.disabled) {
            this.tabs.toArray().forEach((/**
             * @param {?} tab
             * @param {?} index
             * @return {?}
             */
            (tab, index) => this._disabledTabsCache[index] = tab.disabled));
        }
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this._tabsSubscription.unsubscribe();
        this._tabLabelSubscription.unsubscribe();
    }
    /**
     * Subscribes to changes in the tab labels. This is needed, because the \@Input for the label is
     * on the NxTab component, whereas the data binding is inside the NxTabGroup. In order for the
     * binding to be updated, we need to subscribe to changes in it and trigger change detection
     * manually.
     * @private
     * @return {?}
     */
    _subscribeToTabLabels() {
        if (this._tabLabelSubscription) {
            this._tabLabelSubscription.unsubscribe();
        }
        this._tabLabelSubscription = merge(...this.tabs.map((/**
         * @param {?} tab
         * @return {?}
         */
        tab => tab._stateChanges)))
            .subscribe((/**
         * @return {?}
         */
        () => this._changeDetectorRef.markForCheck()));
    }
    /**
     * Clamps the given index to the bounds of 0 and the tabs length.
     * @private
     * @param {?} index
     * @return {?}
     */
    _clampTabIndex(index) {
        // Note the `|| 0`, which ensures that values like NaN can't get through
        // and which would otherwise throw the component into an infinite loop
        // (since Math.max(NaN, 0) === NaN).
        return Math.min(this.tabs.length - 1, Math.max(index || 0, 0));
    }
    /**
     * \@docs-private
     * @param {?} index
     * @return {?}
     */
    focusChanged(index) {
        this.focusChange.emit(this._createChangeEvent(index));
    }
    /**
     * @private
     * @param {?} index
     * @return {?}
     */
    _createChangeEvent(index) {
        /** @type {?} */
        const event = new NxTabChangeEvent;
        event.index = index;
        if (this.tabs && this.tabs.length) {
            event.tab = this.tabs.toArray()[index];
        }
        return event;
    }
    /**
     * \@docs-private
     * @param {?} index
     * @return {?}
     */
    handleClick(index) {
        /** @type {?} */
        const clickedTab = this.tabs.toArray()[index];
        if (!this.disabled && !clickedTab.disabled) {
            this.selectedIndex = this.tabHeader.focusIndex = index;
        }
    }
    /**
     * \@docs-private
     * Returns the tabindex for a tab label
     * @param {?} tab
     * @param {?} idx
     * @return {?}
     */
    getTabIndex(tab, idx) {
        return (this.selectedIndex === idx && !tab.disabled && !this.disabled) ? 0 : -1;
    }
    /**
     * Returns a unique id for each tab label element
     * @param {?} i
     * @return {?}
     */
    _getTabLabelId(i) {
        return `nx-tab-label-${this._groupId}-${i}`;
    }
    /**
     * Returns a unique id for each tab content element
     * @param {?} i
     * @return {?}
     */
    _getTabContentId(i) {
        return `nx-tab-content-${this._groupId}-${i}`;
    }
    /**
     * \@docs-private
     * @param {?} event
     * @return {?}
     */
    onResize(event) {
        this._switchAppearance(event.target.innerWidth);
    }
    /**
     * @private
     * @param {?} viewPortWidth
     * @return {?}
     */
    _switchAppearance(viewPortWidth) {
        if (!this._mobileAccordion) {
            return;
        }
        // notify the outlets to detach the viewrefs for header and body before
        // we switch the appearance. this way we only instantiate the templates
        // once so that they do not get destroyed during the switch
        if (viewPortWidth <= MOBILE_BREAKPOINT && !this._showAccordion) {
            this._appearanceChange.next();
            this._showMobileVersion();
        }
        else if (viewPortWidth > MOBILE_BREAKPOINT && this._showAccordion) {
            this._appearanceChange.next();
            this._showDesktopVersion();
        }
    }
    /**
     * @private
     * @return {?}
     */
    _showMobileVersion() {
        this._showAccordion = true;
        this._changeDetectorRef.markForCheck();
    }
    /**
     * @private
     * @return {?}
     */
    _showDesktopVersion() {
        this._showAccordion = false;
        this._changeDetectorRef.markForCheck();
    }
    /**
     * Emulate the tab change event when an accordion panel is opened in
     * mobile viewports.
     * @param {?} index
     * @return {?}
     */
    _panelOpened(index) {
        this.selectedIndex = index;
    }
}
NxTabGroupComponent.decorators = [
    { type: Component, args: [{
                selector: 'nx-tab-group',
                template: "\n\n  <ng-container *ngIf=\"!_showAccordion\">\n  <nx-tab-header\n      #tabHeader\n      [selectedIndex]=\"selectedIndex\"\n      (selectFocusedIndex)=\"selectedIndex = $event\"\n      (indexFocused)=\"focusChanged($event)\"\n      [autoselect]=\"autoselect\">\n    <button\n      type=\"button\"\n      nxTabLabelWrapper\n      *ngFor=\"let tab of tabs; let i = index\"\n      role=\"tab\"\n      (click)=\"handleClick(i)\"\n      class=\"nx-tab-header__item\"\n      [id]=\"_getTabLabelId(i)\"\n      [attr.aria-controls]=\"_getTabContentId(i)\"\n      [attr.aria-selected]=\"selectedIndex == i\"\n      [attr.tabindex]=\"getTabIndex(tab, i)\"\n      [disabled]=\"tab.disabled\"\n      [class.nx-tab-header__item--disabled]=\"tab.disabled\"\n      [class.nx-tab-header__item--active]=\"selectedIndex == i\">\n      <div class=\"nx-tab-label__content\">\n        <nx-tab-header-outlet *ngIf=\"tab.templateLabel\" [content]=\"tab.headerViewRef\"></nx-tab-header-outlet>\n        <ng-container *ngIf=\"!tab.templateLabel\">{{tab.label}}</ng-container>\n      </div>\n    </button>\n  </nx-tab-header>\n\n  <div class=\"nx-tab-body__container\">\n    <nx-tab-body\n      *ngFor=\"let tab of tabs; let i = index\"\n      [id]=\"_getTabContentId(i)\"\n      role=\"tabpanel\"\n      [attr.tabindex]=\"(selectedIndex == i) ? 0 : -1\"\n      class=\"nx-tab__body\"\n      [attr.aria-labelledby]=\"_getTabContentId(i)\"\n      [class.nx-tab__body--active]=\"selectedIndex == i\"\n      [tab]=\"tab\"\n      [active]=\"selectedIndex == i\"\n    ></nx-tab-body>\n  </div>\n</ng-container>\n\n<nx-accordion *ngIf=\"_showAccordion\" [negative]=\"negative\">\n  <nx-expansion-panel *ngFor=\"let tab of tabs; let i = index\"\n                      [expanded]=\"selectedIndex === i\"\n                      (opened)=\"_panelOpened(i)\"\n                      [disabled]=\"tab.disabled\"\n  >\n    <nx-expansion-panel-header>\n      <nx-expansion-panel-title>\n        <nx-tab-header-outlet *ngIf=\"tab.templateLabel\" [content]=\"tab.headerViewRef\"></nx-tab-header-outlet>\n        <ng-container *ngIf=\"!tab.templateLabel\">{{tab.label}}</ng-container>\n      </nx-expansion-panel-title>\n    </nx-expansion-panel-header>\n    <!-- this is not lazy loading this is a trick because the portal gets added here -->\n    <!-- so we could rewrite the tab-body component that it takes care of \"lazy loading\" and the\n    accordion wouldn't know about it -->\n    <!-- active=true is a trick because we want to keep the content attached for better user experience along with expansion panel animation.  -->\n    <nx-tab-body [active]=\"true\" [tab]=\"tab\"></nx-tab-body>\n  </nx-expansion-panel>\n</nx-accordion>\n",
                changeDetection: ChangeDetectionStrategy.OnPush,
                host: {
                    '[class.is-negative]': 'negative',
                    '[class.is-disabled]': 'disabled'
                },
                providers: [{ provide: NxTabGroupBase, useExisting: NxTabGroupComponent }],
                styles: [":host{display:block}.nx-tab-header__item{font-size:18px;font-size:var(--tab-item-font-size,18px);line-height:24px;line-height:var(--tab-item-line-height,24px);font-weight:400;font-weight:var(--tab-item-font-weight,400);letter-spacing:.2px;letter-spacing:var(--tab-item-letter-spacing,.2px);text-decoration:none;border:#006192;background:0 0;color:#006192;color:var(--tab-item-color,#006192);border-color:var(--tab-item-border-color,#006192);border-bottom-width:2px;border-bottom-style:solid;padding:0 16px 6px;outline:0;margin:0}.nx-tab-header__item:hover:not(.nx-tab-header__item--disabled){cursor:pointer}.nx-tab-header__item::-moz-focus-inner{border:0}.nx-tab-header__item--active{border-width:4px;font-weight:700;transition:font-weight .3s;padding-bottom:4px}@media screen and (-ms-high-contrast:active){.nx-tab-header__item{background-color:buttonFace;border-color:buttonText;color:buttonText;-ms-high-contrast-adjust:none}.nx-tab-header__item--active{background-color:highlight;color:highlightText;border-color:highlight}}.nx-tab-header__item--disabled{border-color:#c2c2c2;border-color:var(--tab-item-disabled-border-color,#c2c2c2);color:#c2c2c2;color:var(--tab-item-disabled-color,#c2c2c2);cursor:not-allowed}.nx-tab-label__content{display:inline-flex;justify-content:center;align-items:center;white-space:nowrap}:host-context([data-whatinput=keyboard]) .nx-tab-header__item:focus{box-shadow:0 0 0 2px #fff,0 0 0 6px #009de6;box-shadow:var(--focus-box-shadow,0 0 0 2px #fff,0 0 0 6px #009de6);border-radius:4px}@media screen and (-ms-high-contrast:active){.nx-tab-header__item--disabled{border-color:GrayText;background-color:buttonFace;color:GrayText}:host-context([data-whatinput=keyboard]) .nx-tab-header__item:focus{box-shadow:0 0 0 2px background,0 0 0 6px windowText}}:host(.is-negative){color:#fff}:host(.is-negative) .nx-tab-header__item{color:#fff;border-bottom-color:#fff}:host(.is-negative) .nx-tab-header__item.nx-tab-header__item--disabled{border-color:rgba(255,255,255,.4);border-color:var(--tab-item-disabled-border-color,#c2c2c2);color:var(--tab-item-disabled-color,#c2c2c2);cursor:not-allowed;color:rgba(255,255,255,.4);color:var(--tab-item-disabled-negative-color,rgba(255,255,255,.4));border-color:var(--tab-item-disabled-negative-color,rgba(255,255,255,.4))}@media screen and (-ms-high-contrast:active){:host(.is-negative) .nx-tab-header__item.nx-tab-header__item--disabled{border-color:GrayText;background-color:buttonFace;color:GrayText}}:host(.is-disabled){cursor:not-allowed}:host(.is-disabled.is-negative) .nx-tab-header__item{border-color:rgba(255,255,255,.4);border-color:var(--tab-item-disabled-border-color,#c2c2c2);color:var(--tab-item-disabled-color,#c2c2c2);cursor:not-allowed;color:rgba(255,255,255,.4);color:var(--tab-item-disabled-negative-color,rgba(255,255,255,.4));border-color:var(--tab-item-disabled-negative-color,rgba(255,255,255,.4))}@media screen and (-ms-high-contrast:active){:host(.is-disabled.is-negative) .nx-tab-header__item{border-color:GrayText;background-color:buttonFace}:host(.is-negative){color:buttonText}:host(.is-negative) .nx-tab-header__item{color:buttonText;border-bottom-color:buttonText}:host(.is-negative) .nx-tab-header__item--active{background-color:highlight;color:highlightText;border-color:highlight;-ms-high-contrast-adjust:none}:host(.is-disabled.is-negative) .nx-tab-header__item{color:GrayText;border-bottom-color:GrayText}}"]
            }] }
];
/** @nocollapse */
NxTabGroupComponent.ctorParameters = () => [
    { type: ChangeDetectorRef }
];
NxTabGroupComponent.propDecorators = {
    tabs: [{ type: ContentChildren, args: [NxTabComponent,] }],
    tabBodyChildren: [{ type: ViewChildren, args: [NxTabBodyComponent,] }],
    tabHeader: [{ type: ViewChild, args: ['tabHeader', { static: false },] }],
    panels: [{ type: ViewChildren, args: [NxExpansionPanelComponent,] }],
    accordion: [{ type: ViewChild, args: [NxAccordionDirective, { static: false },] }],
    selectedIndex: [{ type: Input }],
    negative: [{ type: Input }],
    disabled: [{ type: Input }],
    autoselect: [{ type: Input }],
    mobileAccordion: [{ type: Input }],
    selectedIndexChange: [{ type: Output }],
    selectedTabChange: [{ type: Output }],
    focusChange: [{ type: Output }],
    onResize: [{ type: HostListener, args: ['window:resize', ['$event'],] }]
};
if (false) {
    /**
     * @type {?}
     * @private
     */
    NxTabGroupComponent.prototype._selectedIndex;
    /**
     * @type {?}
     * @private
     */
    NxTabGroupComponent.prototype._groupId;
    /**
     * @type {?}
     * @private
     */
    NxTabGroupComponent.prototype._negative;
    /**
     * @type {?}
     * @private
     */
    NxTabGroupComponent.prototype._disabled;
    /**
     * @type {?}
     * @private
     */
    NxTabGroupComponent.prototype._indexToSelect;
    /**
     * @type {?}
     * @private
     */
    NxTabGroupComponent.prototype._autoselect;
    /**
     * @type {?}
     * @private
     */
    NxTabGroupComponent.prototype._mobileAccordion;
    /** @type {?} */
    NxTabGroupComponent.prototype._showAccordion;
    /**
     * \@docs-private
     * @type {?}
     */
    NxTabGroupComponent.prototype.tabs;
    /**
     * \@docs-private
     * @type {?}
     */
    NxTabGroupComponent.prototype.tabBodyChildren;
    /**
     * \@docs-private
     * @type {?}
     */
    NxTabGroupComponent.prototype.tabHeader;
    /**
     * \@docs-private
     * @type {?}
     */
    NxTabGroupComponent.prototype.panels;
    /**
     * \@docs-private
     * @type {?}
     */
    NxTabGroupComponent.prototype.accordion;
    /**
     * An event emitted when the selected tab has changed.
     * @type {?}
     */
    NxTabGroupComponent.prototype.selectedIndexChange;
    /**
     * An event emitted when the selected tab has changed.
     * @type {?}
     */
    NxTabGroupComponent.prototype.selectedTabChange;
    /**
     * An event emitted when focus has changed within a tab group.
     *
     * **Note:** is not supported in mobile view.
     * @type {?}
     */
    NxTabGroupComponent.prototype.focusChange;
    /**
     * Subscription to tabs being added/removed.
     * @type {?}
     * @private
     */
    NxTabGroupComponent.prototype._tabsSubscription;
    /**
     * Subscription to changes in the tab labels.
     * @type {?}
     * @private
     */
    NxTabGroupComponent.prototype._tabLabelSubscription;
    /**
     * @type {?}
     * @private
     */
    NxTabGroupComponent.prototype._disabledTabsCache;
    /** @type {?} */
    NxTabGroupComponent.prototype._appearanceChange;
    /**
     * @type {?}
     * @private
     */
    NxTabGroupComponent.prototype._changeDetectorRef;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidGFiLWdyb3VwLmpzIiwic291cmNlUm9vdCI6Im5nOi8vQGFsbGlhbnovbmd4LW5kYngvIiwic291cmNlcyI6WyJ0YWJzL3RhYi1ncm91cC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7OztBQUFBLE9BQU8sRUFBRSxjQUFjLEVBQUUsTUFBTSxrQkFBa0IsQ0FBQztBQUNsRCxPQUFPLEVBQUUscUJBQXFCLEVBQUUsb0JBQW9CLEVBQUUsTUFBTSx1QkFBdUIsQ0FBQztBQUNwRixPQUFPLEVBR0wsdUJBQXVCLEVBQ3ZCLGlCQUFpQixFQUNqQixTQUFTLEVBQ1QsZUFBZSxFQUNmLFlBQVksRUFDWixZQUFZLEVBQ1osS0FBSyxFQUVMLE1BQU0sRUFDTixTQUFTLEVBQ1QsU0FBUyxFQUNULFlBQVksRUFFYixNQUFNLGVBQWUsQ0FBQztBQUN2QixPQUFPLEVBQUUsS0FBSyxFQUFFLFlBQVksRUFBRSxPQUFPLEVBQUUsTUFBTSxNQUFNLENBQUM7QUFFcEQsT0FBTyxFQUFFLG9CQUFvQixFQUFFLE1BQU0sNkJBQTZCLENBQUM7QUFDbkUsT0FBTyxFQUFFLHlCQUF5QixFQUFFLE1BQU0sNkJBQTZCLENBQUM7QUFDeEUsT0FBTyxFQUFFLGNBQWMsRUFBRSxNQUFNLE9BQU8sQ0FBQztBQUN2QyxPQUFPLEVBQUUsa0JBQWtCLEVBQUUsTUFBTSxZQUFZLENBQUM7QUFDaEQsT0FBTyxFQUFFLG9CQUFvQixFQUFFLE1BQU0sY0FBYyxDQUFDO0FBRXBELE1BQU0sT0FBTyxnQkFBZ0I7Q0FNNUI7Ozs7OztJQUpDLGlDQUFjOzs7OztJQUdkLCtCQUFvQjs7O0lBR2xCLE1BQU0sR0FBVyxDQUFDOztNQUNoQixpQkFBaUIsR0FBRyxHQUFHO0FBYTdCLE1BQU0sT0FBTyxtQkFBbUI7Ozs7SUFpRzlCLFlBQW9CLGtCQUFxQztRQUFyQyx1QkFBa0IsR0FBbEIsa0JBQWtCLENBQW1CO1FBaEdqRCxtQkFBYyxHQUFrQixJQUFJLENBQUM7UUFFckMsY0FBUyxHQUFZLEtBQUssQ0FBQztR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WUFBWSxTQUFDLGtCQUFrQjt3QkFHL0IsU0FBUyxTQUFDLFdBQVcsRUFBRSxFQUFFLE1BQU0sRUFBRSxLQUFLLEVBQUU7cUJBR3hDLFlBQVksU0FBQyx5QkFBeUI7d0JBR3RDLFNBQVMsU0FBQyxvQkFBb0IsRUFBRSxFQUFFLE1BQU0sRUFBRSxLQUFLLEVBQUU7NEJBR2pELEtBQUs7dUJBU0wsS0FBSzt1QkFXTCxLQUFLO3lCQVdMLEtBQUs7OEJBU0wsS0FBSztrQ0FTTCxNQUFNO2dDQUdOLE1BQU07MEJBT04sTUFBTTt1QkE2S04sWUFBWSxTQUFDLGVBQWUsRUFBRSxDQUFDLFFBQVEsQ0FBQzs7Ozs7OztJQWpRekMsNkNBQTZDOzs7OztJQUM3Qyx1Q0FBeUI7Ozs7O0lBQ3pCLHdDQUFtQzs7Ozs7SUFDbkMsd0NBQW1DOzs7OztJQUNuQyw2Q0FBMEM7Ozs7O0lBQzFDLDBDQUFvQzs7Ozs7SUFDcEMsK0NBQXlDOztJQUN6Qyw2Q0FBZ0M7Ozs7O0lBR2hDLG1DQUFpRTs7Ozs7SUFHakUsOENBQWlGOzs7OztJQUdqRix3Q0FBMkU7Ozs7O0lBRzNFLHFDQUFzRjs7Ozs7SUFHdEYsd0NBQW9GOzs7OztJQW9EcEYsa0RBQTBGOzs7OztJQUcxRixnREFBNEc7Ozs7Ozs7SUFPNUcsMENBQXNHOzs7Ozs7SUFHdEcsZ0RBQStDOzs7Ozs7SUFHL0Msb0RBQW1EOzs7OztJQUVuRCxpREFBZ0M7O0lBRWhDLGdEQUFrQzs7Ozs7SUFFdEIsaURBQTZDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgTnhUYWJHcm91cEJhc2UgfSBmcm9tICcuL3RhYi1ncm91cC1iYXNlJztcbmltcG9ydCB7IGNvZXJjZUJvb2xlYW5Qcm9wZXJ0eSwgY29lcmNlTnVtYmVyUHJvcGVydHkgfSBmcm9tICdAYW5ndWxhci9jZGsvY29lcmNpb24nO1xuaW1wb3J0IHtcbiAgQWZ0ZXJDb250ZW50Q2hlY2tlZCxcbiAgQWZ0ZXJDb250ZW50SW5pdCxcbiAgQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3ksXG4gIENoYW5nZURldGVjdG9yUmVmLFxuICBDb21wb25lbnQsXG4gIENvbnRlbnRDaGlsZHJlbixcbiAgRXZlbnRFbWl0dGVyLFxuICBIb3N0TGlzdGVuZXIsXG4gIElucHV0LFxuICBPbkRlc3Ryb3ksXG4gIE91dHB1dCxcbiAgUXVlcnlMaXN0LFxuICBWaWV3Q2hpbGQsXG4gIFZpZXdDaGlsZHJlbixcbiAgT25Jbml0XG59IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgbWVyZ2UsIFN1YnNjcmlwdGlvbiwgU3ViamVjdCB9IGZyb20gJ3J4anMnO1xuXG5pbXBvcnQgeyBOeEFjY29yZGlvbkRpcmVjdGl2ZSB9IGZyb20gJ0BhbGxpYW56L25neC1uZGJ4L2FjY29yZGlvbic7XG5pbXBvcnQgeyBOeEV4cGFuc2lvblBhbmVsQ29tcG9uZW50IH0gZnJvbSAnQGFsbGlhbnovbmd4LW5kYngvYWNjb3JkaW9uJztcbmltcG9ydCB7IE54VGFiQ29tcG9uZW50IH0gZnJvbSAnLi90YWInO1xuaW1wb3J0IHsgTnhUYWJCb2R5Q29tcG9uZW50IH0gZnJvbSAnLi90YWItYm9keSc7XG5pbXBvcnQgeyBOeFRhYkhlYWRlckNvbXBvbmVudCB9IGZyb20gJy4vdGFiLWhlYWRlcic7XG5cbmV4cG9ydCBjbGFzcyBOeFRhYkNoYW5nZUV2ZW50IHtcbiAgLyoqIFRoZSBpbmRleCBvZiB0aGUgc2VsZWN0ZWQgb3IgZm9jdXNlZCB0YWIuICovXG4gIGluZGV4OiBudW1iZXI7XG5cbiAgLyoqIFRoZSBjb21wb25lbnQgaW5zdGFuY2Ugb2YgdGhlIHNlbGVjdGVkIG9yIGZvY3VzZWQgdGFiLiAqL1xuICB0YWI6IE54VGFiQ29tcG9uZW50O1xufVxuXG5sZXQgbmV4dElkOiBudW1iZXIgPSAwO1xuY29uc3QgTU9CSUxFX0JSRUFLUE9JTlQgPSA0ODA7XG5cbkBDb21wb25lbnQoe1xuICBzZWxlY3RvcjogJ254LXRhYi1ncm91cCcsXG4gIHRlbXBsYXRlVXJsOiAndGFiLWdyb3VwLmh0bWwnLFxuICBzdHlsZVVybHM6IFsnLi90YWItZ3JvdXAuc2NzcyddLFxuICBjaGFuZ2VEZXRlY3Rpb246IENoYW5nZURldGVjdGlvblN0cmF0ZWd5Lk9uUHVzaCxcbiAgaG9zdDoge1xuICAgICdbY2xhc3MuaXMtbmVnYXRpdmVdJzogJ25lZ2F0aXZlJyxcbiAgICAnW2NsYXNzLmlzLWRpc2FibGVkXSc6ICdkaXNhYmxlZCdcbiAgfSxcbiAgcHJvdmlkZXJzOiBbeyBwcm92aWRlOiBOeFRhYkdyb3VwQmFzZSwgdXNlRXhpc3Rpbmc6IE54VGFiR3JvdXBDb21wb25lbnQgfV1cbn0pXG5leHBvcnQgY2xhc3MgTnhUYWJHcm91cENvbXBvbmVudCBpbXBsZW1lbnRzIE54VGFiR3JvdXBCYXNlLCBPbkluaXQsIE9uRGVzdHJveSwgQWZ0ZXJDb250ZW50SW5pdCwgQWZ0ZXJDb250ZW50Q2hlY2tlZCB7XG4gIHByaXZhdGUgX3NlbGVjdGVkSW5kZXg6IG51bWJlciB8IG51bGwgPSBudWxsO1xuICBwcml2YXRlIF9ncm91cElkOiBudW1iZXI7XG4gIHByaXZhdGUgX25lZ2F0aXZlOiBib29sZWFuID0gZmFsc2U7XG4gIHByaXZhdGUgX2Rpc2FibGVkOiBib29sZWFuID0gZmFsc2U7XG4gIHByaXZhdGUgX2luZGV4VG9TZWxlY3Q6IG51bWJlciB8IG51bGwgPSAwO1xuICBwcml2YXRlIF9hdXRvc2VsZWN0OiBib29sZWFuID0gdHJ1ZTtcbiAgcHJpdmF0ZSBfbW9iaWxlQWNjb3JkaW9uOiBib29sZWFuID0gdHJ1ZTtcbiAgX3Nob3dBY2NvcmRpb246IGJvb2xlYW4gPSBmYWxzZTtcblxuICAvKiogQGRvY3MtcHJpdmF0ZSAqL1xuICBAQ29udGVudENoaWxkcmVuKE54VGFiQ29tcG9uZW50KSB0YWJzOiBRdWVyeUxpc3Q8TnhUYWJDb21wb25lbnQ+O1xuXG4gIC8qKiBAZG9jcy1wcml2YXRlICovXG4gIEBWaWV3Q2hpbGRyZW4oTnhUYWJCb2R5Q29tcG9uZW50KSB0YWJCb2R5Q2hpbGRyZW46IFF1ZXJ5TGlzdDxOeFRhYkJvZHlDb21wb25lbnQ+O1xuXG4gIC8qKiBAZG9jcy1wcml2YXRlICovXG4gIEBWaWV3Q2hpbGQoJ3RhYkhlYWRlcicsIHsgc3RhdGljOiBmYWxzZSB9KSB0YWJIZWFkZXI6IE54VGFiSGVhZGVyQ29tcG9uZW50O1xuXG4gIC8qKiBAZG9jcy1wcml2YXRlICovXG4gIEBWaWV3Q2hpbGRyZW4oTnhFeHBhbnNpb25QYW5lbENvbXBvbmVudCkgcGFuZWxzOiBRdWVyeUxpc3Q8TnhFeHBhbnNpb25QYW5lbENvbXBvbmVudD47XG5cbiAgLyoqIEBkb2NzLXByaXZhdGUgKi9cbiAgQFZpZXdDaGlsZChOeEFjY29yZGlvbkRpcmVjdGl2ZSwgeyBzdGF0aWM6IGZhbHNlIH0pIGFjY29yZGlvbjogTnhBY2NvcmRpb25EaXJlY3RpdmU7XG5cbiAgLyoqIFNldHMgdGhlIHNlbGVjdGVkIHRhYi4gKi9cbiAgQElucHV0KClcbiAgZ2V0IHNlbGVjdGVkSW5kZXgoKTogbnVtYmVyIHtcbiAgICByZXR1cm4gdGhpcy5fc2VsZWN0ZWRJbmRleDtcbiAgfVxuICBzZXQgc2VsZWN0ZWRJbmRleCh2YWx1ZTogbnVtYmVyKSB7XG4gICAgdGhpcy5faW5kZXhUb1NlbGVjdCA9IGNvZXJjZU51bWJlclByb3BlcnR5KHZhbHVlLCBudWxsKTtcbiAgfVxuXG4gIC8qKiBXaGV0aGVyIHRoZSBuZWdhdGl2ZSBzZXQgb2Ygc3R5bGluZyBzaG91bGQgYmUgdXNlZC4gKi9cbiAgQElucHV0KClcbiAgZ2V0IG5lZ2F0aXZlKCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0aGlzLl9uZWdhdGl2ZTtcbiAgfVxuICBzZXQgbmVnYXRpdmUodmFsdWU6IGJvb2xlYW4pIHtcbiAgICBpZiAodmFsdWUgIT09IHRoaXMuX25lZ2F0aXZlKSB7XG4gICAgICB0aGlzLl9uZWdhdGl2ZSA9IGNvZXJjZUJvb2xlYW5Qcm9wZXJ0eSh2YWx1ZSk7XG4gICAgfVxuICB9XG5cbiAgLyoqIFdoZXRoZXIgdGhlIHRhYiBncm91cCBpcyBkaXNhYmxlZC4gRGVmYXVsdDogZmFsc2UuICovXG4gIEBJbnB1dCgpXG4gIGdldCBkaXNhYmxlZCgpOiBib29sZWFuIHtcbiAgICByZXR1cm4gdGhpcy5fZGlzYWJsZWQ7XG4gIH1cbiAgc2V0IGRpc2FibGVkKHZhbHVlOiBib29sZWFuKSB7XG4gICAgaWYgKHZhbHVlICE9PSB0aGlzLl9kaXNhYmxlZCkge1xuICAgICAgdGhpcy5fZGlzYWJsZWQgPSBjb2VyY2VCb29sZWFuUHJvcGVydHkodmFsdWUpO1xuICAgIH1cbiAgfVxuXG4gIC8qKiBXaGV0aGVyIHRoZSB0YWIgc2hvdWxkIGJlIGltbWVkaWF0ZWx5IHNlbGVjdGVkIG9uIGZvY3VzLiAqL1xuICBASW5wdXQoKVxuICBnZXQgYXV0b3NlbGVjdCgpOiBib29sZWFuIHtcbiAgICByZXR1cm4gdGhpcy5fYXV0b3NlbGVjdDtcbiAgfVxuICBzZXQgYXV0b3NlbGVjdCh2YWx1ZTogYm9vbGVhbikge1xuICAgIHRoaXMuX2F1dG9zZWxlY3QgPSBjb2VyY2VCb29sZWFuUHJvcGVydHkodmFsdWUpO1xuICB9XG5cbiAgLyoqIFdoZXRoZXIgdGhlIHRhYnMgc2hvdWxkIHRvIGFjY29yZGlvbiBvbiBtb2JpbGUgdmlld3BvcnRzLiAqL1xuICBASW5wdXQoKVxuICBnZXQgbW9iaWxlQWNjb3JkaW9uKCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0aGlzLl9tb2JpbGVBY2NvcmRpb247XG4gIH1cbiAgc2V0IG1vYmlsZUFjY29yZGlvbih2YWx1ZTogYm9vbGVhbikge1xuICAgIHRoaXMuX21vYmlsZUFjY29yZGlvbiA9IGNvZXJjZUJvb2xlYW5Qcm9wZXJ0eSh2YWx1ZSk7XG4gIH1cblxuICAvKiogQW4gZXZlbnQgZW1pdHRlZCB3aGVuIHRoZSBzZWxlY3RlZCB0YWIgaGFzIGNoYW5nZWQuICovXG4gIEBPdXRwdXQoKSByZWFkb25seSBzZWxlY3RlZEluZGV4Q2hhbmdlOiBFdmVudEVtaXR0ZXI8bnVtYmVyPiA9IG5ldyBFdmVudEVtaXR0ZXI8bnVtYmVyPigpO1xuXG4gIC8qKiBBbiBldmVudCBlbWl0dGVkIHdoZW4gdGhlIHNlbGVjdGVkIHRhYiBoYXMgY2hhbmdlZC4gKi9cbiAgQE91dHB1dCgpIHJlYWRvbmx5IHNlbGVjdGVkVGFiQ2hhbmdlOiBFdmVudEVtaXR0ZXI8TnhUYWJDaGFuZ2VFdmVudD4gPSBuZXcgRXZlbnRFbWl0dGVyPE54VGFiQ2hhbmdlRXZlbnQ+KCk7XG5cbiAgLyoqXG4gICAqIEFuIGV2ZW50IGVtaXR0ZWQgd2hlbiBmb2N1cyBoYXMgY2hhbmdlZCB3aXRoaW4gYSB0YWIgZ3JvdXAuXG4gICAqXG4gICAqICoqTm90ZToqKiBpcyBub3Qgc3VwcG9ydGVkIGluIG1vYmlsZSB2aWV3LlxuICAgKi9cbiAgQE91dHB1dCgpIHJlYWRvbmx5IGZvY3VzQ2hhbmdlOiBFdmVudEVtaXR0ZXI8TnhUYWJDaGFuZ2VFdmVudD4gPSBuZXcgRXZlbnRFbWl0dGVyPE54VGFiQ2hhbmdlRXZlbnQ+KCk7XG5cbiAgLyoqIFN1YnNjcmlwdGlvbiB0byB0YWJzIGJlaW5nIGFkZGVkL3JlbW92ZWQuICovXG4gIHByaXZhdGUgX3RhYnNTdWJzY3JpcHRpb24gPSBTdWJzY3JpcHRpb24uRU1QVFk7XG5cbiAgLyoqIFN1YnNjcmlwdGlvbiB0byBjaGFuZ2VzIGluIHRoZSB0YWIgbGFiZWxzLiAqL1xuICBwcml2YXRlIF90YWJMYWJlbFN1YnNjcmlwdGlvbiA9IFN1YnNjcmlwdGlvbi5FTVBUWTtcblxuICBwcml2YXRlIF9kaXNhYmxlZFRhYnNDYWNoZSA9IFtdO1xuXG4gIF9hcHBlYXJhbmNlQ2hhbmdlID0gbmV3IFN1YmplY3QoKTtcblxuICBjb25zdHJ1Y3Rvcihwcml2YXRlIF9jaGFuZ2VEZXRlY3RvclJlZjogQ2hhbmdlRGV0ZWN0b3JSZWYpIHtcbiAgICB0aGlzLl9ncm91cElkID0gbmV4dElkKys7XG4gIH1cblxuICBuZ09uSW5pdCgpIHtcbiAgICB0aGlzLl9zd2l0Y2hBcHBlYXJhbmNlKHdpbmRvdy5pbm5lcldpZHRoKTtcbiAgfVxuXG4gIG5nQWZ0ZXJDb250ZW50SW5pdCgpIHtcbiAgICB0aGlzLl9zdWJzY3JpYmVUb1RhYkxhYmVscygpO1xuXG4gICAgLy8gU3Vic2NyaWJlIHRvIGNoYW5nZXMgaW4gdGhlIGFtb3VudCBvZiB0YWJzLCBpbiBvcmRlciB0byBiZVxuICAgIC8vIGFibGUgdG8gcmUtcmVuZGVyIHRoZSBjb250ZW50IGFzIG5ldyB0YWJzIGFyZSBhZGRlZCBvciByZW1vdmVkLlxuICAgIHRoaXMuX3RhYnNTdWJzY3JpcHRpb24gPSB0aGlzLnRhYnMuY2hhbmdlcy5zdWJzY3JpYmUoKCkgPT4ge1xuICAgICAgY29uc3QgaW5kZXhUb1NlbGVjdCA9IHRoaXMuX2NsYW1wVGFiSW5kZXgodGhpcy5faW5kZXhUb1NlbGVjdCk7XG4gICAgICAvLyBNYWludGFpbiB0aGUgcHJldmlvdXNseS1zZWxlY3RlZCB0YWIgaWYgYSBuZXcgdGFiIGlzIGFkZGVkIG9yIHJlbW92ZWQgYW5kIHRoZXJlIGlzIG5vXG4gICAgICAvLyBleHBsaWNpdCBjaGFuZ2UgdGhhdCBzZWxlY3RzIGEgZGlmZmVyZW50IHRhYi5cbiAgICAgIGlmIChpbmRleFRvU2VsZWN0ID09PSB0aGlzLl9zZWxlY3RlZEluZGV4KSB7XG4gICAgICAgIGNvbnN0IHRhYnMgPSB0aGlzLnRhYnMudG9BcnJheSgpO1xuXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGFicy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGlmICh0YWJzW2ldLmlzQWN0aXZlKSB7XG4gICAgICAgICAgICAvLyBBc3NpZ24gYm90aCB0byB0aGUgYF9pbmRleFRvU2VsZWN0YCBhbmQgYF9zZWxlY3RlZEluZGV4YCBzbyB3ZSBkb24ndCBmaXJlIGEgY2hhbmdlZFxuICAgICAgICAgICAgLy8gZXZlbnQsIG90aGVyd2lzZSB0aGUgY29uc3VtZXIgbWF5IGVuZCB1cCBpbiBhbiBpbmZpbml0ZSBsb29wIGluIHNvbWUgZWRnZSBjYXNlcyBsaWtlXG4gICAgICAgICAgICAvLyBhZGRpbmcgYSB0YWIgd2l0aGluIHRoZSBgc2VsZWN0ZWRJbmRleENoYW5nZWAgZXZlbnQuXG4gICAgICAgICAgICB0aGlzLl9pbmRleFRvU2VsZWN0ID0gdGhpcy5fc2VsZWN0ZWRJbmRleCA9IGk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdGhpcy5fY2hhbmdlRGV0ZWN0b3JSZWYubWFya0ZvckNoZWNrKCk7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICAqIEFmdGVyIHRoZSBjb250ZW50IGlzIGNoZWNrZWQsIHRoaXMgY29tcG9uZW50IGtub3dzIHdoYXQgdGFicyBoYXZlIGJlZW4gZGVmaW5lZFxuICAgICogYW5kIHdoYXQgdGhlIHNlbGVjdGVkIGluZGV4IHNob3VsZCBiZS5cbiAgICAqL1xuICBuZ0FmdGVyQ29udGVudENoZWNrZWQoKSB7XG5cbiAgICAvLyBEb24ndCBjbGFtcCB0aGUgYGluZGV4VG9TZWxlY3RgIGltbWVkaWF0ZWx5IGluIHRoZSBzZXR0ZXIgYmVjYXVzZSBpdCBjYW4gaGFwcGVuIHRoYXRcbiAgICAvLyB0aGUgYW1vdW50IG9mIHRhYnMgY2hhbmdlcyBiZWZvcmUgdGhlIGFjdHVhbCBjaGFuZ2UgZGV0ZWN0aW9uIHJ1bnMuXG4gICAgbGV0IGluZGV4VG9TZWxlY3QgPSB0aGlzLl9pbmRleFRvU2VsZWN0ID0gdGhpcy5fY2xhbXBUYWJJbmRleCh0aGlzLl9pbmRleFRvU2VsZWN0KTtcblxuICAgIC8vIElmIHRoZSBhY3RpdmUgdGFiIGlzIGRpc2FibGVkIHNlbGVjdCB0aGUgbmV4dCBmb2N1c2FibGUgdGFiXG4gICAgLy8gaWYgYWxsIHRhYnMgYXJlIGRpc2FibGVkLCBhbGxvdyBzZWxlY3Rpb24gb2YgZGlzYWJsZWQgYWN0aXZlIHRhYi5cbiAgICBpZiAoIXRoaXMuZGlzYWJsZWQgJiYgdGhpcy50YWJzLnRvQXJyYXkoKVtpbmRleFRvU2VsZWN0XS5kaXNhYmxlZCkge1xuICAgICAgY29uc3QgbmV4dEZvY3VzYWJsZSA9IHRoaXMudGFicy50b0FycmF5KClcbiAgICAgICAgLm1hcCgodGFiLCBpbmRleCkgPT4gKHsgdGFiOiB0YWIsIGluZGV4OiBpbmRleCB9KSlcbiAgICAgICAgLmZpbmQoaXRlbSA9PiAhaXRlbS50YWIuZGlzYWJsZWQpO1xuXG4gICAgICBpbmRleFRvU2VsZWN0ID0gbmV4dEZvY3VzYWJsZSA/IG5leHRGb2N1c2FibGUuaW5kZXggOiBpbmRleFRvU2VsZWN0O1xuICAgIH1cblxuICAgIC8vIElmIHRoZSBpbmRleCB0byBzZWxlY3Qgd2FzIGRpc2FibGVkIHByZXZpb3VzbHkgbGVhdmUgdGhlIHNlbGVjdGlvbiBvbiB0aGUgY3VycmVudFxuICAgIC8vIHNvIHRoYXQgdGhlIHNlbGVjdGlvbiBkb2VzIG5vdCBqdW1wIGZyb20gb25lIHRvIGFub3RoZXIgdGFiLlxuICAgIGlmICh0aGlzLl9kaXNhYmxlZFRhYnNDYWNoZVt0aGlzLl9pbmRleFRvU2VsZWN0XSkge1xuICAgICAgdGhpcy5faW5kZXhUb1NlbGVjdCA9IHRoaXMuc2VsZWN0ZWRJbmRleDtcbiAgICB9XG5cbiAgICAvLyBJZiB0aGVyZSBpcyBhIGNoYW5nZSBpbiBzZWxlY3RlZCBpbmRleCwgZW1pdCBhIGNoYW5nZSBldmVudC4gU2hvdWxkIG5vdCB0cmlnZ2VyIGlmXG4gICAgLy8gdGhlIHNlbGVjdGVkIGluZGV4IGhhcyBub3QgeWV0IGJlZW4gaW5pdGlhbGl6ZWQuXG4gICAgaWYgKHRoaXMuX3NlbGVjdGVkSW5kZXggIT09IGluZGV4VG9TZWxlY3QpIHtcbiAgICAgIGNvbnN0IGlzRmlyc3RSdW4gPSB0aGlzLl9zZWxlY3RlZEluZGV4ID09IG51bGw7XG5cbiAgICAgIGlmICghaXNGaXJzdFJ1bikge1xuICAgICAgICB0aGlzLnNlbGVjdGVkVGFiQ2hhbmdlLmVtaXQodGhpcy5fY3JlYXRlQ2hhbmdlRXZlbnQoaW5kZXhUb1NlbGVjdCkpO1xuICAgICAgfVxuXG4gICAgICAvLyBDaGFuZ2luZyB0aGVzZSB2YWx1ZXMgYWZ0ZXIgY2hhbmdlIGRldGVjdGlvbiBoYXMgcnVuXG4gICAgICAvLyBzaW5jZSB0aGUgY2hlY2tlZCBjb250ZW50IG1heSBjb250YWluIHJlZmVyZW5jZXMgdG8gdGhlbS5cbiAgICAgIFByb21pc2UucmVzb2x2ZSgpLnRoZW4oKCkgPT4ge1xuICAgICAgICB0aGlzLnRhYnMuZm9yRWFjaCgodGFiLCBpbmRleCkgPT4gdGFiLmlzQWN0aXZlID0gaW5kZXggPT09IGluZGV4VG9TZWxlY3QpO1xuXG4gICAgICAgIGlmICghaXNGaXJzdFJ1bikge1xuICAgICAgICAgIHRoaXMuc2VsZWN0ZWRJbmRleENoYW5nZS5lbWl0KGluZGV4VG9TZWxlY3QpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fc2VsZWN0ZWRJbmRleCAhPT0gaW5kZXhUb1NlbGVjdCkge1xuICAgICAgdGhpcy5fc2VsZWN0ZWRJbmRleCA9IGluZGV4VG9TZWxlY3Q7XG4gICAgICB0aGlzLl9jaGFuZ2VEZXRlY3RvclJlZi5tYXJrRm9yQ2hlY2soKTtcbiAgICB9XG5cbiAgICAvLyBjYWNoZSB0aGUgcHJldmlvdXMgZGlzYWJsZWQgc3RhdHVzIG9mIGFsbCB0YWJzXG4gICAgaWYgKCF0aGlzLmRpc2FibGVkKSB7XG4gICAgICB0aGlzLnRhYnMudG9BcnJheSgpLmZvckVhY2goKHRhYiwgaW5kZXgpID0+IHRoaXMuX2Rpc2FibGVkVGFic0NhY2hlW2luZGV4XSA9IHRhYi5kaXNhYmxlZCk7XG4gICAgfVxuICB9XG5cbiAgbmdPbkRlc3Ryb3koKSB7XG4gICAgdGhpcy5fdGFic1N1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xuICAgIHRoaXMuX3RhYkxhYmVsU3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XG4gIH1cblxuICAvKipcbiAgKiBTdWJzY3JpYmVzIHRvIGNoYW5nZXMgaW4gdGhlIHRhYiBsYWJlbHMuIFRoaXMgaXMgbmVlZGVkLCBiZWNhdXNlIHRoZSBASW5wdXQgZm9yIHRoZSBsYWJlbCBpc1xuICAqIG9uIHRoZSBOeFRhYiBjb21wb25lbnQsIHdoZXJlYXMgdGhlIGRhdGEgYmluZGluZyBpcyBpbnNpZGUgdGhlIE54VGFiR3JvdXAuIEluIG9yZGVyIGZvciB0aGVcbiAgKiBiaW5kaW5nIHRvIGJlIHVwZGF0ZWQsIHdlIG5lZWQgdG8gc3Vic2NyaWJlIHRvIGNoYW5nZXMgaW4gaXQgYW5kIHRyaWdnZXIgY2hhbmdlIGRldGVjdGlvblxuICAqIG1hbnVhbGx5LlxuICAqL1xuICBwcml2YXRlIF9zdWJzY3JpYmVUb1RhYkxhYmVscygpIHtcbiAgICBpZiAodGhpcy5fdGFiTGFiZWxTdWJzY3JpcHRpb24pIHtcbiAgICAgIHRoaXMuX3RhYkxhYmVsU3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XG4gICAgfVxuXG4gICAgdGhpcy5fdGFiTGFiZWxTdWJzY3JpcHRpb24gPSBtZXJnZSguLi50aGlzLnRhYnMubWFwKHRhYiA9PiB0YWIuX3N0YXRlQ2hhbmdlcykpXG4gICAgICAuc3Vic2NyaWJlKCgpID0+IHRoaXMuX2NoYW5nZURldGVjdG9yUmVmLm1hcmtGb3JDaGVjaygpKTtcbiAgfVxuXG4gIC8qKiBDbGFtcHMgdGhlIGdpdmVuIGluZGV4IHRvIHRoZSBib3VuZHMgb2YgMCBhbmQgdGhlIHRhYnMgbGVuZ3RoLiAqL1xuICBwcml2YXRlIF9jbGFtcFRhYkluZGV4KGluZGV4OiBudW1iZXIgfCBudWxsKTogbnVtYmVyIHtcbiAgICAvLyBOb3RlIHRoZSBgfHwgMGAsIHdoaWNoIGVuc3VyZXMgdGhhdCB2YWx1ZXMgbGlrZSBOYU4gY2FuJ3QgZ2V0IHRocm91Z2hcbiAgICAvLyBhbmQgd2hpY2ggd291bGQgb3RoZXJ3aXNlIHRocm93IHRoZSBjb21wb25lbnQgaW50byBhbiBpbmZpbml0ZSBsb29wXG4gICAgLy8gKHNpbmNlIE1hdGgubWF4KE5hTiwgMCkgPT09IE5hTikuXG4gICAgcmV0dXJuIE1hdGgubWluKHRoaXMudGFicy5sZW5ndGggLSAxLCBNYXRoLm1heChpbmRleCB8fCAwLCAwKSk7XG4gIH1cblxuICAvKiogQGRvY3MtcHJpdmF0ZSAqL1xuICBmb2N1c0NoYW5nZWQoaW5kZXg6IG51bWJlcikge1xuICAgIHRoaXMuZm9jdXNDaGFuZ2UuZW1pdCh0aGlzLl9jcmVhdGVDaGFuZ2VFdmVudChpbmRleCkpO1xuICB9XG5cbiAgcHJpdmF0ZSBfY3JlYXRlQ2hhbmdlRXZlbnQoaW5kZXg6IG51bWJlcik6IE54VGFiQ2hhbmdlRXZlbnQge1xuICAgIGNvbnN0IGV2ZW50ID0gbmV3IE54VGFiQ2hhbmdlRXZlbnQ7XG4gICAgZXZlbnQuaW5kZXggPSBpbmRleDtcbiAgICBpZiAodGhpcy50YWJzICYmIHRoaXMudGFicy5sZW5ndGgpIHtcbiAgICAgIGV2ZW50LnRhYiA9IHRoaXMudGFicy50b0FycmF5KClbaW5kZXhdO1xuICAgIH1cbiAgICByZXR1cm4gZXZlbnQ7XG4gIH1cblxuICAvKiogQGRvY3MtcHJpdmF0ZSAqL1xuICBoYW5kbGVDbGljayhpbmRleDogbnVtYmVyKSB7XG4gICAgY29uc3QgY2xpY2tlZFRhYiA9IHRoaXMudGFicy50b0FycmF5KClbaW5kZXhdO1xuICAgIGlmICghdGhpcy5kaXNhYmxlZCAmJiAhY2xpY2tlZFRhYi5kaXNhYmxlZCkge1xuICAgICAgdGhpcy5zZWxlY3RlZEluZGV4ID0gdGhpcy50YWJIZWFkZXIuZm9jdXNJbmRleCA9IGluZGV4O1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAZG9jcy1wcml2YXRlXG4gICAqIFJldHVybnMgdGhlIHRhYmluZGV4IGZvciBhIHRhYiBsYWJlbFxuICAgKi9cbiAgZ2V0VGFiSW5kZXgodGFiOiBOeFRhYkNvbXBvbmVudCwgaWR4OiBudW1iZXIpOiBudW1iZXIgfCBudWxsIHtcbiAgICByZXR1cm4gKHRoaXMuc2VsZWN0ZWRJbmRleCA9PT0gaWR4ICYmICF0YWIuZGlzYWJsZWQgJiYgIXRoaXMuZGlzYWJsZWQpID8gMCA6IC0xO1xuICB9XG5cbiAgLyoqIFJldHVybnMgYSB1bmlxdWUgaWQgZm9yIGVhY2ggdGFiIGxhYmVsIGVsZW1lbnQgKi9cbiAgX2dldFRhYkxhYmVsSWQoaTogbnVtYmVyKTogc3RyaW5nIHtcbiAgICByZXR1cm4gYG54LXRhYi1sYWJlbC0ke3RoaXMuX2dyb3VwSWR9LSR7aX1gO1xuICB9XG5cbiAgLyoqIFJldHVybnMgYSB1bmlxdWUgaWQgZm9yIGVhY2ggdGFiIGNvbnRlbnQgZWxlbWVudCAqL1xuICBfZ2V0VGFiQ29udGVudElkKGk6IG51bWJlcik6IHN0cmluZyB7XG4gICAgcmV0dXJuIGBueC10YWItY29udGVudC0ke3RoaXMuX2dyb3VwSWR9LSR7aX1gO1xuICB9XG5cbiAgLyoqIEBkb2NzLXByaXZhdGUgKi9cbiAgQEhvc3RMaXN0ZW5lcignd2luZG93OnJlc2l6ZScsIFsnJGV2ZW50J10pXG4gIG9uUmVzaXplKGV2ZW50KSB7XG4gICAgdGhpcy5fc3dpdGNoQXBwZWFyYW5jZShldmVudC50YXJnZXQuaW5uZXJXaWR0aCk7XG4gIH1cblxuICBwcml2YXRlIF9zd2l0Y2hBcHBlYXJhbmNlKHZpZXdQb3J0V2lkdGgpIHtcbiAgICBpZiAoIXRoaXMuX21vYmlsZUFjY29yZGlvbikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICAvLyBub3RpZnkgdGhlIG91dGxldHMgdG8gZGV0YWNoIHRoZSB2aWV3cmVmcyBmb3IgaGVhZGVyIGFuZCBib2R5IGJlZm9yZVxuICAgIC8vIHdlIHN3aXRjaCB0aGUgYXBwZWFyYW5jZS4gdGhpcyB3YXkgd2Ugb25seSBpbnN0YW50aWF0ZSB0aGUgdGVtcGxhdGVzXG4gICAgLy8gb25jZSBzbyB0aGF0IHRoZXkgZG8gbm90IGdldCBkZXN0cm95ZWQgZHVyaW5nIHRoZSBzd2l0Y2hcbiAgICBpZiAodmlld1BvcnRXaWR0aCA8PSBNT0JJTEVfQlJFQUtQT0lOVCAmJiAhdGhpcy5fc2hvd0FjY29yZGlvbikge1xuICAgICAgdGhpcy5fYXBwZWFyYW5jZUNoYW5nZS5uZXh0KCk7XG4gICAgICB0aGlzLl9zaG93TW9iaWxlVmVyc2lvbigpO1xuICAgIH0gZWxzZSBpZiAodmlld1BvcnRXaWR0aCA+IE1PQklMRV9CUkVBS1BPSU5UICYmIHRoaXMuX3Nob3dBY2NvcmRpb24pIHtcbiAgICAgIHRoaXMuX2FwcGVhcmFuY2VDaGFuZ2UubmV4dCgpO1xuICAgICAgdGhpcy5fc2hvd0Rlc2t0b3BWZXJzaW9uKCk7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBfc2hvd01vYmlsZVZlcnNpb24oKSB7XG4gICAgdGhpcy5fc2hvd0FjY29yZGlvbiA9IHRydWU7XG4gICAgdGhpcy5fY2hhbmdlRGV0ZWN0b3JSZWYubWFya0ZvckNoZWNrKCk7XG4gIH1cblxuICBwcml2YXRlIF9zaG93RGVza3RvcFZlcnNpb24oKSB7XG4gICAgdGhpcy5fc2hvd0FjY29yZGlvbiA9IGZhbHNlO1xuICAgIHRoaXMuX2NoYW5nZURldGVjdG9yUmVmLm1hcmtGb3JDaGVjaygpO1xuICB9XG5cbiAgLyoqXG4gICAqIEVtdWxhdGUgdGhlIHRhYiBjaGFuZ2UgZXZlbnQgd2hlbiBhbiBhY2NvcmRpb24gcGFuZWwgaXMgb3BlbmVkIGluXG4gICAqIG1vYmlsZSB2aWV3cG9ydHMuXG4gICAqL1xuICBfcGFuZWxPcGVuZWQoaW5kZXg6IG51bWJlcikge1xuICAgIHRoaXMuc2VsZWN0ZWRJbmRleCA9IGluZGV4O1xuICB9XG59XG4iXX0=