/**
 * @fileoverview added by tsickle
 * Generated from: tabs/tab.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import { NxTabGroupBase } from './tab-group-base';
import { ChangeDetectionStrategy, Component, Input, TemplateRef, ViewChild, Optional, Inject, Host, ContentChild } from '@angular/core';
import { Subject } from 'rxjs';
import { NxTabLabelDirective } from './tab-label';
import { NxTabContentDirective } from './tab-content';
export class NxTabComponent {
    /**
     * @param {?} _tabGroup
     */
    constructor(_tabGroup) {
        this._tabGroup = _tabGroup;
        this._disabled = false;
        /**
         * Emits whenever the internal state of the tab changes.
         */
        this._stateChanges = new Subject();
        /**
         * Whether the tab is currently active.
         */
        this.isActive = false;
        if (!this._tabGroup) {
            throw Error(`The nx-tab element has to be wrapped in a nx-tab-group to work.
      Please provide a nx-tab-group element and place your tabs inside it.`);
        }
    }
    /**
     * Content for the tab label given by `<ng-template nxTabLabel>`.
     * \@docs-private
     *
     * @return {?}
     */
    get templateLabel() { return this._templateLabel; }
    /**
     * @param {?} value
     * @return {?}
     */
    set templateLabel(value) {
        // Only update the templateLabel via query if there is actually
        // a nxTabLabel found. This works around an issue where a user may have
        // manually set `templateLabel` during creation mode, which would then get clobbered
        // by `undefined` when this query resolves.
        if (value) {
            this._templateLabel = value;
        }
    }
    /**
     * Sets the label of the tab shown in the tablist.
     * @return {?}
     */
    get label() {
        return this._label;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set label(value) {
        if (this._label !== value) {
            this._label = value;
        }
    }
    /**
     * Sets the tab to disabled.
     * @return {?}
     */
    get disabled() {
        return (this._tabGroup && ((/** @type {?} */ (this._tabGroup))).disabled) ?
            ((/** @type {?} */ (this._tabGroup))).disabled : this._disabled;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set disabled(value) {
        if (this._disabled !== value) {
            this._disabled = value;
        }
    }
    /**
     * \@docs-private
     * @return {?}
     */
    get headerViewRef() {
        return this._headerViewRef;
    }
    /**
     * \@docs-private
     * @return {?}
     */
    get contentViewRef() {
        // for lazy loading we only create the viewref when it is asked for
        if (!this._contentViewRef) {
            /** @type {?} */
            const contentTemplate = this._explicitContent || this._implicitContent;
            this._contentViewRef = contentTemplate.createEmbeddedView({});
        }
        return this._contentViewRef;
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        if (changes.hasOwnProperty('label') || changes.hasOwnProperty('disabled')) {
            this._stateChanges.next();
        }
    }
    /**
     * @return {?}
     */
    ngAfterContentInit() {
        if (this.templateLabel) {
            this._headerViewRef = this.templateLabel.createEmbeddedView({});
        }
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this._stateChanges.complete();
        this._contentViewRef.destroy();
        if (this._headerViewRef) {
            this._headerViewRef.destroy();
        }
    }
}
NxTabComponent.decorators = [
    { type: Component, args: [{
                selector: 'nx-tab',
                exportAs: 'nxTab',
                template: "<ng-template><ng-content></ng-content></ng-template>\n",
                changeDetection: ChangeDetectionStrategy.OnPush
            }] }
];
/** @nocollapse */
NxTabComponent.ctorParameters = () => [
    { type: NxTabGroupBase, decorators: [{ type: Inject, args: [NxTabGroupBase,] }, { type: Optional }, { type: Host }] }
];
NxTabComponent.propDecorators = {
    templateLabel: [{ type: ContentChild, args: [NxTabLabelDirective, { read: TemplateRef, static: true },] }],
    _implicitContent: [{ type: ViewChild, args: [TemplateRef, { static: true },] }],
    _explicitContent: [{ type: ContentChild, args: [NxTabContentDirective, { read: TemplateRef, static: true },] }],
    label: [{ type: Input }],
    disabled: [{ type: Input }]
};
if (false) {
    /**
     * @type {?}
     * @private
     */
    NxTabComponent.prototype._label;
    /**
     * @type {?}
     * @private
     */
    NxTabComponent.prototype._disabled;
    /**
     * Emits whenever the internal state of the tab changes.
     * @type {?}
     */
    NxTabComponent.prototype._stateChanges;
    /**
     * @type {?}
     * @private
     */
    NxTabComponent.prototype._templateLabel;
    /**
     * Template inside the NxTab view that contains an `<ng-content>`.
     * @type {?}
     */
    NxTabComponent.prototype._implicitContent;
    /**
     * Template provided in the tab content that will be used if present, used to enable lazy-loading
     * @type {?}
     */
    NxTabComponent.prototype._explicitContent;
    /**
     * @type {?}
     * @private
     */
    NxTabComponent.prototype._headerViewRef;
    /**
     * @type {?}
     * @private
     */
    NxTabComponent.prototype._contentViewRef;
    /**
     * Whether the tab is currently active.
     * @type {?}
     */
    NxTabComponent.prototype.isActive;
    /**
     * @type {?}
     * @private
     */
    NxTabComponent.prototype._tabGroup;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidGFiLmpzIiwic291cmNlUm9vdCI6Im5nOi8vQGFsbGlhbnovbmd4LW5kYngvIiwic291cmNlcyI6WyJ0YWJzL3RhYi50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7OztBQUFBLE9BQU8sRUFBRSxjQUFjLEVBQUUsTUFBTSxrQkFBa0IsQ0FBQztBQUNsRCxPQUFPLEVBQ0wsdUJBQXVCLEVBQ3ZCLFNBQVMsRUFDVCxLQUFLLEVBSUwsV0FBVyxFQUNYLFNBQVMsRUFDVCxRQUFRLEVBQ1IsTUFBTSxFQUNOLElBQUksRUFDSixZQUFZLEVBR2IsTUFBTSxlQUFlLENBQUM7QUFDdkIsT0FBTyxFQUFFLE9BQU8sRUFBRSxNQUFNLE1BQU0sQ0FBQztBQUUvQixPQUFPLEVBQUUsbUJBQW1CLEVBQUUsTUFBTSxhQUFhLENBQUM7QUFDbEQsT0FBTyxFQUFFLHFCQUFxQixFQUFFLE1BQU0sZUFBZSxDQUFDO0FBUXRELE1BQU0sT0FBTyxjQUFjOzs7O0lBK0V6QixZQUNzRCxTQUF5QjtRQUF6QixjQUFTLEdBQVQsU0FBUyxDQUFnQjtRQTlFdkUsY0FBUyxHQUFZLEtBQUssQ0FBQzs7OztRQUcxQixrQkFBYSxHQUFHLElBQUksT0FBTyxFQUFRLENBQUM7Ozs7UUF3RTdDLGFBQVEsR0FBRyxLQUFLLENBQUM7UUFJZixJQUFJLENBQUMsSUFBSSxDQUFDLFNBQVMsRUFBRTtZQUNuQixNQUFNLEtBQUssQ0FBQzsyRUFDeUQsQ0FBQyxDQUFDO1NBQ3hFO0lBQ0gsQ0FBQzs7Ozs7OztJQTFFRCxJQUNJLGFBQWEsS0FBc0IsT0FBTyxJQUFJLENBQUMsY0FBYyxDQUFDLENBQUMsQ0FBQzs7Ozs7SUFDcEUsSUFBSSxhQUFhLENBQUMsS0FBdUI7UUFDdkMsK0RBQStEO1FBQy9ELHVFQUF1RTtRQUN2RSxvRkFBb0Y7UUFDcEYsMkNBQTJDO1FBQzNDLElBQUksS0FBSyxFQUFFO1lBQ1QsSUFBSSxDQUFDLGNBQWMsR0FBRyxLQUFLLENBQUM7U0FDN0I7SUFDSCxDQUFDOzs7OztJQWFELElB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NkM7Ozs7O0lBQzdDLHlDQUE4Qzs7Ozs7SUFvQjlDLGtDQUFpQjs7Ozs7SUFHZixtQ0FBNkUiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBOeFRhYkdyb3VwQmFzZSB9IGZyb20gJy4vdGFiLWdyb3VwLWJhc2UnO1xuaW1wb3J0IHtcbiAgQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3ksXG4gIENvbXBvbmVudCxcbiAgSW5wdXQsXG4gIE9uQ2hhbmdlcyxcbiAgT25EZXN0cm95LFxuICBTaW1wbGVDaGFuZ2VzLFxuICBUZW1wbGF0ZVJlZixcbiAgVmlld0NoaWxkLFxuICBPcHRpb25hbCxcbiAgSW5qZWN0LFxuICBIb3N0LFxuICBDb250ZW50Q2hpbGQsXG4gIEVtYmVkZGVkVmlld1JlZixcbiAgQWZ0ZXJDb250ZW50SW5pdFxufSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IFN1YmplY3QgfSBmcm9tICdyeGpzJztcbmltcG9ydCB7IE54VGFiR3JvdXBDb21wb25lbnQgfSBmcm9tICcuL3RhYi1ncm91cCc7XG5pbXBvcnQgeyBOeFRhYkxhYmVsRGlyZWN0aXZlIH0gZnJvbSAnLi90YWItbGFiZWwnO1xuaW1wb3J0IHsgTnhUYWJDb250ZW50RGlyZWN0aXZlIH0gZnJvbSAnLi90YWItY29udGVudCc7XG5cbkBDb21wb25lbnQoe1xuICBzZWxlY3RvcjogJ254LXRhYicsXG4gIGV4cG9ydEFzOiAnbnhUYWInLFxuICB0ZW1wbGF0ZVVybDogJ3RhYi5odG1sJyxcbiAgY2hhbmdlRGV0ZWN0aW9uOiBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5PblB1c2hcbn0pXG5leHBvcnQgY2xhc3MgTnhUYWJDb21wb25lbnQgaW1wbGVtZW50cyBPbkNoYW5nZXMsIE9uRGVzdHJveSwgQWZ0ZXJDb250ZW50SW5pdCB7XG4gIHByaXZhdGUgX2xhYmVsOiBzdHJpbmc7XG4gIHByaXZhdGUgX2Rpc2FibGVkOiBib29sZWFuID0gZmFsc2U7XG5cbiAgLyoqIEVtaXRzIHdoZW5ldmVyIHRoZSBpbnRlcm5hbCBzdGF0ZSBvZiB0aGUgdGFiIGNoYW5nZXMuICovXG4gIHJlYWRvbmx5IF9zdGF0ZUNoYW5nZXMgPSBuZXcgU3ViamVjdDx2b2lkPigpO1xuXG4gIC8qKlxuICAgKiBDb250ZW50IGZvciB0aGUgdGFiIGxhYmVsIGdpdmVuIGJ5IGA8bmctdGVtcGxhdGUgbnhUYWJMYWJlbD5gLlxuICAgKiBAZG9jcy1wcml2YXRlXG4gICAqICovXG4gIEBDb250ZW50Q2hpbGQoTnhUYWJMYWJlbERpcmVjdGl2ZSwgeyByZWFkOiBUZW1wbGF0ZVJlZiwgc3RhdGljOiB0cnVlIH0pXG4gIGdldCB0ZW1wbGF0ZUxhYmVsKCk6IFRlbXBsYXRlUmVmPGFueT4ge3JldHVybiB0aGlzLl90ZW1wbGF0ZUxhYmVsOyB9XG4gIHNldCB0ZW1wbGF0ZUxhYmVsKHZhbHVlOiBUZW1wbGF0ZVJlZjxhbnk+KSB7XG4gICAgLy8gT25seSB1cGRhdGUgdGhlIHRlbXBsYXRlTGFiZWwgdmlhIHF1ZXJ5IGlmIHRoZXJlIGlzIGFjdHVhbGx5XG4gICAgLy8gYSBueFRhYkxhYmVsIGZvdW5kLiBUaGlzIHdvcmtzIGFyb3VuZCBhbiBpc3N1ZSB3aGVyZSBhIHVzZXIgbWF5IGhhdmVcbiAgICAvLyBtYW51YWxseSBzZXQgYHRlbXBsYXRlTGFiZWxgIGR1cmluZyBjcmVhdGlvbiBtb2RlLCB3aGljaCB3b3VsZCB0aGVuIGdldCBjbG9iYmVyZWRcbiAgICAvLyBieSBgdW5kZWZpbmVkYCB3aGVuIHRoaXMgcXVlcnkgcmVzb2x2ZXMuXG4gICAgaWYgKHZhbHVlKSB7XG4gICAgICB0aGlzLl90ZW1wbGF0ZUxhYmVsID0gdmFsdWU7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBfdGVtcGxhdGVMYWJlbDogVGVtcGxhdGVSZWY8YW55PjtcblxuICAvKiogVGVtcGxhdGUgaW5zaWRlIHRoZSBOeFRhYiB2aWV3IHRoYXQgY29udGFpbnMgYW4gYDxuZy1jb250ZW50PmAuICovXG4gIEBWaWV3Q2hpbGQoVGVtcGxhdGVSZWYsIHsgc3RhdGljOiB0cnVlIH0pIF9pbXBsaWNpdENvbnRlbnQ6IFRlbXBsYXRlUmVmPGFueT47XG4gIC8qKlxuICAgKiBUZW1wbGF0ZSBwcm92aWRlZCBpbiB0aGUgdGFiIGNvbnRlbnQgdGhhdCB3aWxsIGJlIHVzZWQgaWYgcHJlc2VudCwgdXNlZCB0byBlbmFibGUgbGF6eS1sb2FkaW5nXG4gICAqL1xuICBAQ29udGVudENoaWxkKE54VGFiQ29udGVudERpcmVjdGl2ZSwgeyByZWFkOiBUZW1wbGF0ZVJlZiwgc3RhdGljOiB0cnVlIH0pXG4gIF9leHBsaWNpdENvbnRlbnQ6IFRlbXBsYXRlUmVmPGFueT47XG5cbiAgLyoqIFNldHMgdGhlIGxhYmVsIG9mIHRoZSB0YWIgc2hvd24gaW4gdGhlIHRhYmxpc3QuICovXG4gIEBJbnB1dCgpXG4gIGdldCBsYWJlbCgpOiBzdHJpbmcge1xuICAgIHJldHVybiB0aGlzLl9sYWJlbDtcbiAgfVxuICBzZXQgbGFiZWwodmFsdWU6IHN0cmluZykge1xuICAgIGlmICh0aGlzLl9sYWJlbCAhPT0gdmFsdWUpIHtcbiAgICAgIHRoaXMuX2xhYmVsID0gdmFsdWU7XG4gICAgfVxuICB9XG5cbiAgLyoqIFNldHMgdGhlIHRhYiB0byBkaXNhYmxlZC4gKi9cbiAgQElucHV0KClcbiAgZ2V0IGRpc2FibGVkKCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiAodGhpcy5fdGFiR3JvdXAgJiYgKHRoaXMuX3RhYkdyb3VwIGFzIE54VGFiR3JvdXBDb21wb25lbnQpLmRpc2FibGVkKSA/XG4gICAgKHRoaXMuX3RhYkdyb3VwIGFzIE54VGFiR3JvdXBDb21wb25lbnQpLmRpc2FibGVkIDogdGhpcy5fZGlzYWJsZWQ7XG4gIH1cbiAgc2V0IGRpc2FibGVkKHZhbHVlOiBib29sZWFuKSB7XG4gICAgaWYgKHRoaXMuX2Rpc2FibGVkICE9PSB2YWx1ZSkge1xuICAgICAgdGhpcy5fZGlzYWJsZWQgPSB2YWx1ZTtcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIF9oZWFkZXJWaWV3UmVmOiBFbWJlZGRlZFZpZXdSZWY8YW55PjtcbiAgcHJpdmF0ZSBfY29udGVudFZpZXdSZWY6IEVtYmVkZGVkVmlld1JlZjxhbnk+O1xuXG4gIC8qKiBAZG9jcy1wcml2YXRlICovXG4gIGdldCBoZWFkZXJWaWV3UmVmKCkge1xuICAgIHJldHVybiB0aGlzLl9oZWFkZXJWaWV3UmVmO1xuICB9XG5cbiAgLyoqIEBkb2NzLXByaXZhdGUgKi9cbiAgZ2V0IGNvbnRlbnRWaWV3UmVmKCkge1xuICAgIC8vIGZvciBsYXp5IGxvYWRpbmcgd2Ugb25seSBjcmVhdGUgdGhlIHZpZXdyZWYgd2hlbiBpdCBpcyBhc2tlZCBmb3JcbiAgICBpZiAoIXRoaXMuX2NvbnRlbnRWaWV3UmVmKSB7XG4gICAgICBjb25zdCBjb250ZW50VGVtcGxhdGUgPSB0aGlzLl9leHBsaWNpdENvbnRlbnQgfHwgdGhpcy5faW1wbGljaXRDb250ZW50O1xuICAgICAgdGhpcy5fY29udGVudFZpZXdSZWYgPSBjb250ZW50VGVtcGxhdGUuY3JlYXRlRW1iZWRkZWRWaWV3KHt9KTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX2NvbnRlbnRWaWV3UmVmO1xuICB9XG5cbiAgLyoqXG4gICAqIFdoZXRoZXIgdGhlIHRhYiBpcyBjdXJyZW50bHkgYWN0aXZlLlxuICAgKi9cbiAgaXNBY3RpdmUgPSBmYWxzZTtcblxuICBjb25zdHJ1Y3RvcihcbiAgICBASW5qZWN0KE54VGFiR3JvdXBCYXNlKSBAT3B0aW9uYWwoKSBASG9zdCgpIHByaXZhdGUgX3RhYkdyb3VwOiBOeFRhYkdyb3VwQmFzZSkge1xuICAgIGlmICghdGhpcy5fdGFiR3JvdXApIHtcbiAgICAgIHRocm93IEVycm9yKGBUaGUgbngtdGFiIGVsZW1lbnQgaGFzIHRvIGJlIHdyYXBwZWQgaW4gYSBueC10YWItZ3JvdXAgdG8gd29yay5cbiAgICAgIFBsZWFzZSBwcm92aWRlIGEgbngtdGFiLWdyb3VwIGVsZW1lbnQgYW5kIHBsYWNlIHlvdXIgdGFicyBpbnNpZGUgaXQuYCk7XG4gICAgfVxuICB9XG5cbiAgbmdPbkNoYW5nZXMoY2hhbmdlczogU2ltcGxlQ2hhbmdlcyk6IHZvaWQge1xuICAgIGlmIChjaGFuZ2VzLmhhc093blByb3BlcnR5KCdsYWJlbCcpIHx8IGNoYW5nZXMuaGFzT3duUHJvcGVydHkoJ2Rpc2FibGVkJykpIHtcbiAgICAgIHRoaXMuX3N0YXRlQ2hhbmdlcy5uZXh0KCk7XG4gICAgfVxuICB9XG5cbiAgbmdBZnRlckNvbnRlbnRJbml0KCkge1xuICAgIGlmICh0aGlzLnRlbXBsYXRlTGFiZWwpIHtcbiAgICAgIHRoaXMuX2hlYWRlclZpZXdSZWYgPSB0aGlzLnRlbXBsYXRlTGFiZWwuY3JlYXRlRW1iZWRkZWRWaWV3KHt9KTtcbiAgICB9XG4gIH1cblxuICBuZ09uRGVzdHJveSgpOiB2b2lkIHtcbiAgICB0aGlzLl9zdGF0ZUNoYW5nZXMuY29tcGxldGUoKTtcbiAgICB0aGlzLl9jb250ZW50Vmlld1JlZi5kZXN0cm95KCk7XG4gICAgaWYgKHRoaXMuX2hlYWRlclZpZXdSZWYpIHsgdGhpcy5faGVhZGVyVmlld1JlZi5kZXN0cm95KCk7IH1cbiAgfVxufVxuIl19