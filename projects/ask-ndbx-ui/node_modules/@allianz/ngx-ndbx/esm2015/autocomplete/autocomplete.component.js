/**
 * @fileoverview added by tsickle
 * Generated from: autocomplete/autocomplete.component.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import { ActiveDescendantKeyManager } from '@angular/cdk/a11y';
import { Component, ElementRef, EventEmitter, Input, Output, TemplateRef, ViewChild, ViewChildren, ContentChildren, QueryList, ChangeDetectionStrategy, ChangeDetectorRef, Optional } from '@angular/core';
import { NxAutocompleteOptionComponent } from './autocomplete-option.component';
import { NxFormfieldComponent } from '@allianz/ngx-ndbx/formfield';
import { Observable } from 'rxjs';
/**
 * Autocomplete IDs need to be unique across components, so this counter exists outside of
 * the component definition.
 * @type {?}
 */
let _uniqueAutocompleteIdCounter = 0;
/**
 * Event object that is emitted when an autocomplete option is selected.
 */
export class NxAutocompleteSelectedEvent {
    /**
     * @param {?} source
     * @param {?} option
     */
    constructor(source, option) {
        this.source = source;
        this.option = option;
    }
}
if (false) {
    /**
     * Reference to the autocomplete panel that emitted the event.
     * @type {?}
     */
    NxAutocompleteSelectedEvent.prototype.source;
    /**
     * Option that was selected.
     * @type {?}
     */
    NxAutocompleteSelectedEvent.prototype.option;
}
export class NxAutocompleteComponent {
    /**
     * @param {?} _changeDetectorRef
     * @param {?} _elementRef
     * @param {?} formFieldComponent
     */
    constructor(_changeDetectorRef, _elementRef, formFieldComponent) {
        this._changeDetectorRef = _changeDetectorRef;
        this._elementRef = _elementRef;
        this.formFieldComponent = formFieldComponent;
        /**
         * Whether the autocomplete panel should be visible, depending on option length.
         */
        this.showPanel = false;
        this._isOpen = false;
        this._items = null;
        this._hasItems = false;
        /**
         * Event that is emitted whenever an option from the list is selected.
         */
        this.optionSelected = new EventEmitter();
        /**
         * Event that is emitted when the autocomplete panel is opened.
         */
        this.opened = new EventEmitter();
        /**
         * Event that is emitted when the autocomplete panel is closed.
         */
        this.closed = new EventEmitter();
        this._classList = {};
        /**
         * Unique ID to be used by autocomplete trigger's "aria-owns" property.
         */
        this.id = `nx-autocomplete-${_uniqueAutocompleteIdCounter++}`;
        // As autocomplete option can hold any value, we might need a converter
        // to get a string representation, which can be stored in input. Default value ? value.toString() : null.
        /**
         * Value to string converter.
         */
        this.valueFormatter = (/**
         * @param {?} value
         * @return {?}
         */
        (value) => value ? value.toString() : null);
    }
    /**
     * Whether the autocomplete panel is open.
     * @return {?}
     */
    get isOpen() { return this._isOpen && this.showPanel; }
    /**
     * Items observable. If given, autocomplete takes care of the options and ng-content is discarderd
     * @param {?} val
     * @return {?}
     */
    set items(val) {
        this._hasItems = true;
        if (Array.isArray(val)) {
            this._items = val;
        }
        else if (val instanceof Observable) {
            if (this._itemsSubscription) {
                this._itemsSubscription.unsubscribe();
            }
            this._itemsSubscription = val.subscribe((/**
             * @param {?} itms
             * @return {?}
             */
            (itms) => {
                this._items = itms;
                this._changeDetectorRef.markForCheck();
                // and check visibility in next cycle, when options are set
                setTimeout((/**
                 * @return {?}
                 */
                () => this._setVisibility()));
            }));
        }
        else if (val === null) {
            this._items = val;
        }
        else {
            throw new Error('Invalid argument for autocomplete items. It has to be Array<string> or Observable<Array<string>>');
        }
    }
    /**
     * @return {?}
     */
    get items() {
        return this._items;
    }
    /**
     * \@docs-private
     * Is items observable set
     * @return {?}
     */
    get hasItems() {
        return this._hasItems;
    }
    /**
     * Autocomplete options
     * @return {?}
     */
    get options() {
        return this.hasItems ? this._vOptions : this._cOptions;
    }
    /**
     * Takes classes set on the host nx-autocomplete element and applies them to the panel
     * inside the overlay container to allow for easy styling.
     * @param {?} value
     * @return {?}
     */
    set classList(value) {
        if (value && value.length) {
            value.split(' ').forEach((/**
             * @param {?} className
             * @return {?}
             */
            className => this._classList[className.trim()] = true));
            this._elementRef.nativeElement.className = '';
        }
    }
    /**
     * @return {?}
     */
    ngAfterViewInit() {
        this._keyManager = new ActiveDescendantKeyManager(this.options).withWrap();
        this._setVisibility();
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        if (this._itemsSubscription) {
            this._itemsSubscription.unsubscribe();
        }
    }
    /**
     * Sets the panel scrollTop. This allows us to manually scroll to display options
     * above or below the fold, as they are not actually being focused when active.
     * @param {?} scrollTop
     * @return {?}
     */
    _setScrollTop(scrollTop) {
        if (this.panel) {
            this.panel.nativeElement.scrollTop = scrollTop;
        }
    }
    /**
     * Returns the panel's scrollTop.
     * @return {?}
     */
    _getScrollTop() {
        return this.panel ? this.panel.nativeElement.scrollTop : 0;
    }
    /**
     * Panel should hide itself when the option list is empty.
     * @return {?}
     */
    _setVisibility() {
        this.showPanel = !!(this.options && this.options.length);
        this._classList['nx-autocomplete-visible'] = this.showPanel;
        this._classList['nx-autocomplete-hidden'] = !this.showPanel;
        this._changeDetectorRef.markForCheck();
    }
    /**
     * Emits the `select` event.
     * @param {?} option
     * @return {?}
     */
    _emitSelectEvent(option) {
        /** @type {?} */
        const event = new NxAutocompleteSelectedEvent(this, option);
        this.optionSelected.emit(event);
    }
    /**
     * @return {?}
     */
    get _isInOutlineField() {
        return this.formFieldComponent !== null
            && this.formFieldComponent.appearance === 'outline';
    }
}
NxAutocompleteComponent.decorators = [
    { type: Component, args: [{
                selector: 'nx-autocomplete',
                template: "<ng-template>\n  <div class=\"nx-autocomplete-panel\" role=\"listbox\" [id]=\"id\" [ngClass]=\"_classList\"\n  [class.nx-autocomplete-panel--in-outline-field]=\"_isInOutlineField\" #panel>\n    <ng-container *ngIf=\"hasItems\">\n      <nx-autocomplete-option *ngFor=\"let item of items\" [value]=\"item\">\n        {{item}}\n      </nx-autocomplete-option>\n    </ng-container>\n    <ng-container *ngIf=\"!hasItems\">\n      <ng-content></ng-content>\n    </ng-container>\n  </div>\n</ng-template>\n",
                changeDetection: ChangeDetectionStrategy.OnPush,
                exportAs: 'nxAutocomplete',
                host: {
                    'class': 'nx-autocomplete'
                },
                styles: [":host ::ng-deep .c-input::-ms-clear{width:0;height:0}.nx-autocomplete-panel{background-color:#fff;box-shadow:0 2px 4px rgba(65,65,65,.5);overflow-y:auto;overflow-x:hidden;max-height:280px;width:100%;border-radius:4px}.nx-autocomplete-panel.nx-autocomplete-visible{visibility:visible}.nx-autocomplete-panel.nx-autocomplete-hidden{visibility:hidden}.nx-autocomplete-panel--in-outline-field ::ng-deep nx-autocomplete-option .nx-autocomplete-option,.nx-autocomplete-panel--in-outline-field ::ng-deep nx-autocomplete-option .nx-autocomplete-option__label{font-size:16px;font-size:var(--dropdown-item-outline-font-size,16px);line-height:24px;line-height:var(--dropdown-item-outline-line-height,24px);font-weight:400;font-weight:var(--dropdown-item-outline-font-weight,400);letter-spacing:0;letter-spacing:var(--dropdown-item-outline-letter-spacing,0)}@media screen and (-ms-high-contrast:active){.nx-autocomplete-panel{box-shadow:0 0 0 1px windowText}}"]
            }] }
];
/** @nocollapse */
NxAutocompleteComponent.ctorParameters = () => [
    { type: ChangeDetectorRef },
    { type: ElementRef },
    { type: NxFormfieldComponent, decorators: [{ type: Optional }] }
];
NxAutocompleteComponent.propDecorators = {
    template: [{ type: ViewChild, args: [TemplateRef, { static: false },] }],
    panel: [{ type: ViewChild, args: ['panel', { static: false },] }],
    items: [{ type: Input }],
    optionSelected: [{ type: Output }],
    opened: [{ type: Output }],
    closed: [{ type: Output }],
    _vOptions: [{ type: ViewChildren, args: [NxAutocompleteOptionComponent,] }],
    _cOptions: [{ type: ContentChildren, args: [NxAutocompleteOptionComponent, { descendants: true },] }],
    classList: [{ type: Input, args: ['class',] }],
    valueFormatter: [{ type: Input, args: ['nxValueFormatter',] }]
};
if (false) {
    /**
     * Manages active item in option list based on key events.
     * @type {?}
     */
    NxAutocompleteComponent.prototype._keyManager;
    /**
     * Whether the autocomplete panel should be visible, depending on option length.
     * @type {?}
     */
    NxAutocompleteComponent.prototype.showPanel;
    /** @type {?} */
    NxAutocompleteComponent.prototype._isOpen;
    /**
     * \@docs-private
     * @type {?}
     */
    NxAutocompleteComponent.prototype.template;
    /**
     * \@docs-private
     * Element for the panel containing the autocomplete options.
     * @type {?}
     */
    NxAutocompleteComponent.prototype.panel;
    /**
     * @type {?}
     * @private
     */
    NxAutocompleteComponent.prototype._items;
    /**
     * @type {?}
     * @private
     */
    NxAutocompleteComponent.prototype._itemsSubscription;
    /**
     * @type {?}
     * @private
     */
    NxAutocompleteComponent.prototype._hasItems;
    /**
     * Event that is emitted whenever an option from the list is selected.
     * @type {?}
     */
    NxAutocompleteComponent.prototype.optionSelected;
    /**
     * Event that is emitted when the autocomplete panel is opened.
     * @type {?}
     */
    NxAutocompleteComponent.prototype.opened;
    /**
     * Event that is emitted when the autocomplete panel is closed.
     * @type {?}
     */
    NxAutocompleteComponent.prototype.closed;
    /**
     * Autocomplete options in view - ie from items
     * @type {?}
     * @private
     */
    NxAutocompleteComponent.prototype._vOptions;
    /**
     * Autocomplete options in content - ie user provided
     * @type {?}
     * @private
     */
    NxAutocompleteComponent.prototype._cOptions;
    /** @type {?} */
    NxAutocompleteComponent.prototype._classList;
    /**
     * Unique ID to be used by autocomplete trigger's "aria-owns" property.
     * @type {?}
     */
    NxAutocompleteComponent.prototype.id;
    /**
     * Value to string converter.
     * @type {?}
     */
    NxAutocompleteComponent.prototype.valueFormatter;
    /**
     * @type {?}
     * @private
     */
    NxAutocompleteComponent.prototype._changeDetectorRef;
    /**
     * @type {?}
     * @private
     */
    NxAutocompleteComponent.prototype._elementRef;
    /**
     * @type {?}
     * @private
     */
    NxAutocompleteComponent.prototype.formFieldComponent;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYXV0b2NvbXBsZXRlLmNvbXBvbmVudC5qcyIsInNvdXJjZVJvb3QiOiJuZzovL0BhbGxpYW56L25neC1uZGJ4LyIsInNvdXJjZXMiOlsiYXV0b2NvbXBsZXRlL2F1dG9jb21wbGV0ZS5jb21wb25lbnQudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7QUFDQSxPQUFPLEVBQUUsMEJBQTBCLEVBQUUsTUFBTSxtQkFBbUIsQ0FBQztBQUMvRCxPQUFPLEVBRUwsU0FBUyxFQUNULFVBQVUsRUFDVixZQUFZLEVBQ1osS0FBSyxFQUNMLE1BQU0sRUFDTixXQUFXLEVBQ1gsU0FBUyxFQUNULFlBQVksRUFDWixlQUFlLEVBQ2YsU0FBUyxFQUNULHVCQUF1QixFQUFFLGlCQUFpQixFQUMxQyxRQUFRLEVBQ1QsTUFBTSxlQUFlLENBQUM7QUFFdkIsT0FBTyxFQUFFLDZCQUE2QixFQUFFLE1BQU0saUNBQWlDLENBQUM7QUFDaEYsT0FBTyxFQUFFLG9CQUFvQixFQUFFLE1BQU0sNkJBQTZCLENBQUM7QUFDbkUsT0FBTyxFQUFFLFVBQVUsRUFBZ0IsTUFBTSxNQUFNLENBQUM7Ozs7OztJQU01Qyw0QkFBNEIsR0FBRyxDQUFDOzs7O0FBR3BDLE1BQU0sT0FBTywyQkFBMkI7Ozs7O0lBQ3RDLFlBRVMsTUFBK0IsRUFFL0IsTUFBcUM7UUFGckMsV0FBTSxHQUFOLE1BQU0sQ0FBeUI7UUFFL0IsV0FBTSxHQUFOLE1BQU0sQ0FBK0I7SUFDeEMsQ0FBQztDQUNSOzs7Ozs7SUFKRyw2Q0FBc0M7Ozs7O0lBRXRDLDZDQUE0Qzs7QUFjaEQsTUFBTSxPQUFPLHVCQUF1Qjs7Ozs7O0lBeUdsQyxZQUNVLGtCQUFxQyxFQUNyQyxXQUF1QixFQUNYLGtCQUF3QztRQUZwRCx1QkFBa0IsR0FBbEIsa0JBQWtCLENBQW1CO1FBQ3JDLGdCQUFXLEdBQVgsV0FBVyxDQUFZO1FBQ1gsdUJBQWtCLEdBQWxCLGtCQUFrQixDQUFzQjs7OztRQXRHOUQsY0FBUyxHQUFZLEtBQUssQ0FBQztRQUkzQixZ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QUFDO0lBQ3hELENBQUM7OztZQXBLRixTQUFTLFNBQUM7Z0JBQ1QsUUFBUSxFQUFFLGlCQUFpQjtnQkFDM0IsK2ZBQTBDO2dCQUUxQyxlQUFlLEVBQUUsdUJBQXVCLENBQUMsTUFBTTtnQkFDL0MsUUFBUSxFQUFFLGdCQUFnQjtnQkFDMUIsSUFBSSxFQUFFO29CQUNKLE9BQU8sRUFBRSxpQkFBaUI7aUJBQzNCOzthQUNGOzs7O1lBakMwQixpQkFBaUI7WUFUMUMsVUFBVTtZQWNILG9CQUFvQix1QkF5SXhCLFFBQVE7Ozt1QkEvRlYsU0FBUyxTQUFDLFdBQVcsRUFBRSxFQUFFLE1BQU0sRUFBRSxLQUFLLEVBQUU7b0JBTXhDLFNBQVMsU0FBQyxPQUFPLEVBQUUsRUFBRSxNQUFNLEVBQUUsS0FBSyxFQUFFO29CQUdwQyxLQUFLOzZCQXFDTCxNQUFNO3FCQUlOLE1BQU07cUJBR04sTUFBTTt3QkFHTixZQUFZLFNBQUMsNkJBQTZCO3dCQUkxQyxlQUFlLFNBQUMsNkJBQTZCLEVBQUUsRUFBRSxXQUFXLEVBQUUsSUFBSSxFQUFDO3dCQVluRSxLQUFLLFNBQUMsT0FBTzs2QkFpQmIsS0FBSyxTQUFDLGtCQUFrQjs7Ozs7OztJQW5HekIsOENBQXVFOzs7OztJQUd2RSw0Q0FBMkI7O0lBSTNCLDBDQUF5Qjs7Ozs7SUFHekIsMkNBQXNFOzs7Ozs7SUFNdEUsd0NBQXlEOzs7OztJQTJCekQseUNBQXFDOzs7OztJQUNyQyxxREFBeUM7Ozs7O0lBU3pDLDRDQUEwQjs7Ozs7SUFHMUIsaURBQ29EOzs7OztJQUdwRCx5Q0FBeUU7Ozs7O0lBR3pFLHlDQUF5RTs7Ozs7O0lBR3pFLDRDQUM0RDs7Ozs7O0lBRzVELDRDQUM0RDs7SUFrQjVELDZDQUEwQzs7Ozs7SUFHMUMscUNBQWlFOzs7OztJQU9qRSxpREFDK0Y7Ozs7O0lBRzdGLHFEQUE2Qzs7Ozs7SUFDN0MsOENBQStCOzs7OztJQUMvQixxREFBNEQiLCJzb3VyY2VzQ29udGVudCI6WyJcbmltcG9ydCB7IEFjdGl2ZURlc2NlbmRhbnRLZXlNYW5hZ2VyIH0gZnJvbSAnQGFuZ3VsYXIvY2RrL2ExMXknO1xuaW1wb3J0IHtcbiAgQWZ0ZXJWaWV3SW5pdCxcbiAgQ29tcG9uZW50LFxuICBFbGVtZW50UmVmLFxuICBFdmVudEVtaXR0ZXIsXG4gIElucHV0LFxuICBPdXRwdXQsXG4gIFRlbXBsYXRlUmVmLFxuICBWaWV3Q2hpbGQsXG4gIFZpZXdDaGlsZHJlbixcbiAgQ29udGVudENoaWxkcmVuLFxuICBRdWVyeUxpc3QsXG4gIENoYW5nZURldGVjdGlvblN0cmF0ZWd5LCBDaGFuZ2VEZXRlY3RvclJlZiwgT25EZXN0cm95LFxuICBPcHRpb25hbFxufSBmcm9tICdAYW5ndWxhci9jb3JlJztcblxuaW1wb3J0IHsgTnhBdXRvY29tcGxldGVPcHRpb25Db21wb25lbnQgfSBmcm9tICcuL2F1dG9jb21wbGV0ZS1vcHRpb24uY29tcG9uZW50JztcbmltcG9ydCB7IE54Rm9ybWZpZWxkQ29tcG9uZW50IH0gZnJvbSAnQGFsbGlhbnovbmd4LW5kYngvZm9ybWZpZWxkJztcbmltcG9ydCB7IE9ic2VydmFibGUsIFN1YnNjcmlwdGlvbiB9IGZyb20gJ3J4anMnO1xuXG4vKipcbiAqIEF1dG9jb21wbGV0ZSBJRHMgbmVlZCB0byBiZSB1bmlxdWUgYWNyb3NzIGNvbXBvbmVudHMsIHNvIHRoaXMgY291bnRlciBleGlzdHMgb3V0c2lkZSBvZlxuICogdGhlIGNvbXBvbmVudCBkZWZpbml0aW9uLlxuICovXG5sZXQgX3VuaXF1ZUF1dG9jb21wbGV0ZUlkQ291bnRlciA9IDA7XG5cbi8qKiBFdmVudCBvYmplY3QgdGhhdCBpcyBlbWl0dGVkIHdoZW4gYW4gYXV0b2NvbXBsZXRlIG9wdGlvbiBpcyBzZWxlY3RlZC4gKi9cbmV4cG9ydCBjbGFzcyBOeEF1dG9jb21wbGV0ZVNlbGVjdGVkRXZlbnQge1xuICBjb25zdHJ1Y3RvcihcbiAgICAvKiogUmVmZXJlbmNlIHRvIHRoZSBhdXRvY29tcGxldGUgcGFuZWwgdGhhdCBlbWl0dGVkIHRoZSBldmVudC4gKi9cbiAgICBwdWJsaWMgc291cmNlOiBOeEF1dG9jb21wbGV0ZUNvbXBvbmVudCxcbiAgICAvKiogT3B0aW9uIHRoYXQgd2FzIHNlbGVjdGVkLiAqL1xuICAgIHB1YmxpYyBvcHRpb246IE54QXV0b2NvbXBsZXRlT3B0aW9uQ29tcG9uZW50XG4gICAgKSB7IH1cbn1cblxuQENvbXBvbmVudCh7XG4gIHNlbGVjdG9yOiAnbngtYXV0b2NvbXBsZXRlJyxcbiAgdGVtcGxhdGVVcmw6ICdhdXRvY29tcGxldGUuY29tcG9uZW50Lmh0bWwnLFxuICBzdHlsZVVybHM6IFsnYXV0b2NvbXBsZXRlLmNvbXBvbmVudC5zY3NzJ10sXG4gIGNoYW5nZURldGVjdGlvbjogQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuT25QdXNoLFxuICBleHBvcnRBczogJ254QXV0b2NvbXBsZXRlJyxcbiAgaG9zdDoge1xuICAgICdjbGFzcyc6ICdueC1hdXRvY29tcGxldGUnXG4gIH1cbn0pXG5leHBvcnQgY2xhc3MgTnhBdXRvY29tcGxldGVDb21wb25lbnQgaW1wbGVtZW50cyBBZnRlclZpZXdJbml0LCBPbkRlc3Ryb3kge1xuXG4gIC8qKiBNYW5hZ2VzIGFjdGl2ZSBpdGVtIGluIG9wdGlvbiBsaXN0IGJhc2VkIG9uIGtleSBldmVudHMuICovXG4gIF9rZXlNYW5hZ2VyOiBBY3RpdmVEZXNjZW5kYW50S2V5TWFuYWdlcjxOeEF1dG9jb21wbGV0ZU9wdGlvbkNvbXBvbmVudD47XG5cbiAgLyoqIFdoZXRoZXIgdGhlIGF1dG9jb21wbGV0ZSBwYW5lbCBzaG91bGQgYmUgdmlzaWJsZSwgZGVwZW5kaW5nIG9uIG9wdGlvbiBsZW5ndGguICovXG4gIHNob3dQYW5lbDogYm9vbGVhbiA9IGZhbHNlO1xuXG4gIC8qKiBXaGV0aGVyIHRoZSBhdXRvY29tcGxldGUgcGFuZWwgaXMgb3Blbi4gKi9cbiAgZ2V0IGlzT3BlbigpOiBib29sZWFuIHsgcmV0dXJuIHRoaXMuX2lzT3BlbiAmJiB0aGlzLnNob3dQYW5lbDsgfVxuICBfaXNPcGVuOiBib29sZWFuID0gZmFsc2U7XG5cbiAgLyoqIEBkb2NzLXByaXZhdGUgKi9cbiAgQFZpZXdDaGlsZChUZW1wbGF0ZVJlZiwgeyBzdGF0aWM6IGZhbHNlIH0pIHRlbXBsYXRlOiBUZW1wbGF0ZVJlZjxhbnk+O1xuXG4gIC8qKlxuICAgKiBAZG9jcy1wcml2YXRlXG4gICAqIEVsZW1lbnQgZm9yIHRoZSBwYW5lbCBjb250YWluaW5nIHRoZSBhdXRvY29tcGxldGUgb3B0aW9ucy5cbiAgICovXG4gIEBWaWV3Q2hpbGQoJ3BhbmVsJywgeyBzdGF0aWM6IGZhbHNlIH0pIHBhbmVsOiBFbGVtZW50UmVmO1xuXG4gIC8qKiBJdGVtcyBvYnNlcnZhYmxlLiBJZiBnaXZlbiwgYXV0b2NvbXBsZXRlIHRha2VzIGNhcmUgb2YgdGhlIG9wdGlvbnMgYW5kIG5nLWNvbnRlbnQgaXMgZGlzY2FyZGVyZCAqL1xuICBASW5wdXQoKVxuICBzZXQgaXRlbXModmFsOiBBcnJheTxzdHJpbmc+IHwgT2JzZXJ2YWJsZTxBcnJheTxzdHJpbmc+Pikge1xuICAgIHRoaXMuX2hhc0l0ZW1zID0gdHJ1ZTtcbiAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWwpKSB7XG4gICAgICB0aGlzLl9pdGVtcyA9IHZhbDtcbiAgICB9IGVsc2UgaWYgKHZhbCBpbnN0YW5jZW9mIE9ic2VydmFibGUpIHtcbiAgICAgIGlmICh0aGlzLl9pdGVtc1N1YnNjcmlwdGlvbikge1xuICAgICAgICB0aGlzLl9pdGVtc1N1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xuICAgICAgfVxuICAgICAgdGhpcy5faXRlbXNTdWJzY3JpcHRpb24gPSB2YWwuc3Vic2NyaWJlKChpdG1zKSA9PiB7XG4gICAgICAgIHRoaXMuX2l0ZW1zID0gaXRtcztcbiAgICAgICAgdGhpcy5fY2hhbmdlRGV0ZWN0b3JSZWYubWFya0ZvckNoZWNrKCk7XG4gICAgICAgIC8vIGFuZCBjaGVjayB2aXNpYmlsaXR5IGluIG5leHQgY3ljbGUsIHdoZW4gb3B0aW9ucyBhcmUgc2V0XG4gICAgICAgIHNldFRpbWVvdXQoKCkgPT4gdGhpcy5fc2V0VmlzaWJpbGl0eSgpKTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSBpZiAodmFsID09PSBudWxsKSB7XG4gICAgICB0aGlzLl9pdGVtcyA9IHZhbDtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGFyZ3VtZW50IGZvciBhdXRvY29tcGxldGUgaXRlbXMuIEl0IGhhcyB0byBiZSBBcnJheTxzdHJpbmc+IG9yIE9ic2VydmFibGU8QXJyYXk8c3RyaW5nPj4nKTtcbiAgICB9XG4gIH1cbiAgZ2V0IGl0ZW1zKCk6IEFycmF5PHN0cmluZz4gfCBPYnNlcnZhYmxlPEFycmF5PHN0cmluZz4+IHtcbiAgICByZXR1cm4gdGhpcy5faXRlbXM7XG4gIH1cbiAgcHJpdmF0ZSBfaXRlbXM6IEFycmF5PHN0cmluZz4gPSBudWxsO1xuICBwcml2YXRlIF9pdGVtc1N1YnNjcmlwdGlvbjogU3Vic2NyaXB0aW9uO1xuXG4gIC8qKlxuICAgKiBAZG9jcy1wcml2YXRlXG4gICAqIElzIGl0ZW1zIG9ic2VydmFibGUgc2V0XG4gICAqL1xuICBwdWJsaWMgZ2V0IGhhc0l0ZW1zKCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0aGlzLl9oYXNJdGVtcztcbiAgfVxuICBwcml2YXRlIF9oYXNJdGVtcyA9IGZhbHNlO1xuXG4gIC8qKiBFdmVudCB0aGF0IGlzIGVtaXR0ZWQgd2hlbmV2ZXIgYW4gb3B0aW9uIGZyb20gdGhlIGxpc3QgaXMgc2VsZWN0ZWQuICovXG4gIEBPdXRwdXQoKSByZWFkb25seSBvcHRpb25TZWxlY3RlZDogRXZlbnRFbWl0dGVyPE54QXV0b2NvbXBsZXRlU2VsZWN0ZWRFdmVudD4gPVxuICAgICAgbmV3IEV2ZW50RW1pdHRlcjxOeEF1dG9jb21wbGV0ZVNlbGVjdGVkRXZlbnQ+KCk7XG5cbiAgLyoqIEV2ZW50IHRoYXQgaXMgZW1pdHRlZCB3aGVuIHRoZSBhdXRvY29tcGxldGUgcGFuZWwgaXMgb3BlbmVkLiAqL1xuICBAT3V0cHV0KCkgcmVhZG9ubHkgb3BlbmVkOiBFdmVudEVtaXR0ZXI8dm9pZD4gPSBuZXcgRXZlbnRFbWl0dGVyPHZvaWQ+KCk7XG5cbiAgLyoqIEV2ZW50IHRoYXQgaXMgZW1pdHRlZCB3aGVuIHRoZSBhdXRvY29tcGxldGUgcGFuZWwgaXMgY2xvc2VkLiAqL1xuICBAT3V0cHV0KCkgcmVhZG9ubHkgY2xvc2VkOiBFdmVudEVtaXR0ZXI8dm9pZD4gPSBuZXcgRXZlbnRFbWl0dGVyPHZvaWQ+KCk7XG5cbiAgLyoqIEF1dG9jb21wbGV0ZSBvcHRpb25zIGluIHZpZXcgLSBpZSBmcm9tIGl0ZW1zICovXG4gIEBWaWV3Q2hpbGRyZW4oTnhBdXRvY29tcGxldGVPcHRpb25Db21wb25lbnQpXG4gIHByaXZhdGUgX3ZPcHRpb25zOiBRdWVyeUxpc3Q8TnhBdXRvY29tcGxldGVPcHRpb25Db21wb25lbnQ+O1xuXG4gIC8qKiBBdXRvY29tcGxldGUgb3B0aW9ucyBpbiBjb250ZW50IC0gaWUgdXNlciBwcm92aWRlZCAqL1xuICBAQ29udGVudENoaWxkcmVuKE54QXV0b2NvbXBsZXRlT3B0aW9uQ29tcG9uZW50LCB7IGRlc2NlbmRhbnRzOiB0cnVlfSlcbiAgcHJpdmF0ZSBfY09wdGlvbnM6IFF1ZXJ5TGlzdDxOeEF1dG9jb21wbGV0ZU9wdGlvbkNvbXBvbmVudD47XG5cbiAgLyoqIEF1dG9jb21wbGV0ZSBvcHRpb25zICovXG4gIHB1YmxpYyBnZXQgb3B0aW9ucygpOiBRdWVyeUxpc3Q8TnhBdXRvY29tcGxldGVPcHRpb25Db21wb25lbnQ+IHtcbiAgICByZXR1cm4gdGhpcy5oYXNJdGVtcyA/IHRoaXMuX3ZPcHRpb25zIDogdGhpcy5fY09wdGlvbnM7XG4gIH1cblxuICAvKipcbiAgICogVGFrZXMgY2xhc3NlcyBzZXQgb24gdGhlIGhvc3QgbngtYXV0b2NvbXBsZXRlIGVsZW1lbnQgYW5kIGFwcGxpZXMgdGhlbSB0byB0aGUgcGFuZWxcbiAgICogaW5zaWRlIHRoZSBvdmVybGF5IGNvbnRhaW5lciB0byBhbGxvdyBmb3IgZWFzeSBzdHlsaW5nLlxuICAgKi9cbiAgQElucHV0KCdjbGFzcycpXG4gIHNldCBjbGFzc0xpc3QodmFsdWU6IHN0cmluZykge1xuICAgIGlmICh2YWx1ZSAmJiB2YWx1ZS5sZW5ndGgpIHtcbiAgICAgIHZhbHVlLnNwbGl0KCcgJykuZm9yRWFjaChjbGFzc05hbWUgPT4gdGhpcy5fY2xhc3NMaXN0W2NsYXNzTmFtZS50cmltKCldID0gdHJ1ZSk7XG4gICAgICB0aGlzLl9lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQuY2xhc3NOYW1lID0gJyc7XG4gICAgfVxuICB9XG4gIF9jbGFzc0xpc3Q6IHtba2V5OiBzdHJpbmddOiBib29sZWFufSA9IHt9O1xuXG4gIC8qKiBVbmlxdWUgSUQgdG8gYmUgdXNlZCBieSBhdXRvY29tcGxldGUgdHJpZ2dlcidzIFwiYXJpYS1vd25zXCIgcHJvcGVydHkuICovXG4gIGlkOiBzdHJpbmcgPSBgbngtYXV0b2NvbXBsZXRlLSR7X3VuaXF1ZUF1dG9jb21wbGV0ZUlkQ291bnRlcisrfWA7XG5cbiAgLy8gQXMgYXV0b2NvbXBsZXRlIG9wdGlvbiBjYW4gaG9sZCBhbnkgdmFsdWUsIHdlIG1pZ2h0IG5lZWQgYSBjb252ZXJ0ZXJcbiAgLy8gdG8gZ2V0IGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uLCB3aGljaCBjYW4gYmUgc3RvcmVkIGluIGlucHV0LiBEZWZhdWx0IHZhbHVlID8gdmFsdWUudG9TdHJpbmcoKSA6IG51bGwuXG4gIC8qKlxuICAgKiBWYWx1ZSB0byBzdHJpbmcgY29udmVydGVyLlxuICAgKi9cbiAgQElucHV0KCdueFZhbHVlRm9ybWF0dGVyJylcbiAgcHVibGljIHZhbHVlRm9ybWF0dGVyOiAodmFsdWU6IGFueSkgPT4gc3RyaW5nID0gKHZhbHVlOiBhbnkpID0+IHZhbHVlID8gdmFsdWUudG9TdHJpbmcoKSA6IG51bGxcblxuICBjb25zdHJ1Y3RvcihcbiAgICBwcml2YXRlIF9jaGFuZ2VEZXRlY3RvclJlZjogQ2hhbmdlRGV0ZWN0b3JSZWYsXG4gICAgcHJpdmF0ZSBfZWxlbWVudFJlZjogRWxlbWVudFJlZixcbiAgICBAT3B0aW9uYWwoKSBwcml2YXRlIGZvcm1GaWVsZENvbXBvbmVudDogTnhGb3JtZmllbGRDb21wb25lbnQpIHtcbiAgfVxuXG4gIG5nQWZ0ZXJWaWV3SW5pdCgpOiB2b2lkIHtcbiAgICB0aGlzLl9rZXlNYW5hZ2VyID0gbmV3IEFjdGl2ZURlc2NlbmRhbnRLZXlNYW5hZ2VyPE54QXV0b2NvbXBsZXRlT3B0aW9uQ29tcG9uZW50Pih0aGlzLm9wdGlvbnMpLndpdGhXcmFwKCk7XG4gICAgdGhpcy5fc2V0VmlzaWJpbGl0eSgpO1xuICB9XG5cbiAgbmdPbkRlc3Ryb3koKTogdm9pZCB7XG4gICAgaWYgKHRoaXMuX2l0ZW1zU3Vic2NyaXB0aW9uKSB7XG4gICAgICB0aGlzLl9pdGVtc1N1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIHRoZSBwYW5lbCBzY3JvbGxUb3AuIFRoaXMgYWxsb3dzIHVzIHRvIG1hbnVhbGx5IHNjcm9sbCB0byBkaXNwbGF5IG9wdGlvbnNcbiAgICogYWJvdmUgb3IgYmVsb3cgdGhlIGZvbGQsIGFzIHRoZXkgYXJlIG5vdCBhY3R1YWxseSBiZWluZyBmb2N1c2VkIHdoZW4gYWN0aXZlLlxuICAgKi9cbiAgX3NldFNjcm9sbFRvcChzY3JvbGxUb3A6IG51bWJlcik6IHZvaWQge1xuICAgIGlmICh0aGlzLnBhbmVsKSB7XG4gICAgICB0aGlzLnBhbmVsLm5hdGl2ZUVsZW1lbnQuc2Nyb2xsVG9wID0gc2Nyb2xsVG9wO1xuICAgIH1cbiAgfVxuXG4gIC8qKiBSZXR1cm5zIHRoZSBwYW5lbCdzIHNjcm9sbFRvcC4gKi9cbiAgX2dldFNjcm9sbFRvcCgpOiBudW1iZXIge1xuICAgIHJldHVybiB0aGlzLnBhbmVsID8gdGhpcy5wYW5lbC5uYXRpdmVFbGVtZW50LnNjcm9sbFRvcCA6IDA7XG4gIH1cblxuICAvKiogUGFuZWwgc2hvdWxkIGhpZGUgaXRzZWxmIHdoZW4gdGhlIG9wdGlvbiBsaXN0IGlzIGVtcHR5LiAqL1xuICBfc2V0VmlzaWJpbGl0eSgpIHtcbiAgICB0aGlzLnNob3dQYW5lbCA9ICEhKHRoaXMub3B0aW9ucyAmJiB0aGlzLm9wdGlvbnMubGVuZ3RoKTtcbiAgICB0aGlzLl9jbGFzc0xpc3RbJ254LWF1dG9jb21wbGV0ZS12aXNpYmxlJ10gPSB0aGlzLnNob3dQYW5lbDtcbiAgICB0aGlzLl9jbGFzc0xpc3RbJ254LWF1dG9jb21wbGV0ZS1oaWRkZW4nXSA9ICF0aGlzLnNob3dQYW5lbDtcbiAgICB0aGlzLl9jaGFuZ2VEZXRlY3RvclJlZi5tYXJrRm9yQ2hlY2soKTtcbiAgfVxuXG4gIC8qKiBFbWl0cyB0aGUgYHNlbGVjdGAgZXZlbnQuICovXG4gIF9lbWl0U2VsZWN0RXZlbnQob3B0aW9uOiBOeEF1dG9jb21wbGV0ZU9wdGlvbkNvbXBvbmVudCk6IHZvaWQge1xuICAgIGNvbnN0IGV2ZW50ID0gbmV3IE54QXV0b2NvbXBsZXRlU2VsZWN0ZWRFdmVudCh0aGlzLCBvcHRpb24pO1xuICAgIHRoaXMub3B0aW9uU2VsZWN0ZWQuZW1pdChldmVudCk7XG4gIH1cblxuICBnZXQgX2lzSW5PdXRsaW5lRmllbGQoKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRoaXMuZm9ybUZpZWxkQ29tcG9uZW50ICE9PSBudWxsXG4gICAgICAmJiB0aGlzLmZvcm1GaWVsZENvbXBvbmVudC5hcHBlYXJhbmNlID09PSAnb3V0bGluZSc7XG4gIH1cbn1cbiJdfQ==