/**
 * @fileoverview added by tsickle
 * Generated from: context-menu-trigger.directive.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import { Directionality } from '@angular/cdk/bidi';
import { LEFT_ARROW, RIGHT_ARROW } from '@angular/cdk/keycodes';
import { Overlay, OverlayConfig } from '@angular/cdk/overlay';
import { TemplatePortal } from '@angular/cdk/portal';
import { Directive, ElementRef, EventEmitter, Input, Optional, Output, Self, ViewContainerRef } from '@angular/core';
import { normalizePassiveListenerOptions } from '@angular/cdk/platform';
import { asapScheduler, merge, of as observableOf, Subscription, fromEvent } from 'rxjs';
import { delay, filter, take, takeUntil, map } from 'rxjs/operators';
import { NxContextMenuComponent } from './context-menu.component';
import { throwNxContextMenuMissingError } from './context-menu-errors';
import { NxContextMenuItemComponent } from './context-menu-item.component';
/**
 * Default top padding of the menu panel.
 * @type {?}
 */
export const MENU_PANEL_TOP_PADDING = 16;
/** @type {?} */
export const MENU_PANEL_OFFSET = 8;
/**
 * Options for binding a passive event listener.
 * @type {?}
 */
const passiveEventListenerOptions = normalizePassiveListenerOptions({
    passive: true
});
/**
 * This directive is intended to be used in conjunction with an nx-context-menu tag.
 * It is responsible for toggling the display of the provided context menu instance.
 */
export class NxContextMenuTriggerDirective {
    /**
     * @param {?} _overlay
     * @param {?} _element
     * @param {?} _viewContainerRef
     * @param {?} _parentMenu
     * @param {?} _contextMenuItemInstance
     * @param {?} _dir
     */
    constructor(_overlay, _element, _viewContainerRef, _parentMenu, _contextMenuItemInstance, _dir) {
        this._overlay = _overlay;
        this._element = _element;
        this._viewContainerRef = _viewContainerRef;
        this._parentMenu = _parentMenu;
        this._contextMenuItemInstance = _contextMenuItemInstance;
        this._dir = _dir;
        this._overlayRef = null;
        this._contextMenuOpen = false;
        this._closingActionsSubscription = Subscription.EMPTY;
        this._hoverSubscription = Subscription.EMPTY;
        this._contextMenuCloseSubscription = Subscription.EMPTY;
        /**
         * Event emitted when the associated context menu is opened.
         */
        this.contextMenuOpened = new EventEmitter();
        /**
         * Event emitted when the associated context menu is closed.
         */
        this.contextMenuClosed = new EventEmitter();
        if (_contextMenuItemInstance) {
            _contextMenuItemInstance._triggersSubmenu = this.triggersSubmenu();
        }
        this._scrollStrategy = this._overlay.scrollStrategies.reposition;
        this._documentClickObservable = fromEvent(document, 'click');
    }
    /**
     * References the context menu instance that the trigger is associated with.
     * @return {?}
     */
    get contextMenu() {
        return this._contextMenu;
    }
    /**
     * @param {?} contextMenu
     * @return {?}
     */
    set contextMenu(contextMenu) {
        if (contextMenu === this._contextMenu) {
            return;
        }
        this._contextMenu = contextMenu;
        this._contextMenuCloseSubscription.unsubscribe();
        if (contextMenu) {
            this._contextMenuCloseSubscription = contextMenu.closed
                .asObservable()
                .subscribe((/**
             * @param {?} reason
             * @return {?}
             */
            reason => {
                this._destroyMenu();
                // If a click closed the menu, we should close the entire chain of nested menus.
                if ((reason === 'click' || reason === 'tab') && this._parentMenu) {
                    this._parentMenu.closed.emit(reason);
                }
            }));
        }
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set scrollStrategy(value) {
        if (value === 'close') {
            this._scrollStrategy = this._overlay.scrollStrategies.close;
        }
        else {
            this._scrollStrategy = this._overlay.scrollStrategies.reposition;
        }
    }
    /**
     * Whether the context menu is open.
     * @return {?}
     */
    get contextMenuOpen() {
        return this._contextMenuOpen;
    }
    /**
     * The text direction of the containing app.
     * @private
     * @return {?}
     */
    get dir() {
        return this._dir && this._dir.value === 'rtl' ? 'rtl' : 'ltr';
    }
    /**
     * @return {?}
     */
    ngAfterContentInit() {
        this._checkContextMenu();
        this._handleHover();
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        if (this._overlayRef) {
            this._overlayRef.dispose();
            this._overlayRef = null;
        }
        this._contextMenuCloseSubscription.unsubscribe();
        this._closingActionsSubscription.unsubscribe();
        this._hoverSubscription.unsubscribe();
    }
    /**
     * Whether the context menu triggers a sub-menu or a top-level one.
     * @return {?}
     */
    triggersSubmenu() {
        return !!(this._contextMenuItemInstance && this._parentMenu);
    }
    /**
     * Toggles the context menu between the open and closed states.
     * @return {?}
     */
    toggleContextMenu() {
        return this.contextMenuOpen
            ? this.closeContextMenu()
            : this.openContextMenu();
    }
    /**
     * Opens the context menu.
     * @return {?}
     */
    openContextMenu() {
        if (this.contextMenuOpen) {
            return;
        }
        this._checkContextMenu();
        /** @type {?} */
        const overlayRef = this._createOverlay();
        /** @type {?} */
        const overlayConfig = overlayRef.getConfig();
        this._setPosition((/** @type {?} */ (overlayConfig.positionStrategy)));
        overlayRef.attach(this._getPortal());
        if (this.contextMenu.lazyContent) {
            this.contextMenu.lazyContent.attach(this.contextMenuData);
        }
        this._closingActionsSubscription = this._contextMenuClosingActions().subscribe((/**
         * @return {?}
         */
        () => this.closeContextMenu()));
        this._initContextMenu();
        if (this.contextMenu instanceof NxContextMenuComponent) {
            this.contextMenu._startAnimation();
        }
        this._waitForClose();
    }
    /**
     * Closes the context menu.
     * @return {?}
     */
    closeContextMenu() {
        this.contextMenu.closed.emit();
    }
    /**
     * Closes the context menu and does the necessary cleanup.
     * @private
     * @return {?}
     */
    _destroyMenu() {
        if (!this._overlayRef || !this.contextMenuOpen) {
            return;
        }
        /** @type {?} */
        const contextMenu = this.contextMenu;
        this._closingActionsSubscription.unsubscribe();
        this._overlayRef.detach();
        contextMenu._resetAnimation();
        if (contextMenu.lazyContent) {
            // Wait for the exit animation to finish before detaching the content.
            contextMenu._animationDone
                .pipe(filter((/**
             * @param {?} event
             * @return {?}
             */
            event => event.toState === 'void')), take(1), 
            // Interrupt if the content got re-attached.
            takeUntil(contextMenu.lazyContent._attached))
                .subscribe({
                next: (/**
                 * @return {?}
                 */
                () => contextMenu.lazyContent && contextMenu.lazyContent.detach()),
                // No matter whether the content got re-attached, reset the menu.
                complete: (/**
                 * @return {?}
                 */
                () => this._resetContextMenu())
            });
        }
        else {
            this._resetContextMenu();
        }
    }
    /**
     * This method sets the context menu state to open and focuses the first item if
     * the context menu was opened via the keyboard.
     * @private
     * @return {?}
     */
    _initContextMenu() {
        this.contextMenu.parentMenu = this.triggersSubmenu()
            ? this._parentMenu
            : undefined;
        this.contextMenu.direction = this.dir;
        this._setIsContextMenuOpen(true);
        this.contextMenu.focusFirstItem();
    }
    /**
     * Focuses the context menu trigger.
     * @return {?}
     */
    focus() {
        this._element.nativeElement.focus();
    }
    /**
     * This method resets the context menu when it's closed, most importantly restoring
     * focus to the context menu trigger if the context menu was opened via the keyboard.
     * @private
     * @return {?}
     */
    _resetContextMenu() {
        this._setIsContextMenuOpen(false);
        this.focus();
    }
    /**
     * Set state rather than toggle to support triggers sharing a menu.
     * @private
     * @param {?} isOpen
     * @return {?}
     */
    _setIsContextMenuOpen(isOpen) {
        this._contextMenuOpen = isOpen;
        this._contextMenuOpen
            ? this.contextMenuOpened.emit()
            : this.contextMenuClosed.emit();
        if (this.triggersSubmenu()) {
            this._contextMenuItemInstance._highlighted = isOpen;
        }
    }
    /**
     * This method checks that a valid instance of NxContextMenuComponent has been passed into
     * nxContextMenuTriggerFor. If not, an exception is thrown.
     * @private
     * @return {?}
     */
    _checkContextMenu() {
        if (!this.contextMenu) {
            throwNxContextMenuMissingError();
        }
    }
    /**
     * This method creates the overlay from the provided menu's template and saves its
     * OverlayRef so that it can be attached to the DOM when openContextMenu is called.
     * @private
     * @return {?}
     */
    _createOverlay() {
        if (!this._overlayRef) {
            /** @type {?} */
            const config = this._getOverlayConfig();
            this._overlayRef = this._overlay.create(config);
            // Consume the `keydownEvents` in order to prevent them from going to another overlay.
            this._overlayRef.keydownEvents().subscribe();
        }
        return this._overlayRef;
    }
    /**
     * This method builds the configuration object needed to create the overlay, the OverlayState.
     * @private
     * @return {?} OverlayConfig
     */
    _getOverlayConfig() {
        return new OverlayConfig({
            positionStrategy: this._overlay
                .position()
                .flexibleConnectedTo(this._element)
                .withLockedPosition()
                .withFlexibleDimensions(false)
                .withTransformOriginOn('.nx-context-menu'),
            scrollStrategy: this._scrollStrategy(),
            direction: this._dir
        });
    }
    /**
     * Sets the appropriate positions on a position strategy
     * so the overlay connects with the trigger correctly.
     * @private
     * @param {?} positionStrategy Strategy whose position to update.
     * @return {?}
     */
    _setPosition(positionStrategy) {
        /** @type {?} */
        let originX = 'start';
        /** @type {?} */
        let originFallbackX = 'end';
        /** @type {?} */
        const overlayY = 'top';
        /** @type {?} */
        const overlayFallbackY = 'bottom';
        /** @type {?} */
        let originY = overlayY;
        /** @type {?} */
        let originFallbackY = overlayFallbackY;
        /** @type {?} */
        let overlayX = originX;
        /** @type {?} */
        let overlayFallbackX = originFallbackX;
        /** @type {?} */
        let offsetY = 0;
        if (this.triggersSubmenu()) {
            // When the menu is a sub-menu, it should always align itself
            // to the edges of the trigger, instead of overlapping it.
            overlayFallbackX = originX = 'end';
            originFallbackX = overlayX = 'start';
            offsetY = -MENU_PANEL_TOP_PADDING;
        }
        else {
            offsetY = MENU_PANEL_OFFSET;
            originY = 'bottom';
            originFallbackY = 'top';
        }
        positionStrategy.withPositions((/** @type {?} */ ([
            { originX, originY, overlayX, overlayY, offsetY },
            {
                originX: originFallbackX,
                originY,
                overlayX: overlayFallbackX,
                overlayY,
                offsetY
            },
            {
                originX,
                originY: originFallbackY,
                overlayX,
                overlayY: overlayFallbackY,
                offsetY: -offsetY
            },
            {
                originX: originFallbackX,
                originY: originFallbackY,
                overlayX: overlayFallbackX,
                overlayY: overlayFallbackY,
                offsetY: -offsetY
            }
        ])));
    }
    /**
     * Returns a stream that emits whenever an action that should close the context menu occurs.
     * @private
     * @return {?}
     */
    _contextMenuClosingActions() {
        /** @type {?} */
        let backdrop;
        /** @type {?} */
        let detachments;
        if (this._overlayRef) {
            backdrop = this._overlayRef.backdropClick();
            detachments = this._overlayRef.detachments();
        }
        /** @type {?} */
        const parentClose = this._parentMenu
            ? this._parentMenu.closed
            : observableOf();
        /** @type {?} */
        const hover = this._parentMenu
            ? this._parentMenu._hovered().pipe(filter((/**
             * @param {?} active
             * @return {?}
             */
            active => active !== this._contextMenuItemInstance)), filter((/**
             * @return {?}
             */
            () => this._contextMenuOpen)))
            : observableOf();
        return merge(backdrop, parentClose, hover, detachments);
    }
    /**
     * Handles mouse presses on the trigger.
     * @param {?} event
     * @return {?}
     */
    _handleMousedown(event) {
        // Since right or middle button clicks won't trigger the `click` event,
        // we shouldn't consider the menu as opened by mouse in those cases.
        // this._openedBy = event.button === 0 ? 'mouse' : null;
        // Since clicking on the trigger won't close the menu if it opens a sub-menu,
        // we should prevent focus from moving onto it via click to avoid the
        // highlight from lingering on the menu item.
        if (this.triggersSubmenu()) {
            event.preventDefault();
        }
    }
    /**
     * Handles key presses on the trigger.
     * @param {?} event
     * @return {?}
     */
    _handleKeydown(event) {
        /** @type {?} */
        const keyCode = event.keyCode;
        if (this.triggersSubmenu() &&
            ((keyCode === RIGHT_ARROW && this.dir === 'ltr') ||
                (keyCode === LEFT_ARROW && this.dir === 'rtl'))) {
            this.openContextMenu();
        }
    }
    /**
     * Handles click events on the trigger.
     * @param {?} event
     * @return {?}
     */
    _handleClick(event) {
        if (this.triggersSubmenu()) {
            // Stop event propagation to avoid closing the parent menu.
            event.stopPropagation();
            this.openContextMenu();
        }
        else {
            this.toggleContextMenu();
        }
    }
    /* Subscribes to document clicks to close the context menu on clicks on the background. */
    /**
     * @private
     * @return {?}
     */
    _waitForClose() {
        return this._documentClickObservable
            .pipe(map((/**
         * @param {?} event
         * @return {?}
         */
        event => event.target)), filter((/**
         * @param {?} target
         * @return {?}
         */
        (target) => !this._element.nativeElement.contains(target))), takeUntil(this.contextMenu.closed))
            .subscribe((/**
         * @return {?}
         */
        () => {
            this.closeContextMenu();
        }));
    }
    /**
     * Handles the cases where the user hovers over the trigger.
     * @private
     * @return {?}
     */
    _handleHover() {
        // Subscribe to changes in the hovered item in order to toggle the panel.
        if (!this.triggersSubmenu()) {
            return;
        }
        this._hoverSubscription = this._parentMenu
            ._hovered()
            // Since we might have multiple competing triggers for the same menu (e.g. a sub-menu
            // with different data and triggers), we have to delay it by a tick to ensure that
            // it won't be closed immediately after it is opened.
            .pipe(filter((/**
         * @param {?} active
         * @return {?}
         */
        active => active === this._contextMenuItemInstance && !active.disabled)), delay(0, asapScheduler))
            .subscribe((/**
         * @return {?}
         */
        () => {
            // If the same menu is used between multiple triggers, it might still be animating
            // while the new trigger tries to re-open it. Wait for the animation to finish
            // before doing so. Also interrupt if the user moves to another item.
            if (this.contextMenu._isAnimating) {
                // We need the `delay(0)` here in order to avoid
                // 'changed after checked' errors in some cases.
                this.contextMenu._animationDone
                    .pipe(take(1), delay(0, asapScheduler), takeUntil(this._parentMenu._hovered()))
                    .subscribe((/**
                 * @return {?}
                 */
                () => this.openContextMenu()));
            }
            else {
                this.openContextMenu();
            }
        }));
    }
    /**
     * Gets the portal that should be attached to the overlay.
     * @private
     * @return {?}
     */
    _getPortal() {
        // Note that we can avoid this check by keeping the portal on the context menu panel.
        // While it would be cleaner, we'd have to introduce another required method on
        // `NxContextMenuPanelComponent`, making it harder to consume.
        if (!this._portal ||
            this._portal.templateRef !== this.contextMenu.templateRef) {
            this._portal = new TemplatePortal(this.contextMenu.templateRef, this._viewContainerRef);
        }
        return this._portal;
    }
}
NxContextMenuTriggerDirective.decorators = [
    { type: Directive, args: [{
                selector: `[nxContextMenuTriggerFor]`,
                host: {
                    'aria-haspopup': 'true',
                    '[attr.aria-expanded]': 'contextMenuOpen || null',
                    '(mousedown)': '_handleMousedown($event)',
                    '(keydown)': '_handleKeydown($event)',
                    '(click)': '_handleClick($event)'
                },
                exportAs: 'nxContextMenuTrigger'
            },] }
];
/** @nocollapse */
NxContextMenuTriggerDirective.ctorParameters = () => [
    { type: Overlay },
    { type: ElementRef },
    { type: ViewContainerRef },
    { type: NxContextMenuComponent, decorators: [{ type: Optional }] },
    { type: NxContextMenuItemComponent, decorators: [{ type: Optional }, { type: Self }] },
    { type: Directionality, decorators: [{ type: Optional }] }
];
NxContextMenuTriggerDirective.propDecorators = {
    contextMenu: [{ type: Input, args: ['nxContextMenuTriggerFor',] }],
    scrollStrategy: [{ type: Input }],
    contextMenuData: [{ type: Input, args: ['nxContextMenuTriggerData',] }],
    contextMenuOpened: [{ type: Output }],
    contextMenuClosed: [{ type: Output }]
};
if (false) {
    /**
     * @type {?}
     * @private
     */
    NxContextMenuTriggerDirective.prototype._portal;
    /**
     * @type {?}
     * @private
     */
    NxContextMenuTriggerDirective.prototype._overlayRef;
    /**
     * @type {?}
     * @private
     */
    NxContextMenuTriggerDirective.prototype._contextMenuOpen;
    /**
     * @type {?}
     * @private
     */
    NxContextMenuTriggerDirective.prototype._closingActionsSubscription;
    /**
     * @type {?}
     * @private
     */
    NxContextMenuTriggerDirective.prototype._hoverSubscription;
    /**
     * @type {?}
     * @private
     */
    NxContextMenuTriggerDirective.prototype._contextMenuCloseSubscription;
    /**
     * @type {?}
     * @private
     */
    NxContextMenuTriggerDirective.prototype._documentClickObservable;
    /**
     * @type {?}
     * @private
     */
    NxContextMenuTriggerDirective.prototype._scrollStrategy;
    /**
     * @type {?}
     * @private
     */
    NxContextMenuTriggerDirective.prototype._contextMenu;
    /**
     * Data to be passed along to any lazily-rendered content.
     * @type {?}
     */
    NxContextMenuTriggerDirective.prototype.contextMenuData;
    /**
     * Event emitted when the associated context menu is opened.
     * @type {?}
     */
    NxContextMenuTriggerDirective.prototype.contextMenuOpened;
    /**
     * Event emitted when the associated context menu is closed.
     * @type {?}
     */
    NxContextMenuTriggerDirective.prototype.contextMenuClosed;
    /**
     * @type {?}
     * @private
     */
    NxContextMenuTriggerDirective.prototype._overlay;
    /**
     * @type {?}
     * @private
     */
    NxContextMenuTriggerDirective.prototype._element;
    /**
     * @type {?}
     * @private
     */
    NxContextMenuTriggerDirective.prototype._viewContainerRef;
    /**
     * @type {?}
     * @private
     */
    NxContextMenuTriggerDirective.prototype._parentMenu;
    /**
     * @type {?}
     * @private
     */
    NxContextMenuTriggerDirective.prototype._contextMenuItemInstance;
    /**
     * @type {?}
     * @private
     */
    NxContextMenuTriggerDirective.prototype._dir;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY29udGV4dC1tZW51LXRyaWdnZXIuZGlyZWN0aXZlLmpzIiwic291cmNlUm9vdCI6Im5nOi8vQGFsbGlhbnovbmd4LW5kYngvY29udGV4dC1tZW51LyIsInNvdXJjZXMiOlsiY29udGV4dC1tZW51LXRyaWdnZXIuZGlyZWN0aXZlLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7O0FBQUEsT0FBTyxFQUFhLGNBQWMsRUFBRSxNQUFNLG1CQUFtQixDQUFDO0FBQzlELE9BQU8sRUFBRSxVQUFVLEVBQUUsV0FBVyxFQUFFLE1BQU0sdUJBQXVCLENBQUM7QUFDaEUsT0FBTyxFQUVMLE9BQU8sRUFDUCxhQUFhLEVBSWQsTUFBTSxzQkFBc0IsQ0FBQztBQUM5QixPQUFPLEVBQUUsY0FBYyxFQUFFLE1BQU0scUJBQXFCLENBQUM7QUFDckQsT0FBTyxFQUVMLFNBQVMsRUFDVCxVQUFVLEVBQ1YsWUFBWSxFQUNaLEtBQUssRUFFTCxRQUFRLEVBQ1IsTUFBTSxFQUNOLElBQUksRUFDSixnQkFBZ0IsRUFDakIsTUFBTSxlQUFlLENBQUM7QUFDdkIsT0FBTyxFQUFFLCtCQUErQixFQUFFLE1BQU0sdUJBQXVCLENBQUM7QUFDeEUsT0FBTyxFQUFFLGFBQWEsRUFBRSxLQUFLLEVBQUUsRUFBRSxJQUFJLFlBQVksRUFBRSxZQUFZLEVBQUUsU0FBUyxFQUFjLE1BQU0sTUFBTSxDQUFDO0FBQ3JHLE9BQU8sRUFBRSxLQUFLLEVBQUUsTUFBTSxFQUFFLElBQUksRUFBRSxTQUFTLEVBQUUsR0FBRyxFQUFFLE1BQU0sZ0JBQWdCLENBQUM7QUFDckUsT0FBTyxFQUFFLHNCQUFzQixFQUFFLE1BQU0sMEJBQTBCLENBQUM7QUFDbEUsT0FBTyxFQUFFLDhCQUE4QixFQUFFLE1BQU0sdUJBQXVCLENBQUM7QUFDdkUsT0FBTyxFQUFFLDBCQUEwQixFQUFFLE1BQU0sK0JBQStCLENBQUM7Ozs7O0FBRzNFLE1BQU0sT0FBTyxzQkFBc0IsR0FBRyxFQUFFOztBQUV4QyxNQUFNLE9BQU8saUJB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SUFBSSxFQUFFO29CQUNKLGVBQWUsRUFBRSxNQUFNO29CQUN2QixzQkFBc0IsRUFBRSx5QkFBeUI7b0JBQ2pELGFBQWEsRUFBRSwwQkFBMEI7b0JBQ3pDLFdBQVcsRUFBRSx3QkFBd0I7b0JBQ3JDLFNBQVMsRUFBRSxzQkFBc0I7aUJBQ2xDO2dCQUNELFFBQVEsRUFBRSxzQkFBc0I7YUFDakM7Ozs7WUFwREMsT0FBTztZQVVQLFVBQVU7WUFPVixnQkFBZ0I7WUFLVCxzQkFBc0IsdUJBc0d4QixRQUFRO1lBcEdOLDBCQUEwQix1QkFxRzVCLFFBQVEsWUFDUixJQUFJO1lBbElTLGNBQWMsdUJBb0kzQixRQUFROzs7MEJBL0RaLEtBQUssU0FBQyx5QkFBeUI7NkJBMkIvQixLQUFLOzhCQW9CTCxLQUFLLFNBQUMsMEJBQTBCO2dDQUdoQyxNQUFNO2dDQUdOLE1BQU07Ozs7Ozs7SUEvRFAsZ0RBQWdDOzs7OztJQUNoQyxvREFBOEM7Ozs7O0lBQzlDLHlEQUEwQzs7Ozs7SUFDMUMsb0VBQXlEOzs7OztJQUN6RCwyREFBZ0Q7Ozs7O0lBQ2hELHNFQUEyRDs7Ozs7SUFDM0QsaUVBQXlEOzs7OztJQUN6RCx3REFBOEM7Ozs7O0lBNEI5QyxxREFBNkM7Ozs7O0lBc0I3Qyx3REFBd0Q7Ozs7O0lBR3hELDBEQUFvRjs7Ozs7SUFHcEYsMERBQW9GOzs7OztJQUdoRixpREFBeUI7Ozs7O0lBQ3pCLGlEQUF5Qzs7Ozs7SUFDekMsMERBQTJDOzs7OztJQUMzQyxvREFBdUQ7Ozs7O0lBQ3ZELGlFQUU0RDs7Ozs7SUFDNUQsNkNBQXdDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgRGlyZWN0aW9uLCBEaXJlY3Rpb25hbGl0eSB9IGZyb20gJ0Bhbmd1bGFyL2Nkay9iaWRpJztcbmltcG9ydCB7IExFRlRfQVJST1csIFJJR0hUX0FSUk9XIH0gZnJvbSAnQGFuZ3VsYXIvY2RrL2tleWNvZGVzJztcbmltcG9ydCB7XG4gIEZsZXhpYmxlQ29ubmVjdGVkUG9zaXRpb25TdHJhdGVneSxcbiAgT3ZlcmxheSxcbiAgT3ZlcmxheUNvbmZpZyxcbiAgT3ZlcmxheVJlZixcbiAgU2Nyb2xsU3RyYXRlZ3ksXG4gIENvbm5lY3RlZFBvc2l0aW9uXG59IGZyb20gJ0Bhbmd1bGFyL2Nkay9vdmVybGF5JztcbmltcG9ydCB7IFRlbXBsYXRlUG9ydGFsIH0gZnJvbSAnQGFuZ3VsYXIvY2RrL3BvcnRhbCc7XG5pbXBvcnQge1xuICBBZnRlckNvbnRlbnRJbml0LFxuICBEaXJlY3RpdmUsXG4gIEVsZW1lbnRSZWYsXG4gIEV2ZW50RW1pdHRlcixcbiAgSW5wdXQsXG4gIE9uRGVzdHJveSxcbiAgT3B0aW9uYWwsXG4gIE91dHB1dCxcbiAgU2VsZixcbiAgVmlld0NvbnRhaW5lclJlZlxufSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IG5vcm1hbGl6ZVBhc3NpdmVMaXN0ZW5lck9wdGlvbnMgfSBmcm9tICdAYW5ndWxhci9jZGsvcGxhdGZvcm0nO1xuaW1wb3J0IHsgYXNhcFNjaGVkdWxlciwgbWVyZ2UsIG9mIGFzIG9ic2VydmFibGVPZiwgU3Vic2NyaXB0aW9uLCBmcm9tRXZlbnQsIE9ic2VydmFibGUgfSBmcm9tICdyeGpzJztcbmltcG9ydCB7IGRlbGF5LCBmaWx0ZXIsIHRha2UsIHRha2VVbnRpbCwgbWFwIH0gZnJvbSAncnhqcy9vcGVyYXRvcnMnO1xuaW1wb3J0IHsgTnhDb250ZXh0TWVudUNvbXBvbmVudCB9IGZyb20gJy4vY29udGV4dC1tZW51LmNvbXBvbmVudCc7XG5pbXBvcnQgeyB0aHJvd054Q29udGV4dE1lbnVNaXNzaW5nRXJyb3IgfSBmcm9tICcuL2NvbnRleHQtbWVudS1lcnJvcnMnO1xuaW1wb3J0IHsgTnhDb250ZXh0TWVudUl0ZW1Db21wb25lbnQgfSBmcm9tICcuL2NvbnRleHQtbWVudS1pdGVtLmNvbXBvbmVudCc7XG5cbi8qKiBEZWZhdWx0IHRvcCBwYWRkaW5nIG9mIHRoZSBtZW51IHBhbmVsLiAqL1xuZXhwb3J0IGNvbnN0IE1FTlVfUEFORUxfVE9QX1BBRERJTkcgPSAxNjtcblxuZXhwb3J0IGNvbnN0IE1FTlVfUEFORUxfT0ZGU0VUID0gODtcblxuZXhwb3J0IHR5cGUgTnhDb250ZXh0TWVudVNjcm9sbFN0cmF0ZWd5ID0gJ2Nsb3NlJyB8ICdyZXBvc2l0aW9uJztcblxuLyoqIE9wdGlvbnMgZm9yIGJpbmRpbmcgYSBwYXNzaXZlIGV2ZW50IGxpc3RlbmVyLiAqL1xuY29uc3QgcGFzc2l2ZUV2ZW50TGlzdGVuZXJPcHRpb25zID0gbm9ybWFsaXplUGFzc2l2ZUxpc3RlbmVyT3B0aW9ucyh7XG4gIHBhc3NpdmU6IHRydWVcbn0pO1xuXG4vKipcbiAqIFRoaXMgZGlyZWN0aXZlIGlzIGludGVuZGVkIHRvIGJlIHVzZWQgaW4gY29uanVuY3Rpb24gd2l0aCBhbiBueC1jb250ZXh0LW1lbnUgdGFnLlxuICogSXQgaXMgcmVzcG9uc2libGUgZm9yIHRvZ2dsaW5nIHRoZSBkaXNwbGF5IG9mIHRoZSBwcm92aWRlZCBjb250ZXh0IG1lbnUgaW5zdGFuY2UuXG4gKi9cbkBEaXJlY3RpdmUoe1xuICBzZWxlY3RvcjogYFtueENvbnRleHRNZW51VHJpZ2dlckZvcl1gLFxuICBob3N0OiB7XG4gICAgJ2FyaWEtaGFzcG9wdXAnOiAndHJ1ZScsXG4gICAgJ1thdHRyLmFyaWEtZXhwYW5kZWRdJzogJ2NvbnRleHRNZW51T3BlbiB8fCBudWxsJyxcbiAgICAnKG1vdXNlZG93biknOiAnX2hhbmRsZU1vdXNlZG93bigkZXZlbnQpJyxcbiAgICAnKGtleWRvd24pJzogJ19oYW5kbGVLZXlkb3duKCRldmVudCknLFxuICAgICcoY2xpY2spJzogJ19oYW5kbGVDbGljaygkZXZlbnQpJ1xuICB9LFxuICBleHBvcnRBczogJ254Q29udGV4dE1lbnVUcmlnZ2VyJ1xufSlcbmV4cG9ydCBjbGFzcyBOeENvbnRleHRNZW51VHJpZ2dlckRpcmVjdGl2ZVxuICBpbXBsZW1lbnRzIEFmdGVyQ29udGVudEluaXQsIE9uRGVzdHJveSB7XG4gIHByaXZhdGUgX3BvcnRhbDogVGVtcGxhdGVQb3J0YWw7XG4gIHByaXZhdGUgX292ZXJsYXlSZWY6IE92ZXJsYXlSZWYgfCBudWxsID0gbnVsbDtcbiAgcHJpdmF0ZSBfY29udGV4dE1lbnVPcGVuOiBib29sZWFuID0gZmFsc2U7XG4gIHByaXZhdGUgX2Nsb3NpbmdBY3Rpb25zU3Vic2NyaXB0aW9uID0gU3Vic2NyaXB0aW9uLkVNUFRZO1xuICBwcml2YXRlIF9ob3ZlclN1YnNjcmlwdGlvbiA9IFN1YnNjcmlwdGlvbi5FTVBUWTtcbiAgcHJpdmF0ZSBfY29udGV4dE1lbnVDbG9zZVN1YnNjcmlwdGlvbiA9IFN1YnNjcmlwdGlvbi5FTVBUWTtcbiAgcHJpdmF0ZSBfZG9jdW1lbnRDbGlja09ic2VydmFibGU6IE9ic2VydmFibGU8TW91c2VFdmVudD47XG4gIHByaXZhdGUgX3Njcm9sbFN0cmF0ZWd5OiAoKSA9PiBTY3JvbGxTdHJhdGVneTtcblxuICAvKiogUmVmZXJlbmNlcyB0aGUgY29udGV4dCBtZW51IGluc3RhbmNlIHRoYXQgdGhlIHRyaWdnZXIgaXMgYXNzb2NpYXRlZCB3aXRoLiAqL1xuICBASW5wdXQoJ254Q29udGV4dE1lbnVUcmlnZ2VyRm9yJylcbiAgZ2V0IGNvbnRleHRNZW51KCkge1xuICAgIHJldHVybiB0aGlzLl9jb250ZXh0TWVudTtcbiAgfVxuICBzZXQgY29udGV4dE1lbnUoY29udGV4dE1lbnU6IE54Q29udGV4dE1lbnVDb21wb25lbnQpIHtcbiAgICBpZiAoY29udGV4dE1lbnUgPT09IHRoaXMuX2NvbnRleHRNZW51KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5fY29udGV4dE1lbnUgPSBjb250ZXh0TWVudTtcbiAgICB0aGlzLl9jb250ZXh0TWVudUNsb3NlU3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XG5cbiAgICBpZiAoY29udGV4dE1lbnUpIHtcbiAgICAgIHRoaXMuX2NvbnRleHRNZW51Q2xvc2VTdWJzY3JpcHRpb24gPSBjb250ZXh0TWVudS5jbG9zZWRcbiAgICAgICAgLmFzT2JzZXJ2YWJsZSgpXG4gICAgICAgIC5zdWJzY3JpYmUocmVhc29uID0+IHtcbiAgICAgICAgICB0aGlzLl9kZXN0cm95TWVudSgpO1xuXG4gICAgICAgICAgLy8gSWYgYSBjbGljayBjbG9zZWQgdGhlIG1lbnUsIHdlIHNob3VsZCBjbG9zZSB0aGUgZW50aXJlIGNoYWluIG9mIG5lc3RlZCBtZW51cy5cbiAgICAgICAgICBpZiAoKHJlYXNvbiA9PT0gJ2NsaWNrJyB8fCByZWFzb24gPT09ICd0YWInKSAmJiB0aGlzLl9wYXJlbnRNZW51KSB7XG4gICAgICAgICAgICB0aGlzLl9wYXJlbnRNZW51LmNsb3NlZC5lbWl0KHJlYXNvbik7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gIH1cbiAgcHJpdmF0ZSBfY29udGV4dE1lbnU6IE54Q29udGV4dE1lbnVDb21wb25lbnQ7XG5cbiAgQElucHV0KClcbiAgc2V0IHNjcm9sbFN0cmF0ZWd5KHZhbHVlOiBOeENvbnRleHRNZW51U2Nyb2xsU3RyYXRlZ3kpIHtcbiAgICBpZiAodmFsdWUgPT09ICdjbG9zZScpIHtcbiAgICAgIHRoaXMuX3Njcm9sbFN0cmF0ZWd5ID0gdGhpcy5fb3ZlcmxheS5zY3JvbGxTdHJhdGVnaWVzLmNsb3NlO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9zY3JvbGxTdHJhdGVneSA9IHRoaXMuX292ZXJsYXkuc2Nyb2xsU3RyYXRlZ2llcy5yZXBvc2l0aW9uO1xuICAgIH1cbiAgfVxuXG4gIC8qKiBXaGV0aGVyIHRoZSBjb250ZXh0IG1lbnUgaXMgb3Blbi4gKi9cbiAgZ2V0IGNvbnRleHRNZW51T3BlbigpOiBib29sZWFuIHtcbiAgICByZXR1cm4gdGhpcy5fY29udGV4dE1lbnVPcGVuO1xuICB9XG5cbiAgLyoqIFRoZSB0ZXh0IGRpcmVjdGlvbiBvZiB0aGUgY29udGFpbmluZyBhcHAuICovXG4gIHByaXZhdGUgZ2V0IGRpcigpOiBEaXJlY3Rpb24ge1xuICAgIHJldHVybiB0aGlzLl9kaXIgJiYgdGhpcy5fZGlyLnZhbHVlID09PSAncnRsJyA/ICdydGwnIDogJ2x0cic7XG4gIH1cblxuICAvKiogRGF0YSB0byBiZSBwYXNzZWQgYWxvbmcgdG8gYW55IGxhemlseS1yZW5kZXJlZCBjb250ZW50LiAqL1xuICBASW5wdXQoJ254Q29udGV4dE1lbnVUcmlnZ2VyRGF0YScpIGNvbnRleHRNZW51RGF0YTogYW55O1xuXG4gIC8qKiBFdmVudCBlbWl0dGVkIHdoZW4gdGhlIGFzc29jaWF0ZWQgY29udGV4dCBtZW51IGlzIG9wZW5lZC4gKi9cbiAgQE91dHB1dCgpIHJlYWRvbmx5IGNvbnRleHRNZW51T3BlbmVkOiBFdmVudEVtaXR0ZXI8dm9pZD4gPSBuZXcgRXZlbnRFbWl0dGVyPHZvaWQ+KCk7XG5cbiAgLyoqIEV2ZW50IGVtaXR0ZWQgd2hlbiB0aGUgYXNzb2NpYXRlZCBjb250ZXh0IG1lbnUgaXMgY2xvc2VkLiAqL1xuICBAT3V0cHV0KCkgcmVhZG9ubHkgY29udGV4dE1lbnVDbG9zZWQ6IEV2ZW50RW1pdHRlcjx2b2lkPiA9IG5ldyBFdmVudEVtaXR0ZXI8dm9pZD4oKTtcblxuICBjb25zdHJ1Y3RvcihcbiAgICAgIHByaXZhdGUgX292ZXJsYXk6IE92ZXJsYXksXG4gICAgICBwcml2YXRlIF9lbGVtZW50OiBFbGVtZW50UmVmPEhUTUxFbGVtZW50PixcbiAgICAgIHByaXZhdGUgX3ZpZXdDb250YWluZXJSZWY6IFZpZXdDb250YWluZXJSZWYsXG4gICAgICBAT3B0aW9uYWwoKSBwcml2YXRlIF9wYXJlbnRNZW51OiBOeENvbnRleHRNZW51Q29tcG9uZW50LFxuICAgICAgQE9wdGlvbmFsKClcbiAgICAgIEBTZWxmKClcbiAgICAgIHByaXZhdGUgX2NvbnRleHRNZW51SXRlbUluc3RhbmNlOiBOeENvbnRleHRNZW51SXRlbUNvbXBvbmVudCxcbiAgICAgIEBPcHRpb25hbCgpIHByaXZhdGUgX2RpcjogRGlyZWN0aW9uYWxpdHkpIHtcblxuICAgIGlmIChfY29udGV4dE1lbnVJdGVtSW5zdGFuY2UpIHtcbiAgICAgIF9jb250ZXh0TWVudUl0ZW1JbnN0YW5jZS5fdHJpZ2dlcnNTdWJtZW51ID0gdGhpcy50cmlnZ2Vyc1N1Ym1lbnUoKTtcbiAgICB9XG5cbiAgICB0aGlzLl9zY3JvbGxTdHJhdGVneSA9IHRoaXMuX292ZXJsYXkuc2Nyb2xsU3RyYXRlZ2llcy5yZXBvc2l0aW9uO1xuICAgIHRoaXMuX2RvY3VtZW50Q2xpY2tPYnNlcnZhYmxlID0gZnJvbUV2ZW50PE1vdXNlRXZlbnQ+KGRvY3VtZW50LCAnY2xpY2snKTtcbiAgfVxuXG4gIG5nQWZ0ZXJDb250ZW50SW5pdCgpIHtcbiAgICB0aGlzLl9jaGVja0NvbnRleHRNZW51KCk7XG4gICAgdGhpcy5faGFuZGxlSG92ZXIoKTtcbiAgfVxuXG4gIG5nT25EZXN0cm95KCkge1xuICAgIGlmICh0aGlzLl9vdmVybGF5UmVmKSB7XG4gICAgICB0aGlzLl9vdmVybGF5UmVmLmRpc3Bvc2UoKTtcbiAgICAgIHRoaXMuX292ZXJsYXlSZWYgPSBudWxsO1xuICAgIH1cblxuICAgIHRoaXMuX2NvbnRleHRNZW51Q2xvc2VTdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcbiAgICB0aGlzLl9jbG9zaW5nQWN0aW9uc1N1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xuICAgIHRoaXMuX2hvdmVyU3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XG4gIH1cblxuICAvKiogV2hldGhlciB0aGUgY29udGV4dCBtZW51IHRyaWdnZXJzIGEgc3ViLW1lbnUgb3IgYSB0b3AtbGV2ZWwgb25lLiAqL1xuICB0cmlnZ2Vyc1N1Ym1lbnUoKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuICEhKHRoaXMuX2NvbnRleHRNZW51SXRlbUluc3RhbmNlICYmIHRoaXMuX3BhcmVudE1lbnUpO1xuICB9XG5cbiAgLyoqIFRvZ2dsZXMgdGhlIGNvbnRleHQgbWVudSBiZXR3ZWVuIHRoZSBvcGVuIGFuZCBjbG9zZWQgc3RhdGVzLiAqL1xuICB0b2dnbGVDb250ZXh0TWVudSgpOiB2b2lkIHtcbiAgICByZXR1cm4gdGhpcy5jb250ZXh0TWVudU9wZW5cbiAgICAgID8gdGhpcy5jbG9zZUNvbnRleHRNZW51KClcbiAgICAgIDogdGhpcy5vcGVuQ29udGV4dE1lbnUoKTtcbiAgfVxuXG4gIC8qKiBPcGVucyB0aGUgY29udGV4dCBtZW51LiAqL1xuICBvcGVuQ29udGV4dE1lbnUoKTogdm9pZCB7XG4gICAgaWYgKHRoaXMuY29udGV4dE1lbnVPcGVuKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5fY2hlY2tDb250ZXh0TWVudSgpO1xuXG4gICAgY29uc3Qgb3ZlcmxheVJlZiA9IHRoaXMuX2NyZWF0ZU92ZXJsYXkoKTtcbiAgICBjb25zdCBvdmVybGF5Q29uZmlnID0gb3ZlcmxheVJlZi5nZXRDb25maWcoKTtcblxuICAgIHRoaXMuX3NldFBvc2l0aW9uKFxuICAgICAgb3ZlcmxheUNvbmZpZy5wb3NpdGlvblN0cmF0ZWd5IGFzIEZsZXhpYmxlQ29ubmVjdGVkUG9zaXRpb25TdHJhdGVneVxuICAgICk7XG4gICAgb3ZlcmxheVJlZi5hdHRhY2godGhpcy5fZ2V0UG9ydGFsKCkpO1xuXG4gICAgaWYgKHRoaXMuY29udGV4dE1lbnUubGF6eUNvbnRlbnQpIHtcbiAgICAgIHRoaXMuY29udGV4dE1lbnUubGF6eUNvbnRlbnQuYXR0YWNoKHRoaXMuY29udGV4dE1lbnVEYXRhKTtcbiAgICB9XG5cbiAgICB0aGlzLl9jbG9zaW5nQWN0aW9uc1N1YnNjcmlwdGlvbiA9IHRoaXMuX2NvbnRleHRNZW51Q2xvc2luZ0FjdGlvbnMoKS5zdWJzY3JpYmUoXG4gICAgICAoKSA9PiB0aGlzLmNsb3NlQ29udGV4dE1lbnUoKVxuICAgICk7XG4gICAgdGhpcy5faW5pdENvbnRleHRNZW51KCk7XG5cbiAgICBpZiAodGhpcy5jb250ZXh0TWVudSBpbnN0YW5jZW9mIE54Q29udGV4dE1lbnVDb21wb25lbnQpIHtcbiAgICAgIHRoaXMuY29udGV4dE1lbnUuX3N0YXJ0QW5pbWF0aW9uKCk7XG4gICAgfVxuXG4gICAgdGhpcy5fd2FpdEZvckNsb3NlKCk7XG4gIH1cblxuICAvKiogQ2xvc2VzIHRoZSBjb250ZXh0IG1lbnUuICovXG4gIGNsb3NlQ29udGV4dE1lbnUoKTogdm9pZCB7XG4gICAgdGhpcy5jb250ZXh0TWVudS5jbG9zZWQuZW1pdCgpO1xuICB9XG5cbiAgLyoqIENsb3NlcyB0aGUgY29udGV4dCBtZW51IGFuZCBkb2VzIHRoZSBuZWNlc3NhcnkgY2xlYW51cC4gKi9cbiAgcHJpdmF0ZSBfZGVzdHJveU1lbnUoKSB7XG4gICAgaWYgKCF0aGlzLl9vdmVybGF5UmVmIHx8ICF0aGlzLmNvbnRleHRNZW51T3Blbikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IGNvbnRleHRNZW51ID0gdGhpcy5jb250ZXh0TWVudTtcblxuICAgIHRoaXMuX2Nsb3NpbmdBY3Rpb25zU3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XG4gICAgdGhpcy5fb3ZlcmxheVJlZi5kZXRhY2goKTtcblxuICAgIGNvbnRleHRNZW51Ll9yZXNldEFuaW1hdGlvbigpO1xuXG4gICAgaWYgKGNvbnRleHRNZW51LmxhenlDb250ZW50KSB7XG4gICAgICAvLyBXYWl0IGZvciB0aGUgZXhpdCBhbmltYXRpb24gdG8gZmluaXNoIGJlZm9yZSBkZXRhY2hpbmcgdGhlIGNvbnRlbnQuXG4gICAgICBjb250ZXh0TWVudS5fYW5pbWF0aW9uRG9uZVxuICAgICAgICAucGlwZShcbiAgICAgICAgICBmaWx0ZXIoZXZlbnQgPT4gZXZlbnQudG9TdGF0ZSA9PT0gJ3ZvaWQnKSxcbiAgICAgICAgICB0YWtlKDEpLFxuICAgICAgICAgIC8vIEludGVycnVwdCBpZiB0aGUgY29udGVudCBnb3QgcmUtYXR0YWNoZWQuXG4gICAgICAgICAgdGFrZVVudGlsKGNvbnRleHRNZW51LmxhenlDb250ZW50Ll9hdHRhY2hlZClcbiAgICAgICAgKVxuICAgICAgICAuc3Vic2NyaWJlKHtcbiAgICAgICAgICBuZXh0OiAoKSA9PlxuICAgICAgICAgICAgY29udGV4dE1lbnUubGF6eUNvbnRlbnQgJiYgY29udGV4dE1lbnUubGF6eUNvbnRlbnQuZGV0YWNoKCksXG4gICAgICAgICAgLy8gTm8gbWF0dGVyIHdoZXRoZXIgdGhlIGNvbnRlbnQgZ290IHJlLWF0dGFjaGVkLCByZXNldCB0aGUgbWVudS5cbiAgICAgICAgICBjb21wbGV0ZTogKCkgPT4gdGhpcy5fcmVzZXRDb250ZXh0TWVudSgpXG4gICAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9yZXNldENvbnRleHRNZW51KCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFRoaXMgbWV0aG9kIHNldHMgdGhlIGNvbnRleHQgbWVudSBzdGF0ZSB0byBvcGVuIGFuZCBmb2N1c2VzIHRoZSBmaXJzdCBpdGVtIGlmXG4gICAqIHRoZSBjb250ZXh0IG1lbnUgd2FzIG9wZW5lZCB2aWEgdGhlIGtleWJvYXJkLlxuICAgKi9cbiAgcHJpdmF0ZSBfaW5pdENvbnRleHRNZW51KCk6IHZvaWQge1xuICAgIHRoaXMuY29udGV4dE1lbnUucGFyZW50TWVudSA9IHRoaXMudHJpZ2dlcnNTdWJtZW51KClcbiAgICAgID8gdGhpcy5fcGFyZW50TWVudVxuICAgICAgOiB1bmRlZmluZWQ7XG4gICAgdGhpcy5jb250ZXh0TWVudS5kaXJlY3Rpb24gPSB0aGlzLmRpcjtcbiAgICB0aGlzLl9zZXRJc0NvbnRleHRNZW51T3Blbih0cnVlKTtcbiAgICB0aGlzLmNvbnRleHRNZW51LmZvY3VzRmlyc3RJdGVtKCk7XG4gIH1cblxuICAvKipcbiAgICogRm9jdXNlcyB0aGUgY29udGV4dCBtZW51IHRyaWdnZXIuXG4gICAqL1xuICBmb2N1cygpIHtcbiAgICB0aGlzLl9lbGVtZW50Lm5hdGl2ZUVsZW1lbnQuZm9jdXMoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGlzIG1ldGhvZCByZXNldHMgdGhlIGNvbnRleHQgbWVudSB3aGVuIGl0J3MgY2xvc2VkLCBtb3N0IGltcG9ydGFudGx5IHJlc3RvcmluZ1xuICAgKiBmb2N1cyB0byB0aGUgY29udGV4dCBtZW51IHRyaWdnZXIgaWYgdGhlIGNvbnRleHQgbWVudSB3YXMgb3BlbmVkIHZpYSB0aGUga2V5Ym9hcmQuXG4gICAqL1xuICBwcml2YXRlIF9yZXNldENvbnRleHRNZW51KCk6IHZvaWQge1xuICAgIHRoaXMuX3NldElzQ29udGV4dE1lbnVPcGVuKGZhbHNlKTtcbiAgICB0aGlzLmZvY3VzKCk7XG4gIH1cblxuICAvKiogU2V0IHN0YXRlIHJhdGhlciB0aGFuIHRvZ2dsZSB0byBzdXBwb3J0IHRyaWdnZXJzIHNoYXJpbmcgYSBtZW51LiAqL1xuICBwcml2YXRlIF9zZXRJc0NvbnRleHRNZW51T3Blbihpc09wZW46IGJvb2xlYW4pOiB2b2lkIHtcbiAgICB0aGlzLl9jb250ZXh0TWVudU9wZW4gPSBpc09wZW47XG4gICAgdGhpcy5fY29udGV4dE1lbnVPcGVuXG4gICAgICA/IHRoaXMuY29udGV4dE1lbnVPcGVuZWQuZW1pdCgpXG4gICAgICA6IHRoaXMuY29udGV4dE1lbnVDbG9zZWQuZW1pdCgpO1xuXG4gICAgaWYgKHRoaXMudHJpZ2dlcnNTdWJtZW51KCkpIHtcbiAgICAgIHRoaXMuX2NvbnRleHRNZW51SXRlbUluc3RhbmNlLl9oaWdobGlnaHRlZCA9IGlzT3BlbjtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogVGhpcyBtZXRob2QgY2hlY2tzIHRoYXQgYSB2YWxpZCBpbnN0YW5jZSBvZiBOeENvbnRleHRNZW51Q29tcG9uZW50IGhhcyBiZWVuIHBhc3NlZCBpbnRvXG4gICAqIG54Q29udGV4dE1lbnVUcmlnZ2VyRm9yLiBJZiBub3QsIGFuIGV4Y2VwdGlvbiBpcyB0aHJvd24uXG4gICAqL1xuICBwcml2YXRlIF9jaGVja0NvbnRleHRNZW51KCkge1xuICAgIGlmICghdGhpcy5jb250ZXh0TWVudSkge1xuICAgICAgdGhyb3dOeENvbnRleHRNZW51TWlzc2luZ0Vycm9yKCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFRoaXMgbWV0aG9kIGNyZWF0ZXMgdGhlIG92ZXJsYXkgZnJvbSB0aGUgcHJvdmlkZWQgbWVudSdzIHRlbXBsYXRlIGFuZCBzYXZlcyBpdHNcbiAgICogT3ZlcmxheVJlZiBzbyB0aGF0IGl0IGNhbiBiZSBhdHRhY2hlZCB0byB0aGUgRE9NIHdoZW4gb3BlbkNvbnRleHRNZW51IGlzIGNhbGxlZC5cbiAgICovXG4gIHByaXZhdGUgX2NyZWF0ZU92ZXJsYXkoKTogT3ZlcmxheVJlZiB7XG4gICAgaWYgKCF0aGlzLl9vdmVybGF5UmVmKSB7XG4gICAgICBjb25zdCBjb25maWcgPSB0aGlzLl9nZXRPdmVybGF5Q29uZmlnKCk7XG4gICAgICB0aGlzLl9vdmVybGF5UmVmID0gdGhpcy5fb3ZlcmxheS5jcmVhdGUoY29uZmlnKTtcblxuICAgICAgLy8gQ29uc3VtZSB0aGUgYGtleWRvd25FdmVudHNgIGluIG9yZGVyIHRvIHByZXZlbnQgdGhlbSBmcm9tIGdvaW5nIHRvIGFub3RoZXIgb3ZlcmxheS5cbiAgICAgIHRoaXMuX292ZXJsYXlSZWYua2V5ZG93bkV2ZW50cygpLnN1YnNjcmliZSgpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLl9vdmVybGF5UmVmO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoaXMgbWV0aG9kIGJ1aWxkcyB0aGUgY29uZmlndXJhdGlvbiBvYmplY3QgbmVlZGVkIHRvIGNyZWF0ZSB0aGUgb3ZlcmxheSwgdGhlIE92ZXJsYXlTdGF0ZS5cbiAgICogQHJldHVybnMgT3ZlcmxheUNvbmZpZ1xuICAgKi9cbiAgcHJpdmF0ZSBfZ2V0T3ZlcmxheUNvbmZpZygpOiBPdmVybGF5Q29uZmlnIHtcbiAgICByZXR1cm4gbmV3IE92ZXJsYXlDb25maWcoe1xuICAgICAgcG9zaXRpb25TdHJhdGVneTogdGhpcy5fb3ZlcmxheVxuICAgICAgICAucG9zaXRpb24oKVxuICAgICAgICAuZmxleGlibGVDb25uZWN0ZWRUbyh0aGlzLl9lbGVtZW50KVxuICAgICAgICAud2l0aExvY2tlZFBvc2l0aW9uKClcbiAgICAgICAgLndpdGhGbGV4aWJsZURpbWVuc2lvbnMoZmFsc2UpXG4gICAgICAgIC53aXRoVHJhbnNmb3JtT3JpZ2luT24oJy5ueC1jb250ZXh0LW1lbnUnKSxcbiAgICAgIHNjcm9sbFN0cmF0ZWd5OiB0aGlzLl9zY3JvbGxTdHJhdGVneSgpLFxuICAgICAgZGlyZWN0aW9uOiB0aGlzLl9kaXJcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIHRoZSBhcHByb3ByaWF0ZSBwb3NpdGlvbnMgb24gYSBwb3NpdGlvbiBzdHJhdGVneVxuICAgKiBzbyB0aGUgb3ZlcmxheSBjb25uZWN0cyB3aXRoIHRoZSB0cmlnZ2VyIGNvcnJlY3RseS5cbiAgICogQHBhcmFtIHBvc2l0aW9uU3RyYXRlZ3kgU3RyYXRlZ3kgd2hvc2UgcG9zaXRpb24gdG8gdXBkYXRlLlxuICAgKi9cbiAgcHJpdmF0ZSBfc2V0UG9zaXRpb24ocG9zaXRpb25TdHJhdGVneTogRmxleGlibGVDb25uZWN0ZWRQb3NpdGlvblN0cmF0ZWd5KSB7XG4gICAgbGV0IG9yaWdpblggPSAnc3RhcnQnO1xuICAgIGxldCBvcmlnaW5GYWxsYmFja1ggPSAnZW5kJztcbiAgICBjb25zdCBvdmVybGF5WSA9ICd0b3AnO1xuICAgIGNvbnN0IG92ZXJsYXlGYWxsYmFja1kgPSAnYm90dG9tJztcbiAgICBsZXQgb3JpZ2luWSA9IG92ZXJsYXlZO1xuICAgIGxldCBvcmlnaW5GYWxsYmFja1kgPSBvdmVybGF5RmFsbGJhY2tZO1xuICAgIGxldCBvdmVybGF5WCA9IG9yaWdpblg7XG4gICAgbGV0IG92ZXJsYXlGYWxsYmFja1ggPSBvcmlnaW5GYWxsYmFja1g7XG4gICAgbGV0IG9mZnNldFkgPSAwO1xuXG4gICAgaWYgKHRoaXMudHJpZ2dlcnNTdWJtZW51KCkpIHtcbiAgICAgIC8vIFdoZW4gdGhlIG1lbnUgaXMgYSBzdWItbWVudSwgaXQgc2hvdWxkIGFsd2F5cyBhbGlnbiBpdHNlbGZcbiAgICAgIC8vIHRvIHRoZSBlZGdlcyBvZiB0aGUgdHJpZ2dlciwgaW5zdGVhZCBvZiBvdmVybGFwcGluZyBpdC5cbiAgICAgIG92ZXJsYXlGYWxsYmFja1ggPSBvcmlnaW5YID0gJ2VuZCc7XG4gICAgICBvcmlnaW5GYWxsYmFja1ggPSBvdmVybGF5WCA9ICdzdGFydCc7XG4gICAgICBvZmZzZXRZID0gLU1FTlVfUEFORUxfVE9QX1BBRERJTkc7XG4gICAgfSBlbHNlIHtcbiAgICAgIG9mZnNldFkgPSBNRU5VX1BBTkVMX09GRlNFVDtcbiAgICAgIG9yaWdpblkgPSAnYm90dG9tJztcbiAgICAgIG9yaWdpbkZhbGxiYWNrWSA9ICd0b3AnO1xuICAgIH1cblxuICAgIHBvc2l0aW9uU3RyYXRlZ3kud2l0aFBvc2l0aW9ucyhbXG4gICAgICB7IG9yaWdpblgsIG9yaWdpblksIG92ZXJsYXlYLCBvdmVybGF5WSwgb2Zmc2V0WSB9LFxuICAgICAge1xuICAgICAgICBvcmlnaW5YOiBvcmlnaW5GYWxsYmFja1gsXG4gICAgICAgIG9yaWdpblksXG4gICAgICAgIG92ZXJsYXlYOiBvdmVybGF5RmFsbGJhY2tYLFxuICAgICAgICBvdmVybGF5WSxcbiAgICAgICAgb2Zmc2V0WVxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgb3JpZ2luWCxcbiAgICAgICAgb3JpZ2luWTogb3JpZ2luRmFsbGJhY2tZLFxuICAgICAgICBvdmVybGF5WCxcbiAgICAgICAgb3ZlcmxheVk6IG92ZXJsYXlGYWxsYmFja1ksXG4gICAgICAgIG9mZnNldFk6IC1vZmZzZXRZXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBvcmlnaW5YOiBvcmlnaW5GYWxsYmFja1gsXG4gICAgICAgIG9yaWdpblk6IG9yaWdpbkZhbGxiYWNrWSxcbiAgICAgICAgb3ZlcmxheVg6IG92ZXJsYXlGYWxsYmFja1gsXG4gICAgICAgIG92ZXJsYXlZOiBvdmVybGF5RmFsbGJhY2tZLFxuICAgICAgICBvZmZzZXRZOiAtb2Zmc2V0WVxuICAgICAgfVxuICAgIF0gYXMgQ29ubmVjdGVkUG9zaXRpb25bXSk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhIHN0cmVhbSB0aGF0IGVtaXRzIHdoZW5ldmVyIGFuIGFjdGlvbiB0aGF0IHNob3VsZCBjbG9zZSB0aGUgY29udGV4dCBtZW51IG9jY3Vycy4gKi9cbiAgcHJpdmF0ZSBfY29udGV4dE1lbnVDbG9zaW5nQWN0aW9ucygpIHtcbiAgICBsZXQgYmFja2Ryb3A7XG4gICAgbGV0IGRldGFjaG1lbnRzO1xuXG4gICAgaWYgKHRoaXMuX292ZXJsYXlSZWYpIHtcbiAgICAgIGJhY2tkcm9wID0gdGhpcy5fb3ZlcmxheVJlZi5iYWNrZHJvcENsaWNrKCk7XG4gICAgICBkZXRhY2htZW50cyA9IHRoaXMuX292ZXJsYXlSZWYuZGV0YWNobWVudHMoKTtcbiAgICB9XG5cbiAgICBjb25zdCBwYXJlbnRDbG9zZSA9IHRoaXMuX3BhcmVudE1lbnVcbiAgICAgID8gdGhpcy5fcGFyZW50TWVudS5jbG9zZWRcbiAgICAgIDogb2JzZXJ2YWJsZU9mKCk7XG5cbiAgICBjb25zdCBob3ZlciA9IHRoaXMuX3BhcmVudE1lbnVcbiAgICAgID8gdGhpcy5fcGFyZW50TWVudS5faG92ZXJlZCgpLnBpcGUoXG4gICAgICAgICAgZmlsdGVyKGFjdGl2ZSA9PiBhY3RpdmUgIT09IHRoaXMuX2NvbnRleHRNZW51SXRlbUluc3RhbmNlKSxcbiAgICAgICAgICBmaWx0ZXIoKCkgPT4gdGhpcy5fY29udGV4dE1lbnVPcGVuKVxuICAgICAgICApXG4gICAgICA6IG9ic2VydmFibGVPZigpO1xuXG4gICAgcmV0dXJuIG1lcmdlKGJhY2tkcm9wLCBwYXJlbnRDbG9zZSwgaG92ZXIsIGRldGFjaG1lbnRzKTtcbiAgfVxuXG4gIC8qKiBIYW5kbGVzIG1vdXNlIHByZXNzZXMgb24gdGhlIHRyaWdnZXIuICovXG4gIF9oYW5kbGVNb3VzZWRvd24oZXZlbnQ6IE1vdXNlRXZlbnQpOiB2b2lkIHtcbiAgICAvLyBTaW5jZSByaWdodCBvciBtaWRkbGUgYnV0dG9uIGNsaWNrcyB3b24ndCB0cmlnZ2VyIHRoZSBgY2xpY2tgIGV2ZW50LFxuICAgIC8vIHdlIHNob3VsZG4ndCBjb25zaWRlciB0aGUgbWVudSBhcyBvcGVuZWQgYnkgbW91c2UgaW4gdGhvc2UgY2FzZXMuXG4gICAgLy8gdGhpcy5fb3BlbmVkQnkgPSBldmVudC5idXR0b24gPT09IDAgPyAnbW91c2UnIDogbnVsbDtcblxuICAgIC8vIFNpbmNlIGNsaWNraW5nIG9uIHRoZSB0cmlnZ2VyIHdvbid0IGNsb3NlIHRoZSBtZW51IGlmIGl0IG9wZW5zIGEgc3ViLW1lbnUsXG4gICAgLy8gd2Ugc2hvdWxkIHByZXZlbnQgZm9jdXMgZnJvbSBtb3Zpbmcgb250byBpdCB2aWEgY2xpY2sgdG8gYXZvaWQgdGhlXG4gICAgLy8gaGlnaGxpZ2h0IGZyb20gbGluZ2VyaW5nIG9uIHRoZSBtZW51IGl0ZW0uXG4gICAgaWYgKHRoaXMudHJpZ2dlcnNTdWJtZW51KCkpIHtcbiAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgfVxuICB9XG5cbiAgLyoqIEhhbmRsZXMga2V5IHByZXNzZXMgb24gdGhlIHRyaWdnZXIuICovXG4gIF9oYW5kbGVLZXlkb3duKGV2ZW50OiBLZXlib2FyZEV2ZW50KTogdm9pZCB7XG4gICAgY29uc3Qga2V5Q29kZSA9IGV2ZW50LmtleUNvZGU7XG5cbiAgICBpZiAoXG4gICAgICB0aGlzLnRyaWdnZXJzU3VibWVudSgpICYmXG4gICAgICAoKGtleUNvZGUgPT09IFJJR0hUX0FSUk9XICYmIHRoaXMuZGlyID09PSAnbHRyJykgfHxcbiAgICAgICAgKGtleUNvZGUgPT09IExFRlRfQVJST1cgJiYgdGhpcy5kaXIgPT09ICdydGwnKSlcbiAgICApIHtcbiAgICAgIHRoaXMub3BlbkNvbnRleHRNZW51KCk7XG4gICAgfVxuICB9XG5cbiAgLyoqIEhhbmRsZXMgY2xpY2sgZXZlbnRzIG9uIHRoZSB0cmlnZ2VyLiAqL1xuICBfaGFuZGxlQ2xpY2soZXZlbnQ6IE1vdXNlRXZlbnQpOiB2b2lkIHtcbiAgICBpZiAodGhpcy50cmlnZ2Vyc1N1Ym1lbnUoKSkge1xuICAgICAgLy8gU3RvcCBldmVudCBwcm9wYWdhdGlvbiB0byBhdm9pZCBjbG9zaW5nIHRoZSBwYXJlbnQgbWVudS5cbiAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgdGhpcy5vcGVuQ29udGV4dE1lbnUoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy50b2dnbGVDb250ZXh0TWVudSgpO1xuICAgIH1cbiAgfVxuXG4gIC8qIFN1YnNjcmliZXMgdG8gZG9jdW1lbnQgY2xpY2tzIHRvIGNsb3NlIHRoZSBjb250ZXh0IG1lbnUgb24gY2xpY2tzIG9uIHRoZSBiYWNrZ3JvdW5kLiAqL1xuICBwcml2YXRlIF93YWl0Rm9yQ2xvc2UoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2RvY3VtZW50Q2xpY2tPYnNlcnZhYmxlXG4gICAgICAucGlwZShcbiAgICAgICAgbWFwKGV2ZW50ID0+IGV2ZW50LnRhcmdldCksXG4gICAgICAgIGZpbHRlcigodGFyZ2V0OiBOb2RlKSA9PiAhdGhpcy5fZWxlbWVudC5uYXRpdmVFbGVtZW50LmNvbnRhaW5zKHRhcmdldCkpLFxuICAgICAgICB0YWtlVW50aWwodGhpcy5jb250ZXh0TWVudS5jbG9zZWQpKVxuICAgICAgLnN1YnNjcmliZSgoKSA9PiB7XG4gICAgICAgIHRoaXMuY2xvc2VDb250ZXh0TWVudSgpO1xuICAgICAgfSk7XG4gIH1cblxuICAvKiogSGFuZGxlcyB0aGUgY2FzZXMgd2hlcmUgdGhlIHVzZXIgaG92ZXJzIG92ZXIgdGhlIHRyaWdnZXIuICovXG4gIHByaXZhdGUgX2hhbmRsZUhvdmVyKCkge1xuICAgIC8vIFN1YnNjcmliZSB0byBjaGFuZ2VzIGluIHRoZSBob3ZlcmVkIGl0ZW0gaW4gb3JkZXIgdG8gdG9nZ2xlIHRoZSBwYW5lbC5cbiAgICBpZiAoIXRoaXMudHJpZ2dlcnNTdWJtZW51KCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLl9ob3ZlclN1YnNjcmlwdGlvbiA9IHRoaXMuX3BhcmVudE1lbnVcbiAgICAgIC5faG92ZXJlZCgpXG4gICAgICAvLyBTaW5jZSB3ZSBtaWdodCBoYXZlIG11bHRpcGxlIGNvbXBldGluZyB0cmlnZ2VycyBmb3IgdGhlIHNhbWUgbWVudSAoZS5nLiBhIHN1Yi1tZW51XG4gICAgICAvLyB3aXRoIGRpZmZlcmVudCBkYXRhIGFuZCB0cmlnZ2VycyksIHdlIGhhdmUgdG8gZGVsYXkgaXQgYnkgYSB0aWNrIHRvIGVuc3VyZSB0aGF0XG4gICAgICAvLyBpdCB3b24ndCBiZSBjbG9zZWQgaW1tZWRpYXRlbHkgYWZ0ZXIgaXQgaXMgb3BlbmVkLlxuICAgICAgLnBpcGUoXG4gICAgICAgIGZpbHRlcihhY3RpdmUgPT4gYWN0aXZlID09PSB0aGlzLl9jb250ZXh0TWVudUl0ZW1JbnN0YW5jZSAmJiAhYWN0aXZlLmRpc2FibGVkKSxcbiAgICAgICAgZGVsYXkoMCwgYXNhcFNjaGVkdWxlcilcbiAgICAgIClcbiAgICAgIC5zdWJzY3JpYmUoKCkgPT4ge1xuICAgICAgICAvLyBJZiB0aGUgc2FtZSBtZW51IGlzIHVzZWQgYmV0d2VlbiBtdWx0aXBsZSB0cmlnZ2VycywgaXQgbWlnaHQgc3RpbGwgYmUgYW5pbWF0aW5nXG4gICAgICAgIC8vIHdoaWxlIHRoZSBuZXcgdHJpZ2dlciB0cmllcyB0byByZS1vcGVuIGl0LiBXYWl0IGZvciB0aGUgYW5pbWF0aW9uIHRvIGZpbmlzaFxuICAgICAgICAvLyBiZWZvcmUgZG9pbmcgc28uIEFsc28gaW50ZXJydXB0IGlmIHRoZSB1c2VyIG1vdmVzIHRvIGFub3RoZXIgaXRlbS5cbiAgICAgICAgaWYgKHRoaXMuY29udGV4dE1lbnUuX2lzQW5pbWF0aW5nKSB7XG4gICAgICAgICAgLy8gV2UgbmVlZCB0aGUgYGRlbGF5KDApYCBoZXJlIGluIG9yZGVyIHRvIGF2b2lkXG4gICAgICAgICAgLy8gJ2NoYW5nZWQgYWZ0ZXIgY2hlY2tlZCcgZXJyb3JzIGluIHNvbWUgY2FzZXMuXG4gICAgICAgICAgdGhpcy5jb250ZXh0TWVudS5fYW5pbWF0aW9uRG9uZVxuICAgICAgICAgICAgLnBpcGUoXG4gICAgICAgICAgICAgIHRha2UoMSksXG4gICAgICAgICAgICAgIGRlbGF5KDAsIGFzYXBTY2hlZHVsZXIpLFxuICAgICAgICAgICAgICB0YWtlVW50aWwodGhpcy5fcGFyZW50TWVudS5faG92ZXJlZCgpKVxuICAgICAgICAgICAgKVxuICAgICAgICAgICAgLnN1YnNjcmliZSgoKSA9PiB0aGlzLm9wZW5Db250ZXh0TWVudSgpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLm9wZW5Db250ZXh0TWVudSgpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgfVxuXG4gIC8qKiBHZXRzIHRoZSBwb3J0YWwgdGhhdCBzaG91bGQgYmUgYXR0YWNoZWQgdG8gdGhlIG92ZXJsYXkuICovXG4gIHByaXZhdGUgX2dldFBvcnRhbCgpOiBUZW1wbGF0ZVBvcnRhbCB7XG4gICAgLy8gTm90ZSB0aGF0IHdlIGNhbiBhdm9pZCB0aGlzIGNoZWNrIGJ5IGtlZXBpbmcgdGhlIHBvcnRhbCBvbiB0aGUgY29udGV4dCBtZW51IHBhbmVsLlxuICAgIC8vIFdoaWxlIGl0IHdvdWxkIGJlIGNsZWFuZXIsIHdlJ2QgaGF2ZSB0byBpbnRyb2R1Y2UgYW5vdGhlciByZXF1aXJlZCBtZXRob2Qgb25cbiAgICAvLyBgTnhDb250ZXh0TWVudVBhbmVsQ29tcG9uZW50YCwgbWFraW5nIGl0IGhhcmRlciB0byBjb25zdW1lLlxuICAgIGlmICghdGhpcy5fcG9ydGFsIHx8XG4gICAgICAgIHRoaXMuX3BvcnRhbC50ZW1wbGF0ZVJlZiAhPT0gdGhpcy5jb250ZXh0TWVudS50ZW1wbGF0ZVJlZikge1xuICAgICAgdGhpcy5fcG9ydGFsID0gbmV3IFRlbXBsYXRlUG9ydGFsKFxuICAgICAgICB0aGlzLmNvbnRleHRNZW51LnRlbXBsYXRlUmVmLFxuICAgICAgICB0aGlzLl92aWV3Q29udGFpbmVyUmVmXG4gICAgICApO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLl9wb3J0YWw7XG4gIH1cbn1cbiJdfQ==