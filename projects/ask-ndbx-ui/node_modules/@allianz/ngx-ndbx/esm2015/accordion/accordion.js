/**
 * @fileoverview added by tsickle
 * Generated from: accordion/accordion.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import { Directive, Input } from '@angular/core';
import { CdkAccordion } from '@angular/cdk/accordion';
import { coerceBooleanProperty } from '@angular/cdk/coercion';
/** @type {?} */
const DEFAULT_TYPE = 'regular';
export class NxAccordionDirective extends CdkAccordion {
    constructor() {
        super(...arguments);
        this._style = 'regular';
        this._negative = null;
    }
    /**
     * Value for the styling that should be chosen.
     * Default value: 'regular'
     * @param {?} value
     * @return {?}
     */
    set style(value) {
        value = value ? value : DEFAULT_TYPE;
        const [newValue] = value.match(/regular|light/) || [DEFAULT_TYPE];
        this._style = (/** @type {?} */ (newValue));
    }
    /**
     * @return {?}
     */
    get style() {
        return this._style;
    }
    /**
     * Whether the negative set of styles should be used.
     * @param {?} value
     * @return {?}
     */
    set negative(value) {
        this._negative = coerceBooleanProperty(value);
    }
    /**
     * @return {?}
     */
    get negative() {
        return this._negative;
    }
}
NxAccordionDirective.decorators = [
    { type: Directive, args: [{
                // tslint:disable-next-line:directive-selector
                selector: 'nx-accordion',
                host: {
                    '[class.nx-accordion]': 'true',
                    'role': 'presentation'
                }
            },] }
];
NxAccordionDirective.propDecorators = {
    style: [{ type: Input, args: ['nxStyle',] }],
    negative: [{ type: Input }]
};
if (false) {
    /**
     * @type {?}
     * @private
     */
    NxAccordionDirective.prototype._style;
    /**
     * @type {?}
     * @private
     */
    NxAccordionDirective.prototype._negative;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYWNjb3JkaW9uLmpzIiwic291cmNlUm9vdCI6Im5nOi8vQGFsbGlhbnovbmd4LW5kYngvIiwic291cmNlcyI6WyJhY2NvcmRpb24vYWNjb3JkaW9uLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7O0FBQUEsT0FBTyxFQUFFLFNBQVMsRUFBRSxLQUFLLEVBQUUsTUFBTSxlQUFlLENBQUM7QUFDakQsT0FBTyxFQUFFLFlBQVksRUFBRSxNQUFNLHdCQUF3QixDQUFDO0FBQ3RELE9BQU8sRUFBRSxxQkFBcUIsRUFBRSxNQUFNLHVCQUF1QixDQUFDOztNQUd4RCxZQUFZLEdBQW1CLFNBQVM7QUFVOUMsTUFBTSxPQUFPLG9CQUFxQixTQUFRLFlBQVk7SUFSdEQ7O1FBVVUsV0FBTSxHQUFtQixTQUFTLENBQUM7UUFpQm5DLGNBQVMsR0FBWSxJQUFJLENBQUM7SUFVcEMsQ0FBQzs7Ozs7OztJQXJCQyxJQUNJLEtBQUssQ0FBQyxLQUFxQjtRQUM3QixLQUFLLEdBQUcsS0FBSyxDQUFDLENBQUMsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLFlBQVksQ0FBQztjQUUvQixDQUFDLFFBQVEsQ0FBQyxHQUFHLEtBQUssQ0FBQyxLQUFLLENBQUMsZUFBZSxDQUFDLElBQUksQ0FBQyxZQUFZLENBQUM7UUFDakUsSUFBSSxDQUFDLE1BQU0sR0FBRyxtQkFBQSxRQUFRLEVBQWtCLENBQUM7SUFDM0MsQ0FBQzs7OztJQUNELElBQUksS0FBSztRQUNQLE9BQU8sSUFBSSxDQUFDLE1BQU0sQ0FBQztJQUNyQixDQUFDOzs7Ozs7SUFLRCxJQUNJLFFBQVEsQ0FBQyxLQUFjO1FBQ3pCLElBQUksQ0FBQyxTQUFTLEdBQUcscUJBQXFCLENBQUMsS0FBSyxDQUFDLENBQUM7SUFDaEQsQ0FBQzs7OztJQUNELElBQUksUUFBUTtRQUNWLE9BQU8sSUFBSSxDQUFDLFNBQVMsQ0FBQztJQUN4QixDQUFDOzs7WUFwQ0YsU0FBUyxTQUFDOztnQkFFVCxRQUFRLEVBQUUsY0FBYztnQkFDeEIsSUFBSSxFQUFFO29CQUNKLHNCQUFzQixFQUFFLE1BQU07b0JBQzlCLE1BQU0sRUFBRSxjQUFjO2lCQUN2QjthQUNGOzs7b0JBU0UsS0FBSyxTQUFDLFNBQVM7dUJBY2YsS0FBSzs7Ozs7OztJQXBCTixzQ0FBMkM7Ozs7O0lBaUIzQyx5Q0FBa0MiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBEaXJlY3RpdmUsIElucHV0IH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBDZGtBY2NvcmRpb24gfSBmcm9tICdAYW5ndWxhci9jZGsvYWNjb3JkaW9uJztcbmltcG9ydCB7IGNvZXJjZUJvb2xlYW5Qcm9wZXJ0eSB9IGZyb20gJ0Bhbmd1bGFyL2Nkay9jb2VyY2lvbic7XG5pbXBvcnQgeyBBY2NvcmRpb25TdHlsZSB9IGZyb20gJy4vZXhwYW5zaW9uLXBhbmVsJztcblxuY29uc3QgREVGQVVMVF9UWVBFOiBBY2NvcmRpb25TdHlsZSA9ICdyZWd1bGFyJztcblxuQERpcmVjdGl2ZSh7XG4gIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTpkaXJlY3RpdmUtc2VsZWN0b3JcbiAgc2VsZWN0b3I6ICdueC1hY2NvcmRpb24nLFxuICBob3N0OiB7XG4gICAgJ1tjbGFzcy5ueC1hY2NvcmRpb25dJzogJ3RydWUnLFxuICAgICdyb2xlJzogJ3ByZXNlbnRhdGlvbidcbiAgfVxufSlcbmV4cG9ydCBjbGFzcyBOeEFjY29yZGlvbkRpcmVjdGl2ZSBleHRlbmRzIENka0FjY29yZGlvbiB7XG5cbiAgcHJpdmF0ZSBfc3R5bGU6IEFjY29yZGlvblN0eWxlID0gJ3JlZ3VsYXInO1xuXG4gIC8qKlxuICAgKiBWYWx1ZSBmb3IgdGhlIHN0eWxpbmcgdGhhdCBzaG91bGQgYmUgY2hvc2VuLlxuICAgKiBEZWZhdWx0IHZhbHVlOiAncmVndWxhcidcbiAgICovXG4gIEBJbnB1dCgnbnhTdHlsZScpXG4gIHNldCBzdHlsZSh2YWx1ZTogQWNjb3JkaW9uU3R5bGUpIHtcbiAgICB2YWx1ZSA9IHZhbHVlID8gdmFsdWUgOiBERUZBVUxUX1RZUEU7XG5cbiAgICBjb25zdCBbbmV3VmFsdWVdID0gdmFsdWUubWF0Y2goL3JlZ3VsYXJ8bGlnaHQvKSB8fCBbREVGQVVMVF9UWVBFXTtcbiAgICB0aGlzLl9zdHlsZSA9IG5ld1ZhbHVlIGFzIEFjY29yZGlvblN0eWxlO1xuICB9XG4gIGdldCBzdHlsZSgpOiBBY2NvcmRpb25TdHlsZSB7XG4gICAgcmV0dXJuIHRoaXMuX3N0eWxlO1xuICB9XG5cbiAgcHJpdmF0ZSBfbmVnYXRpdmU6IGJvb2xlYW4gPSBudWxsO1xuXG4gIC8qKiBXaGV0aGVyIHRoZSBuZWdhdGl2ZSBzZXQgb2Ygc3R5bGVzIHNob3VsZCBiZSB1c2VkLiAqL1xuICBASW5wdXQoKVxuICBzZXQgbmVnYXRpdmUodmFsdWU6IGJvb2xlYW4pIHtcbiAgICB0aGlzLl9uZWdhdGl2ZSA9IGNvZXJjZUJvb2xlYW5Qcm9wZXJ0eSh2YWx1ZSk7XG4gIH1cbiAgZ2V0IG5lZ2F0aXZlKCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0aGlzLl9uZWdhdGl2ZTtcbiAgfVxufVxuIl19