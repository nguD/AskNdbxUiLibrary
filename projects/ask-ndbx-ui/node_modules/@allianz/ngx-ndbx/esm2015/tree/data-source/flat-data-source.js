/**
 * @fileoverview added by tsickle
 * Generated from: data-source/flat-data-source.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import * as tslib_1 from "tslib";
import { DataSource } from '@angular/cdk/collections';
import { BehaviorSubject, merge } from 'rxjs';
import { map, take } from 'rxjs/operators';
/**
 * Tree flattener to convert a normal type of node to node with children & level information.
 * Transform nested nodes of type `T extends NxTreeNode` to flattened nodes of type `F extends NxFlatTreeNode`.
 *
 * For example, the input data of type `T` is nested, and contains its children data:
 *   SomeNode: {
 *     key: 'Fruits',
 *     children: [
 *       NodeOne: {
 *         key: 'Apple',
 *       },
 *       NodeTwo: {
 *        key: 'Pear',
 *      }
 *    ]
 *  }
 *  After flattener flatten the tree, the structure will become
 *  SomeNode: {
 *    key: 'Fruits',
 *    expandable: true,
 *    level: 1
 *  },
 *  NodeOne: {
 *    key: 'Apple',
 *    expandable: false,
 *    level: 2
 *  },
 *  NodeTwo: {
 *   key: 'Pear',
 *   expandable: false,
 *   level: 2
 * }
 * and the output flattened type is `F extends NxFlatTreeNode` with additional information.
 * @template T, F
 */
class NxTreeFlattener {
    /**
     * @param {?} node
     * @param {?} level
     * @return {?}
     */
    transformFunction(node, level) {
        const { children } = node, rest = tslib_1.__rest(node, ["children"]);
        return (/** @type {?} */ (Object.assign({}, rest, { level, expandable: Array.isArray(children) && children.length > 0 })));
    }
    /**
     * @param {?} node
     * @return {?}
     */
    getLevel(node) {
        return node.level;
    }
    /**
     * @param {?} node
     * @return {?}
     */
    isExpandable(node) {
        return node.expandable;
    }
    /**
     * @param {?} node
     * @return {?}
     */
    getChildren(node) {
        return (/** @type {?} */ (node.children));
    }
    /**
     * @param {?} node
     * @param {?} level
     * @param {?} resultNodes
     * @param {?} parentMap
     * @return {?}
     */
    _flattenNode(node, level, resultNodes, parentMap) {
        /** @type {?} */
        const flatNode = this.transformFunction(node, level);
        resultNodes.push(flatNode);
        if (this.isExpandable(flatNode)) {
            /** @type {?} */
            const childrenNodes = this.getChildren(node);
            if (Array.isArray(childrenNodes)) {
                this._flattenChildren(childrenNodes, level, resultNodes, parentMap);
            }
            else {
                childrenNodes.pipe(take(1)).subscribe((/**
                 * @param {?} children
                 * @return {?}
                 */
                children => {
                    this._flattenChildren(children, level, resultNodes, parentMap);
                }));
            }
        }
        return resultNodes;
    }
    /**
     * @param {?} children
     * @param {?} level
     * @param {?} resultNodes
     * @param {?} parentMap
     * @return {?}
     */
    _flattenChildren(children, level, resultNodes, parentMap) {
        children.forEach((/**
         * @param {?} child
         * @param {?} index
         * @return {?}
         */
        (child, index) => {
            /** @type {?} */
            const childParentMap = parentMap.slice();
            childParentMap.push(index != children.length - 1); // tslint:disable-line
            this._flattenNode(child, level + 1, resultNodes, childParentMap);
        }));
    }
    /**
     * Flatten a list of node type T to flattened version of node F.
     * Please note that type T may be nested, and the length of `structuredData` may be different
     * from that of returned list `F[]`.
     * @param {?} structuredData
     * @return {?}
     */
    flattenNodes(structuredData) {
        /** @type {?} */
        const resultNodes = [];
        structuredData.forEach((/**
         * @param {?} node
         * @return {?}
         */
        node => this._flattenNode(node, 0, resultNodes, [])));
        return resultNodes;
    }
    /**
     * Expand flattened node with current expansion status.
     * The returned list may have different length.
     * @param {?} nodes
     * @param {?} treeControl
     * @return {?}
     */
    expandFlattenedNodes(nodes, treeControl) {
        /** @type {?} */
        const results = [];
        /** @type {?} */
        const currentExpand = [];
        currentExpand[0] = true;
        nodes.forEach((/**
         * @param {?} node
         * @return {?}
         */
        node => {
            /** @type {?} */
            let expand = true;
            for (let i = 0; i <= this.getLevel(node); i++) {
                expand = expand && currentExpand[i];
            }
            if (expand) {
                results.push(node);
            }
            if (this.isExpandable(node)) {
                currentExpand[this.getLevel(node) + 1] = treeControl.isExpanded(node);
            }
        }));
        return results;
    }
}
/**
 * Data source for flat tree.
 * The data source need to handle expansion/collapsion of the tree node and change the data feed
 * to `NxTree`.
 * The nested tree nodes of type `T extends NxTreeNode` are flattened through `NxTreeFlattener`, and converted
 * to type `F extends NxFlatTreeNode` for `NxTree` to consume.
 * @template T, F
 */
export class NxTreeFlatDataSource extends DataSource {
    /**
     * @param {?} treeControl
     * @param {?=} initialData
     */
    constructor(treeControl, initialData = []) {
        super();
        this.treeControl = treeControl;
        this._flattenedData = new BehaviorSubject([]);
        this._expandedData = new BehaviorSubject([]);
        this._data = new BehaviorSubject([]);
        this._treeFlattener = new NxTreeFlattener();
        this.data = initialData;
    }
    /**
     * @return {?}
     */
    get data() { return this._data.value; }
    /**
     * @param {?} value
     * @return {?}
     */
    set data(value) {
        this._data.next(value);
        this._flattenedData.next(this._treeFlattener.flattenNodes(this.data));
        this.treeControl.dataNodes = this._flattenedData.value;
    }
    /**
     * @param {?} collectionViewer
     * @return {?}
     */
    connect(collectionViewer) {
        /** @type {?} */
        const changes = [
            collectionViewer.viewChange,
            this.treeControl.expansionModel.changed,
            this._flattenedData
        ];
        return merge(...changes).pipe(map((/**
         * @return {?}
         */
        () => {
            this._expandedData.next(this._treeFlattener.expandFlattenedNodes(this._flattenedData.value, this.treeControl));
            return this._expandedData.value;
        })));
    }
    /**
     * @return {?}
     */
    disconnect() {
        // no op
    }
}
if (false) {
    /** @type {?} */
    NxTreeFlatDataSource.prototype._treeFlattener;
    /** @type {?} */
    NxTreeFlatDataSource.prototype._flattenedData;
    /** @type {?} */
    NxTreeFlatDataSource.prototype._expandedData;
    /** @type {?} */
    NxTreeFlatDataSource.prototype._data;
    /**
     * @type {?}
     * @private
     */
    NxTreeFlatDataSource.prototype.treeControl;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZmxhdC1kYXRhLXNvdXJjZS5qcyIsInNvdXJjZVJvb3QiOiJuZzovL0BhbGxpYW56L25neC1uZGJ4L3RyZWUvIiwic291cmNlcyI6WyJkYXRhLXNvdXJjZS9mbGF0LWRhdGEtc291cmNlLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7OztBQUFBLE9BQU8sRUFBbUIsVUFBVSxFQUFDLE1BQU0sMEJBQTBCLENBQUM7QUFDdEUsT0FBTyxFQUFDLGVBQWUsRUFBRSxLQUFLLEVBQWlCLE1BQU0sTUFBTSxDQUFDO0FBQzVELE9BQU8sRUFBQyxHQUFHLEVBQUUsSUFBSSxFQUFDLE1BQU0sZ0JBQWdCLENBQUM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQXVDekMsTUFBTSxlQUFlOzs7Ozs7SUFDbkIsaUJBQWlCLENBQUMsSUFBZ0IsRUFBRSxLQUFhO2NBQ3pDLEVBQUUsUUFBUSxLQUFjLElBQUksRUFBaEIseUNBQU87UUFDekIsT0FBTyxxQ0FDRixJQUFJLElBQ1AsS0FBSyxFQUNMLFVBQVUsRUFBRSxLQUFLLENBQUMsT0FBTyxDQUFDLFFBQVEsQ0FBQyxJQUFJLFFBQVEsQ0FBQyxNQUFNLEdBQUcsQ0FBQyxLQUN0RCxDQUFDO0lBQ1QsQ0FBQzs7Ozs7SUFFRCxRQUFRLENBQUMsSUFBTztRQUNkLE9BQU8sSUFBSSxDQUFDLEtBQUssQ0FBQztJQUNwQixDQUFDOzs7OztJQUVELFlBQVksQ0FBQyxJQUFPO1FBQ2xCLE9BQU8sSUFBSSxDQUFDLFVBQVUsQ0FBQztJQUN6QixDQUFDOzs7OztJQUVELFdBQVcsQ0FBQyxJQUFPO1FBQ2pCLE9BQU8sbUJBQUEsSUFBSSxDQUFDLFFBQVEsRUFBTyxDQUFDO0lBQzlCLENBQUM7Ozs7Ozs7O0lBRUQsWUFBWSxDQUFDLElBQU8sRUFBRSxLQUFhLEVBQ3RCLFdBQWdCLEVBQUUsU0FBb0I7O2NBQzNDLFFBQVEsR0FBRyxJQUFJLENBQUMsaUJBQWlCLENBQUMsSUFBSSxFQUFFLEtBQUssQ0FBQztRQUNwRCxX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YSxDQUFDLEtBQUssQ0FBQztRQUNsQyxDQUFDLEVBQUMsQ0FBQyxDQUFDO0lBQ04sQ0FBQzs7OztJQUVELFVBQVU7UUFDUixRQUFRO0lBQ1YsQ0FBQztDQUNGOzs7SUF0Q0MsOENBQXNDOztJQUV0Qyw4Q0FBOEM7O0lBRTlDLDZDQUE2Qzs7SUFFN0MscUNBQXFDOzs7OztJQVN6QiwyQ0FBdUMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge0NvbGxlY3Rpb25WaWV3ZXIsIERhdGFTb3VyY2V9IGZyb20gJ0Bhbmd1bGFyL2Nkay9jb2xsZWN0aW9ucyc7XG5pbXBvcnQge0JlaGF2aW9yU3ViamVjdCwgbWVyZ2UsIE9ic2VydmFibGUsIG9mfSBmcm9tICdyeGpzJztcbmltcG9ydCB7bWFwLCB0YWtlfSBmcm9tICdyeGpzL29wZXJhdG9ycyc7XG5pbXBvcnQgeyBOeFRyZWVOb2RlLCBOeEZsYXRUcmVlTm9kZSB9IGZyb20gJy4vdHJlZS1ub2RlJztcbmltcG9ydCB7IE54RmxhdFRyZWVDb250cm9sIH0gZnJvbSAnLi9mbGF0LXRyZWUtY29udHJvbCc7XG5pbXBvcnQgeyBUcmVlQ29udHJvbCwgRmxhdFRyZWVDb250cm9sIH0gZnJvbSAnQGFuZ3VsYXIvY2RrL3RyZWUnO1xuXG4vKipcbiAqIFRyZWUgZmxhdHRlbmVyIHRvIGNvbnZlcnQgYSBub3JtYWwgdHlwZSBvZiBub2RlIHRvIG5vZGUgd2l0aCBjaGlsZHJlbiAmIGxldmVsIGluZm9ybWF0aW9uLlxuICogVHJhbnNmb3JtIG5lc3RlZCBub2RlcyBvZiB0eXBlIGBUIGV4dGVuZHMgTnhUcmVlTm9kZWAgdG8gZmxhdHRlbmVkIG5vZGVzIG9mIHR5cGUgYEYgZXh0ZW5kcyBOeEZsYXRUcmVlTm9kZWAuXG4gKlxuICogRm9yIGV4YW1wbGUsIHRoZSBpbnB1dCBkYXRhIG9mIHR5cGUgYFRgIGlzIG5lc3RlZCwgYW5kIGNvbnRhaW5zIGl0cyBjaGlsZHJlbiBkYXRhOlxuICogICBTb21lTm9kZToge1xuICogICAgIGtleTogJ0ZydWl0cycsXG4gKiAgICAgY2hpbGRyZW46IFtcbiAqICAgICAgIE5vZGVPbmU6IHtcbiAqICAgICAgICAga2V5OiAnQXBwbGUnLFxuICogICAgICAgfSxcbiAqICAgICAgIE5vZGVUd286IHtcbiAqICAgICAgICBrZXk6ICdQZWFyJyxcbiAqICAgICAgfVxuICogICAgXVxuICogIH1cbiAqICBBZnRlciBmbGF0dGVuZXIgZmxhdHRlbiB0aGUgdHJlZSwgdGhlIHN0cnVjdHVyZSB3aWxsIGJlY29tZVxuICogIFNvbWVOb2RlOiB7XG4gKiAgICBrZXk6ICdGcnVpdHMnLFxuICogICAgZXhwYW5kYWJsZTogdHJ1ZSxcbiAqICAgIGxldmVsOiAxXG4gKiAgfSxcbiAqICBOb2RlT25lOiB7XG4gKiAgICBrZXk6ICdBcHBsZScsXG4gKiAgICBleHBhbmRhYmxlOiBmYWxzZSxcbiAqICAgIGxldmVsOiAyXG4gKiAgfSxcbiAqICBOb2RlVHdvOiB7XG4gKiAgIGtleTogJ1BlYXInLFxuICogICBleHBhbmRhYmxlOiBmYWxzZSxcbiAqICAgbGV2ZWw6IDJcbiAqIH1cbiAqIGFuZCB0aGUgb3V0cHV0IGZsYXR0ZW5lZCB0eXBlIGlzIGBGIGV4dGVuZHMgTnhGbGF0VHJlZU5vZGVgIHdpdGggYWRkaXRpb25hbCBpbmZvcm1hdGlvbi5cbiAqL1xuY2xhc3MgTnhUcmVlRmxhdHRlbmVyPFQgZXh0ZW5kcyBOeFRyZWVOb2RlLCBGIGV4dGVuZHMgTnhGbGF0VHJlZU5vZGU+IHtcbiAgdHJhbnNmb3JtRnVuY3Rpb24obm9kZTogTnhUcmVlTm9kZSwgbGV2ZWw6IG51bWJlcik6IEYge1xuICAgIGNvbnN0IHsgY2hpbGRyZW4sIC4uLnJlc3QgfSA9IG5vZGU7XG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLnJlc3QsXG4gICAgICBsZXZlbCxcbiAgICAgIGV4cGFuZGFibGU6IEFycmF5LmlzQXJyYXkoY2hpbGRyZW4pICYmIGNoaWxkcmVuLmxlbmd0aCA+IDBcbiAgICB9IGFzIEY7XG4gIH1cblxuICBnZXRMZXZlbChub2RlOiBGKTogbnVtYmVyIHtcbiAgICByZXR1cm4gbm9kZS5sZXZlbDtcbiAgfVxuXG4gIGlzRXhwYW5kYWJsZShub2RlOiBGKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIG5vZGUuZXhwYW5kYWJsZTtcbiAgfVxuXG4gIGdldENoaWxkcmVuKG5vZGU6IFQpOiBPYnNlcnZhYmxlPFRbXT4gfCBUW10ge1xuICAgIHJldHVybiBub2RlLmNoaWxkcmVuIGFzIFRbXTtcbiAgfVxuXG4gIF9mbGF0dGVuTm9kZShub2RlOiBULCBsZXZlbDogbnVtYmVyLFxuICAgICAgICAgICAgICAgcmVzdWx0Tm9kZXM6IEZbXSwgcGFyZW50TWFwOiBib29sZWFuW10pOiBGW10ge1xuICAgIGNvbnN0IGZsYXROb2RlID0gdGhpcy50cmFuc2Zvcm1GdW5jdGlvbihub2RlLCBsZXZlbCk7XG4gICAgcmVzdWx0Tm9kZXMucHVzaChmbGF0Tm9kZSk7XG5cbiAgICBpZiAodGhpcy5pc0V4cGFuZGFibGUoZmxhdE5vZGUpKSB7XG4gICAgICBjb25zdCBjaGlsZHJlbk5vZGVzID0gdGhpcy5nZXRDaGlsZHJlbihub2RlKTtcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KGNoaWxkcmVuTm9kZXMpKSB7XG4gICAgICAgIHRoaXMuX2ZsYXR0ZW5DaGlsZHJlbihjaGlsZHJlbk5vZGVzLCBsZXZlbCwgcmVzdWx0Tm9kZXMsIHBhcmVudE1hcCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjaGlsZHJlbk5vZGVzLnBpcGUodGFrZSgxKSkuc3Vic2NyaWJlKGNoaWxkcmVuID0+IHtcbiAgICAgICAgICB0aGlzLl9mbGF0dGVuQ2hpbGRyZW4oY2hpbGRyZW4sIGxldmVsLCByZXN1bHROb2RlcywgcGFyZW50TWFwKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHROb2RlcztcbiAgfVxuXG4gIF9mbGF0dGVuQ2hpbGRyZW4oY2hpbGRyZW46IFRbXSwgbGV2ZWw6IG51bWJlcixcbiAgICAgICAgICAgICAgICAgICByZXN1bHROb2RlczogRltdLCBwYXJlbnRNYXA6IGJvb2xlYW5bXSk6IHZvaWQge1xuICAgIGNoaWxkcmVuLmZvckVhY2goKGNoaWxkLCBpbmRleCkgPT4ge1xuICAgICAgY29uc3QgY2hpbGRQYXJlbnRNYXA6IGJvb2xlYW5bXSA9IHBhcmVudE1hcC5zbGljZSgpO1xuICAgICAgY2hpbGRQYXJlbnRNYXAucHVzaChpbmRleCAhPSBjaGlsZHJlbi5sZW5ndGggLSAxKTsgLy8gdHNsaW50OmRpc2FibGUtbGluZVxuICAgICAgdGhpcy5fZmxhdHRlbk5vZGUoY2hpbGQsIGxldmVsICsgMSwgcmVzdWx0Tm9kZXMsIGNoaWxkUGFyZW50TWFwKTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBGbGF0dGVuIGEgbGlzdCBvZiBub2RlIHR5cGUgVCB0byBmbGF0dGVuZWQgdmVyc2lvbiBvZiBub2RlIEYuXG4gICAqIFBsZWFzZSBub3RlIHRoYXQgdHlwZSBUIG1heSBiZSBuZXN0ZWQsIGFuZCB0aGUgbGVuZ3RoIG9mIGBzdHJ1Y3R1cmVkRGF0YWAgbWF5IGJlIGRpZmZlcmVudFxuICAgKiBmcm9tIHRoYXQgb2YgcmV0dXJuZWQgbGlzdCBgRltdYC5cbiAgICovXG4gIGZsYXR0ZW5Ob2RlcyhzdHJ1Y3R1cmVkRGF0YTogVFtdKTogRltdIHtcbiAgICBjb25zdCByZXN1bHROb2RlczogRltdID0gW107XG4gICAgc3RydWN0dXJlZERhdGEuZm9yRWFjaChub2RlID0+IHRoaXMuX2ZsYXR0ZW5Ob2RlKG5vZGUsIDAsIHJlc3VsdE5vZGVzLCBbXSkpO1xuICAgIHJldHVybiByZXN1bHROb2RlcztcbiAgfVxuXG4gIC8qKlxuICAgKiBFeHBhbmQgZmxhdHRlbmVkIG5vZGUgd2l0aCBjdXJyZW50IGV4cGFuc2lvbiBzdGF0dXMuXG4gICAqIFRoZSByZXR1cm5lZCBsaXN0IG1heSBoYXZlIGRpZmZlcmVudCBsZW5ndGguXG4gICAqL1xuICBleHBhbmRGbGF0dGVuZWROb2Rlcyhub2RlczogRltdLCB0cmVlQ29udHJvbDogVHJlZUNvbnRyb2w8Rj4pOiBGW10ge1xuICAgIGNvbnN0IHJlc3VsdHM6IEZbXSA9IFtdO1xuICAgIGNvbnN0IGN1cnJlbnRFeHBhbmQ6IGJvb2xlYW5bXSA9IFtdO1xuICAgIGN1cnJlbnRFeHBhbmRbMF0gPSB0cnVlO1xuXG4gICAgbm9kZXMuZm9yRWFjaChub2RlID0+IHtcbiAgICAgIGxldCBleHBhbmQgPSB0cnVlO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPD0gdGhpcy5nZXRMZXZlbChub2RlKTsgaSsrKSB7XG4gICAgICAgIGV4cGFuZCA9IGV4cGFuZCAmJiBjdXJyZW50RXhwYW5kW2ldO1xuICAgICAgfVxuICAgICAgaWYgKGV4cGFuZCkge1xuICAgICAgICByZXN1bHRzLnB1c2gobm9kZSk7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5pc0V4cGFuZGFibGUobm9kZSkpIHtcbiAgICAgICAgY3VycmVudEV4cGFuZFt0aGlzLmdldExldmVsKG5vZGUpICsgMV0gPSB0cmVlQ29udHJvbC5pc0V4cGFuZGVkKG5vZGUpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiByZXN1bHRzO1xuICB9XG59XG5cbi8qKlxuICogRGF0YSBzb3VyY2UgZm9yIGZsYXQgdHJlZS5cbiAqIFRoZSBkYXRhIHNvdXJjZSBuZWVkIHRvIGhhbmRsZSBleHBhbnNpb24vY29sbGFwc2lvbiBvZiB0aGUgdHJlZSBub2RlIGFuZCBjaGFuZ2UgdGhlIGRhdGEgZmVlZFxuICogdG8gYE54VHJlZWAuXG4gKiBUaGUgbmVzdGVkIHRyZWUgbm9kZXMgb2YgdHlwZSBgVCBleHRlbmRzIE54VHJlZU5vZGVgIGFyZSBmbGF0dGVuZWQgdGhyb3VnaCBgTnhUcmVlRmxhdHRlbmVyYCwgYW5kIGNvbnZlcnRlZFxuICogdG8gdHlwZSBgRiBleHRlbmRzIE54RmxhdFRyZWVOb2RlYCBmb3IgYE54VHJlZWAgdG8gY29uc3VtZS5cbiAqL1xuZXhwb3J0IGNsYXNzIE54VHJlZUZsYXREYXRhU291cmNlPFQgZXh0ZW5kcyBOeFRyZWVOb2RlLCBGIGV4dGVuZHMgTnhGbGF0VHJlZU5vZGU+IGV4dGVuZHMgRGF0YVNvdXJjZTxGPiB7XG4gIF90cmVlRmxhdHRlbmVyOiBOeFRyZWVGbGF0dGVuZXI8VCwgRj47XG5cbiAgX2ZsYXR0ZW5lZERhdGEgPSBuZXcgQmVoYXZpb3JTdWJqZWN0PEZbXT4oW10pO1xuXG4gIF9leHBhbmRlZERhdGEgPSBuZXcgQmVoYXZpb3JTdWJqZWN0PEZbXT4oW10pO1xuXG4gIF9kYXRhID0gbmV3IEJlaGF2aW9yU3ViamVjdDxUW10+KFtdKTtcblxuICBnZXQgZGF0YSgpIHsgcmV0dXJuIHRoaXMuX2RhdGEudmFsdWU7IH1cbiAgc2V0IGRhdGEodmFsdWU6IFRbXSkge1xuICAgIHRoaXMuX2RhdGEubmV4dCh2YWx1ZSk7XG4gICAgdGhpcy5fZmxhdHRlbmVkRGF0YS5uZXh0KHRoaXMuX3RyZWVGbGF0dGVuZXIuZmxhdHRlbk5vZGVzKHRoaXMuZGF0YSkpO1xuICAgIHRoaXMudHJlZUNvbnRyb2wuZGF0YU5vZGVzID0gdGhpcy5fZmxhdHRlbmVkRGF0YS52YWx1ZTtcbiAgfVxuXG4gIGNvbnN0cnVjdG9yKHByaXZhdGUgdHJlZUNvbnRyb2w6IEZsYXRUcmVlQ29udHJvbDxGPixcbiAgICAgICAgICAgICAgaW5pdGlhbERhdGE6IFRbXSA9IFtdKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLl90cmVlRmxhdHRlbmVyID0gbmV3IE54VHJlZUZsYXR0ZW5lcigpO1xuICAgIHRoaXMuZGF0YSA9IGluaXRpYWxEYXRhO1xuICB9XG5cbiAgY29ubmVjdChjb2xsZWN0aW9uVmlld2VyOiBDb2xsZWN0aW9uVmlld2VyKTogT2JzZXJ2YWJsZTxGW10+IHtcbiAgICBjb25zdCBjaGFuZ2VzID0gW1xuICAgICAgY29sbGVjdGlvblZpZXdlci52aWV3Q2hhbmdlLFxuICAgICAgdGhpcy50cmVlQ29udHJvbC5leHBhbnNpb25Nb2RlbC5jaGFuZ2VkLFxuICAgICAgdGhpcy5fZmxhdHRlbmVkRGF0YVxuICAgIF07XG4gICAgcmV0dXJuIG1lcmdlKC4uLmNoYW5nZXMpLnBpcGUobWFwKCgpID0+IHtcbiAgICAgIHRoaXMuX2V4cGFuZGVkRGF0YS5uZXh0KFxuICAgICAgICB0aGlzLl90cmVlRmxhdHRlbmVyLmV4cGFuZEZsYXR0ZW5lZE5vZGVzKHRoaXMuX2ZsYXR0ZW5lZERhdGEudmFsdWUsIHRoaXMudHJlZUNvbnRyb2wpKTtcbiAgICAgIHJldHVybiB0aGlzLl9leHBhbmRlZERhdGEudmFsdWU7XG4gICAgfSkpO1xuICB9XG5cbiAgZGlzY29ubmVjdCgpIHtcbiAgICAvLyBubyBvcFxuICB9XG59XG4iXX0=