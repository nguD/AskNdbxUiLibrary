/**
 * @fileoverview added by tsickle
 * Generated from: number-stepper/auto-resize.directive.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import { getFontShorthand } from '@allianz/ngx-ndbx/utils';
import { coerceBooleanProperty } from '@angular/cdk/coercion';
import { ChangeDetectorRef, Directive, ElementRef, HostBinding, Input, Renderer2, } from '@angular/core';
/**
 * \@docs-private
 */
export class NxAutoResizeDirective {
    /**
     * @param {?} _element
     * @param {?} _renderer
     * @param {?} _cdr
     */
    constructor(_element, _renderer, _cdr) {
        this._element = _element;
        this._renderer = _renderer;
        this._cdr = _cdr;
        this._resize = true;
        this.updateInputWidth = this.updateInputWidth.bind(this);
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set resize(value) {
        this._resize = coerceBooleanProperty(value);
        if (this._resize) {
            this._addEventListener();
            this.updateInputWidth();
        }
        else {
            this._removeEventListener();
        }
    }
    /**
     * @return {?}
     */
    get resize() {
        return this._resize;
    }
    /**
     * @return {?}
     */
    ngAfterViewInit() {
        if (this.resize) {
            this._addEventListener();
        }
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this._removeEventListener();
    }
    /**
     * @return {?}
     */
    updateInputWidth() {
        /** @type {?} */
        const measureCanvas = this._renderer.createElement('canvas');
        /** @type {?} */
        const ctx = measureCanvas.getContext('2d');
        /** @type {?} */
        const styles = window.getComputedStyle(this._element.nativeElement);
        ctx.font = getFontShorthand(styles);
        /** @type {?} */
        const metrics = ctx.measureText(this._element.nativeElement.value);
        /** @type {?} */
        const padding = this.sumStyles(styles.paddingLeft, styles.paddingRight);
        /** @type {?} */
        const border = this.sumStyles(styles.borderLeftWidth, styles.borderRightWidth);
        // the pixels are needed, because despite the correct calculation the last pixels of a number are always cut
        /** @type {?} */
        const newWidth = metrics.width + padding + border + 16;
        // Limit to own given minimal width
        /** @type {?} */
        const parsed = parseFloat(styles.minWidth);
        this.width = Math.max(Number.isNaN(parsed) ? 0 : parsed, newWidth);
        // needed when the outer component is onPush
        this._cdr.markForCheck();
    }
    /**
     * @return {?}
     */
    _addEventListener() {
        this._element.nativeElement.addEventListener('input', this.updateInputWidth, true);
        this._element.nativeElement.addEventListener('change', this.updateInputWidth, true);
    }
    /**
     * @return {?}
     */
    _removeEventListener() {
        this._element.nativeElement.removeEventListener('input', this.updateInputWidth, true);
        this._element.nativeElement.removeEventListener('change', this.updateInputWidth, true);
    }
    /**
     * @param {?} left
     * @param {?} right
     * @return {?}
     */
    sumStyles(left, right) {
        left = parseInt(left, 10);
        right = parseInt(right, 10);
        left = Number.isNaN(left) ? 0 : left;
        right = Number.isNaN(right) ? 0 : right;
        return left + right;
    }
}
NxAutoResizeDirective.decorators = [
    { type: Directive, args: [{
                selector: 'input[nxAutoResize]'
            },] }
];
/** @nocollapse */
NxAutoResizeDirective.ctorParameters = () => [
    { type: ElementRef },
    { type: Renderer2 },
    { type: ChangeDetectorRef }
];
NxAutoResizeDirective.propDecorators = {
    width: [{ type: HostBinding, args: ['style.width.px',] }],
    resize: [{ type: Input, args: ['nxAutoResize',] }]
};
if (false) {
    /** @type {?} */
    NxAutoResizeDirective.prototype.width;
    /**
     * @type {?}
     * @private
     */
    NxAutoResizeDirective.prototype._resize;
    /**
     * @type {?}
     * @private
     */
    NxAutoResizeDirective.prototype._element;
    /**
     * @type {?}
     * @private
     */
    NxAutoResizeDirective.prototype._renderer;
    /**
     * @type {?}
     * @private
     */
    NxAutoResizeDirective.prototype._cdr;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYXV0by1yZXNpemUuZGlyZWN0aXZlLmpzIiwic291cmNlUm9vdCI6Im5nOi8vQGFsbGlhbnovbmd4LW5kYngvIiwic291cmNlcyI6WyJudW1iZXItc3RlcHBlci9hdXRvLXJlc2l6ZS5kaXJlY3RpdmUudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQSxPQUFPLEVBQUUsZ0JBQWdCLEVBQUUsTUFBTSx5QkFBeUIsQ0FBQztBQUMzRCxPQUFPLEVBQUUscUJBQXFCLEVBQUUsTUFBTSx1QkFBdUIsQ0FBQztBQUM5RCxPQUFPLEVBRUwsaUJBQWlCLEVBQ2pCLFNBQVMsRUFDVCxVQUFVLEVBQ1YsV0FBVyxFQUNYLEtBQUssRUFFTCxTQUFTLEdBQ1YsTUFBTSxlQUFlLENBQUM7Ozs7QUFNdkIsTUFBTSxPQUFPLHFCQUFxQjs7Ozs7O0lBbUJoQyxZQUFvQixRQUFvQixFQUNwQixTQUFvQixFQUNwQixJQUF1QjtRQUZ2QixhQUFRLEdBQVIsUUFBUSxDQUFZO1FBQ3BCLGNBQVMsR0FBVCxTQUFTLENBQVc7UUFDcEIsU0FBSSxHQUFKLElBQUksQ0FBbUI7UUFqQm5DLFlBQU8sR0FBWSxJQUFJLENBQUM7UUFrQjlCLElBQUksQ0FBQyxnQkFBZ0IsR0FBRyxJQUFJLENBQUMsZ0JBQWdCLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDO0lBQzNELENBQUM7Ozs7O0lBbEJELElBQ0ksTUFBTSxDQUFDLEtBQWM7UUFDdkIsSUFBSSxDQUFDLE9BQU8sR0FBRyxxQkFBcUIsQ0FBQyxLQUFLLENBQUMsQ0FBQztRQUM1QyxJQUFJLElBQUksQ0FBQyxPQUFPLEVBQUU7WUFDaEIsSUFBSSxDQUFDLGlCQUFpQixFQUFFLENBQUM7WUFDekIsSUFBSSxDQUFDLGdCQUFnQixFQUFFLENBQUM7U0FDekI7YUFBTTtZQUNMLElBQUksQ0FBQyxvQkFBb0IsRUFBRSxDQUFDO1NBQzdCO0lBQ0gsQ0FBQzs7OztJQUNELElBQUksTUFBTTtRQUNSLE9BQU8sSUFBSSxDQUFDLE9BQU8s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WUFJVixTQUFTO1lBTlQsaUJBQWlCOzs7b0JBZWhCLFdBQVcsU0FBQyxnQkFBZ0I7cUJBRzVCLEtBQUssU0FBQyxjQUFjOzs7O0lBSHJCLHNDQUE2Qzs7Ozs7SUFFN0Msd0NBQWdDOzs7OztJQWVwQix5Q0FBNEI7Ozs7O0lBQzVCLDBDQUE0Qjs7Ozs7SUFDNUIscUNBQStCIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgZ2V0Rm9udFNob3J0aGFuZCB9IGZyb20gJ0BhbGxpYW56L25neC1uZGJ4L3V0aWxzJztcbmltcG9ydCB7IGNvZXJjZUJvb2xlYW5Qcm9wZXJ0eSB9IGZyb20gJ0Bhbmd1bGFyL2Nkay9jb2VyY2lvbic7XG5pbXBvcnQge1xuICBBZnRlclZpZXdJbml0LFxuICBDaGFuZ2VEZXRlY3RvclJlZixcbiAgRGlyZWN0aXZlLFxuICBFbGVtZW50UmVmLFxuICBIb3N0QmluZGluZyxcbiAgSW5wdXQsXG4gIE9uRGVzdHJveSxcbiAgUmVuZGVyZXIyLFxufSBmcm9tICdAYW5ndWxhci9jb3JlJztcblxuLyoqIEBkb2NzLXByaXZhdGUgKi9cbkBEaXJlY3RpdmUoe1xuICBzZWxlY3RvcjogJ2lucHV0W254QXV0b1Jlc2l6ZV0nXG59KVxuZXhwb3J0IGNsYXNzIE54QXV0b1Jlc2l6ZURpcmVjdGl2ZSBpbXBsZW1lbnRzIEFmdGVyVmlld0luaXQsIE9uRGVzdHJveSB7XG5cbiAgQEhvc3RCaW5kaW5nKCdzdHlsZS53aWR0aC5weCcpIHdpZHRoOiBudW1iZXI7XG5cbiAgcHJpdmF0ZSBfcmVzaXplOiBib29sZWFuID0gdHJ1ZTtcbiAgQElucHV0KCdueEF1dG9SZXNpemUnKVxuICBzZXQgcmVzaXplKHZhbHVlOiBib29sZWFuKSB7XG4gICAgdGhpcy5fcmVzaXplID0gY29lcmNlQm9vbGVhblByb3BlcnR5KHZhbHVlKTtcbiAgICBpZiAodGhpcy5fcmVzaXplKSB7XG4gICAgICB0aGlzLl9hZGRFdmVudExpc3RlbmVyKCk7XG4gICAgICB0aGlzLnVwZGF0ZUlucHV0V2lkdGgoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fcmVtb3ZlRXZlbnRMaXN0ZW5lcigpO1xuICAgIH1cbiAgfVxuICBnZXQgcmVzaXplKCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0aGlzLl9yZXNpemU7XG4gIH1cblxuICBjb25zdHJ1Y3Rvcihwcml2YXRlIF9lbGVtZW50OiBFbGVtZW50UmVmLFxuICAgICAgICAgICAgICBwcml2YXRlIF9yZW5kZXJlcjogUmVuZGVyZXIyLFxuICAgICAgICAgICAgICBwcml2YXRlIF9jZHI6IENoYW5nZURldGVjdG9yUmVmKSB7XG4gICAgdGhpcy51cGRhdGVJbnB1dFdpZHRoID0gdGhpcy51cGRhdGVJbnB1dFdpZHRoLmJpbmQodGhpcyk7XG4gIH1cblxuICBuZ0FmdGVyVmlld0luaXQoKSB7XG4gICAgaWYgKHRoaXMucmVzaXplKSB7XG4gICAgICB0aGlzLl9hZGRFdmVudExpc3RlbmVyKCk7XG4gICAgfVxuICB9XG5cbiAgbmdPbkRlc3Ryb3koKSB7XG4gICAgdGhpcy5fcmVtb3ZlRXZlbnRMaXN0ZW5lcigpO1xuICB9XG5cbiAgdXBkYXRlSW5wdXRXaWR0aCgpIHtcbiAgICBjb25zdCBtZWFzdXJlQ2FudmFzID0gdGhpcy5fcmVuZGVyZXIuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XG5cbiAgICBjb25zdCBjdHggPSBtZWFzdXJlQ2FudmFzLmdldENvbnRleHQoJzJkJyk7XG4gICAgY29uc3Qgc3R5bGVzID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUodGhpcy5fZWxlbWVudC5uYXRpdmVFbGVtZW50KTtcblxuICAgIGN0eC5mb250ID0gZ2V0Rm9udFNob3J0aGFuZChzdHlsZXMpO1xuXG4gICAgY29uc3QgbWV0cmljcyA9IGN0eC5tZWFzdXJlVGV4dCh0aGlzLl9lbGVtZW50Lm5hdGl2ZUVsZW1lbnQudmFsdWUpO1xuXG4gICAgY29uc3QgcGFkZGluZyA9IHRoaXMuc3VtU3R5bGVzKHN0eWxlcy5wYWRkaW5nTGVmdCwgc3R5bGVzLnBhZGRpbmdSaWdodCk7XG4gICAgY29uc3QgYm9yZGVyID0gdGhpcy5zdW1TdHlsZXMoc3R5bGVzLmJvcmRlckxlZnRXaWR0aCwgc3R5bGVzLmJvcmRlclJpZ2h0V2lkdGgpO1xuICAgIC8vIHRoZSBwaXhlbHMgYXJlIG5lZWRlZCwgYmVjYXVzZSBkZXNwaXRlIHRoZSBjb3JyZWN0IGNhbGN1bGF0aW9uIHRoZSBsYXN0IHBpeGVscyBvZiBhIG51bWJlciBhcmUgYWx3YXlzIGN1dFxuICAgIGNvbnN0IG5ld1dpZHRoID0gbWV0cmljcy53aWR0aCArIHBhZGRpbmcgKyBib3JkZXIgKyAxNjtcblxuICAgIC8vIExpbWl0IHRvIG93biBnaXZlbiBtaW5pbWFsIHdpZHRoXG4gICAgY29uc3QgcGFyc2VkID0gcGFyc2VGbG9hdChzdHlsZXMubWluV2lkdGgpO1xuICAgIHRoaXMud2lkdGggPSBNYXRoLm1heChOdW1iZXIuaXNOYU4ocGFyc2VkKSA/IDAgOiBwYXJzZWQsIG5ld1dpZHRoKTtcblxuICAgIC8vIG5lZWRlZCB3aGVuIHRoZSBvdXRlciBjb21wb25lbnQgaXMgb25QdXNoXG4gICAgdGhpcy5fY2RyLm1hcmtGb3JDaGVjaygpO1xuICB9XG5cbiAgX2FkZEV2ZW50TGlzdGVuZXIoKSB7XG4gICAgdGhpcy5fZWxlbWVudC5uYXRpdmVFbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2lucHV0JywgdGhpcy51cGRhdGVJbnB1dFdpZHRoLCB0cnVlKTtcbiAgICB0aGlzLl9lbGVtZW50Lm5hdGl2ZUVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignY2hhbmdlJywgdGhpcy51cGRhdGVJbnB1dFdpZHRoLCB0cnVlKTtcbiAgfVxuXG4gIF9yZW1vdmVFdmVudExpc3RlbmVyKCkge1xuICAgIHRoaXMuX2VsZW1lbnQubmF0aXZlRWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdpbnB1dCcsIHRoaXMudXBkYXRlSW5wdXRXaWR0aCwgdHJ1ZSk7XG4gICAgdGhpcy5fZWxlbWVudC5uYXRpdmVFbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NoYW5nZScsIHRoaXMudXBkYXRlSW5wdXRXaWR0aCwgdHJ1ZSk7XG4gIH1cblxuICBzdW1TdHlsZXMobGVmdCwgcmlnaHQpIHtcbiAgICBsZWZ0ID0gcGFyc2VJbnQobGVmdCwgMTApO1xuICAgIHJpZ2h0ID0gcGFyc2VJbnQocmlnaHQsIDEwKTtcbiAgICBsZWZ0ID0gTnVtYmVyLmlzTmFOKGxlZnQpID8gMCA6IGxlZnQ7XG4gICAgcmlnaHQgPSBOdW1iZXIuaXNOYU4ocmlnaHQpID8gMCA6IHJpZ2h0O1xuICAgIHJldHVybiBsZWZ0ICsgcmlnaHQ7XG4gIH1cbn1cbiJdfQ==