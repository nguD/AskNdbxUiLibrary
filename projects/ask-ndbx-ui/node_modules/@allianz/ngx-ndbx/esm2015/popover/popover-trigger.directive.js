/**
 * @fileoverview added by tsickle
 * Generated from: popover/popover-trigger.directive.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import { coerceBooleanProperty } from '@angular/cdk/coercion';
import { Overlay, OverlayConfig } from '@angular/cdk/overlay';
import { TemplatePortal } from '@angular/cdk/portal';
import { Directive, ElementRef, EventEmitter, Inject, Input, Optional, Output, ViewContainerRef, NgZone } from '@angular/core';
import { EventManager } from '@angular/platform-browser';
import { fromEvent, Subject } from 'rxjs';
import { filter, map, takeUntil } from 'rxjs/operators';
import { FocusMonitor } from '@angular/cdk/a11y';
import { NxPopoverComponent } from './popover.component';
import { FocusTrapFactory } from '@angular/cdk/a11y';
import { DOCUMENT } from '@angular/common';
import { Platform } from '@angular/cdk/platform';
import { SPACE, ENTER } from '@angular/cdk/keycodes';
/** @type {?} */
let nextId = 0;
/** @type {?} */
const fallbacks = [
    {
        originX: 'start',
        originY: 'bottom',
        overlayX: 'start',
        overlayY: 'top',
        offsetX: 0,
        offsetY: 16
    },
    {
        originX: 'end',
        originY: 'top',
        overlayX: 'end',
        overlayY: 'bottom',
        offsetX: 0,
        offsetY: -16
    },
    {
        originX: 'center',
        originY: 'bottom',
        overlayX: 'center',
        overlayY: 'top',
        offsetX: 0,
        offsetY: 16
    },
    {
        originX: 'end',
        originY: 'bottom',
        overlayX: 'end',
        overlayY: 'top',
        offsetX: 0,
        offsetY: 16
    },
    {
        originX: 'end',
        originY: 'center',
        overlayX: 'start',
        overlayY: 'center',
        offsetX: 16,
        offsetY: 0
    },
    {
        originX: 'start',
        originY: 'center',
        overlayX: 'end',
        overlayY: 'center',
        offsetX: -16,
        offsetY: 0
    },
    {
        originX: 'center',
        originY: 'top',
        overlayX: 'center',
        overlayY: 'bottom',
        offsetX: 0,
        offsetY: -16
    },
    {
        originX: 'start',
        originY: 'top',
        overlayX: 'start',
        overlayY: 'bottom',
        offsetX: 0,
        offsetY: -16
    }
];
export class NxPopoverTriggerDirective {
    /**
     * @param {?} overlay
     * @param {?} elementRef
     * @param {?} viewContainerRef
     * @param {?} eventManager
     * @param {?} _focusTrapFactory
     * @param {?} _focusMonitor
     * @param {?} _ngZone
     * @param {?} _platform
     * @param {?} _document
     */
    constructor(overlay, elementRef, viewContainerRef, eventManager, _focusTrapFactory, _focusMonitor, _ngZone, _platform, _document) {
        this.overlay = overlay;
        this.elementRef = elementRef;
        this.viewContainerRef = viewContainerRef;
        this.eventManager = eventManager;
        this._focusTrapFactory = _focusTrapFactory;
        this._focusMonitor = _focusMonitor;
        this._ngZone = _ngZone;
        this._platform = _platform;
        this._document = _document;
        this._destroyed = new Subject();
        this._show = false;
        this._closeable = null;
        /**
         * Element that was focused before the Popover was opened. Save this to restore upon close.
         */
        this._elementFocusedBeforePopoverWasOpened = null;
        this._manualListeners = new Map();
        /**
         * \@docs-private
         */
        this.id = 'nx-popover-' + nextId++;
        /**
         * An event is emitted if the visibility status of the popover changes.
         */
        this.changeShow = new EventEmitter();
        this._closeOnClickOutside = true;
        /**
         * Sets the desired direction to open the popover. E.g., right, left, bottom, top
         */
        this.direction = 'right';
        /**
         * Whether the popover will be opened automatically.
         */
        this.popoverInitialVisible = false;
        /**
         * An event is emitted when the visibility of the popopver changes.
         */
        this.visibleChange = new EventEmitter();
        /**
         * Whether the popover opens in modal state.
         */
        this.modal = false;
        // If nxPopoverTrigger equals to 'hover' the popover opens on mouseenter and closes on mouseout.
        // If nxPopoverTrigger equals to 'click' the popover opens on click and closes on a click of the close icon or pressing ESC key.
        // If nxPopoverTrigger equals to 'manual' the popover opens only when programatically requested.
        /**
         * Sets the way to trigger the popover. Options are hover, click, manual
         */
        this.trigger = 'click';
        /**
         * Sets the scroll strategy. 'close' closes the popover on scroll while 'reposition' scrolls the popover with the origin.
         */
        this.scrollStrategy = 'close';
        this._documentClickObservable = fromEvent(document, 'click');
        /** @type {?} */
        const element = elementRef.nativeElement;
        if (!this._platform.IOS && !this._platform.ANDROID) {
            this._manualListeners
                .set('mouseenter', (/**
             * @return {?}
             */
            () => {
                if (this.trigger === 'hover') {
                    this.show = true;
                }
            }))
                .set('mouseleave', (/**
             * @return {?}
             */
            () => {
                if (this.trigger === 'hover') {
                    this.show = false;
                }
            }))
                .set('keydown', (/**
             * @param {?} event
             * @return {?}
             */
            (event) => {
                switch (event.keyCode) {
                    case SPACE:
                    case ENTER:
                        this.handleClick();
                        break;
                    default:
                        return;
                }
            }));
        }
        else {
            this._manualListeners.set('touchstart', (/**
             * @return {?}
             */
            () => {
                if (this.trigger === 'hover') {
                    this.show = true;
                }
            }));
        }
        this._manualListeners.forEach((/**
         * @param {?} listener
         * @param {?} event
         * @return {?}
         */
        (listener, event) => element.addEventListener(event, listener)));
        this._focusMonitor.monitor(element).pipe(takeUntil(this._destroyed)).subscribe((/**
         * @param {?} origin
         * @return {?}
         */
        origin => {
            if (origin === 'keyboard' && this.trigger === 'hover') {
                this._ngZone.run((/**
                 * @return {?}
                 */
                () => this.show = true));
            }
        }));
    }
    /**
     * Whether to show or hide the popover.
     * @param {?} value
     * @return {?}
     */
    set show(value) {
        value = coerceBooleanProperty(value);
        if (this._show !== value) {
            this._show = value;
            if (this._show) {
                this.openPopover();
            }
            else {
                this.closePopover();
            }
        }
    }
    /**
     * @return {?}
     */
    get show() {
        return this._show;
    }
    /**
     * Whether to show a close button. By default a close icon is only shown for trigger type click.
     * @param {?} value
     * @return {?}
     */
    set closeable(value) {
        this._closeable = coerceBooleanProperty(value);
        if (this.popover) {
            this.popover.showCloseButton = this.isCloseable();
        }
    }
    /**
     * @return {?}
     */
    get closeable() {
        return this._closeable;
    }
    /**
     * Whether the popover should be closed on click outside of the popover in the trigger modes 'manual' and 'click'.
     * @param {?} value
     * @return {?}
     */
    set closeOnClickOutside(value) {
        this._closeOnClickOutside = coerceBooleanProperty(value);
    }
    /**
     * @return {?}
     */
    get closeOnClickOutside() {
        return this._closeOnClickOutside;
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.popover.showCloseButton = this.isCloseable();
    }
    /**
     * @return {?}
     */
    ngAfterViewInit() {
        this.popover.id = this.id;
        this.eventManager.addGlobalEventListener('window', 'keyup.esc', (/**
         * @return {?}
         */
        () => {
            if (this.isOpen) {
                this.show = false;
            }
        }));
        this.popover.closeButtonClick.pipe(takeUntil(this._destroyed)).subscribe((/**
         * @return {?}
         */
        () => {
            this.show = false;
        }));
        if (this.popoverInitialVisible || this._show) {
            this.show = true;
        }
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this.show = false;
        // Clean up the event listeners set in the constructor
        this._manualListeners.forEach((/**
         * @param {?} listener
         * @param {?} event
         * @return {?}
         */
        (listener, event) => {
            this.elementRef.nativeElement.removeEventListener(event, listener);
        }));
        this._manualListeners.clear();
        this._destroyed.next();
        this._destroyed.complete();
    }
    /**
     * \@docs-private
     * @return {?}
     */
    get isOpen() {
        return this.overlayRef && this.createOverlay().hasAttached();
    }
    /**
     * \@docs-private
     * @return {?}
     */
    isCloseable() {
        return (this.trigger === 'click' && this._closeable === null) || this._closeable;
    }
    /**
     * Update the popover with the given position strategy.
     * @return {?}
     */
    updatePosition() {
        if (this._positionStrategy) {
            this._positionStrategy.apply();
        }
    }
    /**
     * \@docs-private
     * @return {?}
     */
    handleClick() {
        if (this.trigger === 'click') {
            this.show = !this.isOpen;
        }
        else if (this.trigger === 'hover') {
            this.show = true;
        }
    }
    /**
     * Open the popover instance.
     * @return {?}
     */
    open() {
        this.show = true;
    }
    /**
     * Close the popover instance.
     * @return {?}
     */
    close() {
        this.show = false;
    }
    /**
     * Toggle the popover instance.
     * @return {?}
     */
    toggle() {
        this.show = !this.show;
    }
    /**
     * @private
     * @return {?}
     */
    openPopover() {
        if (!this.createOverlay().hasAttached()) {
            this._embeddedViewRef = this.createOverlay().attach(this.portal);
            /** @type {?} */
            const element = (/** @type {?} */ (this._embeddedViewRef.rootNodes[0]));
            this._focusTrap = this._focusTrapFactory.create(element);
            this._elementFocusedBeforePopoverWasOpened = this.elementRef.nativeElement;
            this._autoFocusFirstTabbableElement(element);
            // attach a close click listener only if it makes sense (ignore it on hover e.g.)
            if (this.shouldReactOnClickOutside()) {
                this.waitForClose();
            }
        }
    }
    /**
     * Autofocus the first tabbable element inside of the popover, if there is not a tabbable element,
     * focus the popover instead.
     * @private
     * @param {?} element
     * @return {?}
     */
    _autoFocusFirstTabbableElement(element) {
        this._focusTrap.focusInitialElementWhenReady().then((/**
         * @param {?} hasMovedFocus
         * @return {?}
         */
        hasMovedFocus => {
            // If we didn't find any focusable elements inside the popover, focus the
            // container so the user can't tab into other elements behind it.
            if (!hasMovedFocus) {
                element.focus();
            }
        }));
    }
    /**
     * @private
     * @return {?}
     */
    shouldReactOnClickOutside() {
        return (!this.modal && this.closeOnClickOutside);
    }
    // detaches the overlay
    // we are listening to the detachments observable which will then emit the nxClosed event
    // on the popover component
    /**
     * @private
     * @return {?}
     */
    closePopover() {
        if (this.overlayRef) {
            this._returnFocusAfterPopover();
            this.overlayRef.detach();
            this._embeddedViewRef = null;
            this._focusTrap.destroy();
        }
    }
    /**
     * @private
     * @return {?}
     */
    createOverlay() {
        if (!this.overlayRef) {
            this.portal = new TemplatePortal(this.popover.templateRef, this.viewContainerRef);
            /** @type {?} */
            const overlayState = new OverlayConfig();
            overlayState.positionStrategy = this.getPosition();
            this._positionStrategy = overlayState.positionStrategy;
            if (this.scrollStrategy === 'reposition') {
                overlayState.scrollStrategy = this.overlay.scrollStrategies.reposition();
            }
            else {
                overlayState.scrollStrategy = this.overlay.scrollStrategies.close();
            }
            overlayState.scrollStrategy.enable();
            if (this.modal && this.trigger === 'click') {
                overlayState.hasBackdrop = true;
            }
            this.overlayRef = this.overlay.create(overlayState);
            this.subscribeToPositions((/** @type {?} */ (overlayState.positionStrategy)));
            this._subscribeToAttach();
            this._subscribeToDetach();
            if (this.modal) {
                this._subscribeToBackdropClick();
            }
        }
        return this.overlayRef;
    }
    /**
     * @private
     * @param {?} position
     * @return {?}
     */
    subscribeToPositions(position) {
        position.positionChanges.pipe(takeUntil(this._destroyed)).subscribe((/**
         * @param {?} change
         * @return {?}
         */
        change => {
            /** @type {?} */
            const pair = change.connectionPair;
            this.positionOverlay(pair);
            this.positionArrow(pair);
            // These position changes arrive too late,
            // We have to trigger the change detection manually
            // as it's detached from any render hierarchy
            // and only updated by the overlay when attached.
            if (this._embeddedViewRef && !this._embeddedViewRef.destroyed) {
                this._embeddedViewRef.detectChanges();
            }
        }));
    }
    // for modal popovers close the popover on backdrop clicks
    /**
     * @private
     * @return {?}
     */
    _subscribeToBackdropClick() {
        this.overlayRef.backdropClick().pipe(takeUntil(this._destroyed)).subscribe((/**
         * @param {?} event
         * @return {?}
         */
        (event) => {
            this.show = false;
        }));
    }
    // Emit the nxClosed and the show status change event on the popover component when the overlay detaches
    /**
     * @private
     * @return {?}
     */
    _subscribeToDetach() {
        this.overlayRef.detachments().pipe(takeUntil(this._destroyed)).subscribe((/**
         * @param {?} data
         * @return {?}
         */
        data => {
            // This is an exception: when the popover is closed by a scrolling event,
            // then only the detached method is called but the show state variable remains unchanged.
            if (this.show) {
                this.show = false;
            }
            this.changeShow.emit(this._show);
            this.popover.emitClosedEvent();
        }));
    }
    /**
     * @private
     * @return {?}
     */
    _subscribeToAttach() {
        this.overlayRef.attachments().pipe(takeUntil(this._destroyed)).subscribe((/**
         * @param {?} data
         * @return {?}
         */
        data => {
            this.changeShow.emit(this._show);
        }));
    }
    // subscribe to document clicks when trigger='click' to close the popover on clicks on the background
    /**
     * @private
     * @return {?}
     */
    waitForClose() {
        return this._documentClickObservable
            .pipe(map((/**
         * @param {?} event
         * @return {?}
         */
        event => event.target)), filter((/**
         * @param {?} target
         * @return {?}
         */
        target => !this.elementRef.nativeElement.contains(target))), takeUntil(this.popover.closed))
            .subscribe((/**
         * @return {?}
         */
        () => {
            this.show = false;
        }));
    }
    /**
     * @private
     * @param {?} pair
     * @return {?}
     */
    positionOverlay(pair) {
        if (pair.originX === 'end' && pair.overlayX === 'start') {
            this.popover.direction = 'right';
        }
        else if (pair.originY === 'bottom' && pair.overlayY === 'top') {
            this.popover.direction = 'bottom';
        }
        else if (pair.originX === 'start' && pair.overlayX === 'end') {
            this.popover.direction = 'left';
        }
        else if (pair.originY === 'top' && pair.overlayY === 'bottom') {
            this.popover.direction = 'top';
        }
    }
    /**
     * @private
     * @param {?} pair
     * @return {?}
     */
    positionArrow(pair) {
        /** @type {?} */
        const parentElementPositionX = this.elementRef.nativeElement.getBoundingClientRect().left;
        /** @type {?} */
        const parentElementWidth = this.elementRef.nativeElement.getBoundingClientRect().width / 2;
        /** @type {?} */
        const parentElementLeftOffset = this.overlayRef.overlayElement.parentElement.offsetLeft;
        /** @type {?} */
        const overlayElementLeftOffset = this.overlayRef.overlayElement.offsetLeft;
        // calculation for x position of the parent element. In this case, overlay left offset is the one thing to consider.
        /** @type {?} */
        const targetPosition = (parentElementPositionX + parentElementWidth) - (parentElementLeftOffset + overlayElementLeftOffset);
        if (pair.originX === pair.overlayX) {
            /** @type {?} */
            const direction = 'left';
            /** @type {?} */
            const arrowStyle = {};
            arrowStyle[direction] = targetPosition + 'px';
            this.popover.arrowStyle = arrowStyle;
        }
        if ((pair.originY === 'bottom' || pair.originY === 'top') && pair.overlayX === 'center') {
            this.popover.arrowStyle = { left: targetPosition + 'px' };
        }
        if ((pair.originX === 'end' || pair.originX === 'start') && pair.overlayY === 'center') {
            this.popover.arrowStyle = { top: '50%' };
        }
    }
    /**
     * @private
     * @return {?}
     */
    getPosition() {
        /** @type {?} */
        let positions;
        /** @type {?} */
        let offsetX = 0;
        /** @type {?} */
        let offsetY = 0;
        if (this.direction === 'top') {
            positions = [{
                    overlayX: 'center',
                    overlayY: 'bottom',
                    originX: 'center',
                    originY: 'top'
                }];
            offsetX = 0;
            offsetY = -20;
        }
        else if (this.direction === 'right') {
            positions = [{
                    overlayX: 'start',
                    overlayY: 'center',
                    originX: 'end',
                    originY: 'center'
                }];
            offsetX = 20;
            offsetY = 0;
        }
        else if (this.direction === 'bottom') {
            positions = [{
                    overlayX: 'center',
                    overlayY: 'top',
                    originX: 'center',
                    originY: 'bottom'
                }];
            offsetX = 0;
            offsetY = 20;
        }
        else if (this.direction === 'left') {
            positions = [{
                    overlayX: 'end',
                    overlayY: 'center',
                    originX: 'start',
                    originY: 'center'
                }];
            offsetX = -20;
            offsetY = 0;
        }
        return this.overlay.position().flexibleConnectedTo(this.elementRef)
            .withPositions([...positions, ...fallbacks])
            .withDefaultOffsetX(offsetX)
            .withDefaultOffsetY(offsetY);
    }
    /**
     * Returns the focus to the element focused before the Popover was open.
     * @private
     * @return {?}
     */
    _returnFocusAfterPopover() {
        /** @type {?} */
        const toFocus = this._elementFocusedBeforePopoverWasOpened;
        // We need the extra check, because IE can set the `activeElement` to null in some cases.
        if (toFocus && typeof toFocus.focus === 'function') {
            toFocus.focus();
        }
    }
}
NxPopoverTriggerDirective.decorators = [
    { type: Directive, args: [{
                selector: '[nxPopoverTriggerFor]',
                exportAs: 'nxPopoverTrigger',
                host: {
                    '(click)': 'handleClick()',
                    'aria-haspopup': 'true',
                    '[attr.aria-expanded]': 'isOpen',
                    '[attr.aria-describedby]': 'isOpen ? id : null'
                }
            },] }
];
/** @nocollapse */
NxPopoverTriggerDirective.ctorParameters = () => [
    { type: Overlay },
    { type: ElementRef },
    { type: ViewContainerRef },
    { type: EventManager },
    { type: FocusTrapFactory },
    { type: FocusMonitor },
    { type: NgZone },
    { type: Platform },
    { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [DOCUMENT,] }] }
];
NxPopoverTriggerDirective.propDecorators = {
    changeShow: [{ type: Output, args: ['nxPopoverShowChange',] }],
    show: [{ type: Input, args: ['nxPopoverShow',] }],
    closeable: [{ type: Input, args: ['nxPopoverCloseable',] }],
    closeOnClickOutside: [{ type: Input }],
    popover: [{ type: Input, args: ['nxPopoverTriggerFor',] }],
    direction: [{ type: Input, args: ['nxPopoverDirection',] }],
    popoverInitialVisible: [{ type: Input, args: ['nxPopoverInitialVisible',] }],
    visibleChange: [{ type: Input, args: ['nxPopoverVisibleChange',] }],
    modal: [{ type: Input, args: ['nxPopoverModal',] }],
    trigger: [{ type: Input, args: ['nxPopoverTrigger',] }],
    scrollStrategy: [{ type: Input, args: ['nxPopoverScrollStrategy',] }]
};
if (false) {
    /**
     * @type {?}
     * @private
     */
    NxPopoverTriggerDirective.prototype.overlayRef;
    /**
     * @type {?}
     * @private
     */
    NxPopoverTriggerDirective.prototype.portal;
    /**
     * @type {?}
     * @private
     */
    NxPopoverTriggerDirective.prototype._destroyed;
    /**
     * @type {?}
     * @private
     */
    NxPopoverTriggerDirective.prototype._show;
    /**
     * @type {?}
     * @private
     */
    NxPopoverTriggerDirective.prototype._closeable;
    /**
     * @type {?}
     * @private
     */
    NxPopoverTriggerDirective.prototype._positionStrategy;
    /**
     * @type {?}
     * @private
     */
    NxPopoverTriggerDirective.prototype._embeddedViewRef;
    /**
     * @type {?}
     * @private
     */
    NxPopoverTriggerDirective.prototype._documentClickObservable;
    /**
     * The class that traps and manages focus within the popover.
     * @type {?}
     * @private
     */
    NxPopoverTriggerDirective.prototype._focusTrap;
    /**
     * Element that was focused before the Popover was opened. Save this to restore upon close.
     * @type {?}
     * @private
     */
    NxPopoverTriggerDirective.prototype._elementFocusedBeforePopoverWasOpened;
    /**
     * @type {?}
     * @private
     */
    NxPopoverTriggerDirective.prototype._manualListeners;
    /**
     * \@docs-private
     * @type {?}
     */
    NxPopoverTriggerDirective.prototype.id;
    /**
     * An event is emitted if the visibility status of the popover changes.
     * @type {?}
     */
    NxPopoverTriggerDirective.prototype.changeShow;
    /**
     * @type {?}
     * @private
     */
    NxPopoverTriggerDirective.prototype._closeOnClickOutside;
    /**
     * Links the trigger with the popover to open.
     * @type {?}
     */
    NxPopoverTriggerDirective.prototype.popover;
    /**
     * Sets the desired direction to open the popover. E.g., right, left, bottom, top
     * @type {?}
     */
    NxPopoverTriggerDirective.prototype.direction;
    /**
     * Whether the popover will be opened automatically.
     * @type {?}
     */
    NxPopoverTriggerDirective.prototype.popoverInitialVisible;
    /**
     * An event is emitted when the visibility of the popopver changes.
     * @type {?}
     */
    NxPopoverTriggerDirective.prototype.visibleChange;
    /**
     * Whether the popover opens in modal state.
     * @type {?}
     */
    NxPopoverTriggerDirective.prototype.modal;
    /**
     * Sets the way to trigger the popover. Options are hover, click, manual
     * @type {?}
     */
    NxPopoverTriggerDirective.prototype.trigger;
    /**
     * Sets the scroll strategy. 'close' closes the popover on scroll while 'reposition' scrolls the popover with the origin.
     * @type {?}
     */
    NxPopoverTriggerDirective.prototype.scrollStrategy;
    /**
     * @type {?}
     * @private
     */
    NxPopoverTriggerDirective.prototype.overlay;
    /**
     * @type {?}
     * @private
     */
    NxPopoverTriggerDirective.prototype.elementRef;
    /**
     * @type {?}
     * @private
     */
    NxPopoverTriggerDirective.prototype.viewContainerRef;
    /**
     * @type {?}
     * @private
     */
    NxPopoverTriggerDirective.prototype.eventManager;
    /**
     * @type {?}
     * @private
     */
    NxPopoverTriggerDirective.prototype._focusTrapFactory;
    /**
     * @type {?}
     * @private
     */
    NxPopoverTriggerDirective.prototype._focusMonitor;
    /**
     * @type {?}
     * @private
     */
    NxPopoverTriggerDirective.prototype._ngZone;
    /**
     * @type {?}
     * @private
     */
    NxPopoverTriggerDirective.prototype._platform;
    /**
     * @type {?}
     * @private
     */
    NxPopoverTriggerDirective.prototype._document;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicG9wb3Zlci10cmlnZ2VyLmRpcmVjdGl2ZS5qcyIsInNvdXJjZVJvb3QiOiJuZzovL0BhbGxpYW56L25neC1uZGJ4LyIsInNvdXJjZXMiOlsicG9wb3Zlci9wb3BvdmVyLXRyaWdnZXIuZGlyZWN0aXZlLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7O0FBQUEsT0FBTyxFQUFFLHFCQUFxQixFQUFFLE1BQU0sdUJBQXVCLENBQUM7QUFDOUQsT0FBTyxFQUlMLE9BQU8sRUFDUCxhQUFhLEVBR2QsTUFBTSxzQkFBc0IsQ0FBQztBQUM5QixPQUFPLEVBQUUsY0FBYyxFQUFFLE1BQU0scUJBQXFCLENBQUM7QUFDckQsT0FBTyxFQUVMLFNBQVMsRUFDVCxVQUFVLEVBRVYsWUFBWSxFQUNaLE1BQU0sRUFDTixLQUFLLEVBR0wsUUFBUSxFQUNSLE1BQU0sRUFDTixnQkFBZ0IsRUFDaEIsTUFBTSxFQUNQLE1BQU0sZUFBZSxDQUFDO0FBQ3ZCLE9BQU8sRUFBRSxZQUFZLEVBQUUsTUFBTSwyQkFBMkIsQ0FBQztBQUN6RCxPQUFPLEVBQUUsU0FBUyxFQUFjLE9BQU8sRUFBRSxNQUFNLE1BQU0sQ0FBQztBQUN0RCxPQUFPLEVBQUUsTUFBTSxFQUFFLEdBQUcsRUFBRSxTQUFTLEVBQUUsTUFBTSxnQkFBZ0IsQ0FBQztBQUN4RCxPQUFPLEVBQUUsWUFBWSxFQUFFLE1BQU0sbUJBQW1CLENBQUM7QUFDakQsT0FBTyxFQUFFLGtCQUFrQixFQUFFLE1BQU0scUJBQXFCLENBQUM7QUFDekQsT0FBTyxFQUFFLGdCQUFnQixFQUFhLE1BQU0sbUJBQW1CLENBQUM7QUFDaEUsT0FBTyxFQUFFLFFBQVEsRUFBRSxNQUFNLGlCQUFpQixDQUFDO0FBQzNDLE9BQU8sRUFBRSxRQUFRLEVBQUUsTUFBTSx1QkFBdUIsQ0FBQztBQUNqRCxPQUFPLEVBQUUsS0FBSyxFQUFFLEtBQUssRUFBRSxNQUFNLHVCQUF1QixDQUFDOztJQUtqRCxNQUFNLEdBQUcsQ0FBQzs7TUFFUixTQUFTLEdBQTZC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Z0JBQWdCO3NCQU90QixLQUFLLFNBQUMsa0JBQWtCOzZCQUl4QixLQUFLLFNBQUMseUJBQXlCOzs7Ozs7O0lBMUZoQywrQ0FBK0I7Ozs7O0lBQy9CLDJDQUFvQzs7Ozs7SUFDcEMsK0NBQXlDOzs7OztJQUN6QywwQ0FBK0I7Ozs7O0lBQy9CLCtDQUFtQzs7Ozs7SUFDbkMsc0RBQTRDOzs7OztJQUM1QyxxREFBK0M7Ozs7O0lBQy9DLDZEQUF5RDs7Ozs7O0lBRXpELCtDQUE4Qjs7Ozs7O0lBRTlCLDBFQUF5RTs7Ozs7SUFDekUscURBQWlGOzs7OztJQUVqRix1Q0FBOEI7Ozs7O0lBRzlCLCtDQUN1RDs7Ozs7SUEwQ3ZELHlEQUE2Qzs7Ozs7SUFHN0MsNENBQzRCOzs7OztJQUc1Qiw4Q0FDc0M7Ozs7O0lBR3RDLDBEQUN1Qzs7Ozs7SUFHdkMsa0RBQzBEOzs7OztJQUcxRCwwQ0FDdUI7Ozs7O0lBTXZCLDRDQUNzQzs7Ozs7SUFHdEMsbURBQ3VEOzs7OztJQUUzQyw0Q0FBd0I7Ozs7O0lBQ3hCLCtDQUE4Qjs7Ozs7SUFDOUIscURBQTBDOzs7OztJQUMxQyxpREFBa0M7Ozs7O0lBQ2xDLHNEQUEyQzs7Ozs7SUFDM0Msa0RBQW1DOzs7OztJQUNuQyw0Q0FBdUI7Ozs7O0lBQ3ZCLDhDQUEyQjs7Ozs7SUFDM0IsOENBQW9EIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgY29lcmNlQm9vbGVhblByb3BlcnR5IH0gZnJvbSAnQGFuZ3VsYXIvY2RrL2NvZXJjaW9uJztcbmltcG9ydCB7XG4gIENvbm5lY3RlZFBvc2l0aW9uLFxuICBDb25uZWN0aW9uUG9zaXRpb25QYWlyLFxuICBGbGV4aWJsZUNvbm5lY3RlZFBvc2l0aW9uU3RyYXRlZ3ksXG4gIE92ZXJsYXksXG4gIE92ZXJsYXlDb25maWcsXG4gIE92ZXJsYXlSZWYsXG4gIFBvc2l0aW9uU3RyYXRlZ3lcbn0gZnJvbSAnQGFuZ3VsYXIvY2RrL292ZXJsYXknO1xuaW1wb3J0IHsgVGVtcGxhdGVQb3J0YWwgfSBmcm9tICdAYW5ndWxhci9jZGsvcG9ydGFsJztcbmltcG9ydCB7XG4gIEFmdGVyVmlld0luaXQsXG4gIERpcmVjdGl2ZSxcbiAgRWxlbWVudFJlZixcbiAgRW1iZWRkZWRWaWV3UmVmLFxuICBFdmVudEVtaXR0ZXIsXG4gIEluamVjdCxcbiAgSW5wdXQsXG4gIE9uRGVzdHJveSxcbiAgT25Jbml0LFxuICBPcHRpb25hbCxcbiAgT3V0cHV0LFxuICBWaWV3Q29udGFpbmVyUmVmLFxuICBOZ1pvbmVcbn0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBFdmVudE1hbmFnZXIgfSBmcm9tICdAYW5ndWxhci9wbGF0Zm9ybS1icm93c2VyJztcbmltcG9ydCB7IGZyb21FdmVudCwgT2JzZXJ2YWJsZSwgU3ViamVjdCB9IGZyb20gJ3J4anMnO1xuaW1wb3J0IHsgZmlsdGVyLCBtYXAsIHRha2VVbnRpbCB9IGZyb20gJ3J4anMvb3BlcmF0b3JzJztcbmltcG9ydCB7IEZvY3VzTW9uaXRvciB9IGZyb20gJ0Bhbmd1bGFyL2Nkay9hMTF5JztcbmltcG9ydCB7IE54UG9wb3ZlckNvbXBvbmVudCB9IGZyb20gJy4vcG9wb3Zlci5jb21wb25lbnQnO1xuaW1wb3J0IHsgRm9jdXNUcmFwRmFjdG9yeSwgRm9jdXNUcmFwIH0gZnJvbSAnQGFuZ3VsYXIvY2RrL2ExMXknO1xuaW1wb3J0IHsgRE9DVU1FTlQgfSBmcm9tICdAYW5ndWxhci9jb21tb24nO1xuaW1wb3J0IHsgUGxhdGZvcm0gfSBmcm9tICdAYW5ndWxhci9jZGsvcGxhdGZvcm0nO1xuaW1wb3J0IHsgU1BBQ0UsIEVOVEVSIH0gZnJvbSAnQGFuZ3VsYXIvY2RrL2tleWNvZGVzJztcblxuZXhwb3J0IGRlY2xhcmUgdHlwZSBQb3BvdmVyRGlyZWN0aW9uID0gJ2xlZnQnIHwgJ3RvcCcgfCAncmlnaHQnIHwgJ2JvdHRvbSc7XG5leHBvcnQgZGVjbGFyZSB0eXBlIFBvcG92ZXJUcmlnZ2VyVHlwZSA9ICdjbGljaycgfCAnaG92ZXInIHwgJ21hbnVhbCc7XG5leHBvcnQgZGVjbGFyZSB0eXBlIFBvcG92ZXJUcmlnZ2VyU2Nyb2xsU3RyYXRlZ3kgPSAnY2xvc2UnIHwgJ3JlcG9zaXRpb24nO1xubGV0IG5leHRJZCA9IDA7XG5cbmNvbnN0IGZhbGxiYWNrczogQ29ubmVjdGlvblBvc2l0aW9uUGFpcltdID0gW1xuICB7XG4gICAgb3JpZ2luWDogJ3N0YXJ0JyxcbiAgICBvcmlnaW5ZOiAnYm90dG9tJyxcbiAgICBvdmVybGF5WDogJ3N0YXJ0JyxcbiAgICBvdmVybGF5WTogJ3RvcCcsXG4gICAgb2Zmc2V0WDogMCxcbiAgICBvZmZzZXRZOiAxNlxuICB9LFxuICB7XG4gICAgb3JpZ2luWDogJ2VuZCcsXG4gICAgb3JpZ2luWTogJ3RvcCcsXG4gICAgb3ZlcmxheVg6ICdlbmQnLFxuICAgIG92ZXJsYXlZOiAnYm90dG9tJyxcbiAgICBvZmZzZXRYOiAwLFxuICAgIG9mZnNldFk6IC0xNlxuICB9LFxuICB7XG4gICAgb3JpZ2luWDogJ2NlbnRlcicsXG4gICAgb3JpZ2luWTogJ2JvdHRvbScsXG4gICAgb3ZlcmxheVg6ICdjZW50ZXInLFxuICAgIG92ZXJsYXlZOiAndG9wJyxcbiAgICBvZmZzZXRYOiAwLFxuICAgIG9mZnNldFk6IDE2XG4gIH0sXG4gIHtcbiAgICBvcmlnaW5YOiAnZW5kJyxcbiAgICBvcmlnaW5ZOiAnYm90dG9tJyxcbiAgICBvdmVybGF5WDogJ2VuZCcsXG4gICAgb3ZlcmxheVk6ICd0b3AnLFxuICAgIG9mZnNldFg6IDAsXG4gICAgb2Zmc2V0WTogMTZcbiAgfSxcbiAge1xuICAgIG9yaWdpblg6ICdlbmQnLFxuICAgIG9yaWdpblk6ICdjZW50ZXInLFxuICAgIG92ZXJsYXlYOiAnc3RhcnQnLFxuICAgIG92ZXJsYXlZOiAnY2VudGVyJyxcbiAgICBvZmZzZXRYOiAxNixcbiAgICBvZmZzZXRZOiAwXG4gIH0sXG4gIHtcbiAgICBvcmlnaW5YOiAnc3RhcnQnLFxuICAgIG9yaWdpblk6ICdjZW50ZXInLFxuICAgIG92ZXJsYXlYOiAnZW5kJyxcbiAgICBvdmVybGF5WTogJ2NlbnRlcicsXG4gICAgb2Zmc2V0WDogLTE2LFxuICAgIG9mZnNldFk6IDBcbiAgfSxcbiAge1xuICAgIG9yaWdpblg6ICdjZW50ZXInLFxuICAgIG9yaWdpblk6ICd0b3AnLFxuICAgIG92ZXJsYXlYOiAnY2VudGVyJyxcbiAgICBvdmVybGF5WTogJ2JvdHRvbScsXG4gICAgb2Zmc2V0WDogMCxcbiAgICBvZmZzZXRZOiAtMTZcbiAgfSxcbiAge1xuICAgIG9yaWdpblg6ICdzdGFydCcsXG4gICAgb3JpZ2luWTogJ3RvcCcsXG4gICAgb3ZlcmxheVg6ICdzdGFydCcsXG4gICAgb3ZlcmxheVk6ICdib3R0b20nLFxuICAgIG9mZnNldFg6IDAsXG4gICAgb2Zmc2V0WTogLTE2XG4gIH1cbl07XG5cbkBEaXJlY3RpdmUoe1xuICBzZWxlY3RvcjogJ1tueFBvcG92ZXJUcmlnZ2VyRm9yXScsXG4gIGV4cG9ydEFzOiAnbnhQb3BvdmVyVHJpZ2dlcicsXG4gIGhvc3Q6IHtcbiAgICAnKGNsaWNrKSc6ICdoYW5kbGVDbGljaygpJyxcbiAgICAnYXJpYS1oYXNwb3B1cCc6ICd0cnVlJyxcbiAgICAnW2F0dHIuYXJpYS1leHBhbmRlZF0nOiAnaXNPcGVuJyxcbiAgICAnW2F0dHIuYXJpYS1kZXNjcmliZWRieV0nOiAnaXNPcGVuID8gaWQgOiBudWxsJ1xuICB9XG59KVxuZXhwb3J0IGNsYXNzIE54UG9wb3ZlclRyaWdnZXJEaXJlY3RpdmUgaW1wbGVtZW50cyBBZnRlclZpZXdJbml0LCBPbkRlc3Ryb3ksIE9uSW5pdCB7XG4gIHByaXZhdGUgb3ZlcmxheVJlZjogT3ZlcmxheVJlZjtcbiAgcHJpdmF0ZSBwb3J0YWw6IFRlbXBsYXRlUG9ydGFsPGFueT47XG4gIHByaXZhdGUgX2Rlc3Ryb3llZCA9IG5ldyBTdWJqZWN0PHZvaWQ+KCk7XG4gIHByaXZhdGUgX3Nob3c6IGJvb2xlYW4gPSBmYWxzZTtcbiAgcHJpdmF0ZSBfY2xvc2VhYmxlOiBib29sZWFuID0gbnVsbDtcbiAgcHJpdmF0ZSBfcG9zaXRpb25TdHJhdGVneTogUG9zaXRpb25TdHJhdGVneTtcbiAgcHJpdmF0ZSBfZW1iZWRkZWRWaWV3UmVmOiBFbWJlZGRlZFZpZXdSZWY8YW55PjtcbiAgcHJpdmF0ZSBfZG9jdW1lbnRDbGlja09ic2VydmFibGU6IE9ic2VydmFibGU8TW91c2VFdmVudD47XG4gIC8qKiBUaGUgY2xhc3MgdGhhdCB0cmFwcyBhbmQgbWFuYWdlcyBmb2N1cyB3aXRoaW4gdGhlIHBvcG92ZXIuICovXG4gIHByaXZhdGUgX2ZvY3VzVHJhcDogRm9jdXNUcmFwO1xuICAvKiogRWxlbWVudCB0aGF0IHdhcyBmb2N1c2VkIGJlZm9yZSB0aGUgUG9wb3ZlciB3YXMgb3BlbmVkLiBTYXZlIHRoaXMgdG8gcmVzdG9yZSB1cG9uIGNsb3NlLiAqL1xuICBwcml2YXRlIF9lbGVtZW50Rm9jdXNlZEJlZm9yZVBvcG92ZXJXYXNPcGVuZWQ6IEhUTUxFbGVtZW50IHwgbnVsbCA9IG51bGw7XG4gIHByaXZhdGUgX21hbnVhbExpc3RlbmVycyA9IG5ldyBNYXA8c3RyaW5nLCBFdmVudExpc3RlbmVyT3JFdmVudExpc3RlbmVyT2JqZWN0PigpO1xuICAvKiogQGRvY3MtcHJpdmF0ZSAqL1xuICBpZCA9ICdueC1wb3BvdmVyLScgKyBuZXh0SWQrKztcblxuICAvKiogQW4gZXZlbnQgaXMgZW1pdHRlZCBpZiB0aGUgdmlzaWJpbGl0eSBzdGF0dXMgb2YgdGhlIHBvcG92ZXIgY2hhbmdlcy4gKi9cbiAgQE91dHB1dCgnbnhQb3BvdmVyU2hvd0NoYW5nZScpXG4gIGNoYW5nZVNob3c6IEV2ZW50RW1pdHRlcjxib29sZWFuPiA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcblxuICAvKiogV2hldGhlciB0byBzaG93IG9yIGhpZGUgdGhlIHBvcG92ZXIuICovXG4gIEBJbnB1dCgnbnhQb3BvdmVyU2hvdycpXG4gIHNldCBzaG93KHZhbHVlOiBib29sZWFuKSB7XG4gICAgdmFsdWUgPSBjb2VyY2VCb29sZWFuUHJvcGVydHkodmFsdWUpO1xuICAgIGlmICh0aGlzLl9zaG93ICE9PSB2YWx1ZSkge1xuICAgICAgdGhpcy5fc2hvdyA9IHZhbHVlO1xuICAgICAgaWYgKHRoaXMuX3Nob3cpIHtcbiAgICAgICAgdGhpcy5vcGVuUG9wb3ZlcigpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5jbG9zZVBvcG92ZXIoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBnZXQgc2hvdygpIHtcbiAgICByZXR1cm4gdGhpcy5fc2hvdztcbiAgfVxuXG4gIC8qKiBXaGV0aGVyIHRvIHNob3cgYSBjbG9zZSBidXR0b24uIEJ5IGRlZmF1bHQgYSBjbG9zZSBpY29uIGlzIG9ubHkgc2hvd24gZm9yIHRyaWdnZXIgdHlwZSBjbGljay4gKi9cbiAgQElucHV0KCdueFBvcG92ZXJDbG9zZWFibGUnKVxuICBzZXQgY2xvc2VhYmxlKHZhbHVlOiBib29sZWFuKSB7XG4gICAgdGhpcy5fY2xvc2VhYmxlID0gY29lcmNlQm9vbGVhblByb3BlcnR5KHZhbHVlKTtcblxuICAgIGlmICh0aGlzLnBvcG92ZXIpIHtcbiAgICAgIHRoaXMucG9wb3Zlci5zaG93Q2xvc2VCdXR0b24gPSB0aGlzLmlzQ2xvc2VhYmxlKCk7XG4gICAgfVxuICB9XG4gIGdldCBjbG9zZWFibGUoKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRoaXMuX2Nsb3NlYWJsZTtcbiAgfVxuXG4gIC8qKiBXaGV0aGVyIHRoZSBwb3BvdmVyIHNob3VsZCBiZSBjbG9zZWQgb24gY2xpY2sgb3V0c2lkZSBvZiB0aGUgcG9wb3ZlciBpbiB0aGUgdHJpZ2dlciBtb2RlcyAnbWFudWFsJyBhbmQgJ2NsaWNrJy4gKi9cbiAgQElucHV0KClcbiAgc2V0IGNsb3NlT25DbGlja091dHNpZGUodmFsdWU6IGJvb2xlYW4pIHtcbiAgICB0aGlzLl9jbG9zZU9uQ2xpY2tPdXRzaWRlID0gY29lcmNlQm9vbGVhblByb3BlcnR5KHZhbHVlKTtcbiAgfVxuICBnZXQgY2xvc2VPbkNsaWNrT3V0c2lkZSgpOiBib29sZWFuIHtcbiAgICByZXR1cm4gdGhpcy5fY2xvc2VPbkNsaWNrT3V0c2lkZTtcbiAgfVxuXG4gIHByaXZhdGUgX2Nsb3NlT25DbGlja091dHNpZGU6IGJvb2xlYW4gPSB0cnVlO1xuXG4gIC8qKiBMaW5rcyB0aGUgdHJpZ2dlciB3aXRoIHRoZSBwb3BvdmVyIHRvIG9wZW4uICovXG4gIEBJbnB1dCgnbnhQb3BvdmVyVHJpZ2dlckZvcicpXG4gIHBvcG92ZXI6IE54UG9wb3ZlckNvbXBvbmVudDtcblxuICAvKiogU2V0cyB0aGUgZGVzaXJlZCBkaXJlY3Rpb24gdG8gb3BlbiB0aGUgcG9wb3Zlci4gRS5nLiwgcmlnaHQsIGxlZnQsIGJvdHRvbSwgdG9wICovXG4gIEBJbnB1dCgnbnhQb3BvdmVyRGlyZWN0aW9uJylcbiAgZGlyZWN0aW9uOiBQb3BvdmVyRGlyZWN0aW9uID0gJ3JpZ2h0JztcblxuICAvKiogV2hldGhlciB0aGUgcG9wb3ZlciB3aWxsIGJlIG9wZW5lZCBhdXRvbWF0aWNhbGx5LiAqL1xuICBASW5wdXQoJ254UG9wb3ZlckluaXRpYWxWaXNpYmxlJylcbiAgcG9wb3ZlckluaXRpYWxWaXNpYmxlOiBib29sZWFuID0gZmFsc2U7XG5cbiAgLyoqIEFuIGV2ZW50IGlzIGVtaXR0ZWQgd2hlbiB0aGUgdmlzaWJpbGl0eSBvZiB0aGUgcG9wb3B2ZXIgY2hhbmdlcy4gKi9cbiAgQElucHV0KCdueFBvcG92ZXJWaXNpYmxlQ2hhbmdlJylcbiAgdmlzaWJsZUNoYW5nZTogRXZlbnRFbWl0dGVyPGJvb2xlYW4+ID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuXG4gIC8qKiBXaGV0aGVyIHRoZSBwb3BvdmVyIG9wZW5zIGluIG1vZGFsIHN0YXRlLiAqL1xuICBASW5wdXQoJ254UG9wb3Zlck1vZGFsJylcbiAgbW9kYWw6IGJvb2xlYW4gPSBmYWxzZTtcblxuICAvLyBJZiBueFBvcG92ZXJUcmlnZ2VyIGVxdWFscyB0byAnaG92ZXInIHRoZSBwb3BvdmVyIG9wZW5zIG9uIG1vdXNlZW50ZXIgYW5kIGNsb3NlcyBvbiBtb3VzZW91dC5cbiAgLy8gSWYgbnhQb3BvdmVyVHJpZ2dlciBlcXVhbHMgdG8gJ2NsaWNrJyB0aGUgcG9wb3ZlciBvcGVucyBvbiBjbGljayBhbmQgY2xvc2VzIG9uIGEgY2xpY2sgb2YgdGhlIGNsb3NlIGljb24gb3IgcHJlc3NpbmcgRVNDIGtleS5cbiAgLy8gSWYgbnhQb3BvdmVyVHJpZ2dlciBlcXVhbHMgdG8gJ21hbnVhbCcgdGhlIHBvcG92ZXIgb3BlbnMgb25seSB3aGVuIHByb2dyYW1hdGljYWxseSByZXF1ZXN0ZWQuXG4gIC8qKiBTZXRzIHRoZSB3YXkgdG8gdHJpZ2dlciB0aGUgcG9wb3Zlci4gT3B0aW9ucyBhcmUgaG92ZXIsIGNsaWNrLCBtYW51YWwgKi9cbiAgQElucHV0KCdueFBvcG92ZXJUcmlnZ2VyJylcbiAgdHJpZ2dlcjogUG9wb3ZlclRyaWdnZXJUeXBlID0gJ2NsaWNrJztcblxuICAvKiogU2V0cyB0aGUgc2Nyb2xsIHN0cmF0ZWd5LiAnY2xvc2UnIGNsb3NlcyB0aGUgcG9wb3ZlciBvbiBzY3JvbGwgd2hpbGUgJ3JlcG9zaXRpb24nIHNjcm9sbHMgdGhlIHBvcG92ZXIgd2l0aCB0aGUgb3JpZ2luLiAqL1xuICBASW5wdXQoJ254UG9wb3ZlclNjcm9sbFN0cmF0ZWd5JylcbiAgc2Nyb2xsU3RyYXRlZ3k6IFBvcG92ZXJUcmlnZ2VyU2Nyb2xsU3RyYXRlZ3kgPSAnY2xvc2UnO1xuXG4gIGNvbnN0cnVjdG9yKHByaXZhdGUgb3ZlcmxheTogT3ZlcmxheSxcbiAgICAgICAgICAgICAgcHJpdmF0ZSBlbGVtZW50UmVmOiBFbGVtZW50UmVmLFxuICAgICAgICAgICAgICBwcml2YXRlIHZpZXdDb250YWluZXJSZWY6IFZpZXdDb250YWluZXJSZWYsXG4gICAgICAgICAgICAgIHByaXZhdGUgZXZlbnRNYW5hZ2VyOiBFdmVudE1hbmFnZXIsXG4gICAgICAgICAgICAgIHByaXZhdGUgX2ZvY3VzVHJhcEZhY3Rvcnk6IEZvY3VzVHJhcEZhY3RvcnksXG4gICAgICAgICAgICAgIHByaXZhdGUgX2ZvY3VzTW9uaXRvcjogRm9jdXNNb25pdG9yLFxuICAgICAgICAgICAgICBwcml2YXRlIF9uZ1pvbmU6IE5nWm9uZSxcbiAgICAgICAgICAgICAgcHJpdmF0ZSBfcGxhdGZvcm06IFBsYXRmb3JtLFxuICAgICAgICAgICAgICBAT3B0aW9uYWwoKSBASW5qZWN0KERPQ1VNRU5UKSBwcml2YXRlIF9kb2N1bWVudDogYW55KSB7XG4gICAgdGhpcy5fZG9jdW1lbnRDbGlja09ic2VydmFibGUgPSBmcm9tRXZlbnQ8TW91c2VFdmVudD4oZG9jdW1lbnQsICdjbGljaycpO1xuICAgIGNvbnN0IGVsZW1lbnQ6IEhUTUxFbGVtZW50ID0gZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50O1xuICAgIGlmICghdGhpcy5fcGxhdGZvcm0uSU9TICYmICF0aGlzLl9wbGF0Zm9ybS5BTkRST0lEKSB7XG4gICAgICB0aGlzLl9tYW51YWxMaXN0ZW5lcnNcbiAgICAgICAgLnNldCgnbW91c2VlbnRlcicsICgpID0+IHtcbiAgICAgICAgICBpZiAodGhpcy50cmlnZ2VyID09PSAnaG92ZXInKSB7XG4gICAgICAgICAgICB0aGlzLnNob3cgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICAgICAgLnNldCgnbW91c2VsZWF2ZScsICgpID0+IHtcbiAgICAgICAgICBpZiAodGhpcy50cmlnZ2VyID09PSAnaG92ZXInKSB7XG4gICAgICAgICAgICB0aGlzLnNob3cgPSBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgICAgIC5zZXQoJ2tleWRvd24nLCAoZXZlbnQ6IEtleWJvYXJkRXZlbnQpID0+IHtcbiAgICAgICAgICBzd2l0Y2ggKGV2ZW50LmtleUNvZGUpIHtcbiAgICAgICAgICAgIGNhc2UgU1BBQ0U6XG4gICAgICAgICAgICBjYXNlIEVOVEVSOlxuICAgICAgICAgICAgICB0aGlzLmhhbmRsZUNsaWNrKCk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX21hbnVhbExpc3RlbmVycy5zZXQoJ3RvdWNoc3RhcnQnLCAoKSA9PiB7XG4gICAgICAgIGlmICh0aGlzLnRyaWdnZXIgPT09ICdob3ZlcicpIHtcbiAgICAgICAgICB0aGlzLnNob3cgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICB0aGlzLl9tYW51YWxMaXN0ZW5lcnMuZm9yRWFjaCgobGlzdGVuZXIsIGV2ZW50KSA9PiBlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoZXZlbnQsIGxpc3RlbmVyKSk7XG5cbiAgICB0aGlzLl9mb2N1c01vbml0b3IubW9uaXRvcihlbGVtZW50KS5waXBlKHRha2VVbnRpbCh0aGlzLl9kZXN0cm95ZWQpKS5zdWJzY3JpYmUob3JpZ2luID0+IHtcbiAgICAgIGlmIChvcmlnaW4gPT09ICdrZXlib2FyZCcgJiYgdGhpcy50cmlnZ2VyID09PSAnaG92ZXInKSB7XG4gICAgICAgIHRoaXMuX25nWm9uZS5ydW4oKCkgPT4gdGhpcy5zaG93ID0gdHJ1ZSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBuZ09uSW5pdCgpIHtcbiAgICB0aGlzLnBvcG92ZXIuc2hvd0Nsb3NlQnV0dG9uID0gdGhpcy5pc0Nsb3NlYWJsZSgpO1xuICB9XG5cbiAgbmdBZnRlclZpZXdJbml0KCk6IHZvaWQge1xuICAgIHRoaXMucG9wb3Zlci5pZCA9IHRoaXMuaWQ7XG5cbiAgICB0aGlzLmV2ZW50TWFuYWdlci5hZGRHbG9iYWxFdmVudExpc3RlbmVyKCd3aW5kb3cnLCAna2V5dXAuZXNjJywgKCkgPT4ge1xuICAgICAgaWYgKHRoaXMuaXNPcGVuKSB7XG4gICAgICAgIHRoaXMuc2hvdyA9IGZhbHNlO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgdGhpcy5wb3BvdmVyLmNsb3NlQnV0dG9uQ2xpY2sucGlwZSh0YWtlVW50aWwodGhpcy5fZGVzdHJveWVkKSkuc3Vic2NyaWJlKCgpID0+IHtcbiAgICAgIHRoaXMuc2hvdyA9IGZhbHNlO1xuICAgIH0pO1xuXG4gICAgaWYgKHRoaXMucG9wb3ZlckluaXRpYWxWaXNpYmxlIHx8IHRoaXMuX3Nob3cpIHtcbiAgICAgIHRoaXMuc2hvdyA9IHRydWU7XG4gICAgfVxuICB9XG5cbiAgbmdPbkRlc3Ryb3koKTogdm9pZCB7XG4gICAgdGhpcy5zaG93ID0gZmFsc2U7XG4gICAgLy8gQ2xlYW4gdXAgdGhlIGV2ZW50IGxpc3RlbmVycyBzZXQgaW4gdGhlIGNvbnN0cnVjdG9yXG4gICAgdGhpcy5fbWFudWFsTGlzdGVuZXJzLmZvckVhY2goKGxpc3RlbmVyLCBldmVudCkgPT4ge1xuICAgICAgdGhpcy5lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudCwgbGlzdGVuZXIpO1xuICAgIH0pO1xuICAgIHRoaXMuX21hbnVhbExpc3RlbmVycy5jbGVhcigpO1xuICAgIHRoaXMuX2Rlc3Ryb3llZC5uZXh0KCk7XG4gICAgdGhpcy5fZGVzdHJveWVkLmNvbXBsZXRlKCk7XG4gIH1cblxuICAvKiogQGRvY3MtcHJpdmF0ZSAqL1xuICBnZXQgaXNPcGVuKCkge1xuICAgIHJldHVybiB0aGlzLm92ZXJsYXlSZWYgJiYgdGhpcy5jcmVhdGVPdmVybGF5KCkuaGFzQXR0YWNoZWQoKTtcbiAgfVxuXG4gIC8qKiBAZG9jcy1wcml2YXRlICovXG4gIGlzQ2xvc2VhYmxlKCkge1xuICAgIHJldHVybiAodGhpcy50cmlnZ2VyID09PSAnY2xpY2snICYmIHRoaXMuX2Nsb3NlYWJsZSA9PT0gbnVsbCkgfHwgdGhpcy5fY2xvc2VhYmxlO1xuICB9XG5cbiAgLyoqIFVwZGF0ZSB0aGUgcG9wb3ZlciB3aXRoIHRoZSBnaXZlbiBwb3NpdGlvbiBzdHJhdGVneS4gKi9cbiAgdXBkYXRlUG9zaXRpb24oKSB7XG4gICAgaWYgKHRoaXMuX3Bvc2l0aW9uU3RyYXRlZ3kpIHtcbiAgICAgIHRoaXMuX3Bvc2l0aW9uU3RyYXRlZ3kuYXBwbHkoKTtcbiAgICB9XG4gIH1cblxuICAvKiogQGRvY3MtcHJpdmF0ZSAqL1xuICBoYW5kbGVDbGljaygpIHtcbiAgICBpZiAodGhpcy50cmlnZ2VyID09PSAnY2xpY2snKSB7XG4gICAgICB0aGlzLnNob3cgPSAhdGhpcy5pc09wZW47XG4gICAgfSBlbHNlIGlmICh0aGlzLnRyaWdnZXIgPT09ICdob3ZlcicpIHtcbiAgICAgIHRoaXMuc2hvdyA9IHRydWU7XG4gICAgfVxuICB9XG5cbiAgLyoqIE9wZW4gdGhlIHBvcG92ZXIgaW5zdGFuY2UuICovXG4gIG9wZW4oKTogdm9pZCB7XG4gICAgdGhpcy5zaG93ID0gdHJ1ZTtcbiAgfVxuXG4gIC8qKiBDbG9zZSB0aGUgcG9wb3ZlciBpbnN0YW5jZS4gKi9cbiAgY2xvc2UoKTogdm9pZCB7XG4gICAgdGhpcy5zaG93ID0gZmFsc2U7XG4gIH1cblxuICAvKiogVG9nZ2xlIHRoZSBwb3BvdmVyIGluc3RhbmNlLiAqL1xuICB0b2dnbGUoKTogdm9pZCB7XG4gICAgdGhpcy5zaG93ID0gIXRoaXMuc2hvdztcbiAgfVxuXG4gIHByaXZhdGUgb3BlblBvcG92ZXIoKTogdm9pZCB7XG4gICAgaWYgKCF0aGlzLmNyZWF0ZU92ZXJsYXkoKS5oYXNBdHRhY2hlZCgpKSB7XG4gICAgICB0aGlzLl9lbWJlZGRlZFZpZXdSZWYgPSB0aGlzLmNyZWF0ZU92ZXJsYXkoKS5hdHRhY2godGhpcy5wb3J0YWwpO1xuXG4gICAgICBjb25zdCBlbGVtZW50ID0gdGhpcy5fZW1iZWRkZWRWaWV3UmVmLnJvb3ROb2Rlc1swXSBhcyBIVE1MRWxlbWVudDtcbiAgICAgIHRoaXMuX2ZvY3VzVHJhcCA9IHRoaXMuX2ZvY3VzVHJhcEZhY3RvcnkuY3JlYXRlKGVsZW1lbnQpO1xuICAgICAgdGhpcy5fZWxlbWVudEZvY3VzZWRCZWZvcmVQb3BvdmVyV2FzT3BlbmVkID0gdGhpcy5lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQ7XG4gICAgICB0aGlzLl9hdXRvRm9jdXNGaXJzdFRhYmJhYmxlRWxlbWVudChlbGVtZW50KTtcblxuICAgICAgLy8gYXR0YWNoIGEgY2xvc2UgY2xpY2sgbGlzdGVuZXIgb25seSBpZiBpdCBtYWtlcyBzZW5zZSAoaWdub3JlIGl0IG9uIGhvdmVyIGUuZy4pXG4gICAgICBpZiAodGhpcy5zaG91bGRSZWFjdE9uQ2xpY2tPdXRzaWRlKCkpIHtcbiAgICAgICAgdGhpcy53YWl0Rm9yQ2xvc2UoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQXV0b2ZvY3VzIHRoZSBmaXJzdCB0YWJiYWJsZSBlbGVtZW50IGluc2lkZSBvZiB0aGUgcG9wb3ZlciwgaWYgdGhlcmUgaXMgbm90IGEgdGFiYmFibGUgZWxlbWVudCxcbiAgICogZm9jdXMgdGhlIHBvcG92ZXIgaW5zdGVhZC5cbiAgICovXG4gIHByaXZhdGUgX2F1dG9Gb2N1c0ZpcnN0VGFiYmFibGVFbGVtZW50KGVsZW1lbnQ6IEhUTUxFbGVtZW50KSB7XG4gICAgdGhpcy5fZm9jdXNUcmFwLmZvY3VzSW5pdGlhbEVsZW1lbnRXaGVuUmVhZHkoKS50aGVuKGhhc01vdmVkRm9jdXMgPT4ge1xuICAgICAgLy8gSWYgd2UgZGlkbid0IGZpbmQgYW55IGZvY3VzYWJsZSBlbGVtZW50cyBpbnNpZGUgdGhlIHBvcG92ZXIsIGZvY3VzIHRoZVxuICAgICAgLy8gY29udGFpbmVyIHNvIHRoZSB1c2VyIGNhbid0IHRhYiBpbnRvIG90aGVyIGVsZW1lbnRzIGJlaGluZCBpdC5cbiAgICAgIGlmICghaGFzTW92ZWRGb2N1cykge1xuICAgICAgICBlbGVtZW50LmZvY3VzKCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBwcml2YXRlIHNob3VsZFJlYWN0T25DbGlja091dHNpZGUoKSB7XG4gICAgcmV0dXJuICghdGhpcy5tb2RhbCAmJiB0aGlzLmNsb3NlT25DbGlja091dHNpZGUpO1xuICB9XG5cbiAgLy8gZGV0YWNoZXMgdGhlIG92ZXJsYXlcbiAgLy8gd2UgYXJlIGxpc3RlbmluZyB0byB0aGUgZGV0YWNobWVudHMgb2JzZXJ2YWJsZSB3aGljaCB3aWxsIHRoZW4gZW1pdCB0aGUgbnhDbG9zZWQgZXZlbnRcbiAgLy8gb24gdGhlIHBvcG92ZXIgY29tcG9uZW50XG4gIHByaXZhdGUgY2xvc2VQb3BvdmVyKCk6IHZvaWQge1xuICAgIGlmICh0aGlzLm92ZXJsYXlSZWYpIHtcbiAgICAgIHRoaXMuX3JldHVybkZvY3VzQWZ0ZXJQb3BvdmVyKCk7XG4gICAgICB0aGlzLm92ZXJsYXlSZWYuZGV0YWNoKCk7XG4gICAgICB0aGlzLl9lbWJlZGRlZFZpZXdSZWYgPSBudWxsO1xuICAgICAgdGhpcy5fZm9jdXNUcmFwLmRlc3Ryb3koKTtcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIGNyZWF0ZU92ZXJsYXkoKTogT3ZlcmxheVJlZiB7XG4gICAgaWYgKCF0aGlzLm92ZXJsYXlSZWYpIHtcbiAgICAgIHRoaXMucG9ydGFsID0gbmV3IFRlbXBsYXRlUG9ydGFsKHRoaXMucG9wb3Zlci50ZW1wbGF0ZVJlZiwgdGhpcy52aWV3Q29udGFpbmVyUmVmKTtcbiAgICAgIGNvbnN0IG92ZXJsYXlTdGF0ZSA9IG5ldyBPdmVybGF5Q29uZmlnKCk7XG4gICAgICBvdmVybGF5U3RhdGUucG9zaXRpb25TdHJhdGVneSA9IHRoaXMuZ2V0UG9zaXRpb24oKTtcbiAgICAgIHRoaXMuX3Bvc2l0aW9uU3RyYXRlZ3kgPSBvdmVybGF5U3RhdGUucG9zaXRpb25TdHJhdGVneTtcblxuICAgICAgaWYgKHRoaXMuc2Nyb2xsU3RyYXRlZ3kgPT09ICdyZXBvc2l0aW9uJykge1xuICAgICAgICBvdmVybGF5U3RhdGUuc2Nyb2xsU3RyYXRlZ3kgPSB0aGlzLm92ZXJsYXkuc2Nyb2xsU3RyYXRlZ2llcy5yZXBvc2l0aW9uKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvdmVybGF5U3RhdGUuc2Nyb2xsU3RyYXRlZ3kgPSB0aGlzLm92ZXJsYXkuc2Nyb2xsU3RyYXRlZ2llcy5jbG9zZSgpO1xuICAgICAgfVxuXG4gICAgICBvdmVybGF5U3RhdGUuc2Nyb2xsU3RyYXRlZ3kuZW5hYmxlKCk7XG5cbiAgICAgIGlmICh0aGlzLm1vZGFsICYmIHRoaXMudHJpZ2dlciA9PT0gJ2NsaWNrJykge1xuICAgICAgICBvdmVybGF5U3RhdGUuaGFzQmFja2Ryb3AgPSB0cnVlO1xuICAgICAgfVxuXG4gICAgICB0aGlzLm92ZXJsYXlSZWYgPSB0aGlzLm92ZXJsYXkuY3JlYXRlKG92ZXJsYXlTdGF0ZSk7XG4gICAgICB0aGlzLnN1YnNjcmliZVRvUG9zaXRpb25zKG92ZXJsYXlTdGF0ZS5wb3NpdGlvblN0cmF0ZWd5IGFzIEZsZXhpYmxlQ29ubmVjdGVkUG9zaXRpb25TdHJhdGVneSk7XG4gICAgICB0aGlzLl9zdWJzY3JpYmVUb0F0dGFjaCgpO1xuICAgICAgdGhpcy5fc3Vic2NyaWJlVG9EZXRhY2goKTtcbiAgICAgIGlmICh0aGlzLm1vZGFsKSB7XG4gICAgICAgIHRoaXMuX3N1YnNjcmliZVRvQmFja2Ryb3BDbGljaygpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGhpcy5vdmVybGF5UmVmO1xuICB9XG5cbiAgcHJpdmF0ZSBzdWJzY3JpYmVUb1Bvc2l0aW9ucyhwb3NpdGlvbjogRmxleGlibGVDb25uZWN0ZWRQb3NpdGlvblN0cmF0ZWd5KTogdm9pZCB7XG4gICAgcG9zaXRpb24ucG9zaXRpb25DaGFuZ2VzLnBpcGUodGFrZVVudGlsKHRoaXMuX2Rlc3Ryb3llZCkpLnN1YnNjcmliZShjaGFuZ2UgPT4ge1xuICAgICAgY29uc3QgcGFpciA9IGNoYW5nZS5jb25uZWN0aW9uUGFpcjtcbiAgICAgIHRoaXMucG9zaXRpb25PdmVybGF5KHBhaXIpO1xuICAgICAgdGhpcy5wb3NpdGlvbkFycm93KHBhaXIpO1xuXG4gICAgICAvLyBUaGVzZSBwb3NpdGlvbiBjaGFuZ2VzIGFycml2ZSB0b28gbGF0ZSxcbiAgICAgIC8vIFdlIGhhdmUgdG8gdHJpZ2dlciB0aGUgY2hhbmdlIGRldGVjdGlvbiBtYW51YWxseVxuICAgICAgLy8gYXMgaXQncyBkZXRhY2hlZCBmcm9tIGFueSByZW5kZXIgaGllcmFyY2h5XG4gICAgICAvLyBhbmQgb25seSB1cGRhdGVkIGJ5IHRoZSBvdmVybGF5IHdoZW4gYXR0YWNoZWQuXG4gICAgICBpZiAodGhpcy5fZW1iZWRkZWRWaWV3UmVmICYmICF0aGlzLl9lbWJlZGRlZFZpZXdSZWYuZGVzdHJveWVkKSB7XG4gICAgICAgIHRoaXMuX2VtYmVkZGVkVmlld1JlZi5kZXRlY3RDaGFuZ2VzKCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICAvLyBmb3IgbW9kYWwgcG9wb3ZlcnMgY2xvc2UgdGhlIHBvcG92ZXIgb24gYmFja2Ryb3AgY2xpY2tzXG4gIHByaXZhdGUgX3N1YnNjcmliZVRvQmFja2Ryb3BDbGljaygpIHtcbiAgICB0aGlzLm92ZXJsYXlSZWYuYmFja2Ryb3BDbGljaygpLnBpcGUodGFrZVVudGlsKHRoaXMuX2Rlc3Ryb3llZCkpLnN1YnNjcmliZSgoZXZlbnQpID0+IHtcbiAgICAgIHRoaXMuc2hvdyA9IGZhbHNlO1xuICAgIH0pO1xuICB9XG5cbiAgLy8gRW1pdCB0aGUgbnhDbG9zZWQgYW5kIHRoZSBzaG93IHN0YXR1cyBjaGFuZ2UgZXZlbnQgb24gdGhlIHBvcG92ZXIgY29tcG9uZW50IHdoZW4gdGhlIG92ZXJsYXkgZGV0YWNoZXNcbiAgcHJpdmF0ZSBfc3Vic2NyaWJlVG9EZXRhY2goKSB7XG4gICAgdGhpcy5vdmVybGF5UmVmLmRldGFjaG1lbnRzKCkucGlwZSh0YWtlVW50aWwodGhpcy5fZGVzdHJveWVkKSkuc3Vic2NyaWJlKGRhdGEgPT4ge1xuICAgICAgLy8gVGhpcyBpcyBhbiBleGNlcHRpb246IHdoZW4gdGhlIHBvcG92ZXIgaXMgY2xvc2VkIGJ5IGEgc2Nyb2xsaW5nIGV2ZW50LFxuICAgICAgLy8gdGhlbiBvbmx5IHRoZSBkZXRhY2hlZCBtZXRob2QgaXMgY2FsbGVkIGJ1dCB0aGUgc2hvdyBzdGF0ZSB2YXJpYWJsZSByZW1haW5zIHVuY2hhbmdlZC5cbiAgICAgIGlmICh0aGlzLnNob3cpIHtcbiAgICAgICAgdGhpcy5zaG93ID0gZmFsc2U7XG4gICAgICB9XG4gICAgICB0aGlzLmNoYW5nZVNob3cuZW1pdCh0aGlzLl9zaG93KTtcbiAgICAgIHRoaXMucG9wb3Zlci5lbWl0Q2xvc2VkRXZlbnQoKTtcbiAgICB9KTtcbiAgfVxuXG4gIHByaXZhdGUgX3N1YnNjcmliZVRvQXR0YWNoKCkge1xuICAgIHRoaXMub3ZlcmxheVJlZi5hdHRhY2htZW50cygpLnBpcGUodGFrZVVudGlsKHRoaXMuX2Rlc3Ryb3llZCkpLnN1YnNjcmliZShkYXRhID0+IHtcbiAgICAgIHRoaXMuY2hhbmdlU2hvdy5lbWl0KHRoaXMuX3Nob3cpO1xuICAgIH0pO1xuICB9XG5cbiAgLy8gc3Vic2NyaWJlIHRvIGRvY3VtZW50IGNsaWNrcyB3aGVuIHRyaWdnZXI9J2NsaWNrJyB0byBjbG9zZSB0aGUgcG9wb3ZlciBvbiBjbGlja3Mgb24gdGhlIGJhY2tncm91bmRcbiAgcHJpdmF0ZSB3YWl0Rm9yQ2xvc2UoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2RvY3VtZW50Q2xpY2tPYnNlcnZhYmxlXG4gICAgICAucGlwZShcbiAgICAgICAgbWFwKGV2ZW50ID0+IGV2ZW50LnRhcmdldCksXG4gICAgICAgIGZpbHRlcih0YXJnZXQgPT4gIXRoaXMuZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50LmNvbnRhaW5zKHRhcmdldCkpLFxuICAgICAgICB0YWtlVW50aWwodGhpcy5wb3BvdmVyLmNsb3NlZCkpXG4gICAgICAuc3Vic2NyaWJlKCgpID0+IHtcbiAgICAgICAgdGhpcy5zaG93ID0gZmFsc2U7XG4gICAgICB9KTtcbiAgfVxuXG4gIHByaXZhdGUgcG9zaXRpb25PdmVybGF5KHBhaXI6IENvbm5lY3Rpb25Qb3NpdGlvblBhaXIpIHtcbiAgICBpZiAocGFpci5vcmlnaW5YID09PSAnZW5kJyAmJiBwYWlyLm92ZXJsYXlYID09PSAnc3RhcnQnKSB7XG4gICAgICB0aGlzLnBvcG92ZXIuZGlyZWN0aW9uID0gJ3JpZ2h0JztcbiAgICB9IGVsc2UgaWYgKHBhaXIub3JpZ2luWSA9PT0gJ2JvdHRvbScgJiYgcGFpci5vdmVybGF5WSA9PT0gJ3RvcCcpIHtcbiAgICAgIHRoaXMucG9wb3Zlci5kaXJlY3Rpb24gPSAnYm90dG9tJztcbiAgICB9IGVsc2UgaWYgKHBhaXIub3JpZ2luWCA9PT0gJ3N0YXJ0JyAmJiBwYWlyLm92ZXJsYXlYID09PSAnZW5kJykge1xuICAgICAgdGhpcy5wb3BvdmVyLmRpcmVjdGlvbiA9ICdsZWZ0JztcbiAgICB9IGVsc2UgaWYgKHBhaXIub3JpZ2luWSA9PT0gJ3RvcCcgJiYgcGFpci5vdmVybGF5WSA9PT0gJ2JvdHRvbScpIHtcbiAgICAgIHRoaXMucG9wb3Zlci5kaXJlY3Rpb24gPSAndG9wJztcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIHBvc2l0aW9uQXJyb3cocGFpcjogQ29ubmVjdGlvblBvc2l0aW9uUGFpcikge1xuXG4gICAgY29uc3QgcGFyZW50RWxlbWVudFBvc2l0aW9uWCA9IHRoaXMuZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmxlZnQ7XG4gICAgY29uc3QgcGFyZW50RWxlbWVudFdpZHRoID0gdGhpcy5lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkud2lkdGggLyAyO1xuICAgIGNvbnN0IHBhcmVudEVsZW1lbnRMZWZ0T2Zmc2V0ID0gdGhpcy5vdmVybGF5UmVmLm92ZXJsYXlFbGVtZW50LnBhcmVudEVsZW1lbnQub2Zmc2V0TGVmdDtcbiAgICBjb25zdCBvdmVybGF5RWxlbWVudExlZnRPZmZzZXQgPSB0aGlzLm92ZXJsYXlSZWYub3ZlcmxheUVsZW1lbnQub2Zmc2V0TGVmdDtcblxuICAgIC8vIGNhbGN1bGF0aW9uIGZvciB4IHBvc2l0aW9uIG9mIHRoZSBwYXJlbnQgZWxlbWVudC4gSW4gdGhpcyBjYXNlLCBvdmVybGF5IGxlZnQgb2Zmc2V0IGlzIHRoZSBvbmUgdGhpbmcgdG8gY29uc2lkZXIuXG4gICAgY29uc3QgdGFyZ2V0UG9zaXRpb24gPSAocGFyZW50RWxlbWVudFBvc2l0aW9uWCArIHBhcmVudEVsZW1lbnRXaWR0aCkgLSAocGFyZW50RWxlbWVudExlZnRPZmZzZXQgKyBvdmVybGF5RWxlbWVudExlZnRPZmZzZXQpO1xuICAgIGlmIChwYWlyLm9yaWdpblggPT09IHBhaXIub3ZlcmxheVgpIHtcbiAgICAgIGNvbnN0IGRpcmVjdGlvbiA9ICdsZWZ0JztcbiAgICAgIGNvbnN0IGFycm93U3R5bGUgPSB7fTtcblxuICAgICAgYXJyb3dTdHlsZVtkaXJlY3Rpb25dID0gdGFyZ2V0UG9zaXRpb24gKyAncHgnO1xuICAgICAgdGhpcy5wb3BvdmVyLmFycm93U3R5bGUgPSBhcnJvd1N0eWxlO1xuICAgIH1cbiAgICBpZiAoKHBhaXIub3JpZ2luWSA9PT0gJ2JvdHRvbScgfHwgcGFpci5vcmlnaW5ZID09PSAndG9wJykgJiYgcGFpci5vdmVybGF5WCA9PT0gJ2NlbnRlcicpIHtcbiAgICAgIHRoaXMucG9wb3Zlci5hcnJvd1N0eWxlID0geyBsZWZ0OiB0YXJnZXRQb3NpdGlvbiArICdweCcgfTtcbiAgICB9XG5cbiAgICBpZiAoKHBhaXIub3JpZ2luWCA9PT0gJ2VuZCcgfHwgcGFpci5vcmlnaW5YID09PSAnc3RhcnQnKSAmJiBwYWlyLm92ZXJsYXlZID09PSAnY2VudGVyJykge1xuICAgICAgdGhpcy5wb3BvdmVyLmFycm93U3R5bGUgPSB7IHRvcDogJzUwJScgfTtcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIGdldFBvc2l0aW9uKCk6IEZsZXhpYmxlQ29ubmVjdGVkUG9zaXRpb25TdHJhdGVneSB7XG4gICAgbGV0IHBvc2l0aW9uczogQ29ubmVjdGVkUG9zaXRpb25bXTtcbiAgICBsZXQgb2Zmc2V0WCA9IDA7XG4gICAgbGV0IG9mZnNldFkgPSAwO1xuICAgIGlmICh0aGlzLmRpcmVjdGlvbiA9PT0gJ3RvcCcpIHtcbiAgICAgIHBvc2l0aW9ucyA9IFt7XG4gICAgICAgIG92ZXJsYXlYOiAnY2VudGVyJyxcbiAgICAgICAgb3ZlcmxheVk6ICdib3R0b20nLFxuICAgICAgICBvcmlnaW5YOiAnY2VudGVyJyxcbiAgICAgICAgb3JpZ2luWTogJ3RvcCdcbiAgICAgIH1dO1xuICAgICAgb2Zmc2V0WCA9IDA7XG4gICAgICBvZmZzZXRZID0gLTIwO1xuICAgIH0gZWxzZSBpZiAodGhpcy5kaXJlY3Rpb24gPT09ICdyaWdodCcpIHtcbiAgICAgIHBvc2l0aW9ucyA9IFt7XG4gICAgICAgIG92ZXJsYXlYOiAnc3RhcnQnLFxuICAgICAgICBvdmVybGF5WTogJ2NlbnRlcicsXG4gICAgICAgIG9yaWdpblg6ICdlbmQnLFxuICAgICAgICBvcmlnaW5ZOiAnY2VudGVyJ1xuICAgICAgfV07XG4gICAgICBvZmZzZXRYID0gMjA7XG4gICAgICBvZmZzZXRZID0gMDtcbiAgICB9IGVsc2UgaWYgKHRoaXMuZGlyZWN0aW9uID09PSAnYm90dG9tJykge1xuICAgICAgcG9zaXRpb25zID0gW3tcbiAgICAgICAgb3ZlcmxheVg6ICdjZW50ZXInLFxuICAgICAgICBvdmVybGF5WTogJ3RvcCcsXG4gICAgICAgIG9yaWdpblg6ICdjZW50ZXInLFxuICAgICAgICBvcmlnaW5ZOiAnYm90dG9tJ1xuICAgICAgfV07XG4gICAgICBvZmZzZXRYID0gMDtcbiAgICAgIG9mZnNldFkgPSAyMDtcbiAgICB9IGVsc2UgaWYgKHRoaXMuZGlyZWN0aW9uID09PSAnbGVmdCcpIHtcbiAgICAgIHBvc2l0aW9ucyA9IFt7XG4gICAgICAgIG92ZXJsYXlYOiAnZW5kJyxcbiAgICAgICAgb3ZlcmxheVk6ICdjZW50ZXInLFxuICAgICAgICBvcmlnaW5YOiAnc3RhcnQnLFxuICAgICAgICBvcmlnaW5ZOiAnY2VudGVyJ1xuICAgICAgfV07XG4gICAgICBvZmZzZXRYID0gLTIwO1xuICAgICAgb2Zmc2V0WSA9IDA7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLm92ZXJsYXkucG9zaXRpb24oKS5mbGV4aWJsZUNvbm5lY3RlZFRvKHRoaXMuZWxlbWVudFJlZilcbiAgICAgIC53aXRoUG9zaXRpb25zKFsuLi5wb3NpdGlvbnMsIC4uLmZhbGxiYWNrc10pXG4gICAgICAud2l0aERlZmF1bHRPZmZzZXRYKG9mZnNldFgpXG4gICAgICAud2l0aERlZmF1bHRPZmZzZXRZKG9mZnNldFkpO1xuICB9XG5cbiAgLyoqIFJldHVybnMgdGhlIGZvY3VzIHRvIHRoZSBlbGVtZW50IGZvY3VzZWQgYmVmb3JlIHRoZSBQb3BvdmVyIHdhcyBvcGVuLiAqL1xuICBwcml2YXRlIF9yZXR1cm5Gb2N1c0FmdGVyUG9wb3ZlcigpIHtcbiAgICBjb25zdCB0b0ZvY3VzID0gdGhpcy5fZWxlbWVudEZvY3VzZWRCZWZvcmVQb3BvdmVyV2FzT3BlbmVkO1xuICAgIC8vIFdlIG5lZWQgdGhlIGV4dHJhIGNoZWNrLCBiZWNhdXNlIElFIGNhbiBzZXQgdGhlIGBhY3RpdmVFbGVtZW50YCB0byBudWxsIGluIHNvbWUgY2FzZXMuXG4gICAgaWYgKHRvRm9jdXMgJiYgdHlwZW9mIHRvRm9jdXMuZm9jdXMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRvRm9jdXMuZm9jdXMoKTtcbiAgICB9XG4gIH1cbn1cbiJdfQ==