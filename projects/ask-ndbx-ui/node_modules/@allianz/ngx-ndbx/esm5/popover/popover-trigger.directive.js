/**
 * @fileoverview added by tsickle
 * Generated from: popover/popover-trigger.directive.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import * as tslib_1 from "tslib";
import { coerceBooleanProperty } from '@angular/cdk/coercion';
import { Overlay, OverlayConfig } from '@angular/cdk/overlay';
import { TemplatePortal } from '@angular/cdk/portal';
import { Directive, ElementRef, EventEmitter, Inject, Input, Optional, Output, ViewContainerRef, NgZone } from '@angular/core';
import { EventManager } from '@angular/platform-browser';
import { fromEvent, Subject } from 'rxjs';
import { filter, map, takeUntil } from 'rxjs/operators';
import { FocusMonitor } from '@angular/cdk/a11y';
import { NxPopoverComponent } from './popover.component';
import { FocusTrapFactory } from '@angular/cdk/a11y';
import { DOCUMENT } from '@angular/common';
import { Platform } from '@angular/cdk/platform';
import { SPACE, ENTER } from '@angular/cdk/keycodes';
/** @type {?} */
var nextId = 0;
/** @type {?} */
var fallbacks = [
    {
        originX: 'start',
        originY: 'bottom',
        overlayX: 'start',
        overlayY: 'top',
        offsetX: 0,
        offsetY: 16
    },
    {
        originX: 'end',
        originY: 'top',
        overlayX: 'end',
        overlayY: 'bottom',
        offsetX: 0,
        offsetY: -16
    },
    {
        originX: 'center',
        originY: 'bottom',
        overlayX: 'center',
        overlayY: 'top',
        offsetX: 0,
        offsetY: 16
    },
    {
        originX: 'end',
        originY: 'bottom',
        overlayX: 'end',
        overlayY: 'top',
        offsetX: 0,
        offsetY: 16
    },
    {
        originX: 'end',
        originY: 'center',
        overlayX: 'start',
        overlayY: 'center',
        offsetX: 16,
        offsetY: 0
    },
    {
        originX: 'start',
        originY: 'center',
        overlayX: 'end',
        overlayY: 'center',
        offsetX: -16,
        offsetY: 0
    },
    {
        originX: 'center',
        originY: 'top',
        overlayX: 'center',
        overlayY: 'bottom',
        offsetX: 0,
        offsetY: -16
    },
    {
        originX: 'start',
        originY: 'top',
        overlayX: 'start',
        overlayY: 'bottom',
        offsetX: 0,
        offsetY: -16
    }
];
var NxPopoverTriggerDirective = /** @class */ (function () {
    function NxPopoverTriggerDirective(overlay, elementRef, viewContainerRef, eventManager, _focusTrapFactory, _focusMonitor, _ngZone, _platform, _document) {
        var _this = this;
        this.overlay = overlay;
        this.elementRef = elementRef;
        this.viewContainerRef = viewContainerRef;
        this.eventManager = eventManager;
        this._focusTrapFactory = _focusTrapFactory;
        this._focusMonitor = _focusMonitor;
        this._ngZone = _ngZone;
        this._platform = _platform;
        this._document = _document;
        this._destroyed = new Subject();
        this._show = false;
        this._closeable = null;
        /**
         * Element that was focused before the Popover was opened. Save this to restore upon close.
         */
        this._elementFocusedBeforePopoverWasOpened = null;
        this._manualListeners = new Map();
        /**
         * \@docs-private
         */
        this.id = 'nx-popover-' + nextId++;
        /**
         * An event is emitted if the visibility status of the popover changes.
         */
        this.changeShow = new EventEmitter();
        this._closeOnClickOutside = true;
        /**
         * Sets the desired direction to open the popover. E.g., right, left, bottom, top
         */
        this.direction = 'right';
        /**
         * Whether the popover will be opened automatically.
         */
        this.popoverInitialVisible = false;
        /**
         * An event is emitted when the visibility of the popopver changes.
         */
        this.visibleChange = new EventEmitter();
        /**
         * Whether the popover opens in modal state.
         */
        this.modal = false;
        // If nxPopoverTrigger equals to 'hover' the popover opens on mouseenter and closes on mouseout.
        // If nxPopoverTrigger equals to 'click' the popover opens on click and closes on a click of the close icon or pressing ESC key.
        // If nxPopoverTrigger equals to 'manual' the popover opens only when programatically requested.
        /**
         * Sets the way to trigger the popover. Options are hover, click, manual
         */
        this.trigger = 'click';
        /**
         * Sets the scroll strategy. 'close' closes the popover on scroll while 'reposition' scrolls the popover with the origin.
         */
        this.scrollStrategy = 'close';
        this._documentClickObservable = fromEvent(document, 'click');
        /** @type {?} */
        var element = elementRef.nativeElement;
        if (!this._platform.IOS && !this._platform.ANDROID) {
            this._manualListeners
                .set('mouseenter', (/**
             * @return {?}
             */
            function () {
                if (_this.trigger === 'hover') {
                    _this.show = true;
                }
            }))
                .set('mouseleave', (/**
             * @return {?}
             */
            function () {
                if (_this.trigger === 'hover') {
                    _this.show = false;
                }
            }))
                .set('keydown', (/**
             * @param {?} event
             * @return {?}
             */
            function (event) {
                switch (event.keyCode) {
                    case SPACE:
                    case ENTER:
                        _this.handleClick();
                        break;
                    default:
                        return;
                }
            }));
        }
        else {
            this._manualListeners.set('touchstart', (/**
             * @return {?}
             */
            function () {
                if (_this.trigger === 'hover') {
                    _this.show = true;
                }
            }));
        }
        this._manualListeners.forEach((/**
         * @param {?} listener
         * @param {?} event
         * @return {?}
         */
        function (listener, event) { return element.addEventListener(event, listener); }));
        this._focusMonitor.monitor(element).pipe(takeUntil(this._destroyed)).subscribe((/**
         * @param {?} origin
         * @return {?}
         */
        function (origin) {
            if (origin === 'keyboard' && _this.trigger === 'hover') {
                _this._ngZone.run((/**
                 * @return {?}
                 */
                function () { return _this.show = true; }));
            }
        }));
    }
    Object.defineProperty(NxPopoverTriggerDirective.prototype, "show", {
        get: /**
         * @return {?}
         */
        function () {
            return this._show;
        },
        /** Whether to show or hide the popover. */
        set: /**
         * Whether to show or hide the popover.
         * @param {?} value
         * @return {?}
         */
        function (value) {
            value = coerceBooleanProperty(value);
            if (this._show !== value) {
                this._show = value;
                if (this._show) {
                    this.openPopover();
                }
                else {
                    this.closePopover();
                }
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NxPopoverTriggerDirective.prototype, "closeable", {
        get: /**
         * @return {?}
         */
        function () {
            return this._closeable;
        },
        /** Whether to show a close button. By default a close icon is only shown for trigger type click. */
        set: /**
         * Whether to show a close button. By default a close icon is only shown for trigger type click.
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this._closeable = coerceBooleanProperty(value);
            if (this.popover) {
                this.popover.showCloseButton = this.isCloseable();
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NxPopoverTriggerDirective.prototype, "closeOnClickOutside", {
        get: /**
         * @return {?}
         */
        function () {
            return this._closeOnClickOutside;
        },
        /** Whether the popover should be closed on click outside of the popover in the trigger modes 'manual' and 'click'. */
        set: /**
         * Whether the popover should be closed on click outside of the popover in the trigger modes 'manual' and 'click'.
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this._closeOnClickOutside = coerceBooleanProperty(value);
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @return {?}
     */
    NxPopoverTriggerDirective.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        this.popover.showCloseButton = this.isCloseable();
    };
    /**
     * @return {?}
     */
    NxPopoverTriggerDirective.prototype.ngAfterViewInit = /**
     * @return {?}
     */
    function () {
        var _this = this;
        this.popover.id = this.id;
        this.eventManager.addGlobalEventListener('window', 'keyup.esc', (/**
         * @return {?}
         */
        function () {
            if (_this.isOpen) {
                _this.show = false;
            }
        }));
        this.popover.closeButtonClick.pipe(takeUntil(this._destroyed)).subscribe((/**
         * @return {?}
         */
        function () {
            _this.show = false;
        }));
        if (this.popoverInitialVisible || this._show) {
            this.show = true;
        }
    };
    /**
     * @return {?}
     */
    NxPopoverTriggerDirective.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        var _this = this;
        this.show = false;
        // Clean up the event listeners set in the constructor
        this._manualListeners.forEach((/**
         * @param {?} listener
         * @param {?} event
         * @return {?}
         */
        function (listener, event) {
            _this.elementRef.nativeElement.removeEventListener(event, listener);
        }));
        this._manualListeners.clear();
        this._destroyed.next();
        this._destroyed.complete();
    };
    Object.defineProperty(NxPopoverTriggerDirective.prototype, "isOpen", {
        /** @docs-private */
        get: /**
         * \@docs-private
         * @return {?}
         */
        function () {
            return this.overlayRef && this.createOverlay().hasAttached();
        },
        enumerable: true,
        configurable: true
    });
    /** @docs-private */
    /**
     * \@docs-private
     * @return {?}
     */
    NxPopoverTriggerDirective.prototype.isCloseable = /**
     * \@docs-private
     * @return {?}
     */
    function () {
        return (this.trigger === 'click' && this._closeable === null) || this._closeable;
    };
    /** Update the popover with the given position strategy. */
    /**
     * Update the popover with the given position strategy.
     * @return {?}
     */
    NxPopoverTriggerDirective.prototype.updatePosition = /**
     * Update the popover with the given position strategy.
     * @return {?}
     */
    function () {
        if (this._positionStrategy) {
            this._positionStrategy.apply();
        }
    };
    /** @docs-private */
    /**
     * \@docs-private
     * @return {?}
     */
    NxPopoverTriggerDirective.prototype.handleClick = /**
     * \@docs-private
     * @return {?}
     */
    function () {
        if (this.trigger === 'click') {
            this.show = !this.isOpen;
        }
        else if (this.trigger === 'hover') {
            this.show = true;
        }
    };
    /** Open the popover instance. */
    /**
     * Open the popover instance.
     * @return {?}
     */
    NxPopoverTriggerDirective.prototype.open = /**
     * Open the popover instance.
     * @return {?}
     */
    function () {
        this.show = true;
    };
    /** Close the popover instance. */
    /**
     * Close the popover instance.
     * @return {?}
     */
    NxPopoverTriggerDirective.prototype.close = /**
     * Close the popover instance.
     * @return {?}
     */
    function () {
        this.show = false;
    };
    /** Toggle the popover instance. */
    /**
     * Toggle the popover instance.
     * @return {?}
     */
    NxPopoverTriggerDirective.prototype.toggle = /**
     * Toggle the popover instance.
     * @return {?}
     */
    function () {
        this.show = !this.show;
    };
    /**
     * @private
     * @return {?}
     */
    NxPopoverTriggerDirective.prototype.openPopover = /**
     * @private
     * @return {?}
     */
    function () {
        if (!this.createOverlay().hasAttached()) {
            this._embeddedViewRef = this.createOverlay().attach(this.portal);
            /** @type {?} */
            var element = (/** @type {?} */ (this._embeddedViewRef.rootNodes[0]));
            this._focusTrap = this._focusTrapFactory.create(element);
            this._elementFocusedBeforePopoverWasOpened = this.elementRef.nativeElement;
            this._autoFocusFirstTabbableElement(element);
            // attach a close click listener only if it makes sense (ignore it on hover e.g.)
            if (this.shouldReactOnClickOutside()) {
                this.waitForClose();
            }
        }
    };
    /**
     * Autofocus the first tabbable element inside of the popover, if there is not a tabbable element,
     * focus the popover instead.
     */
    /**
     * Autofocus the first tabbable element inside of the popover, if there is not a tabbable element,
     * focus the popover instead.
     * @private
     * @param {?} element
     * @return {?}
     */
    NxPopoverTriggerDirective.prototype._autoFocusFirstTabbableElement = /**
     * Autofocus the first tabbable element inside of the popover, if there is not a tabbable element,
     * focus the popover instead.
     * @private
     * @param {?} element
     * @return {?}
     */
    function (element) {
        this._focusTrap.focusInitialElementWhenReady().then((/**
         * @param {?} hasMovedFocus
         * @return {?}
         */
        function (hasMovedFocus) {
            // If we didn't find any focusable elements inside the popover, focus the
            // container so the user can't tab into other elements behind it.
            if (!hasMovedFocus) {
                element.focus();
            }
        }));
    };
    /**
     * @private
     * @return {?}
     */
    NxPopoverTriggerDirective.prototype.shouldReactOnClickOutside = /**
     * @private
     * @return {?}
     */
    function () {
        return (!this.modal && this.closeOnClickOutside);
    };
    // detaches the overlay
    // we are listening to the detachments observable which will then emit the nxClosed event
    // on the popover component
    // detaches the overlay
    // we are listening to the detachments observable which will then emit the nxClosed event
    // on the popover component
    /**
     * @private
     * @return {?}
     */
    NxPopoverTriggerDirective.prototype.closePopover = 
    // detaches the overlay
    // we are listening to the detachments observable which will then emit the nxClosed event
    // on the popover component
    /**
     * @private
     * @return {?}
     */
    function () {
        if (this.overlayRef) {
            this._returnFocusAfterPopover();
            this.overlayRef.detach();
            this._embeddedViewRef = null;
            this._focusTrap.destroy();
        }
    };
    /**
     * @private
     * @return {?}
     */
    NxPopoverTriggerDirective.prototype.createOverlay = /**
     * @private
     * @return {?}
     */
    function () {
        if (!this.overlayRef) {
            this.portal = new TemplatePortal(this.popover.templateRef, this.viewContainerRef);
            /** @type {?} */
            var overlayState = new OverlayConfig();
            overlayState.positionStrategy = this.getPosition();
            this._positionStrategy = overlayState.positionStrategy;
            if (this.scrollStrategy === 'reposition') {
                overlayState.scrollStrategy = this.overlay.scrollStrategies.reposition();
            }
            else {
                overlayState.scrollStrategy = this.overlay.scrollStrategies.close();
            }
            overlayState.scrollStrategy.enable();
            if (this.modal && this.trigger === 'click') {
                overlayState.hasBackdrop = true;
            }
            this.overlayRef = this.overlay.create(overlayState);
            this.subscribeToPositions((/** @type {?} */ (overlayState.positionStrategy)));
            this._subscribeToAttach();
            this._subscribeToDetach();
            if (this.modal) {
                this._subscribeToBackdropClick();
            }
        }
        return this.overlayRef;
    };
    /**
     * @private
     * @param {?} position
     * @return {?}
     */
    NxPopoverTriggerDirective.prototype.subscribeToPositions = /**
     * @private
     * @param {?} position
     * @return {?}
     */
    function (position) {
        var _this = this;
        position.positionChanges.pipe(takeUntil(this._destroyed)).subscribe((/**
         * @param {?} change
         * @return {?}
         */
        function (change) {
            /** @type {?} */
            var pair = change.connectionPair;
            _this.positionOverlay(pair);
            _this.positionArrow(pair);
            // These position changes arrive too late,
            // We have to trigger the change detection manually
            // as it's detached from any render hierarchy
            // and only updated by the overlay when attached.
            if (_this._embeddedViewRef && !_this._embeddedViewRef.destroyed) {
                _this._embeddedViewRef.detectChanges();
            }
        }));
    };
    // for modal popovers close the popover on backdrop clicks
    // for modal popovers close the popover on backdrop clicks
    /**
     * @private
     * @return {?}
     */
    NxPopoverTriggerDirective.prototype._subscribeToBackdropClick = 
    // for modal popovers close the popover on backdrop clicks
    /**
     * @private
     * @return {?}
     */
    function () {
        var _this = this;
        this.overlayRef.backdropClick().pipe(takeUntil(this._destroyed)).subscribe((/**
         * @param {?} event
         * @return {?}
         */
        function (event) {
            _this.show = false;
        }));
    };
    // Emit the nxClosed and the show status change event on the popover component when the overlay detaches
    // Emit the nxClosed and the show status change event on the popover component when the overlay detaches
    /**
     * @private
     * @return {?}
     */
    NxPopoverTriggerDirective.prototype._subscribeToDetach = 
    // Emit the nxClosed and the show status change event on the popover component when the overlay detaches
    /**
     * @private
     * @return {?}
     */
    function () {
        var _this = this;
        this.overlayRef.detachments().pipe(takeUntil(this._destroyed)).subscribe((/**
         * @param {?} data
         * @return {?}
         */
        function (data) {
            // This is an exception: when the popover is closed by a scrolling event,
            // then only the detached method is called but the show state variable remains unchanged.
            if (_this.show) {
                _this.show = false;
            }
            _this.changeShow.emit(_this._show);
            _this.popover.emitClosedEvent();
        }));
    };
    /**
     * @private
     * @return {?}
     */
    NxPopoverTriggerDirective.prototype._subscribeToAttach = /**
     * @private
     * @return {?}
     */
    function () {
        var _this = this;
        this.overlayRef.attachments().pipe(takeUntil(this._destroyed)).subscribe((/**
         * @param {?} data
         * @return {?}
         */
        function (data) {
            _this.changeShow.emit(_this._show);
        }));
    };
    // subscribe to document clicks when trigger='click' to close the popover on clicks on the background
    // subscribe to document clicks when trigger='click' to close the popover on clicks on the background
    /**
     * @private
     * @return {?}
     */
    NxPopoverTriggerDirective.prototype.waitForClose = 
    // subscribe to document clicks when trigger='click' to close the popover on clicks on the background
    /**
     * @private
     * @return {?}
     */
    function () {
        var _this = this;
        return this._documentClickObservable
            .pipe(map((/**
         * @param {?} event
         * @return {?}
         */
        function (event) { return event.target; })), filter((/**
         * @param {?} target
         * @return {?}
         */
        function (target) { return !_this.elementRef.nativeElement.contains(target); })), takeUntil(this.popover.closed))
            .subscribe((/**
         * @return {?}
         */
        function () {
            _this.show = false;
        }));
    };
    /**
     * @private
     * @param {?} pair
     * @return {?}
     */
    NxPopoverTriggerDirective.prototype.positionOverlay = /**
     * @private
     * @param {?} pair
     * @return {?}
     */
    function (pair) {
        if (pair.originX === 'end' && pair.overlayX === 'start') {
            this.popover.direction = 'right';
        }
        else if (pair.originY === 'bottom' && pair.overlayY === 'top') {
            this.popover.direction = 'bottom';
        }
        else if (pair.originX === 'start' && pair.overlayX === 'end') {
            this.popover.direction = 'left';
        }
        else if (pair.originY === 'top' && pair.overlayY === 'bottom') {
            this.popover.direction = 'top';
        }
    };
    /**
     * @private
     * @param {?} pair
     * @return {?}
     */
    NxPopoverTriggerDirective.prototype.positionArrow = /**
     * @private
     * @param {?} pair
     * @return {?}
     */
    function (pair) {
        /** @type {?} */
        var parentElementPositionX = this.elementRef.nativeElement.getBoundingClientRect().left;
        /** @type {?} */
        var parentElementWidth = this.elementRef.nativeElement.getBoundingClientRect().width / 2;
        /** @type {?} */
        var parentElementLeftOffset = this.overlayRef.overlayElement.parentElement.offsetLeft;
        /** @type {?} */
        var overlayElementLeftOffset = this.overlayRef.overlayElement.offsetLeft;
        // calculation for x position of the parent element. In this case, overlay left offset is the one thing to consider.
        /** @type {?} */
        var targetPosition = (parentElementPositionX + parentElementWidth) - (parentElementLeftOffset + overlayElementLeftOffset);
        if (pair.originX === pair.overlayX) {
            /** @type {?} */
            var direction = 'left';
            /** @type {?} */
            var arrowStyle = {};
            arrowStyle[direction] = targetPosition + 'px';
            this.popover.arrowStyle = arrowStyle;
        }
        if ((pair.originY === 'bottom' || pair.originY === 'top') && pair.overlayX === 'center') {
            this.popover.arrowStyle = { left: targetPosition + 'px' };
        }
        if ((pair.originX === 'end' || pair.originX === 'start') && pair.overlayY === 'center') {
            this.popover.arrowStyle = { top: '50%' };
        }
    };
    /**
     * @private
     * @return {?}
     */
    NxPopoverTriggerDirective.prototype.getPosition = /**
     * @private
     * @return {?}
     */
    function () {
        /** @type {?} */
        var positions;
        /** @type {?} */
        var offsetX = 0;
        /** @type {?} */
        var offsetY = 0;
        if (this.direction === 'top') {
            positions = [{
                    overlayX: 'center',
                    overlayY: 'bottom',
                    originX: 'center',
                    originY: 'top'
                }];
            offsetX = 0;
            offsetY = -20;
        }
        else if (this.direction === 'right') {
            positions = [{
                    overlayX: 'start',
                    overlayY: 'center',
                    originX: 'end',
                    originY: 'center'
                }];
            offsetX = 20;
            offsetY = 0;
        }
        else if (this.direction === 'bottom') {
            positions = [{
                    overlayX: 'center',
                    overlayY: 'top',
                    originX: 'center',
                    originY: 'bottom'
                }];
            offsetX = 0;
            offsetY = 20;
        }
        else if (this.direction === 'left') {
            positions = [{
                    overlayX: 'end',
                    overlayY: 'center',
                    originX: 'start',
                    originY: 'center'
                }];
            offsetX = -20;
            offsetY = 0;
        }
        return this.overlay.position().flexibleConnectedTo(this.elementRef)
            .withPositions(tslib_1.__spread(positions, fallbacks))
            .withDefaultOffsetX(offsetX)
            .withDefaultOffsetY(offsetY);
    };
    /** Returns the focus to the element focused before the Popover was open. */
    /**
     * Returns the focus to the element focused before the Popover was open.
     * @private
     * @return {?}
     */
    NxPopoverTriggerDirective.prototype._returnFocusAfterPopover = /**
     * Returns the focus to the element focused before the Popover was open.
     * @private
     * @return {?}
     */
    function () {
        /** @type {?} */
        var toFocus = this._elementFocusedBeforePopoverWasOpened;
        // We need the extra check, because IE can set the `activeElement` to null in some cases.
        if (toFocus && typeof toFocus.focus === 'function') {
            toFocus.focus();
        }
    };
    NxPopoverTriggerDirective.decorators = [
        { type: Directive, args: [{
                    selector: '[nxPopoverTriggerFor]',
                    exportAs: 'nxPopoverTrigger',
                    host: {
                        '(click)': 'handleClick()',
                        'aria-haspopup': 'true',
                        '[attr.aria-expanded]': 'isOpen',
                        '[attr.aria-describedby]': 'isOpen ? id : null'
                    }
                },] }
    ];
    /** @nocollapse */
    NxPopoverTriggerDirective.ctorParameters = function () { return [
        { type: Overlay },
        { type: ElementRef },
        { type: ViewContainerRef },
        { type: EventManager },
        { type: FocusTrapFactory },
        { type: FocusMonitor },
        { type: NgZone },
        { type: Platform },
        { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [DOCUMENT,] }] }
    ]; };
    NxPopoverTriggerDirective.propDecorators = {
        changeShow: [{ type: Output, args: ['nxPopoverShowChange',] }],
        show: [{ type: Input, args: ['nxPopoverShow',] }],
        closeable: [{ type: Input, args: ['nxPopoverCloseable',] }],
        closeOnClickOutside: [{ type: Input }],
        popover: [{ type: Input, args: ['nxPopoverTriggerFor',] }],
        direction: [{ type: Input, args: ['nxPopoverDirection',] }],
        popoverInitialVisible: [{ type: Input, args: ['nxPopoverInitialVisible',] }],
        visibleChange: [{ type: Input, args: ['nxPopoverVisibleChange',] }],
        modal: [{ type: Input, args: ['nxPopoverModal',] }],
        trigger: [{ type: Input, args: ['nxPopoverTrigger',] }],
        scrollStrategy: [{ type: Input, args: ['nxPopoverScrollStrategy',] }]
    };
    return NxPopoverTriggerDirective;
}());
export { NxPopoverTriggerDirective };
if (false) {
    /**
     * @type {?}
     * @private
     */
    NxPopoverTriggerDirective.prototype.overlayRef;
    /**
     * @type {?}
     * @private
     */
    NxPopoverTriggerDirective.prototype.portal;
    /**
     * @type {?}
     * @private
     */
    NxPopoverTriggerDirective.prototype._destroyed;
    /**
     * @type {?}
     * @private
     */
    NxPopoverTriggerDirective.prototype._show;
    /**
     * @type {?}
     * @private
     */
    NxPopoverTriggerDirective.prototype._closeable;
    /**
     * @type {?}
     * @private
     */
    NxPopoverTriggerDirective.prototype._positionStrategy;
    /**
     * @type {?}
     * @private
     */
    NxPopoverTriggerDirective.prototype._embeddedViewRef;
    /**
     * @type {?}
     * @private
     */
    NxPopoverTriggerDirective.prototype._documentClickObservable;
    /**
     * The class that traps and manages focus within the popover.
     * @type {?}
     * @private
     */
    NxPopoverTriggerDirective.prototype._focusTrap;
    /**
     * Element that was focused before the Popover was opened. Save this to restore upon close.
     * @type {?}
     * @private
     */
    NxPopoverTriggerDirective.prototype._elementFocusedBeforePopoverWasOpened;
    /**
     * @type {?}
     * @private
     */
    NxPopoverTriggerDirective.prototype._manualListeners;
    /**
     * \@docs-private
     * @type {?}
     */
    NxPopoverTriggerDirective.prototype.id;
    /**
     * An event is emitted if the visibility status of the popover changes.
     * @type {?}
     */
    NxPopoverTriggerDirective.prototype.changeShow;
    /**
     * @type {?}
     * @private
     */
    NxPopoverTriggerDirective.prototype._closeOnClickOutside;
    /**
     * Links the trigger with the popover to open.
     * @type {?}
     */
    NxPopoverTriggerDirective.prototype.popover;
    /**
     * Sets the desired direction to open the popover. E.g., right, left, bottom, top
     * @type {?}
     */
    NxPopoverTriggerDirective.prototype.direction;
    /**
     * Whether the popover will be opened automatically.
     * @type {?}
     */
    NxPopoverTriggerDirective.prototype.popoverInitialVisible;
    /**
     * An event is emitted when the visibility of the popopver changes.
     * @type {?}
     */
    NxPopoverTriggerDirective.prototype.visibleChange;
    /**
     * Whether the popover opens in modal state.
     * @type {?}
     */
    NxPopoverTriggerDirective.prototype.modal;
    /**
     * Sets the way to trigger the popover. Options are hover, click, manual
     * @type {?}
     */
    NxPopoverTriggerDirective.prototype.trigger;
    /**
     * Sets the scroll strategy. 'close' closes the popover on scroll while 'reposition' scrolls the popover with the origin.
     * @type {?}
     */
    NxPopoverTriggerDirective.prototype.scrollStrategy;
    /**
     * @type {?}
     * @private
     */
    NxPopoverTriggerDirective.prototype.overlay;
    /**
     * @type {?}
     * @private
     */
    NxPopoverTriggerDirective.prototype.elementRef;
    /**
     * @type {?}
     * @private
     */
    NxPopoverTriggerDirective.prototype.viewContainerRef;
    /**
     * @type {?}
     * @private
     */
    NxPopoverTriggerDirective.prototype.eventManager;
    /**
     * @type {?}
     * @private
     */
    NxPopoverTriggerDirective.prototype._focusTrapFactory;
    /**
     * @type {?}
     * @private
     */
    NxPopoverTriggerDirective.prototype._focusMonitor;
    /**
     * @type {?}
     * @private
     */
    NxPopoverTriggerDirective.prototype._ngZone;
    /**
     * @type {?}
     * @private
     */
    NxPopoverTriggerDirective.prototype._platform;
    /**
     * @type {?}
     * @private
     */
    NxPopoverTriggerDirective.prototype._document;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicG9wb3Zlci10cmlnZ2VyLmRpcmVjdGl2ZS5qcyIsInNvdXJjZVJvb3QiOiJuZzovL0BhbGxpYW56L25neC1uZGJ4LyIsInNvdXJjZXMiOlsicG9wb3Zlci9wb3BvdmVyLXRyaWdnZXIuZGlyZWN0aXZlLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7OztBQUFBLE9BQU8sRUFBRSxxQkFBcUIsRUFBRSxNQUFNLHVCQUF1QixDQUFDO0FBQzlELE9BQU8sRUFJTCxPQUFPLEVBQ1AsYUFBYSxFQUdkLE1BQU0sc0JBQXNCLENBQUM7QUFDOUIsT0FBTyxFQUFFLGNBQWMsRUFBRSxNQUFNLHFCQUFxQixDQUFDO0FBQ3JELE9BQU8sRUFFTCxTQUFTLEVBQ1QsVUFBVSxFQUVWLFlBQVksRUFDWixNQUFNLEVBQ04sS0FBSyxFQUdMLFFBQVEsRUFDUixNQUFNLEVBQ04sZ0JBQWdCLEVBQ2hCLE1BQU0sRUFDUCxNQUFNLGVBQWUsQ0FBQztBQUN2QixPQUFPLEVBQUUsWUFBWSxFQUFFLE1BQU0sMkJBQTJCLENBQUM7QUFDekQsT0FBTyxFQUFFLFNBQVMsRUFBYyxPQUFPLEVBQUUsTUFBTSxNQUFNLENBQUM7QUFDdEQsT0FBTyxFQUFFLE1BQU0sRUFBRSxHQUFHLEVBQUUsU0FBUyxFQUFFLE1BQU0sZ0JBQWdCLENBQUM7QUFDeEQsT0FBTyxFQUFFLFlBQVksRUFBRSxNQUFNLG1CQUFtQixDQUFDO0FBQ2pELE9BQU8sRUFBRSxrQkFBa0IsRUFBRSxNQUFNLHFCQUFxQixDQUFDO0FBQ3pELE9BQU8sRUFBRSxnQkFBZ0IsRUFBYSxNQUFNLG1CQUFtQixDQUFDO0FBQ2hFLE9BQU8sRUFBRSxRQUFRLEVBQUUsTUFBTSxpQkFBaUIsQ0FBQztBQUMzQyxPQUFPLEVBQUUsUUFBUSxFQUFFLE1BQU0sdUJBQXVCLENBQUM7QUFDakQsT0FBTyxFQUFFLEtBQUssRUFBRSxLQUFLLEVBQUUsTUFBTSx1QkFBdUIsQ0FBQzs7SUFLakQsTUFBTSxHQUFHLENBQUM7O0lBRVIsU0FBUyxHQUE2QjtJQUMxQztRQUNFLE9BQU8sRUFBRSxPQUFPO1FBQ2hCLE9BQU8sRUFBRSxRQUFRO1FBQ2pCLFFBQVEsRUFBRSxPQUFPO1FBQ2pCLFFBQVEsRUFBRSxLQUFLO1FBQ2YsT0FBTyxFQUFFLENBQUM7UUFDVixPQUFPLEVBQUUsRUFBRTtLQUNaO0lBQ0Q7UUFDRSxPQUFPLEVBQUUsS0FBSztRQUNkLE9BQU8sRUFBRSxLQUFLO1FBQ2QsUUFBUSxFQUFFLEtBQUs7UUFDZixRQUFRLEVBQUUsUUFBUTtRQUNsQixPQUFPLEVBQUUsQ0FBQztRQUNWLE9BQU8sRUFBRSxDQUFDLEVBQUU7S0FDYjtJQUNEO1FBQ0UsT0FBTyxFQUFFLFFBQVE7UUFDakIsT0FBTyxFQUFFLFFBQVE7UUFDakIsUUFBUSxFQUFFLFFBQVE7UUFDbEIsUUFBUSxFQUFFLEtBQUs7UUFDZixPQUFPLEVBQUUsQ0FBQztRQUNWLE9BQU8sRUFBRSxFQUFFO0tBQ1o7SUFDRDtRQUNFLE9BQU8sRUFBRSxLQUFLO1FBQ2QsT0FBTyxFQUFFLFFBQVE7UUFDakIsUUFBUSxFQUFFLEtBQUs7UUFDZixRQUFRLEVBQUUsS0FBSztRQUNmLE9BQU8sRUFBRSxDQUFDO1FBQ1YsT0FBTyxFQUFFLEVBQUU7S0FDWjtJQUNEO1FBQ0UsT0FBTyxFQUFFLEtBQUs7UUFDZCxPQUFPLEVBQUUsUUFBUTtRQUNqQixRQUFRLEVBQUUsT0FBTztRQUNqQixRQUFRLEVBQUUsUUFBUTtRQUNsQixPQUFPLEVBQUUsRUFBRTtRQUNYLE9BQU8sRUFBRSxDQUFDO0tBQ1g7SUFDRDtRQUNFLE9BQU8sRUFBRSxPQUFPO1FBQ2hCLE9BQU8sRUFBRSxRQUFRO1FBQ2pCLFFBQVEsRUFBRSxLQUFLO1FBQ2YsUUFBUSxFQUFFLFFBQVE7UUFDbEIsT0FBTyxFQUFFLENBQUMsRUFBRTtRQUNaLE9BQU8sRUFBRSxDQUFDO0tBQ1g7SUFDRDtRQUNFLE9BQU8sRUFBRSxRQUFRO1FBQ2pCLE9BQU8sRUFBRSxLQUFLO1FBQ2QsUUFBUSxFQUFFLFFBQVE7UUFDbEIsUUFBUSxFQUFFLFFBQVE7UUFDbEIsT0FBTyxFQUFFLENBQUM7UUFDVixPQUFPLEVBQUUsQ0FBQyxFQUFFO0tBQ2I7SUFDRDtRQUNFLE9BQU8sRUFBRSxPQUFPO1FBQ2hCLE9BQU8sRUFBRSxLQUFLO1FBQ2QsUUFBUSxFQUFFLE9BQU87UUFDakIsUUFBUSxFQUFFLFFBQVE7UUFDbEIsT0FBTyxFQUFFLENBQUM7UUFDVixPQUFPLEVBQUUsQ0FBQyxFQUFFO0tBQ2I7Q0FDRjtBQUVEO0lBd0dFLG1DQUFvQixPQUFnQixFQUNoQixVQUFzQixFQUN0QixnQkFBa0MsRUFDbEMsWUFBMEIsRUFDMUIsaUJBQW1DLEVBQ25DLGFBQTJCLEVBQzNCLE9BQWUsRUFDZixTQUFtQixFQUNXLFNBQWM7UUFSaEUsaUJBZ0RDO1FBaERtQixZQUFPLEdBQVAsT0FBTyxDQUFTO1FBQ2hCLGVBQVUsR0FBVixVQUFVLENBQVk7UUFDdEIscUJBQWdCLEdBQWhCLGdCQUFnQixDQUFrQjtRQUNsQyxpQkFBWSxHQUFaLFlBQVksQ0FBYztRQUMxQixzQkFBaUIsR0FBakIsaUJBQWlCLENBQWtCO1FBQ25DLGtCQUFhLEdBQWIsYUFBYSxDQUFjO1FBQzNCLFlBQU8sR0FBUCxPQUFPLENBQVE7UUFDZixjQUFTLEdBQVQsU0FBUyxDQUFVO1FBQ1csY0FBUyxHQUFULFNBQVMsQ0FBSztRQW5HeEQsZUFBVSxHQUFHLElBQUksT0FBTyxFQUFRLENBQUM7UUFDakMsVUFBSyxHQUFZLEtBQUssQ0FBQztRQUN2QixlQUFVLEdBQVksSUFBSSxDQUFDOzs7O1FBTzNCLDBDQUFxQyxHQUF1QixJQUFJLENBQUM7UUFDakUscUJBQWdCLEdBQUcsSUFBSSxHQUFHLEVBQThDLENBQUM7Ozs7UUFFakYsT0FBRSxHQUFHLGFBQWEsR0FBRyxNQUFNLEVBQUUsQ0FBQzs7OztRQUk5QixlQUFVLEdBQTBCLElBQUksWUFBWSxFQUFFLENBQUM7UUEwQy9DLHlCQUFvQixHQUFZLElBQUksQ0FBQzs7OztRQVE3QyxjQUFTLEdBQXFCLE9BQU8sQ0FBQzs7OztRQUl0QywwQkFBcUIsR0FBWSxLQUFLLENBQUM7Ozs7UUFJdkMsa0JBQWEsR0FBMEIsSUFBSSxZQUFZLEVBQUUsQ0FBQzs7OztRQUkxRCxVQUFLLEdBQVksS0FBSyxDQUFDOzs7Ozs7O1FBT3ZCLFlBQU8sR0FBdUIsT0FBTyxDQUFDOzs7O1FBSXRDLG1CQUFjLEdBQWlDLE9BQU8sQ0FBQztRQVdyRCxJQUFJLENBQUMsd0JBQXdCLEdBQUcsU0FBUyxDQUFhLFFBQVEsRUFBRSxPQUFPLENBQUMsQ0FBQzs7WUFDbkUsT0FBTyxHQUFnQixVQUFVLENBQUMsYUFBYTtRQUNyRCxJQUFJLENBQUMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxHQUFHLElBQUksQ0FBQyxJQUFJLENBQUMsU0FBUyxDQUFDLE9BQU8sRUFBRTtZQUNsRCxJQUFJLENBQUMsZ0JBQWdCO2lCQUNsQixHQUFHLENBQUMsWUFBWTs7O1lBQUU7Z0JBQ2pCLElBQUksS0FBSSxDQUFDLE9BQU8sS0FBSyxPQUFPLEVBQUU7b0JBQzVCLEtBQUksQ0FBQyxJQUFJLEdBQUcsSUFBSSxDQUFDO2lCQUNsQjtZQUNILENBQUMsRUFBQztpQkFDRCxHQUFHLENBQUMsWUFBWTs7O1lBQUU7Z0JBQ2pCLElBQUksS0FBSSxDQUFDLE9BQU8sS0FBSyxPQUFPLEVBQUU7b0JBQzVCLEtBQUksQ0FBQyxJQUFJLEdBQUcsS0FBSyxDQUFDO2lCQUNuQjtZQUNILENBQUMsRUFBQztpQkFDRCxHQUFHLENBQUMsU0FBUzs7OztZQUFFLFVBQUMsS0FBb0I7Z0JBQ25DLFFBQVEsS0FBSyxDQUFDLE9BQU8sRUFBRTtvQkFDckIsS0FBSyxLQUFLLENBQUM7b0JBQ1gsS0FBSyxLQUFLO3dCQUNSLEtBQUksQ0FBQyxXQUFXLEVBQUUsQ0FBQzt3QkFDbkIsTUFBTTtvQkFDUjt3QkFDRSxPQUFPO2lCQUNWO1lBQ0gsQ0FBQyxFQUFDLENBQUM7U0FDTjthQUFNO1lBQ0wsSUFBSSxDQUFDLGdCQUFnQixDQUFDLEdBQUcsQ0FBQyxZQUFZOzs7WUFBRTtnQkFDdEMsSUFBSSxLQUFJLENBQUMsT0FBTyxLQUFLLE9BQU8sRUFBRTtvQkFDNUIsS0FBSSxDQUFDLElBQUksR0FBRyxJQUFJLENBQUM7aUJBQ2xCO1lBQ0gsQ0FBQyxFQUFDLENBQUM7U0FDSjtRQUVELElBQUksQ0FBQyxnQkFBZ0IsQ0FBQyxPQUFPOzs7OztRQUFDLFVBQUMsUUFBUSxFQUFFLEtBQUssSUFBSyxPQUFBLE9BQU8sQ0FBQyxnQkFBZ0IsQ0FBQyxLQUFLLEVBQUUsUUFBUSxDQUFDLEVBQXpDLENBQXlDLEVBQUMsQ0FBQztRQUU5RixJQUFJLENBQUMsYUFBYSxDQUFDLE9BQU8sQ0FBQyxPQUFPLENBQUMsQ0FBQyxJQUFJLENBQUMsU0FBUyxDQUFDLElBQUksQ0FBQyxVQUFVLENBQUMsQ0FBQyxDQUFDLFNBQVM7Ozs7UUFBQyxVQUFBLE1BQU07WUFDbkYsSUFBSSxNQUFNLEtBQUssVUFBVSxJQUFJLEtBQUksQ0FBQyxPQUFPLEtBQUssT0FBTyxFQUFFO2dCQUNyRCxLQUFJLENBQUMsT0FBTyxDQUFDLEdBQUc7OztnQkFBQyxjQUFNLE9BQUEsS0FBSSxDQUFDLElBQUksR0FBRyxJQUFJLEVBQWhCLENBQWdCLEVBQUMsQ0FBQzthQUMxQztRQUNILENBQUMsRUFBQyxDQUFDO0lBQ0wsQ0FBQztJQXhIRCxzQkFDSSwyQ0FBSTs7OztRQVlSO1lBQ0UsT0FBTyxJQUFJLENBQUMsS0FBSyxDQUFDO1FBQ3BCLENBQUM7UUFoQkQsMkNBQTJDOzs7Ozs7UUFDM0MsVUFDUyxLQUFjO1lBQ3JCLEtBQUssR0FBRyxxQkFBcUIsQ0FBQyxLQUFLLENBQUMsQ0FBQztZQUNyQyxJQUFJLElBQUksQ0FBQyxLQUFLLEtBQUssS0FBSyxFQUFFO2dCQUN4QixJQUFJLENBQUMsS0FBSyxHQUFHLEtBQUssQ0FBQztnQkFDbkIsSUFBSSxJQUFJLENBQUMsS0FBSyxFQUFFO29CQUNkLElBQUksQ0FBQyxXQUFXLEVBQUUsQ0FBQztpQkFDcEI7cUJBQU07b0JBQ0wsSUFBSSxDQUFDLFlBQVksRUFBRSxDQUFDO2lCQUNyQjthQUNGO1FBQ0gsQ0FBQzs7O09BQUE7SUFPRCxzQkFDSSxnREFBUzs7OztRQU9iO1lBQ0UsT0FBTyxJQUFJLENBQUMsVUFBVSxDQUFDO1FBQ3pCLENBQUM7UUFYRCxvR0FBb0c7Ozs7OztRQUNwRyxVQUNjLEtBQWM7WUFDMUIsSUFBSSxDQUFDLFVBQVUsR0FBRyxxQkFBcUIsQ0FBQyxLQUFLLENBQUMsQ0FBQztZQUUvQyxJQUFJLElBQUksQ0FBQyxPQUFPLEVBQUU7Z0JBQ2hCLElBQUksQ0FBQyxPQUFPLENBQUMsZUFBZSxHQUFHLElBQUksQ0FBQyxXQUFXLEVBQUUsQ0FBQzthQUNuRDtRQUNILENBQUM7OztPQUFBO0lBTUQsc0JBQ0ksMERBQW1COzs7O1FBR3ZCO1lBQ0UsT0FBTyxJQUFJLENBQUMsb0JBQW9CLENBQUM7UUFDbkMsQ0FBQztRQVBELHNIQUFzSDs7Ozs7O1FBQ3RILFVBQ3dCLEtBQWM7WUFDcEMsSUFBSSxDQUFDLG9CQUFvQixHQUFHLHFCQUFxQixDQUFDLEtBQUssQ0FBQyxDQUFDO1FBQzNELENBQUM7OztPQUFBOzs7O0lBd0ZELDRDQUFROzs7SUFBUjtRQUNFLElBQUksQ0FBQyxPQUFPLENBQUMsZUFBZSxHQUFHLElBQUksQ0FBQyxXQUFXLEVBQUUsQ0FBQztJQUNwRCxDQUFDOzs7O0lBRUQsbURBQWU7OztJQUFmO1FBQUEsaUJBZ0JDO1FBZkMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxFQUFFLEdBQUcsSUFBSSxDQUFDLEVBQUUsQ0FBQztRQUUxQixJQUFJLENBQUMsWUFBWSxDQUFDLHNCQUFzQixDQUFDLFFBQVEsRUFBRSxXQUFXOzs7UUFBRTtZQUM5RCxJQUFJLEtBQUksQ0FBQyxNQUFNLEVBQUU7Z0JBQ2YsS0FBSSxDQUFDLElBQUksR0FBRyxLQUFLLENBQUM7YUFDbkI7UUFDSCxDQUFDLEVBQUMsQ0FBQztRQUVILElBQUksQ0FBQyxPQUFPLENBQUMsZ0JBQWdCLENBQUMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxJQUFJLENBQUMsVUFBVSxDQUFDLENBQUMsQ0FBQyxTQUFTOzs7UUFBQztZQUN2RSxLQUFJLENBQUMsSUFBSSxHQUFHLEtBQUssQ0FBQztRQUNwQixDQUFDLEVBQUMsQ0FBQztRQUVILElBQUksSUFBSSxDQUFDLHFCQUFxQixJQUFJLElBQUksQ0FBQyxLQUFLLEVBQUU7WUFDNUMsSUFBSSxDQUFDLElBQUksR0FBRyxJQUFJLENBQUM7U0FDbEI7SUFDSCxDQUFDOzs7O0lBRUQsK0NBQVc7OztJQUFYO1FBQUEsaUJBU0M7UUFSQyxJQUFJLENBQUMsSUFBSSxHQUFHLEtBQUssQ0FBQztRQUNsQixzREFBc0Q7UUFDdEQsSUFBSSxDQUFDLGdCQUFnQixDQUFDLE9BQU87Ozs7O1FBQUMsVUFBQyxRQUFRLEVBQUUsS0FBSztZQUM1QyxLQUFJLENBQUMsVUFBVSxDQUFDLGFBQWEsQ0FBQyxtQkFBbUIsQ0FBQyxLQUFLLEVBQUUsUUFBUSxDQUFDLENBQUM7UUFDckUsQ0FBQyxFQUFDLENBQUM7UUFDSCxJQUFJLENBQUMsZ0JBQWdCLENBQUMsS0FBSyxFQUFFLENBQUM7UUFDOUIsSUFBSSxDQUFDLFVBQVUsQ0FBQyxJQUFJLEVBQUUsQ0FBQztRQUN2QixJQUFJLENBQUMsVUFBVSxDQUFDLFFBQVEsRUFBRSxDQUFDO0lBQzdCLENBQUM7SUFHRCxzQkFBSSw2Q0FBTTtRQURWLG9CQUFvQjs7Ozs7UUFDcEI7WUFDRSxPQUFPLElBQUksQ0FBQyxVQUFVLElBQUksSUFBSSxDQUFDLGFBQWEsRUFBRSxDQUFDLFdBQVcsRUFBRSxDQUFDO1FBQy9ELENBQUM7OztPQUFBO0lBRUQsb0JBQW9COzs7OztJQUNwQiwrQ0FBVzs7OztJQUFYO1FBQ0UsT0FBTyxDQUFDLElBQUksQ0FBQyxPQUFPLEtBQUssT0FBTyxJQUFJLElBQUksQ0FBQyxVQUFVLEtBQUssSUFBSSxDQUFDLElBQUksSUFBSSxDQUFDLFVBQVUsQ0FBQztJQUNuRixDQUFDO0lBRUQsMkRBQTJEOzs7OztJQUMzRCxrREFBYzs7OztJQUFkO1FBQ0UsSUFBSSxJQUFJLENBQUMsaUJBQWlCLEVBQUU7WUFDMUIsSUFBSSxDQUFDLGlCQUFpQixDQUFDLEtBQUssRUFBRSxDQUFDO1NBQ2hDO0lBQ0gsQ0FBQztJQUVELG9CQUFvQjs7Ozs7SUFDcEIsK0NBQVc7Ozs7SUFBWDtRQUNFLElBQUksSUFBSSxDQUFDLE9BQU8sS0FBSyxPQUFPLEVBQUU7WUFDNUIsSUFBSSxDQUFDLElBQUksR0FBRyxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUM7U0FDMUI7YUFBTSxJQUFJLElBQUksQ0FBQyxPQUFPLEtBQUssT0FBTyxFQUFFO1lBQ25DLElBQUksQ0FBQyxJQUFJLEdBQUcsSUFBSSxDQUFDO1NBQ2xCO0lBQ0gsQ0FBQztJQUVELGlDQUFpQzs7Ozs7SUFDakMsd0NBQUk7Ozs7SUFBSjtRQUNFLElBQUksQ0FBQyxJQUFJLEdBQUcsSUFBSSxDQUFDO0lBQ25CLENBQUM7SUFFRCxrQ0FBa0M7Ozs7O0lBQ2xDLHlDQUFLOzs7O0lBQUw7UUFDRSxJQUFJLENBQUMsSUFBSSxHQUFHLEtBQUssQ0FBQztJQUNwQixDQUFDO0lBRUQsbUNBQW1DOzs7OztJQUNuQywwQ0FBTTs7OztJQUFOO1FBQ0UsSUFBSSxDQUFDLElBQUksR0FBRyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUM7SUFDekIsQ0FBQzs7Ozs7SUFFTywrQ0FBVzs7OztJQUFuQjtRQUNFLElBQUksQ0FBQyxJQUFJLENBQUMsYUFBYSxFQUFFLENBQUMsV0FBVyxFQUFFLEVBQUU7WUFDdkMsSUFBSSxDQUFDLGdCQUFnQixHQUFHLElBQUksQ0FBQyxhQUFhLEVBQUUsQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxDQUFDOztnQkFFM0QsT0FBTyxHQUFHLG1CQUFBLElBQUksQ0FBQyxnQkFBZ0IsQ0FBQyxTQUFTLENBQUMsQ0FBQyxDQUFDLEVBQWU7WUFDakUsSUFBSSxDQUFDLFVBQVUsR0FBRyxJQUFJLENBQUMsaUJBQWlCLENBQUMsTUFBTSxDQUFDLE9BQU8sQ0FBQyxDQUFDO1lBQ3pELElBQUksQ0FBQyxxQ0FBcUMsR0FBRyxJQUFJLENBQUMsVUFBVSxDQUFDLGFBQWEsQ0FBQztZQUMzRSxJQUFJLENBQUMsOEJBQThCLENBQUMsT0FBTyxDQUFDLENBQUM7WUFFN0MsaUZBQWlGO1lBQ2pGLElBQUksSUFBSSxDQUFDLHlCQUF5QixFQUFFLEVBQUU7Z0JBQ3BDLElBQUksQ0FBQyxZQUFZLEVBQUUsQ0FBQzthQUNyQjtTQUNGO0lBQ0gsQ0FBQztJQUVEOzs7T0FHRzs7Ozs7Ozs7SUFDSyxrRUFBOEI7Ozs7Ozs7SUFBdEMsVUFBdUMsT0FBb0I7UUFDekQsSUFBSSxDQUFDLFVBQVUsQ0FBQyw0QkFBNEIsRUFBRSxDQUFDLElBQUk7Ozs7UUFBQyxVQUFBLGFBQWE7WUFDL0QseUVBQXlFO1lBQ3pFLGlFQUFpRTtZQUNqRSxJQUFJLENBQUMsYUFBYSxFQUFFO2dCQUNsQixPQUFPLENBQUMsS0FBSyxFQUFFLENBQUM7YUFDakI7UUFDSCxDQUFDLEVBQUMsQ0FBQztJQUNMLENBQUM7Ozs7O0lBRU8sNkRBQXlCOzs7O0lBQWpDO1FBQ0UsT0FBTyxDQUFDLENBQUMsSUFBSSxDQUFDLEtBQUssSUFBSSxJQUFJLENBQUMsbUJBQW1CLENBQUMsQ0FBQztJQUNuRCxDQUFDO0lBRUQsdUJBQXVCO0lBQ3ZCLHlGQUF5RjtJQUN6RiwyQkFBMkI7Ozs7Ozs7O0lBQ25CLGdEQUFZOzs7Ozs7OztJQUFwQjtRQUNFLElBQUksSUFBSSxDQUFDLFVBQVUsRUFBRTtZQUNuQixJQUFJLENBQUMsd0JBQXdCLEVBQUUsQ0FBQztZQUNoQyxJQUFJLENBQUMsVUFBVSxDQUFDLE1BQU0sRUFBRSxDQUFDO1lBQ3pCLElBQUksQ0FBQyxnQkFBZ0IsR0FBRyxJQUFJLENBQUM7WUFDN0IsSUFBSSxDQUFDLFVBQVUsQ0FBQyxPQUFPLEVBQUUsQ0FBQztTQUMzQjtJQUNILENBQUM7Ozs7O0lBRU8saURBQWE7Ozs7SUFBckI7UUFDRSxJQUFJLENBQUMsSUFBSSxDQUFDLFVBQVUsRUFBRTtZQUNwQixJQUFJLENBQUMsTUFBTSxHQUFHLElBQUksY0FBYyxDQUFDLElBQUksQ0FBQyxPQUFPLENBQUMsV0FBVyxFQUFFLElBQUksQ0FBQyxnQkFBZ0IsQ0FBQyxDQUFDOztnQkFDNUUsWUFBWSxHQUFHLElBQUksYUFBYSxFQUFFO1lBQ3hDLFlBQVksQ0FBQyxnQkFBZ0IsR0FBRyxJQUFJLENBQUMsV0FBVyxFQUFFLENBQUM7WUFDbkQsSUFBSSxDQUFDLGlCQUFpQixHQUFHLFlBQVksQ0FBQyxnQkFBZ0IsQ0FBQztZQUV2RCxJQUFJLElBQUksQ0FBQyxjQUFjLEtBQUssWUFBWSxFQUFFO2dCQUN4QyxZQUFZLENBQUMsY0FBYyxHQUFHLElBQUksQ0FBQyxPQUFPLENBQUMsZ0JBQWdCLENBQUMsVUFBVSxFQUFFLENBQUM7YUFDMUU7aUJBQU07Z0JBQ0wsWUFBWSxDQUFDLGNBQWMsR0FBRyxJQUFJLENBQUMsT0FBTyxDQUFDLGdCQUFnQixDQUFDLEtBQUssRUFBRSxDQUFDO2FBQ3JFO1lBRUQsWUFBWSxDQUFDLGNBQWMsQ0FBQyxNQUFNLEVBQUUsQ0FBQztZQUVyQyxJQUFJLElBQUksQ0FBQyxLQUFLLElBQUksSUFBSSxDQUFDLE9BQU8sS0FBSyxPQUFPLEVBQUU7Z0JBQzFDLFlBQVksQ0FBQyxXQUFXLEdBQUcsSUFBSSxDQUFDO2FBQ2pDO1lBRUQsSUFBSSxDQUFDLFVBQVUsR0FBRyxJQUFJLENBQUMsT0FBTyxDQUFDLE1BQU0sQ0FBQyxZQUFZLENBQUMsQ0FBQztZQUNwRCxJQUFJLENBQUMsb0JBQW9CLENBQUMsbUJBQUEsWUFBWSxDQUFDLGdCQUFnQixFQUFxQyxDQUFDLENBQUM7WUFDOUYsSUFBSSxDQUFDLGtCQUFrQixFQUFFLENBQUM7WUFDMUIsSUFBSSxDQUFDLGtCQUFrQixFQUFFLENBQUM7WUFDMUIsSUFBSSxJQUFJLENBQUMsS0FBSyxFQUFFO2dCQUNkLElBQUksQ0FBQyx5QkFBeUIsRUFBRSxDQUFDO2FBQ2xDO1NBQ0Y7UUFDRCxPQUFPLElBQUksQ0FBQyxVQUFVLENBQUM7SUFDekIsQ0FBQzs7Ozs7O0lBRU8sd0RBQW9COzs7OztJQUE1QixVQUE2QixRQUEyQztRQUF4RSxpQkFjQztRQWJDLFFBQVEsQ0FBQyxlQUFlLENBQUMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxJQUFJLENBQUMsVUFBVSxDQUFDLENBQUMsQ0FBQyxTQUFTOzs7O1FBQUMsVUFBQSxNQUFNOztnQkFDbEUsSUFBSSxHQUFHLE1BQU0sQ0FBQyxjQUFjO1lBQ2xDLEtBQUksQ0FBQyxlQUFlLENBQUMsSUFBSSxDQUFDLENBQUM7WUFDM0IsS0FBSSxDQUFDLGFBQWEsQ0FBQyxJQUFJLENBQUMsQ0FBQztZQUV6QiwwQ0FBMEM7WUFDMUMsbURBQW1EO1lBQ25ELDZDQUE2QztZQUM3QyxpREFBaUQ7WUFDakQsSUFBSSxLQUFJLENBQUMsZ0JBQWdCLElBQUksQ0FBQyxLQUFJLENBQUMsZ0JBQWdCLENBQUMsU0FBUyxFQUFFO2dCQUM3RCxLQUFJLENBQUMsZ0JBQWdCLENBQUMsYUFBYSxFQUFFLENBQUM7YUFDdkM7UUFDSCxDQUFDLEVBQUMsQ0FBQztJQUNMLENBQUM7SUFFRCwwREFBMEQ7Ozs7OztJQUNsRCw2REFBeUI7Ozs7OztJQUFqQztRQUFBLGlCQUlDO1FBSEMsSUFBSSxDQUFDLFVBQVUsQ0FBQyxhQUFhLEVBQUUsQ0FBQyxJQUFJLENBQUMsU0FBUyxDQUFDLElBQUksQ0FBQyxVQUFVLENBQUMsQ0FBQyxDQUFDLFNBQVM7Ozs7UUFBQyxVQUFDLEtBQUs7WUFDL0UsS0FBSSxDQUFDLElBQUksR0FBRyxLQUFLLENBQUM7UUFDcEIsQ0FBQyxFQUFDLENBQUM7SUFDTCxDQUFDO0lBRUQsd0dBQXdHOzs7Ozs7SUFDaEcsc0RBQWtCOzs7Ozs7SUFBMUI7UUFBQSxpQkFVQztRQVRDLElBQUksQ0FBQyxVQUFVLENBQUMsV0FBVyxFQUFFLENBQUMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxJQUFJLENBQUMsVUFBVSxDQUFDLENBQUMsQ0FBQyxTQUFTOzs7O1FBQUMsVUFBQSxJQUFJO1lBQzNFLHlFQUF5RTtZQUN6RSx5RkFBeUY7WUFDekYsSUFBSSxLQUFJLENBQUMsSUFBSSxFQUFFO2dCQUNiLEtBQUksQ0FBQyxJQUFJLEdBQUcsS0FBSyxDQUFDO2FBQ25CO1lBQ0QsS0FBSSxDQUFDLFVBQVUsQ0FBQyxJQUFJLENBQUMsS0FBSSxDQUFDLEtBQUssQ0FBQyxDQUFDO1lBQ2pDLEtBQUksQ0FBQyxPQUFPLENBQUMsZUFBZSxFQUFFLENBQUM7UUFDakMsQ0FBQyxFQUFDLENBQUM7SUFDTCxDQUFDOzs7OztJQUVPLHNEQUFrQjs7OztJQUExQjtRQUFBLGlCQUlDO1FBSEMsSUFBSSxDQUFDLFVBQVUsQ0FBQyxXQUFXLEVBQUUsQ0FBQyxJQUFJLENBQUMsU0FBUyxDQUFDLElBQUksQ0FBQyxVQUFVLENBQUMsQ0FBQyxDQUFDLFNBQVM7Ozs7UUFBQyxVQUFBLElBQUk7WUFDM0UsS0FBSSxDQUFDLFVBQVUsQ0FBQyxJQUFJLENBQUMsS0FBSSxDQUFDLEtBQUssQ0FBQyxDQUFDO1FBQ25DLENBQUMsRUFBQyxDQUFDO0lBQ0wsQ0FBQztJQUVELHFHQUFxRzs7Ozs7O0lBQzdGLGdEQUFZOzs7Ozs7SUFBcEI7UUFBQSxpQkFTQztRQVJDLE9BQU8sSUFBSSxDQUFDLHdCQUF3QjthQUNqQyxJQUFJLENBQ0gsR0FBRzs7OztRQUFDLFVBQUEsS0FBSyxJQUFJLE9BQUEsS0FBSyxDQUFDLE1BQU0sRUFBWixDQUFZLEVBQUMsRUFDMUIsTUFBTTs7OztRQUFDLFVBQUEsTUFBTSxJQUFJLE9BQUEsQ0FBQyxLQUFJLENBQUMsVUFBVSxDQUFDLGFBQWEsQ0FBQyxRQUFRLENBQUMsTUFBTSxDQUFDLEVBQS9DLENBQStDLEVBQUMsRUFDakUsU0FBUyxDQUFDLElBQUksQ0FBQyxPQUFPLENBQUMsTUFBTSxDQUFDLENBQUM7YUFDaEMsU0FBUzs7O1FBQUM7WUFDVCxLQUFJLENBQUMsSUFBSSxHQUFHLEtBQUssQ0FBQztRQUNwQixDQUFDLEVBQUMsQ0FBQztJQUNQLENBQUM7Ozs7OztJQUVPLG1EQUFlOzs7OztJQUF2QixVQUF3QixJQUE0QjtRQUNsRCxJQUFJLElBQUksQ0FBQyxPQUFPLEtBQUssS0FBSyxJQUFJLElBQUksQ0FBQyxRQUFRLEtBQUssT0FBTyxFQUFFO1lBQ3ZELElBQUksQ0FBQyxPQUFPLENBQUMsU0FBUyxHQUFHLE9BQU8sQ0FBQztTQUNsQzthQUFNLElBQUksSUFBSSxDQUFDLE9BQU8sS0FBSyxRQUFRLElBQUksSUFBSSxDQUFDLFFBQVEsS0FBSyxLQUFLLEVBQUU7WUFDL0QsSUFBSSxDQUFDLE9BQU8sQ0FBQyxTQUFTLEdBQUcsUUFBUSxDQUFDO1NBQ25DO2FBQU0sSUFBSSxJQUFJLENBQUMsT0FBTyxLQUFLLE9BQU8sSUFBSSxJQUFJLENBQUMsUUFBUSxLQUFLLEtBQUssRUFBRTtZQUM5RCxJQUFJLENBQUMsT0FBTyxDQUFDLFNBQVMsR0FBRyxNQUFNLENBQUM7U0FDakM7YUFBTSxJQUFJLElBQUksQ0FBQyxPQUFPLEtBQUssS0FBSyxJQUFJLElBQUksQ0FBQyxRQUFRLEtBQUssUUFBUSxFQUFFO1lBQy9ELElBQUksQ0FBQyxPQUFPLENBQUMsU0FBUyxHQUFHLEtBQUssQ0FBQztTQUNoQztJQUNILENBQUM7Ozs7OztJQUVPLGlEQUFhOzs7OztJQUFyQixVQUFzQixJQUE0Qjs7WUFFMUMsc0JBQXNCLEdBQUcsSUFBSSxDQUFDLFVBQVUsQ0FBQyxhQUFhLENBQUMscUJBQXFCLEVBQUUsQ0FBQyxJQUFJOztZQUNuRixrQkFBa0IsR0FBRyxJQUFJLENBQUMsVUFBVSxDQUFDLGFBQWEsQ0FBQyxxQkFBcUIsRUFBRSxDQUFDLEtBQUssR0FBRyxDQUFDOztZQUNwRix1QkFBdUIsR0FBRyxJQUFJLENBQUMsVUFBVSxDQUFDLGNBQWMsQ0FBQyxhQUFhLENBQUMsVUFBVTs7WUFDakYsd0JBQXdCLEdBQUcsSUFBSSxDQUFDLFVBQVUsQ0FBQyxjQUFjLENBQUMsVUFBVTs7O1lBR3BFLGNBQWMsR0FBRyxDQUFDLHNCQUFzQixHQUFHLGtCQUFrQixDQUFDLEdBQUcsQ0FBQyx1QkFBdUIsR0FBRyx3QkFBd0IsQ0FBQztRQUMzSCxJQUFJLElBQUksQ0FBQyxPQUFPLEtBQUssSUFBSSxDQUFDLFFBQVEsRUFBRTs7Z0JBQzVCLFNBQVMsR0FBRyxNQUFNOztnQkFDbEIsVUFBVSxHQUFHLEVBQUU7WUFFckIsVUFBVSxDQUFDLFNBQVMsQ0FBQyxHQUFHLGNBQWMsR0FBRyxJQUFJLENBQUM7WUFDOUMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxVQUFVLEdBQUcsVUFBVSxDQUFDO1NBQ3RDO1FBQ0QsSUFBSSxDQUFDLElBQUksQ0FBQyxPQUFPLEtBQUssUUFBUSxJQUFJLElBQUksQ0FBQyxPQUFPLEtBQUssS0FBSyxDQUFDLElBQUksSUFBSSxDQUFDLFFBQVEsS0FBSyxRQUFRLEVBQUU7WUFDdkYsSUFBSSxDQUFDLE9BQU8sQ0FBQyxVQUFVLEdBQUcsRUFBRSxJQUFJLEVBQUUsY0FBYyxHQUFHLElBQUksRUFBRSxDQUFDO1NBQzNEO1FBRUQsSUFBSSxDQUFDLElBQUksQ0FBQyxPQUFPLEtBQUssS0FBSyxJQUFJLElBQUksQ0FBQyxPQUFPLEtBQUssT0FBTyxDQUFDLElBQUksSUFBSSxDQUFDLFFBQVEsS0FBSyxRQUFRLEVBQUU7WUFDdEYsSUFBSSxDQUFDLE9BQU8sQ0FBQyxVQUFVLEdBQUcsRUFBRSxHQUFHLEVBQUUsS0FBSyxFQUFFLENBQUM7U0FDMUM7SUFDSCxDQUFDOzs7OztJQUVPLCtDQUFXOzs7O0lBQW5COztZQUNNLFNBQThCOztZQUM5QixPQUFPLEdBQUcsQ0FBQzs7WUFDWCxPQUFPLEdBQUcsQ0FBQztRQUNmLElBQUksSUFBSSxDQUFDLFNBQVMsS0FBSyxLQUFLLEVBQUU7WUFDNUIsU0FBUyxHQUFHLENBQUM7b0JBQ1gsUUFBUSxFQUFFLFFBQVE7b0JBQ2xCLFFBQVEsRUFBRSxRQUFRO29CQUNsQixPQUFPLEVBQUUsUUFBUTtvQkFDakIsT0FBTyxFQUFFLEtBQUs7aUJBQ2YsQ0FBQyxDQUFDO1lBQ0gsT0FBTyxHQUFHLENBQUMsQ0FBQztZQUNaLE9BQU8sR0FBRyxDQUFDLEVBQUUsQ0FBQztTQUNmO2FBQU0sSUFBSSxJQUFJLENBQUMsU0FBUyxLQUFLLE9BQU8sRUFBRTtZQUNyQyxTQUFTLEdBQUcsQ0FBQztvQkFDWCxRQUFRLEVBQUUsT0FBTztvQkFDakIsUUFBUSxFQUFFLFFBQVE7b0JBQ2xCLE9BQU8sRUFBRSxLQUFLO29CQUNkLE9BQU8sRUFBRSxRQUFRO2lCQUNsQixDQUFDLENBQUM7WUFDSCxPQUFPLEdBQUcsRUFBRSxDQUFDO1lBQ2IsT0FBTyxHQUFHLENBQUMsQ0FBQztTQUNiO2FBQU0sSUFBSSxJQUFJLENBQUMsU0FBUyxLQUFLLFFBQVEsRUFBRTtZQUN0QyxTQUFTLEdBQUcsQ0FBQztvQkFDWCxRQUFRLEVBQUUsUUFBUTtvQkFDbEIsUUFBUSxFQUFFLEtBQUs7b0JBQ2YsT0FBTyxFQUFFLFFBQVE7b0JBQ2pCLE9BQU8sRUFBRSxRQUFRO2lCQUNsQixDQUFDLENBQUM7WUFDSCxPQUFPLEdBQUcsQ0FBQyxDQUFDO1lBQ1osT0FBTyxHQUFHLEVBQUUsQ0FBQztTQUNkO2FBQU0sSUFBSSxJQUFJLENBQUMsU0FBUyxLQUFLLE1BQU0sRUFBRTtZQUNwQyxTQUFTLEdBQUcsQ0FBQztvQkFDWCxRQUFRLEVBQUUsS0FBSztvQkFDZixRQUFRLEVBQUUsUUFBUTtvQkFDbEIsT0FBTyxFQUFFLE9BQU87b0JBQ2hCLE9BQU8sRUFBRSxRQUFRO2lCQUNsQixDQUFDLENBQUM7WUFDSCxPQUFPLEdBQUcsQ0FBQyxFQUFFLENBQUM7WUFDZCxPQUFPLEdBQUcsQ0FBQyxDQUFDO1NBQ2I7UUFDRCxPQUFPLElBQUksQ0FBQyxPQUFPLENBQUMsUUFBUSxFQUFFLENBQUMsbUJBQW1CLENBQUMsSUFBSSxDQUFDLFVBQVUsQ0FBQzthQUNoRSxhQUFhLGtCQUFLLFNBQVMsRUFBSyxTQUFTLEVBQUU7YUFDM0Msa0JBQWtCLENBQUMsT0FBTyxDQUFDO2FBQzNCLGtCQUFrQixDQUFDLE9BQU8sQ0FBQyxDQUFDO0lBQ2pDLENBQUM7SUFFRCw0RUFBNEU7Ozs7OztJQUNwRSw0REFBd0I7Ozs7O0lBQWhDOztZQUNRLE9BQU8sR0FBRyxJQUFJLENBQUMscUNBQXFDO1FBQzFELHlGQUF5RjtRQUN6RixJQUFJLE9BQU8sSUFBSSxPQUFPLE9BQU8sQ0FBQyxLQUFLLEtBQUssVUFBVSxFQUFFO1lBQ2xELE9BQU8sQ0FBQyxLQUFLLEVBQUUsQ0FBQztTQUNqQjtJQUNILENBQUM7O2dCQWpjRixTQUFTLFNBQUM7b0JBQ1QsUUFBUSxFQUFFLHVCQUF1QjtvQkFDakMsUUFBUSxFQUFFLGtCQUFrQjtvQkFDNUIsSUFBSSxFQUFFO3dCQUNKLFNBQVMsRUFBRSxlQUFlO3dCQUMxQixlQUFlLEVBQUUsTUFBTTt3QkFDdkIsc0JBQXNCLEVBQUUsUUFBUTt3QkFDaEMseUJBQXlCLEVBQUUsb0JBQW9CO3FCQUNoRDtpQkFDRjs7OztnQkFoSEMsT0FBTztnQkFTUCxVQUFVO2dCQVNWLGdCQUFnQjtnQkFHVCxZQUFZO2dCQUtaLGdCQUFnQjtnQkFGaEIsWUFBWTtnQkFMbkIsTUFBTTtnQkFTQyxRQUFRO2dEQTJMRixRQUFRLFlBQUksTUFBTSxTQUFDLFFBQVE7Ozs2QkFwRnZDLE1BQU0sU0FBQyxxQkFBcUI7dUJBSTVCLEtBQUssU0FBQyxlQUFlOzRCQWtCckIsS0FBSyxTQUFDLG9CQUFvQjtzQ0FhMUIsS0FBSzswQkFXTCxLQUFLLFNBQUMscUJBQXFCOzRCQUkzQixLQUFLLFNBQUMsb0JBQW9CO3dDQUkxQixLQUFLLFNBQUMseUJBQXlCO2dDQUkvQixLQUFLLFNBQUMsd0JBQXdCO3dCQUk5QixLQUFLLFNBQUMsZ0JBQWdCOzBCQU90QixLQUFLLFNBQUMsa0JBQWtCO2lDQUl4QixLQUFLLFNBQUMseUJBQXlCOztJQTZWbEMsZ0NBQUM7Q0FBQSxBQWxjRCxJQWtjQztTQXhiWSx5QkFBeUI7Ozs7OztJQUNwQywrQ0FBK0I7Ozs7O0lBQy9CLDJDQUFvQzs7Ozs7SUFDcEMsK0NBQXlDOzs7OztJQUN6QywwQ0FBK0I7Ozs7O0lBQy9CLCtDQUFtQzs7Ozs7SUFDbkMsc0RBQTRDOzs7OztJQUM1QyxxREFBK0M7Ozs7O0lBQy9DLDZEQUF5RDs7Ozs7O0lBRXpELCtDQUE4Qjs7Ozs7O0lBRTlCLDBFQUF5RTs7Ozs7SUFDekUscURBQWlGOzs7OztJQUVqRix1Q0FBOEI7Ozs7O0lBRzlCLCtDQUN1RDs7Ozs7SUEwQ3ZELHlEQUE2Qzs7Ozs7SUFHN0MsNENBQzRCOzs7OztJQUc1Qiw4Q0FDc0M7Ozs7O0lBR3RDLDBEQUN1Qzs7Ozs7SUFHdkMsa0RBQzBEOzs7OztJQUcxRCwwQ0FDdUI7Ozs7O0lBTXZCLDRDQUNzQzs7Ozs7SUFHdEMsbURBQ3VEOzs7OztJQUUzQyw0Q0FBd0I7Ozs7O0lBQ3hCLCtDQUE4Qjs7Ozs7SUFDOUIscURBQTBDOzs7OztJQUMxQyxpREFBa0M7Ozs7O0lBQ2xDLHNEQUEyQzs7Ozs7SUFDM0Msa0RBQW1DOzs7OztJQUNuQyw0Q0FBdUI7Ozs7O0lBQ3ZCLDhDQUEyQjs7Ozs7SUFDM0IsOENBQW9EIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgY29lcmNlQm9vbGVhblByb3BlcnR5IH0gZnJvbSAnQGFuZ3VsYXIvY2RrL2NvZXJjaW9uJztcbmltcG9ydCB7XG4gIENvbm5lY3RlZFBvc2l0aW9uLFxuICBDb25uZWN0aW9uUG9zaXRpb25QYWlyLFxuICBGbGV4aWJsZUNvbm5lY3RlZFBvc2l0aW9uU3RyYXRlZ3ksXG4gIE92ZXJsYXksXG4gIE92ZXJsYXlDb25maWcsXG4gIE92ZXJsYXlSZWYsXG4gIFBvc2l0aW9uU3RyYXRlZ3lcbn0gZnJvbSAnQGFuZ3VsYXIvY2RrL292ZXJsYXknO1xuaW1wb3J0IHsgVGVtcGxhdGVQb3J0YWwgfSBmcm9tICdAYW5ndWxhci9jZGsvcG9ydGFsJztcbmltcG9ydCB7XG4gIEFmdGVyVmlld0luaXQsXG4gIERpcmVjdGl2ZSxcbiAgRWxlbWVudFJlZixcbiAgRW1iZWRkZWRWaWV3UmVmLFxuICBFdmVudEVtaXR0ZXIsXG4gIEluamVjdCxcbiAgSW5wdXQsXG4gIE9uRGVzdHJveSxcbiAgT25Jbml0LFxuICBPcHRpb25hbCxcbiAgT3V0cHV0LFxuICBWaWV3Q29udGFpbmVyUmVmLFxuICBOZ1pvbmVcbn0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBFdmVudE1hbmFnZXIgfSBmcm9tICdAYW5ndWxhci9wbGF0Zm9ybS1icm93c2VyJztcbmltcG9ydCB7IGZyb21FdmVudCwgT2JzZXJ2YWJsZSwgU3ViamVjdCB9IGZyb20gJ3J4anMnO1xuaW1wb3J0IHsgZmlsdGVyLCBtYXAsIHRha2VVbnRpbCB9IGZyb20gJ3J4anMvb3BlcmF0b3JzJztcbmltcG9ydCB7IEZvY3VzTW9uaXRvciB9IGZyb20gJ0Bhbmd1bGFyL2Nkay9hMTF5JztcbmltcG9ydCB7IE54UG9wb3ZlckNvbXBvbmVudCB9IGZyb20gJy4vcG9wb3Zlci5jb21wb25lbnQnO1xuaW1wb3J0IHsgRm9jdXNUcmFwRmFjdG9yeSwgRm9jdXNUcmFwIH0gZnJvbSAnQGFuZ3VsYXIvY2RrL2ExMXknO1xuaW1wb3J0IHsgRE9DVU1FTlQgfSBmcm9tICdAYW5ndWxhci9jb21tb24nO1xuaW1wb3J0IHsgUGxhdGZvcm0gfSBmcm9tICdAYW5ndWxhci9jZGsvcGxhdGZvcm0nO1xuaW1wb3J0IHsgU1BBQ0UsIEVOVEVSIH0gZnJvbSAnQGFuZ3VsYXIvY2RrL2tleWNvZGVzJztcblxuZXhwb3J0IGRlY2xhcmUgdHlwZSBQb3BvdmVyRGlyZWN0aW9uID0gJ2xlZnQnIHwgJ3RvcCcgfCAncmlnaHQnIHwgJ2JvdHRvbSc7XG5leHBvcnQgZGVjbGFyZSB0eXBlIFBvcG92ZXJUcmlnZ2VyVHlwZSA9ICdjbGljaycgfCAnaG92ZXInIHwgJ21hbnVhbCc7XG5leHBvcnQgZGVjbGFyZSB0eXBlIFBvcG92ZXJUcmlnZ2VyU2Nyb2xsU3RyYXRlZ3kgPSAnY2xvc2UnIHwgJ3JlcG9zaXRpb24nO1xubGV0IG5leHRJZCA9IDA7XG5cbmNvbnN0IGZhbGxiYWNrczogQ29ubmVjdGlvblBvc2l0aW9uUGFpcltdID0gW1xuICB7XG4gICAgb3JpZ2luWDogJ3N0YXJ0JyxcbiAgICBvcmlnaW5ZOiAnYm90dG9tJyxcbiAgICBvdmVybGF5WDogJ3N0YXJ0JyxcbiAgICBvdmVybGF5WTogJ3RvcCcsXG4gICAgb2Zmc2V0WDogMCxcbiAgICBvZmZzZXRZOiAxNlxuICB9LFxuICB7XG4gICAgb3JpZ2luWDogJ2VuZCcsXG4gICAgb3JpZ2luWTogJ3RvcCcsXG4gICAgb3ZlcmxheVg6ICdlbmQnLFxuICAgIG92ZXJsYXlZOiAnYm90dG9tJyxcbiAgICBvZmZzZXRYOiAwLFxuICAgIG9mZnNldFk6IC0xNlxuICB9LFxuICB7XG4gICAgb3JpZ2luWDogJ2NlbnRlcicsXG4gICAgb3JpZ2luWTogJ2JvdHRvbScsXG4gICAgb3ZlcmxheVg6ICdjZW50ZXInLFxuICAgIG92ZXJsYXlZOiAndG9wJyxcbiAgICBvZmZzZXRYOiAwLFxuICAgIG9mZnNldFk6IDE2XG4gIH0sXG4gIHtcbiAgICBvcmlnaW5YOiAnZW5kJyxcbiAgICBvcmlnaW5ZOiAnYm90dG9tJyxcbiAgICBvdmVybGF5WDogJ2VuZCcsXG4gICAgb3ZlcmxheVk6ICd0b3AnLFxuICAgIG9mZnNldFg6IDAsXG4gICAgb2Zmc2V0WTogMTZcbiAgfSxcbiAge1xuICAgIG9yaWdpblg6ICdlbmQnLFxuICAgIG9yaWdpblk6ICdjZW50ZXInLFxuICAgIG92ZXJsYXlYOiAnc3RhcnQnLFxuICAgIG92ZXJsYXlZOiAnY2VudGVyJyxcbiAgICBvZmZzZXRYOiAxNixcbiAgICBvZmZzZXRZOiAwXG4gIH0sXG4gIHtcbiAgICBvcmlnaW5YOiAnc3RhcnQnLFxuICAgIG9yaWdpblk6ICdjZW50ZXInLFxuICAgIG92ZXJsYXlYOiAnZW5kJyxcbiAgICBvdmVybGF5WTogJ2NlbnRlcicsXG4gICAgb2Zmc2V0WDogLTE2LFxuICAgIG9mZnNldFk6IDBcbiAgfSxcbiAge1xuICAgIG9yaWdpblg6ICdjZW50ZXInLFxuICAgIG9yaWdpblk6ICd0b3AnLFxuICAgIG92ZXJsYXlYOiAnY2VudGVyJyxcbiAgICBvdmVybGF5WTogJ2JvdHRvbScsXG4gICAgb2Zmc2V0WDogMCxcbiAgICBvZmZzZXRZOiAtMTZcbiAgfSxcbiAge1xuICAgIG9yaWdpblg6ICdzdGFydCcsXG4gICAgb3JpZ2luWTogJ3RvcCcsXG4gICAgb3ZlcmxheVg6ICdzdGFydCcsXG4gICAgb3ZlcmxheVk6ICdib3R0b20nLFxuICAgIG9mZnNldFg6IDAsXG4gICAgb2Zmc2V0WTogLTE2XG4gIH1cbl07XG5cbkBEaXJlY3RpdmUoe1xuICBzZWxlY3RvcjogJ1tueFBvcG92ZXJUcmlnZ2VyRm9yXScsXG4gIGV4cG9ydEFzOiAnbnhQb3BvdmVyVHJpZ2dlcicsXG4gIGhvc3Q6IHtcbiAgICAnKGNsaWNrKSc6ICdoYW5kbGVDbGljaygpJyxcbiAgICAnYXJpYS1oYXNwb3B1cCc6ICd0cnVlJyxcbiAgICAnW2F0dHIuYXJpYS1leHBhbmRlZF0nOiAnaXNPcGVuJyxcbiAgICAnW2F0dHIuYXJpYS1kZXNjcmliZWRieV0nOiAnaXNPcGVuID8gaWQgOiBudWxsJ1xuICB9XG59KVxuZXhwb3J0IGNsYXNzIE54UG9wb3ZlclRyaWdnZXJEaXJlY3RpdmUgaW1wbGVtZW50cyBBZnRlclZpZXdJbml0LCBPbkRlc3Ryb3ksIE9uSW5pdCB7XG4gIHByaXZhdGUgb3ZlcmxheVJlZjogT3ZlcmxheVJlZjtcbiAgcHJpdmF0ZSBwb3J0YWw6IFRlbXBsYXRlUG9ydGFsPGFueT47XG4gIHByaXZhdGUgX2Rlc3Ryb3llZCA9IG5ldyBTdWJqZWN0PHZvaWQ+KCk7XG4gIHByaXZhdGUgX3Nob3c6IGJvb2xlYW4gPSBmYWxzZTtcbiAgcHJpdmF0ZSBfY2xvc2VhYmxlOiBib29sZWFuID0gbnVsbDtcbiAgcHJpdmF0ZSBfcG9zaXRpb25TdHJhdGVneTogUG9zaXRpb25TdHJhdGVneTtcbiAgcHJpdmF0ZSBfZW1iZWRkZWRWaWV3UmVmOiBFbWJlZGRlZFZpZXdSZWY8YW55PjtcbiAgcHJpdmF0ZSBfZG9jdW1lbnRDbGlja09ic2VydmFibGU6IE9ic2VydmFibGU8TW91c2VFdmVudD47XG4gIC8qKiBUaGUgY2xhc3MgdGhhdCB0cmFwcyBhbmQgbWFuYWdlcyBmb2N1cyB3aXRoaW4gdGhlIHBvcG92ZXIuICovXG4gIHByaXZhdGUgX2ZvY3VzVHJhcDogRm9jdXNUcmFwO1xuICAvKiogRWxlbWVudCB0aGF0IHdhcyBmb2N1c2VkIGJlZm9yZSB0aGUgUG9wb3ZlciB3YXMgb3BlbmVkLiBTYXZlIHRoaXMgdG8gcmVzdG9yZSB1cG9uIGNsb3NlLiAqL1xuICBwcml2YXRlIF9lbGVtZW50Rm9jdXNlZEJlZm9yZVBvcG92ZXJXYXNPcGVuZWQ6IEhUTUxFbGVtZW50IHwgbnVsbCA9IG51bGw7XG4gIHByaXZhdGUgX21hbnVhbExpc3RlbmVycyA9IG5ldyBNYXA8c3RyaW5nLCBFdmVudExpc3RlbmVyT3JFdmVudExpc3RlbmVyT2JqZWN0PigpO1xuICAvKiogQGRvY3MtcHJpdmF0ZSAqL1xuICBpZCA9ICdueC1wb3BvdmVyLScgKyBuZXh0SWQrKztcblxuICAvKiogQW4gZXZlbnQgaXMgZW1pdHRlZCBpZiB0aGUgdmlzaWJpbGl0eSBzdGF0dXMgb2YgdGhlIHBvcG92ZXIgY2hhbmdlcy4gKi9cbiAgQE91dHB1dCgnbnhQb3BvdmVyU2hvd0NoYW5nZScpXG4gIGNoYW5nZVNob3c6IEV2ZW50RW1pdHRlcjxib29sZWFuPiA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcblxuICAvKiogV2hldGhlciB0byBzaG93IG9yIGhpZGUgdGhlIHBvcG92ZXIuICovXG4gIEBJbnB1dCgnbnhQb3BvdmVyU2hvdycpXG4gIHNldCBzaG93KHZhbHVlOiBib29sZWFuKSB7XG4gICAgdmFsdWUgPSBjb2VyY2VCb29sZWFuUHJvcGVydHkodmFsdWUpO1xuICAgIGlmICh0aGlzLl9zaG93ICE9PSB2YWx1ZSkge1xuICAgICAgdGhpcy5fc2hvdyA9IHZhbHVlO1xuICAgICAgaWYgKHRoaXMuX3Nob3cpIHtcbiAgICAgICAgdGhpcy5vcGVuUG9wb3ZlcigpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5jbG9zZVBvcG92ZXIoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBnZXQgc2hvdygpIHtcbiAgICByZXR1cm4gdGhpcy5fc2hvdztcbiAgfVxuXG4gIC8qKiBXaGV0aGVyIHRvIHNob3cgYSBjbG9zZSBidXR0b24uIEJ5IGRlZmF1bHQgYSBjbG9zZSBpY29uIGlzIG9ubHkgc2hvd24gZm9yIHRyaWdnZXIgdHlwZSBjbGljay4gKi9cbiAgQElucHV0KCdueFBvcG92ZXJDbG9zZWFibGUnKVxuICBzZXQgY2xvc2VhYmxlKHZhbHVlOiBib29sZWFuKSB7XG4gICAgdGhpcy5fY2xvc2VhYmxlID0gY29lcmNlQm9vbGVhblByb3BlcnR5KHZhbHVlKTtcblxuICAgIGlmICh0aGlzLnBvcG92ZXIpIHtcbiAgICAgIHRoaXMucG9wb3Zlci5zaG93Q2xvc2VCdXR0b24gPSB0aGlzLmlzQ2xvc2VhYmxlKCk7XG4gICAgfVxuICB9XG4gIGdldCBjbG9zZWFibGUoKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRoaXMuX2Nsb3NlYWJsZTtcbiAgfVxuXG4gIC8qKiBXaGV0aGVyIHRoZSBwb3BvdmVyIHNob3VsZCBiZSBjbG9zZWQgb24gY2xpY2sgb3V0c2lkZSBvZiB0aGUgcG9wb3ZlciBpbiB0aGUgdHJpZ2dlciBtb2RlcyAnbWFudWFsJyBhbmQgJ2NsaWNrJy4gKi9cbiAgQElucHV0KClcbiAgc2V0IGNsb3NlT25DbGlja091dHNpZGUodmFsdWU6IGJvb2xlYW4pIHtcbiAgICB0aGlzLl9jbG9zZU9uQ2xpY2tPdXRzaWRlID0gY29lcmNlQm9vbGVhblByb3BlcnR5KHZhbHVlKTtcbiAgfVxuICBnZXQgY2xvc2VPbkNsaWNrT3V0c2lkZSgpOiBib29sZWFuIHtcbiAgICByZXR1cm4gdGhpcy5fY2xvc2VPbkNsaWNrT3V0c2lkZTtcbiAgfVxuXG4gIHByaXZhdGUgX2Nsb3NlT25DbGlja091dHNpZGU6IGJvb2xlYW4gPSB0cnVlO1xuXG4gIC8qKiBMaW5rcyB0aGUgdHJpZ2dlciB3aXRoIHRoZSBwb3BvdmVyIHRvIG9wZW4uICovXG4gIEBJbnB1dCgnbnhQb3BvdmVyVHJpZ2dlckZvcicpXG4gIHBvcG92ZXI6IE54UG9wb3ZlckNvbXBvbmVudDtcblxuICAvKiogU2V0cyB0aGUgZGVzaXJlZCBkaXJlY3Rpb24gdG8gb3BlbiB0aGUgcG9wb3Zlci4gRS5nLiwgcmlnaHQsIGxlZnQsIGJvdHRvbSwgdG9wICovXG4gIEBJbnB1dCgnbnhQb3BvdmVyRGlyZWN0aW9uJylcbiAgZGlyZWN0aW9uOiBQb3BvdmVyRGlyZWN0aW9uID0gJ3JpZ2h0JztcblxuICAvKiogV2hldGhlciB0aGUgcG9wb3ZlciB3aWxsIGJlIG9wZW5lZCBhdXRvbWF0aWNhbGx5LiAqL1xuICBASW5wdXQoJ254UG9wb3ZlckluaXRpYWxWaXNpYmxlJylcbiAgcG9wb3ZlckluaXRpYWxWaXNpYmxlOiBib29sZWFuID0gZmFsc2U7XG5cbiAgLyoqIEFuIGV2ZW50IGlzIGVtaXR0ZWQgd2hlbiB0aGUgdmlzaWJpbGl0eSBvZiB0aGUgcG9wb3B2ZXIgY2hhbmdlcy4gKi9cbiAgQElucHV0KCdueFBvcG92ZXJWaXNpYmxlQ2hhbmdlJylcbiAgdmlzaWJsZUNoYW5nZTogRXZlbnRFbWl0dGVyPGJvb2xlYW4+ID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuXG4gIC8qKiBXaGV0aGVyIHRoZSBwb3BvdmVyIG9wZW5zIGluIG1vZGFsIHN0YXRlLiAqL1xuICBASW5wdXQoJ254UG9wb3Zlck1vZGFsJylcbiAgbW9kYWw6IGJvb2xlYW4gPSBmYWxzZTtcblxuICAvLyBJZiBueFBvcG92ZXJUcmlnZ2VyIGVxdWFscyB0byAnaG92ZXInIHRoZSBwb3BvdmVyIG9wZW5zIG9uIG1vdXNlZW50ZXIgYW5kIGNsb3NlcyBvbiBtb3VzZW91dC5cbiAgLy8gSWYgbnhQb3BvdmVyVHJpZ2dlciBlcXVhbHMgdG8gJ2NsaWNrJyB0aGUgcG9wb3ZlciBvcGVucyBvbiBjbGljayBhbmQgY2xvc2VzIG9uIGEgY2xpY2sgb2YgdGhlIGNsb3NlIGljb24gb3IgcHJlc3NpbmcgRVNDIGtleS5cbiAgLy8gSWYgbnhQb3BvdmVyVHJpZ2dlciBlcXVhbHMgdG8gJ21hbnVhbCcgdGhlIHBvcG92ZXIgb3BlbnMgb25seSB3aGVuIHByb2dyYW1hdGljYWxseSByZXF1ZXN0ZWQuXG4gIC8qKiBTZXRzIHRoZSB3YXkgdG8gdHJpZ2dlciB0aGUgcG9wb3Zlci4gT3B0aW9ucyBhcmUgaG92ZXIsIGNsaWNrLCBtYW51YWwgKi9cbiAgQElucHV0KCdueFBvcG92ZXJUcmlnZ2VyJylcbiAgdHJpZ2dlcjogUG9wb3ZlclRyaWdnZXJUeXBlID0gJ2NsaWNrJztcblxuICAvKiogU2V0cyB0aGUgc2Nyb2xsIHN0cmF0ZWd5LiAnY2xvc2UnIGNsb3NlcyB0aGUgcG9wb3ZlciBvbiBzY3JvbGwgd2hpbGUgJ3JlcG9zaXRpb24nIHNjcm9sbHMgdGhlIHBvcG92ZXIgd2l0aCB0aGUgb3JpZ2luLiAqL1xuICBASW5wdXQoJ254UG9wb3ZlclNjcm9sbFN0cmF0ZWd5JylcbiAgc2Nyb2xsU3RyYXRlZ3k6IFBvcG92ZXJUcmlnZ2VyU2Nyb2xsU3RyYXRlZ3kgPSAnY2xvc2UnO1xuXG4gIGNvbnN0cnVjdG9yKHByaXZhdGUgb3ZlcmxheTogT3ZlcmxheSxcbiAgICAgICAgICAgICAgcHJpdmF0ZSBlbGVtZW50UmVmOiBFbGVtZW50UmVmLFxuICAgICAgICAgICAgICBwcml2YXRlIHZpZXdDb250YWluZXJSZWY6IFZpZXdDb250YWluZXJSZWYsXG4gICAgICAgICAgICAgIHByaXZhdGUgZXZlbnRNYW5hZ2VyOiBFdmVudE1hbmFnZXIsXG4gICAgICAgICAgICAgIHByaXZhdGUgX2ZvY3VzVHJhcEZhY3Rvcnk6IEZvY3VzVHJhcEZhY3RvcnksXG4gICAgICAgICAgICAgIHByaXZhdGUgX2ZvY3VzTW9uaXRvcjogRm9jdXNNb25pdG9yLFxuICAgICAgICAgICAgICBwcml2YXRlIF9uZ1pvbmU6IE5nWm9uZSxcbiAgICAgICAgICAgICAgcHJpdmF0ZSBfcGxhdGZvcm06IFBsYXRmb3JtLFxuICAgICAgICAgICAgICBAT3B0aW9uYWwoKSBASW5qZWN0KERPQ1VNRU5UKSBwcml2YXRlIF9kb2N1bWVudDogYW55KSB7XG4gICAgdGhpcy5fZG9jdW1lbnRDbGlja09ic2VydmFibGUgPSBmcm9tRXZlbnQ8TW91c2VFdmVudD4oZG9jdW1lbnQsICdjbGljaycpO1xuICAgIGNvbnN0IGVsZW1lbnQ6IEhUTUxFbGVtZW50ID0gZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50O1xuICAgIGlmICghdGhpcy5fcGxhdGZvcm0uSU9TICYmICF0aGlzLl9wbGF0Zm9ybS5BTkRST0lEKSB7XG4gICAgICB0aGlzLl9tYW51YWxMaXN0ZW5lcnNcbiAgICAgICAgLnNldCgnbW91c2VlbnRlcicsICgpID0+IHtcbiAgICAgICAgICBpZiAodGhpcy50cmlnZ2VyID09PSAnaG92ZXInKSB7XG4gICAgICAgICAgICB0aGlzLnNob3cgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICAgICAgLnNldCgnbW91c2VsZWF2ZScsICgpID0+IHtcbiAgICAgICAgICBpZiAodGhpcy50cmlnZ2VyID09PSAnaG92ZXInKSB7XG4gICAgICAgICAgICB0aGlzLnNob3cgPSBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgICAgIC5zZXQoJ2tleWRvd24nLCAoZXZlbnQ6IEtleWJvYXJkRXZlbnQpID0+IHtcbiAgICAgICAgICBzd2l0Y2ggKGV2ZW50LmtleUNvZGUpIHtcbiAgICAgICAgICAgIGNhc2UgU1BBQ0U6XG4gICAgICAgICAgICBjYXNlIEVOVEVSOlxuICAgICAgICAgICAgICB0aGlzLmhhbmRsZUNsaWNrKCk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX21hbnVhbExpc3RlbmVycy5zZXQoJ3RvdWNoc3RhcnQnLCAoKSA9PiB7XG4gICAgICAgIGlmICh0aGlzLnRyaWdnZXIgPT09ICdob3ZlcicpIHtcbiAgICAgICAgICB0aGlzLnNob3cgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICB0aGlzLl9tYW51YWxMaXN0ZW5lcnMuZm9yRWFjaCgobGlzdGVuZXIsIGV2ZW50KSA9PiBlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoZXZlbnQsIGxpc3RlbmVyKSk7XG5cbiAgICB0aGlzLl9mb2N1c01vbml0b3IubW9uaXRvcihlbGVtZW50KS5waXBlKHRha2VVbnRpbCh0aGlzLl9kZXN0cm95ZWQpKS5zdWJzY3JpYmUob3JpZ2luID0+IHtcbiAgICAgIGlmIChvcmlnaW4gPT09ICdrZXlib2FyZCcgJiYgdGhpcy50cmlnZ2VyID09PSAnaG92ZXInKSB7XG4gICAgICAgIHRoaXMuX25nWm9uZS5ydW4oKCkgPT4gdGhpcy5zaG93ID0gdHJ1ZSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBuZ09uSW5pdCgpIHtcbiAgICB0aGlzLnBvcG92ZXIuc2hvd0Nsb3NlQnV0dG9uID0gdGhpcy5pc0Nsb3NlYWJsZSgpO1xuICB9XG5cbiAgbmdBZnRlclZpZXdJbml0KCk6IHZvaWQge1xuICAgIHRoaXMucG9wb3Zlci5pZCA9IHRoaXMuaWQ7XG5cbiAgICB0aGlzLmV2ZW50TWFuYWdlci5hZGRHbG9iYWxFdmVudExpc3RlbmVyKCd3aW5kb3cnLCAna2V5dXAuZXNjJywgKCkgPT4ge1xuICAgICAgaWYgKHRoaXMuaXNPcGVuKSB7XG4gICAgICAgIHRoaXMuc2hvdyA9IGZhbHNlO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgdGhpcy5wb3BvdmVyLmNsb3NlQnV0dG9uQ2xpY2sucGlwZSh0YWtlVW50aWwodGhpcy5fZGVzdHJveWVkKSkuc3Vic2NyaWJlKCgpID0+IHtcbiAgICAgIHRoaXMuc2hvdyA9IGZhbHNlO1xuICAgIH0pO1xuXG4gICAgaWYgKHRoaXMucG9wb3ZlckluaXRpYWxWaXNpYmxlIHx8IHRoaXMuX3Nob3cpIHtcbiAgICAgIHRoaXMuc2hvdyA9IHRydWU7XG4gICAgfVxuICB9XG5cbiAgbmdPbkRlc3Ryb3koKTogdm9pZCB7XG4gICAgdGhpcy5zaG93ID0gZmFsc2U7XG4gICAgLy8gQ2xlYW4gdXAgdGhlIGV2ZW50IGxpc3RlbmVycyBzZXQgaW4gdGhlIGNvbnN0cnVjdG9yXG4gICAgdGhpcy5fbWFudWFsTGlzdGVuZXJzLmZvckVhY2goKGxpc3RlbmVyLCBldmVudCkgPT4ge1xuICAgICAgdGhpcy5lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudCwgbGlzdGVuZXIpO1xuICAgIH0pO1xuICAgIHRoaXMuX21hbnVhbExpc3RlbmVycy5jbGVhcigpO1xuICAgIHRoaXMuX2Rlc3Ryb3llZC5uZXh0KCk7XG4gICAgdGhpcy5fZGVzdHJveWVkLmNvbXBsZXRlKCk7XG4gIH1cblxuICAvKiogQGRvY3MtcHJpdmF0ZSAqL1xuICBnZXQgaXNPcGVuKCkge1xuICAgIHJldHVybiB0aGlzLm92ZXJsYXlSZWYgJiYgdGhpcy5jcmVhdGVPdmVybGF5KCkuaGFzQXR0YWNoZWQoKTtcbiAgfVxuXG4gIC8qKiBAZG9jcy1wcml2YXRlICovXG4gIGlzQ2xvc2VhYmxlKCkge1xuICAgIHJldHVybiAodGhpcy50cmlnZ2VyID09PSAnY2xpY2snICYmIHRoaXMuX2Nsb3NlYWJsZSA9PT0gbnVsbCkgfHwgdGhpcy5fY2xvc2VhYmxlO1xuICB9XG5cbiAgLyoqIFVwZGF0ZSB0aGUgcG9wb3ZlciB3aXRoIHRoZSBnaXZlbiBwb3NpdGlvbiBzdHJhdGVneS4gKi9cbiAgdXBkYXRlUG9zaXRpb24oKSB7XG4gICAgaWYgKHRoaXMuX3Bvc2l0aW9uU3RyYXRlZ3kpIHtcbiAgICAgIHRoaXMuX3Bvc2l0aW9uU3RyYXRlZ3kuYXBwbHkoKTtcbiAgICB9XG4gIH1cblxuICAvKiogQGRvY3MtcHJpdmF0ZSAqL1xuICBoYW5kbGVDbGljaygpIHtcbiAgICBpZiAodGhpcy50cmlnZ2VyID09PSAnY2xpY2snKSB7XG4gICAgICB0aGlzLnNob3cgPSAhdGhpcy5pc09wZW47XG4gICAgfSBlbHNlIGlmICh0aGlzLnRyaWdnZXIgPT09ICdob3ZlcicpIHtcbiAgICAgIHRoaXMuc2hvdyA9IHRydWU7XG4gICAgfVxuICB9XG5cbiAgLyoqIE9wZW4gdGhlIHBvcG92ZXIgaW5zdGFuY2UuICovXG4gIG9wZW4oKTogdm9pZCB7XG4gICAgdGhpcy5zaG93ID0gdHJ1ZTtcbiAgfVxuXG4gIC8qKiBDbG9zZSB0aGUgcG9wb3ZlciBpbnN0YW5jZS4gKi9cbiAgY2xvc2UoKTogdm9pZCB7XG4gICAgdGhpcy5zaG93ID0gZmFsc2U7XG4gIH1cblxuICAvKiogVG9nZ2xlIHRoZSBwb3BvdmVyIGluc3RhbmNlLiAqL1xuICB0b2dnbGUoKTogdm9pZCB7XG4gICAgdGhpcy5zaG93ID0gIXRoaXMuc2hvdztcbiAgfVxuXG4gIHByaXZhdGUgb3BlblBvcG92ZXIoKTogdm9pZCB7XG4gICAgaWYgKCF0aGlzLmNyZWF0ZU92ZXJsYXkoKS5oYXNBdHRhY2hlZCgpKSB7XG4gICAgICB0aGlzLl9lbWJlZGRlZFZpZXdSZWYgPSB0aGlzLmNyZWF0ZU92ZXJsYXkoKS5hdHRhY2godGhpcy5wb3J0YWwpO1xuXG4gICAgICBjb25zdCBlbGVtZW50ID0gdGhpcy5fZW1iZWRkZWRWaWV3UmVmLnJvb3ROb2Rlc1swXSBhcyBIVE1MRWxlbWVudDtcbiAgICAgIHRoaXMuX2ZvY3VzVHJhcCA9IHRoaXMuX2ZvY3VzVHJhcEZhY3RvcnkuY3JlYXRlKGVsZW1lbnQpO1xuICAgICAgdGhpcy5fZWxlbWVudEZvY3VzZWRCZWZvcmVQb3BvdmVyV2FzT3BlbmVkID0gdGhpcy5lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQ7XG4gICAgICB0aGlzLl9hdXRvRm9jdXNGaXJzdFRhYmJhYmxlRWxlbWVudChlbGVtZW50KTtcblxuICAgICAgLy8gYXR0YWNoIGEgY2xvc2UgY2xpY2sgbGlzdGVuZXIgb25seSBpZiBpdCBtYWtlcyBzZW5zZSAoaWdub3JlIGl0IG9uIGhvdmVyIGUuZy4pXG4gICAgICBpZiAodGhpcy5zaG91bGRSZWFjdE9uQ2xpY2tPdXRzaWRlKCkpIHtcbiAgICAgICAgdGhpcy53YWl0Rm9yQ2xvc2UoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQXV0b2ZvY3VzIHRoZSBmaXJzdCB0YWJiYWJsZSBlbGVtZW50IGluc2lkZSBvZiB0aGUgcG9wb3ZlciwgaWYgdGhlcmUgaXMgbm90IGEgdGFiYmFibGUgZWxlbWVudCxcbiAgICogZm9jdXMgdGhlIHBvcG92ZXIgaW5zdGVhZC5cbiAgICovXG4gIHByaXZhdGUgX2F1dG9Gb2N1c0ZpcnN0VGFiYmFibGVFbGVtZW50KGVsZW1lbnQ6IEhUTUxFbGVtZW50KSB7XG4gICAgdGhpcy5fZm9jdXNUcmFwLmZvY3VzSW5pdGlhbEVsZW1lbnRXaGVuUmVhZHkoKS50aGVuKGhhc01vdmVkRm9jdXMgPT4ge1xuICAgICAgLy8gSWYgd2UgZGlkbid0IGZpbmQgYW55IGZvY3VzYWJsZSBlbGVtZW50cyBpbnNpZGUgdGhlIHBvcG92ZXIsIGZvY3VzIHRoZVxuICAgICAgLy8gY29udGFpbmVyIHNvIHRoZSB1c2VyIGNhbid0IHRhYiBpbnRvIG90aGVyIGVsZW1lbnRzIGJlaGluZCBpdC5cbiAgICAgIGlmICghaGFzTW92ZWRGb2N1cykge1xuICAgICAgICBlbGVtZW50LmZvY3VzKCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBwcml2YXRlIHNob3VsZFJlYWN0T25DbGlja091dHNpZGUoKSB7XG4gICAgcmV0dXJuICghdGhpcy5tb2RhbCAmJiB0aGlzLmNsb3NlT25DbGlja091dHNpZGUpO1xuICB9XG5cbiAgLy8gZGV0YWNoZXMgdGhlIG92ZXJsYXlcbiAgLy8gd2UgYXJlIGxpc3RlbmluZyB0byB0aGUgZGV0YWNobWVudHMgb2JzZXJ2YWJsZSB3aGljaCB3aWxsIHRoZW4gZW1pdCB0aGUgbnhDbG9zZWQgZXZlbnRcbiAgLy8gb24gdGhlIHBvcG92ZXIgY29tcG9uZW50XG4gIHByaXZhdGUgY2xvc2VQb3BvdmVyKCk6IHZvaWQge1xuICAgIGlmICh0aGlzLm92ZXJsYXlSZWYpIHtcbiAgICAgIHRoaXMuX3JldHVybkZvY3VzQWZ0ZXJQb3BvdmVyKCk7XG4gICAgICB0aGlzLm92ZXJsYXlSZWYuZGV0YWNoKCk7XG4gICAgICB0aGlzLl9lbWJlZGRlZFZpZXdSZWYgPSBudWxsO1xuICAgICAgdGhpcy5fZm9jdXNUcmFwLmRlc3Ryb3koKTtcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIGNyZWF0ZU92ZXJsYXkoKTogT3ZlcmxheVJlZiB7XG4gICAgaWYgKCF0aGlzLm92ZXJsYXlSZWYpIHtcbiAgICAgIHRoaXMucG9ydGFsID0gbmV3IFRlbXBsYXRlUG9ydGFsKHRoaXMucG9wb3Zlci50ZW1wbGF0ZVJlZiwgdGhpcy52aWV3Q29udGFpbmVyUmVmKTtcbiAgICAgIGNvbnN0IG92ZXJsYXlTdGF0ZSA9IG5ldyBPdmVybGF5Q29uZmlnKCk7XG4gICAgICBvdmVybGF5U3RhdGUucG9zaXRpb25TdHJhdGVneSA9IHRoaXMuZ2V0UG9zaXRpb24oKTtcbiAgICAgIHRoaXMuX3Bvc2l0aW9uU3RyYXRlZ3kgPSBvdmVybGF5U3RhdGUucG9zaXRpb25TdHJhdGVneTtcblxuICAgICAgaWYgKHRoaXMuc2Nyb2xsU3RyYXRlZ3kgPT09ICdyZXBvc2l0aW9uJykge1xuICAgICAgICBvdmVybGF5U3RhdGUuc2Nyb2xsU3RyYXRlZ3kgPSB0aGlzLm92ZXJsYXkuc2Nyb2xsU3RyYXRlZ2llcy5yZXBvc2l0aW9uKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvdmVybGF5U3RhdGUuc2Nyb2xsU3RyYXRlZ3kgPSB0aGlzLm92ZXJsYXkuc2Nyb2xsU3RyYXRlZ2llcy5jbG9zZSgpO1xuICAgICAgfVxuXG4gICAgICBvdmVybGF5U3RhdGUuc2Nyb2xsU3RyYXRlZ3kuZW5hYmxlKCk7XG5cbiAgICAgIGlmICh0aGlzLm1vZGFsICYmIHRoaXMudHJpZ2dlciA9PT0gJ2NsaWNrJykge1xuICAgICAgICBvdmVybGF5U3RhdGUuaGFzQmFja2Ryb3AgPSB0cnVlO1xuICAgICAgfVxuXG4gICAgICB0aGlzLm92ZXJsYXlSZWYgPSB0aGlzLm92ZXJsYXkuY3JlYXRlKG92ZXJsYXlTdGF0ZSk7XG4gICAgICB0aGlzLnN1YnNjcmliZVRvUG9zaXRpb25zKG92ZXJsYXlTdGF0ZS5wb3NpdGlvblN0cmF0ZWd5IGFzIEZsZXhpYmxlQ29ubmVjdGVkUG9zaXRpb25TdHJhdGVneSk7XG4gICAgICB0aGlzLl9zdWJzY3JpYmVUb0F0dGFjaCgpO1xuICAgICAgdGhpcy5fc3Vic2NyaWJlVG9EZXRhY2goKTtcbiAgICAgIGlmICh0aGlzLm1vZGFsKSB7XG4gICAgICAgIHRoaXMuX3N1YnNjcmliZVRvQmFja2Ryb3BDbGljaygpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGhpcy5vdmVybGF5UmVmO1xuICB9XG5cbiAgcHJpdmF0ZSBzdWJzY3JpYmVUb1Bvc2l0aW9ucyhwb3NpdGlvbjogRmxleGlibGVDb25uZWN0ZWRQb3NpdGlvblN0cmF0ZWd5KTogdm9pZCB7XG4gICAgcG9zaXRpb24ucG9zaXRpb25DaGFuZ2VzLnBpcGUodGFrZVVudGlsKHRoaXMuX2Rlc3Ryb3llZCkpLnN1YnNjcmliZShjaGFuZ2UgPT4ge1xuICAgICAgY29uc3QgcGFpciA9IGNoYW5nZS5jb25uZWN0aW9uUGFpcjtcbiAgICAgIHRoaXMucG9zaXRpb25PdmVybGF5KHBhaXIpO1xuICAgICAgdGhpcy5wb3NpdGlvbkFycm93KHBhaXIpO1xuXG4gICAgICAvLyBUaGVzZSBwb3NpdGlvbiBjaGFuZ2VzIGFycml2ZSB0b28gbGF0ZSxcbiAgICAgIC8vIFdlIGhhdmUgdG8gdHJpZ2dlciB0aGUgY2hhbmdlIGRldGVjdGlvbiBtYW51YWxseVxuICAgICAgLy8gYXMgaXQncyBkZXRhY2hlZCBmcm9tIGFueSByZW5kZXIgaGllcmFyY2h5XG4gICAgICAvLyBhbmQgb25seSB1cGRhdGVkIGJ5IHRoZSBvdmVybGF5IHdoZW4gYXR0YWNoZWQuXG4gICAgICBpZiAodGhpcy5fZW1iZWRkZWRWaWV3UmVmICYmICF0aGlzLl9lbWJlZGRlZFZpZXdSZWYuZGVzdHJveWVkKSB7XG4gICAgICAgIHRoaXMuX2VtYmVkZGVkVmlld1JlZi5kZXRlY3RDaGFuZ2VzKCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICAvLyBmb3IgbW9kYWwgcG9wb3ZlcnMgY2xvc2UgdGhlIHBvcG92ZXIgb24gYmFja2Ryb3AgY2xpY2tzXG4gIHByaXZhdGUgX3N1YnNjcmliZVRvQmFja2Ryb3BDbGljaygpIHtcbiAgICB0aGlzLm92ZXJsYXlSZWYuYmFja2Ryb3BDbGljaygpLnBpcGUodGFrZVVudGlsKHRoaXMuX2Rlc3Ryb3llZCkpLnN1YnNjcmliZSgoZXZlbnQpID0+IHtcbiAgICAgIHRoaXMuc2hvdyA9IGZhbHNlO1xuICAgIH0pO1xuICB9XG5cbiAgLy8gRW1pdCB0aGUgbnhDbG9zZWQgYW5kIHRoZSBzaG93IHN0YXR1cyBjaGFuZ2UgZXZlbnQgb24gdGhlIHBvcG92ZXIgY29tcG9uZW50IHdoZW4gdGhlIG92ZXJsYXkgZGV0YWNoZXNcbiAgcHJpdmF0ZSBfc3Vic2NyaWJlVG9EZXRhY2goKSB7XG4gICAgdGhpcy5vdmVybGF5UmVmLmRldGFjaG1lbnRzKCkucGlwZSh0YWtlVW50aWwodGhpcy5fZGVzdHJveWVkKSkuc3Vic2NyaWJlKGRhdGEgPT4ge1xuICAgICAgLy8gVGhpcyBpcyBhbiBleGNlcHRpb246IHdoZW4gdGhlIHBvcG92ZXIgaXMgY2xvc2VkIGJ5IGEgc2Nyb2xsaW5nIGV2ZW50LFxuICAgICAgLy8gdGhlbiBvbmx5IHRoZSBkZXRhY2hlZCBtZXRob2QgaXMgY2FsbGVkIGJ1dCB0aGUgc2hvdyBzdGF0ZSB2YXJpYWJsZSByZW1haW5zIHVuY2hhbmdlZC5cbiAgICAgIGlmICh0aGlzLnNob3cpIHtcbiAgICAgICAgdGhpcy5zaG93ID0gZmFsc2U7XG4gICAgICB9XG4gICAgICB0aGlzLmNoYW5nZVNob3cuZW1pdCh0aGlzLl9zaG93KTtcbiAgICAgIHRoaXMucG9wb3Zlci5lbWl0Q2xvc2VkRXZlbnQoKTtcbiAgICB9KTtcbiAgfVxuXG4gIHByaXZhdGUgX3N1YnNjcmliZVRvQXR0YWNoKCkge1xuICAgIHRoaXMub3ZlcmxheVJlZi5hdHRhY2htZW50cygpLnBpcGUodGFrZVVudGlsKHRoaXMuX2Rlc3Ryb3llZCkpLnN1YnNjcmliZShkYXRhID0+IHtcbiAgICAgIHRoaXMuY2hhbmdlU2hvdy5lbWl0KHRoaXMuX3Nob3cpO1xuICAgIH0pO1xuICB9XG5cbiAgLy8gc3Vic2NyaWJlIHRvIGRvY3VtZW50IGNsaWNrcyB3aGVuIHRyaWdnZXI9J2NsaWNrJyB0byBjbG9zZSB0aGUgcG9wb3ZlciBvbiBjbGlja3Mgb24gdGhlIGJhY2tncm91bmRcbiAgcHJpdmF0ZSB3YWl0Rm9yQ2xvc2UoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2RvY3VtZW50Q2xpY2tPYnNlcnZhYmxlXG4gICAgICAucGlwZShcbiAgICAgICAgbWFwKGV2ZW50ID0+IGV2ZW50LnRhcmdldCksXG4gICAgICAgIGZpbHRlcih0YXJnZXQgPT4gIXRoaXMuZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50LmNvbnRhaW5zKHRhcmdldCkpLFxuICAgICAgICB0YWtlVW50aWwodGhpcy5wb3BvdmVyLmNsb3NlZCkpXG4gICAgICAuc3Vic2NyaWJlKCgpID0+IHtcbiAgICAgICAgdGhpcy5zaG93ID0gZmFsc2U7XG4gICAgICB9KTtcbiAgfVxuXG4gIHByaXZhdGUgcG9zaXRpb25PdmVybGF5KHBhaXI6IENvbm5lY3Rpb25Qb3NpdGlvblBhaXIpIHtcbiAgICBpZiAocGFpci5vcmlnaW5YID09PSAnZW5kJyAmJiBwYWlyLm92ZXJsYXlYID09PSAnc3RhcnQnKSB7XG4gICAgICB0aGlzLnBvcG92ZXIuZGlyZWN0aW9uID0gJ3JpZ2h0JztcbiAgICB9IGVsc2UgaWYgKHBhaXIub3JpZ2luWSA9PT0gJ2JvdHRvbScgJiYgcGFpci5vdmVybGF5WSA9PT0gJ3RvcCcpIHtcbiAgICAgIHRoaXMucG9wb3Zlci5kaXJlY3Rpb24gPSAnYm90dG9tJztcbiAgICB9IGVsc2UgaWYgKHBhaXIub3JpZ2luWCA9PT0gJ3N0YXJ0JyAmJiBwYWlyLm92ZXJsYXlYID09PSAnZW5kJykge1xuICAgICAgdGhpcy5wb3BvdmVyLmRpcmVjdGlvbiA9ICdsZWZ0JztcbiAgICB9IGVsc2UgaWYgKHBhaXIub3JpZ2luWSA9PT0gJ3RvcCcgJiYgcGFpci5vdmVybGF5WSA9PT0gJ2JvdHRvbScpIHtcbiAgICAgIHRoaXMucG9wb3Zlci5kaXJlY3Rpb24gPSAndG9wJztcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIHBvc2l0aW9uQXJyb3cocGFpcjogQ29ubmVjdGlvblBvc2l0aW9uUGFpcikge1xuXG4gICAgY29uc3QgcGFyZW50RWxlbWVudFBvc2l0aW9uWCA9IHRoaXMuZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmxlZnQ7XG4gICAgY29uc3QgcGFyZW50RWxlbWVudFdpZHRoID0gdGhpcy5lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkud2lkdGggLyAyO1xuICAgIGNvbnN0IHBhcmVudEVsZW1lbnRMZWZ0T2Zmc2V0ID0gdGhpcy5vdmVybGF5UmVmLm92ZXJsYXlFbGVtZW50LnBhcmVudEVsZW1lbnQub2Zmc2V0TGVmdDtcbiAgICBjb25zdCBvdmVybGF5RWxlbWVudExlZnRPZmZzZXQgPSB0aGlzLm92ZXJsYXlSZWYub3ZlcmxheUVsZW1lbnQub2Zmc2V0TGVmdDtcblxuICAgIC8vIGNhbGN1bGF0aW9uIGZvciB4IHBvc2l0aW9uIG9mIHRoZSBwYXJlbnQgZWxlbWVudC4gSW4gdGhpcyBjYXNlLCBvdmVybGF5IGxlZnQgb2Zmc2V0IGlzIHRoZSBvbmUgdGhpbmcgdG8gY29uc2lkZXIuXG4gICAgY29uc3QgdGFyZ2V0UG9zaXRpb24gPSAocGFyZW50RWxlbWVudFBvc2l0aW9uWCArIHBhcmVudEVsZW1lbnRXaWR0aCkgLSAocGFyZW50RWxlbWVudExlZnRPZmZzZXQgKyBvdmVybGF5RWxlbWVudExlZnRPZmZzZXQpO1xuICAgIGlmIChwYWlyLm9yaWdpblggPT09IHBhaXIub3ZlcmxheVgpIHtcbiAgICAgIGNvbnN0IGRpcmVjdGlvbiA9ICdsZWZ0JztcbiAgICAgIGNvbnN0IGFycm93U3R5bGUgPSB7fTtcblxuICAgICAgYXJyb3dTdHlsZVtkaXJlY3Rpb25dID0gdGFyZ2V0UG9zaXRpb24gKyAncHgnO1xuICAgICAgdGhpcy5wb3BvdmVyLmFycm93U3R5bGUgPSBhcnJvd1N0eWxlO1xuICAgIH1cbiAgICBpZiAoKHBhaXIub3JpZ2luWSA9PT0gJ2JvdHRvbScgfHwgcGFpci5vcmlnaW5ZID09PSAndG9wJykgJiYgcGFpci5vdmVybGF5WCA9PT0gJ2NlbnRlcicpIHtcbiAgICAgIHRoaXMucG9wb3Zlci5hcnJvd1N0eWxlID0geyBsZWZ0OiB0YXJnZXRQb3NpdGlvbiArICdweCcgfTtcbiAgICB9XG5cbiAgICBpZiAoKHBhaXIub3JpZ2luWCA9PT0gJ2VuZCcgfHwgcGFpci5vcmlnaW5YID09PSAnc3RhcnQnKSAmJiBwYWlyLm92ZXJsYXlZID09PSAnY2VudGVyJykge1xuICAgICAgdGhpcy5wb3BvdmVyLmFycm93U3R5bGUgPSB7IHRvcDogJzUwJScgfTtcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIGdldFBvc2l0aW9uKCk6IEZsZXhpYmxlQ29ubmVjdGVkUG9zaXRpb25TdHJhdGVneSB7XG4gICAgbGV0IHBvc2l0aW9uczogQ29ubmVjdGVkUG9zaXRpb25bXTtcbiAgICBsZXQgb2Zmc2V0WCA9IDA7XG4gICAgbGV0IG9mZnNldFkgPSAwO1xuICAgIGlmICh0aGlzLmRpcmVjdGlvbiA9PT0gJ3RvcCcpIHtcbiAgICAgIHBvc2l0aW9ucyA9IFt7XG4gICAgICAgIG92ZXJsYXlYOiAnY2VudGVyJyxcbiAgICAgICAgb3ZlcmxheVk6ICdib3R0b20nLFxuICAgICAgICBvcmlnaW5YOiAnY2VudGVyJyxcbiAgICAgICAgb3JpZ2luWTogJ3RvcCdcbiAgICAgIH1dO1xuICAgICAgb2Zmc2V0WCA9IDA7XG4gICAgICBvZmZzZXRZID0gLTIwO1xuICAgIH0gZWxzZSBpZiAodGhpcy5kaXJlY3Rpb24gPT09ICdyaWdodCcpIHtcbiAgICAgIHBvc2l0aW9ucyA9IFt7XG4gICAgICAgIG92ZXJsYXlYOiAnc3RhcnQnLFxuICAgICAgICBvdmVybGF5WTogJ2NlbnRlcicsXG4gICAgICAgIG9yaWdpblg6ICdlbmQnLFxuICAgICAgICBvcmlnaW5ZOiAnY2VudGVyJ1xuICAgICAgfV07XG4gICAgICBvZmZzZXRYID0gMjA7XG4gICAgICBvZmZzZXRZID0gMDtcbiAgICB9IGVsc2UgaWYgKHRoaXMuZGlyZWN0aW9uID09PSAnYm90dG9tJykge1xuICAgICAgcG9zaXRpb25zID0gW3tcbiAgICAgICAgb3ZlcmxheVg6ICdjZW50ZXInLFxuICAgICAgICBvdmVybGF5WTogJ3RvcCcsXG4gICAgICAgIG9yaWdpblg6ICdjZW50ZXInLFxuICAgICAgICBvcmlnaW5ZOiAnYm90dG9tJ1xuICAgICAgfV07XG4gICAgICBvZmZzZXRYID0gMDtcbiAgICAgIG9mZnNldFkgPSAyMDtcbiAgICB9IGVsc2UgaWYgKHRoaXMuZGlyZWN0aW9uID09PSAnbGVmdCcpIHtcbiAgICAgIHBvc2l0aW9ucyA9IFt7XG4gICAgICAgIG92ZXJsYXlYOiAnZW5kJyxcbiAgICAgICAgb3ZlcmxheVk6ICdjZW50ZXInLFxuICAgICAgICBvcmlnaW5YOiAnc3RhcnQnLFxuICAgICAgICBvcmlnaW5ZOiAnY2VudGVyJ1xuICAgICAgfV07XG4gICAgICBvZmZzZXRYID0gLTIwO1xuICAgICAgb2Zmc2V0WSA9IDA7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLm92ZXJsYXkucG9zaXRpb24oKS5mbGV4aWJsZUNvbm5lY3RlZFRvKHRoaXMuZWxlbWVudFJlZilcbiAgICAgIC53aXRoUG9zaXRpb25zKFsuLi5wb3NpdGlvbnMsIC4uLmZhbGxiYWNrc10pXG4gICAgICAud2l0aERlZmF1bHRPZmZzZXRYKG9mZnNldFgpXG4gICAgICAud2l0aERlZmF1bHRPZmZzZXRZKG9mZnNldFkpO1xuICB9XG5cbiAgLyoqIFJldHVybnMgdGhlIGZvY3VzIHRvIHRoZSBlbGVtZW50IGZvY3VzZWQgYmVmb3JlIHRoZSBQb3BvdmVyIHdhcyBvcGVuLiAqL1xuICBwcml2YXRlIF9yZXR1cm5Gb2N1c0FmdGVyUG9wb3ZlcigpIHtcbiAgICBjb25zdCB0b0ZvY3VzID0gdGhpcy5fZWxlbWVudEZvY3VzZWRCZWZvcmVQb3BvdmVyV2FzT3BlbmVkO1xuICAgIC8vIFdlIG5lZWQgdGhlIGV4dHJhIGNoZWNrLCBiZWNhdXNlIElFIGNhbiBzZXQgdGhlIGBhY3RpdmVFbGVtZW50YCB0byBudWxsIGluIHNvbWUgY2FzZXMuXG4gICAgaWYgKHRvRm9jdXMgJiYgdHlwZW9mIHRvRm9jdXMuZm9jdXMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRvRm9jdXMuZm9jdXMoKTtcbiAgICB9XG4gIH1cbn1cbiJdfQ==