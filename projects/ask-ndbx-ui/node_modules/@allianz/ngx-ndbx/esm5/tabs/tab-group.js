/**
 * @fileoverview added by tsickle
 * Generated from: tabs/tab-group.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import * as tslib_1 from "tslib";
import { NxTabGroupBase } from './tab-group-base';
import { coerceBooleanProperty, coerceNumberProperty } from '@angular/cdk/coercion';
import { ChangeDetectionStrategy, ChangeDetectorRef, Component, ContentChildren, EventEmitter, HostListener, Input, Output, QueryList, ViewChild, ViewChildren } from '@angular/core';
import { merge, Subscription, Subject } from 'rxjs';
import { NxAccordionDirective } from '@allianz/ngx-ndbx/accordion';
import { NxExpansionPanelComponent } from '@allianz/ngx-ndbx/accordion';
import { NxTabComponent } from './tab';
import { NxTabBodyComponent } from './tab-body';
import { NxTabHeaderComponent } from './tab-header';
var NxTabChangeEvent = /** @class */ (function () {
    function NxTabChangeEvent() {
    }
    return NxTabChangeEvent;
}());
export { NxTabChangeEvent };
if (false) {
    /**
     * The index of the selected or focused tab.
     * @type {?}
     */
    NxTabChangeEvent.prototype.index;
    /**
     * The component instance of the selected or focused tab.
     * @type {?}
     */
    NxTabChangeEvent.prototype.tab;
}
/** @type {?} */
var nextId = 0;
/** @type {?} */
var MOBILE_BREAKPOINT = 480;
var NxTabGroupComponent = /** @class */ (function () {
    function NxTabGroupComponent(_changeDetectorRef) {
        this._changeDetectorRef = _changeDetectorRef;
        this._selectedIndex = null;
        this._negative = false;
        this._disabled = false;
        this._indexToSelect = 0;
        this._autoselect = true;
        this._mobileAccordion = true;
        this._showAccordion = false;
        /**
         * An event emitted when the selected tab has changed.
         */
        this.selectedIndexChange = new EventEmitter();
        /**
         * An event emitted when the selected tab has changed.
         */
        this.selectedTabChange = new EventEmitter();
        /**
         * An event emitted when focus has changed within a tab group.
         *
         * **Note:** is not supported in mobile view.
         */
        this.focusChange = new EventEmitter();
        /**
         * Subscription to tabs being added/removed.
         */
        this._tabsSubscription = Subscription.EMPTY;
        /**
         * Subscription to changes in the tab labels.
         */
        this._tabLabelSubscription = Subscription.EMPTY;
        this._disabledTabsCache = [];
        this._appearanceChange = new Subject();
        this._groupId = nextId++;
    }
    Object.defineProperty(NxTabGroupComponent.prototype, "selectedIndex", {
        /** Sets the selected tab. */
        get: /**
         * Sets the selected tab.
         * @return {?}
         */
        function () {
            return this._selectedIndex;
        },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this._indexToSelect = coerceNumberProperty(value, null);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NxTabGroupComponent.prototype, "negative", {
        /** Whether the negative set of styling should be used. */
        get: /**
         * Whether the negative set of styling should be used.
         * @return {?}
         */
        function () {
            return this._negative;
        },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            if (value !== this._negative) {
                this._negative = coerceBooleanProperty(value);
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NxTabGroupComponent.prototype, "disabled", {
        /** Whether the tab group is disabled. Default: false. */
        get: /**
         * Whether the tab group is disabled. Default: false.
         * @return {?}
         */
        function () {
            return this._disabled;
        },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            if (value !== this._disabled) {
                this._disabled = coerceBooleanProperty(value);
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NxTabGroupComponent.prototype, "autoselect", {
        /** Whether the tab should be immediately selected on focus. */
        get: /**
         * Whether the tab should be immediately selected on focus.
         * @return {?}
         */
        function () {
            return this._autoselect;
        },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this._autoselect = coerceBooleanProperty(value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NxTabGroupComponent.prototype, "mobileAccordion", {
        /** Whether the tabs should to accordion on mobile viewports. */
        get: /**
         * Whether the tabs should to accordion on mobile viewports.
         * @return {?}
         */
        function () {
            return this._mobileAccordion;
        },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this._mobileAccordion = coerceBooleanProperty(value);
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @return {?}
     */
    NxTabGroupComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        this._switchAppearance(window.innerWidth);
    };
    /**
     * @return {?}
     */
    NxTabGroupComponent.prototype.ngAfterContentInit = /**
     * @return {?}
     */
    function () {
        var _this = this;
        this._subscribeToTabLabels();
        // Subscribe to changes in the amount of tabs, in order to be
        // able to re-render the content as new tabs are added or removed.
        this._tabsSubscription = this.tabs.changes.subscribe((/**
         * @return {?}
         */
        function () {
            /** @type {?} */
            var indexToSelect = _this._clampTabIndex(_this._indexToSelect);
            // Maintain the previously-selected tab if a new tab is added or removed and there is no
            // explicit change that selects a different tab.
            if (indexToSelect === _this._selectedIndex) {
                /** @type {?} */
                var tabs = _this.tabs.toArray();
                for (var i = 0; i < tabs.length; i++) {
                    if (tabs[i].isActive) {
                        // Assign both to the `_indexToSelect` and `_selectedIndex` so we don't fire a changed
                        // event, otherwise the consumer may end up in an infinite loop in some edge cases like
                        // adding a tab within the `selectedIndexChange` event.
                        _this._indexToSelect = _this._selectedIndex = i;
                        break;
                    }
                }
            }
            _this._changeDetectorRef.markForCheck();
        }));
    };
    /**
      * After the content is checked, this component knows what tabs have been defined
      * and what the selected index should be.
      */
    /**
     * After the content is checked, this component knows what tabs have been defined
     * and what the selected index should be.
     * @return {?}
     */
    NxTabGroupComponent.prototype.ngAfterContentChecked = /**
     * After the content is checked, this component knows what tabs have been defined
     * and what the selected index should be.
     * @return {?}
     */
    function () {
        var _this = this;
        // Don't clamp the `indexToSelect` immediately in the setter because it can happen that
        // the amount of tabs changes before the actual change detection runs.
        /** @type {?} */
        var indexToSelect = this._indexToSelect = this._clampTabIndex(this._indexToSelect);
        // If the active tab is disabled select the next focusable tab
        // if all tabs are disabled, allow selection of disabled active tab.
        if (!this.disabled && this.tabs.toArray()[indexToSelect].disabled) {
            /** @type {?} */
            var nextFocusable = this.tabs.toArray()
                .map((/**
             * @param {?} tab
             * @param {?} index
             * @return {?}
             */
            function (tab, index) { return ({ tab: tab, index: index }); }))
                .find((/**
             * @param {?} item
             * @return {?}
             */
            function (item) { return !item.tab.disabled; }));
            indexToSelect = nextFocusable ? nextFocusable.index : indexToSelect;
        }
        // If the index to select was disabled previously leave the selection on the current
        // so that the selection does not jump from one to another tab.
        if (this._disabledTabsCache[this._indexToSelect]) {
            this._indexToSelect = this.selectedIndex;
        }
        // If there is a change in selected index, emit a change event. Should not trigger if
        // the selected index has not yet been initialized.
        if (this._selectedIndex !== indexToSelect) {
            /** @type {?} */
            var isFirstRun_1 = this._selectedIndex == null;
            if (!isFirstRun_1) {
                this.selectedTabChange.emit(this._createChangeEvent(indexToSelect));
            }
            // Changing these values after change detection has run
            // since the checked content may contain references to them.
            Promise.resolve().then((/**
             * @return {?}
             */
            function () {
                _this.tabs.forEach((/**
                 * @param {?} tab
                 * @param {?} index
                 * @return {?}
                 */
                function (tab, index) { return tab.isActive = index === indexToSelect; }));
                if (!isFirstRun_1) {
                    _this.selectedIndexChange.emit(indexToSelect);
                }
            }));
        }
        if (this._selectedIndex !== indexToSelect) {
            this._selectedIndex = indexToSelect;
            this._changeDetectorRef.markForCheck();
        }
        // cache the previous disabled status of all tabs
        if (!this.disabled) {
            this.tabs.toArray().forEach((/**
             * @param {?} tab
             * @param {?} index
             * @return {?}
             */
            function (tab, index) { return _this._disabledTabsCache[index] = tab.disabled; }));
        }
    };
    /**
     * @return {?}
     */
    NxTabGroupComponent.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        this._tabsSubscription.unsubscribe();
        this._tabLabelSubscription.unsubscribe();
    };
    /**
    * Subscribes to changes in the tab labels. This is needed, because the @Input for the label is
    * on the NxTab component, whereas the data binding is inside the NxTabGroup. In order for the
    * binding to be updated, we need to subscribe to changes in it and trigger change detection
    * manually.
    */
    /**
     * Subscribes to changes in the tab labels. This is needed, because the \@Input for the label is
     * on the NxTab component, whereas the data binding is inside the NxTabGroup. In order for the
     * binding to be updated, we need to subscribe to changes in it and trigger change detection
     * manually.
     * @private
     * @return {?}
     */
    NxTabGroupComponent.prototype._subscribeToTabLabels = /**
     * Subscribes to changes in the tab labels. This is needed, because the \@Input for the label is
     * on the NxTab component, whereas the data binding is inside the NxTabGroup. In order for the
     * binding to be updated, we need to subscribe to changes in it and trigger change detection
     * manually.
     * @private
     * @return {?}
     */
    function () {
        var _this = this;
        if (this._tabLabelSubscription) {
            this._tabLabelSubscription.unsubscribe();
        }
        this._tabLabelSubscription = merge.apply(void 0, tslib_1.__spread(this.tabs.map((/**
         * @param {?} tab
         * @return {?}
         */
        function (tab) { return tab._stateChanges; })))).subscribe((/**
         * @return {?}
         */
        function () { return _this._changeDetectorRef.markForCheck(); }));
    };
    /** Clamps the given index to the bounds of 0 and the tabs length. */
    /**
     * Clamps the given index to the bounds of 0 and the tabs length.
     * @private
     * @param {?} index
     * @return {?}
     */
    NxTabGroupComponent.prototype._clampTabIndex = /**
     * Clamps the given index to the bounds of 0 and the tabs length.
     * @private
     * @param {?} index
     * @return {?}
     */
    function (index) {
        // Note the `|| 0`, which ensures that values like NaN can't get through
        // and which would otherwise throw the component into an infinite loop
        // (since Math.max(NaN, 0) === NaN).
        return Math.min(this.tabs.length - 1, Math.max(index || 0, 0));
    };
    /** @docs-private */
    /**
     * \@docs-private
     * @param {?} index
     * @return {?}
     */
    NxTabGroupComponent.prototype.focusChanged = /**
     * \@docs-private
     * @param {?} index
     * @return {?}
     */
    function (index) {
        this.focusChange.emit(this._createChangeEvent(index));
    };
    /**
     * @private
     * @param {?} index
     * @return {?}
     */
    NxTabGroupComponent.prototype._createChangeEvent = /**
     * @private
     * @param {?} index
     * @return {?}
     */
    function (index) {
        /** @type {?} */
        var event = new NxTabChangeEvent;
        event.index = index;
        if (this.tabs && this.tabs.length) {
            event.tab = this.tabs.toArray()[index];
        }
        return event;
    };
    /** @docs-private */
    /**
     * \@docs-private
     * @param {?} index
     * @return {?}
     */
    NxTabGroupComponent.prototype.handleClick = /**
     * \@docs-private
     * @param {?} index
     * @return {?}
     */
    function (index) {
        /** @type {?} */
        var clickedTab = this.tabs.toArray()[index];
        if (!this.disabled && !clickedTab.disabled) {
            this.selectedIndex = this.tabHeader.focusIndex = index;
        }
    };
    /**
     * @docs-private
     * Returns the tabindex for a tab label
     */
    /**
     * \@docs-private
     * Returns the tabindex for a tab label
     * @param {?} tab
     * @param {?} idx
     * @return {?}
     */
    NxTabGroupComponent.prototype.getTabIndex = /**
     * \@docs-private
     * Returns the tabindex for a tab label
     * @param {?} tab
     * @param {?} idx
     * @return {?}
     */
    function (tab, idx) {
        return (this.selectedIndex === idx && !tab.disabled && !this.disabled) ? 0 : -1;
    };
    /** Returns a unique id for each tab label element */
    /**
     * Returns a unique id for each tab label element
     * @param {?} i
     * @return {?}
     */
    NxTabGroupComponent.prototype._getTabLabelId = /**
     * Returns a unique id for each tab label element
     * @param {?} i
     * @return {?}
     */
    function (i) {
        return "nx-tab-label-" + this._groupId + "-" + i;
    };
    /** Returns a unique id for each tab content element */
    /**
     * Returns a unique id for each tab content element
     * @param {?} i
     * @return {?}
     */
    NxTabGroupComponent.prototype._getTabContentId = /**
     * Returns a unique id for each tab content element
     * @param {?} i
     * @return {?}
     */
    function (i) {
        return "nx-tab-content-" + this._groupId + "-" + i;
    };
    /** @docs-private */
    /**
     * \@docs-private
     * @param {?} event
     * @return {?}
     */
    NxTabGroupComponent.prototype.onResize = /**
     * \@docs-private
     * @param {?} event
     * @return {?}
     */
    function (event) {
        this._switchAppearance(event.target.innerWidth);
    };
    /**
     * @private
     * @param {?} viewPortWidth
     * @return {?}
     */
    NxTabGroupComponent.prototype._switchAppearance = /**
     * @private
     * @param {?} viewPortWidth
     * @return {?}
     */
    function (viewPortWidth) {
        if (!this._mobileAccordion) {
            return;
        }
        // notify the outlets to detach the viewrefs for header and body before
        // we switch the appearance. this way we only instantiate the templates
        // once so that they do not get destroyed during the switch
        if (viewPortWidth <= MOBILE_BREAKPOINT && !this._showAccordion) {
            this._appearanceChange.next();
            this._showMobileVersion();
        }
        else if (viewPortWidth > MOBILE_BREAKPOINT && this._showAccordion) {
            this._appearanceChange.next();
            this._showDesktopVersion();
        }
    };
    /**
     * @private
     * @return {?}
     */
    NxTabGroupComponent.prototype._showMobileVersion = /**
     * @private
     * @return {?}
     */
    function () {
        this._showAccordion = true;
        this._changeDetectorRef.markForCheck();
    };
    /**
     * @private
     * @return {?}
     */
    NxTabGroupComponent.prototype._showDesktopVersion = /**
     * @private
     * @return {?}
     */
    function () {
        this._showAccordion = false;
        this._changeDetectorRef.markForCheck();
    };
    /**
     * Emulate the tab change event when an accordion panel is opened in
     * mobile viewports.
     */
    /**
     * Emulate the tab change event when an accordion panel is opened in
     * mobile viewports.
     * @param {?} index
     * @return {?}
     */
    NxTabGroupComponent.prototype._panelOpened = /**
     * Emulate the tab change event when an accordion panel is opened in
     * mobile viewports.
     * @param {?} index
     * @return {?}
     */
    function (index) {
        this.selectedIndex = index;
    };
    NxTabGroupComponent.decorators = [
        { type: Component, args: [{
                    selector: 'nx-tab-group',
                    template: "\n\n  <ng-container *ngIf=\"!_showAccordion\">\n  <nx-tab-header\n      #tabHeader\n      [selectedIndex]=\"selectedIndex\"\n      (selectFocusedIndex)=\"selectedIndex = $event\"\n      (indexFocused)=\"focusChanged($event)\"\n      [autoselect]=\"autoselect\">\n    <button\n      type=\"button\"\n      nxTabLabelWrapper\n      *ngFor=\"let tab of tabs; let i = index\"\n      role=\"tab\"\n      (click)=\"handleClick(i)\"\n      class=\"nx-tab-header__item\"\n      [id]=\"_getTabLabelId(i)\"\n      [attr.aria-controls]=\"_getTabContentId(i)\"\n      [attr.aria-selected]=\"selectedIndex == i\"\n      [attr.tabindex]=\"getTabIndex(tab, i)\"\n      [disabled]=\"tab.disabled\"\n      [class.nx-tab-header__item--disabled]=\"tab.disabled\"\n      [class.nx-tab-header__item--active]=\"selectedIndex == i\">\n      <div class=\"nx-tab-label__content\">\n        <nx-tab-header-outlet *ngIf=\"tab.templateLabel\" [content]=\"tab.headerViewRef\"></nx-tab-header-outlet>\n        <ng-container *ngIf=\"!tab.templateLabel\">{{tab.label}}</ng-container>\n      </div>\n    </button>\n  </nx-tab-header>\n\n  <div class=\"nx-tab-body__container\">\n    <nx-tab-body\n      *ngFor=\"let tab of tabs; let i = index\"\n      [id]=\"_getTabContentId(i)\"\n      role=\"tabpanel\"\n      [attr.tabindex]=\"(selectedIndex == i) ? 0 : -1\"\n      class=\"nx-tab__body\"\n      [attr.aria-labelledby]=\"_getTabContentId(i)\"\n      [class.nx-tab__body--active]=\"selectedIndex == i\"\n      [tab]=\"tab\"\n      [active]=\"selectedIndex == i\"\n    ></nx-tab-body>\n  </div>\n</ng-container>\n\n<nx-accordion *ngIf=\"_showAccordion\" [negative]=\"negative\">\n  <nx-expansion-panel *ngFor=\"let tab of tabs; let i = index\"\n                      [expanded]=\"selectedIndex === i\"\n                      (opened)=\"_panelOpened(i)\"\n                      [disabled]=\"tab.disabled\"\n  >\n    <nx-expansion-panel-header>\n      <nx-expansion-panel-title>\n        <nx-tab-header-outlet *ngIf=\"tab.templateLabel\" [content]=\"tab.headerViewRef\"></nx-tab-header-outlet>\n        <ng-container *ngIf=\"!tab.templateLabel\">{{tab.label}}</ng-container>\n      </nx-expansion-panel-title>\n    </nx-expansion-panel-header>\n    <!-- this is not lazy loading this is a trick because the portal gets added here -->\n    <!-- so we could rewrite the tab-body component that it takes care of \"lazy loading\" and the\n    accordion wouldn't know about it -->\n    <!-- active=true is a trick because we want to keep the content attached for better user experience along with expansion panel animation.  -->\n    <nx-tab-body [active]=\"true\" [tab]=\"tab\"></nx-tab-body>\n  </nx-expansion-panel>\n</nx-accordion>\n",
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    host: {
                        '[class.is-negative]': 'negative',
                        '[class.is-disabled]': 'disabled'
                    },
                    providers: [{ provide: NxTabGroupBase, useExisting: NxTabGroupComponent }],
                    styles: [":host{display:block}.nx-tab-header__item{font-size:18px;font-size:var(--tab-item-font-size,18px);line-height:24px;line-height:var(--tab-item-line-height,24px);font-weight:400;font-weight:var(--tab-item-font-weight,400);letter-spacing:.2px;letter-spacing:var(--tab-item-letter-spacing,.2px);text-decoration:none;border:#006192;background:0 0;color:#006192;color:var(--tab-item-color,#006192);border-color:var(--tab-item-border-color,#006192);border-bottom-width:2px;border-bottom-style:solid;padding:0 16px 6px;outline:0;margin:0}.nx-tab-header__item:hover:not(.nx-tab-header__item--disabled){cursor:pointer}.nx-tab-header__item::-moz-focus-inner{border:0}.nx-tab-header__item--active{border-width:4px;font-weight:700;transition:font-weight .3s;padding-bottom:4px}@media screen and (-ms-high-contrast:active){.nx-tab-header__item{background-color:buttonFace;border-color:buttonText;color:buttonText;-ms-high-contrast-adjust:none}.nx-tab-header__item--active{background-color:highlight;color:highlightText;border-color:highlight}}.nx-tab-header__item--disabled{border-color:#c2c2c2;border-color:var(--tab-item-disabled-border-color,#c2c2c2);color:#c2c2c2;color:var(--tab-item-disabled-color,#c2c2c2);cursor:not-allowed}.nx-tab-label__content{display:inline-flex;justify-content:center;align-items:center;white-space:nowrap}:host-context([data-whatinput=keyboard]) .nx-tab-header__item:focus{box-shadow:0 0 0 2px #fff,0 0 0 6px #009de6;box-shadow:var(--focus-box-shadow,0 0 0 2px #fff,0 0 0 6px #009de6);border-radius:4px}@media screen and (-ms-high-contrast:active){.nx-tab-header__item--disabled{border-color:GrayText;background-color:buttonFace;color:GrayText}:host-context([data-whatinput=keyboard]) .nx-tab-header__item:focus{box-shadow:0 0 0 2px background,0 0 0 6px windowText}}:host(.is-negative){color:#fff}:host(.is-negative) .nx-tab-header__item{color:#fff;border-bottom-color:#fff}:host(.is-negative) .nx-tab-header__item.nx-tab-header__item--disabled{border-color:rgba(255,255,255,.4);border-color:var(--tab-item-disabled-border-color,#c2c2c2);color:var(--tab-item-disabled-color,#c2c2c2);cursor:not-allowed;color:rgba(255,255,255,.4);color:var(--tab-item-disabled-negative-color,rgba(255,255,255,.4));border-color:var(--tab-item-disabled-negative-color,rgba(255,255,255,.4))}@media screen and (-ms-high-contrast:active){:host(.is-negative) .nx-tab-header__item.nx-tab-header__item--disabled{border-color:GrayText;background-color:buttonFace;color:GrayText}}:host(.is-disabled){cursor:not-allowed}:host(.is-disabled.is-negative) .nx-tab-header__item{border-color:rgba(255,255,255,.4);border-color:var(--tab-item-disabled-border-color,#c2c2c2);color:var(--tab-item-disabled-color,#c2c2c2);cursor:not-allowed;color:rgba(255,255,255,.4);color:var(--tab-item-disabled-negative-color,rgba(255,255,255,.4));border-color:var(--tab-item-disabled-negative-color,rgba(255,255,255,.4))}@media screen and (-ms-high-contrast:active){:host(.is-disabled.is-negative) .nx-tab-header__item{border-color:GrayText;background-color:buttonFace}:host(.is-negative){color:buttonText}:host(.is-negative) .nx-tab-header__item{color:buttonText;border-bottom-color:buttonText}:host(.is-negative) .nx-tab-header__item--active{background-color:highlight;color:highlightText;border-color:highlight;-ms-high-contrast-adjust:none}:host(.is-disabled.is-negative) .nx-tab-header__item{color:GrayText;border-bottom-color:GrayText}}"]
                }] }
    ];
    /** @nocollapse */
    NxTabGroupComponent.ctorParameters = function () { return [
        { type: ChangeDetectorRef }
    ]; };
    NxTabGroupComponent.propDecorators = {
        tabs: [{ type: ContentChildren, args: [NxTabComponent,] }],
        tabBodyChildren: [{ type: ViewChildren, args: [NxTabBodyComponent,] }],
        tabHeader: [{ type: ViewChild, args: ['tabHeader', { static: false },] }],
        panels: [{ type: ViewChildren, args: [NxExpansionPanelComponent,] }],
        accordion: [{ type: ViewChild, args: [NxAccordionDirective, { static: false },] }],
        selectedIndex: [{ type: Input }],
        negative: [{ type: Input }],
        disabled: [{ type: Input }],
        autoselect: [{ type: Input }],
        mobileAccordion: [{ type: Input }],
        selectedIndexChange: [{ type: Output }],
        selectedTabChange: [{ type: Output }],
        focusChange: [{ type: Output }],
        onResize: [{ type: HostListener, args: ['window:resize', ['$event'],] }]
    };
    return NxTabGroupComponent;
}());
export { NxTabGroupComponent };
if (false) {
    /**
     * @type {?}
     * @private
     */
    NxTabGroupComponent.prototype._selectedIndex;
    /**
     * @type {?}
     * @private
     */
    NxTabGroupComponent.prototype._groupId;
    /**
     * @type {?}
     * @private
     */
    NxTabGroupComponent.prototype._negative;
    /**
     * @type {?}
     * @private
     */
    NxTabGroupComponent.prototype._disabled;
    /**
     * @type {?}
     * @private
     */
    NxTabGroupComponent.prototype._indexToSelect;
    /**
     * @type {?}
     * @private
     */
    NxTabGroupComponent.prototype._autoselect;
    /**
     * @type {?}
     * @private
     */
    NxTabGroupComponent.prototype._mobileAccordion;
    /** @type {?} */
    NxTabGroupComponent.prototype._showAccordion;
    /**
     * \@docs-private
     * @type {?}
     */
    NxTabGroupComponent.prototype.tabs;
    /**
     * \@docs-private
     * @type {?}
     */
    NxTabGroupComponent.prototype.tabBodyChildren;
    /**
     * \@docs-private
     * @type {?}
     */
    NxTabGroupComponent.prototype.tabHeader;
    /**
     * \@docs-private
     * @type {?}
     */
    NxTabGroupComponent.prototype.panels;
    /**
     * \@docs-private
     * @type {?}
     */
    NxTabGroupComponent.prototype.accordion;
    /**
     * An event emitted when the selected tab has changed.
     * @type {?}
     */
    NxTabGroupComponent.prototype.selectedIndexChange;
    /**
     * An event emitted when the selected tab has changed.
     * @type {?}
     */
    NxTabGroupComponent.prototype.selectedTabChange;
    /**
     * An event emitted when focus has changed within a tab group.
     *
     * **Note:** is not supported in mobile view.
     * @type {?}
     */
    NxTabGroupComponent.prototype.focusChange;
    /**
     * Subscription to tabs being added/removed.
     * @type {?}
     * @private
     */
    NxTabGroupComponent.prototype._tabsSubscription;
    /**
     * Subscription to changes in the tab labels.
     * @type {?}
     * @private
     */
    NxTabGroupComponent.prototype._tabLabelSubscription;
    /**
     * @type {?}
     * @private
     */
    NxTabGroupComponent.prototype._disabledTabsCache;
    /** @type {?} */
    NxTabGroupComponent.prototype._appearanceChange;
    /**
     * @type {?}
     * @private
     */
    NxTabGroupComponent.prototype._changeDetectorRef;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidGFiLWdyb3VwLmpzIiwic291cmNlUm9vdCI6Im5nOi8vQGFsbGlhbnovbmd4LW5kYngvIiwic291cmNlcyI6WyJ0YWJzL3RhYi1ncm91cC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7QUFBQSxPQUFPLEVBQUUsY0FBYyxFQUFFLE1BQU0sa0JBQWtCLENBQUM7QUFDbEQsT0FBTyxFQUFFLHFCQUFxQixFQUFFLG9CQUFvQixFQUFFLE1BQU0sdUJBQXVCLENBQUM7QUFDcEYsT0FBTyxFQUdMLHVCQUF1QixFQUN2QixpQkFBaUIsRUFDakIsU0FBUyxFQUNULGVBQWUsRUFDZixZQUFZLEVBQ1osWUFBWSxFQUNaLEtBQUssRUFFTCxNQUFNLEVBQ04sU0FBUyxFQUNULFNBQVMsRUFDVCxZQUFZLEVBRWIsTUFBTSxlQUFlLENBQUM7QUFDdkIsT0FBTyxFQUFFLEtBQUssRUFBRSxZQUFZLEVBQUUsT0FBTyxFQUFFLE1BQU0sTUFBTSxDQUFDO0FBRXBELE9BQU8sRUFBRSxvQkFBb0IsRUFBRSxNQUFNLDZCQUE2QixDQUFDO0FBQ25FLE9BQU8sRUFBRSx5QkFBeUIsRUFBRSxNQUFNLDZCQUE2QixDQUFDO0FBQ3hFLE9BQU8sRUFBRSxjQUFjLEVBQUUsTUFBTSxPQUFPLENBQUM7QUFDdkMsT0FBTyxFQUFFLGtCQUFrQixFQUFFLE1BQU0sWUFBWSxDQUFDO0FBQ2hELE9BQU8sRUFBRSxvQkFBb0IsRUFBRSxNQUFNLGNBQWMsQ0FBQztBQUVwRDtJQUFBO0lBTUEsQ0FBQztJQUFELHVCQUFDO0FBQUQsQ0FBQyxBQU5ELElBTUM7Ozs7Ozs7SUFKQyxpQ0FBYzs7Ozs7SUFHZCwrQkFBb0I7OztJQUdsQixNQUFNLEdBQVcsQ0FBQzs7SUFDaEIsaUJBQWlCLEdBQUcsR0FBRztBQUU3QjtJQTRHRSw2QkFBb0Isa0JBQXFDO1FBQXJDLHVCQUFrQixHQUFsQixrQkFBa0IsQ0FBbUI7UUFoR2pELG1CQUFjLEdBQWtCLElBQUksQ0FBQztRQUVyQyxjQUFTLEdBQVksS0FBSyxD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Ozs7OztJQUdoQyxtQ0FBaUU7Ozs7O0lBR2pFLDhDQUFpRjs7Ozs7SUFHakYsd0NBQTJFOzs7OztJQUczRSxxQ0FBc0Y7Ozs7O0lBR3RGLHdDQUFvRjs7Ozs7SUFvRHBGLGtEQUEwRjs7Ozs7SUFHMUYsZ0RBQTRHOzs7Ozs7O0lBTzVHLDBDQUFzRzs7Ozs7O0lBR3RHLGdEQUErQzs7Ozs7O0lBRy9DLG9EQUFtRDs7Ozs7SUFFbkQsaURBQWdDOztJQUVoQyxnREFBa0M7Ozs7O0lBRXRCLGlEQUE2QyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IE54VGFiR3JvdXBCYXNlIH0gZnJvbSAnLi90YWItZ3JvdXAtYmFzZSc7XG5pbXBvcnQgeyBjb2VyY2VCb29sZWFuUHJvcGVydHksIGNvZXJjZU51bWJlclByb3BlcnR5IH0gZnJvbSAnQGFuZ3VsYXIvY2RrL2NvZXJjaW9uJztcbmltcG9ydCB7XG4gIEFmdGVyQ29udGVudENoZWNrZWQsXG4gIEFmdGVyQ29udGVudEluaXQsXG4gIENoYW5nZURldGVjdGlvblN0cmF0ZWd5LFxuICBDaGFuZ2VEZXRlY3RvclJlZixcbiAgQ29tcG9uZW50LFxuICBDb250ZW50Q2hpbGRyZW4sXG4gIEV2ZW50RW1pdHRlcixcbiAgSG9zdExpc3RlbmVyLFxuICBJbnB1dCxcbiAgT25EZXN0cm95LFxuICBPdXRwdXQsXG4gIFF1ZXJ5TGlzdCxcbiAgVmlld0NoaWxkLFxuICBWaWV3Q2hpbGRyZW4sXG4gIE9uSW5pdFxufSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IG1lcmdlLCBTdWJzY3JpcHRpb24sIFN1YmplY3QgfSBmcm9tICdyeGpzJztcblxuaW1wb3J0IHsgTnhBY2NvcmRpb25EaXJlY3RpdmUgfSBmcm9tICdAYWxsaWFuei9uZ3gtbmRieC9hY2NvcmRpb24nO1xuaW1wb3J0IHsgTnhFeHBhbnNpb25QYW5lbENvbXBvbmVudCB9IGZyb20gJ0BhbGxpYW56L25neC1uZGJ4L2FjY29yZGlvbic7XG5pbXBvcnQgeyBOeFRhYkNvbXBvbmVudCB9IGZyb20gJy4vdGFiJztcbmltcG9ydCB7IE54VGFiQm9keUNvbXBvbmVudCB9IGZyb20gJy4vdGFiLWJvZHknO1xuaW1wb3J0IHsgTnhUYWJIZWFkZXJDb21wb25lbnQgfSBmcm9tICcuL3RhYi1oZWFkZXInO1xuXG5leHBvcnQgY2xhc3MgTnhUYWJDaGFuZ2VFdmVudCB7XG4gIC8qKiBUaGUgaW5kZXggb2YgdGhlIHNlbGVjdGVkIG9yIGZvY3VzZWQgdGFiLiAqL1xuICBpbmRleDogbnVtYmVyO1xuXG4gIC8qKiBUaGUgY29tcG9uZW50IGluc3RhbmNlIG9mIHRoZSBzZWxlY3RlZCBvciBmb2N1c2VkIHRhYi4gKi9cbiAgdGFiOiBOeFRhYkNvbXBvbmVudDtcbn1cblxubGV0IG5leHRJZDogbnVtYmVyID0gMDtcbmNvbnN0IE1PQklMRV9CUkVBS1BPSU5UID0gNDgwO1xuXG5AQ29tcG9uZW50KHtcbiAgc2VsZWN0b3I6ICdueC10YWItZ3JvdXAnLFxuICB0ZW1wbGF0ZVVybDogJ3RhYi1ncm91cC5odG1sJyxcbiAgc3R5bGVVcmxzOiBbJy4vdGFiLWdyb3VwLnNjc3MnXSxcbiAgY2hhbmdlRGV0ZWN0aW9uOiBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5PblB1c2gsXG4gIGhvc3Q6IHtcbiAgICAnW2NsYXNzLmlzLW5lZ2F0aXZlXSc6ICduZWdhdGl2ZScsXG4gICAgJ1tjbGFzcy5pcy1kaXNhYmxlZF0nOiAnZGlzYWJsZWQnXG4gIH0sXG4gIHByb3ZpZGVyczogW3sgcHJvdmlkZTogTnhUYWJHcm91cEJhc2UsIHVzZUV4aXN0aW5nOiBOeFRhYkdyb3VwQ29tcG9uZW50IH1dXG59KVxuZXhwb3J0IGNsYXNzIE54VGFiR3JvdXBDb21wb25lbnQgaW1wbGVtZW50cyBOeFRhYkdyb3VwQmFzZSwgT25Jbml0LCBPbkRlc3Ryb3ksIEFmdGVyQ29udGVudEluaXQsIEFmdGVyQ29udGVudENoZWNrZWQge1xuICBwcml2YXRlIF9zZWxlY3RlZEluZGV4OiBudW1iZXIgfCBudWxsID0gbnVsbDtcbiAgcHJpdmF0ZSBfZ3JvdXBJZDogbnVtYmVyO1xuICBwcml2YXRlIF9uZWdhdGl2ZTogYm9vbGVhbiA9IGZhbHNlO1xuICBwcml2YXRlIF9kaXNhYmxlZDogYm9vbGVhbiA9IGZhbHNlO1xuICBwcml2YXRlIF9pbmRleFRvU2VsZWN0OiBudW1iZXIgfCBudWxsID0gMDtcbiAgcHJpdmF0ZSBfYXV0b3NlbGVjdDogYm9vbGVhbiA9IHRydWU7XG4gIHByaXZhdGUgX21vYmlsZUFjY29yZGlvbjogYm9vbGVhbiA9IHRydWU7XG4gIF9zaG93QWNjb3JkaW9uOiBib29sZWFuID0gZmFsc2U7XG5cbiAgLyoqIEBkb2NzLXByaXZhdGUgKi9cbiAgQENvbnRlbnRDaGlsZHJlbihOeFRhYkNvbXBvbmVudCkgdGFiczogUXVlcnlMaXN0PE54VGFiQ29tcG9uZW50PjtcblxuICAvKiogQGRvY3MtcHJpdmF0ZSAqL1xuICBAVmlld0NoaWxkcmVuKE54VGFiQm9keUNvbXBvbmVudCkgdGFiQm9keUNoaWxkcmVuOiBRdWVyeUxpc3Q8TnhUYWJCb2R5Q29tcG9uZW50PjtcblxuICAvKiogQGRvY3MtcHJpdmF0ZSAqL1xuICBAVmlld0NoaWxkKCd0YWJIZWFkZXInLCB7IHN0YXRpYzogZmFsc2UgfSkgdGFiSGVhZGVyOiBOeFRhYkhlYWRlckNvbXBvbmVudDtcblxuICAvKiogQGRvY3MtcHJpdmF0ZSAqL1xuICBAVmlld0NoaWxkcmVuKE54RXhwYW5zaW9uUGFuZWxDb21wb25lbnQpIHBhbmVsczogUXVlcnlMaXN0PE54RXhwYW5zaW9uUGFuZWxDb21wb25lbnQ+O1xuXG4gIC8qKiBAZG9jcy1wcml2YXRlICovXG4gIEBWaWV3Q2hpbGQoTnhBY2NvcmRpb25EaXJlY3RpdmUsIHsgc3RhdGljOiBmYWxzZSB9KSBhY2NvcmRpb246IE54QWNjb3JkaW9uRGlyZWN0aXZlO1xuXG4gIC8qKiBTZXRzIHRoZSBzZWxlY3RlZCB0YWIuICovXG4gIEBJbnB1dCgpXG4gIGdldCBzZWxlY3RlZEluZGV4KCk6IG51bWJlciB7XG4gICAgcmV0dXJuIHRoaXMuX3NlbGVjdGVkSW5kZXg7XG4gIH1cbiAgc2V0IHNlbGVjdGVkSW5kZXgodmFsdWU6IG51bWJlcikge1xuICAgIHRoaXMuX2luZGV4VG9TZWxlY3QgPSBjb2VyY2VOdW1iZXJQcm9wZXJ0eSh2YWx1ZSwgbnVsbCk7XG4gIH1cblxuICAvKiogV2hldGhlciB0aGUgbmVnYXRpdmUgc2V0IG9mIHN0eWxpbmcgc2hvdWxkIGJlIHVzZWQuICovXG4gIEBJbnB1dCgpXG4gIGdldCBuZWdhdGl2ZSgpOiBib29sZWFuIHtcbiAgICByZXR1cm4gdGhpcy5fbmVnYXRpdmU7XG4gIH1cbiAgc2V0IG5lZ2F0aXZlKHZhbHVlOiBib29sZWFuKSB7XG4gICAgaWYgKHZhbHVlICE9PSB0aGlzLl9uZWdhdGl2ZSkge1xuICAgICAgdGhpcy5fbmVnYXRpdmUgPSBjb2VyY2VCb29sZWFuUHJvcGVydHkodmFsdWUpO1xuICAgIH1cbiAgfVxuXG4gIC8qKiBXaGV0aGVyIHRoZSB0YWIgZ3JvdXAgaXMgZGlzYWJsZWQuIERlZmF1bHQ6IGZhbHNlLiAqL1xuICBASW5wdXQoKVxuICBnZXQgZGlzYWJsZWQoKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRoaXMuX2Rpc2FibGVkO1xuICB9XG4gIHNldCBkaXNhYmxlZCh2YWx1ZTogYm9vbGVhbikge1xuICAgIGlmICh2YWx1ZSAhPT0gdGhpcy5fZGlzYWJsZWQpIHtcbiAgICAgIHRoaXMuX2Rpc2FibGVkID0gY29lcmNlQm9vbGVhblByb3BlcnR5KHZhbHVlKTtcbiAgICB9XG4gIH1cblxuICAvKiogV2hldGhlciB0aGUgdGFiIHNob3VsZCBiZSBpbW1lZGlhdGVseSBzZWxlY3RlZCBvbiBmb2N1cy4gKi9cbiAgQElucHV0KClcbiAgZ2V0IGF1dG9zZWxlY3QoKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRoaXMuX2F1dG9zZWxlY3Q7XG4gIH1cbiAgc2V0IGF1dG9zZWxlY3QodmFsdWU6IGJvb2xlYW4pIHtcbiAgICB0aGlzLl9hdXRvc2VsZWN0ID0gY29lcmNlQm9vbGVhblByb3BlcnR5KHZhbHVlKTtcbiAgfVxuXG4gIC8qKiBXaGV0aGVyIHRoZSB0YWJzIHNob3VsZCB0byBhY2NvcmRpb24gb24gbW9iaWxlIHZpZXdwb3J0cy4gKi9cbiAgQElucHV0KClcbiAgZ2V0IG1vYmlsZUFjY29yZGlvbigpOiBib29sZWFuIHtcbiAgICByZXR1cm4gdGhpcy5fbW9iaWxlQWNjb3JkaW9uO1xuICB9XG4gIHNldCBtb2JpbGVBY2NvcmRpb24odmFsdWU6IGJvb2xlYW4pIHtcbiAgICB0aGlzLl9tb2JpbGVBY2NvcmRpb24gPSBjb2VyY2VCb29sZWFuUHJvcGVydHkodmFsdWUpO1xuICB9XG5cbiAgLyoqIEFuIGV2ZW50IGVtaXR0ZWQgd2hlbiB0aGUgc2VsZWN0ZWQgdGFiIGhhcyBjaGFuZ2VkLiAqL1xuICBAT3V0cHV0KCkgcmVhZG9ubHkgc2VsZWN0ZWRJbmRleENoYW5nZTogRXZlbnRFbWl0dGVyPG51bWJlcj4gPSBuZXcgRXZlbnRFbWl0dGVyPG51bWJlcj4oKTtcblxuICAvKiogQW4gZXZlbnQgZW1pdHRlZCB3aGVuIHRoZSBzZWxlY3RlZCB0YWIgaGFzIGNoYW5nZWQuICovXG4gIEBPdXRwdXQoKSByZWFkb25seSBzZWxlY3RlZFRhYkNoYW5nZTogRXZlbnRFbWl0dGVyPE54VGFiQ2hhbmdlRXZlbnQ+ID0gbmV3IEV2ZW50RW1pdHRlcjxOeFRhYkNoYW5nZUV2ZW50PigpO1xuXG4gIC8qKlxuICAgKiBBbiBldmVudCBlbWl0dGVkIHdoZW4gZm9jdXMgaGFzIGNoYW5nZWQgd2l0aGluIGEgdGFiIGdyb3VwLlxuICAgKlxuICAgKiAqKk5vdGU6KiogaXMgbm90IHN1cHBvcnRlZCBpbiBtb2JpbGUgdmlldy5cbiAgICovXG4gIEBPdXRwdXQoKSByZWFkb25seSBmb2N1c0NoYW5nZTogRXZlbnRFbWl0dGVyPE54VGFiQ2hhbmdlRXZlbnQ+ID0gbmV3IEV2ZW50RW1pdHRlcjxOeFRhYkNoYW5nZUV2ZW50PigpO1xuXG4gIC8qKiBTdWJzY3JpcHRpb24gdG8gdGFicyBiZWluZyBhZGRlZC9yZW1vdmVkLiAqL1xuICBwcml2YXRlIF90YWJzU3Vic2NyaXB0aW9uID0gU3Vic2NyaXB0aW9uLkVNUFRZO1xuXG4gIC8qKiBTdWJzY3JpcHRpb24gdG8gY2hhbmdlcyBpbiB0aGUgdGFiIGxhYmVscy4gKi9cbiAgcHJpdmF0ZSBfdGFiTGFiZWxTdWJzY3JpcHRpb24gPSBTdWJzY3JpcHRpb24uRU1QVFk7XG5cbiAgcHJpdmF0ZSBfZGlzYWJsZWRUYWJzQ2FjaGUgPSBbXTtcblxuICBfYXBwZWFyYW5jZUNoYW5nZSA9IG5ldyBTdWJqZWN0KCk7XG5cbiAgY29uc3RydWN0b3IocHJpdmF0ZSBfY2hhbmdlRGV0ZWN0b3JSZWY6IENoYW5nZURldGVjdG9yUmVmKSB7XG4gICAgdGhpcy5fZ3JvdXBJZCA9IG5leHRJZCsrO1xuICB9XG5cbiAgbmdPbkluaXQoKSB7XG4gICAgdGhpcy5fc3dpdGNoQXBwZWFyYW5jZSh3aW5kb3cuaW5uZXJXaWR0aCk7XG4gIH1cblxuICBuZ0FmdGVyQ29udGVudEluaXQoKSB7XG4gICAgdGhpcy5fc3Vic2NyaWJlVG9UYWJMYWJlbHMoKTtcblxuICAgIC8vIFN1YnNjcmliZSB0byBjaGFuZ2VzIGluIHRoZSBhbW91bnQgb2YgdGFicywgaW4gb3JkZXIgdG8gYmVcbiAgICAvLyBhYmxlIHRvIHJlLXJlbmRlciB0aGUgY29udGVudCBhcyBuZXcgdGFicyBhcmUgYWRkZWQgb3IgcmVtb3ZlZC5cbiAgICB0aGlzLl90YWJzU3Vic2NyaXB0aW9uID0gdGhpcy50YWJzLmNoYW5nZXMuc3Vic2NyaWJlKCgpID0+IHtcbiAgICAgIGNvbnN0IGluZGV4VG9TZWxlY3QgPSB0aGlzLl9jbGFtcFRhYkluZGV4KHRoaXMuX2luZGV4VG9TZWxlY3QpO1xuICAgICAgLy8gTWFpbnRhaW4gdGhlIHByZXZpb3VzbHktc2VsZWN0ZWQgdGFiIGlmIGEgbmV3IHRhYiBpcyBhZGRlZCBvciByZW1vdmVkIGFuZCB0aGVyZSBpcyBub1xuICAgICAgLy8gZXhwbGljaXQgY2hhbmdlIHRoYXQgc2VsZWN0cyBhIGRpZmZlcmVudCB0YWIuXG4gICAgICBpZiAoaW5kZXhUb1NlbGVjdCA9PT0gdGhpcy5fc2VsZWN0ZWRJbmRleCkge1xuICAgICAgICBjb25zdCB0YWJzID0gdGhpcy50YWJzLnRvQXJyYXkoKTtcblxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRhYnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBpZiAodGFic1tpXS5pc0FjdGl2ZSkge1xuICAgICAgICAgICAgLy8gQXNzaWduIGJvdGggdG8gdGhlIGBfaW5kZXhUb1NlbGVjdGAgYW5kIGBfc2VsZWN0ZWRJbmRleGAgc28gd2UgZG9uJ3QgZmlyZSBhIGNoYW5nZWRcbiAgICAgICAgICAgIC8vIGV2ZW50LCBvdGhlcndpc2UgdGhlIGNvbnN1bWVyIG1heSBlbmQgdXAgaW4gYW4gaW5maW5pdGUgbG9vcCBpbiBzb21lIGVkZ2UgY2FzZXMgbGlrZVxuICAgICAgICAgICAgLy8gYWRkaW5nIGEgdGFiIHdpdGhpbiB0aGUgYHNlbGVjdGVkSW5kZXhDaGFuZ2VgIGV2ZW50LlxuICAgICAgICAgICAgdGhpcy5faW5kZXhUb1NlbGVjdCA9IHRoaXMuX3NlbGVjdGVkSW5kZXggPSBpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX2NoYW5nZURldGVjdG9yUmVmLm1hcmtGb3JDaGVjaygpO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAgKiBBZnRlciB0aGUgY29udGVudCBpcyBjaGVja2VkLCB0aGlzIGNvbXBvbmVudCBrbm93cyB3aGF0IHRhYnMgaGF2ZSBiZWVuIGRlZmluZWRcbiAgICAqIGFuZCB3aGF0IHRoZSBzZWxlY3RlZCBpbmRleCBzaG91bGQgYmUuXG4gICAgKi9cbiAgbmdBZnRlckNvbnRlbnRDaGVja2VkKCkge1xuXG4gICAgLy8gRG9uJ3QgY2xhbXAgdGhlIGBpbmRleFRvU2VsZWN0YCBpbW1lZGlhdGVseSBpbiB0aGUgc2V0dGVyIGJlY2F1c2UgaXQgY2FuIGhhcHBlbiB0aGF0XG4gICAgLy8gdGhlIGFtb3VudCBvZiB0YWJzIGNoYW5nZXMgYmVmb3JlIHRoZSBhY3R1YWwgY2hhbmdlIGRldGVjdGlvbiBydW5zLlxuICAgIGxldCBpbmRleFRvU2VsZWN0ID0gdGhpcy5faW5kZXhUb1NlbGVjdCA9IHRoaXMuX2NsYW1wVGFiSW5kZXgodGhpcy5faW5kZXhUb1NlbGVjdCk7XG5cbiAgICAvLyBJZiB0aGUgYWN0aXZlIHRhYiBpcyBkaXNhYmxlZCBzZWxlY3QgdGhlIG5leHQgZm9jdXNhYmxlIHRhYlxuICAgIC8vIGlmIGFsbCB0YWJzIGFyZSBkaXNhYmxlZCwgYWxsb3cgc2VsZWN0aW9uIG9mIGRpc2FibGVkIGFjdGl2ZSB0YWIuXG4gICAgaWYgKCF0aGlzLmRpc2FibGVkICYmIHRoaXMudGFicy50b0FycmF5KClbaW5kZXhUb1NlbGVjdF0uZGlzYWJsZWQpIHtcbiAgICAgIGNvbnN0IG5leHRGb2N1c2FibGUgPSB0aGlzLnRhYnMudG9BcnJheSgpXG4gICAgICAgIC5tYXAoKHRhYiwgaW5kZXgpID0+ICh7IHRhYjogdGFiLCBpbmRleDogaW5kZXggfSkpXG4gICAgICAgIC5maW5kKGl0ZW0gPT4gIWl0ZW0udGFiLmRpc2FibGVkKTtcblxuICAgICAgaW5kZXhUb1NlbGVjdCA9IG5leHRGb2N1c2FibGUgPyBuZXh0Rm9jdXNhYmxlLmluZGV4IDogaW5kZXhUb1NlbGVjdDtcbiAgICB9XG5cbiAgICAvLyBJZiB0aGUgaW5kZXggdG8gc2VsZWN0IHdhcyBkaXNhYmxlZCBwcmV2aW91c2x5IGxlYXZlIHRoZSBzZWxlY3Rpb24gb24gdGhlIGN1cnJlbnRcbiAgICAvLyBzbyB0aGF0IHRoZSBzZWxlY3Rpb24gZG9lcyBub3QganVtcCBmcm9tIG9uZSB0byBhbm90aGVyIHRhYi5cbiAgICBpZiAodGhpcy5fZGlzYWJsZWRUYWJzQ2FjaGVbdGhpcy5faW5kZXhUb1NlbGVjdF0pIHtcbiAgICAgIHRoaXMuX2luZGV4VG9TZWxlY3QgPSB0aGlzLnNlbGVjdGVkSW5kZXg7XG4gICAgfVxuXG4gICAgLy8gSWYgdGhlcmUgaXMgYSBjaGFuZ2UgaW4gc2VsZWN0ZWQgaW5kZXgsIGVtaXQgYSBjaGFuZ2UgZXZlbnQuIFNob3VsZCBub3QgdHJpZ2dlciBpZlxuICAgIC8vIHRoZSBzZWxlY3RlZCBpbmRleCBoYXMgbm90IHlldCBiZWVuIGluaXRpYWxpemVkLlxuICAgIGlmICh0aGlzLl9zZWxlY3RlZEluZGV4ICE9PSBpbmRleFRvU2VsZWN0KSB7XG4gICAgICBjb25zdCBpc0ZpcnN0UnVuID0gdGhpcy5fc2VsZWN0ZWRJbmRleCA9PSBudWxsO1xuXG4gICAgICBpZiAoIWlzRmlyc3RSdW4pIHtcbiAgICAgICAgdGhpcy5zZWxlY3RlZFRhYkNoYW5nZS5lbWl0KHRoaXMuX2NyZWF0ZUNoYW5nZUV2ZW50KGluZGV4VG9TZWxlY3QpKTtcbiAgICAgIH1cblxuICAgICAgLy8gQ2hhbmdpbmcgdGhlc2UgdmFsdWVzIGFmdGVyIGNoYW5nZSBkZXRlY3Rpb24gaGFzIHJ1blxuICAgICAgLy8gc2luY2UgdGhlIGNoZWNrZWQgY29udGVudCBtYXkgY29udGFpbiByZWZlcmVuY2VzIHRvIHRoZW0uXG4gICAgICBQcm9taXNlLnJlc29sdmUoKS50aGVuKCgpID0+IHtcbiAgICAgICAgdGhpcy50YWJzLmZvckVhY2goKHRhYiwgaW5kZXgpID0+IHRhYi5pc0FjdGl2ZSA9IGluZGV4ID09PSBpbmRleFRvU2VsZWN0KTtcblxuICAgICAgICBpZiAoIWlzRmlyc3RSdW4pIHtcbiAgICAgICAgICB0aGlzLnNlbGVjdGVkSW5kZXhDaGFuZ2UuZW1pdChpbmRleFRvU2VsZWN0KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX3NlbGVjdGVkSW5kZXggIT09IGluZGV4VG9TZWxlY3QpIHtcbiAgICAgIHRoaXMuX3NlbGVjdGVkSW5kZXggPSBpbmRleFRvU2VsZWN0O1xuICAgICAgdGhpcy5fY2hhbmdlRGV0ZWN0b3JSZWYubWFya0ZvckNoZWNrKCk7XG4gICAgfVxuXG4gICAgLy8gY2FjaGUgdGhlIHByZXZpb3VzIGRpc2FibGVkIHN0YXR1cyBvZiBhbGwgdGFic1xuICAgIGlmICghdGhpcy5kaXNhYmxlZCkge1xuICAgICAgdGhpcy50YWJzLnRvQXJyYXkoKS5mb3JFYWNoKCh0YWIsIGluZGV4KSA9PiB0aGlzLl9kaXNhYmxlZFRhYnNDYWNoZVtpbmRleF0gPSB0YWIuZGlzYWJsZWQpO1xuICAgIH1cbiAgfVxuXG4gIG5nT25EZXN0cm95KCkge1xuICAgIHRoaXMuX3RhYnNTdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcbiAgICB0aGlzLl90YWJMYWJlbFN1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xuICB9XG5cbiAgLyoqXG4gICogU3Vic2NyaWJlcyB0byBjaGFuZ2VzIGluIHRoZSB0YWIgbGFiZWxzLiBUaGlzIGlzIG5lZWRlZCwgYmVjYXVzZSB0aGUgQElucHV0IGZvciB0aGUgbGFiZWwgaXNcbiAgKiBvbiB0aGUgTnhUYWIgY29tcG9uZW50LCB3aGVyZWFzIHRoZSBkYXRhIGJpbmRpbmcgaXMgaW5zaWRlIHRoZSBOeFRhYkdyb3VwLiBJbiBvcmRlciBmb3IgdGhlXG4gICogYmluZGluZyB0byBiZSB1cGRhdGVkLCB3ZSBuZWVkIHRvIHN1YnNjcmliZSB0byBjaGFuZ2VzIGluIGl0IGFuZCB0cmlnZ2VyIGNoYW5nZSBkZXRlY3Rpb25cbiAgKiBtYW51YWxseS5cbiAgKi9cbiAgcHJpdmF0ZSBfc3Vic2NyaWJlVG9UYWJMYWJlbHMoKSB7XG4gICAgaWYgKHRoaXMuX3RhYkxhYmVsU3Vic2NyaXB0aW9uKSB7XG4gICAgICB0aGlzLl90YWJMYWJlbFN1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xuICAgIH1cblxuICAgIHRoaXMuX3RhYkxhYmVsU3Vic2NyaXB0aW9uID0gbWVyZ2UoLi4udGhpcy50YWJzLm1hcCh0YWIgPT4gdGFiLl9zdGF0ZUNoYW5nZXMpKVxuICAgICAgLnN1YnNjcmliZSgoKSA9PiB0aGlzLl9jaGFuZ2VEZXRlY3RvclJlZi5tYXJrRm9yQ2hlY2soKSk7XG4gIH1cblxuICAvKiogQ2xhbXBzIHRoZSBnaXZlbiBpbmRleCB0byB0aGUgYm91bmRzIG9mIDAgYW5kIHRoZSB0YWJzIGxlbmd0aC4gKi9cbiAgcHJpdmF0ZSBfY2xhbXBUYWJJbmRleChpbmRleDogbnVtYmVyIHwgbnVsbCk6IG51bWJlciB7XG4gICAgLy8gTm90ZSB0aGUgYHx8IDBgLCB3aGljaCBlbnN1cmVzIHRoYXQgdmFsdWVzIGxpa2UgTmFOIGNhbid0IGdldCB0aHJvdWdoXG4gICAgLy8gYW5kIHdoaWNoIHdvdWxkIG90aGVyd2lzZSB0aHJvdyB0aGUgY29tcG9uZW50IGludG8gYW4gaW5maW5pdGUgbG9vcFxuICAgIC8vIChzaW5jZSBNYXRoLm1heChOYU4sIDApID09PSBOYU4pLlxuICAgIHJldHVybiBNYXRoLm1pbih0aGlzLnRhYnMubGVuZ3RoIC0gMSwgTWF0aC5tYXgoaW5kZXggfHwgMCwgMCkpO1xuICB9XG5cbiAgLyoqIEBkb2NzLXByaXZhdGUgKi9cbiAgZm9jdXNDaGFuZ2VkKGluZGV4OiBudW1iZXIpIHtcbiAgICB0aGlzLmZvY3VzQ2hhbmdlLmVtaXQodGhpcy5fY3JlYXRlQ2hhbmdlRXZlbnQoaW5kZXgpKTtcbiAgfVxuXG4gIHByaXZhdGUgX2NyZWF0ZUNoYW5nZUV2ZW50KGluZGV4OiBudW1iZXIpOiBOeFRhYkNoYW5nZUV2ZW50IHtcbiAgICBjb25zdCBldmVudCA9IG5ldyBOeFRhYkNoYW5nZUV2ZW50O1xuICAgIGV2ZW50LmluZGV4ID0gaW5kZXg7XG4gICAgaWYgKHRoaXMudGFicyAmJiB0aGlzLnRhYnMubGVuZ3RoKSB7XG4gICAgICBldmVudC50YWIgPSB0aGlzLnRhYnMudG9BcnJheSgpW2luZGV4XTtcbiAgICB9XG4gICAgcmV0dXJuIGV2ZW50O1xuICB9XG5cbiAgLyoqIEBkb2NzLXByaXZhdGUgKi9cbiAgaGFuZGxlQ2xpY2soaW5kZXg6IG51bWJlcikge1xuICAgIGNvbnN0IGNsaWNrZWRUYWIgPSB0aGlzLnRhYnMudG9BcnJheSgpW2luZGV4XTtcbiAgICBpZiAoIXRoaXMuZGlzYWJsZWQgJiYgIWNsaWNrZWRUYWIuZGlzYWJsZWQpIHtcbiAgICAgIHRoaXMuc2VsZWN0ZWRJbmRleCA9IHRoaXMudGFiSGVhZGVyLmZvY3VzSW5kZXggPSBpbmRleDtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQGRvY3MtcHJpdmF0ZVxuICAgKiBSZXR1cm5zIHRoZSB0YWJpbmRleCBmb3IgYSB0YWIgbGFiZWxcbiAgICovXG4gIGdldFRhYkluZGV4KHRhYjogTnhUYWJDb21wb25lbnQsIGlkeDogbnVtYmVyKTogbnVtYmVyIHwgbnVsbCB7XG4gICAgcmV0dXJuICh0aGlzLnNlbGVjdGVkSW5kZXggPT09IGlkeCAmJiAhdGFiLmRpc2FibGVkICYmICF0aGlzLmRpc2FibGVkKSA/IDAgOiAtMTtcbiAgfVxuXG4gIC8qKiBSZXR1cm5zIGEgdW5pcXVlIGlkIGZvciBlYWNoIHRhYiBsYWJlbCBlbGVtZW50ICovXG4gIF9nZXRUYWJMYWJlbElkKGk6IG51bWJlcik6IHN0cmluZyB7XG4gICAgcmV0dXJuIGBueC10YWItbGFiZWwtJHt0aGlzLl9ncm91cElkfS0ke2l9YDtcbiAgfVxuXG4gIC8qKiBSZXR1cm5zIGEgdW5pcXVlIGlkIGZvciBlYWNoIHRhYiBjb250ZW50IGVsZW1lbnQgKi9cbiAgX2dldFRhYkNvbnRlbnRJZChpOiBudW1iZXIpOiBzdHJpbmcge1xuICAgIHJldHVybiBgbngtdGFiLWNvbnRlbnQtJHt0aGlzLl9ncm91cElkfS0ke2l9YDtcbiAgfVxuXG4gIC8qKiBAZG9jcy1wcml2YXRlICovXG4gIEBIb3N0TGlzdGVuZXIoJ3dpbmRvdzpyZXNpemUnLCBbJyRldmVudCddKVxuICBvblJlc2l6ZShldmVudCkge1xuICAgIHRoaXMuX3N3aXRjaEFwcGVhcmFuY2UoZXZlbnQudGFyZ2V0LmlubmVyV2lkdGgpO1xuICB9XG5cbiAgcHJpdmF0ZSBfc3dpdGNoQXBwZWFyYW5jZSh2aWV3UG9ydFdpZHRoKSB7XG4gICAgaWYgKCF0aGlzLl9tb2JpbGVBY2NvcmRpb24pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgLy8gbm90aWZ5IHRoZSBvdXRsZXRzIHRvIGRldGFjaCB0aGUgdmlld3JlZnMgZm9yIGhlYWRlciBhbmQgYm9keSBiZWZvcmVcbiAgICAvLyB3ZSBzd2l0Y2ggdGhlIGFwcGVhcmFuY2UuIHRoaXMgd2F5IHdlIG9ubHkgaW5zdGFudGlhdGUgdGhlIHRlbXBsYXRlc1xuICAgIC8vIG9uY2Ugc28gdGhhdCB0aGV5IGRvIG5vdCBnZXQgZGVzdHJveWVkIGR1cmluZyB0aGUgc3dpdGNoXG4gICAgaWYgKHZpZXdQb3J0V2lkdGggPD0gTU9CSUxFX0JSRUFLUE9JTlQgJiYgIXRoaXMuX3Nob3dBY2NvcmRpb24pIHtcbiAgICAgIHRoaXMuX2FwcGVhcmFuY2VDaGFuZ2UubmV4dCgpO1xuICAgICAgdGhpcy5fc2hvd01vYmlsZVZlcnNpb24oKTtcbiAgICB9IGVsc2UgaWYgKHZpZXdQb3J0V2lkdGggPiBNT0JJTEVfQlJFQUtQT0lOVCAmJiB0aGlzLl9zaG93QWNjb3JkaW9uKSB7XG4gICAgICB0aGlzLl9hcHBlYXJhbmNlQ2hhbmdlLm5leHQoKTtcbiAgICAgIHRoaXMuX3Nob3dEZXNrdG9wVmVyc2lvbigpO1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgX3Nob3dNb2JpbGVWZXJzaW9uKCkge1xuICAgIHRoaXMuX3Nob3dBY2NvcmRpb24gPSB0cnVlO1xuICAgIHRoaXMuX2NoYW5nZURldGVjdG9yUmVmLm1hcmtGb3JDaGVjaygpO1xuICB9XG5cbiAgcHJpdmF0ZSBfc2hvd0Rlc2t0b3BWZXJzaW9uKCkge1xuICAgIHRoaXMuX3Nob3dBY2NvcmRpb24gPSBmYWxzZTtcbiAgICB0aGlzLl9jaGFuZ2VEZXRlY3RvclJlZi5tYXJrRm9yQ2hlY2soKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBFbXVsYXRlIHRoZSB0YWIgY2hhbmdlIGV2ZW50IHdoZW4gYW4gYWNjb3JkaW9uIHBhbmVsIGlzIG9wZW5lZCBpblxuICAgKiBtb2JpbGUgdmlld3BvcnRzLlxuICAgKi9cbiAgX3BhbmVsT3BlbmVkKGluZGV4OiBudW1iZXIpIHtcbiAgICB0aGlzLnNlbGVjdGVkSW5kZXggPSBpbmRleDtcbiAgfVxufVxuIl19