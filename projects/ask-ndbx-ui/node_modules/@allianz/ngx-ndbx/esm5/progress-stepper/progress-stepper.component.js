/**
 * @fileoverview added by tsickle
 * Generated from: progress-stepper.component.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import * as tslib_1 from "tslib";
import { DOCUMENT } from '@angular/common';
import { CdkStep, CdkStepper } from '@angular/cdk/stepper';
import { ChangeDetectionStrategy, Component, ContentChildren, Directive, forwardRef, Inject, Input, QueryList, SkipSelf, ElementRef, ChangeDetectorRef } from '@angular/core';
import { takeUntil, takeWhile } from 'rxjs/operators';
import { ErrorStateMatcher } from '@allianz/ngx-ndbx/utils';
import { Subject } from 'rxjs';
import { Directionality } from '@angular/cdk/bidi';
// tslint:disable:use-input-property-decorator
// We need to reference steps in stepper and stepper in steps. To prevent circular depenedency errors
// Provide both components in a single file. Otherwise we would have to introduce interface/abstract classes
// shared between both implementations.
var NxStepComponent = /** @class */ (function (_super) {
    tslib_1.__extends(NxStepComponent, _super);
    function NxStepComponent(stepper, _errorStateMatcher) {
        var _this = _super.call(this, stepper) || this;
        _this.stepper = stepper;
        _this._errorStateMatcher = _errorStateMatcher;
        _this._destroyed = new Subject();
        _this._interacted = false;
        return _this;
    }
    Object.defineProperty(NxStepComponent.prototype, "stepControl", {
        /** The top level abstract control of the step. */
        get: /**
         * The top level abstract control of the step.
         * @return {?}
         */
        function () {
            return this._stepControl;
        },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            var _this = this;
            this._stepControl = value;
            // If a step control changes its state, the stepper needs to update.
            if (this._stepControl) {
                this._stepControl.statusChanges
                    .pipe(takeUntil(this._destroyed), takeWhile((/**
                 * @return {?}
                 */
                function () { return _this._stepControl === value; })))
                    .subscribe((/**
                 * @return {?}
                 */
                function () {
                    _this.stepper._stateChanged();
                }));
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NxStepComponent.prototype, "interacted", {
        /** Whether the user has seen the expanded step content or not. */
        get: /**
         * Whether the user has seen the expanded step content or not.
         * @return {?}
         */
        function () {
            return this._interacted;
        },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this._interacted = value;
            if (this.stepper) {
                this.stepper._stateChanged();
            }
        },
        enumerable: true,
        configurable: true
    });
    /** Custom error state matcher that checks for validity of the step form. */
    /**
     * Custom error state matcher that checks for validity of the step form.
     * @param {?} control
     * @param {?} form
     * @return {?}
     */
    NxStepComponent.prototype.isErrorState = /**
     * Custom error state matcher that checks for validity of the step form.
     * @param {?} control
     * @param {?} form
     * @return {?}
     */
    function (control, form) {
        /** @type {?} */
        var originalErrorState = this._errorStateMatcher.isErrorState(control, form);
        // Checks for the validity of a step form that is not submitted or touched,
        // e.g when the user directly clicks the "next" button or directly on the step
        /** @type {?} */
        var customErrorState = !!(control && control.invalid && this.interacted);
        return originalErrorState || customErrorState;
    };
    /**
     * @return {?}
     */
    NxStepComponent.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        this._destroyed.next(true);
        this._destroyed.complete();
    };
    NxStepComponent.decorators = [
        { type: Component, args: [{
                    selector: 'nx-step',
                    template: "<ng-template><ng-content></ng-content></ng-template>\n",
                    exportAs: 'nxStep',
                    providers: [{ provide: ErrorStateMatcher, useExisting: NxStepComponent }],
                    preserveWhitespaces: false,
                    changeDetection: ChangeDetectionStrategy.OnPush
                }] }
    ];
    /** @nocollapse */
    NxStepComponent.ctorParameters = function () { return [
        { type: NxProgressStepperDirective, decorators: [{ type: Inject, args: [forwardRef((/**
                         * @return {?}
                         */
                        function () { return NxProgressStepperDirective; })),] }] },
        { type: ErrorStateMatcher, decorators: [{ type: SkipSelf }] }
    ]; };
    return NxStepComponent;
}(CdkStep));
export { NxStepComponent };
if (false) {
    /** @type {?} */
    NxStepComponent.prototype._destroyed;
    /**
     * @type {?}
     * @private
     */
    NxStepComponent.prototype._stepControl;
    /**
     * @type {?}
     * @private
     */
    NxStepComponent.prototype._interacted;
    /**
     * @type {?}
     * @private
     */
    NxStepComponent.prototype.stepper;
    /**
     * @type {?}
     * @private
     */
    NxStepComponent.prototype._errorStateMatcher;
}
/**
 * \@docs-private
 */
var NxProgressStepperDirective = /** @class */ (function (_super) {
    tslib_1.__extends(NxProgressStepperDirective, _super);
    function NxProgressStepperDirective(_cdRef, _dir, _elementRef, _document) {
        var _this = _super.call(this, _dir, _cdRef, _elementRef, _document) || this;
        _this._cdRef = _cdRef;
        _this._stepHeader = new QueryList();
        return _this;
    }
    /**
     * @return {?}
     */
    NxProgressStepperDirective.prototype.ngAfterContentInit = /**
     * @return {?}
     */
    function () {
        var _this = this;
        // Mark the component for change detection whenever the content children query changes
        this._steps.changes
            .pipe(takeUntil(this._destroyed))
            .subscribe((/**
         * @return {?}
         */
        function () {
            _this._stateChanged();
        }));
        // If a step control changes its state, the stepper needs to update.
        this._steps.filter((/**
         * @param {?} s
         * @return {?}
         */
        function (s) { return !!s.stepControl; }))
            .forEach((/**
         * @param {?} step
         * @return {?}
         */
        function (step) {
            step.stepControl.statusChanges
                .pipe(takeUntil(step._destroyed))
                .subscribe((/**
             * @return {?}
             */
            function () {
                _this._stateChanged();
            }));
        }));
        // we need to defer change detection that the nxStepperNext and NxStepperPrevious buttons
        // can run change detection again, because they are initialized before the stepper content
        Promise.resolve().then((/**
         * @return {?}
         */
        function () {
            _this._cdRef.detectChanges();
        }));
    };
    Object.defineProperty(NxProgressStepperDirective.prototype, "hasPrevious", {
        /** @docs-private */
        get: /**
         * \@docs-private
         * @return {?}
         */
        function () {
            return (this.selectedIndex - 1) >= 0;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NxProgressStepperDirective.prototype, "hasNext", {
        /** @docs-private */
        get: /**
         * \@docs-private
         * @return {?}
         */
        function () {
            return (this.selectedIndex + 1) < this.count;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NxProgressStepperDirective.prototype, "count", {
        /** @docs-private */
        get: /**
         * \@docs-private
         * @return {?}
         */
        function () {
            return this._steps ? this._steps.length : 0;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NxProgressStepperDirective.prototype, "currentStep", {
        /** @docs-private */
        get: /**
         * \@docs-private
         * @return {?}
         */
        function () {
            if (this.count === 0 || this.selectedIndex === -1) {
                return null;
            }
            /** @type {?} */
            var steps = this._steps.toArray();
            return steps[this.selectedIndex];
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NxProgressStepperDirective.prototype, "nextStep", {
        /** @docs-private */
        get: /**
         * \@docs-private
         * @return {?}
         */
        function () {
            if (this.selectedIndex + 1 >= this._steps.length) {
                return null;
            }
            return this._steps.toArray()[this.selectedIndex + 1];
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NxProgressStepperDirective.prototype, "steps", {
        /** @docs-private */
        get: /**
         * \@docs-private
         * @return {?}
         */
        function () {
            return this._steps;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NxProgressStepperDirective.prototype, "currentLabel", {
        /** @docs-private */
        get: /**
         * \@docs-private
         * @return {?}
         */
        function () {
            /** @type {?} */
            var step = this.currentStep;
            /** @type {?} */
            var label = step.stepLabel || step.label;
            return this.currentStepLabel + " " + (this.selectedIndex + 1) + "/" + this.count + ": " + label;
        },
        enumerable: true,
        configurable: true
    });
    NxProgressStepperDirective.decorators = [
        { type: Directive, args: [{
                    selector: '[nxProgressStepper]',
                    exportAs: 'nxProgressStepper',
                },] }
    ];
    /** @nocollapse */
    NxProgressStepperDirective.ctorParameters = function () { return [
        { type: ChangeDetectorRef },
        { type: Directionality },
        { type: ElementRef },
        { type: undefined, decorators: [{ type: Inject, args: [DOCUMENT,] }] }
    ]; };
    NxProgressStepperDirective.propDecorators = {
        _steps: [{ type: ContentChildren, args: [NxStepComponent, { descendants: true },] }],
        currentStepLabel: [{ type: Input }],
        title: [{ type: Input }]
    };
    return NxProgressStepperDirective;
}(CdkStepper));
export { NxProgressStepperDirective };
if (false) {
    /** @type {?} */
    NxProgressStepperDirective.prototype._steps;
    /** @type {?} */
    NxProgressStepperDirective.prototype._stepHeader;
    /**
     * Sets the label on the left side showing the current step label. Used for mobile viewports.
     * @type {?}
     */
    NxProgressStepperDirective.prototype.currentStepLabel;
    /**
     * Sets the title to be rendered above the progress bar.
     * \@deletion-target 10.0.0
     * @deprecated Use `nx-label` instead
     * @type {?}
     */
    NxProgressStepperDirective.prototype.title;
    /**
     * @type {?}
     * @private
     */
    NxProgressStepperDirective.prototype._cdRef;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicHJvZ3Jlc3Mtc3RlcHBlci5jb21wb25lbnQuanMiLCJzb3VyY2VSb290Ijoibmc6Ly9AYWxsaWFuei9uZ3gtbmRieC9wcm9ncmVzcy1zdGVwcGVyLyIsInNvdXJjZXMiOlsicHJvZ3Jlc3Mtc3RlcHBlci5jb21wb25lbnQudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQUEsT0FBTyxFQUFFLFFBQVEsRUFBRSxNQUFNLGlCQUFpQixDQUFDO0FBQzNDLE9BQU8sRUFBRSxPQUFPLEVBQUUsVUFBVSxFQUFFLE1BQU0sc0JBQXNCLENBQUM7QUFDM0QsT0FBTyxFQUVMLHVCQUF1QixFQUN2QixTQUFTLEVBQ1QsZUFBZSxFQUNmLFNBQVMsRUFDVCxVQUFVLEVBQ1YsTUFBTSxFQUNOLEtBQUssRUFDTCxTQUFTLEVBQ1QsUUFBUSxFQUVSLFVBQVUsRUFDVixpQkFBaUIsRUFDbEIsTUFBTSxlQUFlLENBQUM7QUFDdkIsT0FBTyxFQUFFLFNBQVMsRUFBRSxTQUFTLEVBQUUsTUFBTSxnQkFBZ0IsQ0FBQztBQUN0RCxPQUFPLEVBQUUsaUJBQWlCLEVBQUUsTUFBTSx5QkFBeUIsQ0FBQztBQUU1RCxPQUFPLEVBQUUsT0FBTyxFQUFnQixNQUFNLE1BQU0sQ0FBQztBQUM3QyxPQUFPLEVBQUUsY0FBYyxFQUFFLE1BQU0sbUJBQW1CLENBQUM7Ozs7O0FBUW5EO0lBUXFDLDJDQUFPO0lBRzFDLHlCQUNrRSxPQUFtQyxFQUM3RSxrQkFBcUM7UUFGN0QsWUFHRSxrQkFBTSxPQUFPLENBQUMsU0FDZjtRQUhpRSxhQUFPLEdBQVAsT0FBTyxDQUE0QjtRQUM3RSx3QkFBa0IsR0FBbEIsa0JBQWtCLENBQW1CO1FBSjdELGdCQUFVLEdBQXFCLElBQUksT0FBTyxFQUFFLENBQUM7UUF5Q3JDLGlCQUFXLEdBQVksS0FBSyxDQUFDOztJQW5DckMsQ0FBQztJQUVELHNCQUFJLHdDQUFXO1FBZWYsa0RBQWtEOzs7OztRQUNsRDtZQUNFLE9BQU8sSUFBSSxDQUFDLFlBQVksQ0FBQztR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Qjs7OztnQkF0RkMsaUJBQWlCO2dCQU1WLGNBQWM7Z0JBUHJCLFVBQVU7Z0RBMEdQLE1BQU0sU0FBQyxRQUFROzs7eUJBZmpCLGVBQWUsU0FBQyxlQUFlLEVBQUUsRUFBRSxXQUFXLEVBQUUsSUFBSSxFQUFFO21DQUl0RCxLQUFLO3dCQUtMLEtBQUs7O0lBaUZSLGlDQUFDO0NBQUEsQUFqR0QsQ0FJZ0QsVUFBVSxHQTZGekQ7U0E3RlksMEJBQTBCOzs7SUFHckMsNENBQTRGOztJQUM1RixpREFBK0M7Ozs7O0lBRy9DLHNEQUFrQzs7Ozs7OztJQUtsQywyQ0FBdUI7Ozs7O0lBR3JCLDRDQUFpQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IERPQ1VNRU5UIH0gZnJvbSAnQGFuZ3VsYXIvY29tbW9uJztcbmltcG9ydCB7IENka1N0ZXAsIENka1N0ZXBwZXIgfSBmcm9tICdAYW5ndWxhci9jZGsvc3RlcHBlcic7XG5pbXBvcnQge1xuICBBZnRlckNvbnRlbnRJbml0LFxuICBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneSxcbiAgQ29tcG9uZW50LFxuICBDb250ZW50Q2hpbGRyZW4sXG4gIERpcmVjdGl2ZSxcbiAgZm9yd2FyZFJlZixcbiAgSW5qZWN0LFxuICBJbnB1dCxcbiAgUXVlcnlMaXN0LFxuICBTa2lwU2VsZixcbiAgT25EZXN0cm95LFxuICBFbGVtZW50UmVmLFxuICBDaGFuZ2VEZXRlY3RvclJlZlxufSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IHRha2VVbnRpbCwgdGFrZVdoaWxlIH0gZnJvbSAncnhqcy9vcGVyYXRvcnMnO1xuaW1wb3J0IHsgRXJyb3JTdGF0ZU1hdGNoZXIgfSBmcm9tICdAYWxsaWFuei9uZ3gtbmRieC91dGlscyc7XG5pbXBvcnQgeyBGb3JtQ29udHJvbCwgRm9ybUdyb3VwRGlyZWN0aXZlLCBOZ0Zvcm0gfSBmcm9tICdAYW5ndWxhci9mb3Jtcyc7XG5pbXBvcnQgeyBTdWJqZWN0LCBTdWJzY3JpcHRpb24gfSBmcm9tICdyeGpzJztcbmltcG9ydCB7IERpcmVjdGlvbmFsaXR5IH0gZnJvbSAnQGFuZ3VsYXIvY2RrL2JpZGknO1xuXG4vLyB0c2xpbnQ6ZGlzYWJsZTp1c2UtaW5wdXQtcHJvcGVydHktZGVjb3JhdG9yXG5cbi8vIFdlIG5lZWQgdG8gcmVmZXJlbmNlIHN0ZXBzIGluIHN0ZXBwZXIgYW5kIHN0ZXBwZXIgaW4gc3RlcHMuIFRvIHByZXZlbnQgY2lyY3VsYXIgZGVwZW5lZGVuY3kgZXJyb3JzXG4vLyBQcm92aWRlIGJvdGggY29tcG9uZW50cyBpbiBhIHNpbmdsZSBmaWxlLiBPdGhlcndpc2Ugd2Ugd291bGQgaGF2ZSB0byBpbnRyb2R1Y2UgaW50ZXJmYWNlL2Fic3RyYWN0IGNsYXNzZXNcbi8vIHNoYXJlZCBiZXR3ZWVuIGJvdGggaW1wbGVtZW50YXRpb25zLlxuXG5AQ29tcG9uZW50KHtcbiAgc2VsZWN0b3I6ICdueC1zdGVwJyxcbiAgdGVtcGxhdGVVcmw6ICdwcm9ncmVzcy1zdGVwcGVyLmNvbXBvbmVudC5odG1sJyxcbiAgZXhwb3J0QXM6ICdueFN0ZXAnLFxuICBwcm92aWRlcnM6IFt7cHJvdmlkZTogRXJyb3JTdGF0ZU1hdGNoZXIsIHVzZUV4aXN0aW5nOiBOeFN0ZXBDb21wb25lbnR9XSxcbiAgcHJlc2VydmVXaGl0ZXNwYWNlczogZmFsc2UsXG4gIGNoYW5nZURldGVjdGlvbjogQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuT25QdXNoLFxufSlcbmV4cG9ydCBjbGFzcyBOeFN0ZXBDb21wb25lbnQgZXh0ZW5kcyBDZGtTdGVwIGltcGxlbWVudHMgRXJyb3JTdGF0ZU1hdGNoZXIsIE9uRGVzdHJveSB7XG4gIF9kZXN0cm95ZWQ6IFN1YmplY3Q8Ym9vbGVhbj4gPSBuZXcgU3ViamVjdCgpO1xuXG4gIGNvbnN0cnVjdG9yKFxuICAgICAgQEluamVjdChmb3J3YXJkUmVmKCgpID0+IE54UHJvZ3Jlc3NTdGVwcGVyRGlyZWN0aXZlKSkgcHJpdmF0ZSBzdGVwcGVyOiBOeFByb2dyZXNzU3RlcHBlckRpcmVjdGl2ZSxcbiAgICAgIEBTa2lwU2VsZigpIHByaXZhdGUgX2Vycm9yU3RhdGVNYXRjaGVyOiBFcnJvclN0YXRlTWF0Y2hlcikge1xuICAgIHN1cGVyKHN0ZXBwZXIpO1xuICB9XG5cbiAgc2V0IHN0ZXBDb250cm9sKHZhbHVlOiBhbnkpIHtcbiAgICB0aGlzLl9zdGVwQ29udHJvbCA9IHZhbHVlO1xuXG4gICAgLy8gSWYgYSBzdGVwIGNvbnRyb2wgY2hhbmdlcyBpdHMgc3RhdGUsIHRoZSBzdGVwcGVyIG5lZWRzIHRvIHVwZGF0ZS5cbiAgICBpZiAodGhpcy5fc3RlcENvbnRyb2wpIHtcbiAgICAgIHRoaXMuX3N0ZXBDb250cm9sLnN0YXR1c0NoYW5nZXNcbiAgICAgICAgLnBpcGUoXG4gICAgICAgICAgdGFrZVVudGlsKHRoaXMuX2Rlc3Ryb3llZCksXG4gICAgICAgICAgdGFrZVdoaWxlKCgpID0+IHRoaXMuX3N0ZXBDb250cm9sID09PSB2YWx1ZSlcbiAgICAgICAgKVxuICAgICAgICAuc3Vic2NyaWJlKCgpID0+IHtcbiAgICAgICAgICB0aGlzLnN0ZXBwZXIuX3N0YXRlQ2hhbmdlZCgpO1xuICAgICAgICB9KTtcbiAgICB9XG4gIH1cbiAgLyoqIFRoZSB0b3AgbGV2ZWwgYWJzdHJhY3QgY29udHJvbCBvZiB0aGUgc3RlcC4gKi9cbiAgZ2V0IHN0ZXBDb250cm9sKCkge1xuICAgIHJldHVybiB0aGlzLl9zdGVwQ29udHJvbDtcbiAgfVxuICBwcml2YXRlIF9zdGVwQ29udHJvbDogYW55O1xuXG4gIHNldCBpbnRlcmFjdGVkKHZhbHVlOiBib29sZWFuKSB7XG4gICAgdGhpcy5faW50ZXJhY3RlZCA9IHZhbHVlO1xuXG4gICAgaWYgKHRoaXMuc3RlcHBlcikge1xuICAgICAgdGhpcy5zdGVwcGVyLl9zdGF0ZUNoYW5nZWQoKTtcbiAgICB9XG4gIH1cblxuICAvKiogV2hldGhlciB0aGUgdXNlciBoYXMgc2VlbiB0aGUgZXhwYW5kZWQgc3RlcCBjb250ZW50IG9yIG5vdC4gKi9cbiAgZ2V0IGludGVyYWN0ZWQoKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRoaXMuX2ludGVyYWN0ZWQ7XG4gIH1cbiAgcHJpdmF0ZSBfaW50ZXJhY3RlZDogYm9vbGVhbiA9IGZhbHNlO1xuXG4gIC8qKiBDdXN0b20gZXJyb3Igc3RhdGUgbWF0Y2hlciB0aGF0IGNoZWNrcyBmb3IgdmFsaWRpdHkgb2YgdGhlIHN0ZXAgZm9ybS4gKi9cbiAgaXNFcnJvclN0YXRlKGNvbnRyb2w6IEZvcm1Db250cm9sIHwgbnVsbCwgZm9ybTogRm9ybUdyb3VwRGlyZWN0aXZlIHwgTmdGb3JtIHwgbnVsbCk6IGJvb2xlYW4ge1xuICAgIGNvbnN0IG9yaWdpbmFsRXJyb3JTdGF0ZSA9IHRoaXMuX2Vycm9yU3RhdGVNYXRjaGVyLmlzRXJyb3JTdGF0ZShjb250cm9sLCBmb3JtKTtcblxuICAgIC8vIENoZWNrcyBmb3IgdGhlIHZhbGlkaXR5IG9mIGEgc3RlcCBmb3JtIHRoYXQgaXMgbm90IHN1Ym1pdHRlZCBvciB0b3VjaGVkLFxuICAgIC8vIGUuZyB3aGVuIHRoZSB1c2VyIGRpcmVjdGx5IGNsaWNrcyB0aGUgXCJuZXh0XCIgYnV0dG9uIG9yIGRpcmVjdGx5IG9uIHRoZSBzdGVwXG4gICAgY29uc3QgY3VzdG9tRXJyb3JTdGF0ZSA9ICEhKGNvbnRyb2wgJiYgY29udHJvbC5pbnZhbGlkICYmIHRoaXMuaW50ZXJhY3RlZCk7XG4gICAgcmV0dXJuIG9yaWdpbmFsRXJyb3JTdGF0ZSB8fCBjdXN0b21FcnJvclN0YXRlO1xuICB9XG5cbiAgbmdPbkRlc3Ryb3koKSB7XG4gICAgdGhpcy5fZGVzdHJveWVkLm5leHQodHJ1ZSk7XG4gICAgdGhpcy5fZGVzdHJveWVkLmNvbXBsZXRlKCk7XG4gIH1cbn1cblxuLyoqIEBkb2NzLXByaXZhdGUgKi9cbkBEaXJlY3RpdmUoe1xuICBzZWxlY3RvcjogJ1tueFByb2dyZXNzU3RlcHBlcl0nLFxuICBleHBvcnRBczogJ254UHJvZ3Jlc3NTdGVwcGVyJyxcbn0pXG5leHBvcnQgY2xhc3MgTnhQcm9ncmVzc1N0ZXBwZXJEaXJlY3RpdmUgZXh0ZW5kcyBDZGtTdGVwcGVyIGltcGxlbWVudHMgQWZ0ZXJDb250ZW50SW5pdCB7XG4gIC8vIERvIG5vdCBpbml0aWFsaXplIHdpdGggYW4gZW1wdHkgUXVlcnlMaXN0IG9yIHRoZSBoYXNOZXh0KCkgZnVuY3Rpb24gcHJvZHVjZXNcbiAgLy8gd3JvbmcgcmVzdWx0cyBvbiBpbml0XG4gIEBDb250ZW50Q2hpbGRyZW4oTnhTdGVwQ29tcG9uZW50LCB7IGRlc2NlbmRhbnRzOiB0cnVlIH0pIF9zdGVwczogUXVlcnlMaXN0PE54U3RlcENvbXBvbmVudD47XG4gIF9zdGVwSGVhZGVyOiBRdWVyeUxpc3Q8bnVsbD4gPSBuZXcgUXVlcnlMaXN0KCk7XG5cbiAgLyoqIFNldHMgdGhlIGxhYmVsIG9uIHRoZSBsZWZ0IHNpZGUgc2hvd2luZyB0aGUgY3VycmVudCBzdGVwIGxhYmVsLiBVc2VkIGZvciBtb2JpbGUgdmlld3BvcnRzLiAqL1xuICBASW5wdXQoKSBjdXJyZW50U3RlcExhYmVsOiBzdHJpbmc7XG5cbiAgLyoqIFNldHMgdGhlIHRpdGxlIHRvIGJlIHJlbmRlcmVkIGFib3ZlIHRoZSBwcm9ncmVzcyBiYXIuXG4gICAqIEBkZWxldGlvbi10YXJnZXQgMTAuMC4wXG4gICAqIEBkZXByZWNhdGVkIFVzZSBgbngtbGFiZWxgIGluc3RlYWQgKi9cbiAgQElucHV0KCkgdGl0bGU6IHN0cmluZztcblxuICBjb25zdHJ1Y3RvcihcbiAgICBwcml2YXRlIF9jZFJlZjogQ2hhbmdlRGV0ZWN0b3JSZWYsXG4gICAgX2RpcjogRGlyZWN0aW9uYWxpdHksXG4gICAgX2VsZW1lbnRSZWY6IEVsZW1lbnRSZWY8SFRNTEVsZW1lbnQ+LFxuICAgIEBJbmplY3QoRE9DVU1FTlQpIF9kb2N1bWVudD86IGFueSkge1xuICAgICAgc3VwZXIoX2RpciwgX2NkUmVmLCBfZWxlbWVudFJlZiwgX2RvY3VtZW50KTtcbiAgICB9XG5cbiAgbmdBZnRlckNvbnRlbnRJbml0KCkge1xuICAgIC8vIE1hcmsgdGhlIGNvbXBvbmVudCBmb3IgY2hhbmdlIGRldGVjdGlvbiB3aGVuZXZlciB0aGUgY29udGVudCBjaGlsZHJlbiBxdWVyeSBjaGFuZ2VzXG4gICAgdGhpcy5fc3RlcHMuY2hhbmdlc1xuICAgICAgLnBpcGUodGFrZVVudGlsKHRoaXMuX2Rlc3Ryb3llZCkpXG4gICAgICAuc3Vic2NyaWJlKCgpID0+IHtcbiAgICAgICAgdGhpcy5fc3RhdGVDaGFuZ2VkKCk7XG4gICAgICB9KTtcblxuICAgIC8vIElmIGEgc3RlcCBjb250cm9sIGNoYW5nZXMgaXRzIHN0YXRlLCB0aGUgc3RlcHBlciBuZWVkcyB0byB1cGRhdGUuXG4gICAgdGhpcy5fc3RlcHMuZmlsdGVyKHMgPT4gISFzLnN0ZXBDb250cm9sKVxuICAgICAgLmZvckVhY2goc3RlcCA9PiB7XG4gICAgICAgIHN0ZXAuc3RlcENvbnRyb2wuc3RhdHVzQ2hhbmdlc1xuICAgICAgICAgIC5waXBlKHRha2VVbnRpbChzdGVwLl9kZXN0cm95ZWQpKVxuICAgICAgICAgIC5zdWJzY3JpYmUoKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5fc3RhdGVDaGFuZ2VkKCk7XG4gICAgICAgICAgfSk7XG4gICAgICB9KTtcblxuICAgIC8vIHdlIG5lZWQgdG8gZGVmZXIgY2hhbmdlIGRldGVjdGlvbiB0aGF0IHRoZSBueFN0ZXBwZXJOZXh0IGFuZCBOeFN0ZXBwZXJQcmV2aW91cyBidXR0b25zXG4gICAgLy8gY2FuIHJ1biBjaGFuZ2UgZGV0ZWN0aW9uIGFnYWluLCBiZWNhdXNlIHRoZXkgYXJlIGluaXRpYWxpemVkIGJlZm9yZSB0aGUgc3RlcHBlciBjb250ZW50XG4gICAgUHJvbWlzZS5yZXNvbHZlKCkudGhlbigoKSA9PiB7XG4gICAgICB0aGlzLl9jZFJlZi5kZXRlY3RDaGFuZ2VzKCk7XG4gICAgfSk7XG4gIH1cblxuICAvKiogQGRvY3MtcHJpdmF0ZSAqL1xuICBnZXQgaGFzUHJldmlvdXMoKSB7XG4gICAgcmV0dXJuICh0aGlzLnNlbGVjdGVkSW5kZXggLSAxKSA+PSAwO1xuICB9XG5cbiAgLyoqIEBkb2NzLXByaXZhdGUgKi9cbiAgZ2V0IGhhc05leHQoKSB7XG4gICAgcmV0dXJuICh0aGlzLnNlbGVjdGVkSW5kZXggKyAxKSA8IHRoaXMuY291bnQ7XG4gIH1cblxuICAvKiogQGRvY3MtcHJpdmF0ZSAqL1xuICBnZXQgY291bnQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3N0ZXBzID8gdGhpcy5fc3RlcHMubGVuZ3RoIDogMDtcbiAgfVxuXG4gIC8qKiBAZG9jcy1wcml2YXRlICovXG4gIGdldCBjdXJyZW50U3RlcCgpOiBOeFN0ZXBDb21wb25lbnQgfCBudWxsIHtcbiAgICBpZiAodGhpcy5jb3VudCA9PT0gMCB8fCB0aGlzLnNlbGVjdGVkSW5kZXggPT09IC0xKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBjb25zdCBzdGVwcyA9IHRoaXMuX3N0ZXBzLnRvQXJyYXkoKTtcbiAgICByZXR1cm4gc3RlcHNbdGhpcy5zZWxlY3RlZEluZGV4XTtcbiAgfVxuXG4gIC8qKiBAZG9jcy1wcml2YXRlICovXG4gIGdldCBuZXh0U3RlcCgpOiBOeFN0ZXBDb21wb25lbnQgfCBudWxsIHtcbiAgICBpZiAodGhpcy5zZWxlY3RlZEluZGV4ICsgMSA+PSB0aGlzLl9zdGVwcy5sZW5ndGgpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLl9zdGVwcy50b0FycmF5KClbdGhpcy5zZWxlY3RlZEluZGV4ICsgMV07XG4gIH1cblxuICAvKiogQGRvY3MtcHJpdmF0ZSAqL1xuICBnZXQgc3RlcHMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3N0ZXBzO1xuICB9XG5cbiAgLyoqIEBkb2NzLXByaXZhdGUgKi9cbiAgZ2V0IGN1cnJlbnRMYWJlbCgpIHtcbiAgICBjb25zdCBzdGVwID0gdGhpcy5jdXJyZW50U3RlcDtcbiAgICBjb25zdCBsYWJlbCA9IHN0ZXAuc3RlcExhYmVsIHx8IHN0ZXAubGFiZWw7XG5cbiAgICByZXR1cm4gYCR7dGhpcy5jdXJyZW50U3RlcExhYmVsfSAke3RoaXMuc2VsZWN0ZWRJbmRleCArIDF9LyR7dGhpcy5jb3VudH06ICR7bGFiZWx9YDtcbiAgfVxufVxuIl19