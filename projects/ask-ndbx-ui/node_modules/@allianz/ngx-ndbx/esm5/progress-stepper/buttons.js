/**
 * @fileoverview added by tsickle
 * Generated from: buttons.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import * as tslib_1 from "tslib";
import { CdkStepper, CdkStepperNext, CdkStepperPrevious } from '@angular/cdk/stepper';
import { ChangeDetectorRef, Directive } from '@angular/core';
import { NxProgressStepperDirective } from './progress-stepper.component';
// tslint:disable:use-input-property-decorator
var NxStepperNextDirective = /** @class */ (function (_super) {
    tslib_1.__extends(NxStepperNextDirective, _super);
    function NxStepperNextDirective(_stepper, changeDetectorRef) {
        var _this = _super.call(this, _stepper) || this;
        _this.changeDetectorRef = changeDetectorRef;
        /**
         * \@docs-private
         */
        _this.disabled = false;
        return _this;
    }
    /**
     * Implemented to prevent changed after checked error after stepper init.
     * When the stepper initializes the directive is checked first before
     * the stepper can check its content thus it doesn't know about it's children yet
     * so _stepper.hasNext returns false and disables the buttons. In the same CD cycle
     * after the stepper has checked its contents the button needs to be enabled resulting
     * in the error.
     */
    /**
     * Implemented to prevent changed after checked error after stepper init.
     * When the stepper initializes the directive is checked first before
     * the stepper can check its content thus it doesn't know about it's children yet
     * so _stepper.hasNext returns false and disables the buttons. In the same CD cycle
     * after the stepper has checked its contents the button needs to be enabled resulting
     * in the error.
     * @return {?}
     */
    NxStepperNextDirective.prototype.ngDoCheck = /**
     * Implemented to prevent changed after checked error after stepper init.
     * When the stepper initializes the directive is checked first before
     * the stepper can check its content thus it doesn't know about it's children yet
     * so _stepper.hasNext returns false and disables the buttons. In the same CD cycle
     * after the stepper has checked its contents the button needs to be enabled resulting
     * in the error.
     * @return {?}
     */
    function () {
        /** @type {?} */
        var stepper = (/** @type {?} */ ((/** @type {?} */ (this._stepper))));
        if (this.disabled !== !stepper.hasNext) {
            this.disabled = !stepper.hasNext;
            this.changeDetectorRef.markForCheck();
        }
    };
    NxStepperNextDirective.decorators = [
        { type: Directive, args: [{
                    selector: 'button[nxStepperNext]',
                    host: {
                        '[type]': 'type',
                        '[disabled]': 'disabled'
                    },
                    inputs: ['type'],
                    providers: [{ provide: CdkStepper, useExisting: NxProgressStepperDirective }]
                },] }
    ];
    /** @nocollapse */
    NxStepperNextDirective.ctorParameters = function () { return [
        { type: CdkStepper },
        { type: ChangeDetectorRef }
    ]; };
    return NxStepperNextDirective;
}(CdkStepperNext));
export { NxStepperNextDirective };
if (false) {
    /**
     * \@docs-private
     * @type {?}
     */
    NxStepperNextDirective.prototype.disabled;
    /**
     * @type {?}
     * @private
     */
    NxStepperNextDirective.prototype.changeDetectorRef;
}
var NxStepperPreviousDirective = /** @class */ (function (_super) {
    tslib_1.__extends(NxStepperPreviousDirective, _super);
    function NxStepperPreviousDirective(_stepper) {
        return _super.call(this, _stepper) || this;
    }
    Object.defineProperty(NxStepperPreviousDirective.prototype, "stepper", {
        get: /**
         * @return {?}
         */
        function () {
            return (/** @type {?} */ (this._stepper));
        },
        enumerable: true,
        configurable: true
    });
    NxStepperPreviousDirective.decorators = [
        { type: Directive, args: [{
                    selector: 'button[nxStepperPrevious]',
                    host: {
                        '[type]': 'type',
                        '[disabled]': '!stepper.hasPrevious'
                    },
                    inputs: ['type'],
                    providers: [{ provide: CdkStepper, useExisting: NxProgressStepperDirective }]
                },] }
    ];
    /** @nocollapse */
    NxStepperPreviousDirective.ctorParameters = function () { return [
        { type: CdkStepper }
    ]; };
    return NxStepperPreviousDirective;
}(CdkStepperPrevious));
export { NxStepperPreviousDirective };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYnV0dG9ucy5qcyIsInNvdXJjZVJvb3QiOiJuZzovL0BhbGxpYW56L25neC1uZGJ4L3Byb2dyZXNzLXN0ZXBwZXIvIiwic291cmNlcyI6WyJidXR0b25zLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7OztBQUFBLE9BQU8sRUFBRSxVQUFVLEVBQUUsY0FBYyxFQUFFLGtCQUFrQixFQUFFLE1BQU0sc0JBQXNCLENBQUM7QUFDdEYsT0FBTyxFQUFFLGlCQUFpQixFQUFFLFNBQVMsRUFBVyxNQUFNLGVBQWUsQ0FBQztBQUV0RSxPQUFPLEVBQUUsMEJBQTBCLEVBQUUsTUFBTSw4QkFBOEIsQ0FBQzs7QUFJMUU7SUFTNEMsa0RBQWM7SUFLeEQsZ0NBQVksUUFBb0IsRUFBVSxpQkFBb0M7UUFBOUUsWUFDRSxrQkFBTSxRQUFRLENBQUMsU0FDaEI7UUFGeUMsdUJBQWlCLEdBQWpCLGlCQUFpQixDQUFtQjs7OztRQUY5RSxjQUFRLEdBQUcsS0FBSyxDQUFDOztJQUlqQixDQUFDO0lBRUQ7Ozs7Ozs7T0FPRzs7Ozs7Ozs7OztJQUNILDBDQUFTOzs7Ozs7Ozs7SUFBVDs7WUFDUSxPQUFPLEdBQUcsbUJBQUEsbUJBQUEsSUFBSSxDQUFDLFFBQVEsRUFBTyxFQUE4QjtRQUNsRSxJQUFJLElBQUksQ0FBQyxRQUFRLEtBQUssQ0FBQyxPQUFPLENBQUMsT0FBTyxFQUFFO1lBQ3RDLElBQUksQ0FBQyxRQUFRLEdBQUcsQ0FBQyxPQUFPLENBQUMsT0FBTyxDQUFDO1lBQ2pDLElBQUksQ0FBQyxpQkFBaUIsQ0FBQyxZQUFZLEVBQUUsQ0FBQztTQUN2QztJQUNILENBQUM7O2dCQWhDRixTQUFTLFNBQUM7b0JBQ1QsUUFBUSxFQUFFLHVCQUF1QjtvQkFDakMsSUFBSSxFQUFFO3dCQUNKLFFBQVEsRUFBRSxNQUFNO3dCQUNoQixZQUFZLEVBQUUsVUFBVTtxQkFDekI7b0JBQ0QsTUFBTSxFQUFFLENBQUMsTUFBTSxDQUFDO29CQUNoQixTQUFTLEVBQUUsQ0FBQyxFQUFDLE9BQU8sRUFBRSxVQUFVLEVBQUUsV0FBVyxFQUFFLDBCQUEwQixFQUFDLENBQUM7aUJBQzVFOzs7O2dCQWZRLFVBQVU7Z0JBQ1YsaUJBQWlCOztJQXVDMUIsNkJBQUM7Q0FBQSxBQWpDRCxDQVM0QyxjQUFjLEdBd0J6RDtTQXhCWSxzQkFBc0I7Ozs7OztJQUdqQywwQ0FBaUI7Ozs7O0lBRWlCLG1EQUE0Qzs7QUFxQmhGO0lBU2dELHNEQUFrQjtJQUNoRSxvQ0FBWSxRQUFvQjtlQUM5QixrQkFBTSxRQUFRLENBQUM7SUFDakIsQ0FBQztJQUVELHNCQUFJLCtDQUFPOzs7O1FBQVg7WUFDRSxPQUFPLG1CQUFBLElBQUksQ0FBQyxRQUFRLEVBQThCLENBQUM7UUFDckQsQ0FBQzs7O09BQUE7O2dCQWhCRixTQUFTLFNBQUM7b0JBQ1QsUUFBUSxFQUFFLDJCQUEyQjtvQkFDckMsSUFBSSxFQUFFO3dCQUNKLFFBQVEsRUFBRSxNQUFNO3dCQUNoQixZQUFZLEVBQUUsc0JBQXNCO3FCQUNyQztvQkFDRCxNQUFNLEVBQUUsQ0FBQyxNQUFNLENBQUM7b0JBQ2hCLFNBQVMsRUFBRSxDQUFDLEVBQUMsT0FBTyxFQUFFLFVBQVUsRUFBRSxXQUFXLEVBQUUsMEJBQTBCLEVBQUMsQ0FBQztpQkFDNUU7Ozs7Z0JBbERRLFVBQVU7O0lBNERuQixpQ0FBQztDQUFBLEFBbEJELENBU2dELGtCQUFrQixHQVNqRTtTQVRZLDBCQUEwQiIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IENka1N0ZXBwZXIsIENka1N0ZXBwZXJOZXh0LCBDZGtTdGVwcGVyUHJldmlvdXMgfSBmcm9tICdAYW5ndWxhci9jZGsvc3RlcHBlcic7XG5pbXBvcnQgeyBDaGFuZ2VEZXRlY3RvclJlZiwgRGlyZWN0aXZlLCBEb0NoZWNrIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5cbmltcG9ydCB7IE54UHJvZ3Jlc3NTdGVwcGVyRGlyZWN0aXZlIH0gZnJvbSAnLi9wcm9ncmVzcy1zdGVwcGVyLmNvbXBvbmVudCc7XG5cbi8vIHRzbGludDpkaXNhYmxlOnVzZS1pbnB1dC1wcm9wZXJ0eS1kZWNvcmF0b3JcblxuQERpcmVjdGl2ZSh7XG4gIHNlbGVjdG9yOiAnYnV0dG9uW254U3RlcHBlck5leHRdJyxcbiAgaG9zdDoge1xuICAgICdbdHlwZV0nOiAndHlwZScsXG4gICAgJ1tkaXNhYmxlZF0nOiAnZGlzYWJsZWQnXG4gIH0sXG4gIGlucHV0czogWyd0eXBlJ10sXG4gIHByb3ZpZGVyczogW3twcm92aWRlOiBDZGtTdGVwcGVyLCB1c2VFeGlzdGluZzogTnhQcm9ncmVzc1N0ZXBwZXJEaXJlY3RpdmV9XVxufSlcbmV4cG9ydCBjbGFzcyBOeFN0ZXBwZXJOZXh0RGlyZWN0aXZlIGV4dGVuZHMgQ2RrU3RlcHBlck5leHQgaW1wbGVtZW50cyBEb0NoZWNrIHtcblxuICAvKiogQGRvY3MtcHJpdmF0ZSAqL1xuICBkaXNhYmxlZCA9IGZhbHNlO1xuXG4gIGNvbnN0cnVjdG9yKF9zdGVwcGVyOiBDZGtTdGVwcGVyLCBwcml2YXRlIGNoYW5nZURldGVjdG9yUmVmOiBDaGFuZ2VEZXRlY3RvclJlZikge1xuICAgIHN1cGVyKF9zdGVwcGVyKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBJbXBsZW1lbnRlZCB0byBwcmV2ZW50IGNoYW5nZWQgYWZ0ZXIgY2hlY2tlZCBlcnJvciBhZnRlciBzdGVwcGVyIGluaXQuXG4gICAqIFdoZW4gdGhlIHN0ZXBwZXIgaW5pdGlhbGl6ZXMgdGhlIGRpcmVjdGl2ZSBpcyBjaGVja2VkIGZpcnN0IGJlZm9yZVxuICAgKiB0aGUgc3RlcHBlciBjYW4gY2hlY2sgaXRzIGNvbnRlbnQgdGh1cyBpdCBkb2Vzbid0IGtub3cgYWJvdXQgaXQncyBjaGlsZHJlbiB5ZXRcbiAgICogc28gX3N0ZXBwZXIuaGFzTmV4dCByZXR1cm5zIGZhbHNlIGFuZCBkaXNhYmxlcyB0aGUgYnV0dG9ucy4gSW4gdGhlIHNhbWUgQ0QgY3ljbGVcbiAgICogYWZ0ZXIgdGhlIHN0ZXBwZXIgaGFzIGNoZWNrZWQgaXRzIGNvbnRlbnRzIHRoZSBidXR0b24gbmVlZHMgdG8gYmUgZW5hYmxlZCByZXN1bHRpbmdcbiAgICogaW4gdGhlIGVycm9yLlxuICAgKi9cbiAgbmdEb0NoZWNrKCkge1xuICAgIGNvbnN0IHN0ZXBwZXIgPSB0aGlzLl9zdGVwcGVyIGFzIGFueSBhcyBOeFByb2dyZXNzU3RlcHBlckRpcmVjdGl2ZTtcbiAgICBpZiAodGhpcy5kaXNhYmxlZCAhPT0gIXN0ZXBwZXIuaGFzTmV4dCkge1xuICAgICAgdGhpcy5kaXNhYmxlZCA9ICFzdGVwcGVyLmhhc05leHQ7XG4gICAgICB0aGlzLmNoYW5nZURldGVjdG9yUmVmLm1hcmtGb3JDaGVjaygpO1xuICAgIH1cbiAgfVxufVxuXG5ARGlyZWN0aXZlKHtcbiAgc2VsZWN0b3I6ICdidXR0b25bbnhTdGVwcGVyUHJldmlvdXNdJyxcbiAgaG9zdDoge1xuICAgICdbdHlwZV0nOiAndHlwZScsXG4gICAgJ1tkaXNhYmxlZF0nOiAnIXN0ZXBwZXIuaGFzUHJldmlvdXMnXG4gIH0sXG4gIGlucHV0czogWyd0eXBlJ10sXG4gIHByb3ZpZGVyczogW3twcm92aWRlOiBDZGtTdGVwcGVyLCB1c2VFeGlzdGluZzogTnhQcm9ncmVzc1N0ZXBwZXJEaXJlY3RpdmV9XVxufSlcbmV4cG9ydCBjbGFzcyBOeFN0ZXBwZXJQcmV2aW91c0RpcmVjdGl2ZSBleHRlbmRzIENka1N0ZXBwZXJQcmV2aW91cyB7XG4gIGNvbnN0cnVjdG9yKF9zdGVwcGVyOiBDZGtTdGVwcGVyKSB7XG4gICAgc3VwZXIoX3N0ZXBwZXIpO1xuICB9XG5cbiAgZ2V0IHN0ZXBwZXIoKTogTnhQcm9ncmVzc1N0ZXBwZXJEaXJlY3RpdmUge1xuICAgIHJldHVybiB0aGlzLl9zdGVwcGVyIGFzIE54UHJvZ3Jlc3NTdGVwcGVyRGlyZWN0aXZlO1xuICB9XG5cbn1cbiJdfQ==