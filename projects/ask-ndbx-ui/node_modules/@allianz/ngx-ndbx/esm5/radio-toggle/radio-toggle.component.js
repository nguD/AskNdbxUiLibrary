/**
 * @fileoverview added by tsickle
 * Generated from: radio-toggle/radio-toggle.component.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import * as tslib_1 from "tslib";
import { coerceBooleanProperty } from '@angular/cdk/coercion';
import { mapClassNames } from '@allianz/ngx-ndbx/utils';
import { ChangeDetectionStrategy, Component, ContentChildren, ElementRef, Input, QueryList, Renderer2, ViewChild, ChangeDetectorRef, Optional, Self } from '@angular/core';
import { FormGroupDirective, NgControl, NgForm } from '@angular/forms';
import { Subject, merge } from 'rxjs';
import { filter, startWith, takeUntil } from 'rxjs/operators';
import { ErrorStateMatcher } from '@allianz/ngx-ndbx/utils';
import { NxRadioToggleButtonBaseComponent } from './radio-toggle-button-base.component';
/** @type {?} */
var nextId = 0;
/** @type {?} */
var MAPPING = {
    'negative': 'nx-radio-toggle--negative',
    'small': 'nx-radio-toggle--small',
};
var NxRadioToggleComponent = /** @class */ (function () {
    function NxRadioToggleComponent(renderer, _changeDetectorRef, ngControl, _errorStateMatcher, _parentForm, _parentFormGroup) {
        this.renderer = renderer;
        this._changeDetectorRef = _changeDetectorRef;
        this.ngControl = ngControl;
        this._errorStateMatcher = _errorStateMatcher;
        this._parentForm = _parentForm;
        this._parentFormGroup = _parentFormGroup;
        this._toggleId = (nextId++).toString();
        this._destroyed = new Subject();
        this._disabled = false;
        /**
         * \@docs-private
         */
        this.errorState = false;
        // emits to signal children to run change detection
        this._disableChange = new Subject();
        /**
         * \@docs-private
         */
        this.toggleButtons = new QueryList();
        this.onTouchedCallback = (/**
         * @return {?}
         */
        function () { });
        this.onChangeCallback = (/**
         * @param {?} option
         * @return {?}
         */
        function (option) { });
        if (this.ngControl) {
            // Note: we provide the value accessor through here, instead of
            // the `providers` to avoid running into a circular import.
            this.ngControl.valueAccessor = this;
        }
    }
    Object.defineProperty(NxRadioToggleComponent.prototype, "disabled", {
        get: /**
         * @return {?}
         */
        function () {
            return this._disabled;
        },
        /** Sets the component to the disabled state.*/
        set: /**
         * Sets the component to the disabled state.
         * @param {?} value
         * @return {?}
         */
        function (value) {
            /** @type {?} */
            var coerced = coerceBooleanProperty(value);
            if (this._disabled !== coerced) {
                this._disabled = coerced;
                this._disableChange.next();
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NxRadioToggleComponent.prototype, "name", {
        get: /**
         * @return {?}
         */
        function () {
            return this._name;
        },
        /** Sets the name used for accessibility. */
        set: /**
         * Sets the name used for accessibility.
         * @param {?} value
         * @return {?}
         */
        function (value) {
            if (this._name !== value) {
                this._name = value;
                this._changeDetectorRef.markForCheck();
            }
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @return {?}
     */
    NxRadioToggleComponent.prototype.ngAfterViewInit = /**
     * @return {?}
     */
    function () {
        this.subscribeToToggleButtonsChange();
    };
    /**
     * @return {?}
     */
    NxRadioToggleComponent.prototype.ngAfterContentInit = /**
     * @return {?}
     */
    function () {
        var _this = this;
        /** @type {?} */
        var changedOrDestroyed = merge(this.toggleButtons.changes, this._destroyed);
        merge.apply(void 0, tslib_1.__spread(this.toggleButtons.map((/**
         * @param {?} button
         * @return {?}
         */
        function (button) { return button.onChecked; })))).pipe(takeUntil(changedOrDestroyed))
            .subscribe((/**
         * @param {?} change
         * @return {?}
         */
        function (change) {
            _this._selection = change.value;
            _this.onChangeCallback(_this._selection);
        }));
    };
    /**
     * @return {?}
     */
    NxRadioToggleComponent.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        this._destroyed.next();
        this._destroyed.complete();
        this._disableChange.complete();
    };
    /**
     * @return {?}
     */
    NxRadioToggleComponent.prototype.ngDoCheck = /**
     * @return {?}
     */
    function () {
        if (this.ngControl) {
            // We need to re-evaluate this on every change detection cycle, because there are some
            // error triggers that we can't subscribe to (e.g. parent form submissions). This means
            // that whatever logic is in here has to be super lean or we risk destroying the performance.
            this.updateErrorState();
        }
    };
    /** @docs-private */
    /**
     * \@docs-private
     * @return {?}
     */
    NxRadioToggleComponent.prototype.subscribeToToggleButtonsChange = /**
     * \@docs-private
     * @return {?}
     */
    function () {
        var _this = this;
        this.toggleButtons.changes
            .pipe(startWith(this.toggleButtons), filter((/**
         * @param {?} toggles
         * @return {?}
         */
        function (toggles) { return toggles.length > 0; })), takeUntil(this._destroyed)).subscribe((/**
         * @param {?} toggles
         * @return {?}
         */
        function (toggles) {
            toggles.forEach((/**
             * @param {?} toggle
             * @return {?}
             */
            function (toggle) {
                toggle.resetClasses();
                if (toggle.value === _this.selection) {
                    // We need to defer the selection for the edge case that the button with the value of this.selection
                    // didn't exist yet but was added afterwards to prevent changed after checked errors
                    setTimeout((/**
                     * @return {?}
                     */
                    function () { return toggle.select(); }));
                }
            }));
            toggles.first.setFirstButton();
            toggles.last.setLastButton();
        }));
    };
    /**
     * @param {?} onChangeCallback
     * @return {?}
     */
    NxRadioToggleComponent.prototype.registerOnChange = /**
     * @param {?} onChangeCallback
     * @return {?}
     */
    function (onChangeCallback) {
        this.onChangeCallback = onChangeCallback;
    };
    /**
     * @param {?} onTouchedCallback
     * @return {?}
     */
    NxRadioToggleComponent.prototype.registerOnTouched = /**
     * @param {?} onTouchedCallback
     * @return {?}
     */
    function (onTouchedCallback) {
        this.onTouchedCallback = onTouchedCallback;
    };
    /** Preselects the respective options. */
    /**
     * Preselects the respective options.
     * @param {?} value
     * @return {?}
     */
    NxRadioToggleComponent.prototype.writeValue = /**
     * Preselects the respective options.
     * @param {?} value
     * @return {?}
     */
    function (value) {
        var _this = this;
        this._selection = value;
        /** @type {?} */
        var correspondingButton = this.toggleButtons.find((/**
         * @param {?} button
         * @return {?}
         */
        function (button) { return button.value === _this._selection; }));
        if (correspondingButton) {
            ((/** @type {?} */ (correspondingButton))).select();
        }
    };
    /**
     * @param {?} isDisabled
     * @return {?}
     */
    NxRadioToggleComponent.prototype.setDisabledState = /**
     * @param {?} isDisabled
     * @return {?}
     */
    function (isDisabled) {
        this.disabled = isDisabled;
    };
    Object.defineProperty(NxRadioToggleComponent.prototype, "id", {
        /** @docs-private */
        get: /**
         * \@docs-private
         * @return {?}
         */
        function () {
            return "nx-radio-toggle-" + this._toggleId;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NxRadioToggleComponent.prototype, "style", {
        /** Sets the modifiers for the component. */
        set: /**
         * Sets the modifiers for the component.
         * @param {?} value
         * @return {?}
         */
        function (value) {
            var _this = this;
            /** @type {?} */
            var modifierClasses = mapClassNames(value, [], MAPPING);
            modifierClasses.split(' ')
                .forEach((/**
             * @param {?} className
             * @return {?}
             */
            function (className) { return _this.renderer.addClass(_this.toggleContainer.nativeElement, className); }));
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NxRadioToggleComponent.prototype, "selection", {
        get: /**
         * @return {?}
         */
        function () {
            return this._selection;
        },
        /** @docs-private */
        set: /**
         * \@docs-private
         * @param {?} selection
         * @return {?}
         */
        function (selection) {
            this._selection = selection;
            this.onChangeCallback(selection);
        },
        enumerable: true,
        configurable: true
    });
    /** @docs-private */
    /**
     * \@docs-private
     * @param {?} value
     * @return {?}
     */
    NxRadioToggleComponent.prototype.change = /**
     * \@docs-private
     * @param {?} value
     * @return {?}
     */
    function (value) {
        this.onChangeCallback(value);
        if (this.onTouchedCallback) {
            this.onTouchedCallback();
        }
    };
    /** @docs-private */
    /**
     * \@docs-private
     * @return {?}
     */
    NxRadioToggleComponent.prototype.updateErrorState = /**
     * \@docs-private
     * @return {?}
     */
    function () {
        /** @type {?} */
        var oldState = this.errorState;
        /** @type {?} */
        var parent = this._parentFormGroup || this._parentForm;
        /** @type {?} */
        var control = this.ngControl ? (/** @type {?} */ (this.ngControl.control)) : null;
        /** @type {?} */
        var newState = this._errorStateMatcher.isErrorState(control, parent);
        if (newState !== oldState) {
            this.errorState = newState;
        }
    };
    NxRadioToggleComponent.decorators = [
        { type: Component, args: [{
                    selector: 'nx-radio-toggle',
                    template: "<div #toggleContainer class=\"nx-radio-toggle\" role=\"radiogroup\" [attr.aria-label]=\"name\">\n   <ng-content></ng-content>\n</div>\n",
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    styles: [":host{display:block}.nx-radio-toggle{display:flex;height:100%}@media (max-width:703px){.nx-radio-toggle{flex-direction:column;text-align:center;width:100%;justify-content:center;align-items:center}}"]
                }] }
    ];
    /** @nocollapse */
    NxRadioToggleComponent.ctorParameters = function () { return [
        { type: Renderer2 },
        { type: ChangeDetectorRef },
        { type: NgControl, decorators: [{ type: Optional }, { type: Self }] },
        { type: ErrorStateMatcher },
        { type: NgForm, decorators: [{ type: Optional }] },
        { type: FormGroupDirective, decorators: [{ type: Optional }] }
    ]; };
    NxRadioToggleComponent.propDecorators = {
        disabled: [{ type: Input, args: ['nxDisabled',] }],
        toggleContainer: [{ type: ViewChild, args: ['toggleContainer', { static: true },] }],
        name: [{ type: Input, args: ['nxName',] }],
        toggleButtons: [{ type: ContentChildren, args: [NxRadioToggleButtonBaseComponent,] }],
        writeValue: [{ type: Input, args: ['nxSelection',] }],
        style: [{ type: Input, args: ['nxStyle',] }]
    };
    return NxRadioToggleComponent;
}());
export { NxRadioToggleComponent };
if (false) {
    /**
     * @type {?}
     * @private
     */
    NxRadioToggleComponent.prototype._toggleId;
    /**
     * @type {?}
     * @private
     */
    NxRadioToggleComponent.prototype._selection;
    /**
     * @type {?}
     * @private
     */
    NxRadioToggleComponent.prototype._destroyed;
    /**
     * @type {?}
     * @private
     */
    NxRadioToggleComponent.prototype._disabled;
    /**
     * \@docs-private
     * @type {?}
     */
    NxRadioToggleComponent.prototype.errorState;
    /** @type {?} */
    NxRadioToggleComponent.prototype._disableChange;
    /**
     * @type {?}
     * @private
     */
    NxRadioToggleComponent.prototype.toggleContainer;
    /**
     * @type {?}
     * @private
     */
    NxRadioToggleComponent.prototype._name;
    /**
     * \@docs-private
     * @type {?}
     */
    NxRadioToggleComponent.prototype.toggleButtons;
    /**
     * @type {?}
     * @private
     */
    NxRadioToggleComponent.prototype.onTouchedCallback;
    /**
     * @type {?}
     * @private
     */
    NxRadioToggleComponent.prototype.onChangeCallback;
    /**
     * @type {?}
     * @private
     */
    NxRadioToggleComponent.prototype.renderer;
    /**
     * @type {?}
     * @private
     */
    NxRadioToggleComponent.prototype._changeDetectorRef;
    /**
     * \@docs-private
     * @type {?}
     */
    NxRadioToggleComponent.prototype.ngControl;
    /**
     * @type {?}
     * @private
     */
    NxRadioToggleComponent.prototype._errorStateMatcher;
    /**
     * @type {?}
     * @private
     */
    NxRadioToggleComponent.prototype._parentForm;
    /**
     * @type {?}
     * @private
     */
    NxRadioToggleComponent.prototype._parentFormGroup;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicmFkaW8tdG9nZ2xlLmNvbXBvbmVudC5qcyIsInNvdXJjZVJvb3QiOiJuZzovL0BhbGxpYW56L25neC1uZGJ4LyIsInNvdXJjZXMiOlsicmFkaW8tdG9nZ2xlL3JhZGlvLXRvZ2dsZS5jb21wb25lbnQudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQUEsT0FBTyxFQUFFLHFCQUFxQixFQUFFLE1BQU0sdUJBQXVCLENBQUM7QUFDOUQsT0FBTyxFQUFFLGFBQWEsRUFBRSxNQUFNLHlCQUF5QixDQUFDO0FBQ3hELE9BQU8sRUFHTCx1QkFBdUIsRUFDdkIsU0FBUyxFQUNULGVBQWUsRUFDZixVQUFVLEVBQ1YsS0FBSyxFQUVMLFNBQVMsRUFDVCxTQUFTLEVBQ1QsU0FBUyxFQUNULGlCQUFpQixFQUNqQixRQUFRLEVBQ1IsSUFBSSxFQUVMLE1BQU0sZUFBZSxDQUFDO0FBQ3ZCLE9BQU8sRUFBcUMsa0JBQWtCLEVBQUUsU0FBUyxFQUFFLE1BQU0sRUFBRSxNQUFNLGdCQUFnQixDQUFDO0FBQzFHLE9BQU8sRUFBRSxPQUFPLEVBQUUsS0FBSyxFQUFFLE1BQU0sTUFBTSxDQUFDO0FBQ3RDLE9BQU8sRUFBRSxNQUFNLEVBQUUsU0FBUyxFQUFFLFNBQVMsRUFBRSxNQUFNLGdCQUFnQixDQUFDO0FBQzlELE9BQU8sRUFBRSxpQkFBaUIsRUFBRSxNQUFNLHlCQUF5QixDQUFDO0FBQzVELE9BQU8sRUFBRSxnQ0FBZ0MsRUFBRSxNQUFNLHNDQUFzQyxDQUFDOztJQUdwRixNQUFNLEdBQUcsQ0FBQzs7SUFFUixPQUFPLEdBQUc7SUFDZCxVQUFVLEVBQUUsMkJBQTJCO0lBQ3ZDLE9BQU8sRUFBRSx3QkFBd0I7Q0FDbEM7QUFFRDtJQTRERSxnQ0FBb0IsUUFBbUIsRUFDbkIsa0JBQXFDLEVBRWxCLFNBQW9CLEVBQ3ZDLGtCQUFxQyxFQUN6QixXQUFtQixFQUNuQixnQkFBb0M7UUFOaEQsYUFBUSxHQUFSLFFBQVEsQ0FBVztRQUNuQix1QkFBa0IsR0FBbEIsa0JBQWtC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RSxNQUFNLEVBQUUsSUFBSSxFQUFFO3VCQU03QyxLQUFLLFNBQUMsUUFBUTtnQ0FZZCxlQUFlLFNBQUMsZ0NBQWdDOzZCQWlGaEQsS0FBSyxTQUFDLGFBQWE7d0JBb0JuQixLQUFLLFNBQUMsU0FBUzs7SUFvQ2xCLDZCQUFDO0NBQUEsQUE5TEQsSUE4TEM7U0F4TFksc0JBQXNCOzs7Ozs7SUFHakMsMkNBQWtEOzs7OztJQUVsRCw0Q0FBd0I7Ozs7O0lBRXhCLDRDQUFrRDs7Ozs7SUFFbEQsMkNBQW1DOzs7OztJQUVuQyw0Q0FBNEI7O0lBRTVCLGdEQUFxQzs7Ozs7SUFnQnJDLGlEQUNvQzs7Ozs7SUFFcEMsdUNBQXNCOzs7OztJQWV0QiwrQ0FDNkU7Ozs7O0lBRTdFLG1EQUFzQzs7Ozs7SUFFdEMsa0RBQWdEOzs7OztJQUVwQywwQ0FBMkI7Ozs7O0lBQzNCLG9EQUE2Qzs7Ozs7SUFFN0MsMkNBQStDOzs7OztJQUMvQyxvREFBNkM7Ozs7O0lBQzdDLDZDQUF1Qzs7Ozs7SUFDdkMsa0RBQXdEIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgY29lcmNlQm9vbGVhblByb3BlcnR5IH0gZnJvbSAnQGFuZ3VsYXIvY2RrL2NvZXJjaW9uJztcbmltcG9ydCB7IG1hcENsYXNzTmFtZXMgfSBmcm9tICdAYWxsaWFuei9uZ3gtbmRieC91dGlscyc7XG5pbXBvcnQge1xuICBBZnRlckNvbnRlbnRJbml0LFxuICBBZnRlclZpZXdJbml0LFxuICBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneSxcbiAgQ29tcG9uZW50LFxuICBDb250ZW50Q2hpbGRyZW4sXG4gIEVsZW1lbnRSZWYsXG4gIElucHV0LFxuICBPbkRlc3Ryb3ksXG4gIFF1ZXJ5TGlzdCxcbiAgUmVuZGVyZXIyLFxuICBWaWV3Q2hpbGQsXG4gIENoYW5nZURldGVjdG9yUmVmLFxuICBPcHRpb25hbCxcbiAgU2VsZixcbiAgRG9DaGVja1xufSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IENvbnRyb2xWYWx1ZUFjY2Vzc29yLCBGb3JtQ29udHJvbCwgRm9ybUdyb3VwRGlyZWN0aXZlLCBOZ0NvbnRyb2wsIE5nRm9ybSB9IGZyb20gJ0Bhbmd1bGFyL2Zvcm1zJztcbmltcG9ydCB7IFN1YmplY3QsIG1lcmdlIH0gZnJvbSAncnhqcyc7XG5pbXBvcnQgeyBmaWx0ZXIsIHN0YXJ0V2l0aCwgdGFrZVVudGlsIH0gZnJvbSAncnhqcy9vcGVyYXRvcnMnO1xuaW1wb3J0IHsgRXJyb3JTdGF0ZU1hdGNoZXIgfSBmcm9tICdAYWxsaWFuei9uZ3gtbmRieC91dGlscyc7XG5pbXBvcnQgeyBOeFJhZGlvVG9nZ2xlQnV0dG9uQmFzZUNvbXBvbmVudCB9IGZyb20gJy4vcmFkaW8tdG9nZ2xlLWJ1dHRvbi1iYXNlLmNvbXBvbmVudCc7XG5pbXBvcnQgeyBOeFJhZGlvVG9nZ2xlQnV0dG9uQ2hhbmdlLCBOeFJhZGlvVG9nZ2xlQnV0dG9uQ29tcG9uZW50IH0gZnJvbSAnLi9yYWRpby10b2dnbGUtYnV0dG9uLmNvbXBvbmVudCc7XG5cbmxldCBuZXh0SWQgPSAwO1xuXG5jb25zdCBNQVBQSU5HID0ge1xuICAnbmVnYXRpdmUnOiAnbngtcmFkaW8tdG9nZ2xlLS1uZWdhdGl2ZScsXG4gICdzbWFsbCc6ICdueC1yYWRpby10b2dnbGUtLXNtYWxsJyxcbn07XG5cbkBDb21wb25lbnQoe1xuICBzZWxlY3RvcjogJ254LXJhZGlvLXRvZ2dsZScsXG4gIHRlbXBsYXRlVXJsOiAncmFkaW8tdG9nZ2xlLmNvbXBvbmVudC5odG1sJyxcbiAgY2hhbmdlRGV0ZWN0aW9uOiBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5PblB1c2gsXG4gIHN0eWxlVXJsczogWydyYWRpby10b2dnbGUuY29tcG9uZW50LnNjc3MnXVxufSlcbmV4cG9ydCBjbGFzcyBOeFJhZGlvVG9nZ2xlQ29tcG9uZW50IGltcGxlbWVudHMgQ29udHJvbFZhbHVlQWNjZXNzb3IsIEFmdGVyVmlld0luaXQsIE9uRGVzdHJveSxcbiAgQWZ0ZXJDb250ZW50SW5pdCwgRG9DaGVjayAge1xuXG4gIHByaXZhdGUgX3RvZ2dsZUlkOiBzdHJpbmcgPSAobmV4dElkKyspLnRvU3RyaW5nKCk7XG5cbiAgcHJpdmF0ZSBfc2VsZWN0aW9uOiBhbnk7XG5cbiAgcHJpdmF0ZSBfZGVzdHJveWVkOiBTdWJqZWN0PHZvaWQ+ID0gbmV3IFN1YmplY3QoKTtcblxuICBwcml2YXRlIF9kaXNhYmxlZDogYm9vbGVhbiA9IGZhbHNlO1xuICAvKiogQGRvY3MtcHJpdmF0ZSAqL1xuICBlcnJvclN0YXRlOiBib29sZWFuID0gZmFsc2U7XG4gIC8vIGVtaXRzIHRvIHNpZ25hbCBjaGlsZHJlbiB0byBydW4gY2hhbmdlIGRldGVjdGlvblxuICBfZGlzYWJsZUNoYW5nZSA9IG5ldyBTdWJqZWN0PHZvaWQ+KCk7XG5cbiAgLyoqIFNldHMgdGhlIGNvbXBvbmVudCB0byB0aGUgZGlzYWJsZWQgc3RhdGUuKi9cbiAgQElucHV0KCdueERpc2FibGVkJylcbiAgc2V0IGRpc2FibGVkKHZhbHVlOiBib29sZWFuKSB7XG4gICAgY29uc3QgY29lcmNlZCA9IGNvZXJjZUJvb2xlYW5Qcm9wZXJ0eSh2YWx1ZSk7XG4gICAgaWYgKHRoaXMuX2Rpc2FibGVkICE9PSBjb2VyY2VkKSB7XG4gICAgICB0aGlzLl9kaXNhYmxlZCA9IGNvZXJjZWQ7XG4gICAgICB0aGlzLl9kaXNhYmxlQ2hhbmdlLm5leHQoKTtcbiAgICB9XG4gIH1cblxuICBnZXQgZGlzYWJsZWQoKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRoaXMuX2Rpc2FibGVkO1xuICB9XG5cbiAgQFZpZXdDaGlsZCgndG9nZ2xlQ29udGFpbmVyJywgeyBzdGF0aWM6IHRydWUgfSlcbiAgcHJpdmF0ZSB0b2dnbGVDb250YWluZXI6IEVsZW1lbnRSZWY7XG5cbiAgcHJpdmF0ZSBfbmFtZTogc3RyaW5nO1xuXG4gIC8qKiBTZXRzIHRoZSBuYW1lIHVzZWQgZm9yIGFjY2Vzc2liaWxpdHkuICovXG4gIEBJbnB1dCgnbnhOYW1lJylcbiAgc2V0IG5hbWUodmFsdWU6IHN0cmluZykge1xuICAgIGlmICh0aGlzLl9uYW1lICE9PSB2YWx1ZSkge1xuICAgICAgdGhpcy5fbmFtZSA9IHZhbHVlO1xuICAgICAgdGhpcy5fY2hhbmdlRGV0ZWN0b3JSZWYubWFya0ZvckNoZWNrKCk7XG4gICAgfVxuICB9XG4gIGdldCBuYW1lKCk6IHN0cmluZyB7XG4gICAgcmV0dXJuIHRoaXMuX25hbWU7XG4gIH1cblxuICAvKiogQGRvY3MtcHJpdmF0ZSAqL1xuICBAQ29udGVudENoaWxkcmVuKE54UmFkaW9Ub2dnbGVCdXR0b25CYXNlQ29tcG9uZW50KVxuICB0b2dnbGVCdXR0b25zOiBRdWVyeUxpc3Q8TnhSYWRpb1RvZ2dsZUJ1dHRvbkJhc2VDb21wb25lbnQ+ID0gbmV3IFF1ZXJ5TGlzdCgpO1xuXG4gIHByaXZhdGUgb25Ub3VjaGVkQ2FsbGJhY2sgPSAoKSA9PiB7IH07XG5cbiAgcHJpdmF0ZSBvbkNoYW5nZUNhbGxiYWNrID0gKG9wdGlvbjogYW55KSA9PiB7IH07XG5cbiAgY29uc3RydWN0b3IocHJpdmF0ZSByZW5kZXJlcjogUmVuZGVyZXIyLFxuICAgICAgICAgICAgICBwcml2YXRlIF9jaGFuZ2VEZXRlY3RvclJlZjogQ2hhbmdlRGV0ZWN0b3JSZWYsXG4gICAgICAgICAgICAgIC8qKiBAZG9jcy1wcml2YXRlICovXG4gICAgICAgICAgICAgIEBPcHRpb25hbCgpIEBTZWxmKCkgcHVibGljIG5nQ29udHJvbDogTmdDb250cm9sLFxuICAgICAgICAgICAgICBwcml2YXRlIF9lcnJvclN0YXRlTWF0Y2hlcjogRXJyb3JTdGF0ZU1hdGNoZXIsXG4gICAgICAgICAgICAgIEBPcHRpb25hbCgpIHByaXZhdGUgX3BhcmVudEZvcm06IE5nRm9ybSxcbiAgICAgICAgICAgICAgQE9wdGlvbmFsKCkgcHJpdmF0ZSBfcGFyZW50Rm9ybUdyb3VwOiBGb3JtR3JvdXBEaXJlY3RpdmUpIHtcbiAgICBpZiAodGhpcy5uZ0NvbnRyb2wpIHtcbiAgICAgIC8vIE5vdGU6IHdlIHByb3ZpZGUgdGhlIHZhbHVlIGFjY2Vzc29yIHRocm91Z2ggaGVyZSwgaW5zdGVhZCBvZlxuICAgICAgLy8gdGhlIGBwcm92aWRlcnNgIHRvIGF2b2lkIHJ1bm5pbmcgaW50byBhIGNpcmN1bGFyIGltcG9ydC5cbiAgICAgIHRoaXMubmdDb250cm9sLnZhbHVlQWNjZXNzb3IgPSB0aGlzO1xuICAgIH1cbiAgfVxuXG4gIG5nQWZ0ZXJWaWV3SW5pdCgpIHtcbiAgICB0aGlzLnN1YnNjcmliZVRvVG9nZ2xlQnV0dG9uc0NoYW5nZSgpO1xuICB9XG5cbiAgbmdBZnRlckNvbnRlbnRJbml0KCkge1xuICAgIGNvbnN0IGNoYW5nZWRPckRlc3Ryb3llZCA9IG1lcmdlKHRoaXMudG9nZ2xlQnV0dG9ucy5jaGFuZ2VzLCB0aGlzLl9kZXN0cm95ZWQpO1xuXG4gICAgbWVyZ2UoLi4udGhpcy50b2dnbGVCdXR0b25zLm1hcCgoYnV0dG9uOiBhbnkpID0+IGJ1dHRvbi5vbkNoZWNrZWQpKVxuICAgICAgLnBpcGUodGFrZVVudGlsKGNoYW5nZWRPckRlc3Ryb3llZCkpXG4gICAgICAuc3Vic2NyaWJlKChjaGFuZ2U6IE54UmFkaW9Ub2dnbGVCdXR0b25DaGFuZ2UpID0+IHtcbiAgICAgICAgdGhpcy5fc2VsZWN0aW9uID0gY2hhbmdlLnZhbHVlO1xuICAgICAgICB0aGlzLm9uQ2hhbmdlQ2FsbGJhY2sodGhpcy5fc2VsZWN0aW9uKTtcbiAgICAgIH0pO1xuICB9XG5cbiAgbmdPbkRlc3Ryb3koKSB7XG4gICAgdGhpcy5fZGVzdHJveWVkLm5leHQoKTtcbiAgICB0aGlzLl9kZXN0cm95ZWQuY29tcGxldGUoKTtcbiAgICB0aGlzLl9kaXNhYmxlQ2hhbmdlLmNvbXBsZXRlKCk7XG4gIH1cblxuICBuZ0RvQ2hlY2soKSB7XG4gICAgaWYgKHRoaXMubmdDb250cm9sKSB7XG4gICAgICAvLyBXZSBuZWVkIHRvIHJlLWV2YWx1YXRlIHRoaXMgb24gZXZlcnkgY2hhbmdlIGRldGVjdGlvbiBjeWNsZSwgYmVjYXVzZSB0aGVyZSBhcmUgc29tZVxuICAgICAgLy8gZXJyb3IgdHJpZ2dlcnMgdGhhdCB3ZSBjYW4ndCBzdWJzY3JpYmUgdG8gKGUuZy4gcGFyZW50IGZvcm0gc3VibWlzc2lvbnMpLiBUaGlzIG1lYW5zXG4gICAgICAvLyB0aGF0IHdoYXRldmVyIGxvZ2ljIGlzIGluIGhlcmUgaGFzIHRvIGJlIHN1cGVyIGxlYW4gb3Igd2UgcmlzayBkZXN0cm95aW5nIHRoZSBwZXJmb3JtYW5jZS5cbiAgICAgIHRoaXMudXBkYXRlRXJyb3JTdGF0ZSgpO1xuICAgIH1cbiAgfVxuXG4gIC8qKiBAZG9jcy1wcml2YXRlICovXG4gIHN1YnNjcmliZVRvVG9nZ2xlQnV0dG9uc0NoYW5nZSgpOiB2b2lkIHtcbiAgICB0aGlzLnRvZ2dsZUJ1dHRvbnMuY2hhbmdlc1xuICAgICAgLnBpcGUoXG4gICAgICAgIHN0YXJ0V2l0aCh0aGlzLnRvZ2dsZUJ1dHRvbnMpLFxuICAgICAgICBmaWx0ZXIodG9nZ2xlcyA9PiB0b2dnbGVzLmxlbmd0aCA+IDApLFxuICAgICAgICB0YWtlVW50aWwodGhpcy5fZGVzdHJveWVkKVxuICAgICAgKS5zdWJzY3JpYmUoKHRvZ2dsZXMpID0+IHtcbiAgICAgICAgdG9nZ2xlcy5mb3JFYWNoKHRvZ2dsZSA9PiB7XG4gICAgICAgICAgdG9nZ2xlLnJlc2V0Q2xhc3NlcygpO1xuICAgICAgICAgIGlmICh0b2dnbGUudmFsdWUgPT09IHRoaXMuc2VsZWN0aW9uKSB7XG4gICAgICAgICAgICAvLyBXZSBuZWVkIHRvIGRlZmVyIHRoZSBzZWxlY3Rpb24gZm9yIHRoZSBlZGdlIGNhc2UgdGhhdCB0aGUgYnV0dG9uIHdpdGggdGhlIHZhbHVlIG9mIHRoaXMuc2VsZWN0aW9uXG4gICAgICAgICAgICAvLyBkaWRuJ3QgZXhpc3QgeWV0IGJ1dCB3YXMgYWRkZWQgYWZ0ZXJ3YXJkcyB0byBwcmV2ZW50IGNoYW5nZWQgYWZ0ZXIgY2hlY2tlZCBlcnJvcnNcbiAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4gdG9nZ2xlLnNlbGVjdCgpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB0b2dnbGVzLmZpcnN0LnNldEZpcnN0QnV0dG9uKCk7XG4gICAgICAgIHRvZ2dsZXMubGFzdC5zZXRMYXN0QnV0dG9uKCk7XG4gICAgICB9KTtcbiAgfVxuXG4gIHJlZ2lzdGVyT25DaGFuZ2Uob25DaGFuZ2VDYWxsYmFjazogYW55KTogdm9pZCB7XG4gICAgdGhpcy5vbkNoYW5nZUNhbGxiYWNrID0gb25DaGFuZ2VDYWxsYmFjaztcbiAgfVxuXG4gIHJlZ2lzdGVyT25Ub3VjaGVkKG9uVG91Y2hlZENhbGxiYWNrOiBhbnkpOiB2b2lkIHtcbiAgICB0aGlzLm9uVG91Y2hlZENhbGxiYWNrID0gb25Ub3VjaGVkQ2FsbGJhY2s7XG4gIH1cblxuICAvKiogUHJlc2VsZWN0cyB0aGUgcmVzcGVjdGl2ZSBvcHRpb25zLiAqL1xuICBASW5wdXQoJ254U2VsZWN0aW9uJylcbiAgd3JpdGVWYWx1ZSh2YWx1ZTogc3RyaW5nKTogdm9pZCB7XG4gICAgdGhpcy5fc2VsZWN0aW9uID0gdmFsdWU7XG4gICAgY29uc3QgY29ycmVzcG9uZGluZ0J1dHRvbiA9XG4gICAgICB0aGlzLnRvZ2dsZUJ1dHRvbnMuZmluZCgoYnV0dG9uOiBOeFJhZGlvVG9nZ2xlQnV0dG9uQ29tcG9uZW50KSA9PiBidXR0b24udmFsdWUgPT09IHRoaXMuX3NlbGVjdGlvbik7XG4gICAgaWYgKGNvcnJlc3BvbmRpbmdCdXR0b24pIHtcbiAgICAgIChjb3JyZXNwb25kaW5nQnV0dG9uIGFzIE54UmFkaW9Ub2dnbGVCdXR0b25Db21wb25lbnQpLnNlbGVjdCgpO1xuICAgIH1cbiAgfVxuXG4gIHNldERpc2FibGVkU3RhdGUoaXNEaXNhYmxlZDogYm9vbGVhbik6IHZvaWQge1xuICAgIHRoaXMuZGlzYWJsZWQgPSBpc0Rpc2FibGVkO1xuICB9XG5cbiAgLyoqIEBkb2NzLXByaXZhdGUgKi9cbiAgZ2V0IGlkKCk6IHN0cmluZyB7XG4gICAgcmV0dXJuIGBueC1yYWRpby10b2dnbGUtJHt0aGlzLl90b2dnbGVJZH1gO1xuICB9XG5cbiAgLyoqIFNldHMgdGhlIG1vZGlmaWVycyBmb3IgdGhlIGNvbXBvbmVudC4gKi9cbiAgQElucHV0KCdueFN0eWxlJylcbiAgc2V0IHN0eWxlKHZhbHVlOiBzdHJpbmcpIHtcbiAgICBjb25zdCBtb2RpZmllckNsYXNzZXMgPSBtYXBDbGFzc05hbWVzKHZhbHVlLCBbXSwgTUFQUElORyk7XG4gICAgbW9kaWZpZXJDbGFzc2VzLnNwbGl0KCcgJylcbiAgICAgIC5mb3JFYWNoKGNsYXNzTmFtZSA9PiB0aGlzLnJlbmRlcmVyLmFkZENsYXNzKHRoaXMudG9nZ2xlQ29udGFpbmVyLm5hdGl2ZUVsZW1lbnQsIGNsYXNzTmFtZSkpO1xuICB9XG5cbiAgLyoqIEBkb2NzLXByaXZhdGUgKi9cbiAgc2V0IHNlbGVjdGlvbihzZWxlY3Rpb246IGFueSkge1xuICAgIHRoaXMuX3NlbGVjdGlvbiA9IHNlbGVjdGlvbjtcbiAgICB0aGlzLm9uQ2hhbmdlQ2FsbGJhY2soc2VsZWN0aW9uKTtcbiAgfVxuXG4gIGdldCBzZWxlY3Rpb24oKTogYW55IHtcbiAgICByZXR1cm4gdGhpcy5fc2VsZWN0aW9uO1xuICB9XG5cbiAgLyoqIEBkb2NzLXByaXZhdGUgKi9cbiAgY2hhbmdlKHZhbHVlKSB7XG4gICAgdGhpcy5vbkNoYW5nZUNhbGxiYWNrKHZhbHVlKTtcbiAgICBpZiAodGhpcy5vblRvdWNoZWRDYWxsYmFjaykge1xuICAgICAgdGhpcy5vblRvdWNoZWRDYWxsYmFjaygpO1xuICAgIH1cbiAgfVxuXG4gIC8qKiBAZG9jcy1wcml2YXRlICovXG4gIHVwZGF0ZUVycm9yU3RhdGUoKSB7XG4gICAgY29uc3Qgb2xkU3RhdGUgPSB0aGlzLmVycm9yU3RhdGU7XG4gICAgY29uc3QgcGFyZW50ID0gdGhpcy5fcGFyZW50Rm9ybUdyb3VwIHx8IHRoaXMuX3BhcmVudEZvcm07XG4gICAgY29uc3QgY29udHJvbCA9IHRoaXMubmdDb250cm9sID8gdGhpcy5uZ0NvbnRyb2wuY29udHJvbCBhcyBGb3JtQ29udHJvbCA6IG51bGw7XG4gICAgY29uc3QgbmV3U3RhdGUgPSB0aGlzLl9lcnJvclN0YXRlTWF0Y2hlci5pc0Vycm9yU3RhdGUoY29udHJvbCwgcGFyZW50KTtcblxuICAgIGlmIChuZXdTdGF0ZSAhPT0gb2xkU3RhdGUpIHtcbiAgICAgIHRoaXMuZXJyb3JTdGF0ZSA9IG5ld1N0YXRlO1xuICAgIH1cbiAgfVxufVxuIl19