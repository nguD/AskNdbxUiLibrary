/**
 * @fileoverview added by tsickle
 * Generated from: datefield.directive.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import { NxFormfieldComponent } from '@allianz/ngx-ndbx/formfield';
import { NX_INPUT_VALUE_ACCESSOR } from '@allianz/ngx-ndbx/input';
import { coerceBooleanProperty } from '@angular/cdk/coercion';
import { DOWN_ARROW } from '@angular/cdk/keycodes';
import { Directive, ElementRef, EventEmitter, forwardRef, Inject, Input, Optional, Output, } from '@angular/core';
import { NG_VALIDATORS, NG_VALUE_ACCESSOR, Validators, } from '@angular/forms';
import { Subscription } from 'rxjs';
import { NX_DATE_FORMATS, NxDateAdapter } from './adapter/index';
import { createMissingDateImplError } from './datefield-errors';
import { NxDatepickerComponent } from './datepicker/datepicker.component';
import { NxDateValidators } from './date-validators';
// tslint:disable:member-ordering
/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 * @type {?}
 */
export var NX_DATEFIELD_VALUE_ACCESSOR = {
    provide: NG_VALUE_ACCESSOR,
    useExisting: forwardRef((/**
     * @return {?}
     */
    function () { return NxDatefieldDirective; })),
    multi: true
};
/** @type {?} */
export var NX_DATEFIELD_VALIDATORS = {
    provide: NG_VALIDATORS,
    useExisting: forwardRef((/**
     * @return {?}
     */
    function () { return NxDatefieldDirective; })),
    multi: true
};
/**
 * An event used for datepicker input and change events. We don't always have access to a native
 * input or change event because the event may have been triggered by the user clicking on the
 * calendar popup. For consistency, we always use NxDatepickerInputEvent instead.
 * @template D
 */
var /**
 * An event used for datepicker input and change events. We don't always have access to a native
 * input or change event because the event may have been triggered by the user clicking on the
 * calendar popup. For consistency, we always use NxDatepickerInputEvent instead.
 * @template D
 */
NxDatepickerInputEvent = /** @class */ (function () {
    function NxDatepickerInputEvent(target, targetElement) {
        this.target = target;
        this.targetElement = targetElement;
        this.value = this.target.value;
    }
    return NxDatepickerInputEvent;
}());
/**
 * An event used for datepicker input and change events. We don't always have access to a native
 * input or change event because the event may have been triggered by the user clicking on the
 * calendar popup. For consistency, we always use NxDatepickerInputEvent instead.
 * @template D
 */
export { NxDatepickerInputEvent };
if (false) {
    /**
     * The new value for the target datepicker input.
     * @type {?}
     */
    NxDatepickerInputEvent.prototype.value;
    /**
     * Reference to the datepicker input component that emitted the event.
     * @type {?}
     */
    NxDatepickerInputEvent.prototype.target;
    /**
     * Reference to the native input element associated with the datepicker input.
     * @type {?}
     */
    NxDatepickerInputEvent.prototype.targetElement;
}
/**
 * Directive used to provide date processing functionality to an input.
 * @template D
 */
var NxDatefieldDirective = /** @class */ (function () {
    function NxDatefieldDirective(_elementRef, _dateAdapter, _dateFormats, _formField) {
        var _this = this;
        this._elementRef = _elementRef;
        this._dateAdapter = _dateAdapter;
        this._dateFormats = _dateFormats;
        this._formField = _formField;
        /**
         * \@docs-private
         */
        this.currentFormattedDate = null;
        this._strict = true;
        /**
         * Emits when a `change` event is fired on this `<input>`.
         */
        this.dateChange = new EventEmitter();
        /**
         * Emits when an `input` event is fired on this `<input>`.
         */
        this.dateInput = new EventEmitter();
        /**
         * Emits when the value changes (either due to user input or programmatic change).
         */
        this._valueChange = new EventEmitter();
        /**
         * Emits when the disabled state has changed
         */
        this._disabledChange = new EventEmitter();
        this._onTouched = (/**
         * @return {?}
         */
        function () { });
        this._cvaOnChange = (/**
         * @return {?}
         */
        function () { });
        this._validatorOnChange = (/**
         * @return {?}
         */
        function () { });
        this._datepickerSubscription = Subscription.EMPTY;
        this._localeSubscription = Subscription.EMPTY;
        if (!this._dateAdapter) {
            throw createMissingDateImplError('DateAdapter');
        }
        if (!this._dateFormats) {
            throw createMissingDateImplError('NX_DATE_FORMATS');
        }
        // Update the displayed date when the locale changes.
        this._localeSubscription = _dateAdapter.localeChanges.subscribe((/**
         * @return {?}
         */
        function () {
            _this.value = _this.value;
        }));
    }
    Object.defineProperty(NxDatefieldDirective.prototype, "datepicker", {
        /** The datepicker that this input is associated with. */
        set: /**
         * The datepicker that this input is associated with.
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this.registerDatepicker(value);
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @private
     * @param {?} value
     * @return {?}
     */
    NxDatefieldDirective.prototype.registerDatepicker = /**
     * @private
     * @param {?} value
     * @return {?}
     */
    function (value) {
        if (value) {
            this._datepicker = value;
            this._datepicker.registerInput(this);
        }
    };
    Object.defineProperty(NxDatefieldDirective.prototype, "datefieldFilter", {
        /** Function that can be used to filter out dates within the datepicker and invalidate values in the datefield. */
        set: /**
         * Function that can be used to filter out dates within the datepicker and invalidate values in the datefield.
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this._dateFilter = value;
            this._validatorOnChange();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NxDatefieldDirective.prototype, "value", {
        /** Provide or read the current date. It's type <D> depends on the chosen date implementation */
        get: /**
         * Provide or read the current date. It's type <D> depends on the chosen date implementation
         * @return {?}
         */
        function () { return this._value; },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            value = this._dateAdapter.deserialize(value);
            value = this._getValidDateOrNull(value);
            /** @type {?} */
            var oldDate = this.value;
            this._value = value;
            this._formatValue(this.value);
            if (!this._dateAdapter.sameDate(oldDate, value)) {
                this._valueChange.emit(value);
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NxDatefieldDirective.prototype, "min", {
        /** Sets the minimum valid date. */
        get: /**
         * Sets the minimum valid date.
         * @return {?}
         */
        function () { return this._min; },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this._min = this._getValidDateOrNull(this._dateAdapter.deserialize(value));
            this._validatorOnChange();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NxDatefieldDirective.prototype, "max", {
        /** Sets the maximum valid date. */
        get: /**
         * Sets the maximum valid date.
         * @return {?}
         */
        function () { return this._max; },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this._max = this._getValidDateOrNull(this._dateAdapter.deserialize(value));
            this._validatorOnChange();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NxDatefieldDirective.prototype, "strict", {
        /** If supported by the date implementation enable strict parsing (applies to Moment's parse function here) */
        get: /**
         * If supported by the date implementation enable strict parsing (applies to Moment's parse function here)
         * @return {?}
         */
        function () { return this._strict; },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this._strict = coerceBooleanProperty(value);
            // parse given text value again
            this._onInput(this._elementRef.nativeElement.value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NxDatefieldDirective.prototype, "parseFormat", {
        /** Override the parse format given with parse.dateInput with the token NX_DATE_FORMATS  */
        get: /**
         * Override the parse format given with parse.dateInput with the token NX_DATE_FORMATS
         * @return {?}
         */
        function () { return this._parseFormat; },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this._parseFormat = value;
            // parse given text value again
            this._onInput(this._elementRef.nativeElement.value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NxDatefieldDirective.prototype, "displayFormat", {
        /** Override the display format given with display.dateInput with the token NX_DATE_FORMATS  */
        get: /**
         * Override the display format given with display.dateInput with the token NX_DATE_FORMATS
         * @return {?}
         */
        function () { return this._displayFormat; },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this._displayFormat = value;
            this._formatValue(this.value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NxDatefieldDirective.prototype, "disabled", {
        /** Whether the datepicker-input is disabled. */
        get: /**
         * Whether the datepicker-input is disabled.
         * @return {?}
         */
        function () { return !!this._disabled; },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            /** @type {?} */
            var newValue = coerceBooleanProperty(value);
            if (this._disabled !== newValue) {
                this._disabled = newValue;
                this._disabledChange.emit(newValue);
            }
            if (newValue) {
                // Normally, native input elements automatically blur if they turn disabled. This behavior
                // is problematic, because it would mean that it triggers another change detection cycle,
                // which then causes a changed after checked error if the input element was focused before.
                this._elementRef.nativeElement.blur();
            }
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @deprecated
     * @deletion-target 9.0.0
     * This will force the current value to be parsed again by the given DateAdapter.
     * That's a convenience method so you can trigger it manually.
     */
    /**
     * @deprecated
     * \@deletion-target 9.0.0
     * This will force the current value to be parsed again by the given DateAdapter.
     * That's a convenience method so you can trigger it manually.
     * @return {?}
     */
    NxDatefieldDirective.prototype.format = /**
     * @deprecated
     * \@deletion-target 9.0.0
     * This will force the current value to be parsed again by the given DateAdapter.
     * That's a convenience method so you can trigger it manually.
     * @return {?}
     */
    function () {
        this.value = this.value;
    };
    /**
     * @return {?}
     */
    NxDatefieldDirective.prototype.ngAfterContentInit = /**
     * @return {?}
     */
    function () {
        var _this = this;
        if (this._datepicker) {
            this._datepickerSubscription =
                this._datepicker.selectedChanged.subscribe((/**
                 * @param {?} selected
                 * @return {?}
                 */
                function (selected) {
                    _this.value = selected;
                    _this._cvaOnChange(selected);
                    _this._onTouched();
                    _this.dateInput.emit(new NxDatepickerInputEvent(_this, _this._elementRef.nativeElement));
                    _this.dateChange.emit(new NxDatepickerInputEvent(_this, _this._elementRef.nativeElement));
                }));
        }
    };
    /**
     * @return {?}
     */
    NxDatefieldDirective.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        this._datepickerSubscription.unsubscribe();
        this._localeSubscription.unsubscribe();
        this._valueChange.complete();
        this._disabledChange.complete();
    };
    /** @docs-private */
    /**
     * \@docs-private
     * @param {?} fn
     * @return {?}
     */
    NxDatefieldDirective.prototype.registerOnValidatorChange = /**
     * \@docs-private
     * @param {?} fn
     * @return {?}
     */
    function (fn) {
        this._validatorOnChange = fn;
    };
    /** @docs-private */
    /**
     * \@docs-private
     * @param {?} c
     * @return {?}
     */
    NxDatefieldDirective.prototype.validate = /**
     * \@docs-private
     * @param {?} c
     * @return {?}
     */
    function (c) {
        /** @type {?} */
        var validator = Validators.compose(this.getValidators());
        return validator ? validator(c) : null;
    };
    /**
     * @docs-private
     * @deprecated
     * @deletion-target 7.0.0 Use `getConnectedOverlayOrigin` instead
     */
    /**
     * \@docs-private
     * @deprecated
     * \@deletion-target 7.0.0 Use `getConnectedOverlayOrigin` instead
     * @return {?}
     */
    NxDatefieldDirective.prototype.getPopupConnectionElementRef = /**
     * \@docs-private
     * @deprecated
     * \@deletion-target 7.0.0 Use `getConnectedOverlayOrigin` instead
     * @return {?}
     */
    function () {
        return this.getConnectedOverlayOrigin();
    };
    /**
     * @docs-private
     *
     * Gets the element that the datepicker popup should be connected to.
     * @return The element to connect the popup to.
     */
    /**
     * \@docs-private
     *
     * Gets the element that the datepicker popup should be connected to.
     * @return {?} The element to connect the popup to.
     */
    NxDatefieldDirective.prototype.getConnectedOverlayOrigin = /**
     * \@docs-private
     *
     * Gets the element that the datepicker popup should be connected to.
     * @return {?} The element to connect the popup to.
     */
    function () {
        // formfield not yet accessible as we don't have them in a secondary entry point to import yet.
        // return this._elementRef;
        return this._formField ? this._formField.getConnectedOverlayOrigin() : this._elementRef;
    };
    // Implemented as part of ControlValueAccessor.
    // Implemented as part of ControlValueAccessor.
    /**
     * @param {?} value
     * @return {?}
     */
    NxDatefieldDirective.prototype.writeValue = 
    // Implemented as part of ControlValueAccessor.
    /**
     * @param {?} value
     * @return {?}
     */
    function (value) {
        this.value = value;
    };
    // Implemented as part of ControlValueAccessor.
    // Implemented as part of ControlValueAccessor.
    /**
     * @param {?} fn
     * @return {?}
     */
    NxDatefieldDirective.prototype.registerOnChange = 
    // Implemented as part of ControlValueAccessor.
    /**
     * @param {?} fn
     * @return {?}
     */
    function (fn) {
        this._cvaOnChange = fn;
    };
    // Implemented as part of ControlValueAccessor.
    // Implemented as part of ControlValueAccessor.
    /**
     * @param {?} fn
     * @return {?}
     */
    NxDatefieldDirective.prototype.registerOnTouched = 
    // Implemented as part of ControlValueAccessor.
    /**
     * @param {?} fn
     * @return {?}
     */
    function (fn) {
        this._onTouched = fn;
    };
    // Implemented as part of ControlValueAccessor.
    // Implemented as part of ControlValueAccessor.
    /**
     * @param {?} isDisabled
     * @return {?}
     */
    NxDatefieldDirective.prototype.setDisabledState = 
    // Implemented as part of ControlValueAccessor.
    /**
     * @param {?} isDisabled
     * @return {?}
     */
    function (isDisabled) {
        this.disabled = isDisabled;
    };
    /**
     * @param {?} event
     * @return {?}
     */
    NxDatefieldDirective.prototype._onKeydown = /**
     * @param {?} event
     * @return {?}
     */
    function (event) {
        if (event.altKey && event.keyCode === DOWN_ARROW) {
            this._datepicker.open();
            event.preventDefault();
        }
    };
    /**
     * @param {?} value
     * @return {?}
     */
    NxDatefieldDirective.prototype._onInput = /**
     * @param {?} value
     * @return {?}
     */
    function (value) {
        /** @type {?} */
        var date = this._dateAdapter.parse(value, this._parseFormat || this._dateFormats.parse.dateInput, this.strict);
        date = this._getValidDateOrNull(date);
        this._value = date;
        if (date) {
            this.currentFormattedDate = this._dateAdapter.format(date, this._displayFormat || this._dateFormats.display.dateInput);
        }
        else {
            this.currentFormattedDate = null;
        }
        this._cvaOnChange(date);
        this._valueChange.emit(date);
        this.dateInput.emit(new NxDatepickerInputEvent(this, this._elementRef.nativeElement));
    };
    /**
     * @return {?}
     */
    NxDatefieldDirective.prototype._onChange = /**
     * @return {?}
     */
    function () {
        this.dateChange.emit(new NxDatepickerInputEvent(this, this._elementRef.nativeElement));
    };
    /**
     * @return {?}
     */
    NxDatefieldDirective.prototype._focus = /**
     * @return {?}
     */
    function () {
        this._elementRef.nativeElement.focus();
    };
    /**
     * @return {?}
     */
    NxDatefieldDirective.prototype._onBlur = /**
     * @return {?}
     */
    function () {
        // Reformat the input only if we have a valid value.
        if (this.value) {
            this._formatValue(this.value);
        }
        this._onTouched();
    };
    /** Returns the validators of the datefield. */
    /**
     * Returns the validators of the datefield.
     * @return {?}
     */
    NxDatefieldDirective.prototype.getValidators = /**
     * Returns the validators of the datefield.
     * @return {?}
     */
    function () {
        return [
            NxDateValidators.parse(this._dateAdapter, this._dateFormats, this._elementRef.nativeElement, this._strict, this._parseFormat),
            NxDateValidators.min(this._dateAdapter, this.min),
            NxDateValidators.max(this._dateAdapter, this.max),
            NxDateValidators.filter(this._dateAdapter, this._dateFilter)
        ];
    };
    /** Formats a value and sets it on the input native element. */
    /**
     * Formats a value and sets it on the input native element.
     * @private
     * @param {?} value
     * @return {?}
     */
    NxDatefieldDirective.prototype._formatValue = /**
     * Formats a value and sets it on the input native element.
     * @private
     * @param {?} value
     * @return {?}
     */
    function (value) {
        this._elementRef.nativeElement.value = value ?
            this._dateAdapter.format(value, this._displayFormat || this._dateFormats.display.dateInput) : '';
    };
    /**
     * @param obj The object to check.
     * @returns The given object if it is both a date instance and valid, otherwise null.
     */
    /**
     * @private
     * @param {?} obj The object to check.
     * @return {?} The given object if it is both a date instance and valid, otherwise null.
     */
    NxDatefieldDirective.prototype._getValidDateOrNull = /**
     * @private
     * @param {?} obj The object to check.
     * @return {?} The given object if it is both a date instance and valid, otherwise null.
     */
    function (obj) {
        return (this._dateAdapter.isDateInstance(obj) && this._dateAdapter.isValid(obj)) ? obj : null;
    };
    NxDatefieldDirective.decorators = [
        { type: Directive, args: [{
                    selector: 'input[nxDatefield]',
                    providers: [
                        NX_DATEFIELD_VALUE_ACCESSOR,
                        NX_DATEFIELD_VALIDATORS,
                        // {provide: NX_INPUT_VALUE_ACCESSOR, useExisting: NxDatefieldDirective},
                        { provide: NX_INPUT_VALUE_ACCESSOR, useExisting: NxDatefieldDirective }
                    ],
                    host: {
                        '[attr.aria-haspopup]': 'true',
                        '[attr.aria-owns]': '(_datepicker?.opened && _datepicker.id) || null',
                        '[attr.min]': 'min ? _dateAdapter.toIso8601(min) : null',
                        '[attr.max]': 'max ? _dateAdapter.toIso8601(max) : null',
                        '[disabled]': 'disabled',
                        '(input)': '_onInput($event.target.value)',
                        '(change)': '_onChange()',
                        '(blur)': '_onBlur()',
                        '(keydown)': '_onKeydown($event)',
                    },
                    exportAs: 'nxDatefield',
                },] }
    ];
    /** @nocollapse */
    NxDatefieldDirective.ctorParameters = function () { return [
        { type: ElementRef },
        { type: NxDateAdapter, decorators: [{ type: Optional }] },
        { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [NX_DATE_FORMATS,] }] },
        { type: NxFormfieldComponent, decorators: [{ type: Optional }] }
    ]; };
    NxDatefieldDirective.propDecorators = {
        datepicker: [{ type: Input, args: ['nxDatepicker',] }],
        datefieldFilter: [{ type: Input, args: ['nxDatefieldFilter',] }],
        value: [{ type: Input }],
        min: [{ type: Input, args: ['nxMin',] }],
        max: [{ type: Input, args: ['nxMax',] }],
        strict: [{ type: Input, args: ['nxStrict',] }],
        parseFormat: [{ type: Input, args: ['nxParseFormat',] }],
        displayFormat: [{ type: Input, args: ['nxDisplayFormat',] }],
        disabled: [{ type: Input }],
        dateChange: [{ type: Output }],
        dateInput: [{ type: Output }]
    };
    return NxDatefieldDirective;
}());
export { NxDatefieldDirective };
if (false) {
    /**
     * \@docs-private
     * @type {?}
     */
    NxDatefieldDirective.prototype.currentFormattedDate;
    /** @type {?} */
    NxDatefieldDirective.prototype._datepicker;
    /** @type {?} */
    NxDatefieldDirective.prototype._dateFilter;
    /**
     * @type {?}
     * @private
     */
    NxDatefieldDirective.prototype._value;
    /**
     * @type {?}
     * @private
     */
    NxDatefieldDirective.prototype._min;
    /**
     * @type {?}
     * @private
     */
    NxDatefieldDirective.prototype._max;
    /**
     * @type {?}
     * @private
     */
    NxDatefieldDirective.prototype._strict;
    /**
     * @type {?}
     * @private
     */
    NxDatefieldDirective.prototype._parseFormat;
    /**
     * @type {?}
     * @private
     */
    NxDatefieldDirective.prototype._displayFormat;
    /**
     * @type {?}
     * @private
     */
    NxDatefieldDirective.prototype._disabled;
    /**
     * Emits when a `change` event is fired on this `<input>`.
     * @type {?}
     */
    NxDatefieldDirective.prototype.dateChange;
    /**
     * Emits when an `input` event is fired on this `<input>`.
     * @type {?}
     */
    NxDatefieldDirective.prototype.dateInput;
    /**
     * Emits when the value changes (either due to user input or programmatic change).
     * @type {?}
     */
    NxDatefieldDirective.prototype._valueChange;
    /**
     * Emits when the disabled state has changed
     * @type {?}
     */
    NxDatefieldDirective.prototype._disabledChange;
    /** @type {?} */
    NxDatefieldDirective.prototype._onTouched;
    /**
     * @type {?}
     * @private
     */
    NxDatefieldDirective.prototype._cvaOnChange;
    /**
     * @type {?}
     * @private
     */
    NxDatefieldDirective.prototype._validatorOnChange;
    /**
     * @type {?}
     * @private
     */
    NxDatefieldDirective.prototype._datepickerSubscription;
    /**
     * @type {?}
     * @private
     */
    NxDatefieldDirective.prototype._localeSubscription;
    /**
     * @type {?}
     * @private
     */
    NxDatefieldDirective.prototype._elementRef;
    /** @type {?} */
    NxDatefieldDirective.prototype._dateAdapter;
    /**
     * @type {?}
     * @private
     */
    NxDatefieldDirective.prototype._dateFormats;
    /**
     * @type {?}
     * @private
     */
    NxDatefieldDirective.prototype._formField;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZGF0ZWZpZWxkLmRpcmVjdGl2ZS5qcyIsInNvdXJjZVJvb3QiOiJuZzovL0BhbGxpYW56L25neC1uZGJ4L2RhdGVmaWVsZC8iLCJzb3VyY2VzIjpbImRhdGVmaWVsZC5kaXJlY3RpdmUudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQSxPQUFPLEVBQUUsb0JBQW9CLEVBQUUsTUFBTSw2QkFBNkIsQ0FBQztBQUNuRSxPQUFPLEVBQUUsdUJBQXVCLEVBQUUsTUFBTSx5QkFBeUIsQ0FBQztBQUNsRSxPQUFPLEVBQUUscUJBQXFCLEVBQUUsTUFBTSx1QkFBdUIsQ0FBQztBQUM5RCxPQUFPLEVBQUUsVUFBVSxFQUFFLE1BQU0sdUJBQXVCLENBQUM7QUFDbkQsT0FBTyxFQUVMLFNBQVMsRUFDVCxVQUFVLEVBQ1YsWUFBWSxFQUNaLFVBQVUsRUFDVixNQUFNLEVBQ04sS0FBSyxFQUVMLFFBQVEsRUFDUixNQUFNLEdBQ1AsTUFBTSxlQUFlLENBQUM7QUFDdkIsT0FBTyxFQUdMLGFBQWEsRUFDYixpQkFBaUIsRUFJakIsVUFBVSxHQUNYLE1BQU0sZ0JBQWdCLENBQUM7QUFDeEIsT0FBTyxFQUFFLFlBQVksRUFBRSxNQUFNLE1BQU0sQ0FBQztBQUVwQyxPQUFPLEVBQUUsZUFBZSxFQUFFLGFBQWEsRUFBaUIsTUFBTSxpQkFBaUIsQ0FBQztBQUNoRixPQUFPLEVBQUUsMEJBQTBCLEVBQUUsTUFBTSxvQkFBb0IsQ0FBQztBQUNoRSxPQUFPLEVBQUUscUJBQXFCLEVBQUUsTUFBTSxtQ0FBbUMsQ0FBQztBQUMxRSxPQUFPLEVBQUUsZ0JBQWdCLEVBQUUsTUFBTSxtQkFBbUIsQ0FBQzs7Ozs7Ozs7OztBQVdyRCxNQUFNLEtBQU8sMkJBQTJCLEdBQVE7SUFDOUMsT0FBTyxFQUFFLGlCQUFpQjtJQUMxQixXQUFXLEVBQUUsVUFBVTs7O0lBQUMsY0FBTSxPQUFBLG9CQUFvQixFQUFwQixDQUFvQixFQUFDO0lBQ25ELEtBQUssRUFBRSxJQUFJO0NBQ1o7O0FBRUQsTUFB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QWE7aUJBQ3hCOzs7O2dCQXhGQyxVQUFVO2dCQXFCYyxhQUFhLHVCQXVOaEMsUUFBUTtnREFDUixRQUFRLFlBQUksTUFBTSxTQUFDLGVBQWU7Z0JBcFBoQyxvQkFBb0IsdUJBcVB0QixRQUFROzs7NkJBOUlaLEtBQUssU0FBQyxjQUFjO2tDQWNwQixLQUFLLFNBQUMsbUJBQW1CO3dCQVN6QixLQUFLO3NCQWVMLEtBQUssU0FBQyxPQUFPO3NCQVNiLEtBQUssU0FBQyxPQUFPO3lCQVNiLEtBQUssU0FBQyxVQUFVOzhCQVVoQixLQUFLLFNBQUMsZUFBZTtnQ0FVckIsS0FBSyxTQUFDLGlCQUFpQjsyQkFTdkIsS0FBSzs2QkFvQkwsTUFBTTs0QkFJTixNQUFNOztJQXlMVCwyQkFBQztDQUFBLEFBbFVELElBa1VDO1NBN1NZLG9CQUFvQjs7Ozs7O0lBSS9CLG9EQUFtQzs7SUFPbkMsMkNBQXNDOztJQWdCdEMsMkNBQXlDOzs7OztJQWV6QyxzQ0FBeUI7Ozs7O0lBU3pCLG9DQUF1Qjs7Ozs7SUFTdkIsb0NBQXVCOzs7OztJQVV2Qix1Q0FBZ0M7Ozs7O0lBVWhDLDRDQUF3Qzs7Ozs7SUFTeEMsOENBQStCOzs7OztJQW9CL0IseUNBQTJCOzs7OztJQUczQiwwQ0FDa0Q7Ozs7O0lBR2xELHlDQUNrRDs7Ozs7SUFHbEQsNENBQTRDOzs7OztJQUc1QywrQ0FBOEM7O0lBRTlDLDBDQUFzQjs7Ozs7SUFFdEIsNENBQXNEOzs7OztJQUV0RCxrREFBc0M7Ozs7O0lBRXRDLHVEQUFxRDs7Ozs7SUFFckQsbURBQWlEOzs7OztJQWE3QywyQ0FBK0I7O0lBQy9CLDRDQUFpRDs7Ozs7SUFDakQsNENBQXdFOzs7OztJQUN4RSwwQ0FBb0QiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBOeEZvcm1maWVsZENvbXBvbmVudCB9IGZyb20gJ0BhbGxpYW56L25neC1uZGJ4L2Zvcm1maWVsZCc7XG5pbXBvcnQgeyBOWF9JTlBVVF9WQUxVRV9BQ0NFU1NPUiB9IGZyb20gJ0BhbGxpYW56L25neC1uZGJ4L2lucHV0JztcbmltcG9ydCB7IGNvZXJjZUJvb2xlYW5Qcm9wZXJ0eSB9IGZyb20gJ0Bhbmd1bGFyL2Nkay9jb2VyY2lvbic7XG5pbXBvcnQgeyBET1dOX0FSUk9XIH0gZnJvbSAnQGFuZ3VsYXIvY2RrL2tleWNvZGVzJztcbmltcG9ydCB7XG4gIEFmdGVyQ29udGVudEluaXQsXG4gIERpcmVjdGl2ZSxcbiAgRWxlbWVudFJlZixcbiAgRXZlbnRFbWl0dGVyLFxuICBmb3J3YXJkUmVmLFxuICBJbmplY3QsXG4gIElucHV0LFxuICBPbkRlc3Ryb3ksXG4gIE9wdGlvbmFsLFxuICBPdXRwdXQsXG59IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHtcbiAgQWJzdHJhY3RDb250cm9sLFxuICBDb250cm9sVmFsdWVBY2Nlc3NvcixcbiAgTkdfVkFMSURBVE9SUyxcbiAgTkdfVkFMVUVfQUNDRVNTT1IsXG4gIFZhbGlkYXRpb25FcnJvcnMsXG4gIFZhbGlkYXRvcixcbiAgVmFsaWRhdG9yRm4sXG4gIFZhbGlkYXRvcnMsXG59IGZyb20gJ0Bhbmd1bGFyL2Zvcm1zJztcbmltcG9ydCB7IFN1YnNjcmlwdGlvbiB9IGZyb20gJ3J4anMnO1xuXG5pbXBvcnQgeyBOWF9EQVRFX0ZPUk1BVFMsIE54RGF0ZUFkYXB0ZXIsIE54RGF0ZUZvcm1hdHMgfSBmcm9tICcuL2FkYXB0ZXIvaW5kZXgnO1xuaW1wb3J0IHsgY3JlYXRlTWlzc2luZ0RhdGVJbXBsRXJyb3IgfSBmcm9tICcuL2RhdGVmaWVsZC1lcnJvcnMnO1xuaW1wb3J0IHsgTnhEYXRlcGlja2VyQ29tcG9uZW50IH0gZnJvbSAnLi9kYXRlcGlja2VyL2RhdGVwaWNrZXIuY29tcG9uZW50JztcbmltcG9ydCB7IE54RGF0ZVZhbGlkYXRvcnMgfSBmcm9tICcuL2RhdGUtdmFsaWRhdG9ycyc7XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgTExDIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xuXG4vLyB0c2xpbnQ6ZGlzYWJsZTptZW1iZXItb3JkZXJpbmdcbmV4cG9ydCBjb25zdCBOWF9EQVRFRklFTERfVkFMVUVfQUNDRVNTT1I6IGFueSA9IHtcbiAgcHJvdmlkZTogTkdfVkFMVUVfQUNDRVNTT1IsXG4gIHVzZUV4aXN0aW5nOiBmb3J3YXJkUmVmKCgpID0+IE54RGF0ZWZpZWxkRGlyZWN0aXZlKSxcbiAgbXVsdGk6IHRydWVcbn07XG5cbmV4cG9ydCBjb25zdCBOWF9EQVRFRklFTERfVkFMSURBVE9SUzogYW55ID0ge1xuICBwcm92aWRlOiBOR19WQUxJREFUT1JTLFxuICB1c2VFeGlzdGluZzogZm9yd2FyZFJlZigoKSA9PiBOeERhdGVmaWVsZERpcmVjdGl2ZSksXG4gIG11bHRpOiB0cnVlXG59O1xuXG4vKipcbiAqIEFuIGV2ZW50IHVzZWQgZm9yIGRhdGVwaWNrZXIgaW5wdXQgYW5kIGNoYW5nZSBldmVudHMuIFdlIGRvbid0IGFsd2F5cyBoYXZlIGFjY2VzcyB0byBhIG5hdGl2ZVxuICogaW5wdXQgb3IgY2hhbmdlIGV2ZW50IGJlY2F1c2UgdGhlIGV2ZW50IG1heSBoYXZlIGJlZW4gdHJpZ2dlcmVkIGJ5IHRoZSB1c2VyIGNsaWNraW5nIG9uIHRoZVxuICogY2FsZW5kYXIgcG9wdXAuIEZvciBjb25zaXN0ZW5jeSwgd2UgYWx3YXlzIHVzZSBOeERhdGVwaWNrZXJJbnB1dEV2ZW50IGluc3RlYWQuXG4gKi9cbmV4cG9ydCBjbGFzcyBOeERhdGVwaWNrZXJJbnB1dEV2ZW50PEQ+IHtcbiAgLyoqIFRoZSBuZXcgdmFsdWUgZm9yIHRoZSB0YXJnZXQgZGF0ZXBpY2tlciBpbnB1dC4gKi9cbiAgdmFsdWU6IEQgfCBudWxsO1xuXG4gIGNvbnN0cnVjdG9yKFxuICAgIC8qKiBSZWZlcmVuY2UgdG8gdGhlIGRhdGVwaWNrZXIgaW5wdXQgY29tcG9uZW50IHRoYXQgZW1pdHRlZCB0aGUgZXZlbnQuICovXG4gICAgcHVibGljIHRhcmdldDogTnhEYXRlZmllbGREaXJlY3RpdmU8RD4sXG4gICAgLyoqIFJlZmVyZW5jZSB0byB0aGUgbmF0aXZlIGlucHV0IGVsZW1lbnQgYXNzb2NpYXRlZCB3aXRoIHRoZSBkYXRlcGlja2VyIGlucHV0LiAqL1xuICAgIHB1YmxpYyB0YXJnZXRFbGVtZW50OiBIVE1MRWxlbWVudCkge1xuICAgIHRoaXMudmFsdWUgPSB0aGlzLnRhcmdldC52YWx1ZTtcbiAgfVxufVxuXG4vKipcbiAqIERpcmVjdGl2ZSB1c2VkIHRvIHByb3ZpZGUgZGF0ZSBwcm9jZXNzaW5nIGZ1bmN0aW9uYWxpdHkgdG8gYW4gaW5wdXQuXG4gKi9cbkBEaXJlY3RpdmUoe1xuICBzZWxlY3RvcjogJ2lucHV0W254RGF0ZWZpZWxkXScsXG4gIHByb3ZpZGVyczogW1xuICAgIE5YX0RBVEVGSUVMRF9WQUxVRV9BQ0NFU1NPUixcbiAgICBOWF9EQVRFRklFTERfVkFMSURBVE9SUyxcbiAgICAvLyB7cHJvdmlkZTogTlhfSU5QVVRfVkFMVUVfQUNDRVNTT1IsIHVzZUV4aXN0aW5nOiBOeERhdGVmaWVsZERpcmVjdGl2ZX0sXG4gICAgeyBwcm92aWRlOiBOWF9JTlBVVF9WQUxVRV9BQ0NFU1NPUiwgdXNlRXhpc3Rpbmc6IE54RGF0ZWZpZWxkRGlyZWN0aXZlIH1cbiAgXSxcbiAgaG9zdDoge1xuICAgICdbYXR0ci5hcmlhLWhhc3BvcHVwXSc6ICd0cnVlJyxcbiAgICAnW2F0dHIuYXJpYS1vd25zXSc6ICcoX2RhdGVwaWNrZXI/Lm9wZW5lZCAmJiBfZGF0ZXBpY2tlci5pZCkgfHwgbnVsbCcsXG4gICAgJ1thdHRyLm1pbl0nOiAnbWluID8gX2RhdGVBZGFwdGVyLnRvSXNvODYwMShtaW4pIDogbnVsbCcsXG4gICAgJ1thdHRyLm1heF0nOiAnbWF4ID8gX2RhdGVBZGFwdGVyLnRvSXNvODYwMShtYXgpIDogbnVsbCcsXG4gICAgJ1tkaXNhYmxlZF0nOiAnZGlzYWJsZWQnLFxuICAgICcoaW5wdXQpJzogJ19vbklucHV0KCRldmVudC50YXJnZXQudmFsdWUpJyxcbiAgICAnKGNoYW5nZSknOiAnX29uQ2hhbmdlKCknLFxuICAgICcoYmx1ciknOiAnX29uQmx1cigpJyxcbiAgICAnKGtleWRvd24pJzogJ19vbktleWRvd24oJGV2ZW50KScsXG4gIH0sXG4gIGV4cG9ydEFzOiAnbnhEYXRlZmllbGQnLFxufSlcbmV4cG9ydCBjbGFzcyBOeERhdGVmaWVsZERpcmVjdGl2ZTxEPiBpbXBsZW1lbnRzIEFmdGVyQ29udGVudEluaXQsIENvbnRyb2xWYWx1ZUFjY2Vzc29yLCBPbkRlc3Ryb3ksXG4gICAgVmFsaWRhdG9yIHtcblxuICAvKiogQGRvY3MtcHJpdmF0ZSAqL1xuICBwdWJsaWMgY3VycmVudEZvcm1hdHRlZERhdGUgPSBudWxsO1xuXG4gIC8qKiBUaGUgZGF0ZXBpY2tlciB0aGF0IHRoaXMgaW5wdXQgaXMgYXNzb2NpYXRlZCB3aXRoLiAqL1xuICBASW5wdXQoJ254RGF0ZXBpY2tlcicpXG4gIHNldCBkYXRlcGlja2VyKHZhbHVlOiBOeERhdGVwaWNrZXJDb21wb25lbnQ8RD4pIHtcbiAgICB0aGlzLnJlZ2lzdGVyRGF0ZXBpY2tlcih2YWx1ZSk7XG4gIH1cbiAgX2RhdGVwaWNrZXI6IE54RGF0ZXBpY2tlckNvbXBvbmVudDxEPjtcblxuICBwcml2YXRlIHJlZ2lzdGVyRGF0ZXBpY2tlcih2YWx1ZTogTnhEYXRlcGlja2VyQ29tcG9uZW50PEQ+KSB7XG4gICAgaWYgKHZhbHVlKSB7XG4gICAgICB0aGlzLl9kYXRlcGlja2VyID0gdmFsdWU7XG4gICAgICB0aGlzLl9kYXRlcGlja2VyLnJlZ2lzdGVySW5wdXQodGhpcyk7XG4gICAgfVxuICB9XG5cbiAgLyoqIEZ1bmN0aW9uIHRoYXQgY2FuIGJlIHVzZWQgdG8gZmlsdGVyIG91dCBkYXRlcyB3aXRoaW4gdGhlIGRhdGVwaWNrZXIgYW5kIGludmFsaWRhdGUgdmFsdWVzIGluIHRoZSBkYXRlZmllbGQuICovXG4gIEBJbnB1dCgnbnhEYXRlZmllbGRGaWx0ZXInKVxuICBzZXQgZGF0ZWZpZWxkRmlsdGVyKHZhbHVlOiAoZGF0ZTogRCB8IG51bGwpID0+IGJvb2xlYW4pIHtcbiAgICB0aGlzLl9kYXRlRmlsdGVyID0gdmFsdWU7XG4gICAgdGhpcy5fdmFsaWRhdG9yT25DaGFuZ2UoKTtcbiAgfVxuXG4gIF9kYXRlRmlsdGVyOiAoZGF0ZTogRCB8IG51bGwpID0+IGJvb2xlYW47XG5cbiAgLyoqIFByb3ZpZGUgb3IgcmVhZCB0aGUgY3VycmVudCBkYXRlLiBJdCdzIHR5cGUgPEQ+IGRlcGVuZHMgb24gdGhlIGNob3NlbiBkYXRlIGltcGxlbWVudGF0aW9uICovXG4gIEBJbnB1dCgpXG4gIGdldCB2YWx1ZSgpOiBEIHwgbnVsbCB7IHJldHVybiB0aGlzLl92YWx1ZTsgfVxuICBzZXQgdmFsdWUodmFsdWU6IEQgfCBudWxsKSB7XG4gICAgdmFsdWUgPSB0aGlzLl9kYXRlQWRhcHRlci5kZXNlcmlhbGl6ZSh2YWx1ZSk7XG4gICAgdmFsdWUgPSB0aGlzLl9nZXRWYWxpZERhdGVPck51bGwodmFsdWUpO1xuICAgIGNvbnN0IG9sZERhdGUgPSB0aGlzLnZhbHVlO1xuICAgIHRoaXMuX3ZhbHVlID0gdmFsdWU7XG4gICAgdGhpcy5fZm9ybWF0VmFsdWUodGhpcy52YWx1ZSk7XG4gICAgaWYgKCF0aGlzLl9kYXRlQWRhcHRlci5zYW1lRGF0ZShvbGREYXRlLCB2YWx1ZSkpIHtcbiAgICAgIHRoaXMuX3ZhbHVlQ2hhbmdlLmVtaXQodmFsdWUpO1xuICAgIH1cbiAgfVxuICBwcml2YXRlIF92YWx1ZTogRCB8IG51bGw7XG5cbiAgLyoqIFNldHMgdGhlIG1pbmltdW0gdmFsaWQgZGF0ZS4gKi9cbiAgQElucHV0KCdueE1pbicpXG4gIGdldCBtaW4oKTogRCB8IG51bGwgeyByZXR1cm4gdGhpcy5fbWluOyB9XG4gIHNldCBtaW4odmFsdWU6IEQgfCBudWxsKSB7XG4gICAgdGhpcy5fbWluID0gdGhpcy5fZ2V0VmFsaWREYXRlT3JOdWxsKHRoaXMuX2RhdGVBZGFwdGVyLmRlc2VyaWFsaXplKHZhbHVlKSk7XG4gICAgdGhpcy5fdmFsaWRhdG9yT25DaGFuZ2UoKTtcbiAgfVxuICBwcml2YXRlIF9taW46IEQgfCBudWxsO1xuXG4gIC8qKiBTZXRzIHRoZSBtYXhpbXVtIHZhbGlkIGRhdGUuICovXG4gIEBJbnB1dCgnbnhNYXgnKVxuICBnZXQgbWF4KCk6IEQgfCBudWxsIHsgcmV0dXJuIHRoaXMuX21heDsgfVxuICBzZXQgbWF4KHZhbHVlOiBEIHwgbnVsbCkge1xuICAgIHRoaXMuX21heCA9IHRoaXMuX2dldFZhbGlkRGF0ZU9yTnVsbCh0aGlzLl9kYXRlQWRhcHRlci5kZXNlcmlhbGl6ZSh2YWx1ZSkpO1xuICAgIHRoaXMuX3ZhbGlkYXRvck9uQ2hhbmdlKCk7XG4gIH1cbiAgcHJpdmF0ZSBfbWF4OiBEIHwgbnVsbDtcblxuICAvKiogSWYgc3VwcG9ydGVkIGJ5IHRoZSBkYXRlIGltcGxlbWVudGF0aW9uIGVuYWJsZSBzdHJpY3QgcGFyc2luZyAoYXBwbGllcyB0byBNb21lbnQncyBwYXJzZSBmdW5jdGlvbiBoZXJlKSAqL1xuICBASW5wdXQoJ254U3RyaWN0JylcbiAgZ2V0IHN0cmljdCgpIHsgcmV0dXJuIHRoaXMuX3N0cmljdDsgfVxuICBzZXQgc3RyaWN0KHZhbHVlOiBhbnkpIHtcbiAgICB0aGlzLl9zdHJpY3QgPSBjb2VyY2VCb29sZWFuUHJvcGVydHkodmFsdWUpO1xuICAgIC8vIHBhcnNlIGdpdmVuIHRleHQgdmFsdWUgYWdhaW5cbiAgICB0aGlzLl9vbklucHV0KHRoaXMuX2VsZW1lbnRSZWYubmF0aXZlRWxlbWVudC52YWx1ZSk7XG4gIH1cbiAgcHJpdmF0ZSBfc3RyaWN0OiBib29sZWFuID0gdHJ1ZTtcblxuICAvKiogT3ZlcnJpZGUgdGhlIHBhcnNlIGZvcm1hdCBnaXZlbiB3aXRoIHBhcnNlLmRhdGVJbnB1dCB3aXRoIHRoZSB0b2tlbiBOWF9EQVRFX0ZPUk1BVFMgICovXG4gIEBJbnB1dCgnbnhQYXJzZUZvcm1hdCcpXG4gIGdldCBwYXJzZUZvcm1hdCgpIHsgcmV0dXJuIHRoaXMuX3BhcnNlRm9ybWF0OyB9XG4gIHNldCBwYXJzZUZvcm1hdCh2YWx1ZTogc3RyaW5nIHwgc3RyaW5nW10pIHtcbiAgICB0aGlzLl9wYXJzZUZvcm1hdCA9IHZhbHVlO1xuICAgIC8vIHBhcnNlIGdpdmVuIHRleHQgdmFsdWUgYWdhaW5cbiAgICB0aGlzLl9vbklucHV0KHRoaXMuX2VsZW1lbnRSZWYubmF0aXZlRWxlbWVudC52YWx1ZSk7XG4gIH1cbiAgcHJpdmF0ZSBfcGFyc2VGb3JtYXQ6IHN0cmluZyB8IHN0cmluZ1tdO1xuXG4gIC8qKiBPdmVycmlkZSB0aGUgZGlzcGxheSBmb3JtYXQgZ2l2ZW4gd2l0aCBkaXNwbGF5LmRhdGVJbnB1dCB3aXRoIHRoZSB0b2tlbiBOWF9EQVRFX0ZPUk1BVFMgICovXG4gIEBJbnB1dCgnbnhEaXNwbGF5Rm9ybWF0JylcbiAgZ2V0IGRpc3BsYXlGb3JtYXQoKSB7IHJldHVybiB0aGlzLl9kaXNwbGF5Rm9ybWF0OyB9XG4gIHNldCBkaXNwbGF5Rm9ybWF0KHZhbHVlOiBzdHJpbmcpIHtcbiAgICB0aGlzLl9kaXNwbGF5Rm9ybWF0ID0gdmFsdWU7XG4gICAgdGhpcy5fZm9ybWF0VmFsdWUodGhpcy52YWx1ZSk7XG4gIH1cbiAgcHJpdmF0ZSBfZGlzcGxheUZvcm1hdDogc3RyaW5nO1xuXG4vKiogV2hldGhlciB0aGUgZGF0ZXBpY2tlci1pbnB1dCBpcyBkaXNhYmxlZC4gKi9cbiAgQElucHV0KClcbiAgZ2V0IGRpc2FibGVkKCk6IGJvb2xlYW4geyByZXR1cm4gISF0aGlzLl9kaXNhYmxlZDsgfVxuICBzZXQgZGlzYWJsZWQodmFsdWU6IGJvb2xlYW4pIHtcbiAgICBjb25zdCBuZXdWYWx1ZSA9IGNvZXJjZUJvb2xlYW5Qcm9wZXJ0eSh2YWx1ZSk7XG5cbiAgICBpZiAodGhpcy5fZGlzYWJsZWQgIT09IG5ld1ZhbHVlKSB7XG4gICAgICB0aGlzLl9kaXNhYmxlZCA9IG5ld1ZhbHVlO1xuICAgICAgdGhpcy5fZGlzYWJsZWRDaGFuZ2UuZW1pdChuZXdWYWx1ZSk7XG4gICAgfVxuXG4gICAgaWYgKG5ld1ZhbHVlKSB7XG4gICAgICAvLyBOb3JtYWxseSwgbmF0aXZlIGlucHV0IGVsZW1lbnRzIGF1dG9tYXRpY2FsbHkgYmx1ciBpZiB0aGV5IHR1cm4gZGlzYWJsZWQuIFRoaXMgYmVoYXZpb3JcbiAgICAgIC8vIGlzIHByb2JsZW1hdGljLCBiZWNhdXNlIGl0IHdvdWxkIG1lYW4gdGhhdCBpdCB0cmlnZ2VycyBhbm90aGVyIGNoYW5nZSBkZXRlY3Rpb24gY3ljbGUsXG4gICAgICAvLyB3aGljaCB0aGVuIGNhdXNlcyBhIGNoYW5nZWQgYWZ0ZXIgY2hlY2tlZCBlcnJvciBpZiB0aGUgaW5wdXQgZWxlbWVudCB3YXMgZm9jdXNlZCBiZWZvcmUuXG4gICAgICB0aGlzLl9lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQuYmx1cigpO1xuICAgIH1cbiAgfVxuICBwcml2YXRlIF9kaXNhYmxlZDogYm9vbGVhbjtcblxuICAvKiogRW1pdHMgd2hlbiBhIGBjaGFuZ2VgIGV2ZW50IGlzIGZpcmVkIG9uIHRoaXMgYDxpbnB1dD5gLiAqL1xuICBAT3V0cHV0KCkgcmVhZG9ubHkgZGF0ZUNoYW5nZTogRXZlbnRFbWl0dGVyPE54RGF0ZXBpY2tlcklucHV0RXZlbnQ8RD4+ID1cbiAgICAgIG5ldyBFdmVudEVtaXR0ZXI8TnhEYXRlcGlja2VySW5wdXRFdmVudDxEPj4oKTtcblxuICAvKiogRW1pdHMgd2hlbiBhbiBgaW5wdXRgIGV2ZW50IGlzIGZpcmVkIG9uIHRoaXMgYDxpbnB1dD5gLiAqL1xuICBAT3V0cHV0KCkgcmVhZG9ubHkgZGF0ZUlucHV0OiBFdmVudEVtaXR0ZXI8TnhEYXRlcGlja2VySW5wdXRFdmVudDxEPj4gPVxuICAgICAgbmV3IEV2ZW50RW1pdHRlcjxOeERhdGVwaWNrZXJJbnB1dEV2ZW50PEQ+PigpO1xuXG4gIC8qKiBFbWl0cyB3aGVuIHRoZSB2YWx1ZSBjaGFuZ2VzIChlaXRoZXIgZHVlIHRvIHVzZXIgaW5wdXQgb3IgcHJvZ3JhbW1hdGljIGNoYW5nZSkuICovXG4gIF92YWx1ZUNoYW5nZSA9IG5ldyBFdmVudEVtaXR0ZXI8RCB8IG51bGw+KCk7XG5cbiAgLyoqIEVtaXRzIHdoZW4gdGhlIGRpc2FibGVkIHN0YXRlIGhhcyBjaGFuZ2VkICovXG4gIF9kaXNhYmxlZENoYW5nZSA9IG5ldyBFdmVudEVtaXR0ZXI8Ym9vbGVhbj4oKTtcblxuICBfb25Ub3VjaGVkID0gKCkgPT4ge307XG5cbiAgcHJpdmF0ZSBfY3ZhT25DaGFuZ2U6ICh2YWx1ZTogYW55KSA9PiB2b2lkID0gKCkgPT4ge307XG5cbiAgcHJpdmF0ZSBfdmFsaWRhdG9yT25DaGFuZ2UgPSAoKSA9PiB7fTtcblxuICBwcml2YXRlIF9kYXRlcGlja2VyU3Vic2NyaXB0aW9uID0gU3Vic2NyaXB0aW9uLkVNUFRZO1xuXG4gIHByaXZhdGUgX2xvY2FsZVN1YnNjcmlwdGlvbiA9IFN1YnNjcmlwdGlvbi5FTVBUWTtcblxuICAvKipcbiAgICogQGRlcHJlY2F0ZWRcbiAgICogQGRlbGV0aW9uLXRhcmdldCA5LjAuMFxuICAgKiBUaGlzIHdpbGwgZm9yY2UgdGhlIGN1cnJlbnQgdmFsdWUgdG8gYmUgcGFyc2VkIGFnYWluIGJ5IHRoZSBnaXZlbiBEYXRlQWRhcHRlci5cbiAgICogVGhhdCdzIGEgY29udmVuaWVuY2UgbWV0aG9kIHNvIHlvdSBjYW4gdHJpZ2dlciBpdCBtYW51YWxseS5cbiAgICovXG4gIHB1YmxpYyBmb3JtYXQoKSB7XG4gICAgdGhpcy52YWx1ZSA9IHRoaXMudmFsdWU7XG4gIH1cblxuICBjb25zdHJ1Y3RvcihcbiAgICAgIHByaXZhdGUgX2VsZW1lbnRSZWY6IEVsZW1lbnRSZWYsXG4gICAgICBAT3B0aW9uYWwoKSBwdWJsaWMgX2RhdGVBZGFwdGVyOiBOeERhdGVBZGFwdGVyPEQ+LFxuICAgICAgQE9wdGlvbmFsKCkgQEluamVjdChOWF9EQVRFX0ZPUk1BVFMpIHByaXZhdGUgX2RhdGVGb3JtYXRzOiBOeERhdGVGb3JtYXRzLFxuICAgICAgQE9wdGlvbmFsKCkgcHJpdmF0ZSBfZm9ybUZpZWxkOiBOeEZvcm1maWVsZENvbXBvbmVudCkge1xuICAgIGlmICghdGhpcy5fZGF0ZUFkYXB0ZXIpIHtcbiAgICAgIHRocm93IGNyZWF0ZU1pc3NpbmdEYXRlSW1wbEVycm9yKCdEYXRlQWRhcHRlcicpO1xuICAgIH1cbiAgICBpZiAoIXRoaXMuX2RhdGVGb3JtYXRzKSB7XG4gICAgICB0aHJvdyBjcmVhdGVNaXNzaW5nRGF0ZUltcGxFcnJvcignTlhfREFURV9GT1JNQVRTJyk7XG4gICAgfVxuXG4gICAgLy8gVXBkYXRlIHRoZSBkaXNwbGF5ZWQgZGF0ZSB3aGVuIHRoZSBsb2NhbGUgY2hhbmdlcy5cbiAgICB0aGlzLl9sb2NhbGVTdWJzY3JpcHRpb24gPSBfZGF0ZUFkYXB0ZXIubG9jYWxlQ2hhbmdlcy5zdWJzY3JpYmUoKCkgPT4ge1xuICAgICAgdGhpcy52YWx1ZSA9IHRoaXMudmFsdWU7XG4gICAgfSk7XG4gIH1cblxuICBuZ0FmdGVyQ29udGVudEluaXQoKSB7XG4gICAgaWYgKHRoaXMuX2RhdGVwaWNrZXIpIHtcbiAgICAgIHRoaXMuX2RhdGVwaWNrZXJTdWJzY3JpcHRpb24gPVxuICAgICAgICAgIHRoaXMuX2RhdGVwaWNrZXIuc2VsZWN0ZWRDaGFuZ2VkLnN1YnNjcmliZSgoc2VsZWN0ZWQ6IEQpID0+IHtcbiAgICAgICAgICAgIHRoaXMudmFsdWUgPSBzZWxlY3RlZDtcbiAgICAgICAgICAgIHRoaXMuX2N2YU9uQ2hhbmdlKHNlbGVjdGVkKTtcbiAgICAgICAgICAgIHRoaXMuX29uVG91Y2hlZCgpO1xuICAgICAgICAgICAgdGhpcy5kYXRlSW5wdXQuZW1pdChuZXcgTnhEYXRlcGlja2VySW5wdXRFdmVudCh0aGlzLCB0aGlzLl9lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQpKTtcbiAgICAgICAgICAgIHRoaXMuZGF0ZUNoYW5nZS5lbWl0KG5ldyBOeERhdGVwaWNrZXJJbnB1dEV2ZW50KHRoaXMsIHRoaXMuX2VsZW1lbnRSZWYubmF0aXZlRWxlbWVudCkpO1xuICAgICAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIG5nT25EZXN0cm95KCkge1xuICAgIHRoaXMuX2RhdGVwaWNrZXJTdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcbiAgICB0aGlzLl9sb2NhbGVTdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcbiAgICB0aGlzLl92YWx1ZUNoYW5nZS5jb21wbGV0ZSgpO1xuICAgIHRoaXMuX2Rpc2FibGVkQ2hhbmdlLmNvbXBsZXRlKCk7XG4gIH1cblxuICAvKiogQGRvY3MtcHJpdmF0ZSAqL1xuICByZWdpc3Rlck9uVmFsaWRhdG9yQ2hhbmdlKGZuOiAoKSA9PiB2b2lkKTogdm9pZCB7XG4gICAgdGhpcy5fdmFsaWRhdG9yT25DaGFuZ2UgPSBmbjtcbiAgfVxuXG4gIC8qKiBAZG9jcy1wcml2YXRlICovXG4gIHZhbGlkYXRlKGM6IEFic3RyYWN0Q29udHJvbCk6IFZhbGlkYXRpb25FcnJvcnMgfCBudWxsIHtcbiAgICBjb25zdCB2YWxpZGF0b3IgPSBWYWxpZGF0b3JzLmNvbXBvc2UodGhpcy5nZXRWYWxpZGF0b3JzKCkpO1xuICAgIHJldHVybiB2YWxpZGF0b3IgPyB2YWxpZGF0b3IoYykgOiBudWxsO1xuICB9XG5cbiAgLyoqXG4gICAqIEBkb2NzLXByaXZhdGVcbiAgICogQGRlcHJlY2F0ZWRcbiAgICogQGRlbGV0aW9uLXRhcmdldCA3LjAuMCBVc2UgYGdldENvbm5lY3RlZE92ZXJsYXlPcmlnaW5gIGluc3RlYWRcbiAgICovXG4gIGdldFBvcHVwQ29ubmVjdGlvbkVsZW1lbnRSZWYoKTogRWxlbWVudFJlZiB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0Q29ubmVjdGVkT3ZlcmxheU9yaWdpbigpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBkb2NzLXByaXZhdGVcbiAgICpcbiAgICogR2V0cyB0aGUgZWxlbWVudCB0aGF0IHRoZSBkYXRlcGlja2VyIHBvcHVwIHNob3VsZCBiZSBjb25uZWN0ZWQgdG8uXG4gICAqIEByZXR1cm4gVGhlIGVsZW1lbnQgdG8gY29ubmVjdCB0aGUgcG9wdXAgdG8uXG4gICAqL1xuICBnZXRDb25uZWN0ZWRPdmVybGF5T3JpZ2luKCk6IEVsZW1lbnRSZWYge1xuICAgIC8vIGZvcm1maWVsZCBub3QgeWV0IGFjY2Vzc2libGUgYXMgd2UgZG9uJ3QgaGF2ZSB0aGVtIGluIGEgc2Vjb25kYXJ5IGVudHJ5IHBvaW50IHRvIGltcG9ydCB5ZXQuXG4gICAgLy8gcmV0dXJuIHRoaXMuX2VsZW1lbnRSZWY7XG4gICAgcmV0dXJuIHRoaXMuX2Zvcm1GaWVsZCA/IHRoaXMuX2Zvcm1GaWVsZC5nZXRDb25uZWN0ZWRPdmVybGF5T3JpZ2luKCkgOiB0aGlzLl9lbGVtZW50UmVmO1xuICB9XG5cbiAgLy8gSW1wbGVtZW50ZWQgYXMgcGFydCBvZiBDb250cm9sVmFsdWVBY2Nlc3Nvci5cbiAgd3JpdGVWYWx1ZSh2YWx1ZTogRCk6IHZvaWQge1xuICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgfVxuXG4gIC8vIEltcGxlbWVudGVkIGFzIHBhcnQgb2YgQ29udHJvbFZhbHVlQWNjZXNzb3IuXG4gIHJlZ2lzdGVyT25DaGFuZ2UoZm46ICh2YWx1ZTogYW55KSA9PiB2b2lkKTogdm9pZCB7XG4gICAgdGhpcy5fY3ZhT25DaGFuZ2UgPSBmbjtcbiAgfVxuXG4gIC8vIEltcGxlbWVudGVkIGFzIHBhcnQgb2YgQ29udHJvbFZhbHVlQWNjZXNzb3IuXG4gIHJlZ2lzdGVyT25Ub3VjaGVkKGZuOiAoKSA9PiB2b2lkKTogdm9pZCB7XG4gICAgdGhpcy5fb25Ub3VjaGVkID0gZm47XG4gIH1cblxuICAvLyBJbXBsZW1lbnRlZCBhcyBwYXJ0IG9mIENvbnRyb2xWYWx1ZUFjY2Vzc29yLlxuICBzZXREaXNhYmxlZFN0YXRlKGlzRGlzYWJsZWQ6IGJvb2xlYW4pOiB2b2lkIHtcbiAgICB0aGlzLmRpc2FibGVkID0gaXNEaXNhYmxlZDtcbiAgfVxuXG4gIF9vbktleWRvd24oZXZlbnQ6IEtleWJvYXJkRXZlbnQpIHtcbiAgICBpZiAoZXZlbnQuYWx0S2V5ICYmIGV2ZW50LmtleUNvZGUgPT09IERPV05fQVJST1cpIHtcbiAgICAgIHRoaXMuX2RhdGVwaWNrZXIub3BlbigpO1xuICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICB9XG4gIH1cblxuICBfb25JbnB1dCh2YWx1ZTogc3RyaW5nKSB7XG4gICAgbGV0IGRhdGUgPSB0aGlzLl9kYXRlQWRhcHRlci5wYXJzZSh2YWx1ZSwgdGhpcy5fcGFyc2VGb3JtYXQgfHwgdGhpcy5fZGF0ZUZvcm1hdHMucGFyc2UuZGF0ZUlucHV0LCB0aGlzLnN0cmljdCk7XG4gICAgZGF0ZSA9IHRoaXMuX2dldFZhbGlkRGF0ZU9yTnVsbChkYXRlKTtcbiAgICB0aGlzLl92YWx1ZSA9IGRhdGU7XG5cbiAgICBpZiAoZGF0ZSkge1xuICAgICAgdGhpcy5jdXJyZW50Rm9ybWF0dGVkRGF0ZSA9IHRoaXMuX2RhdGVBZGFwdGVyLmZvcm1hdChcbiAgICAgICAgZGF0ZSxcbiAgICAgICAgdGhpcy5fZGlzcGxheUZvcm1hdCB8fCB0aGlzLl9kYXRlRm9ybWF0cy5kaXNwbGF5LmRhdGVJbnB1dFxuICAgICAgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5jdXJyZW50Rm9ybWF0dGVkRGF0ZSA9IG51bGw7XG4gICAgfVxuXG4gICAgdGhpcy5fY3ZhT25DaGFuZ2UoZGF0ZSk7XG4gICAgdGhpcy5fdmFsdWVDaGFuZ2UuZW1pdChkYXRlKTtcblxuICAgIHRoaXMuZGF0ZUlucHV0LmVtaXQobmV3IE54RGF0ZXBpY2tlcklucHV0RXZlbnQodGhpcywgdGhpcy5fZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50KSk7XG4gIH1cblxuICBfb25DaGFuZ2UoKSB7XG4gICAgdGhpcy5kYXRlQ2hhbmdlLmVtaXQobmV3IE54RGF0ZXBpY2tlcklucHV0RXZlbnQodGhpcywgdGhpcy5fZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50KSk7XG4gIH1cblxuICBfZm9jdXMoKSB7XG4gICAgdGhpcy5fZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50LmZvY3VzKCk7XG4gIH1cblxuICBfb25CbHVyKCkge1xuICAgIC8vIFJlZm9ybWF0IHRoZSBpbnB1dCBvbmx5IGlmIHdlIGhhdmUgYSB2YWxpZCB2YWx1ZS5cbiAgICBpZiAodGhpcy52YWx1ZSkge1xuICAgICAgdGhpcy5fZm9ybWF0VmFsdWUodGhpcy52YWx1ZSk7XG4gICAgfVxuICAgIHRoaXMuX29uVG91Y2hlZCgpO1xuICB9XG5cbiAgLyoqIFJldHVybnMgdGhlIHZhbGlkYXRvcnMgb2YgdGhlIGRhdGVmaWVsZC4gKi9cbiAgZ2V0VmFsaWRhdG9ycygpOiBWYWxpZGF0b3JGbltdIHtcbiAgICByZXR1cm4gW1xuICAgICAgTnhEYXRlVmFsaWRhdG9ycy5wYXJzZSh0aGlzLl9kYXRlQWRhcHRlciwgdGhpcy5fZGF0ZUZvcm1hdHMsIHRoaXMuX2VsZW1lbnRSZWYubmF0aXZlRWxlbWVudCwgdGhpcy5fc3RyaWN0LCB0aGlzLl9wYXJzZUZvcm1hdCksXG4gICAgICBOeERhdGVWYWxpZGF0b3JzLm1pbih0aGlzLl9kYXRlQWRhcHRlciwgdGhpcy5taW4pLFxuICAgICAgTnhEYXRlVmFsaWRhdG9ycy5tYXgodGhpcy5fZGF0ZUFkYXB0ZXIsIHRoaXMubWF4KSxcbiAgICAgIE54RGF0ZVZhbGlkYXRvcnMuZmlsdGVyKHRoaXMuX2RhdGVBZGFwdGVyLCB0aGlzLl9kYXRlRmlsdGVyKVxuICAgIF07XG4gIH1cblxuICAvKiogRm9ybWF0cyBhIHZhbHVlIGFuZCBzZXRzIGl0IG9uIHRoZSBpbnB1dCBuYXRpdmUgZWxlbWVudC4gKi9cbiAgcHJpdmF0ZSBfZm9ybWF0VmFsdWUodmFsdWU6IEQgfCBudWxsKSB7XG4gICAgdGhpcy5fZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50LnZhbHVlID0gdmFsdWUgP1xuICAgICAgdGhpcy5fZGF0ZUFkYXB0ZXIuZm9ybWF0KHZhbHVlLCB0aGlzLl9kaXNwbGF5Rm9ybWF0IHx8IHRoaXMuX2RhdGVGb3JtYXRzLmRpc3BsYXkuZGF0ZUlucHV0KSA6ICcnO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSBvYmogVGhlIG9iamVjdCB0byBjaGVjay5cbiAgICogQHJldHVybnMgVGhlIGdpdmVuIG9iamVjdCBpZiBpdCBpcyBib3RoIGEgZGF0ZSBpbnN0YW5jZSBhbmQgdmFsaWQsIG90aGVyd2lzZSBudWxsLlxuICAgKi9cbiAgcHJpdmF0ZSBfZ2V0VmFsaWREYXRlT3JOdWxsKG9iajogYW55KTogRCB8IG51bGwge1xuICAgIHJldHVybiAodGhpcy5fZGF0ZUFkYXB0ZXIuaXNEYXRlSW5zdGFuY2Uob2JqKSAmJiB0aGlzLl9kYXRlQWRhcHRlci5pc1ZhbGlkKG9iaikpID8gb2JqIDogbnVsbDtcbiAgfVxufVxuIl19