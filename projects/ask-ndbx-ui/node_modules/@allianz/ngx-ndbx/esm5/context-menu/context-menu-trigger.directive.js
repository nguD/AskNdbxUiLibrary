/**
 * @fileoverview added by tsickle
 * Generated from: context-menu-trigger.directive.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import { Directionality } from '@angular/cdk/bidi';
import { LEFT_ARROW, RIGHT_ARROW } from '@angular/cdk/keycodes';
import { Overlay, OverlayConfig } from '@angular/cdk/overlay';
import { TemplatePortal } from '@angular/cdk/portal';
import { Directive, ElementRef, EventEmitter, Input, Optional, Output, Self, ViewContainerRef } from '@angular/core';
import { normalizePassiveListenerOptions } from '@angular/cdk/platform';
import { asapScheduler, merge, of as observableOf, Subscription, fromEvent } from 'rxjs';
import { delay, filter, take, takeUntil, map } from 'rxjs/operators';
import { NxContextMenuComponent } from './context-menu.component';
import { throwNxContextMenuMissingError } from './context-menu-errors';
import { NxContextMenuItemComponent } from './context-menu-item.component';
/**
 * Default top padding of the menu panel.
 * @type {?}
 */
export var MENU_PANEL_TOP_PADDING = 16;
/** @type {?} */
export var MENU_PANEL_OFFSET = 8;
/**
 * Options for binding a passive event listener.
 * @type {?}
 */
var passiveEventListenerOptions = normalizePassiveListenerOptions({
    passive: true
});
/**
 * This directive is intended to be used in conjunction with an nx-context-menu tag.
 * It is responsible for toggling the display of the provided context menu instance.
 */
var NxContextMenuTriggerDirective = /** @class */ (function () {
    function NxContextMenuTriggerDirective(_overlay, _element, _viewContainerRef, _parentMenu, _contextMenuItemInstance, _dir) {
        this._overlay = _overlay;
        this._element = _element;
        this._viewContainerRef = _viewContainerRef;
        this._parentMenu = _parentMenu;
        this._contextMenuItemInstance = _contextMenuItemInstance;
        this._dir = _dir;
        this._overlayRef = null;
        this._contextMenuOpen = false;
        this._closingActionsSubscription = Subscription.EMPTY;
        this._hoverSubscription = Subscription.EMPTY;
        this._contextMenuCloseSubscription = Subscription.EMPTY;
        /**
         * Event emitted when the associated context menu is opened.
         */
        this.contextMenuOpened = new EventEmitter();
        /**
         * Event emitted when the associated context menu is closed.
         */
        this.contextMenuClosed = new EventEmitter();
        if (_contextMenuItemInstance) {
            _contextMenuItemInstance._triggersSubmenu = this.triggersSubmenu();
        }
        this._scrollStrategy = this._overlay.scrollStrategies.reposition;
        this._documentClickObservable = fromEvent(document, 'click');
    }
    Object.defineProperty(NxContextMenuTriggerDirective.prototype, "contextMenu", {
        /** References the context menu instance that the trigger is associated with. */
        get: /**
         * References the context menu instance that the trigger is associated with.
         * @return {?}
         */
        function () {
            return this._contextMenu;
        },
        set: /**
         * @param {?} contextMenu
         * @return {?}
         */
        function (contextMenu) {
            var _this = this;
            if (contextMenu === this._contextMenu) {
                return;
            }
            this._contextMenu = contextMenu;
            this._contextMenuCloseSubscription.unsubscribe();
            if (contextMenu) {
                this._contextMenuCloseSubscription = contextMenu.closed
                    .asObservable()
                    .subscribe((/**
                 * @param {?} reason
                 * @return {?}
                 */
                function (reason) {
                    _this._destroyMenu();
                    // If a click closed the menu, we should close the entire chain of nested menus.
                    if ((reason === 'click' || reason === 'tab') && _this._parentMenu) {
                        _this._parentMenu.closed.emit(reason);
                    }
                }));
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NxContextMenuTriggerDirective.prototype, "scrollStrategy", {
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            if (value === 'close') {
                this._scrollStrategy = this._overlay.scrollStrategies.close;
            }
            else {
                this._scrollStrategy = this._overlay.scrollStrategies.reposition;
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NxContextMenuTriggerDirective.prototype, "contextMenuOpen", {
        /** Whether the context menu is open. */
        get: /**
         * Whether the context menu is open.
         * @return {?}
         */
        function () {
            return this._contextMenuOpen;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NxContextMenuTriggerDirective.prototype, "dir", {
        /** The text direction of the containing app. */
        get: /**
         * The text direction of the containing app.
         * @private
         * @return {?}
         */
        function () {
            return this._dir && this._dir.value === 'rtl' ? 'rtl' : 'ltr';
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @return {?}
     */
    NxContextMenuTriggerDirective.prototype.ngAfterContentInit = /**
     * @return {?}
     */
    function () {
        this._checkContextMenu();
        this._handleHover();
    };
    /**
     * @return {?}
     */
    NxContextMenuTriggerDirective.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        if (this._overlayRef) {
            this._overlayRef.dispose();
            this._overlayRef = null;
        }
        this._contextMenuCloseSubscription.unsubscribe();
        this._closingActionsSubscription.unsubscribe();
        this._hoverSubscription.unsubscribe();
    };
    /** Whether the context menu triggers a sub-menu or a top-level one. */
    /**
     * Whether the context menu triggers a sub-menu or a top-level one.
     * @return {?}
     */
    NxContextMenuTriggerDirective.prototype.triggersSubmenu = /**
     * Whether the context menu triggers a sub-menu or a top-level one.
     * @return {?}
     */
    function () {
        return !!(this._contextMenuItemInstance && this._parentMenu);
    };
    /** Toggles the context menu between the open and closed states. */
    /**
     * Toggles the context menu between the open and closed states.
     * @return {?}
     */
    NxContextMenuTriggerDirective.prototype.toggleContextMenu = /**
     * Toggles the context menu between the open and closed states.
     * @return {?}
     */
    function () {
        return this.contextMenuOpen
            ? this.closeContextMenu()
            : this.openContextMenu();
    };
    /** Opens the context menu. */
    /**
     * Opens the context menu.
     * @return {?}
     */
    NxContextMenuTriggerDirective.prototype.openContextMenu = /**
     * Opens the context menu.
     * @return {?}
     */
    function () {
        var _this = this;
        if (this.contextMenuOpen) {
            return;
        }
        this._checkContextMenu();
        /** @type {?} */
        var overlayRef = this._createOverlay();
        /** @type {?} */
        var overlayConfig = overlayRef.getConfig();
        this._setPosition((/** @type {?} */ (overlayConfig.positionStrategy)));
        overlayRef.attach(this._getPortal());
        if (this.contextMenu.lazyContent) {
            this.contextMenu.lazyContent.attach(this.contextMenuData);
        }
        this._closingActionsSubscription = this._contextMenuClosingActions().subscribe((/**
         * @return {?}
         */
        function () { return _this.closeContextMenu(); }));
        this._initContextMenu();
        if (this.contextMenu instanceof NxContextMenuComponent) {
            this.contextMenu._startAnimation();
        }
        this._waitForClose();
    };
    /** Closes the context menu. */
    /**
     * Closes the context menu.
     * @return {?}
     */
    NxContextMenuTriggerDirective.prototype.closeContextMenu = /**
     * Closes the context menu.
     * @return {?}
     */
    function () {
        this.contextMenu.closed.emit();
    };
    /** Closes the context menu and does the necessary cleanup. */
    /**
     * Closes the context menu and does the necessary cleanup.
     * @private
     * @return {?}
     */
    NxContextMenuTriggerDirective.prototype._destroyMenu = /**
     * Closes the context menu and does the necessary cleanup.
     * @private
     * @return {?}
     */
    function () {
        var _this = this;
        if (!this._overlayRef || !this.contextMenuOpen) {
            return;
        }
        /** @type {?} */
        var contextMenu = this.contextMenu;
        this._closingActionsSubscription.unsubscribe();
        this._overlayRef.detach();
        contextMenu._resetAnimation();
        if (contextMenu.lazyContent) {
            // Wait for the exit animation to finish before detaching the content.
            contextMenu._animationDone
                .pipe(filter((/**
             * @param {?} event
             * @return {?}
             */
            function (event) { return event.toState === 'void'; })), take(1), 
            // Interrupt if the content got re-attached.
            takeUntil(contextMenu.lazyContent._attached))
                .subscribe({
                next: (/**
                 * @return {?}
                 */
                function () {
                    return contextMenu.lazyContent && contextMenu.lazyContent.detach();
                }),
                // No matter whether the content got re-attached, reset the menu.
                complete: (/**
                 * @return {?}
                 */
                function () { return _this._resetContextMenu(); })
            });
        }
        else {
            this._resetContextMenu();
        }
    };
    /**
     * This method sets the context menu state to open and focuses the first item if
     * the context menu was opened via the keyboard.
     */
    /**
     * This method sets the context menu state to open and focuses the first item if
     * the context menu was opened via the keyboard.
     * @private
     * @return {?}
     */
    NxContextMenuTriggerDirective.prototype._initContextMenu = /**
     * This method sets the context menu state to open and focuses the first item if
     * the context menu was opened via the keyboard.
     * @private
     * @return {?}
     */
    function () {
        this.contextMenu.parentMenu = this.triggersSubmenu()
            ? this._parentMenu
            : undefined;
        this.contextMenu.direction = this.dir;
        this._setIsContextMenuOpen(true);
        this.contextMenu.focusFirstItem();
    };
    /**
     * Focuses the context menu trigger.
     */
    /**
     * Focuses the context menu trigger.
     * @return {?}
     */
    NxContextMenuTriggerDirective.prototype.focus = /**
     * Focuses the context menu trigger.
     * @return {?}
     */
    function () {
        this._element.nativeElement.focus();
    };
    /**
     * This method resets the context menu when it's closed, most importantly restoring
     * focus to the context menu trigger if the context menu was opened via the keyboard.
     */
    /**
     * This method resets the context menu when it's closed, most importantly restoring
     * focus to the context menu trigger if the context menu was opened via the keyboard.
     * @private
     * @return {?}
     */
    NxContextMenuTriggerDirective.prototype._resetContextMenu = /**
     * This method resets the context menu when it's closed, most importantly restoring
     * focus to the context menu trigger if the context menu was opened via the keyboard.
     * @private
     * @return {?}
     */
    function () {
        this._setIsContextMenuOpen(false);
        this.focus();
    };
    /** Set state rather than toggle to support triggers sharing a menu. */
    /**
     * Set state rather than toggle to support triggers sharing a menu.
     * @private
     * @param {?} isOpen
     * @return {?}
     */
    NxContextMenuTriggerDirective.prototype._setIsContextMenuOpen = /**
     * Set state rather than toggle to support triggers sharing a menu.
     * @private
     * @param {?} isOpen
     * @return {?}
     */
    function (isOpen) {
        this._contextMenuOpen = isOpen;
        this._contextMenuOpen
            ? this.contextMenuOpened.emit()
            : this.contextMenuClosed.emit();
        if (this.triggersSubmenu()) {
            this._contextMenuItemInstance._highlighted = isOpen;
        }
    };
    /**
     * This method checks that a valid instance of NxContextMenuComponent has been passed into
     * nxContextMenuTriggerFor. If not, an exception is thrown.
     */
    /**
     * This method checks that a valid instance of NxContextMenuComponent has been passed into
     * nxContextMenuTriggerFor. If not, an exception is thrown.
     * @private
     * @return {?}
     */
    NxContextMenuTriggerDirective.prototype._checkContextMenu = /**
     * This method checks that a valid instance of NxContextMenuComponent has been passed into
     * nxContextMenuTriggerFor. If not, an exception is thrown.
     * @private
     * @return {?}
     */
    function () {
        if (!this.contextMenu) {
            throwNxContextMenuMissingError();
        }
    };
    /**
     * This method creates the overlay from the provided menu's template and saves its
     * OverlayRef so that it can be attached to the DOM when openContextMenu is called.
     */
    /**
     * This method creates the overlay from the provided menu's template and saves its
     * OverlayRef so that it can be attached to the DOM when openContextMenu is called.
     * @private
     * @return {?}
     */
    NxContextMenuTriggerDirective.prototype._createOverlay = /**
     * This method creates the overlay from the provided menu's template and saves its
     * OverlayRef so that it can be attached to the DOM when openContextMenu is called.
     * @private
     * @return {?}
     */
    function () {
        if (!this._overlayRef) {
            /** @type {?} */
            var config = this._getOverlayConfig();
            this._overlayRef = this._overlay.create(config);
            // Consume the `keydownEvents` in order to prevent them from going to another overlay.
            this._overlayRef.keydownEvents().subscribe();
        }
        return this._overlayRef;
    };
    /**
     * This method builds the configuration object needed to create the overlay, the OverlayState.
     * @returns OverlayConfig
     */
    /**
     * This method builds the configuration object needed to create the overlay, the OverlayState.
     * @private
     * @return {?} OverlayConfig
     */
    NxContextMenuTriggerDirective.prototype._getOverlayConfig = /**
     * This method builds the configuration object needed to create the overlay, the OverlayState.
     * @private
     * @return {?} OverlayConfig
     */
    function () {
        return new OverlayConfig({
            positionStrategy: this._overlay
                .position()
                .flexibleConnectedTo(this._element)
                .withLockedPosition()
                .withFlexibleDimensions(false)
                .withTransformOriginOn('.nx-context-menu'),
            scrollStrategy: this._scrollStrategy(),
            direction: this._dir
        });
    };
    /**
     * Sets the appropriate positions on a position strategy
     * so the overlay connects with the trigger correctly.
     * @param positionStrategy Strategy whose position to update.
     */
    /**
     * Sets the appropriate positions on a position strategy
     * so the overlay connects with the trigger correctly.
     * @private
     * @param {?} positionStrategy Strategy whose position to update.
     * @return {?}
     */
    NxContextMenuTriggerDirective.prototype._setPosition = /**
     * Sets the appropriate positions on a position strategy
     * so the overlay connects with the trigger correctly.
     * @private
     * @param {?} positionStrategy Strategy whose position to update.
     * @return {?}
     */
    function (positionStrategy) {
        /** @type {?} */
        var originX = 'start';
        /** @type {?} */
        var originFallbackX = 'end';
        /** @type {?} */
        var overlayY = 'top';
        /** @type {?} */
        var overlayFallbackY = 'bottom';
        /** @type {?} */
        var originY = overlayY;
        /** @type {?} */
        var originFallbackY = overlayFallbackY;
        /** @type {?} */
        var overlayX = originX;
        /** @type {?} */
        var overlayFallbackX = originFallbackX;
        /** @type {?} */
        var offsetY = 0;
        if (this.triggersSubmenu()) {
            // When the menu is a sub-menu, it should always align itself
            // to the edges of the trigger, instead of overlapping it.
            overlayFallbackX = originX = 'end';
            originFallbackX = overlayX = 'start';
            offsetY = -MENU_PANEL_TOP_PADDING;
        }
        else {
            offsetY = MENU_PANEL_OFFSET;
            originY = 'bottom';
            originFallbackY = 'top';
        }
        positionStrategy.withPositions((/** @type {?} */ ([
            { originX: originX, originY: originY, overlayX: overlayX, overlayY: overlayY, offsetY: offsetY },
            {
                originX: originFallbackX,
                originY: originY,
                overlayX: overlayFallbackX,
                overlayY: overlayY,
                offsetY: offsetY
            },
            {
                originX: originX,
                originY: originFallbackY,
                overlayX: overlayX,
                overlayY: overlayFallbackY,
                offsetY: -offsetY
            },
            {
                originX: originFallbackX,
                originY: originFallbackY,
                overlayX: overlayFallbackX,
                overlayY: overlayFallbackY,
                offsetY: -offsetY
            }
        ])));
    };
    /**
     * Returns a stream that emits whenever an action that should close the context menu occurs. */
    /**
     * Returns a stream that emits whenever an action that should close the context menu occurs.
     * @private
     * @return {?}
     */
    NxContextMenuTriggerDirective.prototype._contextMenuClosingActions = /**
     * Returns a stream that emits whenever an action that should close the context menu occurs.
     * @private
     * @return {?}
     */
    function () {
        var _this = this;
        /** @type {?} */
        var backdrop;
        /** @type {?} */
        var detachments;
        if (this._overlayRef) {
            backdrop = this._overlayRef.backdropClick();
            detachments = this._overlayRef.detachments();
        }
        /** @type {?} */
        var parentClose = this._parentMenu
            ? this._parentMenu.closed
            : observableOf();
        /** @type {?} */
        var hover = this._parentMenu
            ? this._parentMenu._hovered().pipe(filter((/**
             * @param {?} active
             * @return {?}
             */
            function (active) { return active !== _this._contextMenuItemInstance; })), filter((/**
             * @return {?}
             */
            function () { return _this._contextMenuOpen; })))
            : observableOf();
        return merge(backdrop, parentClose, hover, detachments);
    };
    /** Handles mouse presses on the trigger. */
    /**
     * Handles mouse presses on the trigger.
     * @param {?} event
     * @return {?}
     */
    NxContextMenuTriggerDirective.prototype._handleMousedown = /**
     * Handles mouse presses on the trigger.
     * @param {?} event
     * @return {?}
     */
    function (event) {
        // Since right or middle button clicks won't trigger the `click` event,
        // we shouldn't consider the menu as opened by mouse in those cases.
        // this._openedBy = event.button === 0 ? 'mouse' : null;
        // Since clicking on the trigger won't close the menu if it opens a sub-menu,
        // we should prevent focus from moving onto it via click to avoid the
        // highlight from lingering on the menu item.
        if (this.triggersSubmenu()) {
            event.preventDefault();
        }
    };
    /** Handles key presses on the trigger. */
    /**
     * Handles key presses on the trigger.
     * @param {?} event
     * @return {?}
     */
    NxContextMenuTriggerDirective.prototype._handleKeydown = /**
     * Handles key presses on the trigger.
     * @param {?} event
     * @return {?}
     */
    function (event) {
        /** @type {?} */
        var keyCode = event.keyCode;
        if (this.triggersSubmenu() &&
            ((keyCode === RIGHT_ARROW && this.dir === 'ltr') ||
                (keyCode === LEFT_ARROW && this.dir === 'rtl'))) {
            this.openContextMenu();
        }
    };
    /** Handles click events on the trigger. */
    /**
     * Handles click events on the trigger.
     * @param {?} event
     * @return {?}
     */
    NxContextMenuTriggerDirective.prototype._handleClick = /**
     * Handles click events on the trigger.
     * @param {?} event
     * @return {?}
     */
    function (event) {
        if (this.triggersSubmenu()) {
            // Stop event propagation to avoid closing the parent menu.
            event.stopPropagation();
            this.openContextMenu();
        }
        else {
            this.toggleContextMenu();
        }
    };
    /* Subscribes to document clicks to close the context menu on clicks on the background. */
    /* Subscribes to document clicks to close the context menu on clicks on the background. */
    /**
     * @private
     * @return {?}
     */
    NxContextMenuTriggerDirective.prototype._waitForClose = /* Subscribes to document clicks to close the context menu on clicks on the background. */
    /**
     * @private
     * @return {?}
     */
    function () {
        var _this = this;
        return this._documentClickObservable
            .pipe(map((/**
         * @param {?} event
         * @return {?}
         */
        function (event) { return event.target; })), filter((/**
         * @param {?} target
         * @return {?}
         */
        function (target) { return !_this._element.nativeElement.contains(target); })), takeUntil(this.contextMenu.closed))
            .subscribe((/**
         * @return {?}
         */
        function () {
            _this.closeContextMenu();
        }));
    };
    /** Handles the cases where the user hovers over the trigger. */
    /**
     * Handles the cases where the user hovers over the trigger.
     * @private
     * @return {?}
     */
    NxContextMenuTriggerDirective.prototype._handleHover = /**
     * Handles the cases where the user hovers over the trigger.
     * @private
     * @return {?}
     */
    function () {
        var _this = this;
        // Subscribe to changes in the hovered item in order to toggle the panel.
        if (!this.triggersSubmenu()) {
            return;
        }
        this._hoverSubscription = this._parentMenu
            ._hovered()
            // Since we might have multiple competing triggers for the same menu (e.g. a sub-menu
            // with different data and triggers), we have to delay it by a tick to ensure that
            // it won't be closed immediately after it is opened.
            .pipe(filter((/**
         * @param {?} active
         * @return {?}
         */
        function (active) { return active === _this._contextMenuItemInstance && !active.disabled; })), delay(0, asapScheduler))
            .subscribe((/**
         * @return {?}
         */
        function () {
            // If the same menu is used between multiple triggers, it might still be animating
            // while the new trigger tries to re-open it. Wait for the animation to finish
            // before doing so. Also interrupt if the user moves to another item.
            if (_this.contextMenu._isAnimating) {
                // We need the `delay(0)` here in order to avoid
                // 'changed after checked' errors in some cases.
                _this.contextMenu._animationDone
                    .pipe(take(1), delay(0, asapScheduler), takeUntil(_this._parentMenu._hovered()))
                    .subscribe((/**
                 * @return {?}
                 */
                function () { return _this.openContextMenu(); }));
            }
            else {
                _this.openContextMenu();
            }
        }));
    };
    /** Gets the portal that should be attached to the overlay. */
    /**
     * Gets the portal that should be attached to the overlay.
     * @private
     * @return {?}
     */
    NxContextMenuTriggerDirective.prototype._getPortal = /**
     * Gets the portal that should be attached to the overlay.
     * @private
     * @return {?}
     */
    function () {
        // Note that we can avoid this check by keeping the portal on the context menu panel.
        // While it would be cleaner, we'd have to introduce another required method on
        // `NxContextMenuPanelComponent`, making it harder to consume.
        if (!this._portal ||
            this._portal.templateRef !== this.contextMenu.templateRef) {
            this._portal = new TemplatePortal(this.contextMenu.templateRef, this._viewContainerRef);
        }
        return this._portal;
    };
    NxContextMenuTriggerDirective.decorators = [
        { type: Directive, args: [{
                    selector: "[nxContextMenuTriggerFor]",
                    host: {
                        'aria-haspopup': 'true',
                        '[attr.aria-expanded]': 'contextMenuOpen || null',
                        '(mousedown)': '_handleMousedown($event)',
                        '(keydown)': '_handleKeydown($event)',
                        '(click)': '_handleClick($event)'
                    },
                    exportAs: 'nxContextMenuTrigger'
                },] }
    ];
    /** @nocollapse */
    NxContextMenuTriggerDirective.ctorParameters = function () { return [
        { type: Overlay },
        { type: ElementRef },
        { type: ViewContainerRef },
        { type: NxContextMenuComponent, decorators: [{ type: Optional }] },
        { type: NxContextMenuItemComponent, decorators: [{ type: Optional }, { type: Self }] },
        { type: Directionality, decorators: [{ type: Optional }] }
    ]; };
    NxContextMenuTriggerDirective.propDecorators = {
        contextMenu: [{ type: Input, args: ['nxContextMenuTriggerFor',] }],
        scrollStrategy: [{ type: Input }],
        contextMenuData: [{ type: Input, args: ['nxContextMenuTriggerData',] }],
        contextMenuOpened: [{ type: Output }],
        contextMenuClosed: [{ type: Output }]
    };
    return NxContextMenuTriggerDirective;
}());
export { NxContextMenuTriggerDirective };
if (false) {
    /**
     * @type {?}
     * @private
     */
    NxContextMenuTriggerDirective.prototype._portal;
    /**
     * @type {?}
     * @private
     */
    NxContextMenuTriggerDirective.prototype._overlayRef;
    /**
     * @type {?}
     * @private
     */
    NxContextMenuTriggerDirective.prototype._contextMenuOpen;
    /**
     * @type {?}
     * @private
     */
    NxContextMenuTriggerDirective.prototype._closingActionsSubscription;
    /**
     * @type {?}
     * @private
     */
    NxContextMenuTriggerDirective.prototype._hoverSubscription;
    /**
     * @type {?}
     * @private
     */
    NxContextMenuTriggerDirective.prototype._contextMenuCloseSubscription;
    /**
     * @type {?}
     * @private
     */
    NxContextMenuTriggerDirective.prototype._documentClickObservable;
    /**
     * @type {?}
     * @private
     */
    NxContextMenuTriggerDirective.prototype._scrollStrategy;
    /**
     * @type {?}
     * @private
     */
    NxContextMenuTriggerDirective.prototype._contextMenu;
    /**
     * Data to be passed along to any lazily-rendered content.
     * @type {?}
     */
    NxContextMenuTriggerDirective.prototype.contextMenuData;
    /**
     * Event emitted when the associated context menu is opened.
     * @type {?}
     */
    NxContextMenuTriggerDirective.prototype.contextMenuOpened;
    /**
     * Event emitted when the associated context menu is closed.
     * @type {?}
     */
    NxContextMenuTriggerDirective.prototype.contextMenuClosed;
    /**
     * @type {?}
     * @private
     */
    NxContextMenuTriggerDirective.prototype._overlay;
    /**
     * @type {?}
     * @private
     */
    NxContextMenuTriggerDirective.prototype._element;
    /**
     * @type {?}
     * @private
     */
    NxContextMenuTriggerDirective.prototype._viewContainerRef;
    /**
     * @type {?}
     * @private
     */
    NxContextMenuTriggerDirective.prototype._parentMenu;
    /**
     * @type {?}
     * @private
     */
    NxContextMenuTriggerDirective.prototype._contextMenuItemInstance;
    /**
     * @type {?}
     * @private
     */
    NxContextMenuTriggerDirective.prototype._dir;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY29udGV4dC1tZW51LXRyaWdnZXIuZGlyZWN0aXZlLmpzIiwic291cmNlUm9vdCI6Im5nOi8vQGFsbGlhbnovbmd4LW5kYngvY29udGV4dC1tZW51LyIsInNvdXJjZXMiOlsiY29udGV4dC1tZW51LXRyaWdnZXIuZGlyZWN0aXZlLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7O0FBQUEsT0FBTyxFQUFhLGNBQWMsRUFBRSxNQUFNLG1CQUFtQixDQUFDO0FBQzlELE9BQU8sRUFBRSxVQUFVLEVBQUUsV0FBVyxFQUFFLE1BQU0sdUJBQXVCLENBQUM7QUFDaEUsT0FBTyxFQUVMLE9BQU8sRUFDUCxhQUFhLEVBSWQsTUFBTSxzQkFBc0IsQ0FBQztBQUM5QixPQUFPLEVBQUUsY0FBYyxFQUFFLE1BQU0scUJBQXFCLENBQUM7QUFDckQsT0FBTyxFQUVMLFNBQVMsRUFDVCxVQUFVLEVBQ1YsWUFBWSxFQUNaLEtBQUssRUFFTCxRQUFRLEVBQ1IsTUFBTSxFQUNOLElBQUksRUFDSixnQkFBZ0IsRUFDakIsTUFBTSxlQUFlLENBQUM7QUFDdkIsT0FBTyxFQUFFLCtCQUErQixFQUFFLE1BQU0sdUJBQXVCLENBQUM7QUFDeEUsT0FBTyxFQUFFLGFBQWEsRUFBRSxLQUFLLEVBQUUsRUFBRSxJQUFJLFlBQVksRUFBRSxZQUFZLEVBQUUsU0FBUyxFQUFjLE1BQU0sTUFBTSxDQUFDO0FBQ3JHLE9BQU8sRUFBRSxLQUFLLEVBQUUsTUFBTSxFQUFFLElBQUksRUFBRSxTQUFTLEVBQUUsR0FBRyxFQUFFLE1BQU0sZ0JBQWdCLENBQUM7QUFDckUsT0FBTyxFQUFFLHNCQUFzQixFQUFFLE1BQU0sMEJBQTBCLENBQUM7QUFDbEUsT0FBTyxFQUFFLDhCQUE4QixFQUFFLE1BQU0sdUJBQXVCLENBQUM7QUFDdkUsT0FBTyxFQUFFLDBCQUEwQixFQUFFLE1BQU0sK0JBQStCLENBQUM7Ozs7O0FBRzNFLE1BQU0sS0FBTyxzQkFBc0IsR0FBRyxFQUFFOztBQUV4QyxNQUFNLEtBQU8saUJB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QkFwREMsT0FBTztnQkFVUCxVQUFVO2dCQU9WLGdCQUFnQjtnQkFLVCxzQkFBc0IsdUJBc0d4QixRQUFRO2dCQXBHTiwwQkFBMEIsdUJBcUc1QixRQUFRLFlBQ1IsSUFBSTtnQkFsSVMsY0FBYyx1QkFvSTNCLFFBQVE7Ozs4QkEvRFosS0FBSyxTQUFDLHlCQUF5QjtpQ0EyQi9CLEtBQUs7a0NBb0JMLEtBQUssU0FBQywwQkFBMEI7b0NBR2hDLE1BQU07b0NBR04sTUFBTTs7SUE4WFQsb0NBQUM7Q0FBQSxBQTFjRCxJQTBjQztTQS9iWSw2QkFBNkI7Ozs7OztJQUV4QyxnREFBZ0M7Ozs7O0lBQ2hDLG9EQUE4Qzs7Ozs7SUFDOUMseURBQTBDOzs7OztJQUMxQyxvRUFBeUQ7Ozs7O0lBQ3pELDJEQUFnRDs7Ozs7SUFDaEQsc0VBQTJEOzs7OztJQUMzRCxpRUFBeUQ7Ozs7O0lBQ3pELHdEQUE4Qzs7Ozs7SUE0QjlDLHFEQUE2Qzs7Ozs7SUFzQjdDLHdEQUF3RDs7Ozs7SUFHeEQsMERBQW9GOzs7OztJQUdwRiwwREFBb0Y7Ozs7O0lBR2hGLGlEQUF5Qjs7Ozs7SUFDekIsaURBQXlDOzs7OztJQUN6QywwREFBMkM7Ozs7O0lBQzNDLG9EQUF1RDs7Ozs7SUFDdkQsaUVBRTREOzs7OztJQUM1RCw2Q0FBd0MiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBEaXJlY3Rpb24sIERpcmVjdGlvbmFsaXR5IH0gZnJvbSAnQGFuZ3VsYXIvY2RrL2JpZGknO1xuaW1wb3J0IHsgTEVGVF9BUlJPVywgUklHSFRfQVJST1cgfSBmcm9tICdAYW5ndWxhci9jZGsva2V5Y29kZXMnO1xuaW1wb3J0IHtcbiAgRmxleGlibGVDb25uZWN0ZWRQb3NpdGlvblN0cmF0ZWd5LFxuICBPdmVybGF5LFxuICBPdmVybGF5Q29uZmlnLFxuICBPdmVybGF5UmVmLFxuICBTY3JvbGxTdHJhdGVneSxcbiAgQ29ubmVjdGVkUG9zaXRpb25cbn0gZnJvbSAnQGFuZ3VsYXIvY2RrL292ZXJsYXknO1xuaW1wb3J0IHsgVGVtcGxhdGVQb3J0YWwgfSBmcm9tICdAYW5ndWxhci9jZGsvcG9ydGFsJztcbmltcG9ydCB7XG4gIEFmdGVyQ29udGVudEluaXQsXG4gIERpcmVjdGl2ZSxcbiAgRWxlbWVudFJlZixcbiAgRXZlbnRFbWl0dGVyLFxuICBJbnB1dCxcbiAgT25EZXN0cm95LFxuICBPcHRpb25hbCxcbiAgT3V0cHV0LFxuICBTZWxmLFxuICBWaWV3Q29udGFpbmVyUmVmXG59IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgbm9ybWFsaXplUGFzc2l2ZUxpc3RlbmVyT3B0aW9ucyB9IGZyb20gJ0Bhbmd1bGFyL2Nkay9wbGF0Zm9ybSc7XG5pbXBvcnQgeyBhc2FwU2NoZWR1bGVyLCBtZXJnZSwgb2YgYXMgb2JzZXJ2YWJsZU9mLCBTdWJzY3JpcHRpb24sIGZyb21FdmVudCwgT2JzZXJ2YWJsZSB9IGZyb20gJ3J4anMnO1xuaW1wb3J0IHsgZGVsYXksIGZpbHRlciwgdGFrZSwgdGFrZVVudGlsLCBtYXAgfSBmcm9tICdyeGpzL29wZXJhdG9ycyc7XG5pbXBvcnQgeyBOeENvbnRleHRNZW51Q29tcG9uZW50IH0gZnJvbSAnLi9jb250ZXh0LW1lbnUuY29tcG9uZW50JztcbmltcG9ydCB7IHRocm93TnhDb250ZXh0TWVudU1pc3NpbmdFcnJvciB9IGZyb20gJy4vY29udGV4dC1tZW51LWVycm9ycyc7XG5pbXBvcnQgeyBOeENvbnRleHRNZW51SXRlbUNvbXBvbmVudCB9IGZyb20gJy4vY29udGV4dC1tZW51LWl0ZW0uY29tcG9uZW50JztcblxuLyoqIERlZmF1bHQgdG9wIHBhZGRpbmcgb2YgdGhlIG1lbnUgcGFuZWwuICovXG5leHBvcnQgY29uc3QgTUVOVV9QQU5FTF9UT1BfUEFERElORyA9IDE2O1xuXG5leHBvcnQgY29uc3QgTUVOVV9QQU5FTF9PRkZTRVQgPSA4O1xuXG5leHBvcnQgdHlwZSBOeENvbnRleHRNZW51U2Nyb2xsU3RyYXRlZ3kgPSAnY2xvc2UnIHwgJ3JlcG9zaXRpb24nO1xuXG4vKiogT3B0aW9ucyBmb3IgYmluZGluZyBhIHBhc3NpdmUgZXZlbnQgbGlzdGVuZXIuICovXG5jb25zdCBwYXNzaXZlRXZlbnRMaXN0ZW5lck9wdGlvbnMgPSBub3JtYWxpemVQYXNzaXZlTGlzdGVuZXJPcHRpb25zKHtcbiAgcGFzc2l2ZTogdHJ1ZVxufSk7XG5cbi8qKlxuICogVGhpcyBkaXJlY3RpdmUgaXMgaW50ZW5kZWQgdG8gYmUgdXNlZCBpbiBjb25qdW5jdGlvbiB3aXRoIGFuIG54LWNvbnRleHQtbWVudSB0YWcuXG4gKiBJdCBpcyByZXNwb25zaWJsZSBmb3IgdG9nZ2xpbmcgdGhlIGRpc3BsYXkgb2YgdGhlIHByb3ZpZGVkIGNvbnRleHQgbWVudSBpbnN0YW5jZS5cbiAqL1xuQERpcmVjdGl2ZSh7XG4gIHNlbGVjdG9yOiBgW254Q29udGV4dE1lbnVUcmlnZ2VyRm9yXWAsXG4gIGhvc3Q6IHtcbiAgICAnYXJpYS1oYXNwb3B1cCc6ICd0cnVlJyxcbiAgICAnW2F0dHIuYXJpYS1leHBhbmRlZF0nOiAnY29udGV4dE1lbnVPcGVuIHx8IG51bGwnLFxuICAgICcobW91c2Vkb3duKSc6ICdfaGFuZGxlTW91c2Vkb3duKCRldmVudCknLFxuICAgICcoa2V5ZG93biknOiAnX2hhbmRsZUtleWRvd24oJGV2ZW50KScsXG4gICAgJyhjbGljayknOiAnX2hhbmRsZUNsaWNrKCRldmVudCknXG4gIH0sXG4gIGV4cG9ydEFzOiAnbnhDb250ZXh0TWVudVRyaWdnZXInXG59KVxuZXhwb3J0IGNsYXNzIE54Q29udGV4dE1lbnVUcmlnZ2VyRGlyZWN0aXZlXG4gIGltcGxlbWVudHMgQWZ0ZXJDb250ZW50SW5pdCwgT25EZXN0cm95IHtcbiAgcHJpdmF0ZSBfcG9ydGFsOiBUZW1wbGF0ZVBvcnRhbDtcbiAgcHJpdmF0ZSBfb3ZlcmxheVJlZjogT3ZlcmxheVJlZiB8IG51bGwgPSBudWxsO1xuICBwcml2YXRlIF9jb250ZXh0TWVudU9wZW46IGJvb2xlYW4gPSBmYWxzZTtcbiAgcHJpdmF0ZSBfY2xvc2luZ0FjdGlvbnNTdWJzY3JpcHRpb24gPSBTdWJzY3JpcHRpb24uRU1QVFk7XG4gIHByaXZhdGUgX2hvdmVyU3Vic2NyaXB0aW9uID0gU3Vic2NyaXB0aW9uLkVNUFRZO1xuICBwcml2YXRlIF9jb250ZXh0TWVudUNsb3NlU3Vic2NyaXB0aW9uID0gU3Vic2NyaXB0aW9uLkVNUFRZO1xuICBwcml2YXRlIF9kb2N1bWVudENsaWNrT2JzZXJ2YWJsZTogT2JzZXJ2YWJsZTxNb3VzZUV2ZW50PjtcbiAgcHJpdmF0ZSBfc2Nyb2xsU3RyYXRlZ3k6ICgpID0+IFNjcm9sbFN0cmF0ZWd5O1xuXG4gIC8qKiBSZWZlcmVuY2VzIHRoZSBjb250ZXh0IG1lbnUgaW5zdGFuY2UgdGhhdCB0aGUgdHJpZ2dlciBpcyBhc3NvY2lhdGVkIHdpdGguICovXG4gIEBJbnB1dCgnbnhDb250ZXh0TWVudVRyaWdnZXJGb3InKVxuICBnZXQgY29udGV4dE1lbnUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2NvbnRleHRNZW51O1xuICB9XG4gIHNldCBjb250ZXh0TWVudShjb250ZXh0TWVudTogTnhDb250ZXh0TWVudUNvbXBvbmVudCkge1xuICAgIGlmIChjb250ZXh0TWVudSA9PT0gdGhpcy5fY29udGV4dE1lbnUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLl9jb250ZXh0TWVudSA9IGNvbnRleHRNZW51O1xuICAgIHRoaXMuX2NvbnRleHRNZW51Q2xvc2VTdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcblxuICAgIGlmIChjb250ZXh0TWVudSkge1xuICAgICAgdGhpcy5fY29udGV4dE1lbnVDbG9zZVN1YnNjcmlwdGlvbiA9IGNvbnRleHRNZW51LmNsb3NlZFxuICAgICAgICAuYXNPYnNlcnZhYmxlKClcbiAgICAgICAgLnN1YnNjcmliZShyZWFzb24gPT4ge1xuICAgICAgICAgIHRoaXMuX2Rlc3Ryb3lNZW51KCk7XG5cbiAgICAgICAgICAvLyBJZiBhIGNsaWNrIGNsb3NlZCB0aGUgbWVudSwgd2Ugc2hvdWxkIGNsb3NlIHRoZSBlbnRpcmUgY2hhaW4gb2YgbmVzdGVkIG1lbnVzLlxuICAgICAgICAgIGlmICgocmVhc29uID09PSAnY2xpY2snIHx8IHJlYXNvbiA9PT0gJ3RhYicpICYmIHRoaXMuX3BhcmVudE1lbnUpIHtcbiAgICAgICAgICAgIHRoaXMuX3BhcmVudE1lbnUuY2xvc2VkLmVtaXQocmVhc29uKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgfVxuICBwcml2YXRlIF9jb250ZXh0TWVudTogTnhDb250ZXh0TWVudUNvbXBvbmVudDtcblxuICBASW5wdXQoKVxuICBzZXQgc2Nyb2xsU3RyYXRlZ3kodmFsdWU6IE54Q29udGV4dE1lbnVTY3JvbGxTdHJhdGVneSkge1xuICAgIGlmICh2YWx1ZSA9PT0gJ2Nsb3NlJykge1xuICAgICAgdGhpcy5fc2Nyb2xsU3RyYXRlZ3kgPSB0aGlzLl9vdmVybGF5LnNjcm9sbFN0cmF0ZWdpZXMuY2xvc2U7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX3Njcm9sbFN0cmF0ZWd5ID0gdGhpcy5fb3ZlcmxheS5zY3JvbGxTdHJhdGVnaWVzLnJlcG9zaXRpb247XG4gICAgfVxuICB9XG5cbiAgLyoqIFdoZXRoZXIgdGhlIGNvbnRleHQgbWVudSBpcyBvcGVuLiAqL1xuICBnZXQgY29udGV4dE1lbnVPcGVuKCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0aGlzLl9jb250ZXh0TWVudU9wZW47XG4gIH1cblxuICAvKiogVGhlIHRleHQgZGlyZWN0aW9uIG9mIHRoZSBjb250YWluaW5nIGFwcC4gKi9cbiAgcHJpdmF0ZSBnZXQgZGlyKCk6IERpcmVjdGlvbiB7XG4gICAgcmV0dXJuIHRoaXMuX2RpciAmJiB0aGlzLl9kaXIudmFsdWUgPT09ICdydGwnID8gJ3J0bCcgOiAnbHRyJztcbiAgfVxuXG4gIC8qKiBEYXRhIHRvIGJlIHBhc3NlZCBhbG9uZyB0byBhbnkgbGF6aWx5LXJlbmRlcmVkIGNvbnRlbnQuICovXG4gIEBJbnB1dCgnbnhDb250ZXh0TWVudVRyaWdnZXJEYXRhJykgY29udGV4dE1lbnVEYXRhOiBhbnk7XG5cbiAgLyoqIEV2ZW50IGVtaXR0ZWQgd2hlbiB0aGUgYXNzb2NpYXRlZCBjb250ZXh0IG1lbnUgaXMgb3BlbmVkLiAqL1xuICBAT3V0cHV0KCkgcmVhZG9ubHkgY29udGV4dE1lbnVPcGVuZWQ6IEV2ZW50RW1pdHRlcjx2b2lkPiA9IG5ldyBFdmVudEVtaXR0ZXI8dm9pZD4oKTtcblxuICAvKiogRXZlbnQgZW1pdHRlZCB3aGVuIHRoZSBhc3NvY2lhdGVkIGNvbnRleHQgbWVudSBpcyBjbG9zZWQuICovXG4gIEBPdXRwdXQoKSByZWFkb25seSBjb250ZXh0TWVudUNsb3NlZDogRXZlbnRFbWl0dGVyPHZvaWQ+ID0gbmV3IEV2ZW50RW1pdHRlcjx2b2lkPigpO1xuXG4gIGNvbnN0cnVjdG9yKFxuICAgICAgcHJpdmF0ZSBfb3ZlcmxheTogT3ZlcmxheSxcbiAgICAgIHByaXZhdGUgX2VsZW1lbnQ6IEVsZW1lbnRSZWY8SFRNTEVsZW1lbnQ+LFxuICAgICAgcHJpdmF0ZSBfdmlld0NvbnRhaW5lclJlZjogVmlld0NvbnRhaW5lclJlZixcbiAgICAgIEBPcHRpb25hbCgpIHByaXZhdGUgX3BhcmVudE1lbnU6IE54Q29udGV4dE1lbnVDb21wb25lbnQsXG4gICAgICBAT3B0aW9uYWwoKVxuICAgICAgQFNlbGYoKVxuICAgICAgcHJpdmF0ZSBfY29udGV4dE1lbnVJdGVtSW5zdGFuY2U6IE54Q29udGV4dE1lbnVJdGVtQ29tcG9uZW50LFxuICAgICAgQE9wdGlvbmFsKCkgcHJpdmF0ZSBfZGlyOiBEaXJlY3Rpb25hbGl0eSkge1xuXG4gICAgaWYgKF9jb250ZXh0TWVudUl0ZW1JbnN0YW5jZSkge1xuICAgICAgX2NvbnRleHRNZW51SXRlbUluc3RhbmNlLl90cmlnZ2Vyc1N1Ym1lbnUgPSB0aGlzLnRyaWdnZXJzU3VibWVudSgpO1xuICAgIH1cblxuICAgIHRoaXMuX3Njcm9sbFN0cmF0ZWd5ID0gdGhpcy5fb3ZlcmxheS5zY3JvbGxTdHJhdGVnaWVzLnJlcG9zaXRpb247XG4gICAgdGhpcy5fZG9jdW1lbnRDbGlja09ic2VydmFibGUgPSBmcm9tRXZlbnQ8TW91c2VFdmVudD4oZG9jdW1lbnQsICdjbGljaycpO1xuICB9XG5cbiAgbmdBZnRlckNvbnRlbnRJbml0KCkge1xuICAgIHRoaXMuX2NoZWNrQ29udGV4dE1lbnUoKTtcbiAgICB0aGlzLl9oYW5kbGVIb3ZlcigpO1xuICB9XG5cbiAgbmdPbkRlc3Ryb3koKSB7XG4gICAgaWYgKHRoaXMuX292ZXJsYXlSZWYpIHtcbiAgICAgIHRoaXMuX292ZXJsYXlSZWYuZGlzcG9zZSgpO1xuICAgICAgdGhpcy5fb3ZlcmxheVJlZiA9IG51bGw7XG4gICAgfVxuXG4gICAgdGhpcy5fY29udGV4dE1lbnVDbG9zZVN1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xuICAgIHRoaXMuX2Nsb3NpbmdBY3Rpb25zU3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XG4gICAgdGhpcy5faG92ZXJTdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcbiAgfVxuXG4gIC8qKiBXaGV0aGVyIHRoZSBjb250ZXh0IG1lbnUgdHJpZ2dlcnMgYSBzdWItbWVudSBvciBhIHRvcC1sZXZlbCBvbmUuICovXG4gIHRyaWdnZXJzU3VibWVudSgpOiBib29sZWFuIHtcbiAgICByZXR1cm4gISEodGhpcy5fY29udGV4dE1lbnVJdGVtSW5zdGFuY2UgJiYgdGhpcy5fcGFyZW50TWVudSk7XG4gIH1cblxuICAvKiogVG9nZ2xlcyB0aGUgY29udGV4dCBtZW51IGJldHdlZW4gdGhlIG9wZW4gYW5kIGNsb3NlZCBzdGF0ZXMuICovXG4gIHRvZ2dsZUNvbnRleHRNZW51KCk6IHZvaWQge1xuICAgIHJldHVybiB0aGlzLmNvbnRleHRNZW51T3BlblxuICAgICAgPyB0aGlzLmNsb3NlQ29udGV4dE1lbnUoKVxuICAgICAgOiB0aGlzLm9wZW5Db250ZXh0TWVudSgpO1xuICB9XG5cbiAgLyoqIE9wZW5zIHRoZSBjb250ZXh0IG1lbnUuICovXG4gIG9wZW5Db250ZXh0TWVudSgpOiB2b2lkIHtcbiAgICBpZiAodGhpcy5jb250ZXh0TWVudU9wZW4pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLl9jaGVja0NvbnRleHRNZW51KCk7XG5cbiAgICBjb25zdCBvdmVybGF5UmVmID0gdGhpcy5fY3JlYXRlT3ZlcmxheSgpO1xuICAgIGNvbnN0IG92ZXJsYXlDb25maWcgPSBvdmVybGF5UmVmLmdldENvbmZpZygpO1xuXG4gICAgdGhpcy5fc2V0UG9zaXRpb24oXG4gICAgICBvdmVybGF5Q29uZmlnLnBvc2l0aW9uU3RyYXRlZ3kgYXMgRmxleGlibGVDb25uZWN0ZWRQb3NpdGlvblN0cmF0ZWd5XG4gICAgKTtcbiAgICBvdmVybGF5UmVmLmF0dGFjaCh0aGlzLl9nZXRQb3J0YWwoKSk7XG5cbiAgICBpZiAodGhpcy5jb250ZXh0TWVudS5sYXp5Q29udGVudCkge1xuICAgICAgdGhpcy5jb250ZXh0TWVudS5sYXp5Q29udGVudC5hdHRhY2godGhpcy5jb250ZXh0TWVudURhdGEpO1xuICAgIH1cblxuICAgIHRoaXMuX2Nsb3NpbmdBY3Rpb25zU3Vic2NyaXB0aW9uID0gdGhpcy5fY29udGV4dE1lbnVDbG9zaW5nQWN0aW9ucygpLnN1YnNjcmliZShcbiAgICAgICgpID0+IHRoaXMuY2xvc2VDb250ZXh0TWVudSgpXG4gICAgKTtcbiAgICB0aGlzLl9pbml0Q29udGV4dE1lbnUoKTtcblxuICAgIGlmICh0aGlzLmNvbnRleHRNZW51IGluc3RhbmNlb2YgTnhDb250ZXh0TWVudUNvbXBvbmVudCkge1xuICAgICAgdGhpcy5jb250ZXh0TWVudS5fc3RhcnRBbmltYXRpb24oKTtcbiAgICB9XG5cbiAgICB0aGlzLl93YWl0Rm9yQ2xvc2UoKTtcbiAgfVxuXG4gIC8qKiBDbG9zZXMgdGhlIGNvbnRleHQgbWVudS4gKi9cbiAgY2xvc2VDb250ZXh0TWVudSgpOiB2b2lkIHtcbiAgICB0aGlzLmNvbnRleHRNZW51LmNsb3NlZC5lbWl0KCk7XG4gIH1cblxuICAvKiogQ2xvc2VzIHRoZSBjb250ZXh0IG1lbnUgYW5kIGRvZXMgdGhlIG5lY2Vzc2FyeSBjbGVhbnVwLiAqL1xuICBwcml2YXRlIF9kZXN0cm95TWVudSgpIHtcbiAgICBpZiAoIXRoaXMuX292ZXJsYXlSZWYgfHwgIXRoaXMuY29udGV4dE1lbnVPcGVuKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgY29udGV4dE1lbnUgPSB0aGlzLmNvbnRleHRNZW51O1xuXG4gICAgdGhpcy5fY2xvc2luZ0FjdGlvbnNTdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcbiAgICB0aGlzLl9vdmVybGF5UmVmLmRldGFjaCgpO1xuXG4gICAgY29udGV4dE1lbnUuX3Jlc2V0QW5pbWF0aW9uKCk7XG5cbiAgICBpZiAoY29udGV4dE1lbnUubGF6eUNvbnRlbnQpIHtcbiAgICAgIC8vIFdhaXQgZm9yIHRoZSBleGl0IGFuaW1hdGlvbiB0byBmaW5pc2ggYmVmb3JlIGRldGFjaGluZyB0aGUgY29udGVudC5cbiAgICAgIGNvbnRleHRNZW51Ll9hbmltYXRpb25Eb25lXG4gICAgICAgIC5waXBlKFxuICAgICAgICAgIGZpbHRlcihldmVudCA9PiBldmVudC50b1N0YXRlID09PSAndm9pZCcpLFxuICAgICAgICAgIHRha2UoMSksXG4gICAgICAgICAgLy8gSW50ZXJydXB0IGlmIHRoZSBjb250ZW50IGdvdCByZS1hdHRhY2hlZC5cbiAgICAgICAgICB0YWtlVW50aWwoY29udGV4dE1lbnUubGF6eUNvbnRlbnQuX2F0dGFjaGVkKVxuICAgICAgICApXG4gICAgICAgIC5zdWJzY3JpYmUoe1xuICAgICAgICAgIG5leHQ6ICgpID0+XG4gICAgICAgICAgICBjb250ZXh0TWVudS5sYXp5Q29udGVudCAmJiBjb250ZXh0TWVudS5sYXp5Q29udGVudC5kZXRhY2goKSxcbiAgICAgICAgICAvLyBObyBtYXR0ZXIgd2hldGhlciB0aGUgY29udGVudCBnb3QgcmUtYXR0YWNoZWQsIHJlc2V0IHRoZSBtZW51LlxuICAgICAgICAgIGNvbXBsZXRlOiAoKSA9PiB0aGlzLl9yZXNldENvbnRleHRNZW51KClcbiAgICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX3Jlc2V0Q29udGV4dE1lbnUoKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogVGhpcyBtZXRob2Qgc2V0cyB0aGUgY29udGV4dCBtZW51IHN0YXRlIHRvIG9wZW4gYW5kIGZvY3VzZXMgdGhlIGZpcnN0IGl0ZW0gaWZcbiAgICogdGhlIGNvbnRleHQgbWVudSB3YXMgb3BlbmVkIHZpYSB0aGUga2V5Ym9hcmQuXG4gICAqL1xuICBwcml2YXRlIF9pbml0Q29udGV4dE1lbnUoKTogdm9pZCB7XG4gICAgdGhpcy5jb250ZXh0TWVudS5wYXJlbnRNZW51ID0gdGhpcy50cmlnZ2Vyc1N1Ym1lbnUoKVxuICAgICAgPyB0aGlzLl9wYXJlbnRNZW51XG4gICAgICA6IHVuZGVmaW5lZDtcbiAgICB0aGlzLmNvbnRleHRNZW51LmRpcmVjdGlvbiA9IHRoaXMuZGlyO1xuICAgIHRoaXMuX3NldElzQ29udGV4dE1lbnVPcGVuKHRydWUpO1xuICAgIHRoaXMuY29udGV4dE1lbnUuZm9jdXNGaXJzdEl0ZW0oKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBGb2N1c2VzIHRoZSBjb250ZXh0IG1lbnUgdHJpZ2dlci5cbiAgICovXG4gIGZvY3VzKCkge1xuICAgIHRoaXMuX2VsZW1lbnQubmF0aXZlRWxlbWVudC5mb2N1cygpO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoaXMgbWV0aG9kIHJlc2V0cyB0aGUgY29udGV4dCBtZW51IHdoZW4gaXQncyBjbG9zZWQsIG1vc3QgaW1wb3J0YW50bHkgcmVzdG9yaW5nXG4gICAqIGZvY3VzIHRvIHRoZSBjb250ZXh0IG1lbnUgdHJpZ2dlciBpZiB0aGUgY29udGV4dCBtZW51IHdhcyBvcGVuZWQgdmlhIHRoZSBrZXlib2FyZC5cbiAgICovXG4gIHByaXZhdGUgX3Jlc2V0Q29udGV4dE1lbnUoKTogdm9pZCB7XG4gICAgdGhpcy5fc2V0SXNDb250ZXh0TWVudU9wZW4oZmFsc2UpO1xuICAgIHRoaXMuZm9jdXMoKTtcbiAgfVxuXG4gIC8qKiBTZXQgc3RhdGUgcmF0aGVyIHRoYW4gdG9nZ2xlIHRvIHN1cHBvcnQgdHJpZ2dlcnMgc2hhcmluZyBhIG1lbnUuICovXG4gIHByaXZhdGUgX3NldElzQ29udGV4dE1lbnVPcGVuKGlzT3BlbjogYm9vbGVhbik6IHZvaWQge1xuICAgIHRoaXMuX2NvbnRleHRNZW51T3BlbiA9IGlzT3BlbjtcbiAgICB0aGlzLl9jb250ZXh0TWVudU9wZW5cbiAgICAgID8gdGhpcy5jb250ZXh0TWVudU9wZW5lZC5lbWl0KClcbiAgICAgIDogdGhpcy5jb250ZXh0TWVudUNsb3NlZC5lbWl0KCk7XG5cbiAgICBpZiAodGhpcy50cmlnZ2Vyc1N1Ym1lbnUoKSkge1xuICAgICAgdGhpcy5fY29udGV4dE1lbnVJdGVtSW5zdGFuY2UuX2hpZ2hsaWdodGVkID0gaXNPcGVuO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBUaGlzIG1ldGhvZCBjaGVja3MgdGhhdCBhIHZhbGlkIGluc3RhbmNlIG9mIE54Q29udGV4dE1lbnVDb21wb25lbnQgaGFzIGJlZW4gcGFzc2VkIGludG9cbiAgICogbnhDb250ZXh0TWVudVRyaWdnZXJGb3IuIElmIG5vdCwgYW4gZXhjZXB0aW9uIGlzIHRocm93bi5cbiAgICovXG4gIHByaXZhdGUgX2NoZWNrQ29udGV4dE1lbnUoKSB7XG4gICAgaWYgKCF0aGlzLmNvbnRleHRNZW51KSB7XG4gICAgICB0aHJvd054Q29udGV4dE1lbnVNaXNzaW5nRXJyb3IoKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogVGhpcyBtZXRob2QgY3JlYXRlcyB0aGUgb3ZlcmxheSBmcm9tIHRoZSBwcm92aWRlZCBtZW51J3MgdGVtcGxhdGUgYW5kIHNhdmVzIGl0c1xuICAgKiBPdmVybGF5UmVmIHNvIHRoYXQgaXQgY2FuIGJlIGF0dGFjaGVkIHRvIHRoZSBET00gd2hlbiBvcGVuQ29udGV4dE1lbnUgaXMgY2FsbGVkLlxuICAgKi9cbiAgcHJpdmF0ZSBfY3JlYXRlT3ZlcmxheSgpOiBPdmVybGF5UmVmIHtcbiAgICBpZiAoIXRoaXMuX292ZXJsYXlSZWYpIHtcbiAgICAgIGNvbnN0IGNvbmZpZyA9IHRoaXMuX2dldE92ZXJsYXlDb25maWcoKTtcbiAgICAgIHRoaXMuX292ZXJsYXlSZWYgPSB0aGlzLl9vdmVybGF5LmNyZWF0ZShjb25maWcpO1xuXG4gICAgICAvLyBDb25zdW1lIHRoZSBga2V5ZG93bkV2ZW50c2AgaW4gb3JkZXIgdG8gcHJldmVudCB0aGVtIGZyb20gZ29pbmcgdG8gYW5vdGhlciBvdmVybGF5LlxuICAgICAgdGhpcy5fb3ZlcmxheVJlZi5rZXlkb3duRXZlbnRzKCkuc3Vic2NyaWJlKCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuX292ZXJsYXlSZWY7XG4gIH1cblxuICAvKipcbiAgICogVGhpcyBtZXRob2QgYnVpbGRzIHRoZSBjb25maWd1cmF0aW9uIG9iamVjdCBuZWVkZWQgdG8gY3JlYXRlIHRoZSBvdmVybGF5LCB0aGUgT3ZlcmxheVN0YXRlLlxuICAgKiBAcmV0dXJucyBPdmVybGF5Q29uZmlnXG4gICAqL1xuICBwcml2YXRlIF9nZXRPdmVybGF5Q29uZmlnKCk6IE92ZXJsYXlDb25maWcge1xuICAgIHJldHVybiBuZXcgT3ZlcmxheUNvbmZpZyh7XG4gICAgICBwb3NpdGlvblN0cmF0ZWd5OiB0aGlzLl9vdmVybGF5XG4gICAgICAgIC5wb3NpdGlvbigpXG4gICAgICAgIC5mbGV4aWJsZUNvbm5lY3RlZFRvKHRoaXMuX2VsZW1lbnQpXG4gICAgICAgIC53aXRoTG9ja2VkUG9zaXRpb24oKVxuICAgICAgICAud2l0aEZsZXhpYmxlRGltZW5zaW9ucyhmYWxzZSlcbiAgICAgICAgLndpdGhUcmFuc2Zvcm1PcmlnaW5PbignLm54LWNvbnRleHQtbWVudScpLFxuICAgICAgc2Nyb2xsU3RyYXRlZ3k6IHRoaXMuX3Njcm9sbFN0cmF0ZWd5KCksXG4gICAgICBkaXJlY3Rpb246IHRoaXMuX2RpclxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldHMgdGhlIGFwcHJvcHJpYXRlIHBvc2l0aW9ucyBvbiBhIHBvc2l0aW9uIHN0cmF0ZWd5XG4gICAqIHNvIHRoZSBvdmVybGF5IGNvbm5lY3RzIHdpdGggdGhlIHRyaWdnZXIgY29ycmVjdGx5LlxuICAgKiBAcGFyYW0gcG9zaXRpb25TdHJhdGVneSBTdHJhdGVneSB3aG9zZSBwb3NpdGlvbiB0byB1cGRhdGUuXG4gICAqL1xuICBwcml2YXRlIF9zZXRQb3NpdGlvbihwb3NpdGlvblN0cmF0ZWd5OiBGbGV4aWJsZUNvbm5lY3RlZFBvc2l0aW9uU3RyYXRlZ3kpIHtcbiAgICBsZXQgb3JpZ2luWCA9ICdzdGFydCc7XG4gICAgbGV0IG9yaWdpbkZhbGxiYWNrWCA9ICdlbmQnO1xuICAgIGNvbnN0IG92ZXJsYXlZID0gJ3RvcCc7XG4gICAgY29uc3Qgb3ZlcmxheUZhbGxiYWNrWSA9ICdib3R0b20nO1xuICAgIGxldCBvcmlnaW5ZID0gb3ZlcmxheVk7XG4gICAgbGV0IG9yaWdpbkZhbGxiYWNrWSA9IG92ZXJsYXlGYWxsYmFja1k7XG4gICAgbGV0IG92ZXJsYXlYID0gb3JpZ2luWDtcbiAgICBsZXQgb3ZlcmxheUZhbGxiYWNrWCA9IG9yaWdpbkZhbGxiYWNrWDtcbiAgICBsZXQgb2Zmc2V0WSA9IDA7XG5cbiAgICBpZiAodGhpcy50cmlnZ2Vyc1N1Ym1lbnUoKSkge1xuICAgICAgLy8gV2hlbiB0aGUgbWVudSBpcyBhIHN1Yi1tZW51LCBpdCBzaG91bGQgYWx3YXlzIGFsaWduIGl0c2VsZlxuICAgICAgLy8gdG8gdGhlIGVkZ2VzIG9mIHRoZSB0cmlnZ2VyLCBpbnN0ZWFkIG9mIG92ZXJsYXBwaW5nIGl0LlxuICAgICAgb3ZlcmxheUZhbGxiYWNrWCA9IG9yaWdpblggPSAnZW5kJztcbiAgICAgIG9yaWdpbkZhbGxiYWNrWCA9IG92ZXJsYXlYID0gJ3N0YXJ0JztcbiAgICAgIG9mZnNldFkgPSAtTUVOVV9QQU5FTF9UT1BfUEFERElORztcbiAgICB9IGVsc2Uge1xuICAgICAgb2Zmc2V0WSA9IE1FTlVfUEFORUxfT0ZGU0VUO1xuICAgICAgb3JpZ2luWSA9ICdib3R0b20nO1xuICAgICAgb3JpZ2luRmFsbGJhY2tZID0gJ3RvcCc7XG4gICAgfVxuXG4gICAgcG9zaXRpb25TdHJhdGVneS53aXRoUG9zaXRpb25zKFtcbiAgICAgIHsgb3JpZ2luWCwgb3JpZ2luWSwgb3ZlcmxheVgsIG92ZXJsYXlZLCBvZmZzZXRZIH0sXG4gICAgICB7XG4gICAgICAgIG9yaWdpblg6IG9yaWdpbkZhbGxiYWNrWCxcbiAgICAgICAgb3JpZ2luWSxcbiAgICAgICAgb3ZlcmxheVg6IG92ZXJsYXlGYWxsYmFja1gsXG4gICAgICAgIG92ZXJsYXlZLFxuICAgICAgICBvZmZzZXRZXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBvcmlnaW5YLFxuICAgICAgICBvcmlnaW5ZOiBvcmlnaW5GYWxsYmFja1ksXG4gICAgICAgIG92ZXJsYXlYLFxuICAgICAgICBvdmVybGF5WTogb3ZlcmxheUZhbGxiYWNrWSxcbiAgICAgICAgb2Zmc2V0WTogLW9mZnNldFlcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIG9yaWdpblg6IG9yaWdpbkZhbGxiYWNrWCxcbiAgICAgICAgb3JpZ2luWTogb3JpZ2luRmFsbGJhY2tZLFxuICAgICAgICBvdmVybGF5WDogb3ZlcmxheUZhbGxiYWNrWCxcbiAgICAgICAgb3ZlcmxheVk6IG92ZXJsYXlGYWxsYmFja1ksXG4gICAgICAgIG9mZnNldFk6IC1vZmZzZXRZXG4gICAgICB9XG4gICAgXSBhcyBDb25uZWN0ZWRQb3NpdGlvbltdKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgc3RyZWFtIHRoYXQgZW1pdHMgd2hlbmV2ZXIgYW4gYWN0aW9uIHRoYXQgc2hvdWxkIGNsb3NlIHRoZSBjb250ZXh0IG1lbnUgb2NjdXJzLiAqL1xuICBwcml2YXRlIF9jb250ZXh0TWVudUNsb3NpbmdBY3Rpb25zKCkge1xuICAgIGxldCBiYWNrZHJvcDtcbiAgICBsZXQgZGV0YWNobWVudHM7XG5cbiAgICBpZiAodGhpcy5fb3ZlcmxheVJlZikge1xuICAgICAgYmFja2Ryb3AgPSB0aGlzLl9vdmVybGF5UmVmLmJhY2tkcm9wQ2xpY2soKTtcbiAgICAgIGRldGFjaG1lbnRzID0gdGhpcy5fb3ZlcmxheVJlZi5kZXRhY2htZW50cygpO1xuICAgIH1cblxuICAgIGNvbnN0IHBhcmVudENsb3NlID0gdGhpcy5fcGFyZW50TWVudVxuICAgICAgPyB0aGlzLl9wYXJlbnRNZW51LmNsb3NlZFxuICAgICAgOiBvYnNlcnZhYmxlT2YoKTtcblxuICAgIGNvbnN0IGhvdmVyID0gdGhpcy5fcGFyZW50TWVudVxuICAgICAgPyB0aGlzLl9wYXJlbnRNZW51Ll9ob3ZlcmVkKCkucGlwZShcbiAgICAgICAgICBmaWx0ZXIoYWN0aXZlID0+IGFjdGl2ZSAhPT0gdGhpcy5fY29udGV4dE1lbnVJdGVtSW5zdGFuY2UpLFxuICAgICAgICAgIGZpbHRlcigoKSA9PiB0aGlzLl9jb250ZXh0TWVudU9wZW4pXG4gICAgICAgIClcbiAgICAgIDogb2JzZXJ2YWJsZU9mKCk7XG5cbiAgICByZXR1cm4gbWVyZ2UoYmFja2Ryb3AsIHBhcmVudENsb3NlLCBob3ZlciwgZGV0YWNobWVudHMpO1xuICB9XG5cbiAgLyoqIEhhbmRsZXMgbW91c2UgcHJlc3NlcyBvbiB0aGUgdHJpZ2dlci4gKi9cbiAgX2hhbmRsZU1vdXNlZG93bihldmVudDogTW91c2VFdmVudCk6IHZvaWQge1xuICAgIC8vIFNpbmNlIHJpZ2h0IG9yIG1pZGRsZSBidXR0b24gY2xpY2tzIHdvbid0IHRyaWdnZXIgdGhlIGBjbGlja2AgZXZlbnQsXG4gICAgLy8gd2Ugc2hvdWxkbid0IGNvbnNpZGVyIHRoZSBtZW51IGFzIG9wZW5lZCBieSBtb3VzZSBpbiB0aG9zZSBjYXNlcy5cbiAgICAvLyB0aGlzLl9vcGVuZWRCeSA9IGV2ZW50LmJ1dHRvbiA9PT0gMCA/ICdtb3VzZScgOiBudWxsO1xuXG4gICAgLy8gU2luY2UgY2xpY2tpbmcgb24gdGhlIHRyaWdnZXIgd29uJ3QgY2xvc2UgdGhlIG1lbnUgaWYgaXQgb3BlbnMgYSBzdWItbWVudSxcbiAgICAvLyB3ZSBzaG91bGQgcHJldmVudCBmb2N1cyBmcm9tIG1vdmluZyBvbnRvIGl0IHZpYSBjbGljayB0byBhdm9pZCB0aGVcbiAgICAvLyBoaWdobGlnaHQgZnJvbSBsaW5nZXJpbmcgb24gdGhlIG1lbnUgaXRlbS5cbiAgICBpZiAodGhpcy50cmlnZ2Vyc1N1Ym1lbnUoKSkge1xuICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICB9XG4gIH1cblxuICAvKiogSGFuZGxlcyBrZXkgcHJlc3NlcyBvbiB0aGUgdHJpZ2dlci4gKi9cbiAgX2hhbmRsZUtleWRvd24oZXZlbnQ6IEtleWJvYXJkRXZlbnQpOiB2b2lkIHtcbiAgICBjb25zdCBrZXlDb2RlID0gZXZlbnQua2V5Q29kZTtcblxuICAgIGlmIChcbiAgICAgIHRoaXMudHJpZ2dlcnNTdWJtZW51KCkgJiZcbiAgICAgICgoa2V5Q29kZSA9PT0gUklHSFRfQVJST1cgJiYgdGhpcy5kaXIgPT09ICdsdHInKSB8fFxuICAgICAgICAoa2V5Q29kZSA9PT0gTEVGVF9BUlJPVyAmJiB0aGlzLmRpciA9PT0gJ3J0bCcpKVxuICAgICkge1xuICAgICAgdGhpcy5vcGVuQ29udGV4dE1lbnUoKTtcbiAgICB9XG4gIH1cblxuICAvKiogSGFuZGxlcyBjbGljayBldmVudHMgb24gdGhlIHRyaWdnZXIuICovXG4gIF9oYW5kbGVDbGljayhldmVudDogTW91c2VFdmVudCk6IHZvaWQge1xuICAgIGlmICh0aGlzLnRyaWdnZXJzU3VibWVudSgpKSB7XG4gICAgICAvLyBTdG9wIGV2ZW50IHByb3BhZ2F0aW9uIHRvIGF2b2lkIGNsb3NpbmcgdGhlIHBhcmVudCBtZW51LlxuICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICB0aGlzLm9wZW5Db250ZXh0TWVudSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnRvZ2dsZUNvbnRleHRNZW51KCk7XG4gICAgfVxuICB9XG5cbiAgLyogU3Vic2NyaWJlcyB0byBkb2N1bWVudCBjbGlja3MgdG8gY2xvc2UgdGhlIGNvbnRleHQgbWVudSBvbiBjbGlja3Mgb24gdGhlIGJhY2tncm91bmQuICovXG4gIHByaXZhdGUgX3dhaXRGb3JDbG9zZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fZG9jdW1lbnRDbGlja09ic2VydmFibGVcbiAgICAgIC5waXBlKFxuICAgICAgICBtYXAoZXZlbnQgPT4gZXZlbnQudGFyZ2V0KSxcbiAgICAgICAgZmlsdGVyKCh0YXJnZXQ6IE5vZGUpID0+ICF0aGlzLl9lbGVtZW50Lm5hdGl2ZUVsZW1lbnQuY29udGFpbnModGFyZ2V0KSksXG4gICAgICAgIHRha2VVbnRpbCh0aGlzLmNvbnRleHRNZW51LmNsb3NlZCkpXG4gICAgICAuc3Vic2NyaWJlKCgpID0+IHtcbiAgICAgICAgdGhpcy5jbG9zZUNvbnRleHRNZW51KCk7XG4gICAgICB9KTtcbiAgfVxuXG4gIC8qKiBIYW5kbGVzIHRoZSBjYXNlcyB3aGVyZSB0aGUgdXNlciBob3ZlcnMgb3ZlciB0aGUgdHJpZ2dlci4gKi9cbiAgcHJpdmF0ZSBfaGFuZGxlSG92ZXIoKSB7XG4gICAgLy8gU3Vic2NyaWJlIHRvIGNoYW5nZXMgaW4gdGhlIGhvdmVyZWQgaXRlbSBpbiBvcmRlciB0byB0b2dnbGUgdGhlIHBhbmVsLlxuICAgIGlmICghdGhpcy50cmlnZ2Vyc1N1Ym1lbnUoKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuX2hvdmVyU3Vic2NyaXB0aW9uID0gdGhpcy5fcGFyZW50TWVudVxuICAgICAgLl9ob3ZlcmVkKClcbiAgICAgIC8vIFNpbmNlIHdlIG1pZ2h0IGhhdmUgbXVsdGlwbGUgY29tcGV0aW5nIHRyaWdnZXJzIGZvciB0aGUgc2FtZSBtZW51IChlLmcuIGEgc3ViLW1lbnVcbiAgICAgIC8vIHdpdGggZGlmZmVyZW50IGRhdGEgYW5kIHRyaWdnZXJzKSwgd2UgaGF2ZSB0byBkZWxheSBpdCBieSBhIHRpY2sgdG8gZW5zdXJlIHRoYXRcbiAgICAgIC8vIGl0IHdvbid0IGJlIGNsb3NlZCBpbW1lZGlhdGVseSBhZnRlciBpdCBpcyBvcGVuZWQuXG4gICAgICAucGlwZShcbiAgICAgICAgZmlsdGVyKGFjdGl2ZSA9PiBhY3RpdmUgPT09IHRoaXMuX2NvbnRleHRNZW51SXRlbUluc3RhbmNlICYmICFhY3RpdmUuZGlzYWJsZWQpLFxuICAgICAgICBkZWxheSgwLCBhc2FwU2NoZWR1bGVyKVxuICAgICAgKVxuICAgICAgLnN1YnNjcmliZSgoKSA9PiB7XG4gICAgICAgIC8vIElmIHRoZSBzYW1lIG1lbnUgaXMgdXNlZCBiZXR3ZWVuIG11bHRpcGxlIHRyaWdnZXJzLCBpdCBtaWdodCBzdGlsbCBiZSBhbmltYXRpbmdcbiAgICAgICAgLy8gd2hpbGUgdGhlIG5ldyB0cmlnZ2VyIHRyaWVzIHRvIHJlLW9wZW4gaXQuIFdhaXQgZm9yIHRoZSBhbmltYXRpb24gdG8gZmluaXNoXG4gICAgICAgIC8vIGJlZm9yZSBkb2luZyBzby4gQWxzbyBpbnRlcnJ1cHQgaWYgdGhlIHVzZXIgbW92ZXMgdG8gYW5vdGhlciBpdGVtLlxuICAgICAgICBpZiAodGhpcy5jb250ZXh0TWVudS5faXNBbmltYXRpbmcpIHtcbiAgICAgICAgICAvLyBXZSBuZWVkIHRoZSBgZGVsYXkoMClgIGhlcmUgaW4gb3JkZXIgdG8gYXZvaWRcbiAgICAgICAgICAvLyAnY2hhbmdlZCBhZnRlciBjaGVja2VkJyBlcnJvcnMgaW4gc29tZSBjYXNlcy5cbiAgICAgICAgICB0aGlzLmNvbnRleHRNZW51Ll9hbmltYXRpb25Eb25lXG4gICAgICAgICAgICAucGlwZShcbiAgICAgICAgICAgICAgdGFrZSgxKSxcbiAgICAgICAgICAgICAgZGVsYXkoMCwgYXNhcFNjaGVkdWxlciksXG4gICAgICAgICAgICAgIHRha2VVbnRpbCh0aGlzLl9wYXJlbnRNZW51Ll9ob3ZlcmVkKCkpXG4gICAgICAgICAgICApXG4gICAgICAgICAgICAuc3Vic2NyaWJlKCgpID0+IHRoaXMub3BlbkNvbnRleHRNZW51KCkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMub3BlbkNvbnRleHRNZW51KCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICB9XG5cbiAgLyoqIEdldHMgdGhlIHBvcnRhbCB0aGF0IHNob3VsZCBiZSBhdHRhY2hlZCB0byB0aGUgb3ZlcmxheS4gKi9cbiAgcHJpdmF0ZSBfZ2V0UG9ydGFsKCk6IFRlbXBsYXRlUG9ydGFsIHtcbiAgICAvLyBOb3RlIHRoYXQgd2UgY2FuIGF2b2lkIHRoaXMgY2hlY2sgYnkga2VlcGluZyB0aGUgcG9ydGFsIG9uIHRoZSBjb250ZXh0IG1lbnUgcGFuZWwuXG4gICAgLy8gV2hpbGUgaXQgd291bGQgYmUgY2xlYW5lciwgd2UnZCBoYXZlIHRvIGludHJvZHVjZSBhbm90aGVyIHJlcXVpcmVkIG1ldGhvZCBvblxuICAgIC8vIGBOeENvbnRleHRNZW51UGFuZWxDb21wb25lbnRgLCBtYWtpbmcgaXQgaGFyZGVyIHRvIGNvbnN1bWUuXG4gICAgaWYgKCF0aGlzLl9wb3J0YWwgfHxcbiAgICAgICAgdGhpcy5fcG9ydGFsLnRlbXBsYXRlUmVmICE9PSB0aGlzLmNvbnRleHRNZW51LnRlbXBsYXRlUmVmKSB7XG4gICAgICB0aGlzLl9wb3J0YWwgPSBuZXcgVGVtcGxhdGVQb3J0YWwoXG4gICAgICAgIHRoaXMuY29udGV4dE1lbnUudGVtcGxhdGVSZWYsXG4gICAgICAgIHRoaXMuX3ZpZXdDb250YWluZXJSZWZcbiAgICAgICk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuX3BvcnRhbDtcbiAgfVxufVxuIl19