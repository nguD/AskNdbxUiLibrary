/**
 * @fileoverview added by tsickle
 * Generated from: utils.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import * as tslib_1 from "tslib";
import { Injectable } from '@angular/core';
import * as i0 from "@angular/core";
/**
 * @param {?} value
 * @return {?}
 */
export function isString(value) {
    return typeof value === 'string';
}
/**
 * @param {?} str
 * @param {?=} length
 * @param {?=} padCharacter
 * @return {?}
 */
export function pad(str, length, padCharacter) {
    if (length === void 0) { length = 2; }
    if (padCharacter === void 0) { padCharacter = '0'; }
    if (!isString(str) || str.length >= length) {
        return str;
    }
    while (str.length < length) {
        str = padCharacter + str;
    }
    return str;
}
// DATE -> YYYY-MM-DD
/**
 * @param {?} date
 * @return {?}
 */
export function formatDate(date) {
    /** @type {?} */
    var dateOfBirth = [
        String(date.getFullYear()),
        pad(String(date.getMonth() + 1)),
        pad(String(date.getDate()))
    ].join('-');
    return dateOfBirth;
}
/**
 * @param {?} date
 * @return {?}
 */
export function formatDateHuman(date) {
    /** @type {?} */
    var dateOfBirth = [
        pad(String(date.getDate())),
        pad(String(date.getMonth() + 1)),
        String(date.getFullYear())
    ].join('-');
    return dateOfBirth;
}
/*
  Purpose of this function is to allow a list of short keywords
  expand to longer bem class names with will then be applied to the classname value.

  This function will map a list of keys to values in a MAPPING list.
  Whatever value is found will replace the keyword.
  Every keyword not found will just transfered wiithmout modifying.
*/
/**
 * @param {?} value
 * @param {?=} DEFAULTS
 * @param {?=} MAPPING
 * @return {?}
 */
export function mapClassNames(value, DEFAULTS, MAPPING) {
    if (DEFAULTS === void 0) { DEFAULTS = []; }
    if (MAPPING === void 0) { MAPPING = {}; }
    /** @type {?} */
    var sanitizedList = tslib_1.__spread(DEFAULTS);
    if (typeof value === 'string') {
        /** @type {?} */
        var mappedClasses = getClassNameList(value, MAPPING);
        sanitizedList = tslib_1.__spread(sanitizedList, mappedClasses);
    }
    return sanitizedList.join(' ').trim();
}
/**
 * @param {?} value
 * @param {?=} MAPPING
 * @return {?}
 */
export function getClassNameList(value, MAPPING) {
    if (MAPPING === void 0) { MAPPING = {}; }
    /** @type {?} */
    var mappedClasses = [];
    if (typeof value === 'string') {
        /** @type {?} */
        var classNames = value.split(' ');
        /** @type {?} */
        var keys_1 = Object.keys(MAPPING);
        mappedClasses = classNames.map((/**
         * @param {?} className
         * @return {?}
         */
        function (className) {
            if (keys_1.indexOf(className) > -1) {
                return MAPPING[className];
            }
            else {
                return className;
            }
        }));
    }
    return mappedClasses;
}
/**
 * @param {?} renderer
 * @param {?} element
 * @param {?} classes
 * @return {?}
 */
export function appendClasses(renderer, element, classes) {
    if (renderer && element && classes) {
        classes.split(' ').forEach((/**
         * @param {?} item
         * @return {?}
         */
        function (item) {
            renderer.addClass(element.nativeElement, item);
        }));
    }
}
/**
 * @param {?} renderer
 * @param {?} element
 * @param {?} classes
 * @return {?}
 */
export function removeClasses(renderer, element, classes) {
    if (renderer && element && classes) {
        classes.split(' ').forEach((/**
         * @param {?} item
         * @return {?}
         */
        function (item) {
            renderer.removeClass(element.nativeElement, item);
        }));
    }
}
// YYYY-MM-DD -> DATE
/**
 * @param {?} dateString
 * @return {?}
 */
export function parseDate(dateString) {
    return new Date(dateString);
}
// Manually compose a font shorthand defintion as it's not
// guaranteed to be given by the computed style object.
/**
 * @param {?} style
 * @return {?}
 */
export function getFontShorthand(style) {
    var font = style.font, fontStyle = style.fontStyle, fontVariant = style.fontVariant, fontWeight = style.fontWeight, fontSize = style.fontSize, lineHeight = style.lineHeight, fontFamily = style.fontFamily;
    if (font.length > 0) {
        return font;
    }
    return fontStyle + " " + fontVariant + " " + fontWeight + " " + fontSize + "/" + lineHeight + " " + fontFamily;
}
/**
 * @param {?} number
 * @return {?}
 */
export function numberOfDecimals(number) {
    /** @type {?} */
    var parsed = Number(number);
    if (Number.isNaN(parsed) || Number.isInteger(parsed)) {
        return 0;
    }
    /** @type {?} */
    var match = (parsed.toString()).match(/(?:\.(\d+))?(?:[eE]([+-]?\d+))?$/);
    if (!match[1]) {
        return 0;
    }
    return match[1].length;
}
/**
 * @param {?} value
 * @param {?=} min
 * @param {?=} max
 * @return {?}
 */
export function clamp(value, min, max) {
    if (min === void 0) { min = 0; }
    if (max === void 0) { max = 1; }
    return Math.max(min, Math.min(max, value));
}
/**
 * Provider that defines when form controls have an error.
 */
var ErrorStateMatcher = /** @class */ (function () {
    function ErrorStateMatcher() {
    }
    /**
     * @param {?} control
     * @param {?} form
     * @return {?}
     */
    ErrorStateMatcher.prototype.isErrorState = /**
     * @param {?} control
     * @param {?} form
     * @return {?}
     */
    function (control, form) {
        return !!(control && control.invalid && (control.touched || (form && form.submitted)));
    };
    ErrorStateMatcher.decorators = [
        { type: Injectable, args: [{ providedIn: 'root' },] }
    ];
    /** @nocollapse */ ErrorStateMatcher.ngInjectableDef = i0.ɵɵdefineInjectable({ factory: function ErrorStateMatcher_Factory() { return new ErrorStateMatcher(); }, token: ErrorStateMatcher, providedIn: "root" });
    return ErrorStateMatcher;
}());
export { ErrorStateMatcher };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidXRpbHMuanMiLCJzb3VyY2VSb290Ijoibmc6Ly9AYWxsaWFuei9uZ3gtbmRieC91dGlscy8iLCJzb3VyY2VzIjpbInV0aWxzLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7OztBQUFBLE9BQU8sRUFBYyxVQUFVLEVBQUUsTUFBTSxlQUFlLENBQUM7Ozs7OztBQUd2RCxNQUFNLFVBQVUsUUFBUSxDQUFDLEtBQVU7SUFDakMsT0FBTyxPQUFPLEtBQUssS0FBSyxRQUFRLENBQUM7QUFDbkMsQ0FBQzs7Ozs7OztBQUVELE1BQU0sVUFBVSxHQUFHLENBQUMsR0FBVyxFQUFFLE1BQWtCLEVBQUUsWUFBMEI7SUFBOUMsdUJBQUEsRUFBQSxVQUFrQjtJQUFFLDZCQUFBLEVBQUEsa0JBQTBCO0lBQzNFLElBQUksQ0FBQyxRQUFRLENBQUMsR0FBRyxDQUFDLElBQUksR0FBRyxDQUFDLE1BQU0sSUFBSSxNQUFNLEVBQUU7UUFDMUMsT0FBTyxHQUFHLENBQUM7S0FDWjtJQUNELE9BQU8sR0FBRyxDQUFDLE1BQU0sR0FBRyxNQUFNLEVBQUU7UUFDMUIsR0FBRyxHQUFHLFlBQVksR0FBRyxHQUFHLENBQUM7S0FDMUI7SUFDRCxPQUFPLEdBQUcsQ0FBQztBQUNiLENBQUM7Ozs7OztBQUdILE1BQU0sVUFBVSxVQUFVLENBQUMsSUFBVTs7UUFDM0IsV0FBVyxHQUFJO1FBQ2pCLE1BQU0sQ0FBRSxJQUFJLENBQUMsV0FBVyxFQUFFLENBQUM7UUFDM0IsR0FBRyxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsUUFBUSxFQUFFLEdBQUcsQ0FBQyxDQUFDLENBQUM7UUFDaEMsR0FBRyxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsT0FBTyxFQUFFLENBQUMsQ0FBQztLQUM1QixDQUFDLElBQUksQ0FBQyxHQUFHLENBQUM7SUFFYixPQUFPLFdBQVcsQ0FBQztBQUN2QixDQUFDOzs7OztBQUNELE1BQU0sVUFBVSxlQUFlLENBQUMsSUFBVTs7UUFDaEMsV0FBVyxHQUFJO1FBQ2pCLEdB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VUFBVSxFQUFFLE1BQU0sRUFBQzs7OzRCQS9IaEM7Q0FvSUMsQUFMRCxJQUtDO1NBSlksaUJBQWlCIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgRWxlbWVudFJlZiwgSW5qZWN0YWJsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgUmVuZGVyZXIyIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBGb3JtQ29udHJvbCwgRm9ybUdyb3VwRGlyZWN0aXZlLCBOZ0Zvcm0gfSBmcm9tICdAYW5ndWxhci9mb3Jtcyc7XG5leHBvcnQgZnVuY3Rpb24gaXNTdHJpbmcodmFsdWU6IGFueSkge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHBhZChzdHI6IHN0cmluZywgbGVuZ3RoOiBudW1iZXIgPSAyLCBwYWRDaGFyYWN0ZXI6IHN0cmluZyA9ICcwJyk6IHN0cmluZyB7XG4gICAgaWYgKCFpc1N0cmluZyhzdHIpIHx8IHN0ci5sZW5ndGggPj0gbGVuZ3RoKSB7XG4gICAgICByZXR1cm4gc3RyO1xuICAgIH1cbiAgICB3aGlsZSAoc3RyLmxlbmd0aCA8IGxlbmd0aCkge1xuICAgICAgc3RyID0gcGFkQ2hhcmFjdGVyICsgc3RyO1xuICAgIH1cbiAgICByZXR1cm4gc3RyO1xuICB9XG5cbi8vIERBVEUgLT4gWVlZWS1NTS1ERFxuZXhwb3J0IGZ1bmN0aW9uIGZvcm1hdERhdGUoZGF0ZTogRGF0ZSkge1xuICAgIGNvbnN0IGRhdGVPZkJpcnRoID0gIFtcbiAgICAgICAgU3RyaW5nIChkYXRlLmdldEZ1bGxZZWFyKCkpLFxuICAgICAgICBwYWQoU3RyaW5nKGRhdGUuZ2V0TW9udGgoKSArIDEpKSxcbiAgICAgICAgcGFkKFN0cmluZyhkYXRlLmdldERhdGUoKSkpXG4gICAgICBdLmpvaW4oJy0nKTtcblxuICAgIHJldHVybiBkYXRlT2ZCaXJ0aDtcbn1cbmV4cG9ydCBmdW5jdGlvbiBmb3JtYXREYXRlSHVtYW4oZGF0ZTogRGF0ZSkge1xuICAgIGNvbnN0IGRhdGVPZkJpcnRoID0gIFtcbiAgICAgICAgcGFkKFN0cmluZyhkYXRlLmdldERhdGUoKSkpLFxuICAgICAgICBwYWQoU3RyaW5nKGRhdGUuZ2V0TW9udGgoKSArIDEpKSxcbiAgICAgICAgU3RyaW5nIChkYXRlLmdldEZ1bGxZZWFyKCkpXG4gICAgICBdLmpvaW4oJy0nKTtcblxuICAgIHJldHVybiBkYXRlT2ZCaXJ0aDtcbn1cbi8qXG4gIFB1cnBvc2Ugb2YgdGhpcyBmdW5jdGlvbiBpcyB0byBhbGxvdyBhIGxpc3Qgb2Ygc2hvcnQga2V5d29yZHNcbiAgZXhwYW5kIHRvIGxvbmdlciBiZW0gY2xhc3MgbmFtZXMgd2l0aCB3aWxsIHRoZW4gYmUgYXBwbGllZCB0byB0aGUgY2xhc3NuYW1lIHZhbHVlLlxuXG4gIFRoaXMgZnVuY3Rpb24gd2lsbCBtYXAgYSBsaXN0IG9mIGtleXMgdG8gdmFsdWVzIGluIGEgTUFQUElORyBsaXN0LlxuICBXaGF0ZXZlciB2YWx1ZSBpcyBmb3VuZCB3aWxsIHJlcGxhY2UgdGhlIGtleXdvcmQuXG4gIEV2ZXJ5IGtleXdvcmQgbm90IGZvdW5kIHdpbGwganVzdCB0cmFuc2ZlcmVkIHdpaXRobW91dCBtb2RpZnlpbmcuXG4qL1xuXG5leHBvcnQgZnVuY3Rpb24gbWFwQ2xhc3NOYW1lcyh2YWx1ZSwgREVGQVVMVFMgPSBbXSwgTUFQUElORyA9IHt9KSB7XG4gIGxldCBzYW5pdGl6ZWRMaXN0ID0gWyAuLi5ERUZBVUxUUyBdO1xuXG4gIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgY29uc3QgbWFwcGVkQ2xhc3NlcyA9IGdldENsYXNzTmFtZUxpc3QodmFsdWUsIE1BUFBJTkcpO1xuICAgIHNhbml0aXplZExpc3QgPSBbLi4uc2FuaXRpemVkTGlzdCwgLi4ubWFwcGVkQ2xhc3Nlc107XG4gIH1cblxuICByZXR1cm4gc2FuaXRpemVkTGlzdC5qb2luKCcgJykudHJpbSgpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0Q2xhc3NOYW1lTGlzdCh2YWx1ZSwgTUFQUElORyA9IHt9KSB7XG4gIGxldCBtYXBwZWRDbGFzc2VzID0gW107XG5cbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICBjb25zdCBjbGFzc05hbWVzID0gdmFsdWUuc3BsaXQoJyAnKTtcbiAgICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMoTUFQUElORyk7XG5cbiAgICBtYXBwZWRDbGFzc2VzID0gY2xhc3NOYW1lcy5tYXAoY2xhc3NOYW1lID0+IHtcbiAgICAgIGlmIChrZXlzLmluZGV4T2YoY2xhc3NOYW1lKSA+IC0xKSB7XG4gICAgICAgIHJldHVybiBNQVBQSU5HW2NsYXNzTmFtZV07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gY2xhc3NOYW1lO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgcmV0dXJuIG1hcHBlZENsYXNzZXM7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBhcHBlbmRDbGFzc2VzKHJlbmRlcmVyOiBSZW5kZXJlcjIsIGVsZW1lbnQ6IEVsZW1lbnRSZWYsIGNsYXNzZXM6IHN0cmluZykge1xuICBpZiAocmVuZGVyZXIgJiYgZWxlbWVudCAmJiBjbGFzc2VzKSB7XG4gICAgY2xhc3Nlcy5zcGxpdCgnICcpLmZvckVhY2goaXRlbSA9PiB7XG4gICAgICByZW5kZXJlci5hZGRDbGFzcyhlbGVtZW50Lm5hdGl2ZUVsZW1lbnQsIGl0ZW0pO1xuICAgIH0pO1xuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiByZW1vdmVDbGFzc2VzKHJlbmRlcmVyOiBSZW5kZXJlcjIsIGVsZW1lbnQ6IEVsZW1lbnRSZWYsIGNsYXNzZXM6IHN0cmluZykge1xuICBpZiAocmVuZGVyZXIgJiYgZWxlbWVudCAmJiBjbGFzc2VzKSB7XG4gICAgY2xhc3Nlcy5zcGxpdCgnICcpLmZvckVhY2goaXRlbSA9PiB7XG4gICAgICByZW5kZXJlci5yZW1vdmVDbGFzcyhlbGVtZW50Lm5hdGl2ZUVsZW1lbnQsIGl0ZW0pO1xuICAgIH0pO1xuICB9XG59XG5cbi8vIFlZWVktTU0tREQgLT4gREFURVxuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlRGF0ZShkYXRlU3RyaW5nKSB7XG4gIHJldHVybiBuZXcgRGF0ZShkYXRlU3RyaW5nKTtcbn1cblxuLy8gTWFudWFsbHkgY29tcG9zZSBhIGZvbnQgc2hvcnRoYW5kIGRlZmludGlvbiBhcyBpdCdzIG5vdFxuLy8gZ3VhcmFudGVlZCB0byBiZSBnaXZlbiBieSB0aGUgY29tcHV0ZWQgc3R5bGUgb2JqZWN0LlxuZXhwb3J0IGZ1bmN0aW9uIGdldEZvbnRTaG9ydGhhbmQoc3R5bGU6IENTU1N0eWxlRGVjbGFyYXRpb24pIHtcbiAgY29uc3Qge1xuICAgIGZvbnQsIGZvbnRTdHlsZSwgZm9udFZhcmlhbnQsIGZvbnRXZWlnaHQsIGZvbnRTaXplLCBsaW5lSGVpZ2h0LCBmb250RmFtaWx5XG4gIH0gPSBzdHlsZTtcblxuICBpZiAoZm9udC5sZW5ndGggPiAwKSB7XG4gICAgcmV0dXJuIGZvbnQ7XG4gIH1cblxuICByZXR1cm4gYCR7Zm9udFN0eWxlfSAke2ZvbnRWYXJpYW50fSAke2ZvbnRXZWlnaHR9ICR7Zm9udFNpemV9LyR7bGluZUhlaWdodH0gJHtmb250RmFtaWx5fWA7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBudW1iZXJPZkRlY2ltYWxzKG51bWJlcikge1xuICBjb25zdCBwYXJzZWQgPSBOdW1iZXIobnVtYmVyKTtcbiAgaWYgKE51bWJlci5pc05hTihwYXJzZWQpIHx8IE51bWJlci5pc0ludGVnZXIocGFyc2VkKSkge1xuICAgIHJldHVybiAwO1xuICB9XG4gIGNvbnN0IG1hdGNoID0gKHBhcnNlZC50b1N0cmluZygpKS5tYXRjaCgvKD86XFwuKFxcZCspKT8oPzpbZUVdKFsrLV0/XFxkKykpPyQvKTtcbiAgaWYgKCFtYXRjaFsxXSkge1xuICAgICAgcmV0dXJuIDA7XG4gIH1cbiAgcmV0dXJuIG1hdGNoWzFdLmxlbmd0aDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNsYW1wKHZhbHVlOiBudW1iZXIsIG1pbiA9IDAsIG1heCA9IDEpIHtcbiAgcmV0dXJuIE1hdGgubWF4KG1pbiwgTWF0aC5taW4obWF4LCB2YWx1ZSkpO1xufVxuXG4vKiogUHJvdmlkZXIgdGhhdCBkZWZpbmVzIHdoZW4gZm9ybSBjb250cm9scyBoYXZlIGFuIGVycm9yLiAqL1xuQEluamVjdGFibGUoe3Byb3ZpZGVkSW46ICdyb290J30pXG5leHBvcnQgY2xhc3MgRXJyb3JTdGF0ZU1hdGNoZXIge1xuICBpc0Vycm9yU3RhdGUoY29udHJvbDogRm9ybUNvbnRyb2wgfCBudWxsLCBmb3JtOiBGb3JtR3JvdXBEaXJlY3RpdmUgfCBOZ0Zvcm0gfCBudWxsKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuICEhKGNvbnRyb2wgJiYgY29udHJvbC5pbnZhbGlkICYmIChjb250cm9sLnRvdWNoZWQgfHwgKGZvcm0gJiYgZm9ybS5zdWJtaXR0ZWQpKSk7XG4gIH1cbn1cbiJdfQ==