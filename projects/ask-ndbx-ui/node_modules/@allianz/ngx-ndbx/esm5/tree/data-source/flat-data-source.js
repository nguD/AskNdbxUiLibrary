/**
 * @fileoverview added by tsickle
 * Generated from: data-source/flat-data-source.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import * as tslib_1 from "tslib";
import { DataSource } from '@angular/cdk/collections';
import { BehaviorSubject, merge } from 'rxjs';
import { map, take } from 'rxjs/operators';
/**
 * Tree flattener to convert a normal type of node to node with children & level information.
 * Transform nested nodes of type `T extends NxTreeNode` to flattened nodes of type `F extends NxFlatTreeNode`.
 *
 * For example, the input data of type `T` is nested, and contains its children data:
 *   SomeNode: {
 *     key: 'Fruits',
 *     children: [
 *       NodeOne: {
 *         key: 'Apple',
 *       },
 *       NodeTwo: {
 *        key: 'Pear',
 *      }
 *    ]
 *  }
 *  After flattener flatten the tree, the structure will become
 *  SomeNode: {
 *    key: 'Fruits',
 *    expandable: true,
 *    level: 1
 *  },
 *  NodeOne: {
 *    key: 'Apple',
 *    expandable: false,
 *    level: 2
 *  },
 *  NodeTwo: {
 *   key: 'Pear',
 *   expandable: false,
 *   level: 2
 * }
 * and the output flattened type is `F extends NxFlatTreeNode` with additional information.
 * @template T, F
 */
var /**
 * Tree flattener to convert a normal type of node to node with children & level information.
 * Transform nested nodes of type `T extends NxTreeNode` to flattened nodes of type `F extends NxFlatTreeNode`.
 *
 * For example, the input data of type `T` is nested, and contains its children data:
 *   SomeNode: {
 *     key: 'Fruits',
 *     children: [
 *       NodeOne: {
 *         key: 'Apple',
 *       },
 *       NodeTwo: {
 *        key: 'Pear',
 *      }
 *    ]
 *  }
 *  After flattener flatten the tree, the structure will become
 *  SomeNode: {
 *    key: 'Fruits',
 *    expandable: true,
 *    level: 1
 *  },
 *  NodeOne: {
 *    key: 'Apple',
 *    expandable: false,
 *    level: 2
 *  },
 *  NodeTwo: {
 *   key: 'Pear',
 *   expandable: false,
 *   level: 2
 * }
 * and the output flattened type is `F extends NxFlatTreeNode` with additional information.
 * @template T, F
 */
NxTreeFlattener = /** @class */ (function () {
    function NxTreeFlattener() {
    }
    /**
     * @param {?} node
     * @param {?} level
     * @return {?}
     */
    NxTreeFlattener.prototype.transformFunction = /**
     * @param {?} node
     * @param {?} level
     * @return {?}
     */
    function (node, level) {
        var children = node.children, rest = tslib_1.__rest(node, ["children"]);
        return (/** @type {?} */ (tslib_1.__assign({}, rest, { level: level, expandable: Array.isArray(children) && children.length > 0 })));
    };
    /**
     * @param {?} node
     * @return {?}
     */
    NxTreeFlattener.prototype.getLevel = /**
     * @param {?} node
     * @return {?}
     */
    function (node) {
        return node.level;
    };
    /**
     * @param {?} node
     * @return {?}
     */
    NxTreeFlattener.prototype.isExpandable = /**
     * @param {?} node
     * @return {?}
     */
    function (node) {
        return node.expandable;
    };
    /**
     * @param {?} node
     * @return {?}
     */
    NxTreeFlattener.prototype.getChildren = /**
     * @param {?} node
     * @return {?}
     */
    function (node) {
        return (/** @type {?} */ (node.children));
    };
    /**
     * @param {?} node
     * @param {?} level
     * @param {?} resultNodes
     * @param {?} parentMap
     * @return {?}
     */
    NxTreeFlattener.prototype._flattenNode = /**
     * @param {?} node
     * @param {?} level
     * @param {?} resultNodes
     * @param {?} parentMap
     * @return {?}
     */
    function (node, level, resultNodes, parentMap) {
        var _this = this;
        /** @type {?} */
        var flatNode = this.transformFunction(node, level);
        resultNodes.push(flatNode);
        if (this.isExpandable(flatNode)) {
            /** @type {?} */
            var childrenNodes = this.getChildren(node);
            if (Array.isArray(childrenNodes)) {
                this._flattenChildren(childrenNodes, level, resultNodes, parentMap);
            }
            else {
                childrenNodes.pipe(take(1)).subscribe((/**
                 * @param {?} children
                 * @return {?}
                 */
                function (children) {
                    _this._flattenChildren(children, level, resultNodes, parentMap);
                }));
            }
        }
        return resultNodes;
    };
    /**
     * @param {?} children
     * @param {?} level
     * @param {?} resultNodes
     * @param {?} parentMap
     * @return {?}
     */
    NxTreeFlattener.prototype._flattenChildren = /**
     * @param {?} children
     * @param {?} level
     * @param {?} resultNodes
     * @param {?} parentMap
     * @return {?}
     */
    function (children, level, resultNodes, parentMap) {
        var _this = this;
        children.forEach((/**
         * @param {?} child
         * @param {?} index
         * @return {?}
         */
        function (child, index) {
            /** @type {?} */
            var childParentMap = parentMap.slice();
            childParentMap.push(index != children.length - 1); // tslint:disable-line
            _this._flattenNode(child, level + 1, resultNodes, childParentMap);
        }));
    };
    /**
     * Flatten a list of node type T to flattened version of node F.
     * Please note that type T may be nested, and the length of `structuredData` may be different
     * from that of returned list `F[]`.
     */
    /**
     * Flatten a list of node type T to flattened version of node F.
     * Please note that type T may be nested, and the length of `structuredData` may be different
     * from that of returned list `F[]`.
     * @param {?} structuredData
     * @return {?}
     */
    NxTreeFlattener.prototype.flattenNodes = /**
     * Flatten a list of node type T to flattened version of node F.
     * Please note that type T may be nested, and the length of `structuredData` may be different
     * from that of returned list `F[]`.
     * @param {?} structuredData
     * @return {?}
     */
    function (structuredData) {
        var _this = this;
        /** @type {?} */
        var resultNodes = [];
        structuredData.forEach((/**
         * @param {?} node
         * @return {?}
         */
        function (node) { return _this._flattenNode(node, 0, resultNodes, []); }));
        return resultNodes;
    };
    /**
     * Expand flattened node with current expansion status.
     * The returned list may have different length.
     */
    /**
     * Expand flattened node with current expansion status.
     * The returned list may have different length.
     * @param {?} nodes
     * @param {?} treeControl
     * @return {?}
     */
    NxTreeFlattener.prototype.expandFlattenedNodes = /**
     * Expand flattened node with current expansion status.
     * The returned list may have different length.
     * @param {?} nodes
     * @param {?} treeControl
     * @return {?}
     */
    function (nodes, treeControl) {
        var _this = this;
        /** @type {?} */
        var results = [];
        /** @type {?} */
        var currentExpand = [];
        currentExpand[0] = true;
        nodes.forEach((/**
         * @param {?} node
         * @return {?}
         */
        function (node) {
            /** @type {?} */
            var expand = true;
            for (var i = 0; i <= _this.getLevel(node); i++) {
                expand = expand && currentExpand[i];
            }
            if (expand) {
                results.push(node);
            }
            if (_this.isExpandable(node)) {
                currentExpand[_this.getLevel(node) + 1] = treeControl.isExpanded(node);
            }
        }));
        return results;
    };
    return NxTreeFlattener;
}());
/**
 * Data source for flat tree.
 * The data source need to handle expansion/collapsion of the tree node and change the data feed
 * to `NxTree`.
 * The nested tree nodes of type `T extends NxTreeNode` are flattened through `NxTreeFlattener`, and converted
 * to type `F extends NxFlatTreeNode` for `NxTree` to consume.
 * @template T, F
 */
var /**
 * Data source for flat tree.
 * The data source need to handle expansion/collapsion of the tree node and change the data feed
 * to `NxTree`.
 * The nested tree nodes of type `T extends NxTreeNode` are flattened through `NxTreeFlattener`, and converted
 * to type `F extends NxFlatTreeNode` for `NxTree` to consume.
 * @template T, F
 */
NxTreeFlatDataSource = /** @class */ (function (_super) {
    tslib_1.__extends(NxTreeFlatDataSource, _super);
    function NxTreeFlatDataSource(treeControl, initialData) {
        if (initialData === void 0) { initialData = []; }
        var _this = _super.call(this) || this;
        _this.treeControl = treeControl;
        _this._flattenedData = new BehaviorSubject([]);
        _this._expandedData = new BehaviorSubject([]);
        _this._data = new BehaviorSubject([]);
        _this._treeFlattener = new NxTreeFlattener();
        _this.data = initialData;
        return _this;
    }
    Object.defineProperty(NxTreeFlatDataSource.prototype, "data", {
        get: /**
         * @return {?}
         */
        function () { return this._data.value; },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this._data.next(value);
            this._flattenedData.next(this._treeFlattener.flattenNodes(this.data));
            this.treeControl.dataNodes = this._flattenedData.value;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @param {?} collectionViewer
     * @return {?}
     */
    NxTreeFlatDataSource.prototype.connect = /**
     * @param {?} collectionViewer
     * @return {?}
     */
    function (collectionViewer) {
        var _this = this;
        /** @type {?} */
        var changes = [
            collectionViewer.viewChange,
            this.treeControl.expansionModel.changed,
            this._flattenedData
        ];
        return merge.apply(void 0, tslib_1.__spread(changes)).pipe(map((/**
         * @return {?}
         */
        function () {
            _this._expandedData.next(_this._treeFlattener.expandFlattenedNodes(_this._flattenedData.value, _this.treeControl));
            return _this._expandedData.value;
        })));
    };
    /**
     * @return {?}
     */
    NxTreeFlatDataSource.prototype.disconnect = /**
     * @return {?}
     */
    function () {
        // no op
    };
    return NxTreeFlatDataSource;
}(DataSource));
/**
 * Data source for flat tree.
 * The data source need to handle expansion/collapsion of the tree node and change the data feed
 * to `NxTree`.
 * The nested tree nodes of type `T extends NxTreeNode` are flattened through `NxTreeFlattener`, and converted
 * to type `F extends NxFlatTreeNode` for `NxTree` to consume.
 * @template T, F
 */
export { NxTreeFlatDataSource };
if (false) {
    /** @type {?} */
    NxTreeFlatDataSource.prototype._treeFlattener;
    /** @type {?} */
    NxTreeFlatDataSource.prototype._flattenedData;
    /** @type {?} */
    NxTreeFlatDataSource.prototype._expandedData;
    /** @type {?} */
    NxTreeFlatDataSource.prototype._data;
    /**
     * @type {?}
     * @private
     */
    NxTreeFlatDataSource.prototype.treeControl;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZmxhdC1kYXRhLXNvdXJjZS5qcyIsInNvdXJjZVJvb3QiOiJuZzovL0BhbGxpYW56L25neC1uZGJ4L3RyZWUvIiwic291cmNlcyI6WyJkYXRhLXNvdXJjZS9mbGF0LWRhdGEtc291cmNlLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7OztBQUFBLE9BQU8sRUFBbUIsVUFBVSxFQUFDLE1BQU0sMEJBQTBCLENBQUM7QUFDdEUsT0FBTyxFQUFDLGVBQWUsRUFBRSxLQUFLLEVBQWlCLE1BQU0sTUFBTSxDQUFDO0FBQzVELE9BQU8sRUFBQyxHQUFHLEVBQUUsSUFBSSxFQUFDLE1BQU0sZ0JBQWdCLENBQUM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQXVDekM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztJQUFBO0lBbUZBLENBQUM7Ozs7OztJQWxGQywyQ0FBaUI7Ozs7O0lBQWpCLFVBQWtCLElBQWdCLEVBQUUsS0FBYTtRQUN2QyxJQUFBLHdCQUFRLEVBQUUseUNBQU87UUFDekIsT0FBTyx3Q0FDRixJQUFJLElBQ1AsS0FBSyxPQUFBLEVBQ0wsVUFBVSxFQUFFLEtBQUssQ0FBQyxPQUFPLENBQUMsUUFBUSxDQUFDLElBQUksUUFBUSxDQUFDLE1BQU0sR0FBRyxDQUFDLEtBQ3RELENBQUM7SUFDVCxDQUFDOzs7OztJQUVELGtDQUFROzs7O0lBQVIsVUFBUyxJQUFPO1FBQ2QsT0FBTyxJQUFJLENBQUMsS0FBSyxDQUFDO0lBQ3BCLENBQUM7Ozs7O0lBRUQsc0NBQVk7Ozs7SUFBWixVQUFhLElBQU87UUFDbEIsT0FBTyxJQUFJLENBQUMsVUFBVSxDQUFDO0lBQ3pCLENBQUM7Ozs7O0lBRUQscUNBQVc7Ozs7SUFBWCxVQUFZLElBQU87UUFDakIsT0FBTyxtQkFBQSxJQUFJLENBQUMsUUFBUSxFQUFPLENBQUM7SUFDOUIsQ0FBQzs7Ozs7Ozs7SUFFRCxzQ0FBWTs7Ozs7OztJQUFaLFVBQWEsSUFBTyxFQUFFLEtBQWEsRUFD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TztZQUN2QyxJQUFJLENBQUMsY0FBYztTQUNwQjtRQUNELE9BQU8sS0FBSyxnQ0FBSSxPQUFPLEdBQUUsSUFBSSxDQUFDLEdBQUc7OztRQUFDO1lBQ2hDLEtBQUksQ0FBQyxhQUFhLENBQUMsSUFBSSxDQUNyQixLQUFJLENBQUMsY0FBYyxDQUFDLG9CQUFvQixDQUFDLEtBQUksQ0FBQyxjQUFjLENBQUMsS0FBSyxFQUFFLEtBQUksQ0FBQyxXQUFXLENBQUMsQ0FBQyxDQUFDO1lBQ3pGLE9BQU8sS0FBSSxDQUFDLGFBQWEsQ0FBQyxLQUFLLENBQUM7UUFDbEMsQ0FBQyxFQUFDLENBQUMsQ0FBQztJQUNOLENBQUM7Ozs7SUFFRCx5Q0FBVTs7O0lBQVY7UUFDRSxRQUFRO0lBQ1YsQ0FBQztJQUNILDJCQUFDO0FBQUQsQ0FBQyxBQXZDRCxDQUEwRixVQUFVLEdBdUNuRzs7Ozs7Ozs7Ozs7O0lBdENDLDhDQUFzQzs7SUFFdEMsOENBQThDOztJQUU5Qyw2Q0FBNkM7O0lBRTdDLHFDQUFxQzs7Ozs7SUFTekIsMkNBQXVDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtDb2xsZWN0aW9uVmlld2VyLCBEYXRhU291cmNlfSBmcm9tICdAYW5ndWxhci9jZGsvY29sbGVjdGlvbnMnO1xuaW1wb3J0IHtCZWhhdmlvclN1YmplY3QsIG1lcmdlLCBPYnNlcnZhYmxlLCBvZn0gZnJvbSAncnhqcyc7XG5pbXBvcnQge21hcCwgdGFrZX0gZnJvbSAncnhqcy9vcGVyYXRvcnMnO1xuaW1wb3J0IHsgTnhUcmVlTm9kZSwgTnhGbGF0VHJlZU5vZGUgfSBmcm9tICcuL3RyZWUtbm9kZSc7XG5pbXBvcnQgeyBOeEZsYXRUcmVlQ29udHJvbCB9IGZyb20gJy4vZmxhdC10cmVlLWNvbnRyb2wnO1xuaW1wb3J0IHsgVHJlZUNvbnRyb2wsIEZsYXRUcmVlQ29udHJvbCB9IGZyb20gJ0Bhbmd1bGFyL2Nkay90cmVlJztcblxuLyoqXG4gKiBUcmVlIGZsYXR0ZW5lciB0byBjb252ZXJ0IGEgbm9ybWFsIHR5cGUgb2Ygbm9kZSB0byBub2RlIHdpdGggY2hpbGRyZW4gJiBsZXZlbCBpbmZvcm1hdGlvbi5cbiAqIFRyYW5zZm9ybSBuZXN0ZWQgbm9kZXMgb2YgdHlwZSBgVCBleHRlbmRzIE54VHJlZU5vZGVgIHRvIGZsYXR0ZW5lZCBub2RlcyBvZiB0eXBlIGBGIGV4dGVuZHMgTnhGbGF0VHJlZU5vZGVgLlxuICpcbiAqIEZvciBleGFtcGxlLCB0aGUgaW5wdXQgZGF0YSBvZiB0eXBlIGBUYCBpcyBuZXN0ZWQsIGFuZCBjb250YWlucyBpdHMgY2hpbGRyZW4gZGF0YTpcbiAqICAgU29tZU5vZGU6IHtcbiAqICAgICBrZXk6ICdGcnVpdHMnLFxuICogICAgIGNoaWxkcmVuOiBbXG4gKiAgICAgICBOb2RlT25lOiB7XG4gKiAgICAgICAgIGtleTogJ0FwcGxlJyxcbiAqICAgICAgIH0sXG4gKiAgICAgICBOb2RlVHdvOiB7XG4gKiAgICAgICAga2V5OiAnUGVhcicsXG4gKiAgICAgIH1cbiAqICAgIF1cbiAqICB9XG4gKiAgQWZ0ZXIgZmxhdHRlbmVyIGZsYXR0ZW4gdGhlIHRyZWUsIHRoZSBzdHJ1Y3R1cmUgd2lsbCBiZWNvbWVcbiAqICBTb21lTm9kZToge1xuICogICAga2V5OiAnRnJ1aXRzJyxcbiAqICAgIGV4cGFuZGFibGU6IHRydWUsXG4gKiAgICBsZXZlbDogMVxuICogIH0sXG4gKiAgTm9kZU9uZToge1xuICogICAga2V5OiAnQXBwbGUnLFxuICogICAgZXhwYW5kYWJsZTogZmFsc2UsXG4gKiAgICBsZXZlbDogMlxuICogIH0sXG4gKiAgTm9kZVR3bzoge1xuICogICBrZXk6ICdQZWFyJyxcbiAqICAgZXhwYW5kYWJsZTogZmFsc2UsXG4gKiAgIGxldmVsOiAyXG4gKiB9XG4gKiBhbmQgdGhlIG91dHB1dCBmbGF0dGVuZWQgdHlwZSBpcyBgRiBleHRlbmRzIE54RmxhdFRyZWVOb2RlYCB3aXRoIGFkZGl0aW9uYWwgaW5mb3JtYXRpb24uXG4gKi9cbmNsYXNzIE54VHJlZUZsYXR0ZW5lcjxUIGV4dGVuZHMgTnhUcmVlTm9kZSwgRiBleHRlbmRzIE54RmxhdFRyZWVOb2RlPiB7XG4gIHRyYW5zZm9ybUZ1bmN0aW9uKG5vZGU6IE54VHJlZU5vZGUsIGxldmVsOiBudW1iZXIpOiBGIHtcbiAgICBjb25zdCB7IGNoaWxkcmVuLCAuLi5yZXN0IH0gPSBub2RlO1xuICAgIHJldHVybiB7XG4gICAgICAuLi5yZXN0LFxuICAgICAgbGV2ZWwsXG4gICAgICBleHBhbmRhYmxlOiBBcnJheS5pc0FycmF5KGNoaWxkcmVuKSAmJiBjaGlsZHJlbi5sZW5ndGggPiAwXG4gICAgfSBhcyBGO1xuICB9XG5cbiAgZ2V0TGV2ZWwobm9kZTogRik6IG51bWJlciB7XG4gICAgcmV0dXJuIG5vZGUubGV2ZWw7XG4gIH1cblxuICBpc0V4cGFuZGFibGUobm9kZTogRik6IGJvb2xlYW4ge1xuICAgIHJldHVybiBub2RlLmV4cGFuZGFibGU7XG4gIH1cblxuICBnZXRDaGlsZHJlbihub2RlOiBUKTogT2JzZXJ2YWJsZTxUW10+IHwgVFtdIHtcbiAgICByZXR1cm4gbm9kZS5jaGlsZHJlbiBhcyBUW107XG4gIH1cblxuICBfZmxhdHRlbk5vZGUobm9kZTogVCwgbGV2ZWw6IG51bWJlcixcbiAgICAgICAgICAgICAgIHJlc3VsdE5vZGVzOiBGW10sIHBhcmVudE1hcDogYm9vbGVhbltdKTogRltdIHtcbiAgICBjb25zdCBmbGF0Tm9kZSA9IHRoaXMudHJhbnNmb3JtRnVuY3Rpb24obm9kZSwgbGV2ZWwpO1xuICAgIHJlc3VsdE5vZGVzLnB1c2goZmxhdE5vZGUpO1xuXG4gICAgaWYgKHRoaXMuaXNFeHBhbmRhYmxlKGZsYXROb2RlKSkge1xuICAgICAgY29uc3QgY2hpbGRyZW5Ob2RlcyA9IHRoaXMuZ2V0Q2hpbGRyZW4obm9kZSk7XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShjaGlsZHJlbk5vZGVzKSkge1xuICAgICAgICB0aGlzLl9mbGF0dGVuQ2hpbGRyZW4oY2hpbGRyZW5Ob2RlcywgbGV2ZWwsIHJlc3VsdE5vZGVzLCBwYXJlbnRNYXApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY2hpbGRyZW5Ob2Rlcy5waXBlKHRha2UoMSkpLnN1YnNjcmliZShjaGlsZHJlbiA9PiB7XG4gICAgICAgICAgdGhpcy5fZmxhdHRlbkNoaWxkcmVuKGNoaWxkcmVuLCBsZXZlbCwgcmVzdWx0Tm9kZXMsIHBhcmVudE1hcCk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0Tm9kZXM7XG4gIH1cblxuICBfZmxhdHRlbkNoaWxkcmVuKGNoaWxkcmVuOiBUW10sIGxldmVsOiBudW1iZXIsXG4gICAgICAgICAgICAgICAgICAgcmVzdWx0Tm9kZXM6IEZbXSwgcGFyZW50TWFwOiBib29sZWFuW10pOiB2b2lkIHtcbiAgICBjaGlsZHJlbi5mb3JFYWNoKChjaGlsZCwgaW5kZXgpID0+IHtcbiAgICAgIGNvbnN0IGNoaWxkUGFyZW50TWFwOiBib29sZWFuW10gPSBwYXJlbnRNYXAuc2xpY2UoKTtcbiAgICAgIGNoaWxkUGFyZW50TWFwLnB1c2goaW5kZXggIT0gY2hpbGRyZW4ubGVuZ3RoIC0gMSk7IC8vIHRzbGludDpkaXNhYmxlLWxpbmVcbiAgICAgIHRoaXMuX2ZsYXR0ZW5Ob2RlKGNoaWxkLCBsZXZlbCArIDEsIHJlc3VsdE5vZGVzLCBjaGlsZFBhcmVudE1hcCk7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogRmxhdHRlbiBhIGxpc3Qgb2Ygbm9kZSB0eXBlIFQgdG8gZmxhdHRlbmVkIHZlcnNpb24gb2Ygbm9kZSBGLlxuICAgKiBQbGVhc2Ugbm90ZSB0aGF0IHR5cGUgVCBtYXkgYmUgbmVzdGVkLCBhbmQgdGhlIGxlbmd0aCBvZiBgc3RydWN0dXJlZERhdGFgIG1heSBiZSBkaWZmZXJlbnRcbiAgICogZnJvbSB0aGF0IG9mIHJldHVybmVkIGxpc3QgYEZbXWAuXG4gICAqL1xuICBmbGF0dGVuTm9kZXMoc3RydWN0dXJlZERhdGE6IFRbXSk6IEZbXSB7XG4gICAgY29uc3QgcmVzdWx0Tm9kZXM6IEZbXSA9IFtdO1xuICAgIHN0cnVjdHVyZWREYXRhLmZvckVhY2gobm9kZSA9PiB0aGlzLl9mbGF0dGVuTm9kZShub2RlLCAwLCByZXN1bHROb2RlcywgW10pKTtcbiAgICByZXR1cm4gcmVzdWx0Tm9kZXM7XG4gIH1cblxuICAvKipcbiAgICogRXhwYW5kIGZsYXR0ZW5lZCBub2RlIHdpdGggY3VycmVudCBleHBhbnNpb24gc3RhdHVzLlxuICAgKiBUaGUgcmV0dXJuZWQgbGlzdCBtYXkgaGF2ZSBkaWZmZXJlbnQgbGVuZ3RoLlxuICAgKi9cbiAgZXhwYW5kRmxhdHRlbmVkTm9kZXMobm9kZXM6IEZbXSwgdHJlZUNvbnRyb2w6IFRyZWVDb250cm9sPEY+KTogRltdIHtcbiAgICBjb25zdCByZXN1bHRzOiBGW10gPSBbXTtcbiAgICBjb25zdCBjdXJyZW50RXhwYW5kOiBib29sZWFuW10gPSBbXTtcbiAgICBjdXJyZW50RXhwYW5kWzBdID0gdHJ1ZTtcblxuICAgIG5vZGVzLmZvckVhY2gobm9kZSA9PiB7XG4gICAgICBsZXQgZXhwYW5kID0gdHJ1ZTtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDw9IHRoaXMuZ2V0TGV2ZWwobm9kZSk7IGkrKykge1xuICAgICAgICBleHBhbmQgPSBleHBhbmQgJiYgY3VycmVudEV4cGFuZFtpXTtcbiAgICAgIH1cbiAgICAgIGlmIChleHBhbmQpIHtcbiAgICAgICAgcmVzdWx0cy5wdXNoKG5vZGUpO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuaXNFeHBhbmRhYmxlKG5vZGUpKSB7XG4gICAgICAgIGN1cnJlbnRFeHBhbmRbdGhpcy5nZXRMZXZlbChub2RlKSArIDFdID0gdHJlZUNvbnRyb2wuaXNFeHBhbmRlZChub2RlKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gcmVzdWx0cztcbiAgfVxufVxuXG4vKipcbiAqIERhdGEgc291cmNlIGZvciBmbGF0IHRyZWUuXG4gKiBUaGUgZGF0YSBzb3VyY2UgbmVlZCB0byBoYW5kbGUgZXhwYW5zaW9uL2NvbGxhcHNpb24gb2YgdGhlIHRyZWUgbm9kZSBhbmQgY2hhbmdlIHRoZSBkYXRhIGZlZWRcbiAqIHRvIGBOeFRyZWVgLlxuICogVGhlIG5lc3RlZCB0cmVlIG5vZGVzIG9mIHR5cGUgYFQgZXh0ZW5kcyBOeFRyZWVOb2RlYCBhcmUgZmxhdHRlbmVkIHRocm91Z2ggYE54VHJlZUZsYXR0ZW5lcmAsIGFuZCBjb252ZXJ0ZWRcbiAqIHRvIHR5cGUgYEYgZXh0ZW5kcyBOeEZsYXRUcmVlTm9kZWAgZm9yIGBOeFRyZWVgIHRvIGNvbnN1bWUuXG4gKi9cbmV4cG9ydCBjbGFzcyBOeFRyZWVGbGF0RGF0YVNvdXJjZTxUIGV4dGVuZHMgTnhUcmVlTm9kZSwgRiBleHRlbmRzIE54RmxhdFRyZWVOb2RlPiBleHRlbmRzIERhdGFTb3VyY2U8Rj4ge1xuICBfdHJlZUZsYXR0ZW5lcjogTnhUcmVlRmxhdHRlbmVyPFQsIEY+O1xuXG4gIF9mbGF0dGVuZWREYXRhID0gbmV3IEJlaGF2aW9yU3ViamVjdDxGW10+KFtdKTtcblxuICBfZXhwYW5kZWREYXRhID0gbmV3IEJlaGF2aW9yU3ViamVjdDxGW10+KFtdKTtcblxuICBfZGF0YSA9IG5ldyBCZWhhdmlvclN1YmplY3Q8VFtdPihbXSk7XG5cbiAgZ2V0IGRhdGEoKSB7IHJldHVybiB0aGlzLl9kYXRhLnZhbHVlOyB9XG4gIHNldCBkYXRhKHZhbHVlOiBUW10pIHtcbiAgICB0aGlzLl9kYXRhLm5leHQodmFsdWUpO1xuICAgIHRoaXMuX2ZsYXR0ZW5lZERhdGEubmV4dCh0aGlzLl90cmVlRmxhdHRlbmVyLmZsYXR0ZW5Ob2Rlcyh0aGlzLmRhdGEpKTtcbiAgICB0aGlzLnRyZWVDb250cm9sLmRhdGFOb2RlcyA9IHRoaXMuX2ZsYXR0ZW5lZERhdGEudmFsdWU7XG4gIH1cblxuICBjb25zdHJ1Y3Rvcihwcml2YXRlIHRyZWVDb250cm9sOiBGbGF0VHJlZUNvbnRyb2w8Rj4sXG4gICAgICAgICAgICAgIGluaXRpYWxEYXRhOiBUW10gPSBbXSkge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5fdHJlZUZsYXR0ZW5lciA9IG5ldyBOeFRyZWVGbGF0dGVuZXIoKTtcbiAgICB0aGlzLmRhdGEgPSBpbml0aWFsRGF0YTtcbiAgfVxuXG4gIGNvbm5lY3QoY29sbGVjdGlvblZpZXdlcjogQ29sbGVjdGlvblZpZXdlcik6IE9ic2VydmFibGU8RltdPiB7XG4gICAgY29uc3QgY2hhbmdlcyA9IFtcbiAgICAgIGNvbGxlY3Rpb25WaWV3ZXIudmlld0NoYW5nZSxcbiAgICAgIHRoaXMudHJlZUNvbnRyb2wuZXhwYW5zaW9uTW9kZWwuY2hhbmdlZCxcbiAgICAgIHRoaXMuX2ZsYXR0ZW5lZERhdGFcbiAgICBdO1xuICAgIHJldHVybiBtZXJnZSguLi5jaGFuZ2VzKS5waXBlKG1hcCgoKSA9PiB7XG4gICAgICB0aGlzLl9leHBhbmRlZERhdGEubmV4dChcbiAgICAgICAgdGhpcy5fdHJlZUZsYXR0ZW5lci5leHBhbmRGbGF0dGVuZWROb2Rlcyh0aGlzLl9mbGF0dGVuZWREYXRhLnZhbHVlLCB0aGlzLnRyZWVDb250cm9sKSk7XG4gICAgICByZXR1cm4gdGhpcy5fZXhwYW5kZWREYXRhLnZhbHVlO1xuICAgIH0pKTtcbiAgfVxuXG4gIGRpc2Nvbm5lY3QoKSB7XG4gICAgLy8gbm8gb3BcbiAgfVxufVxuIl19