/**
 * @fileoverview added by tsickle
 * Generated from: mask.directive.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import { Directive, Input, ElementRef, forwardRef } from '@angular/core';
import { NG_VALUE_ACCESSOR, NG_VALIDATORS } from '@angular/forms';
import { coerceBooleanProperty } from '@angular/cdk/coercion';
import { NX_INPUT_VALUE_ACCESSOR } from '@allianz/ngx-ndbx/input';
import { BACKSPACE, DELETE } from '@angular/cdk/keycodes';
import { Subject } from 'rxjs';
/** @type {?} */
export var NX_MASK_VALUE_ACCESSOR = {
    provide: NG_VALUE_ACCESSOR,
    useExisting: forwardRef((/**
     * @return {?}
     */
    function () { return NxMaskDirective; })),
    multi: true
};
/** @type {?} */
export var NX_MASK_VALIDATORS = {
    provide: NG_VALIDATORS,
    useExisting: forwardRef((/**
     * @return {?}
     */
    function () { return NxMaskDirective; })),
    multi: true
};
/**
 * Interface for saving the cursor information.
 * @record
 */
function CursorInfo() { }
if (false) {
    /** @type {?|undefined} */
    CursorInfo.prototype.selectionStart;
    /** @type {?|undefined} */
    CursorInfo.prototype.selectionEnd;
    /** @type {?|undefined} */
    CursorInfo.prototype.position;
}
var NxMaskDirective = /** @class */ (function () {
    function NxMaskDirective(_elementRef) {
        this._elementRef = _elementRef;
        this._separators = ['/', '(', ')', '.', ':', '-', ' ', '+', ','];
        this._dropSpecialCharacters = false;
        this._validateMask = true;
        /**
         * Emits the unmasked value before the value changes.
         */
        this.cvaModelChange = new Subject();
        this._onChangeCallback = (/**
         * @param {?} _
         * @return {?}
         */
        function (_) { });
        this._onTouchedCallback = (/**
         * @return {?}
         */
        function () { });
        this._validatorOnChange = (/**
         * @return {?}
         */
        function () { });
        this._afterInputHook = (/**
         * @param {?} event
         * @return {?}
         */
        function (event) { });
        this._beforePasteHook = (/**
         * @param {?} event
         * @return {?}
         */
        function (event) { });
    }
    /**
     * @private
     * @return {?}
     */
    NxMaskDirective.prototype._callOnChangeCallback = /**
     * @private
     * @return {?}
     */
    function () {
        if (!this.dropSpecialCharacters) {
            this._onChangeCallback(this._elementRef.nativeElement.value);
        }
        else {
            this._onChangeCallback(this.getUnmaskedValue());
        }
    };
    /**
     * Registers a function to be executed after the onInput handler.
     * The registered hook receives a `KeyboardEvent` from the onInput event handler as a parameter.
     *
     * **Note:** If you register a `afterInputHook`, you may also register a `beforePasteHook`
     * to perform similar changes for pasting.
     */
    /**
     * Registers a function to be executed after the onInput handler.
     * The registered hook receives a `KeyboardEvent` from the onInput event handler as a parameter.
     *
     * **Note:** If you register a `afterInputHook`, you may also register a `beforePasteHook`
     * to perform similar changes for pasting.
     * @param {?} afterInput
     * @return {?}
     */
    NxMaskDirective.prototype.registerAfterInputHook = /**
     * Registers a function to be executed after the onInput handler.
     * The registered hook receives a `KeyboardEvent` from the onInput event handler as a parameter.
     *
     * **Note:** If you register a `afterInputHook`, you may also register a `beforePasteHook`
     * to perform similar changes for pasting.
     * @param {?} afterInput
     * @return {?}
     */
    function (afterInput) {
        this._afterInputHook = afterInput;
    };
    /**
     * Registers a function to be executed before the onPaste handler.
     * The registered hook receives a `ClipboardEvent` from the onPaste event handler as a parameter.
     */
    /**
     * Registers a function to be executed before the onPaste handler.
     * The registered hook receives a `ClipboardEvent` from the onPaste event handler as a parameter.
     * @param {?} beforePaste
     * @return {?}
     */
    NxMaskDirective.prototype.registerBeforePasteHook = /**
     * Registers a function to be executed before the onPaste handler.
     * The registered hook receives a `ClipboardEvent` from the onPaste event handler as a parameter.
     * @param {?} beforePaste
     * @return {?}
     */
    function (beforePaste) {
        this._beforePasteHook = beforePaste;
    };
    Object.defineProperty(NxMaskDirective.prototype, "mask", {
        get: /**
         * @return {?}
         */
        function () {
            return this._mask;
        },
        /** Sets the mask. */
        set: /**
         * Sets the mask.
         * @param {?} value
         * @return {?}
         */
        function (value) {
            if (!value) {
                value = '';
            }
            if (value !== this._mask) {
                this._mask = value;
                this.updateValue(this.getMaskedString(this._elementRef.nativeElement.value));
                this._callOnChangeCallback();
                this._validatorOnChange();
            }
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Sets the mask (for programmatical use).
     *
     * No `_onChangeCallback()` will be called!
     */
    /**
     * Sets the mask (for programmatical use).
     *
     * No `_onChangeCallback()` will be called!
     * @param {?} value
     * @return {?}
     */
    NxMaskDirective.prototype.setMask = /**
     * Sets the mask (for programmatical use).
     *
     * No `_onChangeCallback()` will be called!
     * @param {?} value
     * @return {?}
     */
    function (value) {
        if (!value) {
            value = '';
        }
        if (value !== this._mask) {
            this._mask = value;
            this.updateValue(this.getMaskedString(this._elementRef.nativeElement.value));
            this._validatorOnChange();
        }
    };
    Object.defineProperty(NxMaskDirective.prototype, "convertTo", {
        get: /**
         * @return {?}
         */
        function () {
            return this._convertTo;
        },
        /** Sets the case sensitivity of the mask. */
        set: /**
         * Sets the case sensitivity of the mask.
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this._convertTo = value;
            this.updateValue(this.getMaskedString(this._elementRef.nativeElement.value));
            this._callOnChangeCallback();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NxMaskDirective.prototype, "separators", {
        get: /**
         * @return {?}
         */
        function () {
            return this._separators;
        },
        /**
         * Sets the keys that are recognized as separators.
         * Default separators: / ( ) . : - + , and space.
         */
        set: /**
         * Sets the keys that are recognized as separators.
         * Default separators: / ( ) . : - + , and space.
         * @param {?} values
         * @return {?}
         */
        function (values) {
            this._separators = values;
            this.updateValue(this.getMaskedString(this._elementRef.nativeElement.value));
            this._validatorOnChange();
            this._callOnChangeCallback();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NxMaskDirective.prototype, "dropSpecialCharacters", {
        get: /**
         * @return {?}
         */
        function () {
            return this._dropSpecialCharacters;
        },
        /** Whether the separators should be dropped in the control value accessor. */
        set: /**
         * Whether the separators should be dropped in the control value accessor.
         * @param {?} value
         * @return {?}
         */
        function (value) {
            /** @type {?} */
            var newValue = coerceBooleanProperty(value);
            if (newValue !== this._dropSpecialCharacters) {
                this._dropSpecialCharacters = newValue;
                this.updateValue(this.getMaskedString(this._elementRef.nativeElement.value));
                this._callOnChangeCallback();
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NxMaskDirective.prototype, "validateMask", {
        get: /**
         * @return {?}
         */
        function () {
            return this._validateMask;
        },
        /** Whether the mask validation should be applied on the input. Default: true. */
        set: /**
         * Whether the mask validation should be applied on the input. Default: true.
         * @param {?} value
         * @return {?}
         */
        function (value) {
            /** @type {?} */
            var newValue = coerceBooleanProperty(value);
            if (newValue !== this._validateMask) {
                this._validateMask = newValue;
                this._validatorOnChange();
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NxMaskDirective.prototype, "elementRefValue", {
        /** @docs-private */
        get: /**
         * \@docs-private
         * @return {?}
         */
        function () {
            return this._elementRef.nativeElement.value;
        },
        enumerable: true,
        configurable: true
    });
    /** Returns the unmasked value. */
    /**
     * Returns the unmasked value.
     * @return {?}
     */
    NxMaskDirective.prototype.getUnmaskedValue = /**
     * Returns the unmasked value.
     * @return {?}
     */
    function () {
        /** @type {?} */
        var unmaskedValue = this.separators.reduce((/**
         * @param {?} unmasked
         * @param {?} separator
         * @return {?}
         */
        function (unmasked, separator) {
            return unmasked.split(separator).join('');
        }), this._elementRef.nativeElement.value);
        return unmaskedValue;
    };
    /**
     * this._cursor can be set to a new value in this function;
     * in _onInputChange() it is then used to set the cursor position.
     */
    /**
     * this._cursor can be set to a new value in this function;
     * in _onInputChange() it is then used to set the cursor position.
     * @param {?} event
     * @return {?}
     */
    NxMaskDirective.prototype._onKeydown = /**
     * this._cursor can be set to a new value in this function;
     * in _onInputChange() it is then used to set the cursor position.
     * @param {?} event
     * @return {?}
     */
    function (event) {
        /** @type {?} */
        var keyCode = event.keyCode;
        /** @type {?} */
        var input = (/** @type {?} */ (event.target));
        /** @type {?} */
        var currentValue = this._elementRef.nativeElement.value;
        if (keyCode === BACKSPACE || keyCode === DELETE) {
            // if backspace pressed, cursor has to move one character to start
            /** @type {?} */
            var backspaceShift = keyCode === BACKSPACE ? 1 : 0;
            /** @type {?} */
            var lastCharacter = currentValue.substring(input.selectionStart - backspaceShift, input.selectionEnd - backspaceShift + 1);
            /** @type {?} */
            var selectionAtLastCharacter = (input.selectionStart === currentValue.length - 1 + backspaceShift);
            if (input.selectionStart !== input.selectionEnd) {
                /** @type {?} */
                var newPosition = input.selectionStart;
                // jump behind separators, but do not shift after the next character (=> don't use _calculateCursorShift())
                while (this.isSeparator(this.mask[newPosition])) {
                    newPosition++;
                }
                this._cursor = { position: newPosition };
            }
            else if (selectionAtLastCharacter) {
                // if last character is deleted: only delete last character, do not trigger input event again
                // (here the separator would be added again)
                this.updateValue(currentValue.substring(0, currentValue.length - 1));
                this._callOnChangeCallback();
                event.preventDefault();
            }
            else if (this.isSeparator(lastCharacter)) {
                // do not delete a separator, only set cursor position
                input.setSelectionRange(input.selectionStart - backspaceShift, input.selectionEnd - backspaceShift);
                event.preventDefault();
            }
            else {
                // for any other character: decrease cursor position by one (backspaceShift).
                // the input is modified and will be validated in _onInputChange().
                this._cursor = { position: input.selectionStart - backspaceShift };
            }
        }
        else {
            this._cursor = { selectionStart: input.selectionStart, selectionEnd: input.selectionEnd };
        }
    };
    /**
     * Returns the cursor position after a letter is entered at `selectionStart` position in the mask.
     * There are two cases to consider ('|' => cursor position where the character is entered, mask: 00:00:00):
     * - before the separators there is space for entering the letter: '12:3|4:5' => '12:30:|45'
     * - the letter has to be shifted and is entered after the separators: '12:34|:5' => '12:34:0|5'
     */
    /**
     * Returns the cursor position after a letter is entered at `selectionStart` position in the mask.
     * There are two cases to consider ('|' => cursor position where the character is entered, mask: 00:00:00):
     * - before the separators there is space for entering the letter: '12:3|4:5' => '12:30:|45'
     * - the letter has to be shifted and is entered after the separators: '12:34|:5' => '12:34:0|5'
     * @private
     * @param {?} position
     * @return {?}
     */
    NxMaskDirective.prototype._calculateCursorShift = /**
     * Returns the cursor position after a letter is entered at `selectionStart` position in the mask.
     * There are two cases to consider ('|' => cursor position where the character is entered, mask: 00:00:00):
     * - before the separators there is space for entering the letter: '12:3|4:5' => '12:30:|45'
     * - the letter has to be shifted and is entered after the separators: '12:34|:5' => '12:34:0|5'
     * @private
     * @param {?} position
     * @return {?}
     */
    function (position) {
        /** @type {?} */
        var shift = 0;
        // tracks if the entered letter was already placed in the current mask
        // and therefor was considered in the cursor calculation.
        /** @type {?} */
        var characterWasEntered = false;
        if (!this.isSeparator(this.mask[position + shift])) {
            shift++;
            characterWasEntered = true;
        }
        while (this.isSeparator(this.mask[position + shift])) {
            shift++;
        }
        if (!characterWasEntered) {
            shift++;
        }
        return shift;
    };
    /**
     * @private
     * @param {?} value
     * @param {?} maskedValue
     * @return {?}
     */
    NxMaskDirective.prototype._isStringAllowed = /**
     * @private
     * @param {?} value
     * @param {?} maskedValue
     * @return {?}
     */
    function (value, maskedValue) {
        if ((maskedValue === '0' && /^[0-9]{1}$/.test(value))
            || (maskedValue === 'A' && /^[a-zA-Z0-9]{1}$/.test(value))
            || (maskedValue === 'S' && /^[a-zA-Z]{1}$/.test(value))) {
            return true;
        }
        return false;
    };
    /**
     * Handles the onInput event.
     * `_beforeInputHook()` is called before the actual execution.
     *
     */
    /**
     * Handles the onInput event.
     * `_beforeInputHook()` is called before the actual execution.
     *
     * @param {?} event
     * @return {?}
     */
    NxMaskDirective.prototype._onInputChange = /**
     * Handles the onInput event.
     * `_beforeInputHook()` is called before the actual execution.
     *
     * @param {?} event
     * @return {?}
     */
    function (event) {
        // _inputValue is updated in updateValue(), so I need to pick it up here to compare it to a new value
        /** @type {?} */
        var oldVal = this._inputValue;
        /** @type {?} */
        var input = (/** @type {?} */ (event.target));
        /** @type {?} */
        var newVal = this.getMaskedString(input.value);
        // if _pastedData was set in _onPaste(), use this value
        if (this._pastedData) {
            this.updateValue(this._pastedData);
            input.setSelectionRange(this._cursor.position, this._cursor.position);
            this._pastedData = null;
            this._cursor = null;
            this._callOnChangeCallback();
            return;
        }
        // do nothing if mask is already filled up
        if (oldVal.length === this._mask.length
            && newVal.length === this._mask.length
            && oldVal !== newVal
            && (this._cursor
                && this._cursor.selectionStart !== undefined
                && this._cursor.selectionStart === this._cursor.selectionEnd)) {
            this._elementRef.nativeElement.value = this.getMaskedString(oldVal);
            input.setSelectionRange(this._cursor.selectionStart, this._cursor.selectionEnd);
            this._cursor = null;
            return;
        }
        this.updateValue(newVal);
        // set new cursor position
        if (this._cursor && this._cursor.position !== undefined) {
            input.setSelectionRange(this._cursor.position, this._cursor.position);
            this._cursor = null;
        }
        else if (this._cursor && this._cursor.selectionStart !== undefined) {
            // only one character can be entered (except pasting, this is calculated in _onPaste())
            if (oldVal !== input.value) {
                /** @type {?} */
                var newPosition = this._cursor.selectionStart + this._calculateCursorShift(this._cursor.selectionStart);
                input.setSelectionRange(newPosition, newPosition);
                this._cursor = null;
            }
            else {
                // we always have to set the cursor position here even if nothing changed
                // because otherwise the cursor would jump to the end of the input.
                // if the cursor is placed in front of a separator and the user types a non-allowed character,
                // the cursor is supposed to jump over the separator.
                /** @type {?} */
                var currentPosition = this._cursor.selectionStart;
                while (this.isSeparator(this.mask[currentPosition])) {
                    currentPosition++;
                }
                input.setSelectionRange(currentPosition, currentPosition);
                this._cursor = null;
            }
        }
        this._afterInputHook(event);
        this._callOnChangeCallback();
    };
    /**
     * this._cursor and this._pastedData can be set to a new value in this function;
     * _cursor is used to set the cursor position after checking the masked input in _onInputChange().
     * _pastedData carries the valid part of the pasted value to _inInputChange();
     *
     *`_beforePasteHook()` is called before the actual execution.
     */
    /**
     * this._cursor and this._pastedData can be set to a new value in this function;
     * _cursor is used to set the cursor position after checking the masked input in _onInputChange().
     * _pastedData carries the valid part of the pasted value to _inInputChange();
     *
     * `_beforePasteHook()` is called before the actual execution.
     * @param {?} event
     * @return {?}
     */
    NxMaskDirective.prototype._onPaste = /**
     * this._cursor and this._pastedData can be set to a new value in this function;
     * _cursor is used to set the cursor position after checking the masked input in _onInputChange().
     * _pastedData carries the valid part of the pasted value to _inInputChange();
     *
     * `_beforePasteHook()` is called before the actual execution.
     * @param {?} event
     * @return {?}
     */
    function (event) {
        /** @type {?} */
        var input = (/** @type {?} */ (event.target));
        /** @type {?} */
        var pastedData = (event.clipboardData || ((/** @type {?} */ (window))).clipboardData).getData('text');
        // saving these three values as if something is changed in the _beforePasteHook()
        // which causes the input value to be updated, this values will get lost.
        /** @type {?} */
        var selectionStart = input.selectionStart;
        /** @type {?} */
        var selectionEnd = input.selectionEnd;
        /** @type {?} */
        var oldValue = input.value;
        this._beforePasteHook(event);
        /** @type {?} */
        var maskedString = this.getMaskedString(pastedData, selectionStart);
        // if mask is already filled up (and no characters are selected with the cursor), do nothing
        if (input.value.length === this._mask.length
            && maskedString.length > 0
            && selectionStart === selectionEnd) {
            input.setSelectionRange(selectionStart, selectionEnd);
            this._cursor = null; // was set in _onKeydown(), but will not be used in this case; so reset it
            event.preventDefault();
            return;
        }
        // if length of newValue is >= mask: allow only to enter characters from a pasted value until mask is filled up
        // example: 12:|34: ("|" cursor position, mask: 00:00:00) => when pasting '567', only '56' fits in until input is filled up => 12:56:|34
        // get the pasted unmasked value from the pasted string (to cut all the invalid characters and separators)
        /** @type {?} */
        var pastedUnmaskedValue = this.separators.reduce((/**
         * @param {?} unmasked
         * @param {?} separator
         * @return {?}
         */
        function (unmasked, separator) { return unmasked.split(separator).join(''); }), maskedString);
        /** @type {?} */
        var newValue = this.getMaskedString(oldValue.substring(0, selectionStart)
            + pastedUnmaskedValue
            + oldValue.substring(selectionEnd, oldValue.length));
        if (newValue.length >= this._mask.length) {
            /** @type {?} */
            var newPosition = selectionStart;
            /** @type {?} */
            var i = 1;
            do {
                newValue = this.getMaskedString(oldValue.substring(0, selectionStart)
                    + pastedUnmaskedValue.substring(0, i)
                    + oldValue.substring(selectionEnd, oldValue.length));
                newPosition += this._calculateCursorShift(newPosition);
                i++;
            } while (newValue.length < this._mask.length);
            // save value for using it in _onInputChange()
            this._pastedData = newValue;
            this._cursor = {
                position: newPosition
            };
            return;
        }
        // if pasting is fine: save the cursor position for using them in _onInputChange()
        this._cursor = {
            position: selectionStart + maskedString.length
        };
    };
    /**
     * @private
     * @param {?} value
     * @return {?}
     */
    NxMaskDirective.prototype.updateValue = /**
     * @private
     * @param {?} value
     * @return {?}
     */
    function (value) {
        // Write UpperCase
        if (this._convertTo === 'upper') {
            value = value.toUpperCase();
        }
        else if (this._convertTo === 'lower') {
            value = value.toLowerCase();
        }
        this._elementRef.nativeElement.value = value;
        // _inputValue is needed for calculating the cursor shift in onInput()
        this._inputValue = value;
    };
    /** @docs-private */
    /**
     * \@docs-private
     * @param {?} inputValue
     * @param {?=} maskStartIndex
     * @return {?}
     */
    NxMaskDirective.prototype.getMaskedString = /**
     * \@docs-private
     * @param {?} inputValue
     * @param {?=} maskStartIndex
     * @return {?}
     */
    function (inputValue, maskStartIndex) {
        if (maskStartIndex === void 0) { maskStartIndex = 0; }
        /** @type {?} */
        var formattedValue = '';
        /** @type {?} */
        var maskIndex = maskStartIndex;
        /** @type {?} */
        var inputIndex = 0;
        // insert if next in mask is separator
        while (this.isSeparator(this.mask[maskIndex])) {
            formattedValue += this.mask[maskIndex];
            maskIndex++;
        }
        while (inputIndex < inputValue.length) {
            // test if letters are valid
            if (this._isStringAllowed(inputValue[inputIndex], (/** @type {?} */ (this.mask[maskIndex])))) {
                formattedValue += inputValue[inputIndex];
                inputIndex++;
                maskIndex++;
            }
            else {
                inputIndex++;
            }
            // insert if next in mask is separator
            while (this.isSeparator(this.mask[maskIndex])) {
                formattedValue += this.mask[maskIndex];
                maskIndex++;
            }
        }
        return formattedValue;
    };
    /**
     * @private
     * @param {?} value
     * @return {?}
     */
    NxMaskDirective.prototype.isSeparator = /**
     * @private
     * @param {?} value
     * @return {?}
     */
    function (value) {
        return (this._separators.indexOf(value) !== -1);
    };
    // control value accessor
    // control value accessor
    /**
     * @param {?} value
     * @return {?}
     */
    NxMaskDirective.prototype.writeValue = 
    // control value accessor
    /**
     * @param {?} value
     * @return {?}
     */
    function (value) {
        if (!value) {
            value = '';
        }
        this.cvaModelChange.next(value);
        this.updateValue(this.getMaskedString(value));
    };
    /**
     * @param {?} onChange
     * @return {?}
     */
    NxMaskDirective.prototype.registerOnChange = /**
     * @param {?} onChange
     * @return {?}
     */
    function (onChange) {
        this._onChangeCallback = onChange;
    };
    /**
     * @param {?} onTouched
     * @return {?}
     */
    NxMaskDirective.prototype.registerOnTouched = /**
     * @param {?} onTouched
     * @return {?}
     */
    function (onTouched) {
        this._onTouchedCallback = onTouched;
    };
    /** @docs-private */
    /**
     * \@docs-private
     * @param {?} fn
     * @return {?}
     */
    NxMaskDirective.prototype.registerOnValidatorChange = /**
     * \@docs-private
     * @param {?} fn
     * @return {?}
     */
    function (fn) {
        this._validatorOnChange = fn;
    };
    /**
     * @return {?}
     */
    NxMaskDirective.prototype._validateFn = /**
     * @return {?}
     */
    function () {
        /** @type {?} */
        var inputLength = this._elementRef.nativeElement.value.length;
        /** @type {?} */
        var maskLength = this._mask.length;
        if (inputLength !== maskLength) {
            return { nxMaskLengthError: { 'length': maskLength, 'actual': inputLength } };
        }
        return null;
    };
    /** @docs-private */
    /**
     * \@docs-private
     * @return {?}
     */
    NxMaskDirective.prototype.validate = /**
     * \@docs-private
     * @return {?}
     */
    function () {
        return this.validateMask ? this._validateFn() : null;
    };
    /**
     * @return {?}
     */
    NxMaskDirective.prototype._touch = /**
     * @return {?}
     */
    function () {
        this._onTouchedCallback();
    };
    NxMaskDirective.decorators = [
        { type: Directive, args: [{
                    selector: 'input[nxMask]',
                    host: {
                        '(input)': '_onInputChange($event)',
                        '(keydown)': '_onKeydown($event)',
                        '(paste)': '_onPaste($event)',
                        '(blur)': '_touch()'
                    },
                    exportAs: 'nxMaskDirective',
                    providers: [
                        NX_MASK_VALUE_ACCESSOR,
                        { provide: NX_INPUT_VALUE_ACCESSOR, useExisting: NxMaskDirective },
                        NX_MASK_VALIDATORS
                    ]
                },] }
    ];
    /** @nocollapse */
    NxMaskDirective.ctorParameters = function () { return [
        { type: ElementRef }
    ]; };
    NxMaskDirective.propDecorators = {
        mask: [{ type: Input, args: ['nxMask',] }],
        convertTo: [{ type: Input, args: ['nxConvertTo',] }],
        separators: [{ type: Input }],
        dropSpecialCharacters: [{ type: Input }],
        validateMask: [{ type: Input }]
    };
    return NxMaskDirective;
}());
export { NxMaskDirective };
if (false) {
    /**
     * @type {?}
     * @private
     */
    NxMaskDirective.prototype._mask;
    /**
     * @type {?}
     * @private
     */
    NxMaskDirective.prototype._separators;
    /**
     * @type {?}
     * @private
     */
    NxMaskDirective.prototype._dropSpecialCharacters;
    /**
     * @type {?}
     * @private
     */
    NxMaskDirective.prototype._validateMask;
    /**
     * @type {?}
     * @private
     */
    NxMaskDirective.prototype._convertTo;
    /**
     * _cursor is a helper for saving a position or a selectionRange (selectionStart + selectionEnd)
     * and then apply it later on (in _onInputChange()).
     *
     * _cursor.position is used for saving a position that is then applied without any changes.
     * if the position is saved, selectionStart and selectionEnd will be ignored in _onInputChange().
     * _cursor.selectionStart and selectionEnd is used for saving the current cursor position,
     * and a new cursor position is then calculated with this data.
     * @type {?}
     * @private
     */
    NxMaskDirective.prototype._cursor;
    /**
     * helper variable for saving the current value of the input element to compare it then with a new value.
     * @type {?}
     * @private
     */
    NxMaskDirective.prototype._inputValue;
    /**
     * helper variable for saving the masked string of a pasted value and then applying it in _onInputChange().
     * @type {?}
     * @private
     */
    NxMaskDirective.prototype._pastedData;
    /**
     * Emits the unmasked value before the value changes.
     * @type {?}
     */
    NxMaskDirective.prototype.cvaModelChange;
    /**
     * @type {?}
     * @private
     */
    NxMaskDirective.prototype._onChangeCallback;
    /**
     * @type {?}
     * @private
     */
    NxMaskDirective.prototype._onTouchedCallback;
    /**
     * @type {?}
     * @private
     */
    NxMaskDirective.prototype._validatorOnChange;
    /**
     * @type {?}
     * @private
     */
    NxMaskDirective.prototype._afterInputHook;
    /**
     * @type {?}
     * @private
     */
    NxMaskDirective.prototype._beforePasteHook;
    /**
     * @type {?}
     * @private
     */
    NxMaskDirective.prototype._elementRef;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibWFzay5kaXJlY3RpdmUuanMiLCJzb3VyY2VSb290Ijoibmc6Ly9AYWxsaWFuei9uZ3gtbmRieC9tYXNrLyIsInNvdXJjZXMiOlsibWFzay5kaXJlY3RpdmUudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQSxPQUFPLEVBQUUsU0FBUyxFQUFFLEtBQUssRUFBRSxVQUFVLEVBQUUsVUFBVSxFQUFFLE1BQU0sZUFBZSxDQUFDO0FBQ3pFLE9BQU8sRUFFTCxpQkFBaUIsRUFDakIsYUFBYSxFQUVkLE1BQU0sZ0JBQWdCLENBQUM7QUFDeEIsT0FBTyxFQUFFLHFCQUFxQixFQUFFLE1BQU0sdUJBQXVCLENBQUM7QUFDOUQsT0FBTyxFQUFFLHVCQUF1QixFQUFFLE1BQU0seUJBQXlCLENBQUM7QUFDbEUsT0FBTyxFQUFFLFNBQVMsRUFBRSxNQUFNLEVBQUUsTUFBTSx1QkFBdUIsQ0FBQztBQUMxRCxPQUFPLEVBQUUsT0FBTyxFQUFFLE1BQU0sTUFBTSxDQUFDOztBQUkvQixNQUFNLEtBQU8sc0JBQXNCLEdBQVE7SUFDekMsT0FBTyxFQUFFLGlCQUFpQjtJQUMxQixXQUFXLEVBQUUsVUFBVTs7O0lBQUMsY0FBTSxPQUFBLGVBQWUsRUFBZixDQUFlLEVBQUM7SUFDOUMsS0FBSyxFQUFFLElBQUk7Q0FDWjs7QUFFRCxNQUFNLEtBQU8sa0JBQWtCLEdBQVE7SUFDckMsT0FBTyxFQUFFLGFBQWE7SUFDdEIsV0FBVyxFQUFFLFVBQVU7OztJQUFDLGNBQU0sT0FBQSxlQUFlLEVBQWYsQ0FBZSxFQUFDO0lBQzlDLEtBQUssRUFBRSxJQUFJO0NBQ1o7Ozs7O0FBTUQseUJBSUM7OztJQUhDLG9DQUF3Qjs7SUFDeEIsa0NBQXNCOztJQUN0Qiw4QkFBa0I7O0FBR3BCO0lBcUtFLHlCQUNVLFdBQXVCO1FBQXZCLGdCQUFXLEdBQVgsV0FBVyxDQUFZO1FBcEp6QixnQkFBVyxHQUFHLENBQUMsR0FBRyxFQUFFLEdBQUcsRUFBRSxHQUFHLEVBQUUsR0FBRyxFQUFFLEdBQUcs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Ozs7SUFXekMsa0NBQTRCOzs7Ozs7SUFHNUIsc0NBQTRCOzs7Ozs7SUFHNUIsc0NBQTRCOzs7OztJQUs1Qix5Q0FBZ0Q7Ozs7O0lBRWhELDRDQUE0Qzs7Ozs7SUFDNUMsNkNBQXVDOzs7OztJQUN2Qyw2Q0FBc0M7Ozs7O0lBVXRDLDBDQUF3RDs7Ozs7SUFDeEQsMkNBQTBEOzs7OztJQTRHeEQsc0NBQStCIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgRGlyZWN0aXZlLCBJbnB1dCwgRWxlbWVudFJlZiwgZm9yd2FyZFJlZiB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHtcbiAgQ29udHJvbFZhbHVlQWNjZXNzb3IsXG4gIE5HX1ZBTFVFX0FDQ0VTU09SLFxuICBOR19WQUxJREFUT1JTLFxuICBWYWxpZGF0b3Jcbn0gZnJvbSAnQGFuZ3VsYXIvZm9ybXMnO1xuaW1wb3J0IHsgY29lcmNlQm9vbGVhblByb3BlcnR5IH0gZnJvbSAnQGFuZ3VsYXIvY2RrL2NvZXJjaW9uJztcbmltcG9ydCB7IE5YX0lOUFVUX1ZBTFVFX0FDQ0VTU09SIH0gZnJvbSAnQGFsbGlhbnovbmd4LW5kYngvaW5wdXQnO1xuaW1wb3J0IHsgQkFDS1NQQUNFLCBERUxFVEUgfSBmcm9tICdAYW5ndWxhci9jZGsva2V5Y29kZXMnO1xuaW1wb3J0IHsgU3ViamVjdCB9IGZyb20gJ3J4anMnO1xuXG50eXBlIE1BU0tfVFlQRSA9ICcwJyB8ICdBJyB8ICdTJztcblxuZXhwb3J0IGNvbnN0IE5YX01BU0tfVkFMVUVfQUNDRVNTT1I6IGFueSA9IHtcbiAgcHJvdmlkZTogTkdfVkFMVUVfQUNDRVNTT1IsXG4gIHVzZUV4aXN0aW5nOiBmb3J3YXJkUmVmKCgpID0+IE54TWFza0RpcmVjdGl2ZSksXG4gIG11bHRpOiB0cnVlXG59O1xuXG5leHBvcnQgY29uc3QgTlhfTUFTS19WQUxJREFUT1JTOiBhbnkgPSB7XG4gIHByb3ZpZGU6IE5HX1ZBTElEQVRPUlMsXG4gIHVzZUV4aXN0aW5nOiBmb3J3YXJkUmVmKCgpID0+IE54TWFza0RpcmVjdGl2ZSksXG4gIG11bHRpOiB0cnVlXG59O1xuXG4vKiogT3B0aW9ucyBmb3IgaW5wdXQgY2FzZSBzZW5zaXRpdml0eS4gKi9cbmV4cG9ydCB0eXBlIE1hc2tDb252ZXJzaW9uVHlwZXMgPSAnbG93ZXInIHwgJ3VwcGVyJztcblxuLyoqIEludGVyZmFjZSBmb3Igc2F2aW5nIHRoZSBjdXJzb3IgaW5mb3JtYXRpb24uICovXG5pbnRlcmZhY2UgQ3Vyc29ySW5mbyB7XG4gIHNlbGVjdGlvblN0YXJ0PzogbnVtYmVyO1xuICBzZWxlY3Rpb25FbmQ/OiBudW1iZXI7XG4gIHBvc2l0aW9uPzogbnVtYmVyO1xufVxuXG5ARGlyZWN0aXZlKHtcbiAgc2VsZWN0b3I6ICdpbnB1dFtueE1hc2tdJyxcbiAgaG9zdDoge1xuICAgICcoaW5wdXQpJzogJ19vbklucHV0Q2hhbmdlKCRldmVudCknLFxuICAgICcoa2V5ZG93biknOiAnX29uS2V5ZG93bigkZXZlbnQpJyxcbiAgICAnKHBhc3RlKSc6ICdfb25QYXN0ZSgkZXZlbnQpJyxcbiAgICAnKGJsdXIpJzogJ190b3VjaCgpJ1xuICB9LFxuICBleHBvcnRBczogJ254TWFza0RpcmVjdGl2ZScsXG4gIHByb3ZpZGVyczogW1xuICAgIE5YX01BU0tfVkFMVUVfQUNDRVNTT1IsXG4gICAgeyBwcm92aWRlOiBOWF9JTlBVVF9WQUxVRV9BQ0NFU1NPUiwgdXNlRXhpc3Rpbmc6IE54TWFza0RpcmVjdGl2ZSB9LFxuICAgIE5YX01BU0tfVkFMSURBVE9SU1xuICBdXG59KVxuZXhwb3J0IGNsYXNzIE54TWFza0RpcmVjdGl2ZSBpbXBsZW1lbnRzIENvbnRyb2xWYWx1ZUFjY2Vzc29yLCBWYWxpZGF0b3Ige1xuXG4gIHByaXZhdGUgX21hc2s6IHN0cmluZztcbiAgcHJpdmF0ZSBfc2VwYXJhdG9ycyA9IFsnLycsICcoJywgJyknLCAnLicsICc6JywgJy0nLCAnICcsICcrJywgJywnXTtcbiAgcHJpdmF0ZSBfZHJvcFNwZWNpYWxDaGFyYWN0ZXJzOiBib29sZWFuID0gZmFsc2U7XG4gIHByaXZhdGUgX3ZhbGlkYXRlTWFzazogYm9vbGVhbiA9IHRydWU7XG4gIHByaXZhdGUgX2NvbnZlcnRUbz86IE1hc2tDb252ZXJzaW9uVHlwZXM7XG5cbiAgLyoqXG4gICAqIF9jdXJzb3IgaXMgYSBoZWxwZXIgZm9yIHNhdmluZyBhIHBvc2l0aW9uIG9yIGEgc2VsZWN0aW9uUmFuZ2UgKHNlbGVjdGlvblN0YXJ0ICsgc2VsZWN0aW9uRW5kKVxuICAgKiBhbmQgdGhlbiBhcHBseSBpdCBsYXRlciBvbiAoaW4gX29uSW5wdXRDaGFuZ2UoKSkuXG4gICAqXG4gICAqIF9jdXJzb3IucG9zaXRpb24gaXMgdXNlZCBmb3Igc2F2aW5nIGEgcG9zaXRpb24gdGhhdCBpcyB0aGVuIGFwcGxpZWQgd2l0aG91dCBhbnkgY2hhbmdlcy5cbiAgICogaWYgdGhlIHBvc2l0aW9uIGlzIHNhdmVkLCBzZWxlY3Rpb25TdGFydCBhbmQgc2VsZWN0aW9uRW5kIHdpbGwgYmUgaWdub3JlZCBpbiBfb25JbnB1dENoYW5nZSgpLlxuICAgKiBfY3Vyc29yLnNlbGVjdGlvblN0YXJ0IGFuZCBzZWxlY3Rpb25FbmQgaXMgdXNlZCBmb3Igc2F2aW5nIHRoZSBjdXJyZW50IGN1cnNvciBwb3NpdGlvbixcbiAgICogYW5kIGEgbmV3IGN1cnNvciBwb3NpdGlvbiBpcyB0aGVuIGNhbGN1bGF0ZWQgd2l0aCB0aGlzIGRhdGEuXG4gICAqL1xuICBwcml2YXRlIF9jdXJzb3I6IEN1cnNvckluZm87XG5cbiAgLyoqIGhlbHBlciB2YXJpYWJsZSBmb3Igc2F2aW5nIHRoZSBjdXJyZW50IHZhbHVlIG9mIHRoZSBpbnB1dCBlbGVtZW50IHRvIGNvbXBhcmUgaXQgdGhlbiB3aXRoIGEgbmV3IHZhbHVlLiAqL1xuICBwcml2YXRlIF9pbnB1dFZhbHVlOiBzdHJpbmc7XG5cbiAgLyoqIGhlbHBlciB2YXJpYWJsZSBmb3Igc2F2aW5nIHRoZSBtYXNrZWQgc3RyaW5nIG9mIGEgcGFzdGVkIHZhbHVlIGFuZCB0aGVuIGFwcGx5aW5nIGl0IGluIF9vbklucHV0Q2hhbmdlKCkuICovXG4gIHByaXZhdGUgX3Bhc3RlZERhdGE6IHN0cmluZztcblxuICAvKipcbiAgICogRW1pdHMgdGhlIHVubWFza2VkIHZhbHVlIGJlZm9yZSB0aGUgdmFsdWUgY2hhbmdlcy5cbiAgICovXG4gIHJlYWRvbmx5IGN2YU1vZGVsQ2hhbmdlID0gbmV3IFN1YmplY3Q8c3RyaW5nPigpO1xuXG4gIHByaXZhdGUgX29uQ2hhbmdlQ2FsbGJhY2sgPSAoXzogYW55KSA9PiB7IH07XG4gIHByaXZhdGUgX29uVG91Y2hlZENhbGxiYWNrID0gKCkgPT4geyB9O1xuICBwcml2YXRlIF92YWxpZGF0b3JPbkNoYW5nZSA9ICgpID0+IHt9O1xuXG4gIHByaXZhdGUgX2NhbGxPbkNoYW5nZUNhbGxiYWNrKCkge1xuICAgIGlmICghdGhpcy5kcm9wU3BlY2lhbENoYXJhY3RlcnMpIHtcbiAgICAgIHRoaXMuX29uQ2hhbmdlQ2FsbGJhY2sodGhpcy5fZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50LnZhbHVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fb25DaGFuZ2VDYWxsYmFjayh0aGlzLmdldFVubWFza2VkVmFsdWUoKSk7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBfYWZ0ZXJJbnB1dEhvb2sgPSAoZXZlbnQ6IEtleWJvYXJkRXZlbnQpID0+IHsgfTtcbiAgcHJpdmF0ZSBfYmVmb3JlUGFzdGVIb29rID0gKGV2ZW50OiBDbGlwYm9hcmRFdmVudCkgPT4geyB9O1xuXG4gIC8qKlxuICAgKiBSZWdpc3RlcnMgYSBmdW5jdGlvbiB0byBiZSBleGVjdXRlZCBhZnRlciB0aGUgb25JbnB1dCBoYW5kbGVyLlxuICAgKiBUaGUgcmVnaXN0ZXJlZCBob29rIHJlY2VpdmVzIGEgYEtleWJvYXJkRXZlbnRgIGZyb20gdGhlIG9uSW5wdXQgZXZlbnQgaGFuZGxlciBhcyBhIHBhcmFtZXRlci5cbiAgICpcbiAgICogKipOb3RlOioqIElmIHlvdSByZWdpc3RlciBhIGBhZnRlcklucHV0SG9va2AsIHlvdSBtYXkgYWxzbyByZWdpc3RlciBhIGBiZWZvcmVQYXN0ZUhvb2tgXG4gICAqIHRvIHBlcmZvcm0gc2ltaWxhciBjaGFuZ2VzIGZvciBwYXN0aW5nLlxuICAgKi9cbiAgcmVnaXN0ZXJBZnRlcklucHV0SG9vayhhZnRlcklucHV0OiAoZXZlbnQ6IEtleWJvYXJkRXZlbnQpID0+IHZvaWQpOiB2b2lkIHtcbiAgICB0aGlzLl9hZnRlcklucHV0SG9vayA9IGFmdGVySW5wdXQ7XG4gIH1cblxuICAvKipcbiAgICogUmVnaXN0ZXJzIGEgZnVuY3Rpb24gdG8gYmUgZXhlY3V0ZWQgYmVmb3JlIHRoZSBvblBhc3RlIGhhbmRsZXIuXG4gICAqIFRoZSByZWdpc3RlcmVkIGhvb2sgcmVjZWl2ZXMgYSBgQ2xpcGJvYXJkRXZlbnRgIGZyb20gdGhlIG9uUGFzdGUgZXZlbnQgaGFuZGxlciBhcyBhIHBhcmFtZXRlci5cbiAgICovXG4gIHJlZ2lzdGVyQmVmb3JlUGFzdGVIb29rKGJlZm9yZVBhc3RlOiAoZXZlbnQ6IENsaXBib2FyZEV2ZW50KSA9PiB2b2lkKTogdm9pZCB7XG4gICAgdGhpcy5fYmVmb3JlUGFzdGVIb29rID0gYmVmb3JlUGFzdGU7XG4gIH1cblxuICAvKiogU2V0cyB0aGUgbWFzay4gKi9cbiAgQElucHV0KCdueE1hc2snKVxuICBzZXQgbWFzayh2YWx1ZTogc3RyaW5nKSB7XG4gICAgaWYgKCF2YWx1ZSkge1xuICAgICAgdmFsdWUgPSAnJztcbiAgICB9XG4gICAgaWYgKHZhbHVlICE9PSB0aGlzLl9tYXNrKSB7XG4gICAgICB0aGlzLl9tYXNrID0gdmFsdWU7XG4gICAgICB0aGlzLnVwZGF0ZVZhbHVlKHRoaXMuZ2V0TWFza2VkU3RyaW5nKHRoaXMuX2VsZW1lbnRSZWYubmF0aXZlRWxlbWVudC52YWx1ZSkpO1xuICAgICAgdGhpcy5fY2FsbE9uQ2hhbmdlQ2FsbGJhY2soKTtcbiAgICAgIHRoaXMuX3ZhbGlkYXRvck9uQ2hhbmdlKCk7XG4gICAgfVxuICB9XG4gIGdldCBtYXNrKCk6IHN0cmluZyB7XG4gICAgcmV0dXJuIHRoaXMuX21hc2s7XG4gIH1cblxuICAvKipcbiAgICogU2V0cyB0aGUgbWFzayAoZm9yIHByb2dyYW1tYXRpY2FsIHVzZSkuXG4gICAqXG4gICAqIE5vIGBfb25DaGFuZ2VDYWxsYmFjaygpYCB3aWxsIGJlIGNhbGxlZCFcbiAgICovXG4gIHNldE1hc2sodmFsdWU6IHN0cmluZykge1xuICAgIGlmICghdmFsdWUpIHtcbiAgICAgIHZhbHVlID0gJyc7XG4gICAgfVxuICAgIGlmICh2YWx1ZSAhPT0gdGhpcy5fbWFzaykge1xuICAgICAgdGhpcy5fbWFzayA9IHZhbHVlO1xuICAgICAgdGhpcy51cGRhdGVWYWx1ZSh0aGlzLmdldE1hc2tlZFN0cmluZyh0aGlzLl9lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQudmFsdWUpKTtcbiAgICAgIHRoaXMuX3ZhbGlkYXRvck9uQ2hhbmdlKCk7XG4gICAgfVxuICB9XG5cbiAgLyoqIFNldHMgdGhlIGNhc2Ugc2Vuc2l0aXZpdHkgb2YgdGhlIG1hc2suICovXG4gIEBJbnB1dCgnbnhDb252ZXJ0VG8nKVxuICBzZXQgY29udmVydFRvKHZhbHVlOiBNYXNrQ29udmVyc2lvblR5cGVzKSB7XG4gICAgdGhpcy5fY29udmVydFRvID0gdmFsdWU7XG4gICAgdGhpcy51cGRhdGVWYWx1ZSh0aGlzLmdldE1hc2tlZFN0cmluZyh0aGlzLl9lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQudmFsdWUpKTtcbiAgICB0aGlzLl9jYWxsT25DaGFuZ2VDYWxsYmFjaygpO1xuICB9XG4gIGdldCBjb252ZXJ0VG8oKSB7XG4gICAgcmV0dXJuIHRoaXMuX2NvbnZlcnRUbztcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIHRoZSBrZXlzIHRoYXQgYXJlIHJlY29nbml6ZWQgYXMgc2VwYXJhdG9ycy5cbiAgICogRGVmYXVsdCBzZXBhcmF0b3JzOiAvICggKSAuIDogLSArICwgYW5kIHNwYWNlLlxuICAgKi9cbiAgQElucHV0KClcbiAgc2V0IHNlcGFyYXRvcnModmFsdWVzOiBzdHJpbmdbXSkge1xuICAgIHRoaXMuX3NlcGFyYXRvcnMgPSB2YWx1ZXM7XG4gICAgdGhpcy51cGRhdGVWYWx1ZSh0aGlzLmdldE1hc2tlZFN0cmluZyh0aGlzLl9lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQudmFsdWUpKTtcbiAgICB0aGlzLl92YWxpZGF0b3JPbkNoYW5nZSgpO1xuICAgIHRoaXMuX2NhbGxPbkNoYW5nZUNhbGxiYWNrKCk7XG4gIH1cbiAgZ2V0IHNlcGFyYXRvcnMoKTogc3RyaW5nW10ge1xuICAgIHJldHVybiB0aGlzLl9zZXBhcmF0b3JzO1xuICB9XG5cbiAgLyoqIFdoZXRoZXIgdGhlIHNlcGFyYXRvcnMgc2hvdWxkIGJlIGRyb3BwZWQgaW4gdGhlIGNvbnRyb2wgdmFsdWUgYWNjZXNzb3IuICovXG4gIEBJbnB1dCgpXG4gIHNldCBkcm9wU3BlY2lhbENoYXJhY3RlcnModmFsdWU6IGJvb2xlYW4pIHtcbiAgICBjb25zdCBuZXdWYWx1ZSA9IGNvZXJjZUJvb2xlYW5Qcm9wZXJ0eSh2YWx1ZSk7XG4gICAgaWYgKG5ld1ZhbHVlICE9PSB0aGlzLl9kcm9wU3BlY2lhbENoYXJhY3RlcnMpIHtcbiAgICAgIHRoaXMuX2Ryb3BTcGVjaWFsQ2hhcmFjdGVycyA9IG5ld1ZhbHVlO1xuICAgICAgdGhpcy51cGRhdGVWYWx1ZSh0aGlzLmdldE1hc2tlZFN0cmluZyh0aGlzLl9lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQudmFsdWUpKTtcbiAgICAgIHRoaXMuX2NhbGxPbkNoYW5nZUNhbGxiYWNrKCk7XG4gICAgfVxuICB9XG4gIGdldCBkcm9wU3BlY2lhbENoYXJhY3RlcnMoKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRoaXMuX2Ryb3BTcGVjaWFsQ2hhcmFjdGVycztcbiAgfVxuXG4gIC8qKiBXaGV0aGVyIHRoZSBtYXNrIHZhbGlkYXRpb24gc2hvdWxkIGJlIGFwcGxpZWQgb24gdGhlIGlucHV0LiBEZWZhdWx0OiB0cnVlLiAqL1xuICBASW5wdXQoKVxuICBzZXQgdmFsaWRhdGVNYXNrKHZhbHVlOiBib29sZWFuKSB7XG4gICAgY29uc3QgbmV3VmFsdWUgPSBjb2VyY2VCb29sZWFuUHJvcGVydHkodmFsdWUpO1xuICAgIGlmIChuZXdWYWx1ZSAhPT0gdGhpcy5fdmFsaWRhdGVNYXNrKSB7XG4gICAgICB0aGlzLl92YWxpZGF0ZU1hc2sgPSBuZXdWYWx1ZTtcbiAgICAgIHRoaXMuX3ZhbGlkYXRvck9uQ2hhbmdlKCk7XG4gICAgfVxuICB9XG4gIGdldCB2YWxpZGF0ZU1hc2soKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRoaXMuX3ZhbGlkYXRlTWFzaztcbiAgfVxuXG4gIGNvbnN0cnVjdG9yKFxuICAgIHByaXZhdGUgX2VsZW1lbnRSZWY6IEVsZW1lbnRSZWZcbiAgKSB7fVxuXG4gIC8qKiBAZG9jcy1wcml2YXRlICovXG4gIGdldCBlbGVtZW50UmVmVmFsdWUoKTogc3RyaW5nIHtcbiAgICByZXR1cm4gdGhpcy5fZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50LnZhbHVlO1xuICB9XG5cbiAgLyoqIFJldHVybnMgdGhlIHVubWFza2VkIHZhbHVlLiAqL1xuICBnZXRVbm1hc2tlZFZhbHVlKCk6IHN0cmluZyB7XG4gICAgY29uc3QgdW5tYXNrZWRWYWx1ZSA9IHRoaXMuc2VwYXJhdG9ycy5yZWR1Y2UoZnVuY3Rpb24odW5tYXNrZWQsIHNlcGFyYXRvcikge1xuICAgICAgcmV0dXJuIHVubWFza2VkLnNwbGl0KHNlcGFyYXRvcikuam9pbignJyk7XG4gICAgfSwgdGhpcy5fZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50LnZhbHVlKTtcblxuICAgIHJldHVybiB1bm1hc2tlZFZhbHVlO1xuICB9XG5cbiAgLyoqXG4gICAqIHRoaXMuX2N1cnNvciBjYW4gYmUgc2V0IHRvIGEgbmV3IHZhbHVlIGluIHRoaXMgZnVuY3Rpb247XG4gICAqIGluIF9vbklucHV0Q2hhbmdlKCkgaXQgaXMgdGhlbiB1c2VkIHRvIHNldCB0aGUgY3Vyc29yIHBvc2l0aW9uLlxuICAgKi9cbiAgX29uS2V5ZG93bihldmVudDogS2V5Ym9hcmRFdmVudCkge1xuICAgIGNvbnN0IGtleUNvZGUgPSBldmVudC5rZXlDb2RlO1xuXG4gICAgY29uc3QgaW5wdXQ6IEhUTUxJbnB1dEVsZW1lbnQgPSBldmVudC50YXJnZXQgYXMgSFRNTElucHV0RWxlbWVudDtcbiAgICBjb25zdCBjdXJyZW50VmFsdWUgPSB0aGlzLl9lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQudmFsdWU7XG5cbiAgICBpZiAoa2V5Q29kZSA9PT0gQkFDS1NQQUNFIHx8IGtleUNvZGUgPT09IERFTEVURSkge1xuICAgICAgLy8gaWYgYmFja3NwYWNlIHByZXNzZWQsIGN1cnNvciBoYXMgdG8gbW92ZSBvbmUgY2hhcmFjdGVyIHRvIHN0YXJ0XG4gICAgICBjb25zdCBiYWNrc3BhY2VTaGlmdCA9IGtleUNvZGUgPT09IEJBQ0tTUEFDRSA/IDEgOiAwO1xuICAgICAgY29uc3QgbGFzdENoYXJhY3RlciA9IGN1cnJlbnRWYWx1ZS5zdWJzdHJpbmcoaW5wdXQuc2VsZWN0aW9uU3RhcnQgLSBiYWNrc3BhY2VTaGlmdCwgaW5wdXQuc2VsZWN0aW9uRW5kIC0gYmFja3NwYWNlU2hpZnQgKyAxKTtcbiAgICAgIGNvbnN0IHNlbGVjdGlvbkF0TGFzdENoYXJhY3RlciA9IChpbnB1dC5zZWxlY3Rpb25TdGFydCA9PT0gY3VycmVudFZhbHVlLmxlbmd0aCAtIDEgKyBiYWNrc3BhY2VTaGlmdCk7XG5cbiAgICAgIGlmIChpbnB1dC5zZWxlY3Rpb25TdGFydCAhPT0gaW5wdXQuc2VsZWN0aW9uRW5kKSB7XG4gICAgICAgIGxldCBuZXdQb3NpdGlvbiA9IGlucHV0LnNlbGVjdGlvblN0YXJ0O1xuICAgICAgICAvLyBqdW1wIGJlaGluZCBzZXBhcmF0b3JzLCBidXQgZG8gbm90IHNoaWZ0IGFmdGVyIHRoZSBuZXh0IGNoYXJhY3RlciAoPT4gZG9uJ3QgdXNlIF9jYWxjdWxhdGVDdXJzb3JTaGlmdCgpKVxuICAgICAgICB3aGlsZSAodGhpcy5pc1NlcGFyYXRvcih0aGlzLm1hc2tbbmV3UG9zaXRpb25dKSkge1xuICAgICAgICAgIG5ld1Bvc2l0aW9uKys7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fY3Vyc29yID0geyBwb3NpdGlvbjogbmV3UG9zaXRpb24gfTtcbiAgICAgIH0gZWxzZSBpZiAoc2VsZWN0aW9uQXRMYXN0Q2hhcmFjdGVyKSB7XG4gICAgICAgIC8vIGlmIGxhc3QgY2hhcmFjdGVyIGlzIGRlbGV0ZWQ6IG9ubHkgZGVsZXRlIGxhc3QgY2hhcmFjdGVyLCBkbyBub3QgdHJpZ2dlciBpbnB1dCBldmVudCBhZ2FpblxuICAgICAgICAvLyAoaGVyZSB0aGUgc2VwYXJhdG9yIHdvdWxkIGJlIGFkZGVkIGFnYWluKVxuICAgICAgICB0aGlzLnVwZGF0ZVZhbHVlKGN1cnJlbnRWYWx1ZS5zdWJzdHJpbmcoMCwgY3VycmVudFZhbHVlLmxlbmd0aCAtIDEpKTtcbiAgICAgICAgdGhpcy5fY2FsbE9uQ2hhbmdlQ2FsbGJhY2soKTtcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5pc1NlcGFyYXRvcihsYXN0Q2hhcmFjdGVyKSkge1xuICAgICAgICAvLyBkbyBub3QgZGVsZXRlIGEgc2VwYXJhdG9yLCBvbmx5IHNldCBjdXJzb3IgcG9zaXRpb25cbiAgICAgICAgaW5wdXQuc2V0U2VsZWN0aW9uUmFuZ2UoaW5wdXQuc2VsZWN0aW9uU3RhcnQgLSBiYWNrc3BhY2VTaGlmdCwgaW5wdXQuc2VsZWN0aW9uRW5kIC0gYmFja3NwYWNlU2hpZnQpO1xuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gZm9yIGFueSBvdGhlciBjaGFyYWN0ZXI6IGRlY3JlYXNlIGN1cnNvciBwb3NpdGlvbiBieSBvbmUgKGJhY2tzcGFjZVNoaWZ0KS5cbiAgICAgICAgLy8gdGhlIGlucHV0IGlzIG1vZGlmaWVkIGFuZCB3aWxsIGJlIHZhbGlkYXRlZCBpbiBfb25JbnB1dENoYW5nZSgpLlxuICAgICAgICB0aGlzLl9jdXJzb3IgPSB7IHBvc2l0aW9uOiBpbnB1dC5zZWxlY3Rpb25TdGFydCAtIGJhY2tzcGFjZVNoaWZ0IH07XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX2N1cnNvciA9IHsgc2VsZWN0aW9uU3RhcnQ6IGlucHV0LnNlbGVjdGlvblN0YXJ0LCBzZWxlY3Rpb25FbmQ6IGlucHV0LnNlbGVjdGlvbkVuZCB9O1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBjdXJzb3IgcG9zaXRpb24gYWZ0ZXIgYSBsZXR0ZXIgaXMgZW50ZXJlZCBhdCBgc2VsZWN0aW9uU3RhcnRgIHBvc2l0aW9uIGluIHRoZSBtYXNrLlxuICAgKiBUaGVyZSBhcmUgdHdvIGNhc2VzIHRvIGNvbnNpZGVyICgnfCcgPT4gY3Vyc29yIHBvc2l0aW9uIHdoZXJlIHRoZSBjaGFyYWN0ZXIgaXMgZW50ZXJlZCwgbWFzazogMDA6MDA6MDApOlxuICAgKiAtIGJlZm9yZSB0aGUgc2VwYXJhdG9ycyB0aGVyZSBpcyBzcGFjZSBmb3IgZW50ZXJpbmcgdGhlIGxldHRlcjogJzEyOjN8NDo1JyA9PiAnMTI6MzA6fDQ1J1xuICAgKiAtIHRoZSBsZXR0ZXIgaGFzIHRvIGJlIHNoaWZ0ZWQgYW5kIGlzIGVudGVyZWQgYWZ0ZXIgdGhlIHNlcGFyYXRvcnM6ICcxMjozNHw6NScgPT4gJzEyOjM0OjB8NSdcbiAgICovXG4gIHByaXZhdGUgX2NhbGN1bGF0ZUN1cnNvclNoaWZ0KHBvc2l0aW9uOiBudW1iZXIpOiBudW1iZXIge1xuICAgIGxldCBzaGlmdCA9IDA7XG4gICAgLy8gdHJhY2tzIGlmIHRoZSBlbnRlcmVkIGxldHRlciB3YXMgYWxyZWFkeSBwbGFjZWQgaW4gdGhlIGN1cnJlbnQgbWFza1xuICAgIC8vIGFuZCB0aGVyZWZvciB3YXMgY29uc2lkZXJlZCBpbiB0aGUgY3Vyc29yIGNhbGN1bGF0aW9uLlxuICAgIGxldCBjaGFyYWN0ZXJXYXNFbnRlcmVkID0gZmFsc2U7XG5cbiAgICBpZiAoIXRoaXMuaXNTZXBhcmF0b3IodGhpcy5tYXNrW3Bvc2l0aW9uICsgc2hpZnRdKSkge1xuICAgICAgc2hpZnQrKztcbiAgICAgIGNoYXJhY3Rlcldhc0VudGVyZWQgPSB0cnVlO1xuICAgIH1cblxuICAgIHdoaWxlICh0aGlzLmlzU2VwYXJhdG9yKHRoaXMubWFza1twb3NpdGlvbiArIHNoaWZ0XSkpIHtcbiAgICAgIHNoaWZ0Kys7XG4gICAgfVxuXG4gICAgaWYgKCFjaGFyYWN0ZXJXYXNFbnRlcmVkKSB7XG4gICAgICBzaGlmdCsrO1xuICAgIH1cblxuICAgIHJldHVybiBzaGlmdDtcbiAgfVxuXG4gIHByaXZhdGUgX2lzU3RyaW5nQWxsb3dlZCh2YWx1ZTogc3RyaW5nLCBtYXNrZWRWYWx1ZTogTUFTS19UWVBFKSB7XG4gICAgaWYgKChtYXNrZWRWYWx1ZSA9PT0gJzAnICYmIC9eWzAtOV17MX0kLy50ZXN0KHZhbHVlKSlcbiAgICAgICAgICB8fCAobWFza2VkVmFsdWUgPT09ICdBJyAmJiAvXlthLXpBLVowLTldezF9JC8udGVzdCh2YWx1ZSkpXG4gICAgICAgICAgfHwgKG1hc2tlZFZhbHVlID09PSAnUycgJiYgL15bYS16QS1aXXsxfSQvLnRlc3QodmFsdWUpKSkge1xuXG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLyoqXG4gICAqIEhhbmRsZXMgdGhlIG9uSW5wdXQgZXZlbnQuXG4gICAqIGBfYmVmb3JlSW5wdXRIb29rKClgIGlzIGNhbGxlZCBiZWZvcmUgdGhlIGFjdHVhbCBleGVjdXRpb24uXG4gICAqXG4gICAqL1xuICBfb25JbnB1dENoYW5nZShldmVudDogS2V5Ym9hcmRFdmVudCkge1xuICAgIC8vIF9pbnB1dFZhbHVlIGlzIHVwZGF0ZWQgaW4gdXBkYXRlVmFsdWUoKSwgc28gSSBuZWVkIHRvIHBpY2sgaXQgdXAgaGVyZSB0byBjb21wYXJlIGl0IHRvIGEgbmV3IHZhbHVlXG4gICAgY29uc3Qgb2xkVmFsID0gdGhpcy5faW5wdXRWYWx1ZTtcbiAgICBjb25zdCBpbnB1dDogSFRNTElucHV0RWxlbWVudCA9IGV2ZW50LnRhcmdldCBhcyBIVE1MSW5wdXRFbGVtZW50O1xuICAgIGNvbnN0IG5ld1ZhbCA9IHRoaXMuZ2V0TWFza2VkU3RyaW5nKGlucHV0LnZhbHVlKTtcblxuICAgIC8vIGlmIF9wYXN0ZWREYXRhIHdhcyBzZXQgaW4gX29uUGFzdGUoKSwgdXNlIHRoaXMgdmFsdWVcbiAgICBpZiAodGhpcy5fcGFzdGVkRGF0YSkge1xuICAgICAgdGhpcy51cGRhdGVWYWx1ZSh0aGlzLl9wYXN0ZWREYXRhKTtcbiAgICAgIGlucHV0LnNldFNlbGVjdGlvblJhbmdlKHRoaXMuX2N1cnNvci5wb3NpdGlvbiwgdGhpcy5fY3Vyc29yLnBvc2l0aW9uKTtcbiAgICAgIHRoaXMuX3Bhc3RlZERhdGEgPSBudWxsO1xuICAgICAgdGhpcy5fY3Vyc29yID0gbnVsbDtcbiAgICAgIHRoaXMuX2NhbGxPbkNoYW5nZUNhbGxiYWNrKCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gZG8gbm90aGluZyBpZiBtYXNrIGlzIGFscmVhZHkgZmlsbGVkIHVwXG4gICAgaWYgKG9sZFZhbC5sZW5ndGggPT09IHRoaXMuX21hc2subGVuZ3RoXG4gICAgICAgICYmIG5ld1ZhbC5sZW5ndGggPT09IHRoaXMuX21hc2subGVuZ3RoXG4gICAgICAgICYmIG9sZFZhbCAhPT0gbmV3VmFsXG4gICAgICAgICYmICh0aGlzLl9jdXJzb3JcbiAgICAgICAgICAgICAgJiYgdGhpcy5fY3Vyc29yLnNlbGVjdGlvblN0YXJ0ICE9PSB1bmRlZmluZWRcbiAgICAgICAgICAgICAgJiYgdGhpcy5fY3Vyc29yLnNlbGVjdGlvblN0YXJ0ID09PSB0aGlzLl9jdXJzb3Iuc2VsZWN0aW9uRW5kKSkge1xuXG4gICAgICB0aGlzLl9lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQudmFsdWUgPSB0aGlzLmdldE1hc2tlZFN0cmluZyhvbGRWYWwpO1xuICAgICAgaW5wdXQuc2V0U2VsZWN0aW9uUmFuZ2UodGhpcy5fY3Vyc29yLnNlbGVjdGlvblN0YXJ0LCB0aGlzLl9jdXJzb3Iuc2VsZWN0aW9uRW5kKTtcbiAgICAgIHRoaXMuX2N1cnNvciA9IG51bGw7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy51cGRhdGVWYWx1ZShuZXdWYWwpO1xuXG4gICAgLy8gc2V0IG5ldyBjdXJzb3IgcG9zaXRpb25cbiAgICBpZiAodGhpcy5fY3Vyc29yICYmIHRoaXMuX2N1cnNvci5wb3NpdGlvbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBpbnB1dC5zZXRTZWxlY3Rpb25SYW5nZSh0aGlzLl9jdXJzb3IucG9zaXRpb24sIHRoaXMuX2N1cnNvci5wb3NpdGlvbik7XG4gICAgICB0aGlzLl9jdXJzb3IgPSBudWxsO1xuICAgIH0gZWxzZSBpZiAodGhpcy5fY3Vyc29yICYmIHRoaXMuX2N1cnNvci5zZWxlY3Rpb25TdGFydCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAvLyBvbmx5IG9uZSBjaGFyYWN0ZXIgY2FuIGJlIGVudGVyZWQgKGV4Y2VwdCBwYXN0aW5nLCB0aGlzIGlzIGNhbGN1bGF0ZWQgaW4gX29uUGFzdGUoKSlcbiAgICAgIGlmIChvbGRWYWwgIT09IGlucHV0LnZhbHVlKSB7XG4gICAgICAgIGNvbnN0IG5ld1Bvc2l0aW9uID0gdGhpcy5fY3Vyc29yLnNlbGVjdGlvblN0YXJ0ICsgdGhpcy5fY2FsY3VsYXRlQ3Vyc29yU2hpZnQodGhpcy5fY3Vyc29yLnNlbGVjdGlvblN0YXJ0KTtcbiAgICAgICAgaW5wdXQuc2V0U2VsZWN0aW9uUmFuZ2UobmV3UG9zaXRpb24sIG5ld1Bvc2l0aW9uKTtcbiAgICAgICAgdGhpcy5fY3Vyc29yID0gbnVsbDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIHdlIGFsd2F5cyBoYXZlIHRvIHNldCB0aGUgY3Vyc29yIHBvc2l0aW9uIGhlcmUgZXZlbiBpZiBub3RoaW5nIGNoYW5nZWRcbiAgICAgICAgLy8gYmVjYXVzZSBvdGhlcndpc2UgdGhlIGN1cnNvciB3b3VsZCBqdW1wIHRvIHRoZSBlbmQgb2YgdGhlIGlucHV0LlxuICAgICAgICAvLyBpZiB0aGUgY3Vyc29yIGlzIHBsYWNlZCBpbiBmcm9udCBvZiBhIHNlcGFyYXRvciBhbmQgdGhlIHVzZXIgdHlwZXMgYSBub24tYWxsb3dlZCBjaGFyYWN0ZXIsXG4gICAgICAgIC8vIHRoZSBjdXJzb3IgaXMgc3VwcG9zZWQgdG8ganVtcCBvdmVyIHRoZSBzZXBhcmF0b3IuXG4gICAgICAgIGxldCBjdXJyZW50UG9zaXRpb24gPSB0aGlzLl9jdXJzb3Iuc2VsZWN0aW9uU3RhcnQ7XG4gICAgICAgIHdoaWxlICh0aGlzLmlzU2VwYXJhdG9yKHRoaXMubWFza1tjdXJyZW50UG9zaXRpb25dKSkge1xuICAgICAgICAgIGN1cnJlbnRQb3NpdGlvbisrO1xuICAgICAgICB9XG4gICAgICAgIGlucHV0LnNldFNlbGVjdGlvblJhbmdlKGN1cnJlbnRQb3NpdGlvbiwgY3VycmVudFBvc2l0aW9uKTtcbiAgICAgICAgdGhpcy5fY3Vyc29yID0gbnVsbDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLl9hZnRlcklucHV0SG9vayhldmVudCk7XG4gICAgdGhpcy5fY2FsbE9uQ2hhbmdlQ2FsbGJhY2soKTtcbiAgfVxuXG4gIC8qKlxuICAgKiB0aGlzLl9jdXJzb3IgYW5kIHRoaXMuX3Bhc3RlZERhdGEgY2FuIGJlIHNldCB0byBhIG5ldyB2YWx1ZSBpbiB0aGlzIGZ1bmN0aW9uO1xuICAgKiBfY3Vyc29yIGlzIHVzZWQgdG8gc2V0IHRoZSBjdXJzb3IgcG9zaXRpb24gYWZ0ZXIgY2hlY2tpbmcgdGhlIG1hc2tlZCBpbnB1dCBpbiBfb25JbnB1dENoYW5nZSgpLlxuICAgKiBfcGFzdGVkRGF0YSBjYXJyaWVzIHRoZSB2YWxpZCBwYXJ0IG9mIHRoZSBwYXN0ZWQgdmFsdWUgdG8gX2luSW5wdXRDaGFuZ2UoKTtcbiAgICpcbiAgICpgX2JlZm9yZVBhc3RlSG9vaygpYCBpcyBjYWxsZWQgYmVmb3JlIHRoZSBhY3R1YWwgZXhlY3V0aW9uLlxuICAgKi9cbiAgX29uUGFzdGUoZXZlbnQ6IENsaXBib2FyZEV2ZW50KSB7XG4gICAgY29uc3QgaW5wdXQ6IEhUTUxJbnB1dEVsZW1lbnQgPSBldmVudC50YXJnZXQgYXMgSFRNTElucHV0RWxlbWVudDtcbiAgICBjb25zdCBwYXN0ZWREYXRhID0gKGV2ZW50LmNsaXBib2FyZERhdGEgfHwgKDxhbnk+IHdpbmRvdykuY2xpcGJvYXJkRGF0YSkuZ2V0RGF0YSgndGV4dCcpO1xuXG4gICAgLy8gc2F2aW5nIHRoZXNlIHRocmVlIHZhbHVlcyBhcyBpZiBzb21ldGhpbmcgaXMgY2hhbmdlZCBpbiB0aGUgX2JlZm9yZVBhc3RlSG9vaygpXG4gICAgLy8gd2hpY2ggY2F1c2VzIHRoZSBpbnB1dCB2YWx1ZSB0byBiZSB1cGRhdGVkLCB0aGlzIHZhbHVlcyB3aWxsIGdldCBsb3N0LlxuICAgIGNvbnN0IHNlbGVjdGlvblN0YXJ0ID0gaW5wdXQuc2VsZWN0aW9uU3RhcnQ7XG4gICAgY29uc3Qgc2VsZWN0aW9uRW5kID0gaW5wdXQuc2VsZWN0aW9uRW5kO1xuICAgIGNvbnN0IG9sZFZhbHVlID0gaW5wdXQudmFsdWU7XG5cbiAgICB0aGlzLl9iZWZvcmVQYXN0ZUhvb2soZXZlbnQpO1xuXG4gICAgY29uc3QgbWFza2VkU3RyaW5nID0gdGhpcy5nZXRNYXNrZWRTdHJpbmcocGFzdGVkRGF0YSwgc2VsZWN0aW9uU3RhcnQpO1xuXG4gICAgLy8gaWYgbWFzayBpcyBhbHJlYWR5IGZpbGxlZCB1cCAoYW5kIG5vIGNoYXJhY3RlcnMgYXJlIHNlbGVjdGVkIHdpdGggdGhlIGN1cnNvciksIGRvIG5vdGhpbmdcbiAgICBpZiAoaW5wdXQudmFsdWUubGVuZ3RoID09PSB0aGlzLl9tYXNrLmxlbmd0aFxuICAgICAgJiYgbWFza2VkU3RyaW5nLmxlbmd0aCA+IDBcbiAgICAgICYmIHNlbGVjdGlvblN0YXJ0ID09PSBzZWxlY3Rpb25FbmQpIHtcblxuICAgICAgaW5wdXQuc2V0U2VsZWN0aW9uUmFuZ2Uoc2VsZWN0aW9uU3RhcnQsIHNlbGVjdGlvbkVuZCk7XG4gICAgICB0aGlzLl9jdXJzb3IgPSBudWxsOyAgICAvLyB3YXMgc2V0IGluIF9vbktleWRvd24oKSwgYnV0IHdpbGwgbm90IGJlIHVzZWQgaW4gdGhpcyBjYXNlOyBzbyByZXNldCBpdFxuICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBpZiBsZW5ndGggb2YgbmV3VmFsdWUgaXMgPj0gbWFzazogYWxsb3cgb25seSB0byBlbnRlciBjaGFyYWN0ZXJzIGZyb20gYSBwYXN0ZWQgdmFsdWUgdW50aWwgbWFzayBpcyBmaWxsZWQgdXBcbiAgICAvLyBleGFtcGxlOiAxMjp8MzQ6IChcInxcIiBjdXJzb3IgcG9zaXRpb24sIG1hc2s6IDAwOjAwOjAwKSA9PiB3aGVuIHBhc3RpbmcgJzU2NycsIG9ubHkgJzU2JyBmaXRzIGluIHVudGlsIGlucHV0IGlzIGZpbGxlZCB1cCA9PiAxMjo1Njp8MzRcbiAgICAvLyBnZXQgdGhlIHBhc3RlZCB1bm1hc2tlZCB2YWx1ZSBmcm9tIHRoZSBwYXN0ZWQgc3RyaW5nICh0byBjdXQgYWxsIHRoZSBpbnZhbGlkIGNoYXJhY3RlcnMgYW5kIHNlcGFyYXRvcnMpXG4gICAgY29uc3QgcGFzdGVkVW5tYXNrZWRWYWx1ZSA9IHRoaXMuc2VwYXJhdG9ycy5yZWR1Y2UoXG4gICAgICAodW5tYXNrZWQsIHNlcGFyYXRvcikgPT4gdW5tYXNrZWQuc3BsaXQoc2VwYXJhdG9yKS5qb2luKCcnKSwgbWFza2VkU3RyaW5nXG4gICAgKTtcblxuICAgIGxldCBuZXdWYWx1ZTogc3RyaW5nID0gdGhpcy5nZXRNYXNrZWRTdHJpbmcoXG4gICAgICBvbGRWYWx1ZS5zdWJzdHJpbmcoMCwgc2VsZWN0aW9uU3RhcnQpXG4gICAgICArIHBhc3RlZFVubWFza2VkVmFsdWVcbiAgICAgICsgb2xkVmFsdWUuc3Vic3RyaW5nKHNlbGVjdGlvbkVuZCwgb2xkVmFsdWUubGVuZ3RoKVxuICAgICk7XG5cbiAgICBpZiAobmV3VmFsdWUubGVuZ3RoID49IHRoaXMuX21hc2subGVuZ3RoKSB7XG4gICAgICBsZXQgbmV3UG9zaXRpb24gPSBzZWxlY3Rpb25TdGFydDtcblxuICAgICAgbGV0IGkgPSAxO1xuICAgICAgZG8ge1xuICAgICAgICBuZXdWYWx1ZSA9IHRoaXMuZ2V0TWFza2VkU3RyaW5nKFxuICAgICAgICAgIG9sZFZhbHVlLnN1YnN0cmluZygwLCBzZWxlY3Rpb25TdGFydClcbiAgICAgICAgICArIHBhc3RlZFVubWFza2VkVmFsdWUuc3Vic3RyaW5nKDAsIGkpXG4gICAgICAgICAgKyBvbGRWYWx1ZS5zdWJzdHJpbmcoc2VsZWN0aW9uRW5kLCBvbGRWYWx1ZS5sZW5ndGgpXG4gICAgICAgICk7XG4gICAgICAgIG5ld1Bvc2l0aW9uICs9IHRoaXMuX2NhbGN1bGF0ZUN1cnNvclNoaWZ0KG5ld1Bvc2l0aW9uKTtcblxuICAgICAgICBpKys7XG4gICAgICB9IHdoaWxlIChuZXdWYWx1ZS5sZW5ndGggPCB0aGlzLl9tYXNrLmxlbmd0aCk7XG5cbiAgICAgIC8vIHNhdmUgdmFsdWUgZm9yIHVzaW5nIGl0IGluIF9vbklucHV0Q2hhbmdlKClcbiAgICAgIHRoaXMuX3Bhc3RlZERhdGEgPSBuZXdWYWx1ZTtcbiAgICAgIHRoaXMuX2N1cnNvciA9IHtcbiAgICAgICAgcG9zaXRpb246IG5ld1Bvc2l0aW9uXG4gICAgICB9O1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIGlmIHBhc3RpbmcgaXMgZmluZTogc2F2ZSB0aGUgY3Vyc29yIHBvc2l0aW9uIGZvciB1c2luZyB0aGVtIGluIF9vbklucHV0Q2hhbmdlKClcbiAgICB0aGlzLl9jdXJzb3IgPSB7XG4gICAgICBwb3NpdGlvbjogc2VsZWN0aW9uU3RhcnQgKyBtYXNrZWRTdHJpbmcubGVuZ3RoXG4gICAgfTtcbiAgfVxuXG4gIHByaXZhdGUgdXBkYXRlVmFsdWUodmFsdWU6IHN0cmluZykge1xuICAgIC8vIFdyaXRlIFVwcGVyQ2FzZVxuICAgIGlmICh0aGlzLl9jb252ZXJ0VG8gPT09ICd1cHBlcicpIHtcbiAgICAgIHZhbHVlID0gdmFsdWUudG9VcHBlckNhc2UoKTtcbiAgICB9IGVsc2UgaWYgKHRoaXMuX2NvbnZlcnRUbyA9PT0gJ2xvd2VyJykge1xuICAgICAgdmFsdWUgPSB2YWx1ZS50b0xvd2VyQ2FzZSgpO1xuICAgIH1cbiAgICB0aGlzLl9lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQudmFsdWUgPSB2YWx1ZTtcblxuICAgIC8vIF9pbnB1dFZhbHVlIGlzIG5lZWRlZCBmb3IgY2FsY3VsYXRpbmcgdGhlIGN1cnNvciBzaGlmdCBpbiBvbklucHV0KClcbiAgICB0aGlzLl9pbnB1dFZhbHVlID0gdmFsdWU7XG4gIH1cblxuICAvKiogQGRvY3MtcHJpdmF0ZSAqL1xuICBnZXRNYXNrZWRTdHJpbmcoaW5wdXRWYWx1ZTogc3RyaW5nLCBtYXNrU3RhcnRJbmRleDogbnVtYmVyID0gMCk6IHN0cmluZyB7XG4gICAgbGV0IGZvcm1hdHRlZFZhbHVlID0gJyc7XG4gICAgbGV0IG1hc2tJbmRleCA9IG1hc2tTdGFydEluZGV4O1xuICAgIGxldCBpbnB1dEluZGV4ID0gMDtcblxuICAgIC8vIGluc2VydCBpZiBuZXh0IGluIG1hc2sgaXMgc2VwYXJhdG9yXG4gICAgd2hpbGUgKHRoaXMuaXNTZXBhcmF0b3IodGhpcy5tYXNrW21hc2tJbmRleF0pKSB7XG4gICAgICBmb3JtYXR0ZWRWYWx1ZSArPSB0aGlzLm1hc2tbbWFza0luZGV4XTtcbiAgICAgIG1hc2tJbmRleCsrO1xuICAgIH1cblxuICAgIHdoaWxlIChpbnB1dEluZGV4IDwgaW5wdXRWYWx1ZS5sZW5ndGgpIHtcbiAgICAgIC8vIHRlc3QgaWYgbGV0dGVycyBhcmUgdmFsaWRcbiAgICAgIGlmICh0aGlzLl9pc1N0cmluZ0FsbG93ZWQoaW5wdXRWYWx1ZVtpbnB1dEluZGV4XSwgdGhpcy5tYXNrW21hc2tJbmRleF0gYXMgTUFTS19UWVBFKSkge1xuICAgICAgICBmb3JtYXR0ZWRWYWx1ZSArPSBpbnB1dFZhbHVlW2lucHV0SW5kZXhdO1xuICAgICAgICBpbnB1dEluZGV4Kys7XG4gICAgICAgIG1hc2tJbmRleCsrO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaW5wdXRJbmRleCsrO1xuICAgICAgfVxuXG4gICAgICAvLyBpbnNlcnQgaWYgbmV4dCBpbiBtYXNrIGlzIHNlcGFyYXRvclxuICAgICAgd2hpbGUgKHRoaXMuaXNTZXBhcmF0b3IodGhpcy5tYXNrW21hc2tJbmRleF0pKSB7XG4gICAgICAgIGZvcm1hdHRlZFZhbHVlICs9IHRoaXMubWFza1ttYXNrSW5kZXhdO1xuICAgICAgICBtYXNrSW5kZXgrKztcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZm9ybWF0dGVkVmFsdWU7XG4gIH1cblxuICBwcml2YXRlIGlzU2VwYXJhdG9yKHZhbHVlOiBzdHJpbmcpOiBib29sZWFuIHtcbiAgICByZXR1cm4gKHRoaXMuX3NlcGFyYXRvcnMuaW5kZXhPZih2YWx1ZSkgIT09IC0xKTtcbiAgfVxuXG4gIC8vIGNvbnRyb2wgdmFsdWUgYWNjZXNzb3JcbiAgd3JpdGVWYWx1ZSh2YWx1ZTogYW55KTogdm9pZCB7XG4gICAgaWYgKCF2YWx1ZSkge1xuICAgICAgdmFsdWUgPSAnJztcbiAgICB9XG5cbiAgICB0aGlzLmN2YU1vZGVsQ2hhbmdlLm5leHQodmFsdWUpO1xuICAgIHRoaXMudXBkYXRlVmFsdWUodGhpcy5nZXRNYXNrZWRTdHJpbmcodmFsdWUpKTtcbiAgfVxuXG4gIHJlZ2lzdGVyT25DaGFuZ2Uob25DaGFuZ2U6IGFueSk6IHZvaWQge1xuICAgIHRoaXMuX29uQ2hhbmdlQ2FsbGJhY2sgPSBvbkNoYW5nZTtcbiAgfVxuXG4gIHJlZ2lzdGVyT25Ub3VjaGVkKG9uVG91Y2hlZDogYW55KTogdm9pZCB7XG4gICAgdGhpcy5fb25Ub3VjaGVkQ2FsbGJhY2sgPSBvblRvdWNoZWQ7XG4gIH1cblxuICAvKiogQGRvY3MtcHJpdmF0ZSAqL1xuICByZWdpc3Rlck9uVmFsaWRhdG9yQ2hhbmdlKGZuOiAoKSA9PiB2b2lkKTogdm9pZCB7XG4gICAgdGhpcy5fdmFsaWRhdG9yT25DaGFuZ2UgPSBmbjtcbiAgfVxuXG4gIF92YWxpZGF0ZUZuKCkge1xuICAgIGNvbnN0IGlucHV0TGVuZ3RoID0gdGhpcy5fZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50LnZhbHVlLmxlbmd0aDtcbiAgICBjb25zdCBtYXNrTGVuZ3RoID0gdGhpcy5fbWFzay5sZW5ndGg7XG4gICAgaWYgKGlucHV0TGVuZ3RoICE9PSBtYXNrTGVuZ3RoKSB7XG4gICAgICByZXR1cm4geyBueE1hc2tMZW5ndGhFcnJvcjogeydsZW5ndGgnOiBtYXNrTGVuZ3RoLCAnYWN0dWFsJzogaW5wdXRMZW5ndGh9IH07XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgLyoqIEBkb2NzLXByaXZhdGUgKi9cbiAgdmFsaWRhdGUoKSB7XG4gICAgcmV0dXJuIHRoaXMudmFsaWRhdGVNYXNrID8gdGhpcy5fdmFsaWRhdGVGbigpIDogbnVsbDtcbiAgfVxuXG4gIF90b3VjaCgpIHtcbiAgICB0aGlzLl9vblRvdWNoZWRDYWxsYmFjaygpO1xuICB9XG59XG4iXX0=