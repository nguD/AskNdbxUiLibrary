/**
 * @fileoverview added by tsickle
 * Generated from: breadcrumb.component.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import { Component, ContentChildren, QueryList, Input, ChangeDetectorRef, ChangeDetectionStrategy } from '@angular/core';
import { NxBreadcrumbItemComponent } from './breadcrumb-item.component';
import { startWith, takeUntil, filter } from 'rxjs/operators';
import { Subject } from 'rxjs';
var NxBreadcrumbComponent = /** @class */ (function () {
    function NxBreadcrumbComponent(_cdr) {
        this._cdr = _cdr;
        this._destroyed = new Subject();
        this._negative = false;
    }
    Object.defineProperty(NxBreadcrumbComponent.prototype, "negative", {
        get: /**
         * @return {?}
         */
        function () {
            return this._negative;
        },
        /** Whether the component uses the negative styling. */
        set: /**
         * Whether the component uses the negative styling.
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this._negative = value;
            this._cdr.markForCheck();
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @return {?}
     */
    NxBreadcrumbComponent.prototype.ngAfterContentInit = /**
     * @return {?}
     */
    function () {
        var _this = this;
        if (this.breadcrumbItems.length === 0) {
            console.warn('A breadcrumb needs NxBreadcrumbItemComponent children wrapped in <li>!');
        }
        this.breadcrumbItems.changes
            .pipe(startWith(this.breadcrumbItems), filter((/**
         * @param {?} items
         * @return {?}
         */
        function (items) { return items.length !== 0; })), takeUntil(this._destroyed))
            .subscribe((/**
         * @param {?} items
         * @return {?}
         */
        function (items) {
            _this.breadcrumbItems.forEach((/**
             * @param {?} item
             * @return {?}
             */
            function (item) { return item.resetAriaLabel(); }));
            _this.breadcrumbItems.last.setAsLast();
        }));
    };
    /**
     * @return {?}
     */
    NxBreadcrumbComponent.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        this._destroyed.next();
        this._destroyed.complete();
    };
    NxBreadcrumbComponent.decorators = [
        { type: Component, args: [{
                    // tslint:disable-next-line:component-selector
                    selector: 'ol[nxBreadcrumb]',
                    template: "<ng-content></ng-content>\n",
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    host: {
                        '[class.is-negative]': 'negative'
                    },
                    styles: [":host{display:flex;list-style:none;height:24px;padding:0}::ng-deep li:last-child ::ng-deep .nx-breadcrumb-item{font-weight:600;cursor:auto}::ng-deep li:last-child ::ng-deep .nx-breadcrumb-item__chevron{display:none}::ng-deep li+li ::ng-deep .nx-breadcrumb-item{margin-left:4px}:host(.is-negative) ::ng-deep .nx-breadcrumb-item{color:#fff}"]
                }] }
    ];
    /** @nocollapse */
    NxBreadcrumbComponent.ctorParameters = function () { return [
        { type: ChangeDetectorRef }
    ]; };
    NxBreadcrumbComponent.propDecorators = {
        negative: [{ type: Input }],
        breadcrumbItems: [{ type: ContentChildren, args: [NxBreadcrumbItemComponent, { descendants: true },] }]
    };
    return NxBreadcrumbComponent;
}());
export { NxBreadcrumbComponent };
if (false) {
    /** @type {?} */
    NxBreadcrumbComponent.prototype._destroyed;
    /**
     * @type {?}
     * @private
     */
    NxBreadcrumbComponent.prototype._negative;
    /**
     * \@docs-private
     * @type {?}
     */
    NxBreadcrumbComponent.prototype.breadcrumbItems;
    /**
     * @type {?}
     * @private
     */
    NxBreadcrumbComponent.prototype._cdr;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYnJlYWRjcnVtYi5jb21wb25lbnQuanMiLCJzb3VyY2VSb290Ijoibmc6Ly9AYWxsaWFuei9uZ3gtbmRieC9icmVhZGNydW1iLyIsInNvdXJjZXMiOlsiYnJlYWRjcnVtYi5jb21wb25lbnQudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQSxPQUFPLEVBQUUsU0FBUyxFQUFFLGVBQWUsRUFBRSxTQUFTLEVBQUUsS0FBSyxFQUN4QyxpQkFBaUIsRUFBRSx1QkFBdUIsRUFBRSxNQUFNLGVBQWUsQ0FBQztBQUMvRSxPQUFPLEVBQUUseUJBQXlCLEVBQUUsTUFBTSw2QkFBNkIsQ0FBQztBQUN4RSxPQUFPLEVBQUUsU0FBUyxFQUFFLFNBQVMsRUFBRSxNQUFNLEVBQUUsTUFBTSxnQkFBZ0IsQ0FBQztBQUM5RCxPQUFPLEVBQUUsT0FBTyxFQUFFLE1BQU0sTUFBTSxDQUFDO0FBRS9CO0lBOEJFLCtCQUFvQixJQUF1QjtRQUF2QixTQUFJLEdBQUosSUFBSSxDQUFtQjtRQWxCM0MsZUFBVSxHQUFrQixJQUFJLE9BQU8sRUFBRSxDQUFDO1FBRWxDLGNBQVMsR0FBWSxLQUFLLENBQUM7SUFnQlksQ0FBQztJQWJoRCxzQkFDSSwyQ0FBUTs7OztRQUtaO1lBQ0UsT0FBTyxJQUFJLENBQUMsU0FBUyxDQUFDO1FBQ3hCLENBQUM7UUFURCx1REFBdUQ7Ozs7OztRQUN2RCxVQUNhLEtBQWM7WUFDekIsSUFBSSxDQUFDLFNBQVMsR0FBRyxLQUFLLENBQUM7WUFDdkIsSUFBSSxDQUFDLElBQUksQ0FBQyxZQUFZLEVBQUUsQ0FBQztRQUMzQixDQUFDOzs7T0FBQTs7OztJQVdELGtEQUFrQjs7O0lBQWxCO1FBQUEsaUJBV0M7UUFWQyxJQUFJLElBQUksQ0FBQyxlQUFlLENBQUMsTUFBTSxLQUFLLENBQUMsRUFBRTtZQUNyQyxPQUFPLENBQUMsSUFBSSxDQUFDLHdFQUF3RSxDQUFDLENBQUM7U0FDeEY7UUFFRCxJQUFJLENBQUMsZUFBZSxDQUFDLE9BQU87YUFDekIsSUFBSSxDQUFDLFNBQVMsQ0FBQyxJQUFJLENBQUMsZUFBZSxDQUFDLEVBQUUsTUFBTTs7OztRQUFDLFVBQUEsS0FBSyxJQUFJLE9BQUEsS0FBSyxDQUFDLE1BQU0sS0FBSyxDQUFDLEVBQWxCLENBQWtCLEVBQUMsRUFBRSxTQUFTLENBQUMsSUFBSSxDQUFDLFVBQVUsQ0FBQyxDQUFDO2FBQ3RHLFNBQVM7Ozs7UUFBQyxVQUFBLEtBQUs7WUFDZCxLQUFJLENBQUMsZUFBZSxDQUFDLE9BQU87Ozs7WUFBQyxVQUFBLElBQUksSUFBSSxPQUFBLElBQUksQ0FBQyxjQUFjLEVBQUUsRUFBckIsQ0FBcUIsRUFBQyxDQUFDO1lBQzVELEtBQUksQ0FBQyxlQUFlLENBQUMsSUFBSSxDQUFDLFNBQVMsRUFBRSxDQUFDO1FBQ3hDLENBQUMsRUFBQyxDQUFDO0lBQ1AsQ0FBQzs7OztJQUVELDJDQUFXOzs7SUFBWDtRQUNFLElBQUksQ0FBQyxVQUFVLENBQUMsSUFBSSxFQUFFLENBQUM7UUFDdkIsSUFBSSxDQUFDLFVBQVUsQ0FBQyxRQUFRLEVBQUUsQ0FBQztJQUM3QixDQUFDOztnQkFoREYsU0FBUyxTQUFDOztvQkFFVCxRQUFRLEVBQUUsa0JBQWtCO29CQUM1Qix1Q0FBMEM7b0JBRTFDLGVBQWUsRUFBRSx1QkFBdUIsQ0FBQyxNQUFNO29CQUMvQyxJQUFJLEVBQUU7d0JBQ0oscUJBQXFCLEVBQUUsVUFBVTtxQkFDbEM7O2lCQUNGOzs7O2dCQWRZLGlCQUFpQjs7OzJCQXNCM0IsS0FBSztrQ0FXTCxlQUFlLFNBQUMseUJBQXlCLEVBQUUsRUFBQyxXQUFXLEVBQUUsSUFBSSxFQUFDOztJQXFCakUsNEJBQUM7Q0FBQSxBQWpERCxJQWlEQztTQXZDWSxxQkFBcUI7OztJQUVoQywyQ0FBMEM7Ozs7O0lBRTFDLDBDQUFtQzs7Ozs7SUFjbkMsZ0RBQXVIOzs7OztJQUUzRyxxQ0FBK0IiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBDb21wb25lbnQsIENvbnRlbnRDaGlsZHJlbiwgUXVlcnlMaXN0LCBJbnB1dCwgQWZ0ZXJDb250ZW50SW5pdCxcbiAgT25EZXN0cm95LCBDaGFuZ2VEZXRlY3RvclJlZiwgQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IE54QnJlYWRjcnVtYkl0ZW1Db21wb25lbnQgfSBmcm9tICcuL2JyZWFkY3J1bWItaXRlbS5jb21wb25lbnQnO1xuaW1wb3J0IHsgc3RhcnRXaXRoLCB0YWtlVW50aWwsIGZpbHRlciB9IGZyb20gJ3J4anMvb3BlcmF0b3JzJztcbmltcG9ydCB7IFN1YmplY3QgfSBmcm9tICdyeGpzJztcblxuQENvbXBvbmVudCh7XG4gIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTpjb21wb25lbnQtc2VsZWN0b3JcbiAgc2VsZWN0b3I6ICdvbFtueEJyZWFkY3J1bWJdJyxcbiAgdGVtcGxhdGVVcmw6ICcuL2JyZWFkY3J1bWIuY29tcG9uZW50Lmh0bWwnLFxuICBzdHlsZVVybHM6IFsnLi9icmVhZGNydW1iLmNvbXBvbmVudC5zY3NzJ10sXG4gIGNoYW5nZURldGVjdGlvbjogQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuT25QdXNoLFxuICBob3N0OiB7XG4gICAgJ1tjbGFzcy5pcy1uZWdhdGl2ZV0nOiAnbmVnYXRpdmUnXG4gIH1cbn0pXG5leHBvcnQgY2xhc3MgTnhCcmVhZGNydW1iQ29tcG9uZW50IGltcGxlbWVudHMgQWZ0ZXJDb250ZW50SW5pdCwgT25EZXN0cm95ICB7XG5cbiAgX2Rlc3Ryb3llZDogU3ViamVjdDx2b2lkPiA9IG5ldyBTdWJqZWN0KCk7XG5cbiAgcHJpdmF0ZSBfbmVnYXRpdmU6IGJvb2xlYW4gPSBmYWxzZTtcblxuICAvKiogV2hldGhlciB0aGUgY29tcG9uZW50IHVzZXMgdGhlIG5lZ2F0aXZlIHN0eWxpbmcuICovXG4gIEBJbnB1dCgpXG4gIHNldCBuZWdhdGl2ZSh2YWx1ZTogYm9vbGVhbikge1xuICAgIHRoaXMuX25lZ2F0aXZlID0gdmFsdWU7XG4gICAgdGhpcy5fY2RyLm1hcmtGb3JDaGVjaygpO1xuICB9XG5cbiAgZ2V0IG5lZ2F0aXZlKCkge1xuICAgIHJldHVybiB0aGlzLl9uZWdhdGl2ZTtcbiAgfVxuXG4gIC8qKkBkb2NzLXByaXZhdGUgKi9cbiAgQENvbnRlbnRDaGlsZHJlbihOeEJyZWFkY3J1bWJJdGVtQ29tcG9uZW50LCB7ZGVzY2VuZGFudHM6IHRydWV9KSBicmVhZGNydW1iSXRlbXM6IFF1ZXJ5TGlzdDxOeEJyZWFkY3J1bWJJdGVtQ29tcG9uZW50PjtcblxuICBjb25zdHJ1Y3Rvcihwcml2YXRlIF9jZHI6IENoYW5nZURldGVjdG9yUmVmKSB7IH1cblxuICBuZ0FmdGVyQ29udGVudEluaXQoKSB7XG4gICAgaWYgKHRoaXMuYnJlYWRjcnVtYkl0ZW1zLmxlbmd0aCA9PT0gMCkge1xuICAgICAgY29uc29sZS53YXJuKCdBIGJyZWFkY3J1bWIgbmVlZHMgTnhCcmVhZGNydW1iSXRlbUNvbXBvbmVudCBjaGlsZHJlbiB3cmFwcGVkIGluIDxsaT4hJyk7XG4gICAgfVxuXG4gICAgdGhpcy5icmVhZGNydW1iSXRlbXMuY2hhbmdlc1xuICAgICAgLnBpcGUoc3RhcnRXaXRoKHRoaXMuYnJlYWRjcnVtYkl0ZW1zKSwgZmlsdGVyKGl0ZW1zID0+IGl0ZW1zLmxlbmd0aCAhPT0gMCksIHRha2VVbnRpbCh0aGlzLl9kZXN0cm95ZWQpKVxuICAgICAgLnN1YnNjcmliZShpdGVtcyA9PiAge1xuICAgICAgICB0aGlzLmJyZWFkY3J1bWJJdGVtcy5mb3JFYWNoKGl0ZW0gPT4gaXRlbS5yZXNldEFyaWFMYWJlbCgpKTtcbiAgICAgICAgdGhpcy5icmVhZGNydW1iSXRlbXMubGFzdC5zZXRBc0xhc3QoKTtcbiAgICAgIH0pO1xuICB9XG5cbiAgbmdPbkRlc3Ryb3koKSB7XG4gICAgdGhpcy5fZGVzdHJveWVkLm5leHQoKTtcbiAgICB0aGlzLl9kZXN0cm95ZWQuY29tcGxldGUoKTtcbiAgfVxufVxuIl19