/**
 * @fileoverview added by tsickle
 * Generated from: sort-header/sort.directive.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import { Directive, Output, EventEmitter, Input } from '@angular/core';
import { Subject } from 'rxjs';
var SortEvent = /** @class */ (function () {
    function SortEvent(active, direction) {
        this.active = active;
        this.direction = direction;
    }
    return SortEvent;
}());
export { SortEvent };
if (false) {
    /**
     * The name of the column that is being sorted by.
     * @type {?}
     */
    SortEvent.prototype.active;
    /**
     * The sort direction.
     * @type {?}
     */
    SortEvent.prototype.direction;
}
var NxSortDirective = /** @class */ (function () {
    function NxSortDirective() {
        this._stateChanges = new Subject();
        this._direction = 'asc';
        /**
         * \@docs-private
         * An event emitted when the active value has changed.
         */
        this.activeChange = new EventEmitter();
        /**
         * \@docs-private
         * An event emitted when the direction value has changed.
         */
        this.directionChange = new EventEmitter();
        /**
         * An event emitted when either the active sort or sort direction changes.
         */
        this.sortChange = new EventEmitter();
    }
    Object.defineProperty(NxSortDirective.prototype, "active", {
        get: /**
         * @return {?}
         */
        function () {
            return this._active;
        },
        /** Sets the key of the most recently sorted column. */
        set: /**
         * Sets the key of the most recently sorted column.
         * @param {?} value
         * @return {?}
         */
        function (value) {
            if (this._active !== value) {
                this._active = value;
                this.sortChange.emit(new SortEvent(this.active, this.direction));
                this._stateChanges.next();
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NxSortDirective.prototype, "direction", {
        get: /**
         * @return {?}
         */
        function () {
            return this._direction;
        },
        /** Sets the direction of the currently active sorted column. Default: 'asc'. */
        set: /**
         * Sets the direction of the currently active sorted column. Default: 'asc'.
         * @param {?} value
         * @return {?}
         */
        function (value) {
            if (this._direction !== value) {
                this._direction = value;
                this.sortChange.emit(new SortEvent(this.active, this.direction));
                this._stateChanges.next();
            }
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @return {?}
     */
    NxSortDirective.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        this._stateChanges.complete();
    };
    /**
     * Sets the active sort key and determines the new sort direction.
     * Afterwards the output event `sortChange` is called.
     *
     * If `sortable` is not the key of the active sort header, the initial direction to sort is 'asc'.
     * Otherwise the direction of the sorted column changes.
     */
    /**
     * Sets the active sort key and determines the new sort direction.
     * Afterwards the output event `sortChange` is called.
     *
     * If `sortable` is not the key of the active sort header, the initial direction to sort is 'asc'.
     * Otherwise the direction of the sorted column changes.
     * @param {?} sortable
     * @return {?}
     */
    NxSortDirective.prototype.sort = /**
     * Sets the active sort key and determines the new sort direction.
     * Afterwards the output event `sortChange` is called.
     *
     * If `sortable` is not the key of the active sort header, the initial direction to sort is 'asc'.
     * Otherwise the direction of the sorted column changes.
     * @param {?} sortable
     * @return {?}
     */
    function (sortable) {
        if (this._active !== sortable) {
            this._active = sortable;
            this.activeChange.emit(this.active);
            this._direction = 'asc';
            this.directionChange.emit(this.direction);
        }
        else if (this._direction === 'asc') {
            this._direction = 'desc';
            this.directionChange.emit(this.direction);
        }
        else {
            this._direction = 'asc';
            this.directionChange.emit(this.direction);
        }
        this.sortChange.emit(new SortEvent(this.active, this.direction));
        this._stateChanges.next();
    };
    NxSortDirective.decorators = [
        { type: Directive, args: [{
                    selector: 'table[nxSort]',
                    exportAs: 'NxSortDirective'
                },] }
    ];
    NxSortDirective.propDecorators = {
        active: [{ type: Input }],
        direction: [{ type: Input }],
        activeChange: [{ type: Output }],
        directionChange: [{ type: Output }],
        sortChange: [{ type: Output }]
    };
    return NxSortDirective;
}());
export { NxSortDirective };
if (false) {
    /** @type {?} */
    NxSortDirective.prototype._stateChanges;
    /**
     * @type {?}
     * @private
     */
    NxSortDirective.prototype._active;
    /**
     * @type {?}
     * @private
     */
    NxSortDirective.prototype._direction;
    /**
     * \@docs-private
     * An event emitted when the active value has changed.
     * @type {?}
     */
    NxSortDirective.prototype.activeChange;
    /**
     * \@docs-private
     * An event emitted when the direction value has changed.
     * @type {?}
     */
    NxSortDirective.prototype.directionChange;
    /**
     * An event emitted when either the active sort or sort direction changes.
     * @type {?}
     */
    NxSortDirective.prototype.sortChange;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic29ydC5kaXJlY3RpdmUuanMiLCJzb3VyY2VSb290Ijoibmc6Ly9AYWxsaWFuei9uZ3gtbmRieC90YWJsZS8iLCJzb3VyY2VzIjpbInNvcnQtaGVhZGVyL3NvcnQuZGlyZWN0aXZlLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7O0FBQUEsT0FBTyxFQUFFLFNBQVMsRUFBRSxNQUFNLEVBQUUsWUFBWSxFQUFFLEtBQUssRUFBYSxNQUFNLGVBQWUsQ0FBQztBQUNsRixPQUFPLEVBQUUsT0FBTyxFQUFFLE1BQU0sTUFBTSxDQUFDO0FBSS9CO0lBT0UsbUJBQVksTUFBTSxFQUFFLFNBQVM7UUFDM0IsSUFBSSxDQUFDLE1BQU0sR0FBRyxNQUFNLENBQUM7UUFDckIsSUFBSSxDQUFDLFNBQVMsR0FBRyxTQUFTLENBQUM7SUFDN0IsQ0FBQztJQUNILGdCQUFDO0FBQUQsQ0FBQyxBQVhELElBV0M7Ozs7Ozs7SUFUQywyQkFBZTs7Ozs7SUFHZiw4QkFBeUI7O0FBUTNCO0lBQUE7UUFNVyxrQkFBYSxHQUFHLElBQUksT0FBTyxFQUFRLENBQUM7UUFpQnJDLGVBQVUsR0FBa0IsS0FBSyxDQUFDOzs7OztRQW1CdkIsaUJBQVksR0FBeUIsSUFBSSxZQUFZLEVBQVUsQ0FBQzs7Ozs7UUFNaEUsb0JBQWUsR0FBZ0MsSUFBSSxZQUFZLEVBQWlCLENBQUM7Ozs7UUFHakYsZUFBVSxHQUE0QixJQUFJLFlBQVksRUFBYSxDQUFDO0lBK0J6RixDQUFDO0lBdkVDLHNCQUNJLG1DQUFNOzs7O1FBT1Y7WUFDRSxPQUFPLElBQUksQ0FBQyxPQUFPLENBQUM7UUFDdEIsQ0FBQztRQVhELHVEQUF1RDs7Ozs7O1FBQ3ZELFVBQ1csS0FBYTtZQUN0QixJQUFJLElBQUksQ0FBQyxPQUFPLEtBQUssS0FBSyxFQUFFO2dCQUMxQixJQUFJLENBQUMsT0FBTyxHQUFHLEtBQUssQ0FBQztnQkFDckIsSUFBSSxDQUFDLFVBQVUsQ0FBQyxJQUFJLENBQUMsSUFBSSxTQUFTLENBQUMsSUFBSSxDQUFDLE1BQU0sRUFBRSxJQUFJLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBQztnQkFDakUsSUFBSSxDQUFDLGFBQWEsQ0FBQyxJQUFJLEVBQUUsQ0FBQzthQUMzQjtRQUNILENBQUM7OztPQUFBO0lBUUQsc0JBQ0ksc0NBQVM7Ozs7UUFPYjtZQUNFLE9BQU8sSUFBSSxDQUFDLFVBQVUsQ0FBQztRQUN6QixDQUFDO1FBWEQsZ0ZBQWdGOzs7Ozs7UUFDaEYsVUFDYyxLQUFvQjtZQUNoQyxJQUFJLElBQUksQ0FBQyxVQUFVLEtBQUssS0FBSyxFQUFFO2dCQUM3QixJQUFJLENBQUMsVUFBVSxHQUFHLEtBQUssQ0FBQztnQkFDeEIsSUFBSSxDQUFDLFVBQVUsQ0FBQyxJQUFJLENBQUMsSUFBSSxTQUFTLENBQUMsSUFBSSxDQUFDLE1BQU0sRUFBRSxJQUFJLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBQztnQkFDakUsSUFBSSxDQUFDLGFBQWEsQ0FBQyxJQUFJLEVBQUUsQ0FBQzthQUMzQjtRQUNILENBQUM7OztPQUFBOzs7O0lBb0JELHFDQUFXOzs7SUFBWDtRQUNFLElBQUksQ0FBQyxhQUFhLENBQUMsUUFBUSxFQUFFLENBQUM7SUFDaEMsQ0FBQztJQUVEOzs7Ozs7T0FNRzs7Ozs7Ozs7OztJQUNILDhCQUFJOzs7Ozs7Ozs7SUFBSixVQUFLLFFBQWdCO1FBQ25CLElBQUksSUFBSSxDQUFDLE9BQU8sS0FBSyxRQUFRLEVBQUU7WUFDN0IsSUFBSSxDQUFDLE9BQU8sR0FBRyxRQUFRLENBQUM7WUFDeEIsSUFBSSxDQUFDLFlBQVksQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxDQUFDO1lBQ3BDLElBQUksQ0FBQyxVQUFVLEdBQUcsS0FBSyxDQUFDO1lBQ3hCLElBQUksQ0FBQyxlQUFlLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxTQUFTLENBQUMsQ0FBQztTQUMzQzthQUFNLElBQUksSUFBSSxDQUFDLFVBQVUsS0FBSyxLQUFLLEVBQUU7WUFDcEMsSUFBSSxDQUFDLFVBQVUsR0FBRyxNQUFNLENBQUM7WUFDekIsSUFBSSxDQUFDLGVBQWUsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxDQUFDO1NBQzNDO2FBQU07WUFDTCxJQUFJLENBQUMsVUFBVSxHQUFHLEtBQUssQ0FBQztZQUN4QixJQUFJLENBQUMsZUFBZSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsU0FBUyxDQUFDLENBQUM7U0FDM0M7UUFFRCxJQUFJLENBQUMsVUFBVSxDQUFDLElBQUksQ0FBQyxJQUFJLFNBQVMsQ0FBQyxJQUFJLENBQUMsTUFBTSxFQUFFLElBQUksQ0FBQyxTQUFTLENBQUMsQ0FBQyxDQUFDO1FBQ2pFLElBQUksQ0FBQyxhQUFhLENBQUMsSUFBSSxFQUFFLENBQUM7SUFDNUIsQ0FBQzs7Z0JBaEZGLFNBQVMsU0FBQztvQkFDVCxRQUFRLEVBQUUsZUFBZTtvQkFDekIsUUFBUSxFQUFFLGlCQUFpQjtpQkFDNUI7Ozt5QkFRRSxLQUFLOzRCQWVMLEtBQUs7K0JBZ0JMLE1BQU07a0NBTU4sTUFBTTs2QkFHTixNQUFNOztJQStCVCxzQkFBQztDQUFBLEFBbEZELElBa0ZDO1NBOUVZLGVBQWU7OztJQUUxQix3Q0FBNkM7Ozs7O0lBRTdDLGtDQUF3Qjs7Ozs7SUFleEIscUNBQTBDOzs7Ozs7SUFtQjFDLHVDQUFtRjs7Ozs7O0lBTW5GLDBDQUFvRzs7Ozs7SUFHcEcscUNBQXVGIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgRGlyZWN0aXZlLCBPdXRwdXQsIEV2ZW50RW1pdHRlciwgSW5wdXQsIE9uRGVzdHJveSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgU3ViamVjdCB9IGZyb20gJ3J4anMnO1xuXG5leHBvcnQgdHlwZSBTb3J0RGlyZWN0aW9uID0gJ2FzYycgfCAnZGVzYyc7XG5cbmV4cG9ydCBjbGFzcyBTb3J0RXZlbnQge1xuICAvKiogVGhlIG5hbWUgb2YgdGhlIGNvbHVtbiB0aGF0IGlzIGJlaW5nIHNvcnRlZCBieS4gKi9cbiAgYWN0aXZlOiBzdHJpbmc7XG5cbiAgLyoqIFRoZSBzb3J0IGRpcmVjdGlvbi4gKi9cbiAgZGlyZWN0aW9uOiBTb3J0RGlyZWN0aW9uO1xuXG4gIGNvbnN0cnVjdG9yKGFjdGl2ZSwgZGlyZWN0aW9uKSB7XG4gICAgdGhpcy5hY3RpdmUgPSBhY3RpdmU7XG4gICAgdGhpcy5kaXJlY3Rpb24gPSBkaXJlY3Rpb247XG4gIH1cbn1cblxuQERpcmVjdGl2ZSh7XG4gIHNlbGVjdG9yOiAndGFibGVbbnhTb3J0XScsXG4gIGV4cG9ydEFzOiAnTnhTb3J0RGlyZWN0aXZlJ1xufSlcbmV4cG9ydCBjbGFzcyBOeFNvcnREaXJlY3RpdmUgaW1wbGVtZW50cyBPbkRlc3Ryb3kge1xuXG4gIHJlYWRvbmx5IF9zdGF0ZUNoYW5nZXMgPSBuZXcgU3ViamVjdDx2b2lkPigpO1xuXG4gIHByaXZhdGUgX2FjdGl2ZTogc3RyaW5nO1xuXG4gIC8qKiBTZXRzIHRoZSBrZXkgb2YgdGhlIG1vc3QgcmVjZW50bHkgc29ydGVkIGNvbHVtbi4gKi9cbiAgQElucHV0KClcbiAgc2V0IGFjdGl2ZSh2YWx1ZTogc3RyaW5nKSB7XG4gICAgaWYgKHRoaXMuX2FjdGl2ZSAhPT0gdmFsdWUpIHtcbiAgICAgIHRoaXMuX2FjdGl2ZSA9IHZhbHVlO1xuICAgICAgdGhpcy5zb3J0Q2hhbmdlLmVtaXQobmV3IFNvcnRFdmVudCh0aGlzLmFjdGl2ZSwgdGhpcy5kaXJlY3Rpb24pKTtcbiAgICAgIHRoaXMuX3N0YXRlQ2hhbmdlcy5uZXh0KCk7XG4gICAgfVxuICB9XG4gIGdldCBhY3RpdmUoKTogc3RyaW5nIHtcbiAgICByZXR1cm4gdGhpcy5fYWN0aXZlO1xuICB9XG5cbiAgcHJpdmF0ZSBfZGlyZWN0aW9uOiBTb3J0RGlyZWN0aW9uID0gJ2FzYyc7XG5cbiAgLyoqIFNldHMgdGhlIGRpcmVjdGlvbiBvZiB0aGUgY3VycmVudGx5IGFjdGl2ZSBzb3J0ZWQgY29sdW1uLiBEZWZhdWx0OiAnYXNjJy4gKi9cbiAgQElucHV0KClcbiAgc2V0IGRpcmVjdGlvbih2YWx1ZTogU29ydERpcmVjdGlvbikge1xuICAgIGlmICh0aGlzLl9kaXJlY3Rpb24gIT09IHZhbHVlKSB7XG4gICAgICB0aGlzLl9kaXJlY3Rpb24gPSB2YWx1ZTtcbiAgICAgIHRoaXMuc29ydENoYW5nZS5lbWl0KG5ldyBTb3J0RXZlbnQodGhpcy5hY3RpdmUsIHRoaXMuZGlyZWN0aW9uKSk7XG4gICAgICB0aGlzLl9zdGF0ZUNoYW5nZXMubmV4dCgpO1xuICAgIH1cbiAgfVxuICBnZXQgZGlyZWN0aW9uKCk6IFNvcnREaXJlY3Rpb24ge1xuICAgIHJldHVybiB0aGlzLl9kaXJlY3Rpb247XG4gIH1cblxuICAvKipcbiAgICogQGRvY3MtcHJpdmF0ZVxuICAgKiBBbiBldmVudCBlbWl0dGVkIHdoZW4gdGhlIGFjdGl2ZSB2YWx1ZSBoYXMgY2hhbmdlZC5cbiAgICovXG4gIEBPdXRwdXQoKSByZWFkb25seSBhY3RpdmVDaGFuZ2U6IEV2ZW50RW1pdHRlcjxzdHJpbmc+ID0gbmV3IEV2ZW50RW1pdHRlcjxzdHJpbmc+KCk7XG5cbiAgLyoqXG4gICAqIEBkb2NzLXByaXZhdGVcbiAgICogQW4gZXZlbnQgZW1pdHRlZCB3aGVuIHRoZSBkaXJlY3Rpb24gdmFsdWUgaGFzIGNoYW5nZWQuXG4gICAqL1xuICBAT3V0cHV0KCkgcmVhZG9ubHkgZGlyZWN0aW9uQ2hhbmdlOiBFdmVudEVtaXR0ZXI8U29ydERpcmVjdGlvbj4gPSBuZXcgRXZlbnRFbWl0dGVyPFNvcnREaXJlY3Rpb24+KCk7XG5cbiAgLyoqIEFuIGV2ZW50IGVtaXR0ZWQgd2hlbiBlaXRoZXIgdGhlIGFjdGl2ZSBzb3J0IG9yIHNvcnQgZGlyZWN0aW9uIGNoYW5nZXMuICovXG4gIEBPdXRwdXQoKSByZWFkb25seSBzb3J0Q2hhbmdlOiBFdmVudEVtaXR0ZXI8U29ydEV2ZW50PiA9IG5ldyBFdmVudEVtaXR0ZXI8U29ydEV2ZW50PigpO1xuXG4gIG5nT25EZXN0cm95KCkge1xuICAgIHRoaXMuX3N0YXRlQ2hhbmdlcy5jb21wbGV0ZSgpO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldHMgdGhlIGFjdGl2ZSBzb3J0IGtleSBhbmQgZGV0ZXJtaW5lcyB0aGUgbmV3IHNvcnQgZGlyZWN0aW9uLlxuICAgKiBBZnRlcndhcmRzIHRoZSBvdXRwdXQgZXZlbnQgYHNvcnRDaGFuZ2VgIGlzIGNhbGxlZC5cbiAgICpcbiAgICogSWYgYHNvcnRhYmxlYCBpcyBub3QgdGhlIGtleSBvZiB0aGUgYWN0aXZlIHNvcnQgaGVhZGVyLCB0aGUgaW5pdGlhbCBkaXJlY3Rpb24gdG8gc29ydCBpcyAnYXNjJy5cbiAgICogT3RoZXJ3aXNlIHRoZSBkaXJlY3Rpb24gb2YgdGhlIHNvcnRlZCBjb2x1bW4gY2hhbmdlcy5cbiAgICovXG4gIHNvcnQoc29ydGFibGU6IHN0cmluZyk6IHZvaWQge1xuICAgIGlmICh0aGlzLl9hY3RpdmUgIT09IHNvcnRhYmxlKSB7XG4gICAgICB0aGlzLl9hY3RpdmUgPSBzb3J0YWJsZTtcbiAgICAgIHRoaXMuYWN0aXZlQ2hhbmdlLmVtaXQodGhpcy5hY3RpdmUpO1xuICAgICAgdGhpcy5fZGlyZWN0aW9uID0gJ2FzYyc7XG4gICAgICB0aGlzLmRpcmVjdGlvbkNoYW5nZS5lbWl0KHRoaXMuZGlyZWN0aW9uKTtcbiAgICB9IGVsc2UgaWYgKHRoaXMuX2RpcmVjdGlvbiA9PT0gJ2FzYycpIHtcbiAgICAgIHRoaXMuX2RpcmVjdGlvbiA9ICdkZXNjJztcbiAgICAgIHRoaXMuZGlyZWN0aW9uQ2hhbmdlLmVtaXQodGhpcy5kaXJlY3Rpb24pO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9kaXJlY3Rpb24gPSAnYXNjJztcbiAgICAgIHRoaXMuZGlyZWN0aW9uQ2hhbmdlLmVtaXQodGhpcy5kaXJlY3Rpb24pO1xuICAgIH1cblxuICAgIHRoaXMuc29ydENoYW5nZS5lbWl0KG5ldyBTb3J0RXZlbnQodGhpcy5hY3RpdmUsIHRoaXMuZGlyZWN0aW9uKSk7XG4gICAgdGhpcy5fc3RhdGVDaGFuZ2VzLm5leHQoKTtcbiAgfVxuXG59XG4iXX0=