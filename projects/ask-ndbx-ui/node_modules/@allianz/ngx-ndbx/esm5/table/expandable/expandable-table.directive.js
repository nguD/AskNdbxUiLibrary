/**
 * @fileoverview added by tsickle
 * Generated from: expandable/expandable-table.directive.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import { ContentChildren, QueryList, Directive } from '@angular/core';
import { NxExpandableTableRowComponent } from './expandable-table-row.component';
import { flatMap, startWith, map, distinctUntilChanged } from 'rxjs/operators';
import { combineLatest, BehaviorSubject } from 'rxjs';
/**
 * The nxExpandableTable adds row expansion functionality to the nxTable.
 * It provides the logic to expand/collapse all expandable rows simultanously.
 */
var NxExpandableTableDirective = /** @class */ (function () {
    function NxExpandableTableDirective() {
        this.expanded = new BehaviorSubject(false);
    }
    /**
     * @return {?}
     */
    NxExpandableTableDirective.prototype.ngAfterViewInit = /**
     * @return {?}
     */
    function () {
        var _this = this;
        this.rows.changes.pipe(startWith(this.rows), flatMap((/**
         * @param {?} rows
         * @return {?}
         */
        function (rows) {
            return combineLatest(rows.map((/**
             * @param {?} row
             * @return {?}
             */
            function (row) { return row.expanded; })));
        })), map((/**
         * @param {?} values
         * @return {?}
         */
        function (values) {
            return values.reduce((/**
             * @param {?} a
             * @param {?} x
             * @return {?}
             */
            function (a, x) { return a && x; }), true);
        })), distinctUntilChanged())
            .subscribe((/**
         * @param {?} rowsOpen
         * @return {?}
         */
        function (rowsOpen) {
            _this.expanded.next(rowsOpen);
        }));
    };
    /**
     * Toggles the expandable rows. If all rows are open it will close them, otherwise it will open them.
     */
    /**
     * Toggles the expandable rows. If all rows are open it will close them, otherwise it will open them.
     * @return {?}
     */
    NxExpandableTableDirective.prototype.toggle = /**
     * Toggles the expandable rows. If all rows are open it will close them, otherwise it will open them.
     * @return {?}
     */
    function () {
        if (this.expanded.value) {
            this.close();
        }
        else {
            this.expand();
        }
    };
    /**
     * Expands all expandable rows.
     */
    /**
     * Expands all expandable rows.
     * @return {?}
     */
    NxExpandableTableDirective.prototype.expand = /**
     * Expands all expandable rows.
     * @return {?}
     */
    function () {
        this.rows.forEach((/**
         * @param {?} row
         * @return {?}
         */
        function (row) { return row.expanded.next(true); }));
    };
    /**
     * Closes all expandable rows.
     */
    /**
     * Closes all expandable rows.
     * @return {?}
     */
    NxExpandableTableDirective.prototype.close = /**
     * Closes all expandable rows.
     * @return {?}
     */
    function () {
        this.rows.forEach((/**
         * @param {?} row
         * @return {?}
         */
        function (row) { return row.expanded.next(false); }));
    };
    NxExpandableTableDirective.decorators = [
        { type: Directive, args: [{
                    selector: 'table[nxExpandableTable]',
                    exportAs: 'nxExpandableTable'
                },] }
    ];
    NxExpandableTableDirective.propDecorators = {
        rows: [{ type: ContentChildren, args: [NxExpandableTableRowComponent, { descendants: true },] }]
    };
    return NxExpandableTableDirective;
}());
export { NxExpandableTableDirective };
if (false) {
    /** @type {?} */
    NxExpandableTableDirective.prototype.rows;
    /** @type {?} */
    NxExpandableTableDirective.prototype.expanded;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZXhwYW5kYWJsZS10YWJsZS5kaXJlY3RpdmUuanMiLCJzb3VyY2VSb290Ijoibmc6Ly9AYWxsaWFuei9uZ3gtbmRieC90YWJsZS8iLCJzb3VyY2VzIjpbImV4cGFuZGFibGUvZXhwYW5kYWJsZS10YWJsZS5kaXJlY3RpdmUudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQSxPQUFPLEVBQUUsZUFBZSxFQUFFLFNBQVMsRUFBaUIsU0FBUyxFQUFFLE1BQU0sZUFBZSxDQUFDO0FBQ3JGLE9BQU8sRUFBRSw2QkFBNkIsRUFBRSxNQUFNLGtDQUFrQyxDQUFDO0FBQ2pGLE9BQU8sRUFBRSxPQUFPLEVBQUUsU0FBUyxFQUFFLEdBQUcsRUFBRSxvQkFBb0IsRUFBRSxNQUFNLGdCQUFnQixDQUFDO0FBQy9FLE9BQU8sRUFBRSxhQUFhLEVBQUUsZUFBZSxFQUFFLE1BQU0sTUFBTSxDQUFDOzs7OztBQU90RDtJQUFBO1FBT0UsYUFBUSxHQUE2QixJQUFJLGVBQWUsQ0FBQyxLQUFLLENBQUMsQ0FBQztJQTBDbEUsQ0FBQzs7OztJQXhDQyxvREFBZTs7O0lBQWY7UUFBQSxpQkFjQztRQWJDLElBQUksQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFDLElBQUksQ0FDcEIsU0FBUyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsRUFDcEIsT0FBTzs7OztRQUFDLFVBQUMsSUFBcUM7WUFDNUMsT0FBTyxhQUFhLENBQUMsSUFBSSxDQUFDLEdBQUc7Ozs7WUFBQyxVQUFBLEdBQUcsSUFBSSxPQUFBLEdBQUcsQ0FBQyxRQUFRLEVBQVosQ0FBWSxFQUFDLENBQUMsQ0FBQztRQUN0RCxDQUFDLEVBQUMsRUFDRixHQUFHOzs7O1FBQUMsVUFBQyxNQUFpQjtZQUNwQixPQUFBLE1BQU0sQ0FBQyxNQUFNOzs7OztZQUFDLFVBQUMsQ0FBQyxFQUFFLENBQUMsSUFBSyxPQUFBLENBQUMsSUFBSSxDQUFDLEVBQU4sQ0FBTSxHQUFFLElBQUksQ0FBQztRQUFyQyxDQUFxQyxFQUN0QyxFQUNELG9CQUFvQixFQUFFLENBQ3ZCO2FBQ0EsU0FBUzs7OztRQUFDLFVBQUMsUUFBUTtZQUNsQixLQUFJLENBQUMsUUFBUSxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUMsQ0FBQztRQUMvQixDQUFDLEVBQUMsQ0FBQztJQUNMLENBQUM7SUFFRDs7T0FFRzs7Ozs7SUFDSCwyQ0FBTTs7OztJQUFOO1FBQ0UsSUFBSSxJQUFJLENBQUMsUUFBUSxDQUFDLEtBQUssRUFBRTtZQUN2QixJQUFJLENBQUMsS0FBSyxFQUFFLENBQUM7U0FDZDthQUFNO1lBQ0wsSUFBSSxDQUFDLE1BQU0sRUFBRSxDQUFDO1NBQ2Y7SUFDSCxDQUFDO0lBRUQ7O09BRUc7Ozs7O0lBQ0gsMkNBQU07Ozs7SUFBTjtRQUNFLElBQUksQ0FBQyxJQUFJLENBQUMsT0FBTzs7OztRQUFDLFVBQUEsR0FBRyxJQUFJLE9BQUEsR0FBRyxDQUFDLFFBQVEsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLEVBQXZCLENBQXVCLEVBQUMsQ0FBQztJQUNwRCxDQUFDO0lBRUQ7O09BRUc7Ozs7O0lBQ0gsMENBQUs7Ozs7SUFBTDtRQUNFLElBQUksQ0FBQyxJQUFJLENBQUMsT0FBTzs7OztRQUFDLFVBQUEsR0FBRyxJQUFJLE9BQUEsR0FBRyxDQUFDLFFBQVEsQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLEVBQXhCLENBQXdCLEVBQUMsQ0FBQztJQUNyRCxDQUFDOztnQkFoREYsU0FBUyxTQUFDO29CQUNULFFBQVEsRUFBRSwwQkFBMEI7b0JBQ3BDLFFBQVEsRUFBRSxtQkFBbUI7aUJBQzlCOzs7dUJBRUUsZUFBZSxTQUFDLDZCQUE2QixFQUFFLEVBQUUsV0FBVyxFQUFFLElBQUksRUFBRTs7SUE0Q3ZFLGlDQUFDO0NBQUEsQUFqREQsSUFpREM7U0E3Q1ksMEJBQTBCOzs7SUFDckMsMENBQXNIOztJQUV0SCw4Q0FBZ0UiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBDb250ZW50Q2hpbGRyZW4sIFF1ZXJ5TGlzdCwgQWZ0ZXJWaWV3SW5pdCwgRGlyZWN0aXZlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBOeEV4cGFuZGFibGVUYWJsZVJvd0NvbXBvbmVudCB9IGZyb20gJy4vZXhwYW5kYWJsZS10YWJsZS1yb3cuY29tcG9uZW50JztcbmltcG9ydCB7IGZsYXRNYXAsIHN0YXJ0V2l0aCwgbWFwLCBkaXN0aW5jdFVudGlsQ2hhbmdlZCB9IGZyb20gJ3J4anMvb3BlcmF0b3JzJztcbmltcG9ydCB7IGNvbWJpbmVMYXRlc3QsIEJlaGF2aW9yU3ViamVjdCB9IGZyb20gJ3J4anMnO1xuaW1wb3J0IHsgTnhFeHBhbmRhYmxlIH0gZnJvbSAnLi90b2dnbGUtYnV0dG9uLmNvbXBvbmVudCc7XG5cbi8qKlxuICogVGhlIG54RXhwYW5kYWJsZVRhYmxlIGFkZHMgcm93IGV4cGFuc2lvbiBmdW5jdGlvbmFsaXR5IHRvIHRoZSBueFRhYmxlLlxuICogSXQgcHJvdmlkZXMgdGhlIGxvZ2ljIHRvIGV4cGFuZC9jb2xsYXBzZSBhbGwgZXhwYW5kYWJsZSByb3dzIHNpbXVsdGFub3VzbHkuXG4gKi9cbkBEaXJlY3RpdmUoe1xuICBzZWxlY3RvcjogJ3RhYmxlW254RXhwYW5kYWJsZVRhYmxlXScsXG4gIGV4cG9ydEFzOiAnbnhFeHBhbmRhYmxlVGFibGUnXG59KVxuZXhwb3J0IGNsYXNzIE54RXhwYW5kYWJsZVRhYmxlRGlyZWN0aXZlIGltcGxlbWVudHMgQWZ0ZXJWaWV3SW5pdCwgTnhFeHBhbmRhYmxlIHtcbiAgQENvbnRlbnRDaGlsZHJlbihOeEV4cGFuZGFibGVUYWJsZVJvd0NvbXBvbmVudCwgeyBkZXNjZW5kYW50czogdHJ1ZSB9KSByb3dzOiBRdWVyeUxpc3Q8TnhFeHBhbmRhYmxlVGFibGVSb3dDb21wb25lbnQ+O1xuXG4gIGV4cGFuZGVkOiBCZWhhdmlvclN1YmplY3Q8Ym9vbGVhbj4gPSBuZXcgQmVoYXZpb3JTdWJqZWN0KGZhbHNlKTtcblxuICBuZ0FmdGVyVmlld0luaXQoKSB7XG4gICAgdGhpcy5yb3dzLmNoYW5nZXMucGlwZShcbiAgICAgIHN0YXJ0V2l0aCh0aGlzLnJvd3MpLFxuICAgICAgZmxhdE1hcCgocm93czogTnhFeHBhbmRhYmxlVGFibGVSb3dDb21wb25lbnRbXSkgPT4ge1xuICAgICAgICByZXR1cm4gY29tYmluZUxhdGVzdChyb3dzLm1hcChyb3cgPT4gcm93LmV4cGFuZGVkKSk7XG4gICAgICB9KSxcbiAgICAgIG1hcCgodmFsdWVzOiBib29sZWFuW10pID0+XG4gICAgICAgIHZhbHVlcy5yZWR1Y2UoKGEsIHgpID0+IGEgJiYgeCwgdHJ1ZSlcbiAgICAgICksXG4gICAgICBkaXN0aW5jdFVudGlsQ2hhbmdlZCgpXG4gICAgKVxuICAgIC5zdWJzY3JpYmUoKHJvd3NPcGVuKSA9PiB7XG4gICAgICB0aGlzLmV4cGFuZGVkLm5leHQocm93c09wZW4pO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFRvZ2dsZXMgdGhlIGV4cGFuZGFibGUgcm93cy4gSWYgYWxsIHJvd3MgYXJlIG9wZW4gaXQgd2lsbCBjbG9zZSB0aGVtLCBvdGhlcndpc2UgaXQgd2lsbCBvcGVuIHRoZW0uXG4gICAqL1xuICB0b2dnbGUoKSB7XG4gICAgaWYgKHRoaXMuZXhwYW5kZWQudmFsdWUpIHtcbiAgICAgIHRoaXMuY2xvc2UoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5leHBhbmQoKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogRXhwYW5kcyBhbGwgZXhwYW5kYWJsZSByb3dzLlxuICAgKi9cbiAgZXhwYW5kKCkge1xuICAgIHRoaXMucm93cy5mb3JFYWNoKHJvdyA9PiByb3cuZXhwYW5kZWQubmV4dCh0cnVlKSk7XG4gIH1cblxuICAvKipcbiAgICogQ2xvc2VzIGFsbCBleHBhbmRhYmxlIHJvd3MuXG4gICAqL1xuICBjbG9zZSgpIHtcbiAgICB0aGlzLnJvd3MuZm9yRWFjaChyb3cgPT4gcm93LmV4cGFuZGVkLm5leHQoZmFsc2UpKTtcbiAgfVxufVxuIl19