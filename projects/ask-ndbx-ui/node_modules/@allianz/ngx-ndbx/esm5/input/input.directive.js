/**
 * @fileoverview added by tsickle
 * Generated from: input.directive.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import { coerceBooleanProperty } from '@angular/cdk/coercion';
import { getSupportedInputTypes, Platform } from '@angular/cdk/platform';
import { Inject, Directive, ElementRef, Input, Optional, Self, InjectionToken } from '@angular/core';
import { FormGroupDirective, NgControl, NgForm } from '@angular/forms';
import { Subject } from 'rxjs';
import { AutofillMonitor } from '@angular/cdk/text-field';
import { NxFormfieldControl } from '@allianz/ngx-ndbx/formfield';
import { ErrorStateMatcher } from '@allianz/ngx-ndbx/utils';
/** @type {?} */
export var NX_INPUT_VALUE_ACCESSOR = new InjectionToken('NX_INPUT_VALUE_ACCESSOR');
/** @type {?} */
var INVALID_TYPES = [
    'button',
    'checkbox',
    'file',
    'hidden',
    'image',
    'radio',
    'range',
    'reset',
    'submit'
];
var ɵ0 = /**
 * @param {?} t
 * @return {?}
 */
function (t) { return getSupportedInputTypes().has(t); };
/** @type {?} */
var NEVER_EMPTY = [
    'date',
    'datetime',
    'datetime-local',
    'month',
    'time',
    'week'
].filter((ɵ0));
/** @type {?} */
var nextUniqueId = 0;
var NxInputDirective = /** @class */ (function () {
    function NxInputDirective(_elementRef, _platform, ngControl, _parentForm, _parentFormGroup, _errorStateMatcher, inputValueAccessor, _autofillMonitor) {
        this._elementRef = _elementRef;
        this._platform = _platform;
        this.ngControl = ngControl;
        this._parentForm = _parentForm;
        this._parentFormGroup = _parentFormGroup;
        this._errorStateMatcher = _errorStateMatcher;
        this._autofillMonitor = _autofillMonitor;
        this._type = 'text';
        this._uid = "nx-input-" + nextUniqueId++;
        this._disabled = false;
        this._required = false;
        this._readonly = false;
        /**
         * \@docs-private
         */
        this.errorState = false;
        /**
         * Name of this control that is used inside the formfield component
         * \@docs-private
         */
        this.controlType = 'nx-input';
        /**
         * \@docs-private
         */
        this.autofilled = false;
        /**
         * \@docs-private
         */
        this.stateChanges = new Subject();
        /**
         * \@docs-private
         */
        this.focused = false;
        this.id = this.id;
        // This will enable other directives to plugin itself as the value accessor
        // by using the NX_INPUT_VALUE_ACCESSOR Token. Default is the given input field.
        // TODO eliminate injected dateValueAccessor once we have intra-package support in ng-packagr
        // See the datefield for details.
        this._inputValueAccessor = inputValueAccessor || this._elementRef.nativeElement;
        this._previousNativeValue = this.value;
        if (this._elementRef.nativeElement.nodeName.toLowerCase() === 'textarea') {
            this.controlType = 'textarea';
        }
    }
    Object.defineProperty(NxInputDirective.prototype, "id", {
        /** The id of the input. */
        get: /**
         * The id of the input.
         * @return {?}
         */
        function () {
            return this._id;
        },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this._id = value || this._uid;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NxInputDirective.prototype, "value", {
        /** The input element's value. */
        get: /**
         * The input element's value.
         * @return {?}
         */
        function () { return this._inputValueAccessor.value; },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            if (value !== this.value) {
                this._inputValueAccessor.value = value;
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NxInputDirective.prototype, "readonly", {
        /** Whether the element is readonly. */
        get: /**
         * Whether the element is readonly.
         * @return {?}
         */
        function () { return this._readonly; },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this._readonly = coerceBooleanProperty(value);
            this.stateChanges.next();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NxInputDirective.prototype, "disabled", {
        /** Whether the input is disabled. */
        get: /**
         * Whether the input is disabled.
         * @return {?}
         */
        function () {
            if (this.ngControl && this.ngControl.disabled !== null) {
                return this.ngControl.disabled;
            }
            return this._disabled;
        },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this._disabled = coerceBooleanProperty(value);
            // Browsers may not fire the blur event if the input is disabled too quickly.
            // Reset from here to ensure that the element doesn't become stuck.
            if (this.focused) {
                this.focused = false;
                this.stateChanges.next();
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NxInputDirective.prototype, "required", {
        /** Whether the element is required. */
        get: /**
         * Whether the element is required.
         * @return {?}
         */
        function () { return this._required; },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) { this._required = coerceBooleanProperty(value); },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NxInputDirective.prototype, "type", {
        /** Sets the type of the input element (e.g. password, text etc). */
        get: /**
         * Sets the type of the input element (e.g. password, text etc).
         * @return {?}
         */
        function () { return this._type; },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this._type = value || 'text';
            this._validateType();
            // When using Angular inputs, developers are no longer able to set the properties on the native
            // input element. To ensure that bindings for `type` work, we need to sync the setter
            // with the native property. Textarea elements don't support the type property or attribute.
            if (!this._isTextarea() && getSupportedInputTypes().has(this._type)) {
                this._elementRef.nativeElement.type = this._type;
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NxInputDirective.prototype, "placeholder", {
        /**
         * Sets the text for the input placeholder
         */
        get: /**
         * Sets the text for the input placeholder
         * @return {?}
         */
        function () {
            return this.empty ? this._placeholder : '';
        },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this._placeholder = value;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @return {?}
     */
    NxInputDirective.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        var _this = this;
        if (this._platform.isBrowser) {
            this._autofillMonitor.monitor(this._elementRef.nativeElement).subscribe((/**
             * @param {?} event
             * @return {?}
             */
            function (event) {
                _this.autofilled = event.isAutofilled;
                _this.stateChanges.next();
            }));
        }
    };
    Object.defineProperty(NxInputDirective.prototype, "elementRef", {
        /** @docs-private */
        get: /**
         * \@docs-private
         * @return {?}
         */
        function () {
            return this._elementRef;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @return {?}
     */
    NxInputDirective.prototype._onInput = /**
     * @return {?}
     */
    function () {
        // force to to run change detection so we know about changes in the native form input
    };
    /**
     * @param {?} isFocused
     * @return {?}
     */
    NxInputDirective.prototype._focusChanged = /**
     * @param {?} isFocused
     * @return {?}
     */
    function (isFocused) {
        if (isFocused !== this.focused && !this.readonly) {
            this.focused = isFocused;
            this.stateChanges.next();
        }
    };
    /**
     * @return {?}
     */
    NxInputDirective.prototype.ngOnChanges = /**
     * @return {?}
     */
    function () {
        this.stateChanges.next();
    };
    /**
     * @return {?}
     */
    NxInputDirective.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        this.stateChanges.complete();
        if (this._platform.isBrowser) {
            this._autofillMonitor.stopMonitoring(this._elementRef.nativeElement);
        }
    };
    /**
     * @return {?}
     */
    NxInputDirective.prototype.ngDoCheck = /**
     * @return {?}
     */
    function () {
        if (this.ngControl) {
            // We need to re-evaluate this on every change detection cycle, because there are some
            // error triggers that we can't subscribe to (e.g. parent form submissions). This means
            // that whatever logic is in here has to be super lean or we risk destroying the performance.
            this.updateErrorState();
        }
        // We need to dirty-check the native element's value, because there are some cases where
        // we won't be notified when it changes (e.g. the consumer isn't using forms or they're
        // updating the value using `emitEvent: false`).
        this._dirtyCheckNativeValue();
    };
    /** @docs-private */
    /**
     * \@docs-private
     * @return {?}
     */
    NxInputDirective.prototype.updateErrorState = /**
     * \@docs-private
     * @return {?}
     */
    function () {
        /** @type {?} */
        var oldState = this.errorState;
        /** @type {?} */
        var parent = this._parentFormGroup || this._parentForm;
        /** @type {?} */
        var control = this.ngControl ? (/** @type {?} */ (this.ngControl.control)) : null;
        /** @type {?} */
        var newState = this._errorStateMatcher.isErrorState(control, parent);
        if (newState !== oldState) {
            this.errorState = newState;
            this.stateChanges.next();
        }
    };
    /**
     * Set a list of ids that is currently describing this input
     * (if you have hints and errors for example).
     */
    /**
     * Set a list of ids that is currently describing this input
     * (if you have hints and errors for example).
     * @param {?} ids
     * @return {?}
     */
    NxInputDirective.prototype.setDescribedByIds = /**
     * Set a list of ids that is currently describing this input
     * (if you have hints and errors for example).
     * @param {?} ids
     * @return {?}
     */
    function (ids) {
        this._ariaDescribedby = ids.join(' ');
    };
    // allow to set a arial label value in case there
    // is not possibility to display a proper label
    /**
     * Method to set the aria label.
     * This is required if you use the input outside of a formfield
     * where you don't have a label connected.
     */
    // allow to set a arial label value in case there
    // is not possibility to display a proper label
    /**
     * Method to set the aria label.
     * This is required if you use the input outside of a formfield
     * where you don't have a label connected.
     * @param {?} value
     * @return {?}
     */
    NxInputDirective.prototype.setAriaLabel = 
    // allow to set a arial label value in case there
    // is not possibility to display a proper label
    /**
     * Method to set the aria label.
     * This is required if you use the input outside of a formfield
     * where you don't have a label connected.
     * @param {?} value
     * @return {?}
     */
    function (value) {
        this._ariaLabel = value;
    };
    /**
     * @protected
     * @return {?}
     */
    NxInputDirective.prototype._isBadInput = /**
     * @protected
     * @return {?}
     */
    function () {
        // The `validity` property won't be present on platform-server.
        /** @type {?} */
        var validity = ((/** @type {?} */ (this._elementRef.nativeElement))).validity;
        return validity && validity.badInput;
    };
    Object.defineProperty(NxInputDirective.prototype, "empty", {
        /** @docs-private */
        get: /**
         * \@docs-private
         * @return {?}
         */
        function () {
            return !this._isNeverEmpty() && !this._elementRef.nativeElement.value && !this._isBadInput() && !this.autofilled;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @protected
     * @return {?}
     */
    NxInputDirective.prototype._isNeverEmpty = /**
     * @protected
     * @return {?}
     */
    function () {
        return NEVER_EMPTY.indexOf(this._type) > -1;
    };
    /**
     * @protected
     * @return {?}
     */
    NxInputDirective.prototype._isTextarea = /**
     * @protected
     * @return {?}
     */
    function () {
        /** @type {?} */
        var nativeElement = this._elementRef.nativeElement;
        return nativeElement.nodeName ? nativeElement.nodeName.toLowerCase() === 'textarea' : false;
    };
    /**
     * @protected
     * @return {?}
     */
    NxInputDirective.prototype._validateType = /**
     * @protected
     * @return {?}
     */
    function () {
        if (INVALID_TYPES.indexOf(this._type) > -1) {
            throw new Error("Input of type '" + this._type + "' is not supported");
        }
    };
    Object.defineProperty(NxInputDirective.prototype, "shouldLabelFloat", {
        /** @docs-private */
        get: /**
         * \@docs-private
         * @return {?}
         */
        function () {
            return this.focused || !this.empty || (this.placeholder && this.placeholder.length > 0);
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @protected
     * @return {?}
     */
    NxInputDirective.prototype._dirtyCheckNativeValue = /**
     * @protected
     * @return {?}
     */
    function () {
        /** @type {?} */
        var newValue = this.value;
        if (this._previousNativeValue !== newValue) {
            this._previousNativeValue = newValue;
            this.stateChanges.next();
        }
    };
    NxInputDirective.decorators = [
        { type: Directive, args: [{
                    selector: 'input[nxInput], textarea[nxInput], select[nxInput]',
                    exportAs: 'nxInput',
                    host: {
                        '[class.c-input]': 'true',
                        '[attr.id]': 'id',
                        '[class.is-filled]': 'empty === false',
                        '[class.is-disabled]': 'disabled',
                        '[class.has-error]': 'errorState',
                        '[class.is-focused]': 'focused',
                        '[attr.disabled]': 'disabled || null',
                        '[attr.readonly]': 'readonly || null',
                        '[attr.required]': 'required || null',
                        '[attr.aria-label]': '_ariaLabel || null',
                        '[attr.aria-describedby]': '_ariaDescribedby || null',
                        '[attr.aria-invalid]': 'errorState',
                        '[attr.aria-required]': 'required.toString()',
                        '[attr.placeholder]': 'placeholder || null',
                        '(blur)': '_focusChanged(false)',
                        '(focus)': '_focusChanged(true)',
                        '(input)': '_onInput()',
                    },
                    providers: [{ provide: NxFormfieldControl, useExisting: NxInputDirective }],
                },] }
    ];
    /** @nocollapse */
    NxInputDirective.ctorParameters = function () { return [
        { type: ElementRef },
        { type: Platform },
        { type: NgControl, decorators: [{ type: Optional }, { type: Self }] },
        { type: NgForm, decorators: [{ type: Optional }] },
        { type: FormGroupDirective, decorators: [{ type: Optional }] },
        { type: ErrorStateMatcher },
        { type: undefined, decorators: [{ type: Optional }, { type: Self }, { type: Inject, args: [NX_INPUT_VALUE_ACCESSOR,] }] },
        { type: AutofillMonitor }
    ]; };
    NxInputDirective.propDecorators = {
        _ariaLabel: [{ type: Input, args: ['nxAriaLabel',] }],
        id: [{ type: Input }],
        value: [{ type: Input }],
        readonly: [{ type: Input }],
        disabled: [{ type: Input }],
        required: [{ type: Input }],
        type: [{ type: Input }],
        placeholder: [{ type: Input }]
    };
    return NxInputDirective;
}());
export { NxInputDirective };
if (false) {
    /**
     * @type {?}
     * @protected
     */
    NxInputDirective.prototype._type;
    /**
     * @type {?}
     * @protected
     */
    NxInputDirective.prototype._id;
    /**
     * @type {?}
     * @protected
     */
    NxInputDirective.prototype._uid;
    /**
     * @type {?}
     * @protected
     */
    NxInputDirective.prototype._previousNativeValue;
    /**
     * @type {?}
     * @protected
     */
    NxInputDirective.prototype._disabled;
    /**
     * @type {?}
     * @protected
     */
    NxInputDirective.prototype._required;
    /**
     * @type {?}
     * @private
     */
    NxInputDirective.prototype._readonly;
    /**
     * @type {?}
     * @private
     */
    NxInputDirective.prototype._inputValueAccessor;
    /** @type {?} */
    NxInputDirective.prototype._ariaDescribedby;
    /**
     * @type {?}
     * @private
     */
    NxInputDirective.prototype._placeholder;
    /** @type {?} */
    NxInputDirective.prototype._ariaLabel;
    /**
     * \@docs-private
     * @type {?}
     */
    NxInputDirective.prototype.errorState;
    /**
     * Name of this control that is used inside the formfield component
     * \@docs-private
     * @type {?}
     */
    NxInputDirective.prototype.controlType;
    /**
     * \@docs-private
     * @type {?}
     */
    NxInputDirective.prototype.autofilled;
    /**
     * \@docs-private
     * @type {?}
     */
    NxInputDirective.prototype.stateChanges;
    /**
     * \@docs-private
     * @type {?}
     */
    NxInputDirective.prototype.focused;
    /**
     * @type {?}
     * @protected
     */
    NxInputDirective.prototype._elementRef;
    /**
     * @type {?}
     * @protected
     */
    NxInputDirective.prototype._platform;
    /**
     * \@docs-private
     * @type {?}
     */
    NxInputDirective.prototype.ngControl;
    /**
     * @type {?}
     * @private
     */
    NxInputDirective.prototype._parentForm;
    /**
     * @type {?}
     * @private
     */
    NxInputDirective.prototype._parentFormGroup;
    /**
     * @type {?}
     * @private
     */
    NxInputDirective.prototype._errorStateMatcher;
    /**
     * @type {?}
     * @private
     */
    NxInputDirective.prototype._autofillMonitor;
}
export { ɵ0 };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5wdXQuZGlyZWN0aXZlLmpzIiwic291cmNlUm9vdCI6Im5nOi8vQGFsbGlhbnovbmd4LW5kYngvaW5wdXQvIiwic291cmNlcyI6WyJpbnB1dC5kaXJlY3RpdmUudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQSxPQUFPLEVBQUUscUJBQXFCLEVBQUUsTUFBTSx1QkFBdUIsQ0FBQztBQUM5RCxPQUFPLEVBQUUsc0JBQXNCLEVBQUUsUUFBUSxFQUFFLE1BQU0sdUJBQXVCLENBQUM7QUFDekUsT0FBTyxFQUNMLE1BQU0sRUFDTixTQUFTLEVBRVQsVUFBVSxFQUNWLEtBQUssRUFHTCxRQUFRLEVBQ1IsSUFBSSxFQUNKLGNBQWMsRUFFZixNQUFNLGVBQWUsQ0FBQztBQUN2QixPQUFPLEVBQWUsa0JBQWtCLEVBQUUsU0FBUyxFQUFFLE1BQU0sRUFBRSxNQUFNLGdCQUFnQixDQUFDO0FBQ3BGLE9BQU8sRUFBRSxPQUFPLEVBQUUsTUFBTSxNQUFNLENBQUM7QUFDL0IsT0FBTyxFQUFFLGVBQWUsRUFBRSxNQUFNLHlCQUF5QixDQUFDO0FBRTFELE9BQU8sRUFBRSxrQkFBa0IsRUFBRSxNQUFNLDZCQUE2QixDQUFDO0FBQ2pFLE9BQU8sRUFBRSxpQkFBaUIsRUFBRSxNQUFNLHlCQUF5QixDQUFDOztBQUU1RCxNQUFNLEtBQU8sdUJBQXVCLEdBQUcsSUFBSSxjQUFjLENBQWUseUJBQXlCLENBQUM7O0lBRTVGLGFBQWEsR0FBRztJQUNwQixRQUFRO0lBQ1IsVUFBVTtJQUNWLE1BQU07SUFDTixRQUFRO0lBQ1IsT0FBTztJQUNQLE9BQU87SUFDUCxPQUFPO0lBQ1AsT0FBTztJQUNQLFFBQVE7Q0FDVDs7Ozs7QUFTUSxVQUFBLENBQUMsSUFBSSxPQUFBLHNCQUFzQixFQUFFLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxFQUEvQixDQUErQjs7SUFQdkMsV0FBVyxHQUFHO0lBQ2xCLE1BQU07SUFDTixVQUFVO0lBQ1YsZ0JBQWdCO0lBQ2hCLE9BQU87SUFDUCxN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QUFFLENBQUMsRUFBQyxPQUFPLEVBQUUsa0JBQWtCLEVBQUUsV0FBVyxFQUFFLGdCQUFnQixFQUFDLENBQUM7aUJBQzFFOzs7O2dCQWhFQyxVQUFVO2dCQUxxQixRQUFRO2dCQWNDLFNBQVMsdUJBNEs5QyxRQUFRLFlBQUksSUFBSTtnQkE1S2dDLE1BQU0sdUJBNkt0RCxRQUFRO2dCQTdLUyxrQkFBa0IsdUJBOEtuQyxRQUFRO2dCQXpLSixpQkFBaUI7Z0RBMktyQixRQUFRLFlBQUksSUFBSSxZQUFJLE1BQU0sU0FBQyx1QkFBdUI7Z0JBOUs5QyxlQUFlOzs7NkJBb0VyQixLQUFLLFNBQUMsYUFBYTtxQkF1Qm5CLEtBQUs7d0JBU0wsS0FBSzsyQkFTTCxLQUFLOzJCQVFMLEtBQUs7MkJBbUJMLEtBQUs7dUJBS0wsS0FBSzs4QkFpQkwsS0FBSzs7SUEySlIsdUJBQUM7Q0FBQSxBQTNSRCxJQTJSQztTQW5RWSxnQkFBZ0I7Ozs7OztJQUUzQixpQ0FBeUI7Ozs7O0lBRXpCLCtCQUFzQjs7Ozs7SUFDdEIsZ0NBQThDOzs7OztJQUM5QyxnREFBb0M7Ozs7O0lBQ3BDLHFDQUE0Qjs7Ozs7SUFDNUIscUNBQTRCOzs7OztJQUM1QixxQ0FBbUM7Ozs7O0lBQ25DLCtDQUEwQzs7SUFDMUMsNENBQWdDOzs7OztJQUNoQyx3Q0FBNkI7O0lBRTdCLHNDQUF5Qzs7Ozs7SUFHekMsc0NBQTRCOzs7Ozs7SUFNNUIsdUNBQWlDOzs7OztJQUtqQyxzQ0FBbUI7Ozs7O0lBR25CLHdDQUFtQzs7Ozs7SUFHbkMsbUNBQWdCOzs7OztJQStFZCx1Q0FBaUM7Ozs7O0lBQ2pDLHFDQUE2Qjs7Ozs7SUFFN0IscUNBQStDOzs7OztJQUMvQyx1Q0FBdUM7Ozs7O0lBQ3ZDLDRDQUF3RDs7Ozs7SUFDeEQsOENBQTZDOzs7OztJQUU3Qyw0Q0FBeUMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBjb2VyY2VCb29sZWFuUHJvcGVydHkgfSBmcm9tICdAYW5ndWxhci9jZGsvY29lcmNpb24nO1xuaW1wb3J0IHsgZ2V0U3VwcG9ydGVkSW5wdXRUeXBlcywgUGxhdGZvcm0gfSBmcm9tICdAYW5ndWxhci9jZGsvcGxhdGZvcm0nO1xuaW1wb3J0IHtcbiAgSW5qZWN0LFxuICBEaXJlY3RpdmUsXG4gIERvQ2hlY2ssXG4gIEVsZW1lbnRSZWYsXG4gIElucHV0LFxuICBPbkNoYW5nZXMsXG4gIE9uRGVzdHJveSxcbiAgT3B0aW9uYWwsXG4gIFNlbGYsXG4gIEluamVjdGlvblRva2VuLFxuICBPbkluaXRcbn0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBGb3JtQ29udHJvbCwgRm9ybUdyb3VwRGlyZWN0aXZlLCBOZ0NvbnRyb2wsIE5nRm9ybSB9IGZyb20gJ0Bhbmd1bGFyL2Zvcm1zJztcbmltcG9ydCB7IFN1YmplY3QgfSBmcm9tICdyeGpzJztcbmltcG9ydCB7IEF1dG9maWxsTW9uaXRvciB9IGZyb20gJ0Bhbmd1bGFyL2Nkay90ZXh0LWZpZWxkJztcblxuaW1wb3J0IHsgTnhGb3JtZmllbGRDb250cm9sIH0gZnJvbSAnQGFsbGlhbnovbmd4LW5kYngvZm9ybWZpZWxkJztcbmltcG9ydCB7IEVycm9yU3RhdGVNYXRjaGVyIH0gZnJvbSAnQGFsbGlhbnovbmd4LW5kYngvdXRpbHMnO1xuXG5leHBvcnQgY29uc3QgTlhfSU5QVVRfVkFMVUVfQUNDRVNTT1IgPSBuZXcgSW5qZWN0aW9uVG9rZW48e3ZhbHVlOiBhbnl9PignTlhfSU5QVVRfVkFMVUVfQUNDRVNTT1InKTtcblxuY29uc3QgSU5WQUxJRF9UWVBFUyA9IFtcbiAgJ2J1dHRvbicsXG4gICdjaGVja2JveCcsXG4gICdmaWxlJyxcbiAgJ2hpZGRlbicsXG4gICdpbWFnZScsXG4gICdyYWRpbycsXG4gICdyYW5nZScsXG4gICdyZXNldCcsXG4gICdzdWJtaXQnXG5dO1xuXG5jb25zdCBORVZFUl9FTVBUWSA9IFtcbiAgJ2RhdGUnLFxuICAnZGF0ZXRpbWUnLFxuICAnZGF0ZXRpbWUtbG9jYWwnLFxuICAnbW9udGgnLFxuICAndGltZScsXG4gICd3ZWVrJ1xuXS5maWx0ZXIodCA9PiBnZXRTdXBwb3J0ZWRJbnB1dFR5cGVzKCkuaGFzKHQpKTtcblxubGV0IG5leHRVbmlxdWVJZCA9IDA7XG5cbkBEaXJlY3RpdmUoe1xuICBzZWxlY3RvcjogJ2lucHV0W254SW5wdXRdLCB0ZXh0YXJlYVtueElucHV0XSwgc2VsZWN0W254SW5wdXRdJyxcbiAgZXhwb3J0QXM6ICdueElucHV0JyxcbiAgaG9zdDoge1xuICAgICdbY2xhc3MuYy1pbnB1dF0nOiAndHJ1ZScsXG4gICAgJ1thdHRyLmlkXSc6ICdpZCcsXG4gICAgJ1tjbGFzcy5pcy1maWxsZWRdJzogJ2VtcHR5ID09PSBmYWxzZScsXG4gICAgJ1tjbGFzcy5pcy1kaXNhYmxlZF0nOiAnZGlzYWJsZWQnLFxuICAgICdbY2xhc3MuaGFzLWVycm9yXSc6ICdlcnJvclN0YXRlJyxcbiAgICAnW2NsYXNzLmlzLWZvY3VzZWRdJzogJ2ZvY3VzZWQnLFxuICAgICdbYXR0ci5kaXNhYmxlZF0nOiAnZGlzYWJsZWQgfHwgbnVsbCcsXG4gICAgJ1thdHRyLnJlYWRvbmx5XSc6ICdyZWFkb25seSB8fCBudWxsJyxcbiAgICAnW2F0dHIucmVxdWlyZWRdJzogJ3JlcXVpcmVkIHx8IG51bGwnLFxuICAgICdbYXR0ci5hcmlhLWxhYmVsXSc6ICdfYXJpYUxhYmVsIHx8IG51bGwnLFxuICAgICdbYXR0ci5hcmlhLWRlc2NyaWJlZGJ5XSc6ICdfYXJpYURlc2NyaWJlZGJ5IHx8IG51bGwnLFxuICAgICdbYXR0ci5hcmlhLWludmFsaWRdJzogJ2Vycm9yU3RhdGUnLFxuICAgICdbYXR0ci5hcmlhLXJlcXVpcmVkXSc6ICdyZXF1aXJlZC50b1N0cmluZygpJyxcbiAgICAnW2F0dHIucGxhY2Vob2xkZXJdJzogJ3BsYWNlaG9sZGVyIHx8IG51bGwnLFxuICAgICcoYmx1ciknOiAnX2ZvY3VzQ2hhbmdlZChmYWxzZSknLFxuICAgICcoZm9jdXMpJzogJ19mb2N1c0NoYW5nZWQodHJ1ZSknLFxuICAgICcoaW5wdXQpJzogJ19vbklucHV0KCknLFxuICB9LFxuICBwcm92aWRlcnM6IFt7cHJvdmlkZTogTnhGb3JtZmllbGRDb250cm9sLCB1c2VFeGlzdGluZzogTnhJbnB1dERpcmVjdGl2ZX1dLFxufSlcbmV4cG9ydCBjbGFzcyBOeElucHV0RGlyZWN0aXZlIGltcGxlbWVudHMgT25Jbml0LCBEb0NoZWNrLCBPbkNoYW5nZXMsIE9uRGVzdHJveSwgTnhGb3JtZmllbGRDb250cm9sPGFueT4ge1xuXG4gIHByb3RlY3RlZCBfdHlwZSA9ICd0ZXh0JztcblxuICBwcm90ZWN0ZWQgX2lkOiBzdHJpbmc7XG4gIHByb3RlY3RlZCBfdWlkID0gYG54LWlucHV0LSR7bmV4dFVuaXF1ZUlkKyt9YDtcbiAgcHJvdGVjdGVkIF9wcmV2aW91c05hdGl2ZVZhbHVlOiBhbnk7XG4gIHByb3RlY3RlZCBfZGlzYWJsZWQgPSBmYWxzZTtcbiAgcHJvdGVjdGVkIF9yZXF1aXJlZCA9IGZhbHNlO1xuICBwcml2YXRlIF9yZWFkb25seTogYm9vbGVhbiA9IGZhbHNlO1xuICBwcml2YXRlIF9pbnB1dFZhbHVlQWNjZXNzb3I6IHt2YWx1ZTogYW55fTtcbiAgcHVibGljIF9hcmlhRGVzY3JpYmVkYnk6IHN0cmluZztcbiAgcHJpdmF0ZSBfcGxhY2Vob2xkZXI6IHN0cmluZztcblxuICBASW5wdXQoJ254QXJpYUxhYmVsJykgX2FyaWFMYWJlbDogc3RyaW5nO1xuXG4gIC8qKiBAZG9jcy1wcml2YXRlICovXG4gIGVycm9yU3RhdGU6IGJvb2xlYW4gPSBmYWxzZTtcblxuICAvKipcbiAgICogTmFtZSBvZiB0aGlzIGNvbnRyb2wgdGhhdCBpcyB1c2VkIGluc2lkZSB0aGUgZm9ybWZpZWxkIGNvbXBvbmVudFxuICAgKiBAZG9jcy1wcml2YXRlXG4gICAqL1xuICBjb250cm9sVHlwZTogc3RyaW5nID0gJ254LWlucHV0JztcblxuICAvKipcbiAgKiBAZG9jcy1wcml2YXRlXG4gICovXG4gIGF1dG9maWxsZWQgPSBmYWxzZTtcblxuICAvKiogQGRvY3MtcHJpdmF0ZSAqL1xuICBzdGF0ZUNoYW5nZXMgPSBuZXcgU3ViamVjdDx2b2lkPigpO1xuXG4gIC8qKiBAZG9jcy1wcml2YXRlICovXG4gIGZvY3VzZWQgPSBmYWxzZTtcblxuICAvKiogVGhlIGlkIG9mIHRoZSBpbnB1dC4gKi9cbiAgQElucHV0KClcbiAgZ2V0IGlkKCkge1xuICAgIHJldHVybiB0aGlzLl9pZDtcbiAgfVxuICBzZXQgaWQodmFsdWU6IHN0cmluZykge1xuICAgIHRoaXMuX2lkID0gdmFsdWUgfHwgdGhpcy5fdWlkO1xuICB9XG5cbiAgLyoqIFRoZSBpbnB1dCBlbGVtZW50J3MgdmFsdWUuICovXG4gIEBJbnB1dCgpXG4gIGdldCB2YWx1ZSgpOiBhbnkgeyByZXR1cm4gdGhpcy5faW5wdXRWYWx1ZUFjY2Vzc29yLnZhbHVlOyB9XG4gIHNldCB2YWx1ZSh2YWx1ZTogYW55KSB7XG4gICAgaWYgKHZhbHVlICE9PSB0aGlzLnZhbHVlKSB7XG4gICAgICB0aGlzLl9pbnB1dFZhbHVlQWNjZXNzb3IudmFsdWUgPSB2YWx1ZTtcbiAgICB9XG4gIH1cblxuICAvKiogV2hldGhlciB0aGUgZWxlbWVudCBpcyByZWFkb25seS4gKi9cbiAgQElucHV0KClcbiAgZ2V0IHJlYWRvbmx5KCk6IGJvb2xlYW4geyByZXR1cm4gdGhpcy5fcmVhZG9ubHk7IH1cbiAgc2V0IHJlYWRvbmx5KHZhbHVlOiBib29sZWFuKSB7XG4gICAgdGhpcy5fcmVhZG9ubHkgPSBjb2VyY2VCb29sZWFuUHJvcGVydHkodmFsdWUpO1xuICAgIHRoaXMuc3RhdGVDaGFuZ2VzLm5leHQoKTtcbiAgfVxuXG4gIC8qKiBXaGV0aGVyIHRoZSBpbnB1dCBpcyBkaXNhYmxlZC4gKi9cbiAgQElucHV0KClcbiAgZ2V0IGRpc2FibGVkKCk6IGJvb2xlYW4ge1xuICAgIGlmICh0aGlzLm5nQ29udHJvbCAmJiB0aGlzLm5nQ29udHJvbC5kaXNhYmxlZCAhPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIHRoaXMubmdDb250cm9sLmRpc2FibGVkO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fZGlzYWJsZWQ7XG4gIH1cbiAgc2V0IGRpc2FibGVkKHZhbHVlOiBib29sZWFuKSB7XG4gICAgdGhpcy5fZGlzYWJsZWQgPSBjb2VyY2VCb29sZWFuUHJvcGVydHkodmFsdWUpO1xuXG4gICAgLy8gQnJvd3NlcnMgbWF5IG5vdCBmaXJlIHRoZSBibHVyIGV2ZW50IGlmIHRoZSBpbnB1dCBpcyBkaXNhYmxlZCB0b28gcXVpY2tseS5cbiAgICAvLyBSZXNldCBmcm9tIGhlcmUgdG8gZW5zdXJlIHRoYXQgdGhlIGVsZW1lbnQgZG9lc24ndCBiZWNvbWUgc3R1Y2suXG4gICAgaWYgKHRoaXMuZm9jdXNlZCkge1xuICAgICAgdGhpcy5mb2N1c2VkID0gZmFsc2U7XG4gICAgICB0aGlzLnN0YXRlQ2hhbmdlcy5uZXh0KCk7XG4gICAgfVxuICB9XG5cbiAgLyoqIFdoZXRoZXIgdGhlIGVsZW1lbnQgaXMgcmVxdWlyZWQuICovXG4gIEBJbnB1dCgpXG4gIGdldCByZXF1aXJlZCgpIHsgcmV0dXJuIHRoaXMuX3JlcXVpcmVkOyB9XG4gIHNldCByZXF1aXJlZCh2YWx1ZTogYW55KSB7IHRoaXMuX3JlcXVpcmVkID0gY29lcmNlQm9vbGVhblByb3BlcnR5KHZhbHVlKTsgfVxuXG4gIC8qKiBTZXRzIHRoZSB0eXBlIG9mIHRoZSBpbnB1dCBlbGVtZW50IChlLmcuIHBhc3N3b3JkLCB0ZXh0IGV0YykuICovXG4gIEBJbnB1dCgpXG4gIGdldCB0eXBlKCkgeyByZXR1cm4gdGhpcy5fdHlwZTsgfVxuICBzZXQgdHlwZSh2YWx1ZTogc3RyaW5nKSB7XG4gICAgdGhpcy5fdHlwZSA9IHZhbHVlIHx8ICd0ZXh0JztcbiAgICB0aGlzLl92YWxpZGF0ZVR5cGUoKTtcblxuICAgIC8vIFdoZW4gdXNpbmcgQW5ndWxhciBpbnB1dHMsIGRldmVsb3BlcnMgYXJlIG5vIGxvbmdlciBhYmxlIHRvIHNldCB0aGUgcHJvcGVydGllcyBvbiB0aGUgbmF0aXZlXG4gICAgLy8gaW5wdXQgZWxlbWVudC4gVG8gZW5zdXJlIHRoYXQgYmluZGluZ3MgZm9yIGB0eXBlYCB3b3JrLCB3ZSBuZWVkIHRvIHN5bmMgdGhlIHNldHRlclxuICAgIC8vIHdpdGggdGhlIG5hdGl2ZSBwcm9wZXJ0eS4gVGV4dGFyZWEgZWxlbWVudHMgZG9uJ3Qgc3VwcG9ydCB0aGUgdHlwZSBwcm9wZXJ0eSBvciBhdHRyaWJ1dGUuXG4gICAgaWYgKCF0aGlzLl9pc1RleHRhcmVhKCkgJiYgZ2V0U3VwcG9ydGVkSW5wdXRUeXBlcygpLmhhcyh0aGlzLl90eXBlKSkge1xuICAgICAgdGhpcy5fZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50LnR5cGUgPSB0aGlzLl90eXBlO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIHRoZSB0ZXh0IGZvciB0aGUgaW5wdXQgcGxhY2Vob2xkZXJcbiAgICovXG4gIEBJbnB1dCgpXG4gIGdldCBwbGFjZWhvbGRlcigpIHtcbiAgICByZXR1cm4gdGhpcy5lbXB0eSA/IHRoaXMuX3BsYWNlaG9sZGVyIDogJyc7XG4gIH1cbiAgc2V0IHBsYWNlaG9sZGVyKHZhbHVlOiBzdHJpbmcpIHtcbiAgICB0aGlzLl9wbGFjZWhvbGRlciA9IHZhbHVlO1xuICB9XG5cbiAgY29uc3RydWN0b3IoXG4gICAgcHJvdGVjdGVkIF9lbGVtZW50UmVmOiBFbGVtZW50UmVmLFxuICAgIHByb3RlY3RlZCBfcGxhdGZvcm06IFBsYXRmb3JtLFxuICAgIC8qKiBAZG9jcy1wcml2YXRlICovXG4gICAgQE9wdGlvbmFsKCkgQFNlbGYoKSBwdWJsaWMgbmdDb250cm9sOiBOZ0NvbnRyb2wsXG4gICAgQE9wdGlvbmFsKCkgcHJpdmF0ZSBfcGFyZW50Rm9ybTogTmdGb3JtLFxuICAgIEBPcHRpb25hbCgpIHByaXZhdGUgX3BhcmVudEZvcm1Hcm91cDogRm9ybUdyb3VwRGlyZWN0aXZlLFxuICAgIHByaXZhdGUgX2Vycm9yU3RhdGVNYXRjaGVyOiBFcnJvclN0YXRlTWF0Y2hlcixcbiAgICBAT3B0aW9uYWwoKSBAU2VsZigpIEBJbmplY3QoTlhfSU5QVVRfVkFMVUVfQUNDRVNTT1IpIGlucHV0VmFsdWVBY2Nlc3NvcjogYW55LFxuICAgIHByaXZhdGUgX2F1dG9maWxsTW9uaXRvcjogQXV0b2ZpbGxNb25pdG9yLFxuICApIHtcbiAgICB0aGlzLmlkID0gdGhpcy5pZDtcblxuICAgIC8vIFRoaXMgd2lsbCBlbmFibGUgb3RoZXIgZGlyZWN0aXZlcyB0byBwbHVnaW4gaXRzZWxmIGFzIHRoZSB2YWx1ZSBhY2Nlc3NvclxuICAgIC8vIGJ5IHVzaW5nIHRoZSBOWF9JTlBVVF9WQUxVRV9BQ0NFU1NPUiBUb2tlbi4gRGVmYXVsdCBpcyB0aGUgZ2l2ZW4gaW5wdXQgZmllbGQuXG4gICAgLy8gVE9ETyBlbGltaW5hdGUgaW5qZWN0ZWQgZGF0ZVZhbHVlQWNjZXNzb3Igb25jZSB3ZSBoYXZlIGludHJhLXBhY2thZ2Ugc3VwcG9ydCBpbiBuZy1wYWNrYWdyXG4gICAgLy8gU2VlIHRoZSBkYXRlZmllbGQgZm9yIGRldGFpbHMuXG4gICAgdGhpcy5faW5wdXRWYWx1ZUFjY2Vzc29yID0gaW5wdXRWYWx1ZUFjY2Vzc29yIHx8IHRoaXMuX2VsZW1lbnRSZWYubmF0aXZlRWxlbWVudDtcbiAgICB0aGlzLl9wcmV2aW91c05hdGl2ZVZhbHVlID0gdGhpcy52YWx1ZTtcblxuICAgIGlmICh0aGlzLl9lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gJ3RleHRhcmVhJykge1xuICAgICAgdGhpcy5jb250cm9sVHlwZSA9ICd0ZXh0YXJlYSc7XG4gICAgfVxuICB9XG5cbiAgbmdPbkluaXQoKSB7XG4gICAgaWYgKHRoaXMuX3BsYXRmb3JtLmlzQnJvd3Nlcikge1xuICAgICAgdGhpcy5fYXV0b2ZpbGxNb25pdG9yLm1vbml0b3IodGhpcy5fZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50KS5zdWJzY3JpYmUoZXZlbnQgPT4ge1xuICAgICAgICB0aGlzLmF1dG9maWxsZWQgPSBldmVudC5pc0F1dG9maWxsZWQ7XG4gICAgICAgIHRoaXMuc3RhdGVDaGFuZ2VzLm5leHQoKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIC8qKiBAZG9jcy1wcml2YXRlICovXG4gIGdldCBlbGVtZW50UmVmKCk6IEVsZW1lbnRSZWYge1xuICAgIHJldHVybiB0aGlzLl9lbGVtZW50UmVmO1xuICB9XG5cbiAgX29uSW5wdXQoKSB7XG4gICAgLy8gZm9yY2UgdG8gdG8gcnVuIGNoYW5nZSBkZXRlY3Rpb24gc28gd2Uga25vdyBhYm91dCBjaGFuZ2VzIGluIHRoZSBuYXRpdmUgZm9ybSBpbnB1dFxuICB9XG5cbiAgX2ZvY3VzQ2hhbmdlZChpc0ZvY3VzZWQ6IGJvb2xlYW4pIHtcbiAgICBpZiAoaXNGb2N1c2VkICE9PSB0aGlzLmZvY3VzZWQgJiYgIXRoaXMucmVhZG9ubHkpIHtcbiAgICAgIHRoaXMuZm9jdXNlZCA9IGlzRm9jdXNlZDtcbiAgICAgIHRoaXMuc3RhdGVDaGFuZ2VzLm5leHQoKTtcbiAgICB9XG4gIH1cblxuICBuZ09uQ2hhbmdlcygpIHtcbiAgICB0aGlzLnN0YXRlQ2hhbmdlcy5uZXh0KCk7XG4gIH1cblxuICBuZ09uRGVzdHJveSgpIHtcbiAgICB0aGlzLnN0YXRlQ2hhbmdlcy5jb21wbGV0ZSgpO1xuXG4gICAgaWYgKHRoaXMuX3BsYXRmb3JtLmlzQnJvd3Nlcikge1xuICAgICAgdGhpcy5fYXV0b2ZpbGxNb25pdG9yLnN0b3BNb25pdG9yaW5nKHRoaXMuX2VsZW1lbnRSZWYubmF0aXZlRWxlbWVudCk7XG4gICAgfVxuICB9XG5cbiAgbmdEb0NoZWNrKCkge1xuICAgIGlmICh0aGlzLm5nQ29udHJvbCkge1xuICAgICAgLy8gV2UgbmVlZCB0byByZS1ldmFsdWF0ZSB0aGlzIG9uIGV2ZXJ5IGNoYW5nZSBkZXRlY3Rpb24gY3ljbGUsIGJlY2F1c2UgdGhlcmUgYXJlIHNvbWVcbiAgICAgIC8vIGVycm9yIHRyaWdnZXJzIHRoYXQgd2UgY2FuJ3Qgc3Vic2NyaWJlIHRvIChlLmcuIHBhcmVudCBmb3JtIHN1Ym1pc3Npb25zKS4gVGhpcyBtZWFuc1xuICAgICAgLy8gdGhhdCB3aGF0ZXZlciBsb2dpYyBpcyBpbiBoZXJlIGhhcyB0byBiZSBzdXBlciBsZWFuIG9yIHdlIHJpc2sgZGVzdHJveWluZyB0aGUgcGVyZm9ybWFuY2UuXG4gICAgICB0aGlzLnVwZGF0ZUVycm9yU3RhdGUoKTtcbiAgICB9XG5cbiAgICAvLyBXZSBuZWVkIHRvIGRpcnR5LWNoZWNrIHRoZSBuYXRpdmUgZWxlbWVudCdzIHZhbHVlLCBiZWNhdXNlIHRoZXJlIGFyZSBzb21lIGNhc2VzIHdoZXJlXG4gICAgLy8gd2Ugd29uJ3QgYmUgbm90aWZpZWQgd2hlbiBpdCBjaGFuZ2VzIChlLmcuIHRoZSBjb25zdW1lciBpc24ndCB1c2luZyBmb3JtcyBvciB0aGV5J3JlXG4gICAgLy8gdXBkYXRpbmcgdGhlIHZhbHVlIHVzaW5nIGBlbWl0RXZlbnQ6IGZhbHNlYCkuXG4gICAgdGhpcy5fZGlydHlDaGVja05hdGl2ZVZhbHVlKCk7XG4gIH1cblxuICAvKiogQGRvY3MtcHJpdmF0ZSAqL1xuICB1cGRhdGVFcnJvclN0YXRlKCkge1xuICAgIGNvbnN0IG9sZFN0YXRlID0gdGhpcy5lcnJvclN0YXRlO1xuICAgIGNvbnN0IHBhcmVudCA9IHRoaXMuX3BhcmVudEZvcm1Hcm91cCB8fCB0aGlzLl9wYXJlbnRGb3JtO1xuICAgIGNvbnN0IGNvbnRyb2wgPSB0aGlzLm5nQ29udHJvbCA/IHRoaXMubmdDb250cm9sLmNvbnRyb2wgYXMgRm9ybUNvbnRyb2wgOiBudWxsO1xuICAgIGNvbnN0IG5ld1N0YXRlID0gdGhpcy5fZXJyb3JTdGF0ZU1hdGNoZXIuaXNFcnJvclN0YXRlKGNvbnRyb2wsIHBhcmVudCk7XG5cbiAgICBpZiAobmV3U3RhdGUgIT09IG9sZFN0YXRlKSB7XG4gICAgICB0aGlzLmVycm9yU3RhdGUgPSBuZXdTdGF0ZTtcbiAgICAgIHRoaXMuc3RhdGVDaGFuZ2VzLm5leHQoKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogU2V0IGEgbGlzdCBvZiBpZHMgdGhhdCBpcyBjdXJyZW50bHkgZGVzY3JpYmluZyB0aGlzIGlucHV0XG4gICAqIChpZiB5b3UgaGF2ZSBoaW50cyBhbmQgZXJyb3JzIGZvciBleGFtcGxlKS5cbiAgICovXG4gIHNldERlc2NyaWJlZEJ5SWRzKGlkczogc3RyaW5nW10pIHtcbiAgICB0aGlzLl9hcmlhRGVzY3JpYmVkYnkgPSBpZHMuam9pbignICcpO1xuICB9XG5cbiAgLy8gYWxsb3cgdG8gc2V0IGEgYXJpYWwgbGFiZWwgdmFsdWUgaW4gY2FzZSB0aGVyZVxuICAvLyBpcyBub3QgcG9zc2liaWxpdHkgdG8gZGlzcGxheSBhIHByb3BlciBsYWJlbFxuICAvKipcbiAgICogTWV0aG9kIHRvIHNldCB0aGUgYXJpYSBsYWJlbC5cbiAgICogVGhpcyBpcyByZXF1aXJlZCBpZiB5b3UgdXNlIHRoZSBpbnB1dCBvdXRzaWRlIG9mIGEgZm9ybWZpZWxkXG4gICAqIHdoZXJlIHlvdSBkb24ndCBoYXZlIGEgbGFiZWwgY29ubmVjdGVkLlxuICAgKi9cbiAgc2V0QXJpYUxhYmVsKHZhbHVlOiBzdHJpbmcpIHtcbiAgICB0aGlzLl9hcmlhTGFiZWwgPSB2YWx1ZTtcbiAgfVxuXG4gIHByb3RlY3RlZCBfaXNCYWRJbnB1dCgpIHtcbiAgICAvLyBUaGUgYHZhbGlkaXR5YCBwcm9wZXJ0eSB3b24ndCBiZSBwcmVzZW50IG9uIHBsYXRmb3JtLXNlcnZlci5cbiAgICBjb25zdCB2YWxpZGl0eSA9ICh0aGlzLl9lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQgYXMgSFRNTElucHV0RWxlbWVudCkudmFsaWRpdHk7XG4gICAgcmV0dXJuIHZhbGlkaXR5ICYmIHZhbGlkaXR5LmJhZElucHV0O1xuICB9XG5cbiAgLyoqIEBkb2NzLXByaXZhdGUgKi9cbiAgZ2V0IGVtcHR5KCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiAhdGhpcy5faXNOZXZlckVtcHR5KCkgJiYgIXRoaXMuX2VsZW1lbnRSZWYubmF0aXZlRWxlbWVudC52YWx1ZSAmJiAhdGhpcy5faXNCYWRJbnB1dCgpICYmICF0aGlzLmF1dG9maWxsZWQ7XG4gIH1cblxuICBwcm90ZWN0ZWQgX2lzTmV2ZXJFbXB0eSgpIHtcbiAgICByZXR1cm4gTkVWRVJfRU1QVFkuaW5kZXhPZih0aGlzLl90eXBlKSA+IC0xO1xuICB9XG5cbiAgcHJvdGVjdGVkIF9pc1RleHRhcmVhKCkge1xuICAgIGNvbnN0IG5hdGl2ZUVsZW1lbnQgPSB0aGlzLl9lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQ7XG4gICAgcmV0dXJuIG5hdGl2ZUVsZW1lbnQubm9kZU5hbWUgPyBuYXRpdmVFbGVtZW50Lm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT09ICd0ZXh0YXJlYScgOiBmYWxzZTtcbiAgfVxuXG4gIHByb3RlY3RlZCBfdmFsaWRhdGVUeXBlKCkge1xuICAgIGlmIChJTlZBTElEX1RZUEVTLmluZGV4T2YodGhpcy5fdHlwZSkgPiAtMSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnB1dCBvZiB0eXBlICcke3RoaXMuX3R5cGV9JyBpcyBub3Qgc3VwcG9ydGVkYCk7XG4gICAgfVxuICB9XG5cbiAgLyoqIEBkb2NzLXByaXZhdGUgKi9cbiAgZ2V0IHNob3VsZExhYmVsRmxvYXQoKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRoaXMuZm9jdXNlZCB8fCAhdGhpcy5lbXB0eSB8fCAodGhpcy5wbGFjZWhvbGRlciAmJiB0aGlzLnBsYWNlaG9sZGVyLmxlbmd0aCA+IDApO1xuICB9XG5cbiAgcHJvdGVjdGVkIF9kaXJ0eUNoZWNrTmF0aXZlVmFsdWUoKSB7XG4gICAgY29uc3QgbmV3VmFsdWUgPSB0aGlzLnZhbHVlO1xuXG4gICAgaWYgKHRoaXMuX3ByZXZpb3VzTmF0aXZlVmFsdWUgIT09IG5ld1ZhbHVlKSB7XG4gICAgICB0aGlzLl9wcmV2aW91c05hdGl2ZVZhbHVlID0gbmV3VmFsdWU7XG4gICAgICB0aGlzLnN0YXRlQ2hhbmdlcy5uZXh0KCk7XG4gICAgfVxuICB9XG59XG4iXX0=