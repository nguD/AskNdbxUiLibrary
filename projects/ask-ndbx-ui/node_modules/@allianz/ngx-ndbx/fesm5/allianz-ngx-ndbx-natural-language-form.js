import { NxPopoverModule } from '@allianz/ngx-ndbx/popover';
import { NxInputModule } from '@allianz/ngx-ndbx/input';
import { NxFormfieldControl, NxFormfieldErrorDirective } from '@allianz/ngx-ndbx/formfield';
import { getFontShorthand } from '@allianz/ngx-ndbx/utils';
import { OverlayConfig, Overlay, OverlayPositionBuilder } from '@angular/cdk/overlay';
import { Component, ChangeDetectionStrategy, ElementRef, ChangeDetectorRef, Renderer2, ViewContainerRef, ContentChild, ContentChildren, ViewChild, HostBinding, Input, HostListener, NgModule } from '@angular/core';
import { startWith, throttleTime, delay } from 'rxjs/operators';
import { Subscription, Subject, merge } from 'rxjs';
import { NxDropdownComponent } from '@allianz/ngx-ndbx/dropdown';
import { TemplatePortal } from '@angular/cdk/portal';
import { __spread } from 'tslib';
import { coerceBooleanProperty } from '@angular/cdk/coercion';
import { CommonModule } from '@angular/common';

/**
 * @fileoverview added by tsickle
 * Generated from: word.component.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var NxWordComponent = /** @class */ (function () {
    function NxWordComponent(elementRef, _changeDetectorRef, _renderer, _overlay, _viewContainerRef, _overlayPositionBuilder) {
        this.elementRef = elementRef;
        this._changeDetectorRef = _changeDetectorRef;
        this._renderer = _renderer;
        this._overlay = _overlay;
        this._viewContainerRef = _viewContainerRef;
        this._overlayPositionBuilder = _overlayPositionBuilder;
        this.subscription = Subscription.EMPTY;
        this.subscriptionValues = Subscription.EMPTY;
        /**
         * \@docs-private
         */
        this.inputChanges = new Subject();
        this._hasErrors = false;
        /**
         * \@docs-private
         */
        this.currentTextWidth = 0;
        // this will apply different min-widths to our component through our styles
        /**
         * Provide a hint for a minimal width. The actual size will be determined for inputs for each change.
         */
        this.size = 'regular';
    }
    /**
     * @return {?}
     */
    NxWordComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        this.setupErrorPopover();
    };
    /**
     * @return {?}
     */
    NxWordComponent.prototype.ngAfterContentInit = /**
     * @return {?}
     */
    function () {
        var _this = this;
        this._validateControlChild();
        this.subscription = this._control.stateChanges.pipe(startWith(null)).subscribe((/**
         * @return {?}
         */
        function () {
            _this._hasErrors = _this._control.errorState;
            _this.updateErrorPopoverState();
            _this._changeDetectorRef.markForCheck();
        }));
        // if we have a ngcontrol available stick to its valueChanges subject
        if (this._control.ngControl) {
            this.subscriptionValues = this._control.ngControl.valueChanges.subscribe((/**
             * @param {?} value
             * @return {?}
             */
            function (value) {
                _this.updateCurrentTextWidth();
                _this.inputChanges.next();
            }));
            // in any other case it is a bre input and input changes are signaled through simple state changes
        }
        else {
            this.subscriptionValues = this._control.stateChanges.subscribe((/**
             * @param {?} value
             * @return {?}
             */
            function (value) {
                _this.updateCurrentTextWidth();
                _this.inputChanges.next();
            }));
        }
        this._control.setAriaLabel(this.label);
    };
    /**
     * @return {?}
     */
    NxWordComponent.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        this.subscription.unsubscribe();
    };
    /**
      @docs-private
      Calculate the width of the full text given by the input,
      that value is bound to this component so it can grow.
  
      The involved input is known to have a width of 100% an will fit the additional space given
      which completes the auto growing behavior.
    */
    /**
     * \@docs-private
     * Calculate the width of the full text given by the input,
     * that value is bound to this component so it can grow.
     * The involved input is known to have a width of 100% an will fit the additional space given
     * which completes the auto growing behavior.
     * @return {?}
     */
    NxWordComponent.prototype.updateCurrentTextWidth = /**
     * \@docs-private
     * Calculate the width of the full text given by the input,
     * that value is bound to this component so it can grow.
     * The involved input is known to have a width of 100% an will fit the additional space given
     * which completes the auto growing behavior.
     * @return {?}
     */
    function () {
        // provide the canvas only lazy
        if (!this.measureCanvas) {
            this.measureCanvas = this._renderer.createElement('canvas');
        }
        /** @type {?} */
        var ctx = this.measureCanvas.getContext('2d');
        /** @type {?} */
        var inputRef = this._control.elementRef;
        /** @type {?} */
        var styles = window.getComputedStyle(inputRef.nativeElement);
        ctx.font = getFontShorthand(styles);
        /** @type {?} */
        var metrics = ctx.measureText(this._control.value);
        // add 1px (cursor width) to prevent jumping of the text on blur.
        /** @type {?} */
        var newWidth = metrics.width + parseInt(styles.paddingRight, 10) + parseInt(styles.paddingLeft, 10) + 1;
        // This should be injected via @Host to get an exact reference to NxNaturalLanguageFormComponent
        // Works as promised as long as there is not other tag around the word. Not expected but possible.
        /** @type {?} */
        var parent = this.elementRef.nativeElement.parentElement;
        /** @type {?} */
        var parentMeasurement = parent.getBoundingClientRect();
        // Limit to own given minimal width
        this.currentTextWidth = Math.max(parseInt(styles.minWidth, 10), newWidth);
        // Limit to container width
        this.currentTextWidth = Math.min(this.currentTextWidth, parentMeasurement.width);
        if (this._overlayRef.hasAttached()) {
            this._overlayState.positionStrategy.apply();
        }
    };
    /** @docs-private */
    /**
     * \@docs-private
     * @return {?}
     */
    NxWordComponent.prototype.repositionError = /**
     * \@docs-private
     * @return {?}
     */
    function () {
        if (this._overlayRef.hasAttached()) {
            this._overlayState.positionStrategy.apply();
        }
    };
    // Fail if the required control is missing.
    // Fail if the required control is missing.
    /**
     * @protected
     * @return {?}
     */
    NxWordComponent.prototype._validateControlChild = 
    // Fail if the required control is missing.
    /**
     * @protected
     * @return {?}
     */
    function () {
        if (!this._control) {
            throw new Error('NxWordComponent requires an NxFormfieldControl compatible input.');
        }
    };
    /** @docs-private */
    /**
     * \@docs-private
     * @return {?}
     */
    NxWordComponent.prototype.getConnectedOverlayOrigin = /**
     * \@docs-private
     * @return {?}
     */
    function () {
        return this.elementRef;
    };
    Object.defineProperty(NxWordComponent.prototype, "isFocused", {
        /** @docs-private */
        get: /**
         * \@docs-private
         * @return {?}
         */
        function () {
            return this._control.focused;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NxWordComponent.prototype, "isFilled", {
        /** @docs-private */
        get: /**
         * \@docs-private
         * @return {?}
         */
        function () {
            return !this._control.empty;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NxWordComponent.prototype, "hasDropdown", {
        /** @docs-private */
        get: /**
         * \@docs-private
         * @return {?}
         */
        function () {
            return Boolean(this._dropdown);
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @return {?}
     */
    NxWordComponent.prototype.updateErrorPopoverState = /**
     * @return {?}
     */
    function () {
        if (this._hasErrors && this._errorChildren.length > 0) {
            this.showPopover();
        }
        else {
            this.hidePopover();
        }
    };
    /**
     * @return {?}
     */
    NxWordComponent.prototype.setupErrorPopover = /**
     * @return {?}
     */
    function () {
        var _this = this;
        /** @type {?} */
        var positionStrategy = this._overlayPositionBuilder
            .flexibleConnectedTo(this.elementRef)
            .withLockedPosition(true)
            .withFlexibleDimensions(false)
            .withPush(true)
            .withPositions([{
                originX: 'center',
                originY: 'top',
                overlayX: 'center',
                overlayY: 'bottom'
            },
            {
                originX: 'center',
                originY: 'bottom',
                overlayX: 'center',
                overlayY: 'top'
            }])
            .withDefaultOffsetY(-8);
        this._overlayState = new OverlayConfig();
        this._overlayState.positionStrategy = positionStrategy;
        this._overlayState.scrollStrategy = this._overlay.scrollStrategies.reposition();
        this._overlayRef = this._overlay.create(this._overlayState);
        ((/** @type {?} */ (this._overlayState.positionStrategy))).positionChanges.subscribe((/**
         * @param {?} change
         * @return {?}
         */
        function (change) {
            /** @type {?} */
            var pair = change.connectionPair;
            _this.positionArrow(pair);
            // These position changes arrive too late,
            // We have to trigger the change detection manually
            // as it's detached from any render hierarchy
            // and only updated by the overlay when attached.
            if (_this._embeddedViewRef && !_this._embeddedViewRef.destroyed) {
                _this._embeddedViewRef.detectChanges();
            }
        }));
    };
    /**
     * @private
     * @param {?} pair
     * @return {?}
     */
    NxWordComponent.prototype.positionArrow = /**
     * @private
     * @param {?} pair
     * @return {?}
     */
    function (pair) {
        /** @type {?} */
        var parentElementPositionX = this.elementRef.nativeElement.getBoundingClientRect().left;
        /** @type {?} */
        var parentElementWidth = this.elementRef.nativeElement.getBoundingClientRect().width / 2;
        /** @type {?} */
        var parentElementLeftOffset = this._overlayRef.overlayElement.parentElement.offsetLeft;
        /** @type {?} */
        var overlayElementLeftOffset = this._overlayRef.overlayElement.offsetLeft;
        // calculation for x position of the parent element. In this case, overlay left offset is the one thing to consider.
        /** @type {?} */
        var targetPosition = (parentElementPositionX + parentElementWidth) - (parentElementLeftOffset + overlayElementLeftOffset);
        if (pair.originY === 'top' && pair.overlayY === 'bottom') {
            this._popover.direction = 'top';
        }
        else {
            this._popover.direction = 'bottom';
        }
        this._popover.arrowStyle = { left: targetPosition + 'px' };
    };
    /**
     * @return {?}
     */
    NxWordComponent.prototype.showPopover = /**
     * @return {?}
     */
    function () {
        if (!this._overlayRef.hasAttached()) {
            /** @type {?} */
            var tooltipPortal = new TemplatePortal(this._popover.templateRef, this._viewContainerRef);
            this._embeddedViewRef = this._overlayRef.attach(tooltipPortal);
        }
    };
    /**
     * @return {?}
     */
    NxWordComponent.prototype.hidePopover = /**
     * @return {?}
     */
    function () {
        this._overlayRef.detach();
    };
    NxWordComponent.decorators = [
        { type: Component, args: [{
                    selector: 'nx-word',
                    template: "<div>\n  <!-- We only allow formfield controls here -->\n  <div *ngIf=\"!hasDropdown\" class=\"nx-word__inner-wrapper\">\n    <ng-content select=\"[nxInput]\"></ng-content>\n  </div>\n  <ng-content select=\"nx-dropdown\"></ng-content>\n</div>\n\n<nx-popover #popover>\n  <ng-content select=\"[nxError]\"></ng-content>\n</nx-popover>",
                    host: {
                        '[class.size-short]': 'size == "short"',
                        '[class.size-regular]': 'size == "regular"',
                        '[class.size-long]': 'size == "long"',
                        '[class.has-error]': '_hasErrors',
                        '[class.is-focused]': 'isFocused',
                        '[class.is-filled]': 'isFilled',
                        '[class.has-dropdown]': 'hasDropdown',
                    },
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    styles: [":host{display:inline-block;position:relative;font-weight:400;text-align:center;-webkit-hyphens:none;-ms-hyphens:none;hyphens:none;width:100%;margin:0 4px}:host .nx-word__inner-wrapper{border-bottom:2px solid #d9d9d9}:host.size-short{min-width:80px}:host.size-regular{min-width:152px}:host.size-long{min-width:360px}@media (max-width:991px){:host.size-long{min-width:280px}}@media (max-width:703px){:host.size-long{min-width:248px}}:host ::ng-deep .c-input{display:inline-block;text-align:inherit;font-size:inherit;line-height:inherit;background:0 0;color:inherit;border:none;outline:0;margin:0;width:100%;max-width:100%;height:auto;box-shadow:none;padding:0 8px}:host ::ng-deep .c-input.is-focused{outline:0;box-shadow:none}:host ::ng-deep .c-input.is-filled,:host ::ng-deep .c-input.is-focused{color:#006192;color:var(--natural-language-form-active-color,#006192);font-weight:400}:host ::ng-deep .c-input.is-disabled{cursor:not-allowed}:host ::ng-deep .c-input::-ms-clear{display:none}:host ::ng-deep nx-dropdown{position:relative;border-bottom:2px solid #d9d9d9}:host ::ng-deep nx-dropdown .nx-dropdown__container{font-size:inherit;margin-bottom:-2px}:host ::ng-deep nx-dropdown.has-focus,:host ::ng-deep nx-dropdown.is-filled{color:#006192;color:var(--natural-language-form-active-color,#006192);border-color:#007ab3;border-color:var(--natural-language-form-active-border-color,#007ab3)}:host ::ng-deep nx-dropdown .nx-dropdown__icon{line-height:inherit}:host ::ng-deep .nx-word__input-wrapper{width:100%}:host(.is-filled) .nx-word__inner-wrapper,:host(.is-focused) .nx-word__inner-wrapper{border-color:#007ab3;border-color:var(--natural-language-form-active-border-color,#007ab3)}:host(.has-error) .nx-word__inner-wrapper{border-color:#dc3149;border-color:var(--natural-language-form-error-border-color,#dc3149)}:host.has-error ::ng-deep nx-dropdown{color:#dc3149;color:var(--natural-language-form-error-color,#dc3149);border-color:#dc3149;border-color:var(--natural-language-form-error-border-color,#dc3149)}:host.has-error ::ng-deep .c-input.has-error{color:#dc3149;color:var(--natural-language-form-error-color,#dc3149)}:host-context(.is-negative) ::ng-deep .nx-dropdown,:host-context(.is-negative) ::ng-deep nx-dropdown,:host-context(.is-negative) ::ng-deep nx-dropdown.is-filled{border-color:#fff;color:#fff}:host-context(.is-negative) ::ng-deep .c-input,:host-context(.is-negative) ::ng-deep .c-input.has-error{color:#fff}:host-context(.is-negative) .nx-word__inner-wrapper{border-color:#fff}.nx-word__inner-wrapper{height:52px;height:var(--natural-language-form-large-line-height,52px)}@media (max-width:991px){:host ::ng-deep nx-dropdown .nx-dropdown__container{font-size:26px}.nx-word__inner-wrapper{height:36px;height:var(--natural-language-form-small-line-height,36px)}}:host-context(.nx-natural-language-form--small) .nx-word__inner-wrapper{height:36px;height:var(--natural-language-form-small-line-height,36px)}@media screen and (-ms-high-contrast:active){.nx-word__inner-wrapper,::ng-deep nx-dropdown{border-bottom-color:buttonText}}"]
                }] }
    ];
    /** @nocollapse */
    NxWordComponent.ctorParameters = function () { return [
        { type: ElementRef },
        { type: ChangeDetectorRef },
        { type: Renderer2 },
        { type: Overlay },
        { type: ViewContainerRef },
        { type: OverlayPositionBuilder }
    ]; };
    NxWordComponent.propDecorators = {
        _control: [{ type: ContentChild, args: [NxFormfieldControl, { static: false },] }],
        _errorChildren: [{ type: ContentChildren, args: [NxFormfieldErrorDirective,] }],
        _popover: [{ type: ViewChild, args: ['popover', { static: true },] }],
        _dropdown: [{ type: ContentChild, args: [NxDropdownComponent, { static: false },] }],
        currentTextWidth: [{ type: HostBinding, args: ['style.width.px',] }],
        size: [{ type: Input, args: ['nxSize',] }],
        label: [{ type: Input, args: ['nxLabel',] }]
    };
    return NxWordComponent;
}());
if (false) {
    /**
     * @type {?}
     * @private
     */
    NxWordComponent.prototype.subscription;
    /**
     * @type {?}
     * @private
     */
    NxWordComponent.prototype.subscriptionValues;
    /**
     * @type {?}
     * @private
     */
    NxWordComponent.prototype.measureCanvas;
    /**
     * \@docs-private
     * @type {?}
     */
    NxWordComponent.prototype.inputChanges;
    /** @type {?} */
    NxWordComponent.prototype._hasErrors;
    /**
     * @type {?}
     * @private
     */
    NxWordComponent.prototype._overlayRef;
    /**
     * @type {?}
     * @private
     */
    NxWordComponent.prototype._embeddedViewRef;
    /**
     * @type {?}
     * @private
     */
    NxWordComponent.prototype._overlayState;
    /** @type {?} */
    NxWordComponent.prototype._control;
    /** @type {?} */
    NxWordComponent.prototype._errorChildren;
    /** @type {?} */
    NxWordComponent.prototype._popover;
    /** @type {?} */
    NxWordComponent.prototype._dropdown;
    /**
     * \@docs-private
     * @type {?}
     */
    NxWordComponent.prototype.currentTextWidth;
    /**
     * Provide a hint for a minimal width. The actual size will be determined for inputs for each change.
     * @type {?}
     */
    NxWordComponent.prototype.size;
    /**
     * A word doesn't have a set place to show labels.
     * In order to be accessible, you have to provide a label with this property.
     * It will be attached to the given input through `aria-label`.
     * @type {?}
     */
    NxWordComponent.prototype.label;
    /**
     * \@docs-private
     * @type {?}
     */
    NxWordComponent.prototype.elementRef;
    /**
     * @type {?}
     * @private
     */
    NxWordComponent.prototype._changeDetectorRef;
    /**
     * @type {?}
     * @private
     */
    NxWordComponent.prototype._renderer;
    /**
     * @type {?}
     * @private
     */
    NxWordComponent.prototype._overlay;
    /**
     * @type {?}
     * @private
     */
    NxWordComponent.prototype._viewContainerRef;
    /**
     * @type {?}
     * @private
     */
    NxWordComponent.prototype._overlayPositionBuilder;
}

/**
 * @fileoverview added by tsickle
 * Generated from: natural-language-form.component.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
var DEFAULT_SIZE = 'large';
var NxNaturalLanguageFormComponent = /** @class */ (function () {
    function NxNaturalLanguageFormComponent(_changeDetectorRef) {
        this._changeDetectorRef = _changeDetectorRef;
        this._negative = false;
        /**
         * \@docs-private
         */
        this.resizeEvent$ = new Subject();
        /**
         * \@docs-private
         */
        this.updatePopoversSubscription = Subscription.EMPTY;
        /**
         * \@docs-private
         */
        this._size = DEFAULT_SIZE;
    }
    Object.defineProperty(NxNaturalLanguageFormComponent.prototype, "negative", {
        get: /**
         * @return {?}
         */
        function () {
            return this._negative;
        },
        /** Whether the negative set of stylings should be used. */
        set: /**
         * Whether the negative set of stylings should be used.
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this._negative = coerceBooleanProperty(value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NxNaturalLanguageFormComponent.prototype, "size", {
        get: /**
         * @return {?}
         */
        function () {
            return this._size;
        },
        /**
         * Sets the size of the NLF. Default value: large
         */
        set: /**
         * Sets the size of the NLF. Default value: large
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this._size = value;
            this._changeDetectorRef.markForCheck();
        },
        enumerable: true,
        configurable: true
    });
    /** @docs-private */
    /**
     * \@docs-private
     * @param {?} event
     * @return {?}
     */
    NxNaturalLanguageFormComponent.prototype.onResize = /**
     * \@docs-private
     * @param {?} event
     * @return {?}
     */
    function (event) {
        this.resizeEvent$.next();
    };
    /**
     * @return {?}
     */
    NxNaturalLanguageFormComponent.prototype.ngAfterContentInit = /**
     * @return {?}
     */
    function () {
        var _this = this;
        // Collect all words and listen for changes so we can update any open error popover
        // which would otherwise get wrongly positioned.
        /** @type {?} */
        var subjects = this._words.map((/**
         * @param {?} word
         * @return {?}
         */
        function (word) { return word.inputChanges; }));
        /** @type {?} */
        var source = merge.apply(void 0, __spread(subjects));
        this.updatePopoversSubscription = source.subscribe((/**
         * @return {?}
         */
        function () {
            _this.updatePositionPopovers();
        }));
        this.resizeObservable = this.resizeEvent$.pipe(throttleTime(500), delay(100));
        this.resizeObservable.subscribe((/**
         * @return {?}
         */
        function () { return _this.resizeWords(); }));
    };
    /** @docs-private */
    /**
     * \@docs-private
     * @return {?}
     */
    NxNaturalLanguageFormComponent.prototype.resizeWords = /**
     * \@docs-private
     * @return {?}
     */
    function () {
        this._words.forEach((/**
         * @param {?} word
         * @return {?}
         */
        function (word) {
            word.updateCurrentTextWidth();
        }));
    };
    /**
     * @return {?}
     */
    NxNaturalLanguageFormComponent.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        this.updatePopoversSubscription.unsubscribe();
    };
    /** @docs-private */
    /**
     * \@docs-private
     * @return {?}
     */
    NxNaturalLanguageFormComponent.prototype.updatePositionPopovers = /**
     * \@docs-private
     * @return {?}
     */
    function () {
        if (this._words) {
            this._words.forEach((/**
             * @param {?} word
             * @return {?}
             */
            function (word) {
                word.repositionError();
            }));
        }
    };
    NxNaturalLanguageFormComponent.decorators = [
        { type: Component, args: [{
                    selector: 'nx-natural-language-form',
                    template: "<div class=\"nx-natural-language-form__wrapper\">\n    <ng-content></ng-content>\n</div>",
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    host: {
                        '[class.is-negative]': 'negative',
                        '[class.nx-natural-language-form--small]': 'size === "small"',
                        '[class.nx-natural-language-form--large]': 'size === "large"',
                    },
                    styles: [":host{display:block;font-size:40px;font-size:var(--natural-language-form-large-font-size,40px);line-height:52px;line-height:var(--natural-language-form-large-line-height,52px);font-weight:300;font-weight:var(--natural-language-form-large-font-weight,300);letter-spacing:.3px;letter-spacing:var(--natural-language-form-large-letter-spacing,.3px);color:#414141;color:var(--natural-language-form-text-color,#414141);padding-top:72px;padding-bottom:80px}:host ::ng-deep .c-input{font-size:inherit;line-height:inherit}:host ::ng-deep nx-word+nx-word{margin-left:2px}:host.is-negative{color:#fff}@media (max-width:991px){:host{font-size:26px;font-size:var(--natural-language-form-small-font-size,26px);line-height:36px;line-height:var(--natural-language-form-small-line-height,36px);font-weight:300;font-weight:var(--natural-language-form-small-font-weight,300);letter-spacing:.3px;letter-spacing:var(--natural-language-form-small-letter-spacing,.3px)}}.nx-natural-language-form__wrapper{display:flex;flex-wrap:wrap}.nx-natural-language-form__wrapper>::ng-deep *{margin-bottom:8px}:host(.nx-natural-language-form--small){font-size:26px;font-size:var(--natural-language-form-small-font-size,26px);line-height:36px;line-height:var(--natural-language-form-small-line-height,36px);font-weight:300;font-weight:var(--natural-language-form-small-font-weight,300);letter-spacing:.3px;letter-spacing:var(--natural-language-form-small-letter-spacing,.3px)}:host(.nx-natural-language-form--small) ::ng-deep .c-input{font-size:inherit;line-height:inherit}"]
                }] }
    ];
    /** @nocollapse */
    NxNaturalLanguageFormComponent.ctorParameters = function () { return [
        { type: ChangeDetectorRef }
    ]; };
    NxNaturalLanguageFormComponent.propDecorators = {
        _words: [{ type: ContentChildren, args: [NxWordComponent,] }],
        negative: [{ type: Input, args: ['nxNegative',] }],
        size: [{ type: Input }],
        onResize: [{ type: HostListener, args: ['window:orientationchange', ['$event'],] }, { type: HostListener, args: ['window:resize', ['$event'],] }]
    };
    return NxNaturalLanguageFormComponent;
}());
if (false) {
    /**
     * @type {?}
     * @private
     */
    NxNaturalLanguageFormComponent.prototype._negative;
    /**
     * \@docs-private
     * @type {?}
     */
    NxNaturalLanguageFormComponent.prototype.resizeEvent$;
    /**
     * \@docs-private
     * @type {?}
     */
    NxNaturalLanguageFormComponent.prototype.resizeObservable;
    /** @type {?} */
    NxNaturalLanguageFormComponent.prototype._words;
    /**
     * \@docs-private
     * @type {?}
     */
    NxNaturalLanguageFormComponent.prototype.updatePopoversSubscription;
    /**
     * \@docs-private
     * @type {?}
     * @private
     */
    NxNaturalLanguageFormComponent.prototype._size;
    /**
     * @type {?}
     * @private
     */
    NxNaturalLanguageFormComponent.prototype._changeDetectorRef;
}

/**
 * @fileoverview added by tsickle
 * Generated from: natural-language-form.module.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var NxNaturalLanguageFormModule = /** @class */ (function () {
    function NxNaturalLanguageFormModule() {
    }
    NxNaturalLanguageFormModule.decorators = [
        { type: NgModule, args: [{
                    imports: [
                        CommonModule,
                        NxInputModule,
                        NxPopoverModule
                    ],
                    declarations: [
                        NxNaturalLanguageFormComponent,
                        NxWordComponent
                    ],
                    exports: [
                        NxNaturalLanguageFormComponent,
                        NxWordComponent
                    ]
                },] }
    ];
    return NxNaturalLanguageFormModule;
}());

/**
 * @fileoverview added by tsickle
 * Generated from: public-api.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * Generated from: allianz-ngx-ndbx-natural-language-form.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

export { NxNaturalLanguageFormComponent, NxNaturalLanguageFormModule, NxWordComponent };
//# sourceMappingURL=allianz-ngx-ndbx-natural-language-form.js.map
