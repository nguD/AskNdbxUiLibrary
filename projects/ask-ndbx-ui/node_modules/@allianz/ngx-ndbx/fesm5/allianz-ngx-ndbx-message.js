import { CommonModule } from '@angular/common';
import { EventEmitter, Component, ChangeDetectionStrategy, ChangeDetectorRef, Input, Output, NgZone, ViewChild, NgModule, InjectionToken, Injectable, Injector, Optional, SkipSelf, Inject, ɵɵdefineInjectable, ɵɵinject, INJECTOR } from '@angular/core';
import { NxIconModule } from '@allianz/ngx-ndbx/icon';
import { coerceBooleanProperty } from '@angular/cdk/coercion';
import { OverlayModule, OverlayConfig, Overlay } from '@angular/cdk/overlay';
import { CdkPortalOutlet, BasePortalOutlet, PortalModule, ComponentPortal, TemplatePortal, PortalInjector } from '@angular/cdk/portal';
import { __extends, __assign } from 'tslib';
import { trigger, state, style, transition, animate } from '@angular/animations';
import { Subject } from 'rxjs';
import { take } from 'rxjs/operators';
import { LiveAnnouncer } from '@angular/cdk/a11y';

/**
 * @fileoverview added by tsickle
 * Generated from: message/message.component.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
var ICONS = {
    info: 'info-circle',
    error: 'exclamation-triangle',
    success: 'check-circle',
    warning: 'exclamation-circle'
};
var NxMessageComponent = /** @class */ (function () {
    function NxMessageComponent(_changeDetectorRef) {
        this._changeDetectorRef = _changeDetectorRef;
        this._context = 'regular';
        this._showIcon = false;
        this._closable = false;
        this._closeButtonLabel = 'Close dialog';
        /**
         * Event emitted when the close icon of the message has been clicked.
         */
        this.closeEvent = new EventEmitter();
    }
    Object.defineProperty(NxMessageComponent.prototype, "context", {
        get: /**
         * @return {?}
         */
        function () {
            return this._context;
        },
        /**
         * Sets the context of the message.
         * The message box will color accordingly. Default: 'regular' */
        set: /**
         * Sets the context of the message.
         * The message box will color accordingly. Default: 'regular'
         * @param {?} value
         * @return {?}
         */
        function (value) {
            if (value !== this._context) {
                this._context = value;
                this._icon = this.getIconName();
                this._changeDetectorRef.markForCheck();
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NxMessageComponent.prototype, "showIcon", {
        get: /**
         * @return {?}
         */
        function () {
            return this._showIcon;
        },
        /**
         * Whether an icon that belongs to the context of the message should be displayed.
         *
         * **Important:** The `showIcon` attribute should always be set to `true` due to deprecation.
         *
         * @deprecated The `showIcon` attribute should be always true in future. Messages without an icon are deprecated.
         * @deletion-target 9.0.0
         * */
        set: /**
         * Whether an icon that belongs to the context of the message should be displayed.
         *
         * **Important:** The `showIcon` attribute should always be set to `true` due to deprecation.
         *
         * @deprecated The `showIcon` attribute should be always true in future. Messages without an icon are deprecated.
         * \@deletion-target 9.0.0
         *
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this._showIcon = coerceBooleanProperty(value);
            this._changeDetectorRef.markForCheck();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NxMessageComponent.prototype, "closable", {
        get: /**
         * @return {?}
         */
        function () {
            return this._closable;
        },
        /** Whether a message should have a close icon in order to be dismissed. */
        set: /**
         * Whether a message should have a close icon in order to be dismissed.
         * @param {?} value
         * @return {?}
         */
        function (value) {
            /** @type {?} */
            var newValue = coerceBooleanProperty(value);
            if (newValue !== this._closable) {
                this._closable = newValue;
                this._changeDetectorRef.markForCheck();
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NxMessageComponent.prototype, "icon", {
        /** @docs-private */
        get: /**
         * \@docs-private
         * @return {?}
         */
        function () {
            return this._icon;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NxMessageComponent.prototype, "closeButtonLabel", {
        get: /**
         * @return {?}
         */
        function () {
            return this._closeButtonLabel;
        },
        /** Sets the label of the close button of the message. */
        set: /**
         * Sets the label of the close button of the message.
         * @param {?} value
         * @return {?}
         */
        function (value) {
            if (value !== this._closeButtonLabel) {
                this._closeButtonLabel = value;
                this._changeDetectorRef.markForCheck();
            }
        },
        enumerable: true,
        configurable: true
    });
    /** @docs-private */
    /**
     * \@docs-private
     * @return {?}
     */
    NxMessageComponent.prototype._emitCloseEvent = /**
     * \@docs-private
     * @return {?}
     */
    function () {
        this.closeEvent.emit();
    };
    /** @docs-private */
    /**
     * \@docs-private
     * @return {?}
     */
    NxMessageComponent.prototype.getIconName = /**
     * \@docs-private
     * @return {?}
     */
    function () {
        if (this._context === 'info') {
            return ICONS.info;
        }
        else if (this._context === 'error') {
            return ICONS.error;
        }
        else if (this._context === 'success') {
            return ICONS.success;
        }
        else if (this._context === 'warning') {
            return ICONS.warning;
        }
        return '';
    };
    NxMessageComponent.decorators = [
        { type: Component, args: [{
                    selector: 'nx-message',
                    template: "<nx-icon *ngIf=\"showIcon && context !== 'regular'\"\n         class=\"nx-message__icon\"\n         [name]=\"icon\"\n         size=\"s\">\n</nx-icon>\n<button\n  *ngIf=\"closable\"\n  (click)=\"_emitCloseEvent()\"\n  [attr.aria-label]=\"closeButtonLabel\"\n  tabindex=\"0\"\n  class=\"nx-message__close-icon\">\n    <nx-icon\n      name=\"close\"\n      size=\"s\"\n      aria-hidden=\"true\">\n    </nx-icon>\n</button>\n\n\n<div class=\"nx-message__content-wrapper\">\n  <div class=\"nx-message__content\">\n    <ng-content></ng-content>\n  </div>\n</div>\n",
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    exportAs: 'nxMessage',
                    host: {
                        '[class.context-info]': 'context === "info"',
                        '[class.context-error]': 'context === "error"',
                        '[class.context-success]': 'context === "success"',
                        '[class.context-warning]': 'context === "warning"',
                        '[class.nx-message--closable]': 'closable'
                    },
                    styles: [":host{font-size:16px;font-size:var(--message-font-size,16px);line-height:24px;line-height:var(--message-line-height,24px);font-weight:400;font-weight:var(--message-font-weight,400);letter-spacing:0;letter-spacing:var(--message-letter-spacing,0);color:#414141;color:var(--message-text-color,#414141);border-radius:4px;border-radius:var(--message-border-radius,4px);width:100%;display:flex;align-items:flex-start;text-align:left;position:relative;border:1px solid;padding:23px;margin:12px 0}.nx-message__content-wrapper{max-width:100%}:host,:host(.context-regular){border-color:#414141;border-color:var(--message-regular-border-color,#414141);background-color:#fff;background-color:var(--message-regular-background-color,#fff)}:host(.context-info){border-color:#496ebd;border-color:var(--message-info-border-color,#496ebd);background-color:#ecf0f8;background-color:var(--message-info-background-color,#ecf0f8)}:host(.context-info) .nx-message__icon{color:#496ebd;color:var(--message-info-icon-color,#496ebd)}:host(.context-error){border-color:#dc3149;border-color:var(--message-error-border-color,#dc3149);background-color:#fbeaec;background-color:var(--message-error-background-color,#fbeaec)}:host(.context-error) .nx-message__icon{color:#dc3149;color:var(--message-error-icon-color,#dc3149)}:host(.context-success){border-color:#1e8927;border-color:var(--message-success-border-color,#1e8927);background-color:#e8f3e9;background-color:var(--message-success-background-color,#e8f3e9)}:host(.context-success) .nx-message__icon{color:#1e8927;color:var(--message-success-icon-color,#1e8927)}:host(.context-warning){border-color:#efbe25;border-color:var(--message-warning-border-color,#efbe25);background-color:#fdf8e9;background-color:var(--message-warning-background-color,#fdf8e9)}:host(.context-warning) .nx-message__icon{color:#efbe25;color:var(--message-warning-icon-color,#efbe25)}.nx-message__icon{margin-right:16px}@media (max-width:703px){:host{padding:31px;display:block}:host(.context-error) .nx-message__icon~.nx-message__content-wrapper .nx-message__content,:host(.context-info) .nx-message__icon~.nx-message__content-wrapper .nx-message__content,:host(.context-success) .nx-message__icon~.nx-message__content-wrapper .nx-message__content,:host(.context-warning) .nx-message__icon~.nx-message__content-wrapper .nx-message__content{display:inline;margin-left:31px}.nx-message__icon{position:absolute}}:host(.nx-message--closable){padding-right:39px}@media (max-width:703px){:host(.nx-message--closable){padding-right:31px}}.nx-message__close-icon{position:absolute;top:16px;right:16px;cursor:pointer;background-color:transparent;border:none;outline:0;padding:0;display:flex;align-items:center}.nx-message__close-icon nx-icon{color:#414141;color:var(--message-close-icon-color,#414141);font-size:16px}:host-context([data-whatinput=keyboard]) .nx-message__close-icon:focus{box-shadow:0 0 0 2px #fff,0 0 0 6px #009de6;box-shadow:var(--focus-box-shadow,0 0 0 2px #fff,0 0 0 6px #009de6);border-radius:4px}@media screen and (-ms-high-contrast:active){:host(.context-error) .nx-message__icon,:host(.context-info) .nx-message__icon,:host(.context-success) .nx-message__icon,:host(.context-warning) .nx-message__icon{color:windowText}:host-context([data-whatinput=keyboard]) .nx-message__close-icon:focus{box-shadow:0 0 0 2px background,0 0 0 6px windowText}}"]
                }] }
    ];
    /** @nocollapse */
    NxMessageComponent.ctorParameters = function () { return [
        { type: ChangeDetectorRef }
    ]; };
    NxMessageComponent.propDecorators = {
        context: [{ type: Input, args: ['nxContext',] }],
        showIcon: [{ type: Input }],
        closable: [{ type: Input }],
        closeButtonLabel: [{ type: Input }],
        closeEvent: [{ type: Output, args: ['close',] }]
    };
    return NxMessageComponent;
}());
if (false) {
    /**
     * @type {?}
     * @private
     */
    NxMessageComponent.prototype._context;
    /**
     * @type {?}
     * @private
     */
    NxMessageComponent.prototype._showIcon;
    /**
     * @type {?}
     * @private
     */
    NxMessageComponent.prototype._closable;
    /**
     * @type {?}
     * @private
     */
    NxMessageComponent.prototype._icon;
    /**
     * @type {?}
     * @private
     */
    NxMessageComponent.prototype._closeButtonLabel;
    /**
     * Event emitted when the close icon of the message has been clicked.
     * @type {?}
     */
    NxMessageComponent.prototype.closeEvent;
    /**
     * @type {?}
     * @private
     */
    NxMessageComponent.prototype._changeDetectorRef;
}

/**
 * @fileoverview added by tsickle
 * Generated from: message-toast/message-toast-animations.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Animations used by the Message Toast.
 * \@docs-private
 * @type {?}
 */
var messageToastAnimations = {
    toastState: trigger('state', [
        state('initial, void, hidden', style({ opacity: 0, transform: 'translateY(100%)' })),
        state('visible', style({ opacity: 1 })),
        transition('* => visible', animate('300ms cubic-bezier(0, 0, 0.2, 1)', style({ opacity: 1, transform: 'translateY(0)' }))),
        transition('* => hidden', animate('300ms cubic-bezier(0, 0, 0.2, 1)', style({ opacity: 0, transform: 'translateY(200%)' }))),
    ])
};

/**
 * @fileoverview added by tsickle
 * Generated from: message-toast/message-toast-config.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Configuration used when opening a message toast.
 */
var  /**
 * Configuration used when opening a message toast.
 */
NxMessageToastConfig = /** @class */ (function () {
    function NxMessageToastConfig() {
        /**
         * The politeness level for the LiveAnnouncer announcement.
         *
         *  Default value: 'polite'.
         */
        this.politeness = 'polite';
        /**
         * Message to be announced by the LiveAnnouncer. When opening a toast message without a custom
         * component or template, the announcement message will default to the specified message.
         *
         * Default value: ''.
         */
        this.announcementMessage = '';
        /**
         * The length of time in milliseconds to wait before automatically dismissing the message toast.
         *
         * Default value: 3000.
         */
        this.duration = 3000;
        /**
         * Context of the message toast.
         *
         * Default value: 'info'.
         */
        this.context = 'info';
    }
    return NxMessageToastConfig;
}());
if (false) {
    /**
     * The politeness level for the LiveAnnouncer announcement.
     *
     *  Default value: 'polite'.
     * @type {?}
     */
    NxMessageToastConfig.prototype.politeness;
    /**
     * Message to be announced by the LiveAnnouncer. When opening a toast message without a custom
     * component or template, the announcement message will default to the specified message.
     *
     * Default value: ''.
     * @type {?}
     */
    NxMessageToastConfig.prototype.announcementMessage;
    /**
     * The length of time in milliseconds to wait before automatically dismissing the message toast.
     *
     * Default value: 3000.
     * @type {?}
     */
    NxMessageToastConfig.prototype.duration;
    /**
     * Context of the message toast.
     *
     * Default value: 'info'.
     * @type {?}
     */
    NxMessageToastConfig.prototype.context;
}
/**
 * \@docs-private
 * Needed so that the user text data can be injected in the message toastcomponent
 */
var  /**
 * \@docs-private
 * Needed so that the user text data can be injected in the message toastcomponent
 */
NxMessageToastData = /** @class */ (function () {
    function NxMessageToastData(data) {
        this.data = data;
    }
    return NxMessageToastData;
}());
if (false) {
    /** @type {?} */
    NxMessageToastData.prototype.data;
}

/**
 * @fileoverview added by tsickle
 * Generated from: message-toast/message-toast.component.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
var ICONS$1 = {
    info: 'info-circle',
    success: 'check-circle',
};
/**
 * Internal component that wraps user-provided message toastcontent.
 * \@docs-private
 */
var NxMessageToastComponent = /** @class */ (function (_super) {
    __extends(NxMessageToastComponent, _super);
    function NxMessageToastComponent(_ngZone, _changeDetectorRef, config, data) {
        var _this = _super.call(this) || this;
        _this._ngZone = _ngZone;
        _this._changeDetectorRef = _changeDetectorRef;
        _this.config = config;
        _this.data = data;
        /**
         * Whether the component has been destroyed.
         */
        _this._destroyed = false;
        /**
         * Subject for notifying that the message toasthas exited from view.
         */
        _this._onExit = new Subject();
        /**
         * Subject for notifying that the message toasthas finished entering the view.
         */
        _this._onEnter = new Subject();
        /**
         * The state of the message toastanimations.
         */
        _this._animationState = 'void';
        _this._context = _this.config.context;
        _this._setAriaLabels();
        return _this;
    }
    /** Attach a component portal as content to this message toastcontainer. */
    /**
     * Attach a component portal as content to this message toastcontainer.
     * @template T
     * @param {?} portal
     * @return {?}
     */
    NxMessageToastComponent.prototype.attachComponentPortal = /**
     * Attach a component portal as content to this message toastcontainer.
     * @template T
     * @param {?} portal
     * @return {?}
     */
    function (portal) {
        this._assertNotAttached();
        return this._portalOutlet.attachComponentPortal(portal);
    };
    /** Attach a template portal as content to this message toastcontainer. */
    /**
     * Attach a template portal as content to this message toastcontainer.
     * @template C
     * @param {?} portal
     * @return {?}
     */
    NxMessageToastComponent.prototype.attachTemplatePortal = /**
     * Attach a template portal as content to this message toastcontainer.
     * @template C
     * @param {?} portal
     * @return {?}
     */
    function (portal) {
        this._assertNotAttached();
        return this._portalOutlet.attachTemplatePortal(portal);
    };
    /** Handle end of animations, updating the state of the notification. */
    /**
     * Handle end of animations, updating the state of the notification.
     * @param {?} event
     * @return {?}
     */
    NxMessageToastComponent.prototype.onAnimationEnd = /**
     * Handle end of animations, updating the state of the notification.
     * @param {?} event
     * @return {?}
     */
    function (event) {
        var fromState = event.fromState, toState = event.toState;
        if ((toState === 'void' && fromState !== 'void') || toState === 'hidden') {
            this._completeExit();
        }
        if (toState === 'visible') {
            // Note: we shouldn't use `this` inside the zone callback,
            // because it can cause a memory leak.
            /** @type {?} */
            var onEnter_1 = this._onEnter;
            this._ngZone.run((/**
             * @return {?}
             */
            function () {
                onEnter_1.next();
                onEnter_1.complete();
            }));
        }
    };
    /** Begin animation of message toastentrance into view. */
    /**
     * Begin animation of message toastentrance into view.
     * @return {?}
     */
    NxMessageToastComponent.prototype.enter = /**
     * Begin animation of message toastentrance into view.
     * @return {?}
     */
    function () {
        if (!this._destroyed) {
            this._animationState = 'visible';
            this._changeDetectorRef.detectChanges();
        }
    };
    /** Begin animation of the message toastexiting from view. */
    /**
     * Begin animation of the message toastexiting from view.
     * @return {?}
     */
    NxMessageToastComponent.prototype.exit = /**
     * Begin animation of the message toastexiting from view.
     * @return {?}
     */
    function () {
        // Note: this one transitions to `hidden`, rather than `void`, in order to handle the case
        // where multiple notifications are opened in quick succession (e.g. two consecutive calls to
        // `NxMessageToastService.open`).
        this._animationState = 'hidden';
    };
    /** Makes sure the exit callbacks have been invoked when the element is destroyed. */
    /**
     * Makes sure the exit callbacks have been invoked when the element is destroyed.
     * @return {?}
     */
    NxMessageToastComponent.prototype.ngOnDestroy = /**
     * Makes sure the exit callbacks have been invoked when the element is destroyed.
     * @return {?}
     */
    function () {
        this._destroyed = true;
        this._completeExit();
    };
    /**
     * Waits for the zone to settle before removing the element. Helps prevent
     * errors where we end up removing an element which is in the middle of an animation.
     */
    /**
     * Waits for the zone to settle before removing the element. Helps prevent
     * errors where we end up removing an element which is in the middle of an animation.
     * @private
     * @return {?}
     */
    NxMessageToastComponent.prototype._completeExit = /**
     * Waits for the zone to settle before removing the element. Helps prevent
     * errors where we end up removing an element which is in the middle of an animation.
     * @private
     * @return {?}
     */
    function () {
        var _this = this;
        this._ngZone.onMicrotaskEmpty.asObservable().pipe(take(1)).subscribe((/**
         * @return {?}
         */
        function () {
            _this._onExit.next();
            _this._onExit.complete();
        }));
    };
    /** Asserts that no content is already attached to the container. */
    /**
     * Asserts that no content is already attached to the container.
     * @private
     * @return {?}
     */
    NxMessageToastComponent.prototype._assertNotAttached = /**
     * Asserts that no content is already attached to the container.
     * @private
     * @return {?}
     */
    function () {
        if (this._portalOutlet.hasAttached()) {
            throw Error('Attempting to attach message toastcontent after content is already attached');
        }
    };
    /**
     * @return {?}
     */
    NxMessageToastComponent.prototype._getIconName = /**
     * @return {?}
     */
    function () {
        return this._context === 'success' ? ICONS$1.success : ICONS$1.info;
    };
    /**
     * @return {?}
     */
    NxMessageToastComponent.prototype._setAriaLabels = /**
     * @return {?}
     */
    function () {
        // Based on the ARIA spec, `alert` and `status` roles have an
        // implicit `assertive` and `polite` politeness respectively.
        if (this.config.politeness === 'assertive' && !this.config.announcementMessage) {
            this._role = 'alert';
        }
        else if (this.config.politeness === 'off') {
            this._role = null;
        }
        else {
            this._role = 'status';
        }
    };
    NxMessageToastComponent.decorators = [
        { type: Component, args: [{
                    selector: 'nx-message-toast',
                    template: "<nx-icon class=\"nx-message__icon\" [name]=\"_getIconName()\" size=\"s\">\n</nx-icon>\n\n<div class=\"nx-message__content-wrapper\">\n    <!-- Used when opening from a template -->\n    <ng-template cdkPortalOutlet></ng-template>\n    <!-- Used when opening only with custom text-->\n    <ng-container *ngIf=\"data\">{{data.data}}</ng-container>\n</div>\n",
                    host: {
                        '[attr.role]': '_role',
                        '[class.context-info]': '_context === "info"',
                        '[class.context-success]': '_context === "success"',
                        '[@state]': '_animationState',
                        '(@state.done)': 'onAnimationEnd($event)'
                    },
                    animations: [messageToastAnimations.toastState],
                    styles: [":host{font-size:16px;font-size:var(--message-font-size,16px);line-height:24px;line-height:var(--message-line-height,24px);font-weight:400;font-weight:var(--message-font-weight,400);letter-spacing:0;letter-spacing:var(--message-letter-spacing,0);color:#414141;color:var(--message-text-color,#414141);border-radius:4px;border-radius:var(--message-border-radius,4px);width:100%;display:flex;align-items:flex-start;text-align:left;position:relative;border:1px solid;padding:23px 23px 23px 63px;margin:12px 0;box-shadow:0 2px 4px rgba(65,65,65,.5);box-shadow:var(--message-box-shadow,0 2px 4px rgba(65,65,65,.5));max-width:352px}@media (max-width:703px){:host{padding:23px 23px 23px 63px;display:block}}:host(.context-info){border-color:#496ebd;border-color:var(--message-info-border-color,#496ebd);background-color:#ecf0f8;background-color:var(--message-info-background-color,#ecf0f8)}:host(.context-info) .nx-message__icon{color:#496ebd;color:var(--message-info-icon-color,#496ebd)}:host(.context-success){border-color:#1e8927;border-color:var(--message-success-border-color,#1e8927);background-color:#e8f3e9;background-color:var(--message-success-background-color,#e8f3e9)}:host(.context-success) .nx-message__icon{color:#1e8927;color:var(--message-success-icon-color,#1e8927)}@media screen and (-ms-high-contrast:active){:host(.context-info) .nx-message__icon,:host(.context-success) .nx-message__icon{color:windowText}}.nx-message__icon{position:absolute;top:23px;left:23px}"]
                }] }
    ];
    /** @nocollapse */
    NxMessageToastComponent.ctorParameters = function () { return [
        { type: NgZone },
        { type: ChangeDetectorRef },
        { type: NxMessageToastConfig },
        { type: NxMessageToastData }
    ]; };
    NxMessageToastComponent.propDecorators = {
        _portalOutlet: [{ type: ViewChild, args: [CdkPortalOutlet, { static: true },] }]
    };
    return NxMessageToastComponent;
}(BasePortalOutlet));
if (false) {
    /**
     * Whether the component has been destroyed.
     * @type {?}
     * @private
     */
    NxMessageToastComponent.prototype._destroyed;
    /**
     * The portal outlet inside of this container into which the message toastcontent will be loaded.
     * @type {?}
     */
    NxMessageToastComponent.prototype._portalOutlet;
    /**
     * Subject for notifying that the message toasthas exited from view.
     * @type {?}
     */
    NxMessageToastComponent.prototype._onExit;
    /**
     * Subject for notifying that the message toasthas finished entering the view.
     * @type {?}
     */
    NxMessageToastComponent.prototype._onEnter;
    /**
     * The state of the message toastanimations.
     * @type {?}
     */
    NxMessageToastComponent.prototype._animationState;
    /**
     * ARIA role for the message toastcontainer.
     * @type {?}
     */
    NxMessageToastComponent.prototype._role;
    /** @type {?} */
    NxMessageToastComponent.prototype._context;
    /**
     * @type {?}
     * @private
     */
    NxMessageToastComponent.prototype._ngZone;
    /**
     * @type {?}
     * @private
     */
    NxMessageToastComponent.prototype._changeDetectorRef;
    /**
     * The message toastconfiguration.
     * @type {?}
     */
    NxMessageToastComponent.prototype.config;
    /**
     * Injected data into the notifciation.
     * @type {?}
     */
    NxMessageToastComponent.prototype.data;
}

/**
 * @fileoverview added by tsickle
 * Generated from: message.module.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var NxMessageModule = /** @class */ (function () {
    function NxMessageModule() {
    }
    NxMessageModule.decorators = [
        { type: NgModule, args: [{
                    imports: [
                        CommonModule,
                        NxIconModule,
                        OverlayModule,
                        PortalModule
                    ],
                    declarations: [
                        NxMessageComponent,
                        NxMessageToastComponent
                    ],
                    exports: [
                        NxMessageComponent
                    ],
                    entryComponents: [
                        NxMessageToastComponent
                    ]
                },] }
    ];
    return NxMessageModule;
}());

/**
 * @fileoverview added by tsickle
 * Generated from: message-toast/message-toast-ref.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Maximum amount of milliseconds that can be passed into setTimeout.
 * @type {?}
 */
var MAX_TIMEOUT = Math.pow(2, 31) - 1;
var NxMessageToastRef = /** @class */ (function () {
    function NxMessageToastRef(toastInstance, _overlayRef) {
        var _this = this;
        this._overlayRef = _overlayRef;
        /**
         * Subject for notifying the user that the message toasthas been dismissed.
         */
        this._afterDismissed = new Subject();
        /**
         * Subject for notifying the user that the message toasthas opened and appeared.
         */
        this._afterOpened = new Subject();
        this.toastInstance = toastInstance;
        toastInstance._onExit.subscribe((/**
         * @return {?}
         */
        function () { return _this._finishDismiss(); }));
    }
    /** Dismisses the message toast. */
    /**
     * Dismisses the message toast.
     * @return {?}
     */
    NxMessageToastRef.prototype.dismiss = /**
     * Dismisses the message toast.
     * @return {?}
     */
    function () {
        if (!this._afterDismissed.closed) {
            this.toastInstance.exit();
        }
        clearTimeout(this._durationTimeoutId);
    };
    /** Dismisses the message toastafter some duration */
    /**
     * Dismisses the message toastafter some duration
     * @param {?} duration
     * @return {?}
     */
    NxMessageToastRef.prototype._dismissAfter = /**
     * Dismisses the message toastafter some duration
     * @param {?} duration
     * @return {?}
     */
    function (duration) {
        var _this = this;
        // Note that we need to cap the duration to the maximum value for setTimeout, because
        // it'll revert to 1 if somebody passes in something greater (e.g. `Infinity`). See #17234.
        this._durationTimeoutId = setTimeout((/**
         * @return {?}
         */
        function () { return _this.dismiss(); }), Math.min(duration, MAX_TIMEOUT));
    };
    /** Marks the message toastas opened */
    /**
     * Marks the message toastas opened
     * @return {?}
     */
    NxMessageToastRef.prototype._open = /**
     * Marks the message toastas opened
     * @return {?}
     */
    function () {
        if (!this._afterOpened.closed) {
            this._afterOpened.next();
            this._afterOpened.complete();
        }
    };
    /** Cleans up the DOM after closing. */
    /**
     * Cleans up the DOM after closing.
     * @private
     * @return {?}
     */
    NxMessageToastRef.prototype._finishDismiss = /**
     * Cleans up the DOM after closing.
     * @private
     * @return {?}
     */
    function () {
        this._overlayRef.dispose();
        this._afterDismissed.next();
        this._afterDismissed.complete();
    };
    /** Gets an observable that is notified when the message toastis finished closing. */
    /**
     * Gets an observable that is notified when the message toastis finished closing.
     * @return {?}
     */
    NxMessageToastRef.prototype.afterDismissed = /**
     * Gets an observable that is notified when the message toastis finished closing.
     * @return {?}
     */
    function () {
        return this._afterDismissed.asObservable();
    };
    /** Gets an observable that is notified when the message toasthas opened and appeared. */
    /**
     * Gets an observable that is notified when the message toasthas opened and appeared.
     * @return {?}
     */
    NxMessageToastRef.prototype.afterOpened = /**
     * Gets an observable that is notified when the message toasthas opened and appeared.
     * @return {?}
     */
    function () {
        return this.toastInstance._onEnter;
    };
    return NxMessageToastRef;
}());
if (false) {
    /**
     * The instance of the component making up the content of the message toast.
     * \@docs-private
     * @type {?}
     */
    NxMessageToastRef.prototype.toastInstance;
    /**
     * Subject for notifying the user that the message toasthas been dismissed.
     * @type {?}
     * @private
     */
    NxMessageToastRef.prototype._afterDismissed;
    /**
     * Subject for notifying the user that the message toasthas opened and appeared.
     * @type {?}
     * @private
     */
    NxMessageToastRef.prototype._afterOpened;
    /**
     * Timeout ID for the duration setTimeout call. Used to clear the timeout if the message toastis
     * dismissed before the duration passes.
     * @type {?}
     * @private
     */
    NxMessageToastRef.prototype._durationTimeoutId;
    /**
     * @type {?}
     * @private
     */
    NxMessageToastRef.prototype._overlayRef;
}

/**
 * @fileoverview added by tsickle
 * Generated from: message-toast/message-toast.service.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Injection token that can be used to specify default message toast.
 * @type {?}
 */
var NX_MESSAGE_TOAST_DEFAULT_CONFIG = new InjectionToken('NX_MESSAGE_TOAST_DEFAULT_CONFIG');
/**
 * A service for dispatching and displaying toast messages.
 */
var NxMessageToastService = /** @class */ (function () {
    function NxMessageToastService(_overlay, _injector, _live, _parentMessageToastService, _defaultConfig) {
        this._overlay = _overlay;
        this._injector = _injector;
        this._live = _live;
        this._parentMessageToastService = _parentMessageToastService;
        this._defaultConfig = _defaultConfig;
        /**
         * Reference to the current message toast in the view *at this level* (in the Angular injector tree).
         * If there is a parent message toast service, all operations should delegate to that parent
         * via `_oldToastMessageRef`.
         */
        this._toastRefAtThisLevel = null;
    }
    Object.defineProperty(NxMessageToastService.prototype, "_oldToastMessageRef", {
        /** Reference to the currently opened message toastat *any* level. */
        get: /**
         * Reference to the currently opened message toastat *any* level.
         * @return {?}
         */
        function () {
            /** @type {?} */
            var parent = this._parentMessageToastService;
            return parent ? parent._oldToastMessageRef : this._toastRefAtThisLevel;
        },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            if (this._parentMessageToastService) {
                this._parentMessageToastService._oldToastMessageRef = value;
            }
            else {
                this._toastRefAtThisLevel = value;
            }
        },
        enumerable: true,
        configurable: true
    });
    /** Creates and dispatches a message toastwith a custom text.
     *
     * @param text Text to be used for the message toast.
     * @param config Extra configuration for the message toast.
    */
    /**
     * Creates and dispatches a message toastwith a custom text.
     *
     * @param {?} text Text to be used for the message toast.
     * @param {?=} config Extra configuration for the message toast.
     * @return {?}
     */
    NxMessageToastService.prototype.open = /**
     * Creates and dispatches a message toastwith a custom text.
     *
     * @param {?} text Text to be used for the message toast.
     * @param {?=} config Extra configuration for the message toast.
     * @return {?}
     */
    function (text, config) {
        /** @type {?} */
        var currentConfig = __assign({}, new NxMessageToastConfig(), this._defaultConfig, config);
        /** @type {?} */
        var overlayRef = this._createOverlay(currentConfig);
        /** @type {?} */
        var injector = this._createInjector(currentConfig, new NxMessageToastData(text), this._injector);
        /** @type {?} */
        var componentPortal = new ComponentPortal(NxMessageToastComponent, undefined, injector);
        /** @type {?} */
        var componentRef = overlayRef.attach(componentPortal);
        /** @type {?} */
        var toastRef = new NxMessageToastRef(componentRef.instance, overlayRef);
        this._animateToast(toastRef, currentConfig);
        this._oldToastMessageRef = toastRef;
        return this._oldToastMessageRef;
    };
    /** Creates and dispatches a message toastwith a custom template for the content.
     *
     * @param template Template to be used for the message toast.
     * @param config Extra configuration for the message toast.
    */
    /**
     * Creates and dispatches a message toastwith a custom template for the content.
     *
     * @param {?} template Template to be used for the message toast.
     * @param {?=} config Extra configuration for the message toast.
     * @return {?}
     */
    NxMessageToastService.prototype.openFromTemplate = /**
     * Creates and dispatches a message toastwith a custom template for the content.
     *
     * @param {?} template Template to be used for the message toast.
     * @param {?=} config Extra configuration for the message toast.
     * @return {?}
     */
    function (template, config) {
        /** @type {?} */
        var currentConfig = __assign({}, new NxMessageToastConfig(), this._defaultConfig, config);
        /** @type {?} */
        var overlayRef = this._createOverlay(currentConfig);
        /** @type {?} */
        var container = this._attachToastComponent(overlayRef, currentConfig);
        /** @type {?} */
        var toastRef = new NxMessageToastRef(container, overlayRef);
        /** @type {?} */
        var portal = new TemplatePortal(template, (/** @type {?} */ (null)), toastRef);
        container.attachTemplatePortal(portal);
        this._animateToast(toastRef, currentConfig);
        this._oldToastMessageRef = toastRef;
        return this._oldToastMessageRef;
    };
    // Attaches the message toastcontainer component to the overlay.
    // Attaches the message toastcontainer component to the overlay.
    /**
     * @private
     * @param {?} overlayRef
     * @param {?} config
     * @return {?}
     */
    NxMessageToastService.prototype._attachToastComponent = 
    // Attaches the message toastcontainer component to the overlay.
    /**
     * @private
     * @param {?} overlayRef
     * @param {?} config
     * @return {?}
     */
    function (overlayRef, config) {
        /** @type {?} */
        var injector = this._createInjector(config, null, this._injector);
        /** @type {?} */
        var containerPortal = new ComponentPortal(NxMessageToastComponent, null, injector);
        /** @type {?} */
        var containerRef = overlayRef.attach(containerPortal);
        containerRef.instance.config = config;
        return containerRef.instance;
    };
    // Creates a new overlay and places it in the correct place.
    // Creates a new overlay and places it in the correct place.
    /**
     * @private
     * @param {?} config
     * @return {?}
     */
    NxMessageToastService.prototype._createOverlay = 
    // Creates a new overlay and places it in the correct place.
    /**
     * @private
     * @param {?} config
     * @return {?}
     */
    function (config) {
        /** @type {?} */
        var overlayConfig = new OverlayConfig();
        /** @type {?} */
        var positionStrategy = this._overlay.position().global();
        positionStrategy.bottom('0');
        positionStrategy.centerHorizontally();
        overlayConfig.positionStrategy = positionStrategy;
        return this._overlay.create(overlayConfig);
    };
    /** Animates the old message toastout and the new one in. */
    /**
     * Animates the old message toastout and the new one in.
     * @private
     * @param {?} toastRef
     * @param {?} config
     * @return {?}
     */
    NxMessageToastService.prototype._animateToast = /**
     * Animates the old message toastout and the new one in.
     * @private
     * @param {?} toastRef
     * @param {?} config
     * @return {?}
     */
    function (toastRef, config) {
        var _this = this;
        // When the message toastis dismissed, clear the reference to it.
        toastRef.afterDismissed().subscribe((/**
         * @return {?}
         */
        function () {
            // Clear the message toastref if it hasn't already been replaced by a newer message toast.
            if (_this._oldToastMessageRef === toastRef) {
                _this._oldToastMessageRef = null;
            }
            if (config.announcementMessage) {
                _this._live.clear();
            }
        }));
        if (this._oldToastMessageRef) {
            // If a message toastis opened, dismiss it and enter the
            // new message toastafter exit animation is complete.
            this._oldToastMessageRef.afterDismissed().subscribe((/**
             * @return {?}
             */
            function () {
                toastRef.toastInstance.enter();
            }));
            this._oldToastMessageRef.dismiss();
        }
        else {
            // If no message toastis in view, enter the message toast.
            toastRef.toastInstance.enter();
        }
        // If a message toastduration is provided, set up dismiss based on after the message toastis opened.
        if (config.duration && config.duration > 0) {
            toastRef.afterOpened().subscribe((/**
             * @return {?}
             */
            function () { return toastRef._dismissAfter((/** @type {?} */ (config.duration))); }));
        }
        if (config.announcementMessage) {
            this._live.announce(config.announcementMessage, config.politeness);
        }
    };
    /**
     * @private
     * @param {?} config
     * @param {?} data
     * @param {?} injector
     * @return {?}
     */
    NxMessageToastService.prototype._createInjector = /**
     * @private
     * @param {?} config
     * @param {?} data
     * @param {?} injector
     * @return {?}
     */
    function (config, data, injector) {
        /** @type {?} */
        var tokens = new WeakMap();
        tokens.set(NxMessageToastConfig, config);
        tokens.set(NxMessageToastData, data);
        return new PortalInjector(injector, tokens);
    };
    /**
     * Dismisses the currently visible message toast.
     */
    /**
     * Dismisses the currently visible message toast.
     * @return {?}
     */
    NxMessageToastService.prototype.dismiss = /**
     * Dismisses the currently visible message toast.
     * @return {?}
     */
    function () {
        if (this._oldToastMessageRef) {
            this._oldToastMessageRef.dismiss();
        }
    };
    /**
     * @return {?}
     */
    NxMessageToastService.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        if (this._toastRefAtThisLevel) {
            this._toastRefAtThisLevel.dismiss();
        }
    };
    NxMessageToastService.decorators = [
        { type: Injectable, args: [{ providedIn: NxMessageModule },] }
    ];
    /** @nocollapse */
    NxMessageToastService.ctorParameters = function () { return [
        { type: Overlay },
        { type: Injector },
        { type: LiveAnnouncer },
        { type: NxMessageToastService, decorators: [{ type: Optional }, { type: SkipSelf }] },
        { type: NxMessageToastConfig, decorators: [{ type: Optional }, { type: Inject, args: [NX_MESSAGE_TOAST_DEFAULT_CONFIG,] }] }
    ]; };
    /** @nocollapse */ NxMessageToastService.ngInjectableDef = ɵɵdefineInjectable({ factory: function NxMessageToastService_Factory() { return new NxMessageToastService(ɵɵinject(Overlay), ɵɵinject(INJECTOR), ɵɵinject(LiveAnnouncer), ɵɵinject(NxMessageToastService, 12), ɵɵinject(NX_MESSAGE_TOAST_DEFAULT_CONFIG, 8)); }, token: NxMessageToastService, providedIn: NxMessageModule });
    return NxMessageToastService;
}());
if (false) {
    /**
     * Reference to the current message toast in the view *at this level* (in the Angular injector tree).
     * If there is a parent message toast service, all operations should delegate to that parent
     * via `_oldToastMessageRef`.
     * @type {?}
     * @private
     */
    NxMessageToastService.prototype._toastRefAtThisLevel;
    /**
     * @type {?}
     * @private
     */
    NxMessageToastService.prototype._overlay;
    /**
     * @type {?}
     * @private
     */
    NxMessageToastService.prototype._injector;
    /**
     * @type {?}
     * @private
     */
    NxMessageToastService.prototype._live;
    /**
     * @type {?}
     * @private
     */
    NxMessageToastService.prototype._parentMessageToastService;
    /**
     * @type {?}
     * @private
     */
    NxMessageToastService.prototype._defaultConfig;
}

/**
 * @fileoverview added by tsickle
 * Generated from: public-api.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * Generated from: allianz-ngx-ndbx-message.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

export { NX_MESSAGE_TOAST_DEFAULT_CONFIG, NxMessageComponent, NxMessageModule, NxMessageToastComponent, NxMessageToastConfig, NxMessageToastData, NxMessageToastRef, NxMessageToastService, messageToastAnimations };
//# sourceMappingURL=allianz-ngx-ndbx-message.js.map
