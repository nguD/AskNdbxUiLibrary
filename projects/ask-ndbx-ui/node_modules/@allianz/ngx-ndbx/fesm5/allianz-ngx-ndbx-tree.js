import { __rest, __assign, __extends, __spread } from 'tslib';
import { DataSource } from '@angular/cdk/collections';
import { BehaviorSubject, merge, Subject } from 'rxjs';
import { take, map, takeUntil } from 'rxjs/operators';
import { FlatTreeControl, CdkTreeNode, CdkTreeNodeDef, CdkTree, CdkTreeNodeToggle, CdkTreeModule } from '@angular/cdk/tree';
import { Component, Directive, Input, ViewContainerRef, Renderer2, ElementRef, Optional, ViewEncapsulation, ChangeDetectionStrategy, ViewChild, NgModule } from '@angular/core';
import { Directionality } from '@angular/cdk/bidi';
import { coerceNumberProperty } from '@angular/cdk/coercion';
import { CommonModule } from '@angular/common';

/**
 * @fileoverview added by tsickle
 * Generated from: data-source/flat-data-source.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Tree flattener to convert a normal type of node to node with children & level information.
 * Transform nested nodes of type `T extends NxTreeNode` to flattened nodes of type `F extends NxFlatTreeNode`.
 *
 * For example, the input data of type `T` is nested, and contains its children data:
 *   SomeNode: {
 *     key: 'Fruits',
 *     children: [
 *       NodeOne: {
 *         key: 'Apple',
 *       },
 *       NodeTwo: {
 *        key: 'Pear',
 *      }
 *    ]
 *  }
 *  After flattener flatten the tree, the structure will become
 *  SomeNode: {
 *    key: 'Fruits',
 *    expandable: true,
 *    level: 1
 *  },
 *  NodeOne: {
 *    key: 'Apple',
 *    expandable: false,
 *    level: 2
 *  },
 *  NodeTwo: {
 *   key: 'Pear',
 *   expandable: false,
 *   level: 2
 * }
 * and the output flattened type is `F extends NxFlatTreeNode` with additional information.
 * @template T, F
 */
var /**
 * Tree flattener to convert a normal type of node to node with children & level information.
 * Transform nested nodes of type `T extends NxTreeNode` to flattened nodes of type `F extends NxFlatTreeNode`.
 *
 * For example, the input data of type `T` is nested, and contains its children data:
 *   SomeNode: {
 *     key: 'Fruits',
 *     children: [
 *       NodeOne: {
 *         key: 'Apple',
 *       },
 *       NodeTwo: {
 *        key: 'Pear',
 *      }
 *    ]
 *  }
 *  After flattener flatten the tree, the structure will become
 *  SomeNode: {
 *    key: 'Fruits',
 *    expandable: true,
 *    level: 1
 *  },
 *  NodeOne: {
 *    key: 'Apple',
 *    expandable: false,
 *    level: 2
 *  },
 *  NodeTwo: {
 *   key: 'Pear',
 *   expandable: false,
 *   level: 2
 * }
 * and the output flattened type is `F extends NxFlatTreeNode` with additional information.
 * @template T, F
 */
NxTreeFlattener = /** @class */ (function () {
    function NxTreeFlattener() {
    }
    /**
     * @param {?} node
     * @param {?} level
     * @return {?}
     */
    NxTreeFlattener.prototype.transformFunction = /**
     * @param {?} node
     * @param {?} level
     * @return {?}
     */
    function (node, level) {
        var children = node.children, rest = __rest(node, ["children"]);
        return (/** @type {?} */ (__assign({}, rest, { level: level, expandable: Array.isArray(children) && children.length > 0 })));
    };
    /**
     * @param {?} node
     * @return {?}
     */
    NxTreeFlattener.prototype.getLevel = /**
     * @param {?} node
     * @return {?}
     */
    function (node) {
        return node.level;
    };
    /**
     * @param {?} node
     * @return {?}
     */
    NxTreeFlattener.prototype.isExpandable = /**
     * @param {?} node
     * @return {?}
     */
    function (node) {
        return node.expandable;
    };
    /**
     * @param {?} node
     * @return {?}
     */
    NxTreeFlattener.prototype.getChildren = /**
     * @param {?} node
     * @return {?}
     */
    function (node) {
        return (/** @type {?} */ (node.children));
    };
    /**
     * @param {?} node
     * @param {?} level
     * @param {?} resultNodes
     * @param {?} parentMap
     * @return {?}
     */
    NxTreeFlattener.prototype._flattenNode = /**
     * @param {?} node
     * @param {?} level
     * @param {?} resultNodes
     * @param {?} parentMap
     * @return {?}
     */
    function (node, level, resultNodes, parentMap) {
        var _this = this;
        /** @type {?} */
        var flatNode = this.transformFunction(node, level);
        resultNodes.push(flatNode);
        if (this.isExpandable(flatNode)) {
            /** @type {?} */
            var childrenNodes = this.getChildren(node);
            if (Array.isArray(childrenNodes)) {
                this._flattenChildren(childrenNodes, level, resultNodes, parentMap);
            }
            else {
                childrenNodes.pipe(take(1)).subscribe((/**
                 * @param {?} children
                 * @return {?}
                 */
                function (children) {
                    _this._flattenChildren(children, level, resultNodes, parentMap);
                }));
            }
        }
        return resultNodes;
    };
    /**
     * @param {?} children
     * @param {?} level
     * @param {?} resultNodes
     * @param {?} parentMap
     * @return {?}
     */
    NxTreeFlattener.prototype._flattenChildren = /**
     * @param {?} children
     * @param {?} level
     * @param {?} resultNodes
     * @param {?} parentMap
     * @return {?}
     */
    function (children, level, resultNodes, parentMap) {
        var _this = this;
        children.forEach((/**
         * @param {?} child
         * @param {?} index
         * @return {?}
         */
        function (child, index) {
            /** @type {?} */
            var childParentMap = parentMap.slice();
            childParentMap.push(index != children.length - 1); // tslint:disable-line
            _this._flattenNode(child, level + 1, resultNodes, childParentMap);
        }));
    };
    /**
     * Flatten a list of node type T to flattened version of node F.
     * Please note that type T may be nested, and the length of `structuredData` may be different
     * from that of returned list `F[]`.
     */
    /**
     * Flatten a list of node type T to flattened version of node F.
     * Please note that type T may be nested, and the length of `structuredData` may be different
     * from that of returned list `F[]`.
     * @param {?} structuredData
     * @return {?}
     */
    NxTreeFlattener.prototype.flattenNodes = /**
     * Flatten a list of node type T to flattened version of node F.
     * Please note that type T may be nested, and the length of `structuredData` may be different
     * from that of returned list `F[]`.
     * @param {?} structuredData
     * @return {?}
     */
    function (structuredData) {
        var _this = this;
        /** @type {?} */
        var resultNodes = [];
        structuredData.forEach((/**
         * @param {?} node
         * @return {?}
         */
        function (node) { return _this._flattenNode(node, 0, resultNodes, []); }));
        return resultNodes;
    };
    /**
     * Expand flattened node with current expansion status.
     * The returned list may have different length.
     */
    /**
     * Expand flattened node with current expansion status.
     * The returned list may have different length.
     * @param {?} nodes
     * @param {?} treeControl
     * @return {?}
     */
    NxTreeFlattener.prototype.expandFlattenedNodes = /**
     * Expand flattened node with current expansion status.
     * The returned list may have different length.
     * @param {?} nodes
     * @param {?} treeControl
     * @return {?}
     */
    function (nodes, treeControl) {
        var _this = this;
        /** @type {?} */
        var results = [];
        /** @type {?} */
        var currentExpand = [];
        currentExpand[0] = true;
        nodes.forEach((/**
         * @param {?} node
         * @return {?}
         */
        function (node) {
            /** @type {?} */
            var expand = true;
            for (var i = 0; i <= _this.getLevel(node); i++) {
                expand = expand && currentExpand[i];
            }
            if (expand) {
                results.push(node);
            }
            if (_this.isExpandable(node)) {
                currentExpand[_this.getLevel(node) + 1] = treeControl.isExpanded(node);
            }
        }));
        return results;
    };
    return NxTreeFlattener;
}());
/**
 * Data source for flat tree.
 * The data source need to handle expansion/collapsion of the tree node and change the data feed
 * to `NxTree`.
 * The nested tree nodes of type `T extends NxTreeNode` are flattened through `NxTreeFlattener`, and converted
 * to type `F extends NxFlatTreeNode` for `NxTree` to consume.
 * @template T, F
 */
var  /**
 * Data source for flat tree.
 * The data source need to handle expansion/collapsion of the tree node and change the data feed
 * to `NxTree`.
 * The nested tree nodes of type `T extends NxTreeNode` are flattened through `NxTreeFlattener`, and converted
 * to type `F extends NxFlatTreeNode` for `NxTree` to consume.
 * @template T, F
 */
NxTreeFlatDataSource = /** @class */ (function (_super) {
    __extends(NxTreeFlatDataSource, _super);
    function NxTreeFlatDataSource(treeControl, initialData) {
        if (initialData === void 0) { initialData = []; }
        var _this = _super.call(this) || this;
        _this.treeControl = treeControl;
        _this._flattenedData = new BehaviorSubject([]);
        _this._expandedData = new BehaviorSubject([]);
        _this._data = new BehaviorSubject([]);
        _this._treeFlattener = new NxTreeFlattener();
        _this.data = initialData;
        return _this;
    }
    Object.defineProperty(NxTreeFlatDataSource.prototype, "data", {
        get: /**
         * @return {?}
         */
        function () { return this._data.value; },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this._data.next(value);
            this._flattenedData.next(this._treeFlattener.flattenNodes(this.data));
            this.treeControl.dataNodes = this._flattenedData.value;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @param {?} collectionViewer
     * @return {?}
     */
    NxTreeFlatDataSource.prototype.connect = /**
     * @param {?} collectionViewer
     * @return {?}
     */
    function (collectionViewer) {
        var _this = this;
        /** @type {?} */
        var changes = [
            collectionViewer.viewChange,
            this.treeControl.expansionModel.changed,
            this._flattenedData
        ];
        return merge.apply(void 0, __spread(changes)).pipe(map((/**
         * @return {?}
         */
        function () {
            _this._expandedData.next(_this._treeFlattener.expandFlattenedNodes(_this._flattenedData.value, _this.treeControl));
            return _this._expandedData.value;
        })));
    };
    /**
     * @return {?}
     */
    NxTreeFlatDataSource.prototype.disconnect = /**
     * @return {?}
     */
    function () {
        // no op
    };
    return NxTreeFlatDataSource;
}(DataSource));
if (false) {
    /** @type {?} */
    NxTreeFlatDataSource.prototype._treeFlattener;
    /** @type {?} */
    NxTreeFlatDataSource.prototype._flattenedData;
    /** @type {?} */
    NxTreeFlatDataSource.prototype._expandedData;
    /** @type {?} */
    NxTreeFlatDataSource.prototype._data;
    /**
     * @type {?}
     * @private
     */
    NxTreeFlatDataSource.prototype.treeControl;
}

/**
 * @fileoverview added by tsickle
 * Generated from: data-source/flat-tree-control.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Flat tree control.
 * Able to expand/collapse a subtree recursively for flattened tree.
 * @template F
 */
var  /**
 * Flat tree control.
 * Able to expand/collapse a subtree recursively for flattened tree.
 * @template F
 */
NxFlatTreeControl = /** @class */ (function (_super) {
    __extends(NxFlatTreeControl, _super);
    function NxFlatTreeControl() {
        return _super.call(this, (/**
         * @param {?} node
         * @return {?}
         */
        function (node) { return node.level; }), (/**
         * @param {?} node
         * @return {?}
         */
        function (node) { return node.expandable; })) || this;
    }
    return NxFlatTreeControl;
}(FlatTreeControl));

/**
 * @fileoverview added by tsickle
 * Generated from: data-source/tree-node.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * This interface defines a single node of the trees data structure.
 * @record
 */
function NxTreeNode() { }
if (false) {
    /** @type {?|undefined} */
    NxTreeNode.prototype.children;
}
/**
 * Flat node with level information.
 * @record
 */
function NxFlatTreeNode() { }
if (false) {
    /** @type {?} */
    NxFlatTreeNode.prototype.expandable;
    /** @type {?} */
    NxFlatTreeNode.prototype.level;
}

/**
 * @fileoverview added by tsickle
 * Generated from: node.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Wrapper for the CdkTree node with NDBX design styles.
 * @template T
 */
var NxTreeNodeComponent = /** @class */ (function (_super) {
    __extends(NxTreeNodeComponent, _super);
    function NxTreeNodeComponent() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    NxTreeNodeComponent.decorators = [
        { type: Component, args: [{
                    selector: 'nx-tree-node',
                    exportAs: 'nxTreeNode',
                    inputs: ['disabled', 'tabIndex'],
                    host: {
                        '[attr.aria-expanded]': 'isExpanded',
                        '[attr.aria-level]': 'role === "treeitem" ? level : null',
                        '[attr.role]': 'role',
                        'class': 'nx-tree__node',
                        '[class.is-expanded]': 'isExpanded'
                    },
                    providers: [{ provide: CdkTreeNode, useExisting: NxTreeNodeComponent }],
                    template: "<div class=\"nx-tree__node-box\">\n  <ng-content></ng-content>\n</div>\n"
                }] }
    ];
    return NxTreeNodeComponent;
}(CdkTreeNode));
/**
 * Wrapper for the CdkTree node definition with NDBX design styles.
 * @template T
 */
var NxTreeNodeDefDirective = /** @class */ (function (_super) {
    __extends(NxTreeNodeDefDirective, _super);
    function NxTreeNodeDefDirective() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    NxTreeNodeDefDirective.decorators = [
        { type: Directive, args: [{
                    selector: '[nxTreeNodeDef]',
                    inputs: [
                        'when: nxTreeNodeDefWhen'
                    ],
                    providers: [{ provide: CdkTreeNodeDef, useExisting: NxTreeNodeDefDirective }]
                },] }
    ];
    NxTreeNodeDefDirective.propDecorators = {
        data: [{ type: Input, args: ['nxTreeNode',] }]
    };
    return NxTreeNodeDefDirective;
}(CdkTreeNodeDef));
if (false) {
    /** @type {?} */
    NxTreeNodeDefDirective.prototype.data;
}

/**
 * @fileoverview added by tsickle
 * Generated from: outlet.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Outlet for nested CdkNode. Put `[nxTreeNodeOutlet]` on a tag to place children dataNodes
 * inside the outlet.
 */
var NxTreeNodeOutletDirective = /** @class */ (function () {
    function NxTreeNodeOutletDirective(viewContainer) {
        this.viewContainer = viewContainer;
    }
    NxTreeNodeOutletDirective.decorators = [
        { type: Directive, args: [{
                    selector: '[nxTreeNodeOutlet]'
                },] }
    ];
    /** @nocollapse */
    NxTreeNodeOutletDirective.ctorParameters = function () { return [
        { type: ViewContainerRef }
    ]; };
    return NxTreeNodeOutletDirective;
}());
if (false) {
    /** @type {?} */
    NxTreeNodeOutletDirective.prototype.viewContainer;
}

/**
 * @fileoverview added by tsickle
 * Generated from: padding.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Regex used to split a string on its CSS units.
 * @type {?}
 */
var cssUnitPattern = /([A-Za-z%]+)$/;
/**
 * Indent for the children tree dataNodes.
 * This directive will add left-padding to the node to show hierarchy.
 * @template T
 */
var NxTreeNodePaddingDirective = /** @class */ (function () {
    function NxTreeNodePaddingDirective(_treeNode, _tree, _renderer, _element, _dir) {
        var _this = this;
        this._treeNode = _treeNode;
        this._tree = _tree;
        this._renderer = _renderer;
        this._element = _element;
        this._dir = _dir;
        /**
         * Subject that emits when the component has been destroyed.
         */
        this._destroyed = new Subject();
        /**
         * CSS units used for the indentation value.
         */
        this.indentUnits = 'px';
        this._offset = 0;
        this._indent = 24;
        this._setPadding();
        if (this._dir) {
            this._dir.change.pipe(takeUntil(this._destroyed)).subscribe((/**
             * @return {?}
             */
            function () { return _this._setPadding(); }));
        }
    }
    Object.defineProperty(NxTreeNodePaddingDirective.prototype, "level", {
        /** The level of depth of the tree node. The padding will be `level * indent` pixels. */
        get: /**
         * The level of depth of the tree node. The padding will be `level * indent` pixels.
         * @return {?}
         */
        function () { return this._level; },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this._level = coerceNumberProperty(value);
            this._setPadding();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NxTreeNodePaddingDirective.prototype, "offset", {
        /** The offset is added once on top of each indent. Default number is 0. */
        get: /**
         * The offset is added once on top of each indent. Default number is 0.
         * @return {?}
         */
        function () { return this._offset; },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this._offset = coerceNumberProperty(value);
            this._setPadding();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NxTreeNodePaddingDirective.prototype, "indent", {
        /**
         * The indent for each level. Can be a number or a CSS string.
         * Default number 24px from material design menu sub-menu spec.
         */
        get: /**
         * The indent for each level. Can be a number or a CSS string.
         * Default number 24px from material design menu sub-menu spec.
         * @return {?}
         */
        function () { return this._indent; },
        set: /**
         * @param {?} indent
         * @return {?}
         */
        function (indent) {
            /** @type {?} */
            var value = indent;
            /** @type {?} */
            var units = 'px';
            if (typeof indent === 'string') {
                /** @type {?} */
                var parts = indent.split(cssUnitPattern);
                value = parts[0];
                units = parts[1] || units;
            }
            this.indentUnits = units;
            this._indent = coerceNumberProperty(value);
            this._setPadding();
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @return {?}
     */
    NxTreeNodePaddingDirective.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        this._destroyed.next();
        this._destroyed.complete();
    };
    /** The padding indent value for the tree node. Returns a string with px numbers if not null. */
    /**
     * The padding indent value for the tree node. Returns a string with px numbers if not null.
     * @return {?}
     */
    NxTreeNodePaddingDirective.prototype._paddingIndent = /**
     * The padding indent value for the tree node. Returns a string with px numbers if not null.
     * @return {?}
     */
    function () {
        /** @type {?} */
        var nodeLevel = (this._treeNode.data && this._tree.treeControl.getLevel)
            ? this._tree.treeControl.getLevel(this._treeNode.data)
            : null;
        /** @type {?} */
        var level = this._level || nodeLevel;
        return level ? "" + (level * this._indent + this._offset) + this.indentUnits : null;
    };
    /**
     * @return {?}
     */
    NxTreeNodePaddingDirective.prototype._setPadding = /**
     * @return {?}
     */
    function () {
        /** @type {?} */
        var padding = this._paddingIndent();
        /** @type {?} */
        var paddingProp = this._dir && this._dir.value === 'rtl' ? 'paddingRight' : 'paddingLeft';
        this._renderer.setStyle(this._element.nativeElement, paddingProp, padding);
    };
    NxTreeNodePaddingDirective.decorators = [
        { type: Directive, args: [{
                    selector: '[nxTreeNodePadding]',
                },] }
    ];
    /** @nocollapse */
    NxTreeNodePaddingDirective.ctorParameters = function () { return [
        { type: CdkTreeNode },
        { type: CdkTree },
        { type: Renderer2 },
        { type: ElementRef },
        { type: Directionality, decorators: [{ type: Optional }] }
    ]; };
    NxTreeNodePaddingDirective.propDecorators = {
        level: [{ type: Input, args: ['nxTreeNodePadding',] }],
        offset: [{ type: Input, args: ['nxTreeNodePaddingOffset',] }],
        indent: [{ type: Input, args: ['nxTreeNodePaddingIndent',] }]
    };
    return NxTreeNodePaddingDirective;
}());
if (false) {
    /**
     * Subject that emits when the component has been destroyed.
     * @type {?}
     * @private
     */
    NxTreeNodePaddingDirective.prototype._destroyed;
    /**
     * CSS units used for the indentation value.
     * @type {?}
     */
    NxTreeNodePaddingDirective.prototype.indentUnits;
    /** @type {?} */
    NxTreeNodePaddingDirective.prototype._level;
    /** @type {?} */
    NxTreeNodePaddingDirective.prototype._offset;
    /** @type {?} */
    NxTreeNodePaddingDirective.prototype._indent;
    /**
     * @type {?}
     * @private
     */
    NxTreeNodePaddingDirective.prototype._treeNode;
    /**
     * @type {?}
     * @private
     */
    NxTreeNodePaddingDirective.prototype._tree;
    /**
     * @type {?}
     * @private
     */
    NxTreeNodePaddingDirective.prototype._renderer;
    /**
     * @type {?}
     * @private
     */
    NxTreeNodePaddingDirective.prototype._element;
    /**
     * @type {?}
     * @private
     */
    NxTreeNodePaddingDirective.prototype._dir;
}

/**
 * @fileoverview added by tsickle
 * Generated from: toggle.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Wrapper for the CdkTree's toggle with NDBX design styles.
 * @template T
 */
var NxTreeNodeToggleDirective = /** @class */ (function (_super) {
    __extends(NxTreeNodeToggleDirective, _super);
    function NxTreeNodeToggleDirective() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.recursive = false;
        return _this;
    }
    NxTreeNodeToggleDirective.decorators = [
        { type: Directive, args: [{
                    selector: '[nxTreeNodeToggle]',
                    providers: [{ provide: CdkTreeNodeToggle, useExisting: NxTreeNodeToggleDirective }]
                },] }
    ];
    NxTreeNodeToggleDirective.propDecorators = {
        recursive: [{ type: Input, args: ['nxTreeNodeToggleRecursive',] }]
    };
    return NxTreeNodeToggleDirective;
}(CdkTreeNodeToggle));
if (false) {
    /** @type {?} */
    NxTreeNodeToggleDirective.prototype.recursive;
}

/**
 * @fileoverview added by tsickle
 * Generated from: tree.component.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Wrapper for the CdkTable with NDBX design styles.
 * @template T
 */
var NxTreeComponent = /** @class */ (function (_super) {
    __extends(NxTreeComponent, _super);
    function NxTreeComponent() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    NxTreeComponent.decorators = [
        { type: Component, args: [{
                    selector: 'nx-tree',
                    exportAs: 'nxTree',
                    template: "<ng-container nxTreeNodeOutlet></ng-container>",
                    host: {
                        'class': 'nx-tree',
                        'role': 'tree',
                    },
                    encapsulation: ViewEncapsulation.None,
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    providers: [{ provide: CdkTree, useExisting: NxTreeComponent }],
                    styles: [":host.nx-tree{display:block}.nx-tree__node{display:block;overflow:hidden}"]
                }] }
    ];
    NxTreeComponent.propDecorators = {
        _nodeOutlet: [{ type: ViewChild, args: [NxTreeNodeOutletDirective, { static: true },] }]
    };
    return NxTreeComponent;
}(CdkTree));
if (false) {
    /** @type {?} */
    NxTreeComponent.prototype._nodeOutlet;
}

/**
 * @fileoverview added by tsickle
 * Generated from: tree.module.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var NxTreeModule = /** @class */ (function () {
    function NxTreeModule() {
    }
    NxTreeModule.decorators = [
        { type: NgModule, args: [{
                    imports: [CdkTreeModule, CommonModule],
                    declarations: [NxTreeComponent, NxTreeNodeComponent, NxTreeNodeDefDirective,
                        NxTreeNodePaddingDirective, NxTreeNodeToggleDirective, NxTreeNodeOutletDirective],
                    exports: [NxTreeComponent, NxTreeNodeComponent, NxTreeNodeDefDirective,
                        NxTreeNodePaddingDirective, NxTreeNodeToggleDirective, NxTreeNodeOutletDirective]
                },] }
    ];
    return NxTreeModule;
}());

/**
 * @fileoverview added by tsickle
 * Generated from: public-api.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * Generated from: allianz-ngx-ndbx-tree.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

export { NxFlatTreeControl, NxTreeComponent, NxTreeFlatDataSource, NxTreeModule, NxTreeNodeComponent, NxTreeNodeDefDirective, NxTreeNodeOutletDirective, NxTreeNodePaddingDirective, NxTreeNodeToggleDirective };
//# sourceMappingURL=allianz-ngx-ndbx-tree.js.map
