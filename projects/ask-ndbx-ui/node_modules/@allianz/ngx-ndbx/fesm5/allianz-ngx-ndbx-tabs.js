import { Component, ViewChild, ViewContainerRef, Input, Directive, TemplateRef, ChangeDetectionStrategy, Inject, Optional, Host, ContentChild, ElementRef, EventEmitter, ChangeDetectorRef, Output, ContentChildren, ViewChildren, HostListener, SkipSelf, NgModule } from '@angular/core';
import { CdkPortal, PortalModule } from '@angular/cdk/portal';
import { CommonModule } from '@angular/common';
import { NxExpansionPanelComponent, NxAccordionDirective, NxAccordionModule } from '@allianz/ngx-ndbx/accordion';
import { Subject, Subscription, merge } from 'rxjs';
import { __extends, __spread } from 'tslib';
import { coerceBooleanProperty, coerceNumberProperty } from '@angular/cdk/coercion';
import { FocusKeyManager } from '@angular/cdk/a11y';
import { SPACE, ENTER, END, HOME } from '@angular/cdk/keycodes';

/**
 * @fileoverview added by tsickle
 * Generated from: tab-group-base.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * \@docs-private
 * @abstract
 */
var  /**
 * \@docs-private
 * @abstract
 */
NxTabGroupBase = /** @class */ (function () {
    function NxTabGroupBase() {
    }
    return NxTabGroupBase;
}());

/**
 * @fileoverview added by tsickle
 * Generated from: tab-header-outlet.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * \@docs-private
 */
var NxTabHeaderOutletComponent = /** @class */ (function () {
    function NxTabHeaderOutletComponent(_tabGroup) {
        this._tabGroup = _tabGroup;
    }
    /**
     * @return {?}
     */
    NxTabHeaderOutletComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        var _this = this;
        this._appearanceSubscription = ((/** @type {?} */ (this._tabGroup)))._appearanceChange.subscribe((/**
         * @return {?}
         */
        function () {
            _this.detach();
        }));
        this.attach();
    };
    /**
     * @return {?}
     */
    NxTabHeaderOutletComponent.prototype.attach = /**
     * @return {?}
     */
    function () {
        this._outlet.insert(this.content);
    };
    /**
     * @return {?}
     */
    NxTabHeaderOutletComponent.prototype.detach = /**
     * @return {?}
     */
    function () {
        /** @type {?} */
        var index = this._outlet.indexOf(this.content);
        if (index !== -1) {
            this._outlet.detach(index);
        }
    };
    /**
     * @return {?}
     */
    NxTabHeaderOutletComponent.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        this._appearanceSubscription.unsubscribe();
    };
    NxTabHeaderOutletComponent.decorators = [
        { type: Component, args: [{
                    selector: 'nx-tab-header-outlet',
                    template: '<ng-container #outlet></ng-container>'
                }] }
    ];
    /** @nocollapse */
    NxTabHeaderOutletComponent.ctorParameters = function () { return [
        { type: NxTabGroupBase }
    ]; };
    NxTabHeaderOutletComponent.propDecorators = {
        _outlet: [{ type: ViewChild, args: ['outlet', { static: true, read: ViewContainerRef },] }],
        content: [{ type: Input }]
    };
    return NxTabHeaderOutletComponent;
}());
if (false) {
    /** @type {?} */
    NxTabHeaderOutletComponent.prototype._outlet;
    /** @type {?} */
    NxTabHeaderOutletComponent.prototype.content;
    /**
     * @type {?}
     * @private
     */
    NxTabHeaderOutletComponent.prototype._appearanceSubscription;
    /**
     * @type {?}
     * @private
     */
    NxTabHeaderOutletComponent.prototype._tabGroup;
}

/**
 * @fileoverview added by tsickle
 * Generated from: tab-label.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * \@docs-private
 */
var NxTabLabelDirective = /** @class */ (function (_super) {
    __extends(NxTabLabelDirective, _super);
    function NxTabLabelDirective() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    NxTabLabelDirective.decorators = [
        { type: Directive, args: [{ selector: '[nxTabLabel]' },] }
    ];
    return NxTabLabelDirective;
}(CdkPortal));

/**
 * @fileoverview added by tsickle
 * Generated from: tab-content.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Decorates the `ng-template` tags and reads out the template from it.
 */
var NxTabContentDirective = /** @class */ (function () {
    function NxTabContentDirective(/** @docs-private */ template) {
        this.template = template;
    }
    NxTabContentDirective.decorators = [
        { type: Directive, args: [{ selector: '[nxTabContent]' },] }
    ];
    /** @nocollapse */
    NxTabContentDirective.ctorParameters = function () { return [
        { type: TemplateRef }
    ]; };
    return NxTabContentDirective;
}());
if (false) {
    /**
     * \@docs-private
     * @type {?}
     */
    NxTabContentDirective.prototype.template;
}

/**
 * @fileoverview added by tsickle
 * Generated from: tab.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var NxTabComponent = /** @class */ (function () {
    function NxTabComponent(_tabGroup) {
        this._tabGroup = _tabGroup;
        this._disabled = false;
        /**
         * Emits whenever the internal state of the tab changes.
         */
        this._stateChanges = new Subject();
        /**
         * Whether the tab is currently active.
         */
        this.isActive = false;
        if (!this._tabGroup) {
            throw Error("The nx-tab element has to be wrapped in a nx-tab-group to work.\n      Please provide a nx-tab-group element and place your tabs inside it.");
        }
    }
    Object.defineProperty(NxTabComponent.prototype, "templateLabel", {
        /**
         * Content for the tab label given by `<ng-template nxTabLabel>`.
         * @docs-private
         * */
        get: /**
         * Content for the tab label given by `<ng-template nxTabLabel>`.
         * \@docs-private
         *
         * @return {?}
         */
        function () { return this._templateLabel; },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            // Only update the templateLabel via query if there is actually
            // a nxTabLabel found. This works around an issue where a user may have
            // manually set `templateLabel` during creation mode, which would then get clobbered
            // by `undefined` when this query resolves.
            if (value) {
                this._templateLabel = value;
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NxTabComponent.prototype, "label", {
        /** Sets the label of the tab shown in the tablist. */
        get: /**
         * Sets the label of the tab shown in the tablist.
         * @return {?}
         */
        function () {
            return this._label;
        },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            if (this._label !== value) {
                this._label = value;
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NxTabComponent.prototype, "disabled", {
        /** Sets the tab to disabled. */
        get: /**
         * Sets the tab to disabled.
         * @return {?}
         */
        function () {
            return (this._tabGroup && ((/** @type {?} */ (this._tabGroup))).disabled) ?
                ((/** @type {?} */ (this._tabGroup))).disabled : this._disabled;
        },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            if (this._disabled !== value) {
                this._disabled = value;
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NxTabComponent.prototype, "headerViewRef", {
        /** @docs-private */
        get: /**
         * \@docs-private
         * @return {?}
         */
        function () {
            return this._headerViewRef;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NxTabComponent.prototype, "contentViewRef", {
        /** @docs-private */
        get: /**
         * \@docs-private
         * @return {?}
         */
        function () {
            // for lazy loading we only create the viewref when it is asked for
            if (!this._contentViewRef) {
                /** @type {?} */
                var contentTemplate = this._explicitContent || this._implicitContent;
                this._contentViewRef = contentTemplate.createEmbeddedView({});
            }
            return this._contentViewRef;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @param {?} changes
     * @return {?}
     */
    NxTabComponent.prototype.ngOnChanges = /**
     * @param {?} changes
     * @return {?}
     */
    function (changes) {
        if (changes.hasOwnProperty('label') || changes.hasOwnProperty('disabled')) {
            this._stateChanges.next();
        }
    };
    /**
     * @return {?}
     */
    NxTabComponent.prototype.ngAfterContentInit = /**
     * @return {?}
     */
    function () {
        if (this.templateLabel) {
            this._headerViewRef = this.templateLabel.createEmbeddedView({});
        }
    };
    /**
     * @return {?}
     */
    NxTabComponent.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        this._stateChanges.complete();
        this._contentViewRef.destroy();
        if (this._headerViewRef) {
            this._headerViewRef.destroy();
        }
    };
    NxTabComponent.decorators = [
        { type: Component, args: [{
                    selector: 'nx-tab',
                    exportAs: 'nxTab',
                    template: "<ng-template><ng-content></ng-content></ng-template>\n",
                    changeDetection: ChangeDetectionStrategy.OnPush
                }] }
    ];
    /** @nocollapse */
    NxTabComponent.ctorParameters = function () { return [
        { type: NxTabGroupBase, decorators: [{ type: Inject, args: [NxTabGroupBase,] }, { type: Optional }, { type: Host }] }
    ]; };
    NxTabComponent.propDecorators = {
        templateLabel: [{ type: ContentChild, args: [NxTabLabelDirective, { read: TemplateRef, static: true },] }],
        _implicitContent: [{ type: ViewChild, args: [TemplateRef, { static: true },] }],
        _explicitContent: [{ type: ContentChild, args: [NxTabContentDirective, { read: TemplateRef, static: true },] }],
        label: [{ type: Input }],
        disabled: [{ type: Input }]
    };
    return NxTabComponent;
}());
if (false) {
    /**
     * @type {?}
     * @private
     */
    NxTabComponent.prototype._label;
    /**
     * @type {?}
     * @private
     */
    NxTabComponent.prototype._disabled;
    /**
     * Emits whenever the internal state of the tab changes.
     * @type {?}
     */
    NxTabComponent.prototype._stateChanges;
    /**
     * @type {?}
     * @private
     */
    NxTabComponent.prototype._templateLabel;
    /**
     * Template inside the NxTab view that contains an `<ng-content>`.
     * @type {?}
     */
    NxTabComponent.prototype._implicitContent;
    /**
     * Template provided in the tab content that will be used if present, used to enable lazy-loading
     * @type {?}
     */
    NxTabComponent.prototype._explicitContent;
    /**
     * @type {?}
     * @private
     */
    NxTabComponent.prototype._headerViewRef;
    /**
     * @type {?}
     * @private
     */
    NxTabComponent.prototype._contentViewRef;
    /**
     * Whether the tab is currently active.
     * @type {?}
     */
    NxTabComponent.prototype.isActive;
    /**
     * @type {?}
     * @private
     */
    NxTabComponent.prototype._tabGroup;
}

/**
 * @fileoverview added by tsickle
 * Generated from: tab-body.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * \@docs-private
 */
var NxTabBodyComponent = /** @class */ (function () {
    function NxTabBodyComponent(_tabGroup) {
        this._tabGroup = _tabGroup;
        this._active = false;
    }
    Object.defineProperty(NxTabBodyComponent.prototype, "active", {
        get: /**
         * @return {?}
         */
        function () {
            return this._active;
        },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this._active = coerceBooleanProperty(value);
            if (this._active) {
                this.attach();
            }
            else {
                this.detach();
            }
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @return {?}
     */
    NxTabBodyComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        var _this = this;
        this._appearanceSubscription = ((/** @type {?} */ (this._tabGroup)))._appearanceChange.subscribe((/**
         * @return {?}
         */
        function () {
            _this.detach();
        }));
    };
    /**
     * @return {?}
     */
    NxTabBodyComponent.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        this._appearanceSubscription.unsubscribe();
    };
    /**
     * @return {?}
     */
    NxTabBodyComponent.prototype.attach = /**
     * @return {?}
     */
    function () {
        this._outlet.insert(this.tab.contentViewRef);
    };
    /**
     * @return {?}
     */
    NxTabBodyComponent.prototype.detach = /**
     * @return {?}
     */
    function () {
        /** @type {?} */
        var index = this._outlet.indexOf(this.tab.contentViewRef);
        if (index !== -1) {
            this._outlet.detach(index);
        }
    };
    NxTabBodyComponent.decorators = [
        { type: Component, args: [{
                    selector: 'nx-tab-body',
                    template: "<ng-container #outlet></ng-container>",
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    styles: [":host{display:block}"]
                }] }
    ];
    /** @nocollapse */
    NxTabBodyComponent.ctorParameters = function () { return [
        { type: NxTabGroupBase }
    ]; };
    NxTabBodyComponent.propDecorators = {
        _outlet: [{ type: ViewChild, args: ['outlet', { static: true, read: ViewContainerRef },] }],
        tab: [{ type: Input }],
        active: [{ type: Input }]
    };
    return NxTabBodyComponent;
}());
if (false) {
    /**
     * @type {?}
     * @private
     */
    NxTabBodyComponent.prototype._appearanceSubscription;
    /** @type {?} */
    NxTabBodyComponent.prototype._outlet;
    /** @type {?} */
    NxTabBodyComponent.prototype.tab;
    /**
     * @type {?}
     * @private
     */
    NxTabBodyComponent.prototype._active;
    /**
     * @type {?}
     * @private
     */
    NxTabBodyComponent.prototype._tabGroup;
}

/**
 * @fileoverview added by tsickle
 * Generated from: tab-label-wrapper.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * \@docs-private
 */
var NxTabLabelWrapperDirective = /** @class */ (function () {
    function NxTabLabelWrapperDirective(elementRef) {
        this.elementRef = elementRef;
        this._disabled = false;
    }
    Object.defineProperty(NxTabLabelWrapperDirective.prototype, "disabled", {
        /** Whether the tab group is disabled. Default: false. */
        get: /**
         * Whether the tab group is disabled. Default: false.
         * @return {?}
         */
        function () {
            return this._disabled;
        },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            /** @type {?} */
            var newValue = coerceBooleanProperty(value);
            if (this.disabled !== newValue) {
                this._disabled = newValue;
            }
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @return {?}
     */
    NxTabLabelWrapperDirective.prototype.focus = /**
     * @return {?}
     */
    function () {
        this.elementRef.nativeElement.focus();
    };
    NxTabLabelWrapperDirective.decorators = [
        { type: Directive, args: [{ selector: '[nxTabLabelWrapper]' },] }
    ];
    /** @nocollapse */
    NxTabLabelWrapperDirective.ctorParameters = function () { return [
        { type: ElementRef }
    ]; };
    NxTabLabelWrapperDirective.propDecorators = {
        disabled: [{ type: Input }]
    };
    return NxTabLabelWrapperDirective;
}());
if (false) {
    /**
     * @type {?}
     * @private
     */
    NxTabLabelWrapperDirective.prototype._disabled;
    /** @type {?} */
    NxTabLabelWrapperDirective.prototype.elementRef;
}

/**
 * @fileoverview added by tsickle
 * Generated from: tab-header.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * \@docs-private
 */
var NxTabHeaderComponent = /** @class */ (function () {
    function NxTabHeaderComponent(_changeDetectorRef) {
        this._changeDetectorRef = _changeDetectorRef;
        this._selectedIndex = 0;
        this._autoselect = true;
        this.selectFocusedIndex = new EventEmitter();
        this.indexFocused = new EventEmitter();
    }
    Object.defineProperty(NxTabHeaderComponent.prototype, "selectedIndex", {
        get: /**
         * @return {?}
         */
        function () {
            return this._selectedIndex;
        },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this._selectedIndex = value;
            if (this._keyManager) {
                this._keyManager.updateActiveItem(value);
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NxTabHeaderComponent.prototype, "focusIndex", {
        get: /**
         * @return {?}
         */
        function () {
            return this._keyManager ? this._keyManager.activeItemIndex : 0;
        },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            if (!this._isValidIndex(value) || this.focusIndex === value || !this._keyManager) {
                return;
            }
            this._keyManager.setActiveItem(value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NxTabHeaderComponent.prototype, "autoselect", {
        get: /**
         * @return {?}
         */
        function () {
            return this._autoselect;
        },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this._autoselect = value;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @return {?}
     */
    NxTabHeaderComponent.prototype.ngAfterContentInit = /**
     * @return {?}
     */
    function () {
        this._keyManager = new FocusKeyManager(this.labels).withHorizontalOrientation('ltr').withWrap();
        this._keyManager.updateActiveItem(0);
        this._changeDetectorRef.markForCheck();
    };
    /**
     * @private
     * @param {?} idx
     * @return {?}
     */
    NxTabHeaderComponent.prototype._isValidIndex = /**
     * @private
     * @param {?} idx
     * @return {?}
     */
    function (idx) {
        if (!this.labels) {
            return true;
        }
        /** @type {?} */
        var tab = this.labels.toArray()[idx] || null;
        return !!tab && !tab.disabled;
    };
    /**
     * Handles keyboard inputs on the labels
     * If autoselect is enabled the tab gets changed immediately
     * If autoselect is disabled only the focus changes but the user still has to select the item
     * by himself
     */
    /**
     * Handles keyboard inputs on the labels
     * If autoselect is enabled the tab gets changed immediately
     * If autoselect is disabled only the focus changes but the user still has to select the item
     * by himself
     * @param {?} event
     * @return {?}
     */
    NxTabHeaderComponent.prototype.handleKeydown = /**
     * Handles keyboard inputs on the labels
     * If autoselect is enabled the tab gets changed immediately
     * If autoselect is disabled only the focus changes but the user still has to select the item
     * by himself
     * @param {?} event
     * @return {?}
     */
    function (event) {
        switch (event.keyCode) {
            case HOME:
                this._keyManager.setFirstItemActive();
                event.preventDefault();
                break;
            case END:
                this._keyManager.setLastItemActive();
                event.preventDefault();
                break;
            case ENTER:
            case SPACE:
                this.selectFocusedIndex.emit(this._keyManager.activeItemIndex);
                event.preventDefault();
                break;
            default:
                this._keyManager.onKeydown(event);
        }
        if (this.autoselect) {
            this.selectFocusedIndex.emit(this._keyManager.activeItemIndex);
        }
        else if (event.keyCode !== ENTER && event.keyCode !== SPACE) {
            this.indexFocused.emit(this._keyManager.activeItemIndex);
        }
    };
    NxTabHeaderComponent.decorators = [
        { type: Component, args: [{
                    selector: 'nx-tab-header',
                    template: "<div class=\"nx-tab-header\" (keydown)=\"handleKeydown($event)\" role=\"tablist\">\n  <ng-content></ng-content>\n</div>",
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    styles: [":host{display:block}.nx-tab-header{display:flex;align-items:flex-end;justify-content:center;padding:60px 0}"]
                }] }
    ];
    /** @nocollapse */
    NxTabHeaderComponent.ctorParameters = function () { return [
        { type: ChangeDetectorRef }
    ]; };
    NxTabHeaderComponent.propDecorators = {
        selectedIndex: [{ type: Input }],
        autoselect: [{ type: Input }],
        selectFocusedIndex: [{ type: Output }],
        indexFocused: [{ type: Output }],
        labels: [{ type: ContentChildren, args: [NxTabLabelWrapperDirective,] }]
    };
    return NxTabHeaderComponent;
}());
if (false) {
    /**
     * @type {?}
     * @private
     */
    NxTabHeaderComponent.prototype._keyManager;
    /**
     * @type {?}
     * @private
     */
    NxTabHeaderComponent.prototype._selectedIndex;
    /**
     * @type {?}
     * @private
     */
    NxTabHeaderComponent.prototype._autoselect;
    /** @type {?} */
    NxTabHeaderComponent.prototype.selectFocusedIndex;
    /** @type {?} */
    NxTabHeaderComponent.prototype.indexFocused;
    /** @type {?} */
    NxTabHeaderComponent.prototype.labels;
    /**
     * @type {?}
     * @private
     */
    NxTabHeaderComponent.prototype._changeDetectorRef;
}

/**
 * @fileoverview added by tsickle
 * Generated from: tab-group.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var NxTabChangeEvent = /** @class */ (function () {
    function NxTabChangeEvent() {
    }
    return NxTabChangeEvent;
}());
if (false) {
    /**
     * The index of the selected or focused tab.
     * @type {?}
     */
    NxTabChangeEvent.prototype.index;
    /**
     * The component instance of the selected or focused tab.
     * @type {?}
     */
    NxTabChangeEvent.prototype.tab;
}
/** @type {?} */
var nextId = 0;
/** @type {?} */
var MOBILE_BREAKPOINT = 480;
var NxTabGroupComponent = /** @class */ (function () {
    function NxTabGroupComponent(_changeDetectorRef) {
        this._changeDetectorRef = _changeDetectorRef;
        this._selectedIndex = null;
        this._negative = false;
        this._disabled = false;
        this._indexToSelect = 0;
        this._autoselect = true;
        this._mobileAccordion = true;
        this._showAccordion = false;
        /**
         * An event emitted when the selected tab has changed.
         */
        this.selectedIndexChange = new EventEmitter();
        /**
         * An event emitted when the selected tab has changed.
         */
        this.selectedTabChange = new EventEmitter();
        /**
         * An event emitted when focus has changed within a tab group.
         *
         * **Note:** is not supported in mobile view.
         */
        this.focusChange = new EventEmitter();
        /**
         * Subscription to tabs being added/removed.
         */
        this._tabsSubscription = Subscription.EMPTY;
        /**
         * Subscription to changes in the tab labels.
         */
        this._tabLabelSubscription = Subscription.EMPTY;
        this._disabledTabsCache = [];
        this._appearanceChange = new Subject();
        this._groupId = nextId++;
    }
    Object.defineProperty(NxTabGroupComponent.prototype, "selectedIndex", {
        /** Sets the selected tab. */
        get: /**
         * Sets the selected tab.
         * @return {?}
         */
        function () {
            return this._selectedIndex;
        },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this._indexToSelect = coerceNumberProperty(value, null);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NxTabGroupComponent.prototype, "negative", {
        /** Whether the negative set of styling should be used. */
        get: /**
         * Whether the negative set of styling should be used.
         * @return {?}
         */
        function () {
            return this._negative;
        },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            if (value !== this._negative) {
                this._negative = coerceBooleanProperty(value);
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NxTabGroupComponent.prototype, "disabled", {
        /** Whether the tab group is disabled. Default: false. */
        get: /**
         * Whether the tab group is disabled. Default: false.
         * @return {?}
         */
        function () {
            return this._disabled;
        },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            if (value !== this._disabled) {
                this._disabled = coerceBooleanProperty(value);
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NxTabGroupComponent.prototype, "autoselect", {
        /** Whether the tab should be immediately selected on focus. */
        get: /**
         * Whether the tab should be immediately selected on focus.
         * @return {?}
         */
        function () {
            return this._autoselect;
        },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this._autoselect = coerceBooleanProperty(value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NxTabGroupComponent.prototype, "mobileAccordion", {
        /** Whether the tabs should to accordion on mobile viewports. */
        get: /**
         * Whether the tabs should to accordion on mobile viewports.
         * @return {?}
         */
        function () {
            return this._mobileAccordion;
        },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this._mobileAccordion = coerceBooleanProperty(value);
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @return {?}
     */
    NxTabGroupComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        this._switchAppearance(window.innerWidth);
    };
    /**
     * @return {?}
     */
    NxTabGroupComponent.prototype.ngAfterContentInit = /**
     * @return {?}
     */
    function () {
        var _this = this;
        this._subscribeToTabLabels();
        // Subscribe to changes in the amount of tabs, in order to be
        // able to re-render the content as new tabs are added or removed.
        this._tabsSubscription = this.tabs.changes.subscribe((/**
         * @return {?}
         */
        function () {
            /** @type {?} */
            var indexToSelect = _this._clampTabIndex(_this._indexToSelect);
            // Maintain the previously-selected tab if a new tab is added or removed and there is no
            // explicit change that selects a different tab.
            if (indexToSelect === _this._selectedIndex) {
                /** @type {?} */
                var tabs = _this.tabs.toArray();
                for (var i = 0; i < tabs.length; i++) {
                    if (tabs[i].isActive) {
                        // Assign both to the `_indexToSelect` and `_selectedIndex` so we don't fire a changed
                        // event, otherwise the consumer may end up in an infinite loop in some edge cases like
                        // adding a tab within the `selectedIndexChange` event.
                        _this._indexToSelect = _this._selectedIndex = i;
                        break;
                    }
                }
            }
            _this._changeDetectorRef.markForCheck();
        }));
    };
    /**
      * After the content is checked, this component knows what tabs have been defined
      * and what the selected index should be.
      */
    /**
     * After the content is checked, this component knows what tabs have been defined
     * and what the selected index should be.
     * @return {?}
     */
    NxTabGroupComponent.prototype.ngAfterContentChecked = /**
     * After the content is checked, this component knows what tabs have been defined
     * and what the selected index should be.
     * @return {?}
     */
    function () {
        var _this = this;
        // Don't clamp the `indexToSelect` immediately in the setter because it can happen that
        // the amount of tabs changes before the actual change detection runs.
        /** @type {?} */
        var indexToSelect = this._indexToSelect = this._clampTabIndex(this._indexToSelect);
        // If the active tab is disabled select the next focusable tab
        // if all tabs are disabled, allow selection of disabled active tab.
        if (!this.disabled && this.tabs.toArray()[indexToSelect].disabled) {
            /** @type {?} */
            var nextFocusable = this.tabs.toArray()
                .map((/**
             * @param {?} tab
             * @param {?} index
             * @return {?}
             */
            function (tab, index) { return ({ tab: tab, index: index }); }))
                .find((/**
             * @param {?} item
             * @return {?}
             */
            function (item) { return !item.tab.disabled; }));
            indexToSelect = nextFocusable ? nextFocusable.index : indexToSelect;
        }
        // If the index to select was disabled previously leave the selection on the current
        // so that the selection does not jump from one to another tab.
        if (this._disabledTabsCache[this._indexToSelect]) {
            this._indexToSelect = this.selectedIndex;
        }
        // If there is a change in selected index, emit a change event. Should not trigger if
        // the selected index has not yet been initialized.
        if (this._selectedIndex !== indexToSelect) {
            /** @type {?} */
            var isFirstRun_1 = this._selectedIndex == null;
            if (!isFirstRun_1) {
                this.selectedTabChange.emit(this._createChangeEvent(indexToSelect));
            }
            // Changing these values after change detection has run
            // since the checked content may contain references to them.
            Promise.resolve().then((/**
             * @return {?}
             */
            function () {
                _this.tabs.forEach((/**
                 * @param {?} tab
                 * @param {?} index
                 * @return {?}
                 */
                function (tab, index) { return tab.isActive = index === indexToSelect; }));
                if (!isFirstRun_1) {
                    _this.selectedIndexChange.emit(indexToSelect);
                }
            }));
        }
        if (this._selectedIndex !== indexToSelect) {
            this._selectedIndex = indexToSelect;
            this._changeDetectorRef.markForCheck();
        }
        // cache the previous disabled status of all tabs
        if (!this.disabled) {
            this.tabs.toArray().forEach((/**
             * @param {?} tab
             * @param {?} index
             * @return {?}
             */
            function (tab, index) { return _this._disabledTabsCache[index] = tab.disabled; }));
        }
    };
    /**
     * @return {?}
     */
    NxTabGroupComponent.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        this._tabsSubscription.unsubscribe();
        this._tabLabelSubscription.unsubscribe();
    };
    /**
    * Subscribes to changes in the tab labels. This is needed, because the @Input for the label is
    * on the NxTab component, whereas the data binding is inside the NxTabGroup. In order for the
    * binding to be updated, we need to subscribe to changes in it and trigger change detection
    * manually.
    */
    /**
     * Subscribes to changes in the tab labels. This is needed, because the \@Input for the label is
     * on the NxTab component, whereas the data binding is inside the NxTabGroup. In order for the
     * binding to be updated, we need to subscribe to changes in it and trigger change detection
     * manually.
     * @private
     * @return {?}
     */
    NxTabGroupComponent.prototype._subscribeToTabLabels = /**
     * Subscribes to changes in the tab labels. This is needed, because the \@Input for the label is
     * on the NxTab component, whereas the data binding is inside the NxTabGroup. In order for the
     * binding to be updated, we need to subscribe to changes in it and trigger change detection
     * manually.
     * @private
     * @return {?}
     */
    function () {
        var _this = this;
        if (this._tabLabelSubscription) {
            this._tabLabelSubscription.unsubscribe();
        }
        this._tabLabelSubscription = merge.apply(void 0, __spread(this.tabs.map((/**
         * @param {?} tab
         * @return {?}
         */
        function (tab) { return tab._stateChanges; })))).subscribe((/**
         * @return {?}
         */
        function () { return _this._changeDetectorRef.markForCheck(); }));
    };
    /** Clamps the given index to the bounds of 0 and the tabs length. */
    /**
     * Clamps the given index to the bounds of 0 and the tabs length.
     * @private
     * @param {?} index
     * @return {?}
     */
    NxTabGroupComponent.prototype._clampTabIndex = /**
     * Clamps the given index to the bounds of 0 and the tabs length.
     * @private
     * @param {?} index
     * @return {?}
     */
    function (index) {
        // Note the `|| 0`, which ensures that values like NaN can't get through
        // and which would otherwise throw the component into an infinite loop
        // (since Math.max(NaN, 0) === NaN).
        return Math.min(this.tabs.length - 1, Math.max(index || 0, 0));
    };
    /** @docs-private */
    /**
     * \@docs-private
     * @param {?} index
     * @return {?}
     */
    NxTabGroupComponent.prototype.focusChanged = /**
     * \@docs-private
     * @param {?} index
     * @return {?}
     */
    function (index) {
        this.focusChange.emit(this._createChangeEvent(index));
    };
    /**
     * @private
     * @param {?} index
     * @return {?}
     */
    NxTabGroupComponent.prototype._createChangeEvent = /**
     * @private
     * @param {?} index
     * @return {?}
     */
    function (index) {
        /** @type {?} */
        var event = new NxTabChangeEvent;
        event.index = index;
        if (this.tabs && this.tabs.length) {
            event.tab = this.tabs.toArray()[index];
        }
        return event;
    };
    /** @docs-private */
    /**
     * \@docs-private
     * @param {?} index
     * @return {?}
     */
    NxTabGroupComponent.prototype.handleClick = /**
     * \@docs-private
     * @param {?} index
     * @return {?}
     */
    function (index) {
        /** @type {?} */
        var clickedTab = this.tabs.toArray()[index];
        if (!this.disabled && !clickedTab.disabled) {
            this.selectedIndex = this.tabHeader.focusIndex = index;
        }
    };
    /**
     * @docs-private
     * Returns the tabindex for a tab label
     */
    /**
     * \@docs-private
     * Returns the tabindex for a tab label
     * @param {?} tab
     * @param {?} idx
     * @return {?}
     */
    NxTabGroupComponent.prototype.getTabIndex = /**
     * \@docs-private
     * Returns the tabindex for a tab label
     * @param {?} tab
     * @param {?} idx
     * @return {?}
     */
    function (tab, idx) {
        return (this.selectedIndex === idx && !tab.disabled && !this.disabled) ? 0 : -1;
    };
    /** Returns a unique id for each tab label element */
    /**
     * Returns a unique id for each tab label element
     * @param {?} i
     * @return {?}
     */
    NxTabGroupComponent.prototype._getTabLabelId = /**
     * Returns a unique id for each tab label element
     * @param {?} i
     * @return {?}
     */
    function (i) {
        return "nx-tab-label-" + this._groupId + "-" + i;
    };
    /** Returns a unique id for each tab content element */
    /**
     * Returns a unique id for each tab content element
     * @param {?} i
     * @return {?}
     */
    NxTabGroupComponent.prototype._getTabContentId = /**
     * Returns a unique id for each tab content element
     * @param {?} i
     * @return {?}
     */
    function (i) {
        return "nx-tab-content-" + this._groupId + "-" + i;
    };
    /** @docs-private */
    /**
     * \@docs-private
     * @param {?} event
     * @return {?}
     */
    NxTabGroupComponent.prototype.onResize = /**
     * \@docs-private
     * @param {?} event
     * @return {?}
     */
    function (event) {
        this._switchAppearance(event.target.innerWidth);
    };
    /**
     * @private
     * @param {?} viewPortWidth
     * @return {?}
     */
    NxTabGroupComponent.prototype._switchAppearance = /**
     * @private
     * @param {?} viewPortWidth
     * @return {?}
     */
    function (viewPortWidth) {
        if (!this._mobileAccordion) {
            return;
        }
        // notify the outlets to detach the viewrefs for header and body before
        // we switch the appearance. this way we only instantiate the templates
        // once so that they do not get destroyed during the switch
        if (viewPortWidth <= MOBILE_BREAKPOINT && !this._showAccordion) {
            this._appearanceChange.next();
            this._showMobileVersion();
        }
        else if (viewPortWidth > MOBILE_BREAKPOINT && this._showAccordion) {
            this._appearanceChange.next();
            this._showDesktopVersion();
        }
    };
    /**
     * @private
     * @return {?}
     */
    NxTabGroupComponent.prototype._showMobileVersion = /**
     * @private
     * @return {?}
     */
    function () {
        this._showAccordion = true;
        this._changeDetectorRef.markForCheck();
    };
    /**
     * @private
     * @return {?}
     */
    NxTabGroupComponent.prototype._showDesktopVersion = /**
     * @private
     * @return {?}
     */
    function () {
        this._showAccordion = false;
        this._changeDetectorRef.markForCheck();
    };
    /**
     * Emulate the tab change event when an accordion panel is opened in
     * mobile viewports.
     */
    /**
     * Emulate the tab change event when an accordion panel is opened in
     * mobile viewports.
     * @param {?} index
     * @return {?}
     */
    NxTabGroupComponent.prototype._panelOpened = /**
     * Emulate the tab change event when an accordion panel is opened in
     * mobile viewports.
     * @param {?} index
     * @return {?}
     */
    function (index) {
        this.selectedIndex = index;
    };
    NxTabGroupComponent.decorators = [
        { type: Component, args: [{
                    selector: 'nx-tab-group',
                    template: "\n\n  <ng-container *ngIf=\"!_showAccordion\">\n  <nx-tab-header\n      #tabHeader\n      [selectedIndex]=\"selectedIndex\"\n      (selectFocusedIndex)=\"selectedIndex = $event\"\n      (indexFocused)=\"focusChanged($event)\"\n      [autoselect]=\"autoselect\">\n    <button\n      type=\"button\"\n      nxTabLabelWrapper\n      *ngFor=\"let tab of tabs; let i = index\"\n      role=\"tab\"\n      (click)=\"handleClick(i)\"\n      class=\"nx-tab-header__item\"\n      [id]=\"_getTabLabelId(i)\"\n      [attr.aria-controls]=\"_getTabContentId(i)\"\n      [attr.aria-selected]=\"selectedIndex == i\"\n      [attr.tabindex]=\"getTabIndex(tab, i)\"\n      [disabled]=\"tab.disabled\"\n      [class.nx-tab-header__item--disabled]=\"tab.disabled\"\n      [class.nx-tab-header__item--active]=\"selectedIndex == i\">\n      <div class=\"nx-tab-label__content\">\n        <nx-tab-header-outlet *ngIf=\"tab.templateLabel\" [content]=\"tab.headerViewRef\"></nx-tab-header-outlet>\n        <ng-container *ngIf=\"!tab.templateLabel\">{{tab.label}}</ng-container>\n      </div>\n    </button>\n  </nx-tab-header>\n\n  <div class=\"nx-tab-body__container\">\n    <nx-tab-body\n      *ngFor=\"let tab of tabs; let i = index\"\n      [id]=\"_getTabContentId(i)\"\n      role=\"tabpanel\"\n      [attr.tabindex]=\"(selectedIndex == i) ? 0 : -1\"\n      class=\"nx-tab__body\"\n      [attr.aria-labelledby]=\"_getTabContentId(i)\"\n      [class.nx-tab__body--active]=\"selectedIndex == i\"\n      [tab]=\"tab\"\n      [active]=\"selectedIndex == i\"\n    ></nx-tab-body>\n  </div>\n</ng-container>\n\n<nx-accordion *ngIf=\"_showAccordion\" [negative]=\"negative\">\n  <nx-expansion-panel *ngFor=\"let tab of tabs; let i = index\"\n                      [expanded]=\"selectedIndex === i\"\n                      (opened)=\"_panelOpened(i)\"\n                      [disabled]=\"tab.disabled\"\n  >\n    <nx-expansion-panel-header>\n      <nx-expansion-panel-title>\n        <nx-tab-header-outlet *ngIf=\"tab.templateLabel\" [content]=\"tab.headerViewRef\"></nx-tab-header-outlet>\n        <ng-container *ngIf=\"!tab.templateLabel\">{{tab.label}}</ng-container>\n      </nx-expansion-panel-title>\n    </nx-expansion-panel-header>\n    <!-- this is not lazy loading this is a trick because the portal gets added here -->\n    <!-- so we could rewrite the tab-body component that it takes care of \"lazy loading\" and the\n    accordion wouldn't know about it -->\n    <!-- active=true is a trick because we want to keep the content attached for better user experience along with expansion panel animation.  -->\n    <nx-tab-body [active]=\"true\" [tab]=\"tab\"></nx-tab-body>\n  </nx-expansion-panel>\n</nx-accordion>\n",
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    host: {
                        '[class.is-negative]': 'negative',
                        '[class.is-disabled]': 'disabled'
                    },
                    providers: [{ provide: NxTabGroupBase, useExisting: NxTabGroupComponent }],
                    styles: [":host{display:block}.nx-tab-header__item{font-size:18px;font-size:var(--tab-item-font-size,18px);line-height:24px;line-height:var(--tab-item-line-height,24px);font-weight:400;font-weight:var(--tab-item-font-weight,400);letter-spacing:.2px;letter-spacing:var(--tab-item-letter-spacing,.2px);text-decoration:none;border:#006192;background:0 0;color:#006192;color:var(--tab-item-color,#006192);border-color:var(--tab-item-border-color,#006192);border-bottom-width:2px;border-bottom-style:solid;padding:0 16px 6px;outline:0;margin:0}.nx-tab-header__item:hover:not(.nx-tab-header__item--disabled){cursor:pointer}.nx-tab-header__item::-moz-focus-inner{border:0}.nx-tab-header__item--active{border-width:4px;font-weight:700;transition:font-weight .3s;padding-bottom:4px}@media screen and (-ms-high-contrast:active){.nx-tab-header__item{background-color:buttonFace;border-color:buttonText;color:buttonText;-ms-high-contrast-adjust:none}.nx-tab-header__item--active{background-color:highlight;color:highlightText;border-color:highlight}}.nx-tab-header__item--disabled{border-color:#c2c2c2;border-color:var(--tab-item-disabled-border-color,#c2c2c2);color:#c2c2c2;color:var(--tab-item-disabled-color,#c2c2c2);cursor:not-allowed}.nx-tab-label__content{display:inline-flex;justify-content:center;align-items:center;white-space:nowrap}:host-context([data-whatinput=keyboard]) .nx-tab-header__item:focus{box-shadow:0 0 0 2px #fff,0 0 0 6px #009de6;box-shadow:var(--focus-box-shadow,0 0 0 2px #fff,0 0 0 6px #009de6);border-radius:4px}@media screen and (-ms-high-contrast:active){.nx-tab-header__item--disabled{border-color:GrayText;background-color:buttonFace;color:GrayText}:host-context([data-whatinput=keyboard]) .nx-tab-header__item:focus{box-shadow:0 0 0 2px background,0 0 0 6px windowText}}:host(.is-negative){color:#fff}:host(.is-negative) .nx-tab-header__item{color:#fff;border-bottom-color:#fff}:host(.is-negative) .nx-tab-header__item.nx-tab-header__item--disabled{border-color:rgba(255,255,255,.4);border-color:var(--tab-item-disabled-border-color,#c2c2c2);color:var(--tab-item-disabled-color,#c2c2c2);cursor:not-allowed;color:rgba(255,255,255,.4);color:var(--tab-item-disabled-negative-color,rgba(255,255,255,.4));border-color:var(--tab-item-disabled-negative-color,rgba(255,255,255,.4))}@media screen and (-ms-high-contrast:active){:host(.is-negative) .nx-tab-header__item.nx-tab-header__item--disabled{border-color:GrayText;background-color:buttonFace;color:GrayText}}:host(.is-disabled){cursor:not-allowed}:host(.is-disabled.is-negative) .nx-tab-header__item{border-color:rgba(255,255,255,.4);border-color:var(--tab-item-disabled-border-color,#c2c2c2);color:var(--tab-item-disabled-color,#c2c2c2);cursor:not-allowed;color:rgba(255,255,255,.4);color:var(--tab-item-disabled-negative-color,rgba(255,255,255,.4));border-color:var(--tab-item-disabled-negative-color,rgba(255,255,255,.4))}@media screen and (-ms-high-contrast:active){:host(.is-disabled.is-negative) .nx-tab-header__item{border-color:GrayText;background-color:buttonFace}:host(.is-negative){color:buttonText}:host(.is-negative) .nx-tab-header__item{color:buttonText;border-bottom-color:buttonText}:host(.is-negative) .nx-tab-header__item--active{background-color:highlight;color:highlightText;border-color:highlight;-ms-high-contrast-adjust:none}:host(.is-disabled.is-negative) .nx-tab-header__item{color:GrayText;border-bottom-color:GrayText}}"]
                }] }
    ];
    /** @nocollapse */
    NxTabGroupComponent.ctorParameters = function () { return [
        { type: ChangeDetectorRef }
    ]; };
    NxTabGroupComponent.propDecorators = {
        tabs: [{ type: ContentChildren, args: [NxTabComponent,] }],
        tabBodyChildren: [{ type: ViewChildren, args: [NxTabBodyComponent,] }],
        tabHeader: [{ type: ViewChild, args: ['tabHeader', { static: false },] }],
        panels: [{ type: ViewChildren, args: [NxExpansionPanelComponent,] }],
        accordion: [{ type: ViewChild, args: [NxAccordionDirective, { static: false },] }],
        selectedIndex: [{ type: Input }],
        negative: [{ type: Input }],
        disabled: [{ type: Input }],
        autoselect: [{ type: Input }],
        mobileAccordion: [{ type: Input }],
        selectedIndexChange: [{ type: Output }],
        selectedTabChange: [{ type: Output }],
        focusChange: [{ type: Output }],
        onResize: [{ type: HostListener, args: ['window:resize', ['$event'],] }]
    };
    return NxTabGroupComponent;
}());
if (false) {
    /**
     * @type {?}
     * @private
     */
    NxTabGroupComponent.prototype._selectedIndex;
    /**
     * @type {?}
     * @private
     */
    NxTabGroupComponent.prototype._groupId;
    /**
     * @type {?}
     * @private
     */
    NxTabGroupComponent.prototype._negative;
    /**
     * @type {?}
     * @private
     */
    NxTabGroupComponent.prototype._disabled;
    /**
     * @type {?}
     * @private
     */
    NxTabGroupComponent.prototype._indexToSelect;
    /**
     * @type {?}
     * @private
     */
    NxTabGroupComponent.prototype._autoselect;
    /**
     * @type {?}
     * @private
     */
    NxTabGroupComponent.prototype._mobileAccordion;
    /** @type {?} */
    NxTabGroupComponent.prototype._showAccordion;
    /**
     * \@docs-private
     * @type {?}
     */
    NxTabGroupComponent.prototype.tabs;
    /**
     * \@docs-private
     * @type {?}
     */
    NxTabGroupComponent.prototype.tabBodyChildren;
    /**
     * \@docs-private
     * @type {?}
     */
    NxTabGroupComponent.prototype.tabHeader;
    /**
     * \@docs-private
     * @type {?}
     */
    NxTabGroupComponent.prototype.panels;
    /**
     * \@docs-private
     * @type {?}
     */
    NxTabGroupComponent.prototype.accordion;
    /**
     * An event emitted when the selected tab has changed.
     * @type {?}
     */
    NxTabGroupComponent.prototype.selectedIndexChange;
    /**
     * An event emitted when the selected tab has changed.
     * @type {?}
     */
    NxTabGroupComponent.prototype.selectedTabChange;
    /**
     * An event emitted when focus has changed within a tab group.
     *
     * **Note:** is not supported in mobile view.
     * @type {?}
     */
    NxTabGroupComponent.prototype.focusChange;
    /**
     * Subscription to tabs being added/removed.
     * @type {?}
     * @private
     */
    NxTabGroupComponent.prototype._tabsSubscription;
    /**
     * Subscription to changes in the tab labels.
     * @type {?}
     * @private
     */
    NxTabGroupComponent.prototype._tabLabelSubscription;
    /**
     * @type {?}
     * @private
     */
    NxTabGroupComponent.prototype._disabledTabsCache;
    /** @type {?} */
    NxTabGroupComponent.prototype._appearanceChange;
    /**
     * @type {?}
     * @private
     */
    NxTabGroupComponent.prototype._changeDetectorRef;
}

/**
 * @fileoverview added by tsickle
 * Generated from: tab-nav-bar.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var NxTabNavBarComponent = /** @class */ (function () {
    function NxTabNavBarComponent(_changeDetectorRef) {
        this._changeDetectorRef = _changeDetectorRef;
        this._negative = false;
        this._disabled = false;
    }
    Object.defineProperty(NxTabNavBarComponent.prototype, "negative", {
        get: /**
         * @return {?}
         */
        function () {
            return this._negative;
        },
        /** Whether the tab nav bar has negative styling. */
        set: /**
         * Whether the tab nav bar has negative styling.
         * @param {?} value
         * @return {?}
         */
        function (value) {
            /** @type {?} */
            var newValue = coerceBooleanProperty(value);
            if (newValue !== this.negative) {
                this._negative = newValue;
                this._changeDetectorRef.markForCheck();
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NxTabNavBarComponent.prototype, "disabled", {
        get: /**
         * @return {?}
         */
        function () {
            return this._disabled;
        },
        /** Whether the tab nav bar has disabled styling. */
        set: /**
         * Whether the tab nav bar has disabled styling.
         * @param {?} value
         * @return {?}
         */
        function (value) {
            /** @type {?} */
            var newValue = coerceBooleanProperty(value);
            if (newValue !== this.disabled) {
                this._disabled = newValue;
                this._changeDetectorRef.markForCheck();
            }
        },
        enumerable: true,
        configurable: true
    });
    NxTabNavBarComponent.decorators = [
        { type: Component, args: [{
                    selector: 'nx-tab-nav-bar',
                    template: "<ng-content></ng-content>",
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    host: {
                        '[class.is-negative]': 'negative',
                        '[class.is-disabled]': 'disabled',
                        'role': 'navigation',
                    },
                    styles: [":host{display:flex;align-items:flex-end;justify-content:center}:host ::ng-deep a.nx-tab-link{font-size:18px;font-size:var(--tab-item-font-size,18px);line-height:24px;line-height:var(--tab-item-line-height,24px);font-weight:400;font-weight:var(--tab-item-font-weight,400);letter-spacing:.2px;letter-spacing:var(--tab-item-letter-spacing,.2px);text-decoration:none;border:#006192;background:0 0;color:#006192;color:var(--tab-item-color,#006192);border-color:var(--tab-item-border-color,#006192);border-bottom-width:2px;border-bottom-style:solid;padding:0 16px 6px;outline:0;margin:0}:host ::ng-deep a.nx-tab-link.is-active{border-width:4px;font-weight:700;transition:font-weight .3s;padding-bottom:4px}@media screen and (-ms-high-contrast:active){:host ::ng-deep a.nx-tab-link{background-color:buttonFace;border-color:buttonText;color:buttonText;-ms-high-contrast-adjust:none}:host ::ng-deep a.nx-tab-link.is-active{background-color:highlight;color:highlightText;border-color:highlight}}:host(.is-negative){color:#fff}:host(.is-negative) ::ng-deep a.nx-tab-link{color:#fff;border-bottom-color:#fff}:host(.is-negative) ::ng-deep a.nx-tab-link.is-disabled{color:rgba(255,255,255,.4);color:var(--tab-item-disabled-negative-color,rgba(255,255,255,.4));border-color:rgba(255,255,255,.4);border-color:var(--tab-item-disabled-negative-color,rgba(255,255,255,.4))}:host ::ng-deep a.nx-tab-link.is-disabled{border-color:#c2c2c2;border-color:var(--tab-item-disabled-border-color,#c2c2c2);color:#c2c2c2;color:var(--tab-item-disabled-color,#c2c2c2);cursor:not-allowed}@media screen and (-ms-high-contrast:active){:host(.is-negative) ::ng-deep a.nx-tab-link.is-active{background-color:highlight;color:highlightText;border-color:windowFrame}:host ::ng-deep a.nx-tab-link.is-disabled{border-color:GrayText;background-color:buttonFace;color:GrayText}}:host(.is-disabled){cursor:not-allowed}:host(.is-disabled.is-negative) ::ng-deep a.nx-tab-link{color:rgba(255,255,255,.4);color:var(--tab-item-disabled-negative-color,rgba(255,255,255,.4));border-color:rgba(255,255,255,.4);border-color:var(--tab-item-disabled-negative-color,rgba(255,255,255,.4))}:host-context([data-whatinput=keyboard]) ::ng-deep .nx-tab-link:not(.is-disabled):focus{box-shadow:0 0 0 2px #fff,0 0 0 6px #009de6;box-shadow:var(--focus-box-shadow,0 0 0 2px #fff,0 0 0 6px #009de6);border-radius:4px}@media screen and (-ms-high-contrast:active){:host-context([data-whatinput=keyboard]) ::ng-deep .nx-tab-link:not(.is-disabled):focus{box-shadow:0 0 0 2px background,0 0 0 6px windowText}:host(.is-negative){color:buttonText}:host(.is-negative) ::ng-deep a.nx-tab-link{color:buttonText;border-bottom-color:buttonText}:host(.is-negative) ::ng-deep a.nx-tab-link.is-active{background-color:highlight;color:highlightText;border-color:highlight}:host(.is-negative) ::ng-deep a.nx-tab-link.is-disabled{color:GrayText;border-bottom-color:GrayText}}"]
                }] }
    ];
    /** @nocollapse */
    NxTabNavBarComponent.ctorParameters = function () { return [
        { type: ChangeDetectorRef }
    ]; };
    NxTabNavBarComponent.propDecorators = {
        negative: [{ type: Input }],
        disabled: [{ type: Input }]
    };
    return NxTabNavBarComponent;
}());
if (false) {
    /**
     * @type {?}
     * @private
     */
    NxTabNavBarComponent.prototype._negative;
    /**
     * @type {?}
     * @private
     */
    NxTabNavBarComponent.prototype._disabled;
    /**
     * @type {?}
     * @private
     */
    NxTabNavBarComponent.prototype._changeDetectorRef;
}
var NxTabLinkDirective = /** @class */ (function () {
    function NxTabLinkDirective(_tabNavBar) {
        this._tabNavBar = _tabNavBar;
        this._active = false;
        this._disabled = false;
        if (!this._tabNavBar) {
            throw Error("The nx-tab-link element has to be wrapped in a nx-tab-nav-bar to work.");
        }
    }
    Object.defineProperty(NxTabLinkDirective.prototype, "active", {
        /** Whether the tab link is active and has the active styling. */
        get: /**
         * Whether the tab link is active and has the active styling.
         * @return {?}
         */
        function () {
            return this._active;
        },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            /** @type {?} */
            var newValue = coerceBooleanProperty(value);
            if (newValue !== this._active) {
                this._active = value;
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NxTabLinkDirective.prototype, "disabled", {
        /** Whether the tab link is disabled. Default: false. */
        get: /**
         * Whether the tab link is disabled. Default: false.
         * @return {?}
         */
        function () {
            return (this._tabNavBar && this._tabNavBar.disabled) ? this._tabNavBar.disabled : this._disabled;
        },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            /** @type {?} */
            var newValue = coerceBooleanProperty(value);
            if (newValue !== this._disabled) {
                this._disabled = value;
            }
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @return {?}
     */
    NxTabLinkDirective.prototype._getTabIndex = /**
     * @return {?}
     */
    function () {
        return (this.disabled) ? '-1' : '0';
    };
    NxTabLinkDirective.decorators = [
        { type: Directive, args: [{
                    selector: '[nxTabLink]',
                    host: {
                        '[class.nx-tab-link]': 'true',
                        '[class.is-active]': 'active',
                        '[class.is-disabled]': 'disabled',
                        '[attr.aria-current]': 'active',
                        '[attr.tabindex]': '_getTabIndex()',
                        '[attr.aria-disabled]': 'disabled.toString()',
                    }
                },] }
    ];
    /** @nocollapse */
    NxTabLinkDirective.ctorParameters = function () { return [
        { type: NxTabNavBarComponent, decorators: [{ type: Optional }, { type: SkipSelf }] }
    ]; };
    NxTabLinkDirective.propDecorators = {
        active: [{ type: Input }],
        disabled: [{ type: Input }]
    };
    return NxTabLinkDirective;
}());
if (false) {
    /**
     * @type {?}
     * @private
     */
    NxTabLinkDirective.prototype._active;
    /**
     * @type {?}
     * @private
     */
    NxTabLinkDirective.prototype._disabled;
    /**
     * @type {?}
     * @private
     */
    NxTabLinkDirective.prototype._tabNavBar;
}

/**
 * @fileoverview added by tsickle
 * Generated from: tabs.module.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var NxTabsModule = /** @class */ (function () {
    function NxTabsModule() {
    }
    NxTabsModule.decorators = [
        { type: NgModule, args: [{
                    imports: [
                        CommonModule,
                        PortalModule,
                        NxAccordionModule
                    ],
                    exports: [
                        NxTabComponent,
                        NxTabGroupComponent,
                        NxTabLabelDirective,
                        NxTabLabelWrapperDirective,
                        NxTabHeaderComponent,
                        NxTabBodyComponent,
                        NxTabNavBarComponent,
                        NxTabLinkDirective,
                        NxTabContentDirective
                    ],
                    declarations: [
                        NxTabComponent,
                        NxTabGroupComponent,
                        NxTabLabelDirective,
                        NxTabLabelWrapperDirective,
                        NxTabHeaderComponent,
                        NxTabBodyComponent,
                        NxTabNavBarComponent,
                        NxTabLinkDirective,
                        NxTabContentDirective,
                        NxTabHeaderOutletComponent
                    ],
                    providers: [],
                },] }
    ];
    return NxTabsModule;
}());

/**
 * @fileoverview added by tsickle
 * Generated from: public-api.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * Generated from: allianz-ngx-ndbx-tabs.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

export { NxTabBodyComponent, NxTabChangeEvent, NxTabComponent, NxTabContentDirective, NxTabGroupComponent, NxTabHeaderComponent, NxTabLabelDirective, NxTabLinkDirective, NxTabNavBarComponent, NxTabsModule, NxTabGroupBase as a, NxTabLabelWrapperDirective as b, NxTabHeaderOutletComponent as c };
//# sourceMappingURL=allianz-ngx-ndbx-tabs.js.map
