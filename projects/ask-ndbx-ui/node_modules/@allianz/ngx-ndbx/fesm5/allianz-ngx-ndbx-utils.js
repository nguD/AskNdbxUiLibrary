import { __spread } from 'tslib';
import { Injectable, ɵɵdefineInjectable } from '@angular/core';

/**
 * @fileoverview added by tsickle
 * Generated from: utils.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @param {?} value
 * @return {?}
 */
function isString(value) {
    return typeof value === 'string';
}
/**
 * @param {?} str
 * @param {?=} length
 * @param {?=} padCharacter
 * @return {?}
 */
function pad(str, length, padCharacter) {
    if (length === void 0) { length = 2; }
    if (padCharacter === void 0) { padCharacter = '0'; }
    if (!isString(str) || str.length >= length) {
        return str;
    }
    while (str.length < length) {
        str = padCharacter + str;
    }
    return str;
}
// DATE -> YYYY-MM-DD
/**
 * @param {?} date
 * @return {?}
 */
function formatDate(date) {
    /** @type {?} */
    var dateOfBirth = [
        String(date.getFullYear()),
        pad(String(date.getMonth() + 1)),
        pad(String(date.getDate()))
    ].join('-');
    return dateOfBirth;
}
/**
 * @param {?} date
 * @return {?}
 */
function formatDateHuman(date) {
    /** @type {?} */
    var dateOfBirth = [
        pad(String(date.getDate())),
        pad(String(date.getMonth() + 1)),
        String(date.getFullYear())
    ].join('-');
    return dateOfBirth;
}
/*
  Purpose of this function is to allow a list of short keywords
  expand to longer bem class names with will then be applied to the classname value.

  This function will map a list of keys to values in a MAPPING list.
  Whatever value is found will replace the keyword.
  Every keyword not found will just transfered wiithmout modifying.
*/
/**
 * @param {?} value
 * @param {?=} DEFAULTS
 * @param {?=} MAPPING
 * @return {?}
 */
function mapClassNames(value, DEFAULTS, MAPPING) {
    if (DEFAULTS === void 0) { DEFAULTS = []; }
    if (MAPPING === void 0) { MAPPING = {}; }
    /** @type {?} */
    var sanitizedList = __spread(DEFAULTS);
    if (typeof value === 'string') {
        /** @type {?} */
        var mappedClasses = getClassNameList(value, MAPPING);
        sanitizedList = __spread(sanitizedList, mappedClasses);
    }
    return sanitizedList.join(' ').trim();
}
/**
 * @param {?} value
 * @param {?=} MAPPING
 * @return {?}
 */
function getClassNameList(value, MAPPING) {
    if (MAPPING === void 0) { MAPPING = {}; }
    /** @type {?} */
    var mappedClasses = [];
    if (typeof value === 'string') {
        /** @type {?} */
        var classNames = value.split(' ');
        /** @type {?} */
        var keys_1 = Object.keys(MAPPING);
        mappedClasses = classNames.map((/**
         * @param {?} className
         * @return {?}
         */
        function (className) {
            if (keys_1.indexOf(className) > -1) {
                return MAPPING[className];
            }
            else {
                return className;
            }
        }));
    }
    return mappedClasses;
}
/**
 * @param {?} renderer
 * @param {?} element
 * @param {?} classes
 * @return {?}
 */
function appendClasses(renderer, element, classes) {
    if (renderer && element && classes) {
        classes.split(' ').forEach((/**
         * @param {?} item
         * @return {?}
         */
        function (item) {
            renderer.addClass(element.nativeElement, item);
        }));
    }
}
/**
 * @param {?} renderer
 * @param {?} element
 * @param {?} classes
 * @return {?}
 */
function removeClasses(renderer, element, classes) {
    if (renderer && element && classes) {
        classes.split(' ').forEach((/**
         * @param {?} item
         * @return {?}
         */
        function (item) {
            renderer.removeClass(element.nativeElement, item);
        }));
    }
}
// YYYY-MM-DD -> DATE
/**
 * @param {?} dateString
 * @return {?}
 */
function parseDate(dateString) {
    return new Date(dateString);
}
// Manually compose a font shorthand defintion as it's not
// guaranteed to be given by the computed style object.
/**
 * @param {?} style
 * @return {?}
 */
function getFontShorthand(style) {
    var font = style.font, fontStyle = style.fontStyle, fontVariant = style.fontVariant, fontWeight = style.fontWeight, fontSize = style.fontSize, lineHeight = style.lineHeight, fontFamily = style.fontFamily;
    if (font.length > 0) {
        return font;
    }
    return fontStyle + " " + fontVariant + " " + fontWeight + " " + fontSize + "/" + lineHeight + " " + fontFamily;
}
/**
 * @param {?} number
 * @return {?}
 */
function numberOfDecimals(number) {
    /** @type {?} */
    var parsed = Number(number);
    if (Number.isNaN(parsed) || Number.isInteger(parsed)) {
        return 0;
    }
    /** @type {?} */
    var match = (parsed.toString()).match(/(?:\.(\d+))?(?:[eE]([+-]?\d+))?$/);
    if (!match[1]) {
        return 0;
    }
    return match[1].length;
}
/**
 * @param {?} value
 * @param {?=} min
 * @param {?=} max
 * @return {?}
 */
function clamp(value, min, max) {
    if (min === void 0) { min = 0; }
    if (max === void 0) { max = 1; }
    return Math.max(min, Math.min(max, value));
}
/**
 * Provider that defines when form controls have an error.
 */
var ErrorStateMatcher = /** @class */ (function () {
    function ErrorStateMatcher() {
    }
    /**
     * @param {?} control
     * @param {?} form
     * @return {?}
     */
    ErrorStateMatcher.prototype.isErrorState = /**
     * @param {?} control
     * @param {?} form
     * @return {?}
     */
    function (control, form) {
        return !!(control && control.invalid && (control.touched || (form && form.submitted)));
    };
    ErrorStateMatcher.decorators = [
        { type: Injectable, args: [{ providedIn: 'root' },] }
    ];
    /** @nocollapse */ ErrorStateMatcher.ngInjectableDef = ɵɵdefineInjectable({ factory: function ErrorStateMatcher_Factory() { return new ErrorStateMatcher(); }, token: ErrorStateMatcher, providedIn: "root" });
    return ErrorStateMatcher;
}());

/**
 * @fileoverview added by tsickle
 * Generated from: public-api.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * Generated from: allianz-ngx-ndbx-utils.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

export { ErrorStateMatcher, appendClasses, clamp, formatDate, formatDateHuman, getClassNameList, getFontShorthand, isString, mapClassNames, numberOfDecimals, pad, parseDate, removeClasses };
//# sourceMappingURL=allianz-ngx-ndbx-utils.js.map
