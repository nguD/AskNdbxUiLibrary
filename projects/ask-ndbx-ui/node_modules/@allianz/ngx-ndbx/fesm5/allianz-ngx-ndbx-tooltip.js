import { trigger, state, style, transition, animate } from '@angular/animations';
import { Component, ChangeDetectionStrategy, ChangeDetectorRef, ElementRef, InjectionToken, Directive, ViewContainerRef, NgZone, Optional, Inject, Input, NgModule } from '@angular/core';
import { Subject } from 'rxjs';
import { __spread, __assign } from 'tslib';
import { AriaDescriber, FocusMonitor, A11yModule } from '@angular/cdk/a11y';
import { Directionality } from '@angular/cdk/bidi';
import { coerceBooleanProperty } from '@angular/cdk/coercion';
import { ESCAPE } from '@angular/cdk/keycodes';
import { Overlay, OverlayModule } from '@angular/cdk/overlay';
import { Platform } from '@angular/cdk/platform';
import { ComponentPortal } from '@angular/cdk/portal';
import { ScrollDispatcher } from '@angular/cdk/scrolling';
import { takeUntil, take } from 'rxjs/operators';
import { CommonModule } from '@angular/common';

/**
 * @fileoverview added by tsickle
 * Generated from: tooltip-animations.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Animations used by NxTooltip.
 * \@docs-private
 * @type {?}
 */
var nxTooltipAnimations = {
    /**
     * Animation that transitions a tooltip in and out.
     */
    tooltipState: trigger('state', [
        state('initial, void, hidden', style({ opacity: 0 })),
        state('visible', style({ opacity: 1 })),
        transition('* => visible', animate('70ms cubic-bezier(0, 0, 0.2, 1)', style({ opacity: 1 }))),
        transition('* => hidden', animate('70ms cubic-bezier(0, 0, 0.2, 1)', style({ opacity: 0 }))),
    ])
};

/**
 * @fileoverview added by tsickle
 * Generated from: tooltip.component.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Internal component that wraps the tooltip's content.
 * \@docs-private
 */
var NxTooltipComponent = /** @class */ (function () {
    function NxTooltipComponent(_changeDetectorRef, elementRef) {
        this._changeDetectorRef = _changeDetectorRef;
        this.elementRef = elementRef;
        /**
         * The timeout ID of any current timer set to show the tooltip
         */
        this._showTimeoutId = null;
        /**
         * The timeout ID of any current timer set to hide the tooltip
         */
        this._hideTimeoutId = null;
        this._visibility = 'initial';
        this._position = 'bottom';
        this._arrowStyle = {};
        /**
         * Whether interactions on the page should close the tooltip
         */
        this._closeOnInteraction = false;
        /**
         * Subject for notifying that the tooltip has been hidden from the view
         */
        this._onHide = new Subject();
    }
    Object.defineProperty(NxTooltipComponent.prototype, "message", {
        get: /**
         * @return {?}
         */
        function () {
            return this._message;
        },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this._message = value;
            this._changeDetectorRef.markForCheck();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NxTooltipComponent.prototype, "visibility", {
        /** Property watched by the animation framework to show or hide the tooltip */
        get: /**
         * Property watched by the animation framework to show or hide the tooltip
         * @return {?}
         */
        function () {
            return this._visibility;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NxTooltipComponent.prototype, "position", {
        /* @docs-private */
        get: /* @docs-private */
        /**
         * @return {?}
         */
        function () {
            return this._position;
        },
        /* @docs-private */
        set: /* @docs-private */
        /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this._position = value;
            this._changeDetectorRef.markForCheck();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NxTooltipComponent.prototype, "arrowStyle", {
        /* @docs-private */
        get: /* @docs-private */
        /**
         * @return {?}
         */
        function () {
            return this._arrowStyle;
        },
        /* @docs-private */
        set: /* @docs-private */
        /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this._arrowStyle = value;
            this._changeDetectorRef.markForCheck();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NxTooltipComponent.prototype, "arrowClass", {
        /* @docs-private */
        get: /* @docs-private */
        /**
         * @return {?}
         */
        function () {
            return "nx-tooltip__arrow--" + this.position;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Shows the tooltip with an aninxion originating from the provided origin
     * @param delay Amount of milliseconds to the delay showing the tooltip.
     */
    /**
     * Shows the tooltip with an aninxion originating from the provided origin
     * @param {?} delay Amount of milliseconds to the delay showing the tooltip.
     * @return {?}
     */
    NxTooltipComponent.prototype.show = /**
     * Shows the tooltip with an aninxion originating from the provided origin
     * @param {?} delay Amount of milliseconds to the delay showing the tooltip.
     * @return {?}
     */
    function (delay) {
        var _this = this;
        // Cancel the delayed hide if it is scheduled
        if (this._hideTimeoutId) {
            clearTimeout(this._hideTimeoutId);
            this._hideTimeoutId = null;
        }
        // Body interactions should cancel the tooltip if there is a delay in showing.
        this._closeOnInteraction = true;
        this._showTimeoutId = window.setTimeout((/**
         * @return {?}
         */
        function () {
            _this._visibility = 'visible';
            _this._showTimeoutId = null;
            // Mark for check so if any parent component has set the
            // ChangeDetectionStrategy to OnPush it will be checked anyways
            _this._changeDetectorRef.markForCheck();
        }), delay);
    };
    /**
     * Begins the animation to hide the tooltip after the provided delay in ms.
     * @param delay Amount of milliseconds to delay showing the tooltip.
     */
    /**
     * Begins the animation to hide the tooltip after the provided delay in ms.
     * @param {?} delay Amount of milliseconds to delay showing the tooltip.
     * @return {?}
     */
    NxTooltipComponent.prototype.hide = /**
     * Begins the animation to hide the tooltip after the provided delay in ms.
     * @param {?} delay Amount of milliseconds to delay showing the tooltip.
     * @return {?}
     */
    function (delay) {
        var _this = this;
        if (this._hideTimeoutId) {
            return;
        }
        // Cancel the delayed show if it is scheduled
        if (this._showTimeoutId) {
            clearTimeout(this._showTimeoutId);
            this._showTimeoutId = null;
        }
        this._hideTimeoutId = window.setTimeout((/**
         * @return {?}
         */
        function () {
            _this._visibility = 'hidden';
            _this._hideTimeoutId = null;
            // Mark for check so if any parent component has set the
            // ChangeDetectionStrategy to OnPush it will be checked anyways
            _this._changeDetectorRef.markForCheck();
        }), delay);
    };
    /** Returns an observable that notifies when the tooltip has been hidden from view. */
    /**
     * Returns an observable that notifies when the tooltip has been hidden from view.
     * @return {?}
     */
    NxTooltipComponent.prototype.afterHidden = /**
     * Returns an observable that notifies when the tooltip has been hidden from view.
     * @return {?}
     */
    function () {
        return this._onHide.asObservable();
    };
    /** Whether the tooltip is being displayed. */
    /**
     * Whether the tooltip is being displayed.
     * @return {?}
     */
    NxTooltipComponent.prototype.isVisible = /**
     * Whether the tooltip is being displayed.
     * @return {?}
     */
    function () {
        return this.visibility === 'visible';
    };
    /** Whether the tooltip started a delay to be shown/hidden */
    /**
     * Whether the tooltip started a delay to be shown/hidden
     * @return {?}
     */
    NxTooltipComponent.prototype.isDelayed = /**
     * Whether the tooltip started a delay to be shown/hidden
     * @return {?}
     */
    function () {
        return this._showTimeoutId !== null || this._hideTimeoutId !== null;
    };
    /**
     * @return {?}
     */
    NxTooltipComponent.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        this._onHide.complete();
    };
    /**
     * @return {?}
     */
    NxTooltipComponent.prototype._animationStart = /**
     * @return {?}
     */
    function () {
        this._closeOnInteraction = false;
    };
    /**
     * @param {?} event
     * @return {?}
     */
    NxTooltipComponent.prototype._animationDone = /**
     * @param {?} event
     * @return {?}
     */
    function (event) {
        /** @type {?} */
        var toState = (/** @type {?} */ (event.toState));
        if (toState === 'hidden' && !this.isVisible()) {
            this._onHide.next();
        }
        if (toState === 'visible' || toState === 'hidden') {
            this._closeOnInteraction = true;
        }
    };
    /**
     * Interactions on the HTML body should close the tooltip immediately.
     */
    /**
     * Interactions on the HTML body should close the tooltip immediately.
     * @return {?}
     */
    NxTooltipComponent.prototype._handleBodyInteraction = /**
     * Interactions on the HTML body should close the tooltip immediately.
     * @return {?}
     */
    function () {
        if (this._closeOnInteraction) {
            this.hide(0);
        }
    };
    NxTooltipComponent.decorators = [
        { type: Component, args: [{
                    selector: 'nx-tooltip-component',
                    template: "<div class=\"nx-tooltip\"\n    [@state]=\"visibility\"\n    (@state.start)=\"_animationStart()\"\n    (@state.done)=\"_animationDone($event)\">\n  <div [ngClass]=\"arrowClass\" class=\"nx-tooltip__arrow\" [ngStyle]=\"arrowStyle\"></div>\n  {{ message }}\n</div>\n",
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    animations: [nxTooltipAnimations.tooltipState],
                    host: {
                        // Forces the element to have a layout in IE and Edge. This fixes issues where the element
                        // won't be rendered if the aninxions are disabled or there is no web aninxions polyfill.
                        '[style.zoom]': 'visibility === "visible" ? 1 : null',
                        '(body:click)': 'this._handleBodyInteraction()',
                        'aria-hidden': 'true',
                    },
                    styles: ["::ng-deep .nx-tooltip-panel{pointer-events:none!important}:host{padding:16px}.nx-tooltip{font-size:14px;font-size:var(--tooltip-font-size,14px);line-height:20px;line-height:var(--tooltip-line-height,20px);font-weight:400;font-weight:var(--tooltip-font-weight,400);letter-spacing:.2px;letter-spacing:var(--tooltip-letter-spacing,.2px);color:#fff;color:var(--tooltip-text-color,#fff);background-color:#414141;background-color:var(--tooltip-background-color,#414141);border-radius:4px;border-radius:var(--tooltip-border-radius,4px);max-width:408px;padding:8px 16px}.nx-tooltip__arrow{position:absolute;width:12px;height:12px;background-color:inherit;z-index:-1;opacity:inherit}.nx-tooltip__arrow--top{transform:translate(-50%,0) rotate(45deg);bottom:10px}.nx-tooltip__arrow--right{transform:translate(0,-50%) rotate(45deg);left:10px}.nx-tooltip__arrow--bottom{transform:translate(-50%,0) rotate(45deg);top:10px}.nx-tooltip__arrow--left{transform:translate(0,-50%) rotate(45deg);right:10px}@media screen and (-ms-high-contrast:active){.nx-tooltip__arrow{border:1px solid windowText}.nx-tooltip{border:1px solid windowText;border-radius:4px}}"]
                }] }
    ];
    /** @nocollapse */
    NxTooltipComponent.ctorParameters = function () { return [
        { type: ChangeDetectorRef },
        { type: ElementRef }
    ]; };
    return NxTooltipComponent;
}());
if (false) {
    /**
     * The timeout ID of any current timer set to show the tooltip
     * @type {?}
     * @private
     */
    NxTooltipComponent.prototype._showTimeoutId;
    /**
     * The timeout ID of any current timer set to hide the tooltip
     * @type {?}
     * @private
     */
    NxTooltipComponent.prototype._hideTimeoutId;
    /**
     * Message to display in the tooltip
     * @type {?}
     * @private
     */
    NxTooltipComponent.prototype._message;
    /**
     * @type {?}
     * @private
     */
    NxTooltipComponent.prototype._visibility;
    /**
     * @type {?}
     * @private
     */
    NxTooltipComponent.prototype._position;
    /** @type {?} */
    NxTooltipComponent.prototype._arrowStyle;
    /**
     * Whether interactions on the page should close the tooltip
     * @type {?}
     * @private
     */
    NxTooltipComponent.prototype._closeOnInteraction;
    /**
     * Subject for notifying that the tooltip has been hidden from the view
     * @type {?}
     * @private
     */
    NxTooltipComponent.prototype._onHide;
    /**
     * @type {?}
     * @private
     */
    NxTooltipComponent.prototype._changeDetectorRef;
    /** @type {?} */
    NxTooltipComponent.prototype.elementRef;
}

/**
 * @fileoverview added by tsickle
 * Generated from: tooltip.directive.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * CSS class that will be attached to the overlay panel.
 * \@docs-private
 * @type {?}
 */
var NX_TOOLTIP_PANEL_CLASS = 'nx-tooltip-panel';
/**
 * Creates an error to be thrown if the user supplied an invalid tooltip position.
 * \@docs-private
 * @param {?} position
 * @return {?}
 */
function getNxTooltipInvalidPositionError(position) {
    return Error("Tooltip position \"" + position + "\" is invalid.");
}
/**
 * Default `nxTooltip` options that can be overridden.
 * @record
 */
function NxTooltipDefaultOptions() { }
if (false) {
    /**
     * The default delay in ms before showing the tooltip after show is called
     * @type {?}
     */
    NxTooltipDefaultOptions.prototype.showDelay;
    /**
     * The default delay in ms before hiding the tooltip after hide is called
     * @type {?}
     */
    NxTooltipDefaultOptions.prototype.hideDelay;
    /**
     * The default delay in ms before hiding the tooltip on touch devices
     * @type {?}
     */
    NxTooltipDefaultOptions.prototype.touchendHideDelay;
    /**
     * The default position of the tooltip
     * @type {?|undefined}
     */
    NxTooltipDefaultOptions.prototype.position;
}
/**
 * Injection token to be used to override the default options for `nxTooltip`.
 * @type {?}
 */
var NX_TOOLTIP_DEFAULT_OPTIONS = new InjectionToken('nx-tooltip-default-options', {
    providedIn: 'root',
    factory: NX_TOOLTIP_DEFAULT_OPTIONS_FACTORY
});
/**
 * @return {?}
 */
function NX_TOOLTIP_DEFAULT_OPTIONS_FACTORY() {
    return {
        showDelay: 200,
        hideDelay: 200,
        touchendHideDelay: 1500,
    };
}
/** @type {?} */
var fallbacks = [
    {
        originX: 'center',
        originY: 'bottom',
        overlayX: 'center',
        overlayY: 'top',
    },
    {
        originX: 'end',
        originY: 'center',
        overlayX: 'start',
        overlayY: 'center',
    },
    {
        originX: 'start',
        originY: 'center',
        overlayX: 'end',
        overlayY: 'center',
    },
    {
        originX: 'center',
        originY: 'top',
        overlayX: 'center',
        overlayY: 'bottom',
    }
];
/**
 * Directive that attaches a tooltip to the host element.
 *
 */
var NxTooltipDirective = /** @class */ (function () {
    function NxTooltipDirective(_overlay, _elementRef, _scrollDispatcher, _viewContainerRef, _ngZone, platform, _ariaDescriber, _focusMonitor, _dir, _defaultOptions) {
        var _this = this;
        this._overlay = _overlay;
        this._elementRef = _elementRef;
        this._scrollDispatcher = _scrollDispatcher;
        this._viewContainerRef = _viewContainerRef;
        this._ngZone = _ngZone;
        this._ariaDescriber = _ariaDescriber;
        this._focusMonitor = _focusMonitor;
        this._dir = _dir;
        this._defaultOptions = _defaultOptions;
        this._position = 'bottom';
        this._disabled = false;
        /**
         * The default delay in ms before showing the tooltip after show is called
         */
        this.showDelay = this._defaultOptions.showDelay;
        /**
         * The default delay in ms before hiding the tooltip after hide is called
         */
        this.hideDelay = this._defaultOptions.hideDelay;
        this._message = '';
        this._manualListeners = new Map();
        /**
         * Emits when the component is destroyed.
         */
        this._destroyed = new Subject();
        this._scrollStrategy = this._overlay.scrollStrategies.reposition;
        /** @type {?} */
        var element = _elementRef.nativeElement;
        // The mouse events shouldn't be bound on mobile devices, because they can prevent the
        // first tap from firing its click event or can cause the tooltip to open for clicks.
        if (!platform.IOS && !platform.ANDROID) {
            this._manualListeners
                .set('mouseenter', (/**
             * @return {?}
             */
            function () { return _this.show(); }))
                .set('mouseleave', (/**
             * @return {?}
             */
            function () { return _this.hide(); }));
        }
        else {
            // Fall back to showing on `touchstart`, otherwise
            // there's no way for the user to trigger the tooltip on a touch device.
            this._manualListeners.set('touchstart', (/**
             * @return {?}
             */
            function () { return _this.show(); }));
        }
        this._manualListeners.forEach((/**
         * @param {?} listener
         * @param {?} event
         * @return {?}
         */
        function (listener, event) { return element.addEventListener(event, listener); }));
        _focusMonitor.monitor(_elementRef).pipe(takeUntil(this._destroyed)).subscribe((/**
         * @param {?} origin
         * @return {?}
         */
        function (origin) {
            // Note that the focus monitor runs outside the Angular zone.
            if (!origin) {
                _ngZone.run((/**
                 * @return {?}
                 */
                function () { return _this.hide(0); }));
            }
            else if (origin === 'keyboard') {
                _ngZone.run((/**
                 * @return {?}
                 */
                function () { return _this.show(); }));
            }
        }));
        if (_defaultOptions && _defaultOptions.position) {
            this.position = _defaultOptions.position;
        }
    }
    Object.defineProperty(NxTooltipDirective.prototype, "position", {
        /** Allows the user to define the position of the tooltip relative to the parent element */
        get: /**
         * Allows the user to define the position of the tooltip relative to the parent element
         * @return {?}
         */
        function () { return this._position; },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            if (value !== this._position) {
                this._position = value;
                if (this._overlayRef) {
                    this._updatePosition();
                    if (this._tooltipInstance) {
                        this._tooltipInstance.position = this._position;
                        this._tooltipInstance.show(0);
                    }
                    this._overlayRef.updatePosition();
                }
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NxTooltipDirective.prototype, "disabled", {
        /** Disables the display of the tooltip. */
        get: /**
         * Disables the display of the tooltip.
         * @return {?}
         */
        function () { return this._disabled; },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this._disabled = coerceBooleanProperty(value);
            // If tooltip is disabled, hide immediately.
            if (this._disabled) {
                this.hide(0);
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NxTooltipDirective.prototype, "message", {
        /** The message to be displayed in the tooltip */
        get: /**
         * The message to be displayed in the tooltip
         * @return {?}
         */
        function () {
            return this._message;
        },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this._ariaDescriber.removeDescription(this._elementRef.nativeElement, this._message);
            // If the message is not a string (e.g. number), convert it to a string and trim it.
            this._message = value != null ? ("" + value).trim() : '';
            if (!this._message && this._isTooltipVisible()) {
                this.hide(0);
            }
            else {
                this._updateTooltipMessage();
                this._ariaDescriber.describe(this._elementRef.nativeElement, this.message);
            }
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Setup styling-specific things
     */
    /**
     * Setup styling-specific things
     * @return {?}
     */
    NxTooltipDirective.prototype.ngOnInit = /**
     * Setup styling-specific things
     * @return {?}
     */
    function () {
        /** @type {?} */
        var element = this._elementRef.nativeElement;
        /** @type {?} */
        var elementStyle = (/** @type {?} */ (element.style));
        /** @type {?} */
        var userSelect = element.nodeName === 'INPUT' || element.nodeName === 'TEXTAREA' ? '' : 'none';
        elementStyle.webkitUserSelect = elementStyle.userSelect = elementStyle.msUserSelect = userSelect;
    };
    /**
     * Dispose the tooltip when destroyed.
     */
    /**
     * Dispose the tooltip when destroyed.
     * @return {?}
     */
    NxTooltipDirective.prototype.ngOnDestroy = /**
     * Dispose the tooltip when destroyed.
     * @return {?}
     */
    function () {
        var _this = this;
        if (this._overlayRef) {
            this._overlayRef.dispose();
            this._tooltipInstance = null;
        }
        // Clean up the event listeners set in the constructor
        this._manualListeners.forEach((/**
         * @param {?} listener
         * @param {?} event
         * @return {?}
         */
        function (listener, event) {
            _this._elementRef.nativeElement.removeEventListener(event, listener);
        }));
        this._manualListeners.clear();
        this._destroyed.next();
        this._destroyed.complete();
        this._ariaDescriber.removeDescription(this._elementRef.nativeElement, this.message);
        this._focusMonitor.stopMonitoring(this._elementRef);
    };
    /** Shows the tooltip after the delay in ms, defaults to tooltip-delay-show or 0ms if no input */
    /**
     * Shows the tooltip after the delay in ms, defaults to tooltip-delay-show or 0ms if no input
     * @param {?=} delay
     * @return {?}
     */
    NxTooltipDirective.prototype.show = /**
     * Shows the tooltip after the delay in ms, defaults to tooltip-delay-show or 0ms if no input
     * @param {?=} delay
     * @return {?}
     */
    function (delay) {
        var _this = this;
        if (delay === void 0) { delay = this.showDelay; }
        if (this.disabled || !this.message || (this._isTooltipVisible() &&
            !this._tooltipInstance.isDelayed())) {
            return;
        }
        /** @type {?} */
        var overlayRef = this._createOverlay();
        this._detach();
        this._portal = this._portal || new ComponentPortal(NxTooltipComponent, this._viewContainerRef);
        this._embeddedViewRef = overlayRef.attach(this._portal);
        this._tooltipInstance = this._embeddedViewRef.instance;
        this._tooltipInstance.afterHidden()
            .pipe(takeUntil(this._destroyed))
            .subscribe((/**
         * @return {?}
         */
        function () { return _this._detach(); }));
        this._updateTooltipMessage();
        this._tooltipInstance.show(delay);
    };
    /** Hides the tooltip after the delay in ms, defaults to tooltip-delay-hide or 0ms if no input */
    /**
     * Hides the tooltip after the delay in ms, defaults to tooltip-delay-hide or 0ms if no input
     * @param {?=} delay
     * @return {?}
     */
    NxTooltipDirective.prototype.hide = /**
     * Hides the tooltip after the delay in ms, defaults to tooltip-delay-hide or 0ms if no input
     * @param {?=} delay
     * @return {?}
     */
    function (delay) {
        if (delay === void 0) { delay = this.hideDelay; }
        if (this._tooltipInstance) {
            this._tooltipInstance.hide(delay);
        }
    };
    /** Shows/hides the tooltip */
    /**
     * Shows/hides the tooltip
     * @return {?}
     */
    NxTooltipDirective.prototype.toggle = /**
     * Shows/hides the tooltip
     * @return {?}
     */
    function () {
        this._isTooltipVisible() ? this.hide() : this.show();
    };
    /** Returns true if the tooltip is currently visible to the user */
    /**
     * Returns true if the tooltip is currently visible to the user
     * @return {?}
     */
    NxTooltipDirective.prototype._isTooltipVisible = /**
     * Returns true if the tooltip is currently visible to the user
     * @return {?}
     */
    function () {
        return !!this._tooltipInstance && this._tooltipInstance.isVisible();
    };
    /** Handles the keydown events on the host element. */
    /**
     * Handles the keydown events on the host element.
     * @param {?} e
     * @return {?}
     */
    NxTooltipDirective.prototype._handleKeydown = /**
     * Handles the keydown events on the host element.
     * @param {?} e
     * @return {?}
     */
    function (e) {
        if (this._isTooltipVisible() && e.keyCode === ESCAPE) {
            e.stopPropagation();
            this.hide(0);
        }
    };
    /** Handles the touchend events on the host element. */
    /**
     * Handles the touchend events on the host element.
     * @return {?}
     */
    NxTooltipDirective.prototype._handleTouchend = /**
     * Handles the touchend events on the host element.
     * @return {?}
     */
    function () {
        this.hide(this._defaultOptions.touchendHideDelay);
    };
    /** Create the overlay config and position strategy */
    /**
     * Create the overlay config and position strategy
     * @private
     * @return {?}
     */
    NxTooltipDirective.prototype._createOverlay = /**
     * Create the overlay config and position strategy
     * @private
     * @return {?}
     */
    function () {
        var _this = this;
        if (this._overlayRef && !!this._overlayRef.hostElement) {
            return this._overlayRef;
        }
        /** @type {?} */
        var scrollableAncestors = this._scrollDispatcher.getAncestorScrollContainers(this._elementRef);
        // Create connected position strategy that listens for scroll events to reposition.
        /** @type {?} */
        var strategy = this._overlay.position()
            .flexibleConnectedTo(this._elementRef)
            .withLockedPosition(true)
            .withFlexibleDimensions(false)
            .withPush(true);
        strategy.withScrollableContainers(scrollableAncestors);
        strategy.positionChanges.pipe(takeUntil(this._destroyed)).subscribe((/**
         * @param {?} change
         * @return {?}
         */
        function (change) {
            if (_this._tooltipInstance) {
                /** @type {?} */
                var pair_1 = change.connectionPair;
                _this._ngZone.run((/**
                 * @return {?}
                 */
                function () { return _this._positionArrow(pair_1); }));
                if (change.scrollableViewProperties.isOverlayClipped && _this._tooltipInstance.isVisible()) {
                    // After position changes occur and the overlay is clipped by
                    // a parent scrollable then close the tooltip.
                    _this._ngZone.run((/**
                     * @return {?}
                     */
                    function () { return _this.hide(0); }));
                }
            }
        }));
        this._overlayRef = this._overlay.create({
            direction: this._dir,
            positionStrategy: strategy,
            panelClass: NX_TOOLTIP_PANEL_CLASS,
            scrollStrategy: this._scrollStrategy(),
            disposeOnNavigation: true
        });
        this._updatePosition();
        this._overlayRef.detachments()
            .pipe(takeUntil(this._destroyed))
            .subscribe((/**
         * @return {?}
         */
        function () { return _this._detach(); }));
        return this._overlayRef;
    };
    /** Detaches the currently-attached tooltip. */
    /**
     * Detaches the currently-attached tooltip.
     * @private
     * @return {?}
     */
    NxTooltipDirective.prototype._detach = /**
     * Detaches the currently-attached tooltip.
     * @private
     * @return {?}
     */
    function () {
        if (this._overlayRef && this._overlayRef.hasAttached()) {
            this._overlayRef.detach();
        }
        this._tooltipInstance = null;
    };
    /** Updates the position of the current tooltip. */
    /**
     * Updates the position of the current tooltip.
     * @private
     * @return {?}
     */
    NxTooltipDirective.prototype._updatePosition = /**
     * Updates the position of the current tooltip.
     * @private
     * @return {?}
     */
    function () {
        /** @type {?} */
        var position = (/** @type {?} */ (this._overlayRef.getConfig().positionStrategy));
        /** @type {?} */
        var origin = this._getOrigin();
        /** @type {?} */
        var overlay = this._getOverlayPosition();
        position.withPositions(__spread([
            __assign({}, origin, overlay)
        ], fallbacks));
    };
    /**
     * Returns the origin position and a fallback position based on the user's position preference.
     * The fallback position is the inverse of the origin (e.g. `'left' -> 'right'`).
     */
    /**
     * Returns the origin position and a fallback position based on the user's position preference.
     * The fallback position is the inverse of the origin (e.g. `'left' -> 'right'`).
     * @return {?}
     */
    NxTooltipDirective.prototype._getOrigin = /**
     * Returns the origin position and a fallback position based on the user's position preference.
     * The fallback position is the inverse of the origin (e.g. `'left' -> 'right'`).
     * @return {?}
     */
    function () {
        /** @type {?} */
        var isLtr = !this._dir || this._dir.value === 'ltr';
        /** @type {?} */
        var position = this.position;
        /** @type {?} */
        var originPosition;
        if (position === 'top' || position === 'bottom') {
            originPosition = {
                originX: 'center',
                originY: position
            };
        }
        else if ((position === 'left' && isLtr) ||
            (position === 'right' && !isLtr)) {
            originPosition = { originX: 'start', originY: 'center' };
        }
        else if ((position === 'right' && isLtr) ||
            (position === 'left' && !isLtr)) {
            originPosition = { originX: 'end', originY: 'center' };
        }
        else {
            throw getNxTooltipInvalidPositionError(position);
        }
        return originPosition;
    };
    /** Returns the overlay position and a fallback position based on the user's preference */
    /**
     * Returns the overlay position and a fallback position based on the user's preference
     * @return {?}
     */
    NxTooltipDirective.prototype._getOverlayPosition = /**
     * Returns the overlay position and a fallback position based on the user's preference
     * @return {?}
     */
    function () {
        /** @type {?} */
        var isLtr = !this._dir || this._dir.value === 'ltr';
        /** @type {?} */
        var position = this.position;
        /** @type {?} */
        var overlayPosition;
        if (position === 'top') {
            overlayPosition = { overlayX: 'center', overlayY: 'bottom' };
        }
        else if (position === 'bottom') {
            overlayPosition = { overlayX: 'center', overlayY: 'top' };
        }
        else if ((position === 'left' && isLtr) ||
            (position === 'right' && !isLtr)) {
            overlayPosition = { overlayX: 'end', overlayY: 'center' };
        }
        else if ((position === 'right' && isLtr) ||
            (position === 'left' && !isLtr)) {
            overlayPosition = { overlayX: 'start', overlayY: 'center' };
        }
        else {
            throw getNxTooltipInvalidPositionError(position);
        }
        return overlayPosition;
    };
    /** Updates the tooltip message and repositions the overlay according to the new message length */
    /**
     * Updates the tooltip message and repositions the overlay according to the new message length
     * @private
     * @return {?}
     */
    NxTooltipDirective.prototype._updateTooltipMessage = /**
     * Updates the tooltip message and repositions the overlay according to the new message length
     * @private
     * @return {?}
     */
    function () {
        var _this = this;
        // Must wait for the message to be painted to the tooltip so that the overlay can properly
        // calculate the correct positioning based on the size of the text.
        if (this._tooltipInstance) {
            this._tooltipInstance.message = this.message;
            this._ngZone.onMicrotaskEmpty.asObservable().pipe(take(1), takeUntil(this._destroyed)).subscribe((/**
             * @return {?}
             */
            function () {
                if (_this._tooltipInstance) {
                    _this._overlayRef.updatePosition();
                }
            }));
        }
    };
    /**
     * @private
     * @param {?} pair
     * @return {?}
     */
    NxTooltipDirective.prototype._positionArrow = /**
     * @private
     * @param {?} pair
     * @return {?}
     */
    function (pair) {
        /** @type {?} */
        var parentElementPositionX = this._elementRef.nativeElement.getBoundingClientRect().left;
        /** @type {?} */
        var parentElementWidth = this._elementRef.nativeElement.getBoundingClientRect().width / 2;
        /** @type {?} */
        var overlayElementLeftOffset = this._overlayRef
            .overlayElement
            .getBoundingClientRect()
            .left;
        // calculation for x position of the parent element. In this case, overlay left offset is the one thing to consider.
        /** @type {?} */
        var targetPosition = (parentElementPositionX + parentElementWidth) - (overlayElementLeftOffset);
        if (pair.originX === pair.overlayX) {
            /** @type {?} */
            var direction = 'left';
            /** @type {?} */
            var arrowStyle = {};
            arrowStyle[direction] = targetPosition + 'px';
            this._tooltipInstance.arrowStyle = arrowStyle;
        }
        if (pair.originX === 'end' && pair.overlayX === 'start') {
            this._tooltipInstance.arrowStyle = {
                top: '50%',
            };
            this._tooltipInstance.position = 'right';
        }
        else if (pair.originY === 'bottom' && pair.overlayY === 'top') {
            this._tooltipInstance.arrowStyle = {
                left: targetPosition + 'px',
            };
            this._tooltipInstance.position = 'bottom';
        }
        else if (pair.originX === 'start' && pair.overlayX === 'end') {
            this._tooltipInstance.arrowStyle = {
                top: '50%',
            };
            this._tooltipInstance.position = 'left';
        }
        else if (pair.originY === 'top' && pair.overlayY === 'bottom') {
            this._tooltipInstance.arrowStyle = {
                left: targetPosition + 'px',
            };
            this._tooltipInstance.position = 'top';
        }
    };
    NxTooltipDirective.decorators = [
        { type: Directive, args: [{
                    selector: '[nxTooltip]',
                    exportAs: 'nxTooltip',
                    host: {
                        '(keydown)': '_handleKeydown($event)',
                        '(touchend)': '_handleTouchend()',
                    },
                },] }
    ];
    /** @nocollapse */
    NxTooltipDirective.ctorParameters = function () { return [
        { type: Overlay },
        { type: ElementRef },
        { type: ScrollDispatcher },
        { type: ViewContainerRef },
        { type: NgZone },
        { type: Platform },
        { type: AriaDescriber },
        { type: FocusMonitor },
        { type: Directionality, decorators: [{ type: Optional }] },
        { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [NX_TOOLTIP_DEFAULT_OPTIONS,] }] }
    ]; };
    NxTooltipDirective.propDecorators = {
        position: [{ type: Input, args: ['nxTooltipPosition',] }],
        disabled: [{ type: Input, args: ['nxTooltipDisabled',] }],
        showDelay: [{ type: Input, args: ['nxTooltipShowDelay',] }],
        hideDelay: [{ type: Input, args: ['nxTooltipHideDelay',] }],
        message: [{ type: Input, args: ['nxTooltip',] }]
    };
    return NxTooltipDirective;
}());
if (false) {
    /** @type {?} */
    NxTooltipDirective.prototype._overlayRef;
    /** @type {?} */
    NxTooltipDirective.prototype._tooltipInstance;
    /**
     * @type {?}
     * @private
     */
    NxTooltipDirective.prototype._portal;
    /**
     * @type {?}
     * @private
     */
    NxTooltipDirective.prototype._position;
    /**
     * @type {?}
     * @private
     */
    NxTooltipDirective.prototype._disabled;
    /**
     * @type {?}
     * @private
     */
    NxTooltipDirective.prototype._scrollStrategy;
    /**
     * @type {?}
     * @private
     */
    NxTooltipDirective.prototype._embeddedViewRef;
    /**
     * The default delay in ms before showing the tooltip after show is called
     * @type {?}
     */
    NxTooltipDirective.prototype.showDelay;
    /**
     * The default delay in ms before hiding the tooltip after hide is called
     * @type {?}
     */
    NxTooltipDirective.prototype.hideDelay;
    /**
     * @type {?}
     * @private
     */
    NxTooltipDirective.prototype._message;
    /**
     * @type {?}
     * @private
     */
    NxTooltipDirective.prototype._manualListeners;
    /**
     * Emits when the component is destroyed.
     * @type {?}
     * @private
     */
    NxTooltipDirective.prototype._destroyed;
    /**
     * @type {?}
     * @private
     */
    NxTooltipDirective.prototype._overlay;
    /**
     * @type {?}
     * @private
     */
    NxTooltipDirective.prototype._elementRef;
    /**
     * @type {?}
     * @private
     */
    NxTooltipDirective.prototype._scrollDispatcher;
    /**
     * @type {?}
     * @private
     */
    NxTooltipDirective.prototype._viewContainerRef;
    /**
     * @type {?}
     * @private
     */
    NxTooltipDirective.prototype._ngZone;
    /**
     * @type {?}
     * @private
     */
    NxTooltipDirective.prototype._ariaDescriber;
    /**
     * @type {?}
     * @private
     */
    NxTooltipDirective.prototype._focusMonitor;
    /**
     * @type {?}
     * @private
     */
    NxTooltipDirective.prototype._dir;
    /**
     * @type {?}
     * @private
     */
    NxTooltipDirective.prototype._defaultOptions;
}

/**
 * @fileoverview added by tsickle
 * Generated from: tooltip.module.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var NxTooltipModule = /** @class */ (function () {
    function NxTooltipModule() {
    }
    NxTooltipModule.decorators = [
        { type: NgModule, args: [{
                    imports: [
                        A11yModule,
                        CommonModule,
                        OverlayModule
                    ],
                    exports: [NxTooltipDirective, NxTooltipComponent],
                    declarations: [NxTooltipDirective, NxTooltipComponent],
                    entryComponents: [NxTooltipComponent]
                },] }
    ];
    return NxTooltipModule;
}());

/**
 * @fileoverview added by tsickle
 * Generated from: public-api.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * Generated from: allianz-ngx-ndbx-tooltip.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

export { NX_TOOLTIP_DEFAULT_OPTIONS, NX_TOOLTIP_DEFAULT_OPTIONS_FACTORY, NX_TOOLTIP_PANEL_CLASS, NxTooltipComponent, NxTooltipDirective, NxTooltipModule, getNxTooltipInvalidPositionError, nxTooltipAnimations };
//# sourceMappingURL=allianz-ngx-ndbx-tooltip.js.map
