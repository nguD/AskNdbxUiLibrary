import { CommonModule } from '@angular/common';
import { Component, ChangeDetectionStrategy, Directive, ChangeDetectorRef, Input, EventEmitter, ElementRef, Output, ContentChildren, Injectable, Optional, NgModule } from '@angular/core';
import { NxIconModule } from '@allianz/ngx-ndbx/icon';
import { coerceBooleanProperty } from '@angular/cdk/coercion';
import { SPACE, ENTER } from '@angular/cdk/keycodes';
import { trigger, state, style, transition, animate } from '@angular/animations';
import { BehaviorSubject, Subject, combineLatest } from 'rxjs';
import { takeUntil, startWith, flatMap, map, distinctUntilChanged } from 'rxjs/operators';

/**
 * @fileoverview added by tsickle
 * Generated from: table-cell.component.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * This is a table cell.
 */
var NxTableCellComponent = /** @class */ (function () {
    function NxTableCellComponent() {
    }
    NxTableCellComponent.decorators = [
        { type: Component, args: [{
                    // tslint:disable-next-line:component-selector
                    selector: 'td[nxTableCell], td[nxCell]',
                    template: '<ng-content></ng-content>',
                    host: {
                        '[class.nx-table-cell]': 'true',
                    },
                    changeDetection: ChangeDetectionStrategy.OnPush
                }] }
    ];
    return NxTableCellComponent;
}());

/**
 * @fileoverview added by tsickle
 * Generated from: header-cell.directive.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * This is a table header cell.
 */
var NxHeaderCellDirective = /** @class */ (function () {
    function NxHeaderCellDirective() {
    }
    NxHeaderCellDirective.decorators = [
        { type: Directive, args: [{
                    selector: '[nxHeaderCell]',
                    host: {
                        '[class.nx-header-cell]': 'true'
                    }
                },] }
    ];
    return NxHeaderCellDirective;
}());

/**
 * @fileoverview added by tsickle
 * Generated from: table.component.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * This is a table.
 * The table supports a `zebra` and a `condensed` mode.
 */
var NxTableComponent = /** @class */ (function () {
    function NxTableComponent(_changeDetectorRef) {
        this._changeDetectorRef = _changeDetectorRef;
    }
    Object.defineProperty(NxTableComponent.prototype, "condensed", {
        get: /**
         * @return {?}
         */
        function () {
            return this._condensed;
        },
        /** Change the table mode to condensed  */
        set: /**
         * Change the table mode to condensed
         * @param {?} value
         * @return {?}
         */
        function (value) {
            /** @type {?} */
            var newValue = coerceBooleanProperty(value);
            if (value !== this._condensed) {
                this._condensed = newValue;
                this._changeDetectorRef.markForCheck();
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NxTableComponent.prototype, "zebra", {
        get: /**
         * @return {?}
         */
        function () {
            return this._zebra;
        },
        /** Change the table mode to zebra  */
        set: /**
         * Change the table mode to zebra
         * @param {?} value
         * @return {?}
         */
        function (value) {
            /** @type {?} */
            var newValue = coerceBooleanProperty(value);
            if (value !== this._zebra) {
                this._zebra = newValue;
                this._changeDetectorRef.markForCheck();
            }
        },
        enumerable: true,
        configurable: true
    });
    NxTableComponent.decorators = [
        { type: Component, args: [{
                    // tslint:disable-next-line:component-selector
                    selector: 'table[nxTable]',
                    template: '<ng-content></ng-content>',
                    host: {
                        'class': 'nx-table',
                        '[class.nx-table--condensed]': 'condensed',
                        '[class.nx-table--zebra]': 'zebra'
                    },
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    styles: [":host{border-spacing:0;border-bottom:2px solid #414141;border-bottom:2px solid var(--table-border-bottom-color,#414141);width:100%}::ng-deep .nx-header-cell{font-size:16px;font-size:var(--table-header-cell-font-size,16px);line-height:24px;line-height:var(--table-header-cell-line-height,24px);font-weight:600;font-weight:var(--table-header-cell-font-weight,600);letter-spacing:0;letter-spacing:var(--table-header-cell-letter-spacing,0);color:#414141;color:var(--table-header-cell-color,#414141);background:0 0;background:var(--table-header-cell-background-color,transparent);border-top:1px solid #d9d9d9;border-top:1px solid var(--table-header-border-top-color,#d9d9d9);border-bottom:2px solid #414141;border-bottom:2px solid var(--table-header-border-bottom-color,#414141);text-align:left;white-space:nowrap;vertical-align:top;padding:16px 16px 14px}::ng-deep .nx-header-cell:first-child{padding-left:8px}::ng-deep .nx-header-cell:last-child{padding-right:8px}::ng-deep .nx-table-row{background:0 0;background:var(--table-row-background-color,transparent)}::ng-deep .nx-table-cell{font-size:16px;font-size:var(--table-cell-font-size,16px);line-height:24px;line-height:var(--table-cell-line-height,24px);font-weight:400;font-weight:var(--table-cell-font-weight,400);letter-spacing:0;letter-spacing:var(--table-cell-letter-spacing,0);color:#414141;color:var(--table-cell-color,#414141);border-top:1px solid #d9d9d9;border-top:1px solid var(--table-cell-border-top-color,#d9d9d9);padding:16px 16px 15px}::ng-deep .nx-table-cell:first-child{padding-left:8px}::ng-deep .nx-table-cell:last-child{padding-right:8px}:host(.nx-table--condensed) ::ng-deep .nx-table-cell{padding-bottom:7px;padding-top:8px}:host(.nx-table--zebra) ::ng-deep .nx-table-cell{border-top:1px solid #f5f5f5;border-top:1px solid var(--zebra-table-cell-border-top-color,#f5f5f5)}:host(.nx-table--zebra) ::ng-deep .nx-table-cell--expandable{border-top:0}:host(.nx-table--condensed) ::ng-deep .nx-table-cell--expandable{padding-bottom:0;padding-top:0}:host(.nx-table--condensed) ::ng-deep .nx-table-cell--expandable .nx-table-cell__wrapper{padding-bottom:7px;padding-top:8px}::ng-deep .nx-expandable-table-cell{font-size:16px;font-size:var(--table-cell-font-size,16px);line-height:24px;line-height:var(--table-cell-line-height,24px);font-weight:400;font-weight:var(--table-cell-font-weight,400);letter-spacing:0;letter-spacing:var(--table-cell-letter-spacing,0);color:#414141;color:var(--table-cell-color,#414141)}::ng-deep .nx-expandable-table-cell__content{overflow:hidden}::ng-deep .nx-expandable-table-cell__wrapper{padding:16px}::ng-deep .nx-expandable-table-cell:first-child .nx-cell__wrapper{padding-left:8px}::ng-deep .nx-expandable-table-cell:last-child .nx-cell__wrapper{padding-right:8px}:host(.nx-table--condensed) ::ng-deep .nx-expandable-table-cell .nx-expandable-table-cell__wrapper{padding-bottom:7px;padding-top:8px}:host(.nx-table--zebra) ::ng-deep .nx-expandable-table-row:nth-child(4n){background:#f5f5f5;background:var(--zebra-table-even-row-background-color,#f5f5f5)}:host(.nx-table--zebra) ::ng-deep .nx-expandable-table-row:nth-child(4n)+.nx-table-row:not(.is-selected){background:0 0;background:var(--zebra-table-odd-row-background-color,transparent)}:host(.nx-table--zebra) ::ng-deep .nx-expandable-table-row:nth-child(4n+2){background:0 0;background:var(--zebra-table-odd-row-background-color,transparent)}:host(.nx-table--zebra) ::ng-deep .nx-expandable-table-row:nth-child(4n+2)+.nx-table-row:not(.is-selected){background:#f5f5f5;background:var(--zebra-table-even-row-background-color,#f5f5f5)}:host(.nx-table--zebra) ::ng-deep .nx-table-row:nth-child(2n){background:#f5f5f5;background:var(--zebra-table-even-row-background-color,#f5f5f5)}:host(.nx-table--zebra) ::ng-deep .nx-table-row.nx-table-row--selectable:not(.is-selected):hover{background:#ececec;background:var(--zebra-table-row-hover-background-color,#ececec)}:host(.nx-table--zebra) ::ng-deep .nx-table-row.nx-table-row--selectable:not(.is-selected):active{background:#d9d9d9;background:var(--zebra-table-row-active-background-color,#d9d9d9)}:host(.nx-table--zebra) ::ng-deep .nx-table-row.nx-table-row--selectable.is-selected:hover{background:#cfe9ee;background:var(--selectable-table-row-selected-hover-background-color,#cfe9ee)}::ng-deep .nx-table-row:first-child .nx-table-cell{border-top:0}::ng-deep .nx-table-row.nx-table-row--selectable{cursor:pointer}::ng-deep .nx-table-row.nx-table-row--selectable::-moz-focus-inner{border:0}::ng-deep .nx-table-row.nx-table-row--selectable:focus{outline:0}::ng-deep .nx-table-row.nx-table-row--selectable:not(.is-selected):hover{background:#f5f5f5;background:var(--selectable-table-row-hover-background-color,#f5f5f5)}::ng-deep .nx-table-row.nx-table-row--selectable:not(.is-selected):active{background:#f5f5f5;background:var(--selectable-table-row-active-background-color,#f5f5f5)}::ng-deep .nx-table-row.nx-table-row--selectable.is-selected:hover{background:#cfe9ee;background:var(--selectable-table-row-selected-hover-background-color,#cfe9ee)}::ng-deep .nx-table-row.is-selected,:host(.nx-table--zebra) ::ng-deep .nx-table-row.is-selected{background:#f1f9fa;background:var(--zebra-table-row-selected-background-color,#f1f9fa)}::ng-deep .nx-table-row.is-selected+.nx-expandable-table-row,:host(.nx-table--zebra) ::ng-deep .nx-table-row.is-selected+.nx-expandable-table-row{background:#f1f9fa;background:var(--zebra-table-row-selected-background-color,#f1f9fa)}::ng-deep .nx-table-row.is-selected+.nx-expandable-table-row+.nx-table-row>.nx-table-cell,::ng-deep .nx-table-row.is-selected+.nx-table-row>.nx-table-cell,::ng-deep .nx-table-row.is-selected>.nx-table-cell,:host(.nx-table--zebra) ::ng-deep .nx-table-row.is-selected+.nx-expandable-table-row+.nx-table-row>.nx-table-cell,:host(.nx-table--zebra) ::ng-deep .nx-table-row.is-selected+.nx-table-row>.nx-table-cell,:host(.nx-table--zebra) ::ng-deep .nx-table-row.is-selected>.nx-table-cell{border-color:#003781;border-color:var(--selectable-table-row-selected-border-color,#003781)}::ng-deep .nx-exandable-table-cell nx-checkbox,::ng-deep .nx-header-cell nx-checkbox,::ng-deep .nx-table-cell nx-checkbox{margin:0}::ng-deep .nx-exandable-table-cell nx-checkbox .nx-checkbox__label,::ng-deep .nx-header-cell nx-checkbox .nx-checkbox__label,::ng-deep .nx-table-cell nx-checkbox .nx-checkbox__label{padding:0}::ng-deep .nx-exandable-table-cell nx-taglist,::ng-deep .nx-header-cell nx-taglist,::ng-deep .nx-table-cell nx-taglist{margin:0}::ng-deep .nx-exandable-table-cell nx-taglist .nx-taglist__list-item,::ng-deep .nx-header-cell nx-taglist .nx-taglist__list-item,::ng-deep .nx-table-cell nx-taglist .nx-taglist__list-item{margin-bottom:0}::ng-deep .nx-exandable-table-cell button[nxbutton],::ng-deep .nx-header-cell button[nxbutton],::ng-deep .nx-table-cell button[nxbutton]{margin:0}::ng-deep .nx-exandable-table-cell nx-formfield .nx-formfield__wrapper,::ng-deep .nx-header-cell nx-formfield .nx-formfield__wrapper,::ng-deep .nx-table-cell nx-formfield .nx-formfield__wrapper{padding:0}::ng-deep .nx-exandable-table-cell [nxlist],::ng-deep .nx-header-cell [nxlist],::ng-deep .nx-table-cell [nxlist]{margin:0}::ng-deep .nx-exandable-table-cell [nxlist] li:last-child,::ng-deep .nx-header-cell [nxlist] li:last-child,::ng-deep .nx-table-cell [nxlist] li:last-child{margin-bottom:0}::ng-deep .nx-exandable-table-cell nx-link a,::ng-deep .nx-header-cell nx-link a,::ng-deep .nx-table-cell nx-link a{display:inline-flex}"]
                }] }
    ];
    /** @nocollapse */
    NxTableComponent.ctorParameters = function () { return [
        { type: ChangeDetectorRef }
    ]; };
    NxTableComponent.propDecorators = {
        condensed: [{ type: Input }],
        zebra: [{ type: Input }]
    };
    return NxTableComponent;
}());
if (false) {
    /**
     * @type {?}
     * @private
     */
    NxTableComponent.prototype._condensed;
    /**
     * @type {?}
     * @private
     */
    NxTableComponent.prototype._zebra;
    /**
     * @type {?}
     * @private
     */
    NxTableComponent.prototype._changeDetectorRef;
}

/**
 * @fileoverview added by tsickle
 * Generated from: table-row.component.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * This is a table row.
 */
var NxTableRowComponent = /** @class */ (function () {
    function NxTableRowComponent(_changeDetectorRef, _elementRef) {
        this._changeDetectorRef = _changeDetectorRef;
        this._elementRef = _elementRef;
        this._selectable = false;
        this._selected = false;
        this.select = new EventEmitter();
    }
    Object.defineProperty(NxTableRowComponent.prototype, "selectable", {
        get: /**
         * @return {?}
         */
        function () {
            return this._selectable;
        },
        /** Whether this table row is selectable */
        set: /**
         * Whether this table row is selectable
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this._selectable = coerceBooleanProperty(value);
            this._changeDetectorRef.markForCheck();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NxTableRowComponent.prototype, "selected", {
        get: /**
         * @return {?}
         */
        function () {
            return this._selected;
        },
        /** Whether this table row is selected */
        set: /**
         * Whether this table row is selected
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this._selected = coerceBooleanProperty(value);
            this._changeDetectorRef.markForCheck();
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @param {?} $event
     * @return {?}
     */
    NxTableRowComponent.prototype._onSelect = /**
     * @param {?} $event
     * @return {?}
     */
    function ($event) {
        if (!this._selectable || this.isActionEvent($event)) {
            return;
        }
        if ($event.keyCode === SPACE) {
            $event.preventDefault();
        }
        this.select.emit();
    };
    /**
     * Checks if the event would trigger an action.
     * Return `true` if a button, link, input or label are clicked.
     */
    /**
     * Checks if the event would trigger an action.
     * Return `true` if a button, link, input or label are clicked.
     * @private
     * @param {?} $event
     * @return {?}
     */
    NxTableRowComponent.prototype.isActionEvent = /**
     * Checks if the event would trigger an action.
     * Return `true` if a button, link, input or label are clicked.
     * @private
     * @param {?} $event
     * @return {?}
     */
    function ($event) {
        /** @type {?} */
        var parent = $event.target;
        while (parent && parent !== this._elementRef.nativeElement) {
            if (['A', 'INPUT', 'BUTTON'].indexOf(parent.tagName) >= 0) {
                return true;
            }
            else if (parent.tagName === 'LABEL' && parent.getAttribute('for')) {
                return true;
            }
            parent = parent.parentElement;
        }
        return false;
    };
    NxTableRowComponent.decorators = [
        { type: Component, args: [{
                    // tslint:disable-next-line:component-selector
                    selector: 'tr[nxTableRow]',
                    host: {
                        'class': 'nx-table-row',
                        '[class.is-selected]': 'selected',
                        '[class.nx-table-row--selectable]': 'selectable',
                        '[attr.aria-selected]': 'selected',
                        '(click)': '_onSelect($event)',
                        '(keydown.space)': '_onSelect($event)'
                    },
                    template: "<ng-content></ng-content>",
                    changeDetection: ChangeDetectionStrategy.OnPush
                }] }
    ];
    /** @nocollapse */
    NxTableRowComponent.ctorParameters = function () { return [
        { type: ChangeDetectorRef },
        { type: ElementRef }
    ]; };
    NxTableRowComponent.propDecorators = {
        selectable: [{ type: Input }],
        selected: [{ type: Input }],
        select: [{ type: Output }]
    };
    return NxTableRowComponent;
}());
if (false) {
    /**
     * @type {?}
     * @private
     */
    NxTableRowComponent.prototype._selectable;
    /**
     * @type {?}
     * @private
     */
    NxTableRowComponent.prototype._selected;
    /** @type {?} */
    NxTableRowComponent.prototype.select;
    /**
     * @type {?}
     * @protected
     */
    NxTableRowComponent.prototype._changeDetectorRef;
    /**
     * @type {?}
     * @private
     */
    NxTableRowComponent.prototype._elementRef;
}

/**
 * @fileoverview added by tsickle
 * Generated from: expandable/expandable-table-row.component.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * This is an expandable table row.
 * It can collapse its height to hide the content.
 * Requires the table cells to have the `[nxExpandableTableCell]` component.
 */
var NxExpandableTableRowComponent = /** @class */ (function () {
    function NxExpandableTableRowComponent(_changeDetectorRef) {
        this._changeDetectorRef = _changeDetectorRef;
        this.expanded = new BehaviorSubject(false);
    }
    /**
     * Toggles the expansion of this row.
     */
    /**
     * Toggles the expansion of this row.
     * @return {?}
     */
    NxExpandableTableRowComponent.prototype.toggle = /**
     * Toggles the expansion of this row.
     * @return {?}
     */
    function () {
        if (this.expanded.value) {
            this.close();
        }
        else {
            this.expand();
        }
    };
    /**
     * Expands this row.
     */
    /**
     * Expands this row.
     * @return {?}
     */
    NxExpandableTableRowComponent.prototype.expand = /**
     * Expands this row.
     * @return {?}
     */
    function () {
        if (!this.expanded.value) {
            this.expanded.next(true);
            this._changeDetectorRef.markForCheck();
        }
    };
    /**
     * Closes this row.
     */
    /**
     * Closes this row.
     * @return {?}
     */
    NxExpandableTableRowComponent.prototype.close = /**
     * Closes this row.
     * @return {?}
     */
    function () {
        if (this.expanded.value) {
            this.expanded.next(false);
            this._changeDetectorRef.markForCheck();
        }
    };
    NxExpandableTableRowComponent.decorators = [
        { type: Component, args: [{
                    // tslint:disable-next-line:component-selector
                    selector: 'tr[nxExpandableTableRow]',
                    host: {
                        'class': 'nx-expandable-table-row'
                    },
                    template: "<ng-content></ng-content>",
                    changeDetection: ChangeDetectionStrategy.OnPush
                }] }
    ];
    /** @nocollapse */
    NxExpandableTableRowComponent.ctorParameters = function () { return [
        { type: ChangeDetectorRef }
    ]; };
    return NxExpandableTableRowComponent;
}());
if (false) {
    /** @type {?} */
    NxExpandableTableRowComponent.prototype.expanded;
    /**
     * @type {?}
     * @private
     */
    NxExpandableTableRowComponent.prototype._changeDetectorRef;
}

/**
 * @fileoverview added by tsickle
 * Generated from: expandable/expandable-table-cell.component.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * This is an expandable table cell.
 * Only works in conjunction with the `[nxExpandableTableRow]` component.
 */
var NxExpandableTableCellComponent = /** @class */ (function () {
    function NxExpandableTableCellComponent(_row, _changeDetectorRef) {
        var _this = this;
        this._changeDetectorRef = _changeDetectorRef;
        this._destroyed = new Subject();
        this._open = false;
        _row.expanded.pipe(takeUntil(this._destroyed))
            .subscribe((/**
         * @param {?} open
         * @return {?}
         */
        function (open) {
            _this._open = open;
            _this._changeDetectorRef.markForCheck();
        }));
    }
    /**
     * @return {?}
     */
    NxExpandableTableCellComponent.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        this._destroyed.next();
        this._destroyed.complete();
    };
    NxExpandableTableCellComponent.decorators = [
        { type: Component, args: [{
                    // tslint:disable-next-line:component-selector
                    selector: 'td[nxExpandableTableCell]',
                    template: "<div [@openClose]=\"_open ? 'open' : 'closed'\" class=\"nx-expandable-table-cell__content\">\n  <div class=\"nx-expandable-table-cell__wrapper\">\n    <ng-content></ng-content>\n  </div>\n</div>\n",
                    host: {
                        'class': 'nx-expandable-table-cell'
                    },
                    animations: [
                        trigger('openClose', [
                            state('open', style({
                                height: '*',
                                visibility: 'visible'
                            })),
                            state('closed, void', style({
                                height: '0',
                                visibility: 'hidden' // visibility and height to toggle instead of display: none to prevent cell width jumping
                            })),
                            transition('closed <=> open, void => closed', [
                                animate('225ms cubic-bezier(0.4,0.0,0.2,1)')
                            ])
                        ])
                    ],
                    changeDetection: ChangeDetectionStrategy.OnPush
                }] }
    ];
    /** @nocollapse */
    NxExpandableTableCellComponent.ctorParameters = function () { return [
        { type: NxExpandableTableRowComponent },
        { type: ChangeDetectorRef }
    ]; };
    return NxExpandableTableCellComponent;
}());
if (false) {
    /**
     * @type {?}
     * @private
     */
    NxExpandableTableCellComponent.prototype._destroyed;
    /** @type {?} */
    NxExpandableTableCellComponent.prototype._open;
    /**
     * @type {?}
     * @private
     */
    NxExpandableTableCellComponent.prototype._changeDetectorRef;
}

/**
 * @fileoverview added by tsickle
 * Generated from: expandable/toggle-button.component.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @record
 */
function NxExpandable() { }
if (false) {
    /**
     * Indicates if this expandable instance is open or not.
     * @type {?}
     */
    NxExpandable.prototype.expanded;
    /**
     * Toggles the open state.
     * @type {?}
     */
    NxExpandable.prototype.toggle;
    /**
     * Expands this component.
     * @type {?}
     */
    NxExpandable.prototype.expand;
    /**
     * Closes this component.
     * @type {?}
     */
    NxExpandable.prototype.close;
}
/**
 * This toggle button can be clicked and toggles expandable elements.
 * e.g. it can toggle a expandable table row or anything else that implements the `NxExpandable` interface.
 */
var NxToggleButtonComponent = /** @class */ (function () {
    function NxToggleButtonComponent(_changeDetectorRef) {
        this._changeDetectorRef = _changeDetectorRef;
        this._expanded = false;
        this._ariaLabel = '';
    }
    Object.defineProperty(NxToggleButtonComponent.prototype, "target", {
        /**
         * This is the expandable target that will be toggled when the user clicks the button.
         */
        set: /**
         * This is the expandable target that will be toggled when the user clicks the button.
         * @param {?} value
         * @return {?}
         */
        function (value) {
            var _this = this;
            this._target = value;
            if (this._subscription) {
                this._subscription.unsubscribe();
            }
            if (this._target) {
                this._subscription = this._target.expanded.subscribe((/**
                 * @param {?} expanded
                 * @return {?}
                 */
                function (expanded) {
                    _this._expanded = expanded;
                    _this._changeDetectorRef.markForCheck();
                }));
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NxToggleButtonComponent.prototype, "ariaLabel", {
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this._ariaLabel = value;
            this._changeDetectorRef.markForCheck();
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @return {?}
     */
    NxToggleButtonComponent.prototype._onClick = /**
     * @return {?}
     */
    function () {
        if (this._target) {
            this._target.toggle();
        }
    };
    /**
     * @return {?}
     */
    NxToggleButtonComponent.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        if (this._subscription) {
            this._subscription.unsubscribe();
        }
    };
    NxToggleButtonComponent.decorators = [
        { type: Component, args: [{
                    selector: 'nx-toggle-button',
                    template: "<button (click)=\"_onClick()\"\n    class=\"nx-toggle-button\"\n    [attr.aria-label]=\"_ariaLabel\"\n    [attr.aria-expanded]=\"_expanded\"\n    [class.is-expanded]=\"_expanded\">\n  <nx-icon name=\"chevron-down\"\n      aria-hidden=\"true\"\n      size=\"s\"\n      class=\"nx-toggle-button__icon\"></nx-icon>\n</button>\n",
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    styles: [":host{display:block}.nx-toggle-button{display:block;cursor:pointer;-webkit-appearance:none;-moz-appearance:none;appearance:none;border:none;outline:0;background:0 0;padding:0;line-height:24px;height:24px}.nx-toggle-button .nx-toggle-button__icon{transform:rotateZ(0);transition:transform .2s;color:#414141;color:var(--expandable-table-arrow-icon-color,#414141)}.nx-toggle-button.is-expanded .nx-toggle-button__icon{transform:rotateZ(-180deg)}.nx-toggle-button::-moz-focus-inner{border:0}:host-context([data-whatinput=keyboard]) .nx-toggle-button:focus{border-radius:4px;box-shadow:0 0 0 2px #fff,0 0 0 6px #009de6;box-shadow:var(--focus-box-shadow,0 0 0 2px #fff,0 0 0 6px #009de6)}@media screen and (-ms-high-contrast:active){:host-context([data-whatinput=keyboard]) .nx-toggle-button:focus{box-shadow:0 0 0 2px background,0 0 0 6px windowText}}"]
                }] }
    ];
    /** @nocollapse */
    NxToggleButtonComponent.ctorParameters = function () { return [
        { type: ChangeDetectorRef }
    ]; };
    NxToggleButtonComponent.propDecorators = {
        target: [{ type: Input }],
        ariaLabel: [{ type: Input }]
    };
    return NxToggleButtonComponent;
}());
if (false) {
    /** @type {?} */
    NxToggleButtonComponent.prototype._expanded;
    /** @type {?} */
    NxToggleButtonComponent.prototype._target;
    /** @type {?} */
    NxToggleButtonComponent.prototype._ariaLabel;
    /**
     * @type {?}
     * @private
     */
    NxToggleButtonComponent.prototype._subscription;
    /**
     * @type {?}
     * @private
     */
    NxToggleButtonComponent.prototype._changeDetectorRef;
}

/**
 * @fileoverview added by tsickle
 * Generated from: expandable/expandable-table.directive.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * The nxExpandableTable adds row expansion functionality to the nxTable.
 * It provides the logic to expand/collapse all expandable rows simultanously.
 */
var NxExpandableTableDirective = /** @class */ (function () {
    function NxExpandableTableDirective() {
        this.expanded = new BehaviorSubject(false);
    }
    /**
     * @return {?}
     */
    NxExpandableTableDirective.prototype.ngAfterViewInit = /**
     * @return {?}
     */
    function () {
        var _this = this;
        this.rows.changes.pipe(startWith(this.rows), flatMap((/**
         * @param {?} rows
         * @return {?}
         */
        function (rows) {
            return combineLatest(rows.map((/**
             * @param {?} row
             * @return {?}
             */
            function (row) { return row.expanded; })));
        })), map((/**
         * @param {?} values
         * @return {?}
         */
        function (values) {
            return values.reduce((/**
             * @param {?} a
             * @param {?} x
             * @return {?}
             */
            function (a, x) { return a && x; }), true);
        })), distinctUntilChanged())
            .subscribe((/**
         * @param {?} rowsOpen
         * @return {?}
         */
        function (rowsOpen) {
            _this.expanded.next(rowsOpen);
        }));
    };
    /**
     * Toggles the expandable rows. If all rows are open it will close them, otherwise it will open them.
     */
    /**
     * Toggles the expandable rows. If all rows are open it will close them, otherwise it will open them.
     * @return {?}
     */
    NxExpandableTableDirective.prototype.toggle = /**
     * Toggles the expandable rows. If all rows are open it will close them, otherwise it will open them.
     * @return {?}
     */
    function () {
        if (this.expanded.value) {
            this.close();
        }
        else {
            this.expand();
        }
    };
    /**
     * Expands all expandable rows.
     */
    /**
     * Expands all expandable rows.
     * @return {?}
     */
    NxExpandableTableDirective.prototype.expand = /**
     * Expands all expandable rows.
     * @return {?}
     */
    function () {
        this.rows.forEach((/**
         * @param {?} row
         * @return {?}
         */
        function (row) { return row.expanded.next(true); }));
    };
    /**
     * Closes all expandable rows.
     */
    /**
     * Closes all expandable rows.
     * @return {?}
     */
    NxExpandableTableDirective.prototype.close = /**
     * Closes all expandable rows.
     * @return {?}
     */
    function () {
        this.rows.forEach((/**
         * @param {?} row
         * @return {?}
         */
        function (row) { return row.expanded.next(false); }));
    };
    NxExpandableTableDirective.decorators = [
        { type: Directive, args: [{
                    selector: 'table[nxExpandableTable]',
                    exportAs: 'nxExpandableTable'
                },] }
    ];
    NxExpandableTableDirective.propDecorators = {
        rows: [{ type: ContentChildren, args: [NxExpandableTableRowComponent, { descendants: true },] }]
    };
    return NxExpandableTableDirective;
}());
if (false) {
    /** @type {?} */
    NxExpandableTableDirective.prototype.rows;
    /** @type {?} */
    NxExpandableTableDirective.prototype.expanded;
}

/**
 * @fileoverview added by tsickle
 * Generated from: sort-header/sort.directive.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var SortEvent = /** @class */ (function () {
    function SortEvent(active, direction) {
        this.active = active;
        this.direction = direction;
    }
    return SortEvent;
}());
if (false) {
    /**
     * The name of the column that is being sorted by.
     * @type {?}
     */
    SortEvent.prototype.active;
    /**
     * The sort direction.
     * @type {?}
     */
    SortEvent.prototype.direction;
}
var NxSortDirective = /** @class */ (function () {
    function NxSortDirective() {
        this._stateChanges = new Subject();
        this._direction = 'asc';
        /**
         * \@docs-private
         * An event emitted when the active value has changed.
         */
        this.activeChange = new EventEmitter();
        /**
         * \@docs-private
         * An event emitted when the direction value has changed.
         */
        this.directionChange = new EventEmitter();
        /**
         * An event emitted when either the active sort or sort direction changes.
         */
        this.sortChange = new EventEmitter();
    }
    Object.defineProperty(NxSortDirective.prototype, "active", {
        get: /**
         * @return {?}
         */
        function () {
            return this._active;
        },
        /** Sets the key of the most recently sorted column. */
        set: /**
         * Sets the key of the most recently sorted column.
         * @param {?} value
         * @return {?}
         */
        function (value) {
            if (this._active !== value) {
                this._active = value;
                this.sortChange.emit(new SortEvent(this.active, this.direction));
                this._stateChanges.next();
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NxSortDirective.prototype, "direction", {
        get: /**
         * @return {?}
         */
        function () {
            return this._direction;
        },
        /** Sets the direction of the currently active sorted column. Default: 'asc'. */
        set: /**
         * Sets the direction of the currently active sorted column. Default: 'asc'.
         * @param {?} value
         * @return {?}
         */
        function (value) {
            if (this._direction !== value) {
                this._direction = value;
                this.sortChange.emit(new SortEvent(this.active, this.direction));
                this._stateChanges.next();
            }
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @return {?}
     */
    NxSortDirective.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        this._stateChanges.complete();
    };
    /**
     * Sets the active sort key and determines the new sort direction.
     * Afterwards the output event `sortChange` is called.
     *
     * If `sortable` is not the key of the active sort header, the initial direction to sort is 'asc'.
     * Otherwise the direction of the sorted column changes.
     */
    /**
     * Sets the active sort key and determines the new sort direction.
     * Afterwards the output event `sortChange` is called.
     *
     * If `sortable` is not the key of the active sort header, the initial direction to sort is 'asc'.
     * Otherwise the direction of the sorted column changes.
     * @param {?} sortable
     * @return {?}
     */
    NxSortDirective.prototype.sort = /**
     * Sets the active sort key and determines the new sort direction.
     * Afterwards the output event `sortChange` is called.
     *
     * If `sortable` is not the key of the active sort header, the initial direction to sort is 'asc'.
     * Otherwise the direction of the sorted column changes.
     * @param {?} sortable
     * @return {?}
     */
    function (sortable) {
        if (this._active !== sortable) {
            this._active = sortable;
            this.activeChange.emit(this.active);
            this._direction = 'asc';
            this.directionChange.emit(this.direction);
        }
        else if (this._direction === 'asc') {
            this._direction = 'desc';
            this.directionChange.emit(this.direction);
        }
        else {
            this._direction = 'asc';
            this.directionChange.emit(this.direction);
        }
        this.sortChange.emit(new SortEvent(this.active, this.direction));
        this._stateChanges.next();
    };
    NxSortDirective.decorators = [
        { type: Directive, args: [{
                    selector: 'table[nxSort]',
                    exportAs: 'NxSortDirective'
                },] }
    ];
    NxSortDirective.propDecorators = {
        active: [{ type: Input }],
        direction: [{ type: Input }],
        activeChange: [{ type: Output }],
        directionChange: [{ type: Output }],
        sortChange: [{ type: Output }]
    };
    return NxSortDirective;
}());
if (false) {
    /** @type {?} */
    NxSortDirective.prototype._stateChanges;
    /**
     * @type {?}
     * @private
     */
    NxSortDirective.prototype._active;
    /**
     * @type {?}
     * @private
     */
    NxSortDirective.prototype._direction;
    /**
     * \@docs-private
     * An event emitted when the active value has changed.
     * @type {?}
     */
    NxSortDirective.prototype.activeChange;
    /**
     * \@docs-private
     * An event emitted when the direction value has changed.
     * @type {?}
     */
    NxSortDirective.prototype.directionChange;
    /**
     * An event emitted when either the active sort or sort direction changes.
     * @type {?}
     */
    NxSortDirective.prototype.sortChange;
}

/**
 * @fileoverview added by tsickle
 * Generated from: sort-header/sort-header-intl.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var NxSortHeaderIntl = /** @class */ (function () {
    function NxSortHeaderIntl() {
        /**
         * Stream that emits whenever the labels here are changed. Use this to notify
         * components if the labels have changed after initialization.
         */
        this.changes = new Subject();
        /**
         * The aria label for a header that can be sorted ascending.
         */
        this.sortAscendingAriaLabel = 'sort ascending by';
        /**
         * The aria label for a header that can be sorted descending.
         */
        this.sortDescendingAriaLabel = 'sort descending by';
    }
    NxSortHeaderIntl.decorators = [
        { type: Injectable }
    ];
    return NxSortHeaderIntl;
}());
if (false) {
    /**
     * Stream that emits whenever the labels here are changed. Use this to notify
     * components if the labels have changed after initialization.
     * @type {?}
     */
    NxSortHeaderIntl.prototype.changes;
    /**
     * The aria label for a header that can be sorted ascending.
     * @type {?}
     */
    NxSortHeaderIntl.prototype.sortAscendingAriaLabel;
    /**
     * The aria label for a header that can be sorted descending.
     * @type {?}
     */
    NxSortHeaderIntl.prototype.sortDescendingAriaLabel;
}

/**
 * @fileoverview added by tsickle
 * Generated from: sort-header/sort-header.component.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var NxSortHeaderComponent = /** @class */ (function () {
    function NxSortHeaderComponent(_sort, _intl, _changeDetectorRef) {
        var _this = this;
        this._sort = _sort;
        this._intl = _intl;
        this._changeDetectorRef = _changeDetectorRef;
        this._intlSubscription = this._intl.changes.subscribe((/**
         * @return {?}
         */
        function () { return _this._changeDetectorRef.markForCheck(); }));
    }
    Object.defineProperty(NxSortHeaderComponent.prototype, "key", {
        get: /**
         * @return {?}
         */
        function () {
            return this._key;
        },
        /** Sets the key of this sort header. */
        set: /**
         * Sets the key of this sort header.
         * @param {?} value
         * @return {?}
         */
        function (value) {
            if (this._key !== value) {
                this._key = value;
            }
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @return {?}
     */
    NxSortHeaderComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        var _this = this;
        this._parentChangeSubscription = this._sort._stateChanges.subscribe((/**
         * @return {?}
         */
        function () {
            _this._changeDetectorRef.markForCheck();
        }));
    };
    /**
     * @return {?}
     */
    NxSortHeaderComponent.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        if (this._parentChangeSubscription) {
            this._parentChangeSubscription.unsubscribe();
        }
        this._intlSubscription.unsubscribe();
    };
    /**
     * @return {?}
     */
    NxSortHeaderComponent.prototype._handleClick = /**
     * @return {?}
     */
    function () {
        this._sort.sort(this._key);
    };
    /**
     * @param {?} $event
     * @return {?}
     */
    NxSortHeaderComponent.prototype._onKeydown = /**
     * @param {?} $event
     * @return {?}
     */
    function ($event) {
        if ($event && ($event.keyCode === ENTER || $event.keyCode === SPACE)) {
            this._sort.sort(this._key);
            // prevent page from scrolling down
            if ($event.keyCode === SPACE) {
                $event.preventDefault();
            }
        }
    };
    /**
     * @return {?}
     */
    NxSortHeaderComponent.prototype._isSortedAscending = /**
     * @return {?}
     */
    function () {
        return (this._sort.active === this._key && this._sort.direction === 'asc');
    };
    /**
     * @return {?}
     */
    NxSortHeaderComponent.prototype._isSortedDescending = /**
     * @return {?}
     */
    function () {
        return (this._sort.active === this._key && this._sort.direction === 'desc');
    };
    /**
     * @return {?}
     */
    NxSortHeaderComponent.prototype._getAriaLabel = /**
     * @return {?}
     */
    function () {
        if (this._sort.active === this._key && this._sort.direction === 'asc') {
            return "" + this._intl.sortDescendingAriaLabel;
        }
        return "" + this._intl.sortAscendingAriaLabel;
    };
    NxSortHeaderComponent.decorators = [
        { type: Component, args: [{
                    // tslint:disable-next-line:component-selector
                    selector: 'th[nxSortHeaderCell]',
                    exportAs: 'nxSortHeaderComponent',
                    template: "<div class=\"nx-sort-header__focus-container\" role=\"button\" tabindex=\"0\">\n  <div class=\"nx-sort-header__icons-container\"\n      [attr.aria-label]=\"_getAriaLabel()\">\n    <nx-icon name=\"chevron-up-small\"\n        class=\"nx-sort-header__icon-up\"\n        [class.nx-sort-header__hidden-icon]=\"_isSortedDescending()\">\n    </nx-icon>\n    <nx-icon name=\"chevron-down-small\"\n        class=\"nx-sort-header__icon-down\"\n        [class.nx-sort-header__hidden-icon]=\"_isSortedAscending()\">\n    </nx-icon>\n  </div>\n\n  <ng-content></ng-content>\n</div>\n",
                    host: {
                        '(click)': '_handleClick()',
                        '(keydown)': '_onKeydown($event)'
                    },
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    styles: [":host{cursor:pointer}.nx-sort-header__icons-container{display:inline-block;margin-right:8px;vertical-align:bottom;width:24px;position:relative;height:24px}.nx-sort-header__icons-container nx-icon{font-size:20px;position:absolute;font-weight:600;width:24px}.nx-sort-header__icons-container .nx-sort-header__icon-up{top:-3px}.nx-sort-header__icons-container .nx-sort-header__icon-down{top:5px}.nx-sort-header__icons-container .nx-sort-header__hidden-icon{visibility:hidden}.nx-sort-header__focus-container{display:flex}.nx-sort-header__focus-container:focus{outline:0}:host-context([data-whatinput=keyboard]) .nx-sort-header__focus-container:focus{box-shadow:0 0 0 2px #fff,0 0 0 6px #009de6;box-shadow:var(--focus-box-shadow,0 0 0 2px #fff,0 0 0 6px #009de6);border-radius:4px}@media screen and (-ms-high-contrast:active){:host-context([data-whatinput=keyboard]) .nx-sort-header__focus-container:focus{box-shadow:0 0 0 2px background,0 0 0 6px windowText}.nx-sort-header__focus-container{color:buttonText}}"]
                }] }
    ];
    /** @nocollapse */
    NxSortHeaderComponent.ctorParameters = function () { return [
        { type: NxSortDirective, decorators: [{ type: Optional }] },
        { type: NxSortHeaderIntl },
        { type: ChangeDetectorRef }
    ]; };
    NxSortHeaderComponent.propDecorators = {
        key: [{ type: Input, args: ['nxSortHeaderCell',] }]
    };
    return NxSortHeaderComponent;
}());
if (false) {
    /**
     * @type {?}
     * @private
     */
    NxSortHeaderComponent.prototype._parentChangeSubscription;
    /**
     * @type {?}
     * @private
     */
    NxSortHeaderComponent.prototype._intlSubscription;
    /**
     * @type {?}
     * @private
     */
    NxSortHeaderComponent.prototype._key;
    /** @type {?} */
    NxSortHeaderComponent.prototype._sort;
    /** @type {?} */
    NxSortHeaderComponent.prototype._intl;
    /**
     * @type {?}
     * @private
     */
    NxSortHeaderComponent.prototype._changeDetectorRef;
}

/**
 * @fileoverview added by tsickle
 * Generated from: table.module.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
var EXPORTED_DECLARED_ELEMENTS = [
    NxHeaderCellDirective,
    NxTableComponent,
    NxTableCellComponent,
    NxTableComponent,
    NxTableRowComponent,
    NxToggleButtonComponent,
    NxExpandableTableDirective,
    NxExpandableTableRowComponent,
    NxExpandableTableCellComponent,
    NxSortHeaderComponent,
    NxSortDirective
];
var NxTableModule = /** @class */ (function () {
    function NxTableModule() {
    }
    NxTableModule.decorators = [
        { type: NgModule, args: [{
                    declarations: EXPORTED_DECLARED_ELEMENTS,
                    exports: EXPORTED_DECLARED_ELEMENTS,
                    imports: [
                        CommonModule,
                        NxIconModule
                    ],
                    providers: [NxSortHeaderIntl],
                },] }
    ];
    return NxTableModule;
}());

/**
 * @fileoverview added by tsickle
 * Generated from: public-api.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * Generated from: allianz-ngx-ndbx-table.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

export { NxExpandableTableCellComponent, NxExpandableTableDirective, NxExpandableTableRowComponent, NxHeaderCellDirective, NxSortDirective, NxSortHeaderComponent, NxSortHeaderIntl, NxTableCellComponent, NxTableComponent, NxTableModule, NxTableRowComponent, NxToggleButtonComponent, SortEvent };
//# sourceMappingURL=allianz-ngx-ndbx-table.js.map
