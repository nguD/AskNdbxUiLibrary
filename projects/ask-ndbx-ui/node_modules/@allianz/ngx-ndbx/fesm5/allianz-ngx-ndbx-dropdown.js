import { NxFormfieldControl, NxFormfieldComponent, NxFormfieldModule } from '@allianz/ngx-ndbx/formfield';
import { NxIconModule } from '@allianz/ngx-ndbx/icon';
import { ActiveDescendantKeyManager, A11yModule } from '@angular/cdk/a11y';
import { CdkConnectedOverlay, OverlayModule } from '@angular/cdk/overlay';
import { CommonModule } from '@angular/common';
import { Input, Component, ChangeDetectionStrategy, EventEmitter, Inject, Optional, ChangeDetectorRef, ElementRef, Output, ViewChild, Directive, TemplateRef, isDevMode, NgZone, Attribute, Self, ContentChildren, ContentChild, NgModule } from '@angular/core';
import { NxCheckboxModule } from '@allianz/ngx-ndbx/checkbox';
import { __extends, __spread } from 'tslib';
import { SelectionModel } from '@angular/cdk/collections';
import { DOWN_ARROW, UP_ARROW, LEFT_ARROW, RIGHT_ARROW, ENTER, SPACE, HOME, END, SHIFT, TAB } from '@angular/cdk/keycodes';
import { NgControl, NgForm, FormGroupDirective } from '@angular/forms';
import { Subject, defer, merge } from 'rxjs';
import { takeUntil, filter, map, take, switchMap, startWith, delay } from 'rxjs/operators';
import { ObserversModule } from '@angular/cdk/observers';

/**
 * @fileoverview added by tsickle
 * Generated from: dropdown-errors.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Returns an exception to be thrown when attempting to change a select's `multiple` option
 * after initialization.
 * \@docs-private
 * @return {?}
 */
function getNxDropdownDynamicMultipleError() {
    return Error('Cannot change `multiselect` mode of select after initialization.');
}
/**
 * Returns an exception to be thrown when attempting to assign a non-array value to a select
 * in `multiselect` mode. Note that `undefined` and `null` are still valid values to allow for
 * resetting the value.
 * \@docs-private
 * @return {?}
 */
function getNxDropdownNonArrayValueError() {
    return Error('Value must be an array in multiselect mode.');
}
/**
 * Returns an exception to be thrown when assigning a non-function value to the comparator
 * used to determine if a value corresponds to an option. Note that whether the function
 * actually takes two values and returns a boolean is not checked.
 * @return {?}
 */
function getNxDropdownNonFunctionValueError() {
    return Error('`compareWith` must be a function.');
}

/**
 * @fileoverview added by tsickle
 * Generated from: dropdown.control.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @abstract
 */
var NxDropdownControl = /** @class */ (function (_super) {
    __extends(NxDropdownControl, _super);
    function NxDropdownControl() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        /**
         * Whether the dropdown should allow multi selection and additional checkboxes are shown.
         *
         * Note: Please make sure the value you bind is an array. If not an error is thrown!
         */
        _this.isMultiSelect = false;
        return _this;
    }
    NxDropdownControl.propDecorators = {
        isMultiSelect: [{ type: Input, args: ['nxIsMultiselect',] }]
    };
    return NxDropdownControl;
}(NxFormfieldControl));
if (false) {
    /**
     * Whether the dropdown should allow multi selection and additional checkboxes are shown.
     *
     * Note: Please make sure the value you bind is an array. If not an error is thrown!
     * @type {?}
     */
    NxDropdownControl.prototype.isMultiSelect;
    /**
     * \@docs-private
     * @abstract
     * @param {?} value
     * @return {?}
     */
    NxDropdownControl.prototype.formatValue = function (value) { };
}

/**
 * @fileoverview added by tsickle
 * Generated from: group/dropdown-group.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var NxDropdownGroupComponent = /** @class */ (function () {
    function NxDropdownGroupComponent() {
    }
    NxDropdownGroupComponent.decorators = [
        { type: Component, args: [{
                    selector: 'nx-dropdown-group',
                    template: "<div class=\"nx-dropdown-results__group\">\n  <div class=\"nx-dropdown-results__group-label\">{{label}}</div>\n  <ng-content></ng-content>\n</div>\n",
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    styles: [":host{display:block}:host:first-child .nx-dropdown-results__group{background:rgba(236,236,236,.5);background:var(--dropdown-group-section-background-color,rgba(236,236,236,.5))}:host:first-child .nx-dropdown-results__group-label{padding-top:16px}.nx-dropdown-results__group-label{font-size:12px;font-size:var(--formfield-label-font-size,12px);line-height:16px;line-height:var(--formfield-label-line-height,16px);font-weight:var(--formfield-label-font-weight,600);letter-spacing:.5px;letter-spacing:var(--formfield-label-letter-spacing,.5px);font-style:italic;font-weight:700;padding:24px 32px 16px}"]
                }] }
    ];
    NxDropdownGroupComponent.propDecorators = {
        label: [{ type: Input, args: ['nxLabel',] }]
    };
    return NxDropdownGroupComponent;
}());
if (false) {
    /**
     * Label displayed in the group.
     * @type {?}
     */
    NxDropdownGroupComponent.prototype.label;
}

/**
 * @fileoverview added by tsickle
 * Generated from: item/dropdown-item.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var NxDropdownItemChange = /** @class */ (function () {
    function NxDropdownItemChange(item, isUserInput) {
        if (isUserInput === void 0) { isUserInput = false; }
        this.item = item;
        this.isUserInput = isUserInput;
    }
    return NxDropdownItemChange;
}());
if (false) {
    /**
     * Reference to the option that emitted the event.
     * @type {?}
     */
    NxDropdownItemChange.prototype.item;
    /**
     * Whether the change in the option's value was a result of a user action.
     * @type {?}
     */
    NxDropdownItemChange.prototype.isUserInput;
}
/**
 * the unique id counter
 * @type {?}
 */
var nextId = 0;
var NxDropdownItemComponent = /** @class */ (function () {
    function NxDropdownItemComponent(_dropdown, group, _changeDetectorRef, _elementRef) {
        var _this = this;
        this._dropdown = _dropdown;
        this.group = group;
        this._changeDetectorRef = _changeDetectorRef;
        this._elementRef = _elementRef;
        this._hidden = false;
        this._mostRecentViewValue = '';
        this._id = "nx-dropdown-item-" + nextId++;
        this._selected = false;
        /**
         * Emits whenever the component is destroyed.
         */
        this._destroy = new Subject();
        /**
         * Event emitted when the option is selected or deselected.
         */
        // tslint:disable-next-line:no-output-on-prefix
        this.onSelectionChange = new EventEmitter();
        /**
         * Emits when the state of the option changes and any parents have to be notified.
         */
        this._stateChanges = new Subject();
        ((/** @type {?} */ (this._dropdown))).filterChanges.pipe(takeUntil(this._destroy)).subscribe((/**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            _this._showOrHideByFilter(value);
        }));
        // reset the hidden state when dropdown closes that on next open the user is seeing the full list again
        ((/** @type {?} */ (this._dropdown)))._closedStream.pipe(takeUntil(this._destroy)).subscribe((/**
         * @return {?}
         */
        function () {
            _this._hidden = false;
        }));
    }
    Object.defineProperty(NxDropdownItemComponent.prototype, "id", {
        /** The unique ID of the option. */
        get: /**
         * The unique ID of the option.
         * @return {?}
         */
        function () { return this._id; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NxDropdownItemComponent.prototype, "selected", {
        /** Whether the item is selected. */
        get: /**
         * Whether the item is selected.
         * @return {?}
         */
        function () {
            return this._selected;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NxDropdownItemComponent.prototype, "active", {
        /** Whether the item is active. */
        get: /**
         * Whether the item is active.
         * @return {?}
         */
        function () {
            return this._active;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NxDropdownItemComponent.prototype, "multiselect", {
        /**
         * @docs-private
         * Whether the parent dropdown is in multiselect mode.
         */
        get: /**
         * \@docs-private
         * Whether the parent dropdown is in multiselect mode.
         * @return {?}
         */
        function () {
            return this._dropdown && this._dropdown.isMultiSelect;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @return {?}
     */
    NxDropdownItemComponent.prototype.ngAfterViewChecked = /**
     * @return {?}
     */
    function () {
        // Since the parent dropdown component could be using the item's label to display the selected values
        // and it doesn't have a way of knowing if the item's label has changed
        // we have to check for changes in the DOM ourselves and dispatch an event. These checks are
        // relatively cheap, however we still limit them only to selected options in order to avoid
        // hitting the DOM too often.
        if (this._selected) {
            /** @type {?} */
            var viewValue = this.viewValue;
            if (viewValue !== this._mostRecentViewValue) {
                this._mostRecentViewValue = viewValue;
                this._stateChanges.next();
            }
        }
    };
    /**
     * @return {?}
     */
    NxDropdownItemComponent.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        this._stateChanges.complete();
        this._destroy.next();
        this._destroy.complete();
    };
    /**
     * @param {?} event
     * @return {?}
     */
    NxDropdownItemComponent.prototype._onClick = /**
     * @param {?} event
     * @return {?}
     */
    function (event) {
        /* preventDefault to stop triggering the event twice when you click on the checkbox or the label inside the item */
        event.preventDefault();
        event.stopPropagation();
        this._selectViaInteraction();
    };
    /**
    * `Selects the option while indicating the selection came from the user. Used to
    * determine if the select's view -> model callback should be invoked.`
    */
    /**
     * `Selects the option while indicating the selection came from the user. Used to
     * determine if the select's view -> model callback should be invoked.`
     * @return {?}
     */
    NxDropdownItemComponent.prototype._selectViaInteraction = /**
     * `Selects the option while indicating the selection came from the user. Used to
     * determine if the select's view -> model callback should be invoked.`
     * @return {?}
     */
    function () {
        this._selected = this.multiselect ? !this._selected : true;
        this._changeDetectorRef.markForCheck();
        this._emitSelectionChangeEvent(true);
    };
    /** @docs-private */
    /**
     * \@docs-private
     * @return {?}
     */
    NxDropdownItemComponent.prototype.show = /**
     * \@docs-private
     * @return {?}
     */
    function () {
        this._hidden = false;
        this._changeDetectorRef.markForCheck();
    };
    /** @docs-private */
    /**
     * \@docs-private
     * @return {?}
     */
    NxDropdownItemComponent.prototype.hide = /**
     * \@docs-private
     * @return {?}
     */
    function () {
        this._hidden = true;
        this._changeDetectorRef.markForCheck();
    };
    /**
     * @private
     * @param {?} search
     * @return {?}
     */
    NxDropdownItemComponent.prototype._showOrHideByFilter = /**
     * @private
     * @param {?} search
     * @return {?}
     */
    function (search) {
        /** @type {?} */
        var constraint = ((/** @type {?} */ (this._dropdown))).filterFn(search, this.viewValue);
        this._hidden = constraint ? false : true;
        this._changeDetectorRef.markForCheck();
    };
    Object.defineProperty(NxDropdownItemComponent.prototype, "_formattedValue", {
        get: /**
         * @return {?}
         */
        function () {
            return ((/** @type {?} */ (this._dropdown))).valueFormatter(this.value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NxDropdownItemComponent.prototype, "viewValue", {
        /** @docs-private */
        get: /**
         * \@docs-private
         * @return {?}
         */
        function () {
            return (this._elementRef.nativeElement.textContent || '').trim();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NxDropdownItemComponent.prototype, "elementRef", {
        /** @docs-private */
        get: /**
         * \@docs-private
         * @return {?}
         */
        function () {
            return this._elementRef;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @return {?}
     */
    NxDropdownItemComponent.prototype.select = /**
     * @return {?}
     */
    function () {
        if (!this._selected) {
            this._selected = true;
            this._changeDetectorRef.markForCheck();
            this._emitSelectionChangeEvent();
        }
    };
    /** @docs-private */
    /**
     * \@docs-private
     * @return {?}
     */
    NxDropdownItemComponent.prototype.deselect = /**
     * \@docs-private
     * @return {?}
     */
    function () {
        if (this._selected) {
            this._selected = false;
            this._changeDetectorRef.markForCheck();
            this._emitSelectionChangeEvent();
        }
    };
    /** @docs-private */
    /**
     * \@docs-private
     * @return {?}
     */
    NxDropdownItemComponent.prototype.focus = /**
     * \@docs-private
     * @return {?}
     */
    function () {
        this._elementRef.nativeElement.focus();
    };
    /**
     * @private
     * @param {?=} isUserInput
     * @return {?}
     */
    NxDropdownItemComponent.prototype._emitSelectionChangeEvent = /**
     * @private
     * @param {?=} isUserInput
     * @return {?}
     */
    function (isUserInput) {
        if (isUserInput === void 0) { isUserInput = false; }
        this.onSelectionChange.emit(new NxDropdownItemChange(this, isUserInput));
    };
    /** @docs-private */
    /**
     * \@docs-private
     * @return {?}
     */
    NxDropdownItemComponent.prototype.setActiveStyles = /**
     * \@docs-private
     * @return {?}
     */
    function () {
        this._active = true;
        this._changeDetectorRef.markForCheck();
    };
    /** @docs-private */
    /**
     * \@docs-private
     * @return {?}
     */
    NxDropdownItemComponent.prototype.setInactiveStyles = /**
     * \@docs-private
     * @return {?}
     */
    function () {
        this._active = false;
        this._changeDetectorRef.markForCheck();
    };
    /**
     * Returns the list item's text label. Implemented as a part of the ListKeyManagerOption.
     * @docs-private */
    /**
     * Returns the list item's text label. Implemented as a part of the ListKeyManagerOption.
     * \@docs-private
     * @return {?}
     */
    NxDropdownItemComponent.prototype.getLabel = /**
     * Returns the list item's text label. Implemented as a part of the ListKeyManagerOption.
     * \@docs-private
     * @return {?}
     */
    function () {
        return this.viewValue;
    };
    /**
     * @param {?} element
     * @return {?}
     */
    NxDropdownItemComponent.prototype._isContentEmpty = /**
     * @param {?} element
     * @return {?}
     */
    function (element) {
        return element.children.length === 0 && !element.textContent.trim();
    };
    /**
     * @return {?}
     */
    NxDropdownItemComponent.prototype._onLabelChange = /**
     * @return {?}
     */
    function () {
        // trigger change detection when the label content changes for the case that ng-content was empty before.
        // this is also important when the label comes in deferred, e.g. by a delayed observable,
        // then first the default label derived from the value is shown
        // and after the value from the async observable is ready we need to trigger change detection that the derived label
        // gets hidden again.
        // Notice(!): the event of (cdkObserveContent) is run outside of the ngZone
        // We run detectChanges directly here as markForCheck wasn't enough to always trigger change detection correctly
        this._changeDetectorRef.detectChanges();
    };
    NxDropdownItemComponent.decorators = [
        { type: Component, args: [{
                    selector: 'nx-dropdown-item',
                    template: "<div #container class=\"nx-dropdown-results__option\"\n     [ngClass]=\"{'nx-dropdown-results__option--selected': selected}\">\n\n   <nx-checkbox *ngIf=\"multiselect\" [checked]=\"selected\">\n      <ng-container *ngTemplateOutlet=\"contentTemplate\"></ng-container>\n    </nx-checkbox>\n\n    <span *ngIf=\"!multiselect\" class=\"nx-dropdown-results__option-checkicon\">\n       <nx-icon name=\"check\" aria-hidden=\"true\"></nx-icon>\n    </span>\n\n    <ng-container *ngIf=\"!multiselect\">\n      <ng-container *ngTemplateOutlet=\"contentTemplate\"></ng-container>\n    </ng-container>\n</div>\n\n<ng-template #contentTemplate>\n  <div class=\"nx-dropdown-results__option-label\" >\n    <span #content (cdkObserveContent)=\"_onLabelChange()\">\n      <ng-content></ng-content>\n    </span>\n    <ng-container *ngIf=\"_isContentEmpty(content)\">\n      {{_formattedValue}}\n    </ng-container>\n  </div>\n</ng-template>\n",
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    host: {
                        '[id]': 'id',
                        'role': 'option',
                        '[attr.aria-selected]': 'selected.toString()',
                        '[class.nx-hidden]': '_hidden',
                        '[class.nx-dropdown-item--active]': 'active',
                        '[class.nx-selected]': 'selected',
                        '[class.nx-multiselect]': 'multiselect',
                        '(click)': '_onClick($event)'
                    },
                    styles: [":host{display:block}:host(.nx-hidden){display:none}:host:first-child .nx-dropdown-results__option{padding-top:16px}:host:last-child .nx-dropdown-results__option{padding-bottom:16px}nx-checkbox{margin-bottom:0}.nx-dropdown-results__option{font-size:20px;font-size:var(--dropdown-item-font-size,20px);line-height:28px;line-height:var(--dropdown-item-line-height,28px);font-weight:400;font-weight:var(--dropdown-item-font-weight,400);letter-spacing:.2px;letter-spacing:var(--dropdown-item-letter-spacing,.2px);padding:8px 32px 8px 8px;cursor:pointer;position:relative;display:flex;max-width:100%;white-space:nowrap}.nx-dropdown-results__option-label{padding:0 12px;margin:0 -12px;color:#414141;color:var(--dropdown-item-text-color,#414141);white-space:pre-line}@media screen and (-ms-high-contrast:active){.nx-dropdown-results__option-label{-ms-high-contrast-adjust:none;color:buttonText;background-color:buttonFace;border-radius:4px}}:host(.nx-multiselect) .nx-dropdown-results__option{display:block;padding-left:32px}:host(.nx-selected):hover .nx-dropdown-results__option-checkicon,:host(.nx-selected):hover .nx-dropdown-results__option-label,:host:hover .nx-dropdown-results__option-label{color:#006192;color:var(--hover-primary,#006192)}@media screen and (-ms-high-contrast:active){:host(.nx-dropdown-item--active):not(.nx-multiselect) .nx-dropdown-results__option-label,:host:hover .nx-dropdown-results__option-label{color:highlightText;background-color:highlight}:host(.nx-dropdown-item--active):not(.nx-multiselect) .nx-dropdown-results__option-checkicon{-ms-high-contrast-adjust:none;color:highlightText;background:highlight;z-index:1}}:host(.nx-selected) .nx-dropdown-results__option-checkicon{opacity:1}:host(.nx-selected) .nx-dropdown-results__option-label{color:#414141;color:var(--dropdown-item-selected-color,#414141)}.nx-dropdown-results__option-checkicon{opacity:0;margin-right:8px;height:28px;height:var(--dropdown-item-line-height,28px);color:#414141;color:var(--dropdown-item-checkmark-color,#414141)}.nx-dropdown-results__option-checkicon nx-icon{line-height:28px;line-height:var(--dropdown-item-line-height,28px);font-size:16px}\n:host-context([data-whatinput=\"keyboard\"] .nx-dropdown__panel-body.is-stable).nx-dropdown-item--active .nx-dropdown-results__option .nx-dropdown-results__option-label {\n  border-radius: 4px;\n  box-shadow: 0 0 0 2px #ffffff, 0 0 0 6px #009DE6;\n  box-shadow: var(--focus-box-shadow, 0 0 0 2px #ffffff, 0 0 0 6px #009DE6); }\n  @media screen and (-ms-high-contrast: active) {\n    :host-context([data-whatinput=\"keyboard\"] .nx-dropdown__panel-body.is-stable).nx-dropdown-item--active .nx-dropdown-results__option .nx-dropdown-results__option-label {\n      box-shadow: 0 0 0 2px background, 0 0 0 6px windowText; } }\n\n\n:host-context([data-whatinput=\"keyboard\"] .nx-dropdown__panel-body.is-stable).nx-multiselect.nx-dropdown-item--active .nx-dropdown-results__option .nx-dropdown-results__option-label {\n  box-shadow: none; }\n  @media screen and (-ms-high-contrast: active) {\n    :host-context([data-whatinput=\"keyboard\"] .nx-dropdown__panel-body.is-stable).nx-multiselect.nx-dropdown-item--active .nx-dropdown-results__option .nx-dropdown-results__option-label {\n      box-shadow: none; } }\n\n:host-context([data-whatinput=\"keyboard\"] .nx-dropdown__panel-body.is-stable).nx-multiselect.nx-dropdown-item--active ::ng-deep .nx-checkbox__label {\n  border-radius: 4px;\n  box-shadow: 0 0 0 2px #ffffff, 0 0 0 6px #009DE6;\n  box-shadow: var(--focus-box-shadow, 0 0 0 2px #ffffff, 0 0 0 6px #009DE6); }\n  @media screen and (-ms-high-contrast: active) {\n    :host-context([data-whatinput=\"keyboard\"] .nx-dropdown__panel-body.is-stable).nx-multiselect.nx-dropdown-item--active ::ng-deep .nx-checkbox__label {\n      box-shadow: 0 0 0 2px background, 0 0 0 6px windowText; } }\n\n:host(.nx-selected.nx-dropdown-item--active) .nx-dropdown-results__option-label{padding-left:24px;margin-left:-24px}:host ::ng-deep .nx-checkbox__label{padding:0 4px;margin:0 -4px}"]
                }] }
    ];
    /** @nocollapse */
    NxDropdownItemComponent.ctorParameters = function () { return [
        { type: NxDropdownControl, decorators: [{ type: Inject, args: [NxDropdownControl,] }] },
        { type: NxDropdownGroupComponent, decorators: [{ type: Optional }] },
        { type: ChangeDetectorRef },
        { type: ElementRef }
    ]; };
    NxDropdownItemComponent.propDecorators = {
        value: [{ type: Input, args: ['nxValue',] }],
        onSelectionChange: [{ type: Output }],
        containerElement: [{ type: ViewChild, args: ['container', { static: true },] }]
    };
    return NxDropdownItemComponent;
}());
if (false) {
    /** @type {?} */
    NxDropdownItemComponent.prototype._hidden;
    /**
     * @type {?}
     * @private
     */
    NxDropdownItemComponent.prototype._mostRecentViewValue;
    /**
     * @type {?}
     * @private
     */
    NxDropdownItemComponent.prototype._id;
    /**
     * The value of the dropdown item.
     * You can't use undefined, null and '' (empty strings)
     * as they are sentinel values signalling empty data.
     * @type {?}
     */
    NxDropdownItemComponent.prototype.value;
    /**
     * @type {?}
     * @private
     */
    NxDropdownItemComponent.prototype._selected;
    /**
     * @type {?}
     * @private
     */
    NxDropdownItemComponent.prototype._active;
    /**
     * Emits whenever the component is destroyed.
     * @type {?}
     * @private
     */
    NxDropdownItemComponent.prototype._destroy;
    /**
     * Event emitted when the option is selected or deselected.
     * @type {?}
     */
    NxDropdownItemComponent.prototype.onSelectionChange;
    /**
     * Emits when the state of the option changes and any parents have to be notified.
     * @type {?}
     */
    NxDropdownItemComponent.prototype._stateChanges;
    /**
     * \@docs-private
     * The wrapping div in the template. Used by dropdown to use the container height for scrolling.
     * @type {?}
     */
    NxDropdownItemComponent.prototype.containerElement;
    /**
     * @type {?}
     * @private
     */
    NxDropdownItemComponent.prototype._dropdown;
    /**
     * \@docs-private
     * @type {?}
     */
    NxDropdownItemComponent.prototype.group;
    /**
     * @type {?}
     * @private
     */
    NxDropdownItemComponent.prototype._changeDetectorRef;
    /**
     * @type {?}
     * @private
     */
    NxDropdownItemComponent.prototype._elementRef;
}

/**
 * @fileoverview added by tsickle
 * Generated from: closed-label.directive.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
// This Directive solely purpose is to mark given ng-template and project it into the required destination.
var NxDropdownClosedLabelDirective = /** @class */ (function () {
    function NxDropdownClosedLabelDirective(templateRef) {
        this.templateRef = templateRef;
    }
    NxDropdownClosedLabelDirective.decorators = [
        { type: Directive, args: [{
                    selector: '[nxClosedLabel]'
                },] }
    ];
    /** @nocollapse */
    NxDropdownClosedLabelDirective.ctorParameters = function () { return [
        { type: TemplateRef }
    ]; };
    return NxDropdownClosedLabelDirective;
}());
if (false) {
    /** @type {?} */
    NxDropdownClosedLabelDirective.prototype.templateRef;
}

/**
 * @fileoverview added by tsickle
 * Generated from: dropdown.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Change event object that is emitted when the select value has changed.
 * @template T
 */
var  /**
 * Change event object that is emitted when the select value has changed.
 * @template T
 */
NxDropdownSelectChange = /** @class */ (function () {
    function NxDropdownSelectChange(source, value) {
        this.source = source;
        this.value = value;
    }
    return NxDropdownSelectChange;
}());
if (false) {
    /**
     * Reference to the select that emitted the change event.
     * @type {?}
     */
    NxDropdownSelectChange.prototype.source;
    /**
     * Current value of the select that emitted the event.
     * @type {?}
     */
    NxDropdownSelectChange.prototype.value;
}
/**
 * @return {?}
 */
function getPositions() {
    return [{
            originX: 'start',
            originY: 'top',
            overlayX: 'start',
            overlayY: 'top'
        }, {
            originX: 'start',
            originY: 'center',
            overlayX: 'start',
            overlayY: 'center'
        }, {
            originX: 'start',
            originY: 'bottom',
            overlayX: 'start',
            overlayY: 'bottom'
        }];
}
var NxDropdownComponent = /** @class */ (function (_super) {
    __extends(NxDropdownComponent, _super);
    function NxDropdownComponent(_changeDetectorRef, _elementRef, _ngZone, tabIndex, formFieldComponent, ngControl, _parentForm, _parentFormGroup) {
        var _this = _super.call(this) || this;
        _this._changeDetectorRef = _changeDetectorRef;
        _this._elementRef = _elementRef;
        _this._ngZone = _ngZone;
        _this.formFieldComponent = formFieldComponent;
        _this.ngControl = ngControl;
        _this._parentForm = _parentForm;
        _this._parentFormGroup = _parentFormGroup;
        // The dropdown currently doesn't support readonly of the NxFormfieldControl so we hardcode it here
        _this.readonly = false;
        _this._disabled = false;
        _this._focused = false;
        /**
         * Whether or not the overlay panel is open.
         */
        _this._panelOpen = false;
        /**
         * \@docs-private
         */
        _this.errorState = false;
        /**
         * \@docs-private
         */
        _this.isStable = false;
        /**
         * Name of this control that is used inside the formfield component
         * \@docs-private
         */
        _this.controlType = 'nx-dropdown';
        /**
         * The minimal space between the viewport and the overlay
         */
        _this._overlayViewportMargin = 16;
        /**
         * \@docs-private
         * Emits when internal state changes to inform formfield about it.
         */
        _this.stateChanges = new Subject();
        /**
         * The IDs of child options to be passed to the aria-owns attribute.
         */
        _this._optionIds = '';
        _this._tabIndex = 0;
        /**
         * \@docs-private
         */
        _this.currentFilter = '';
        /**
         * Label to describe the component.
         */
        _this._ariaLabel = '';
        _this._style = '';
        /**
         * Whether the dropdown should render in its negative style or not.
         */
        _this._negative = false;
        /**
         * Whether the dropdown should be shown with an additional filter input.
         */
        _this.showFilter = false;
        /**
         * Text displayed as placeholder for the filter.
         */
        _this.filterPlaceholder = '';
        /**
         * Event emitted when the select panel has been toggled.
         */
        _this.openedChange = new EventEmitter();
        /**
         * Event emitted when the select has been opened.
         */
        _this._openedStream = _this.openedChange.pipe(filter((/**
         * @param {?} o
         * @return {?}
         */
        function (o) { return o; })), map((/**
         * @return {?}
         */
        function () { })));
        /**
         * Event emitted when the select has been closed.
         */
        _this._closedStream = _this.openedChange.pipe(filter((/**
         * @param {?} o
         * @return {?}
         */
        function (o) { return !o; })), map((/**
         * @return {?}
         */
        function () { })));
        /**
         * Event emitted when the user types in the filter input.
         */
        _this.filterChanges = new Subject();
        /**
         * Event that emits whenever the raw value of the select changes. This is here primarily
         * to facilitate the two-way binding for the `value` input.
         * \@docs-private
         */
        _this.valueChange = new EventEmitter();
        /**
         * Event emitted when the selected value has been changed.
         */
        _this.selectionChange = new EventEmitter();
        /**
         * \@docs-private
         */
        _this.optionSelectionChanges = defer((/**
         * @return {?}
         */
        function () {
            if (_this.options) {
                return merge.apply(void 0, __spread(_this.options.map((/**
                 * @param {?} option
                 * @return {?}
                 */
                function (option) { return option.onSelectionChange; }))));
            }
            return _this._ngZone.onStable
                .asObservable()
                .pipe(take(1), switchMap((/**
             * @return {?}
             */
            function () { return _this.optionSelectionChanges; })));
        }));
        /**
         * Emits whenever the component is destroyed.
         */
        _this._destroy = new Subject();
        /**
         * Function that transforms the value into a string.
         * This function is used for displaying and filtering the content
         * ( Default: (value) => value ? value.toString() : null; ).
         */
        _this.valueFormatter = (/**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            return value == null ? '' : value.toString();
        });
        /**
         * Comparison function to specify which option is displayed. Defaults to object equality.
         */
        _this._compareWith = (/**
         * @param {?} o1
         * @param {?} o2
         * @return {?}
         */
        function (o1, o2) { return o1 === o2; });
        _this._filterFn = (/**
         * @param {?} search
         * @param {?} itemValue
         * @return {?}
         */
        function (search, itemValue) {
            return itemValue.toLocaleLowerCase().indexOf(search.toLocaleLowerCase()) >= 0;
        });
        /**
         * `View -> model callback called when value changes`
         */
        _this._onChange = (/**
         * @return {?}
         */
        function () { });
        /**
         * `View -> model callback called when select has been touched`
         */
        _this._onTouched = (/**
         * @return {?}
         */
        function () { });
        if (_this.ngControl) {
            // Note: we provide the value accessor through here, instead of
            // the `providers` to avoid running into a circular import.
            _this.ngControl.valueAccessor = _this;
        }
        _this._positions = getPositions();
        _this.tabIndex = parseInt(tabIndex, 10) || 0;
        return _this;
    }
    Object.defineProperty(NxDropdownComponent.prototype, "tabIndex", {
        get: /**
         * @return {?}
         */
        function () { return this.disabled ? -1 : this._tabIndex; },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            // If the specified tabIndex value is null or undefined, fall back to the default value.
            this._tabIndex = value != null ? value : 0;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NxDropdownComponent.prototype, "value", {
        /** Selected value */
        get: /**
         * Selected value
         * @return {?}
         */
        function () { return this._value; },
        set: /**
         * @param {?} newValue
         * @return {?}
         */
        function (newValue) {
            if (newValue !== this._value) {
                this.writeValue(newValue);
                this._value = newValue;
                this._onChange(newValue);
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NxDropdownComponent.prototype, "disabled", {
        /** Whether the dropdown is disabled. */
        get: /**
         * Whether the dropdown is disabled.
         * @return {?}
         */
        function () {
            return this._disabled;
        },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this._disabled = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NxDropdownComponent.prototype, "styles", {
        /** If set to 'negative', the component is displayed with the negative set of styles. */
        set: /**
         * If set to 'negative', the component is displayed with the negative set of styles.
         * @param {?} value
         * @return {?}
         */
        function (value) {
            if (this._style === value) {
                return;
            }
            this._style = value;
            this._negative = !!this._style.match(/negative/);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NxDropdownComponent.prototype, "closedDropdownLabel", {
        /** @docs-private */
        get: /**
         * \@docs-private
         * @return {?}
         */
        function () {
            return this._closedDropdownLabel;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NxDropdownComponent.prototype, "selected", {
        /**
         * @docs-private
         * The currently selected option.
         */
        get: /**
         * \@docs-private
         * The currently selected option.
         * @return {?}
         */
        function () {
            return this.isMultiSelect ? this._selectionModel.selected : this._selectionModel.selected[0];
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NxDropdownComponent.prototype, "panelOpen", {
        /** @docs-private */
        get: /**
         * \@docs-private
         * @return {?}
         */
        function () {
            return this._panelOpen;
        },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this._panelOpen = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NxDropdownComponent.prototype, "label", {
        /** @docs-private */
        get: /**
         * \@docs-private
         * @return {?}
         */
        function () {
            return this.formFieldComponent ? this.formFieldComponent.label : '';
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NxDropdownComponent.prototype, "compareWith", {
        /**
         * Function to compare the option values with the selected values. The first argument
         * is a value from an option. The second is a value from the selection. A boolean
         * should be returned.
         */
        get: /**
         * Function to compare the option values with the selected values. The first argument
         * is a value from an option. The second is a value from the selection. A boolean
         * should be returned.
         * @return {?}
         */
        function () { return this._compareWith; },
        set: /**
         * @param {?} fn
         * @return {?}
         */
        function (fn) {
            if (typeof fn !== 'function') {
                throw getNxDropdownNonFunctionValueError();
            }
            this._compareWith = fn;
            if (this._selectionModel) {
                // A different comparator means the selection could change.
                this._initializeSelection();
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NxDropdownComponent.prototype, "filterFn", {
        /**
         * Function to be used when the user types into the search filter. The first argument is the user input,
         * the second argument is the dropdown item value. The dropdown items will use this function to set their
         * visibility state.
         * A boolean should be returned.
         */
        get: /**
         * Function to be used when the user types into the search filter. The first argument is the user input,
         * the second argument is the dropdown item value. The dropdown items will use this function to set their
         * visibility state.
         * A boolean should be returned.
         * @return {?}
         */
        function () { return this._filterFn; },
        set: /**
         * @param {?} fn
         * @return {?}
         */
        function (fn) {
            if (typeof fn !== 'function') {
                throw getNxDropdownNonFunctionValueError();
            }
            this._filterFn = fn;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NxDropdownComponent.prototype, "focused", {
        /**
         * @docs-private
         * Whether the select is focused.
         */
        get: /**
         * \@docs-private
         * Whether the select is focused.
         * @return {?}
         */
        function () {
            return this._focused || this.panelOpen;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NxDropdownComponent.prototype, "elementRef", {
        /** @docs-private */
        get: /**
         * \@docs-private
         * @return {?}
         */
        function () {
            return this._elementRef;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @return {?}
     */
    NxDropdownComponent.prototype.ngDoCheck = /**
     * @return {?}
     */
    function () {
        if (this.ngControl) {
            this.updateErrorState();
        }
    };
    /**
     * @return {?}
     */
    NxDropdownComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        this._selectionModel = new SelectionModel(this.isMultiSelect);
    };
    /**
     * @return {?}
     */
    NxDropdownComponent.prototype.ngAfterContentInit = /**
     * @return {?}
     */
    function () {
        var _this = this;
        this._closedDropdownLabel =
            this._customClosedDropdownLabel && this._customClosedDropdownLabel.templateRef || this._defaultClosedDropdownLabel;
        this._initKeyManager();
        this._selectionModel.changed.pipe(takeUntil(this._destroy)).subscribe((/**
         * @param {?} event
         * @return {?}
         */
        function (event) {
            event.added.forEach((/**
             * @param {?} option
             * @return {?}
             */
            function (option) { return option.select(); }));
            event.removed.forEach((/**
             * @param {?} option
             * @return {?}
             */
            function (option) { return option.deselect(); }));
        }));
        this.options.changes.pipe(startWith(null), takeUntil(this._destroy)).subscribe((/**
         * @return {?}
         */
        function () {
            _this._resetOptions();
            _this._initializeSelection();
        }));
    };
    /**
     * @return {?}
     */
    NxDropdownComponent.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        this._destroy.next();
        this._destroy.complete();
    };
    /** @docs-private */
    /**
     * \@docs-private
     * @param {?} control
     * @param {?} form
     * @return {?}
     */
    NxDropdownComponent.prototype.isErrorState = /**
     * \@docs-private
     * @param {?} control
     * @param {?} form
     * @return {?}
     */
    function (control, form) {
        return !!(control && control.invalid && (control.touched || (form && form.submitted)));
    };
    /** @docs-private */
    /**
     * \@docs-private
     * @return {?}
     */
    NxDropdownComponent.prototype.updateErrorState = /**
     * \@docs-private
     * @return {?}
     */
    function () {
        /** @type {?} */
        var oldState = this.errorState;
        /** @type {?} */
        var parent = this._parentFormGroup || this._parentForm;
        /** @type {?} */
        var control = this.ngControl ? (/** @type {?} */ (this.ngControl.control)) : null;
        /** @type {?} */
        var newState = this.isErrorState(control, parent);
        if (newState !== oldState) {
            this.errorState = newState;
            this.stateChanges.next();
        }
    };
    /** Sets up a key manager to listen to keyboard events on the overlay panel. */
    /**
     * Sets up a key manager to listen to keyboard events on the overlay panel.
     * @private
     * @return {?}
     */
    NxDropdownComponent.prototype._initKeyManager = /**
     * Sets up a key manager to listen to keyboard events on the overlay panel.
     * @private
     * @return {?}
     */
    function () {
        var _this = this;
        this._keyManager = new ActiveDescendantKeyManager(this.options)
            .withTypeAhead()
            .withWrap()
            .withVerticalOrientation()
            .withHorizontalOrientation('ltr')
            .skipPredicate((/**
         * @param {?} item
         * @return {?}
         */
        function (item) { return item._hidden; }));
        this._keyManager.tabOut.pipe(takeUntil(this._destroy)).subscribe((/**
         * @return {?}
         */
        function () {
            // Restore focus to the trigger before closing. Ensures that the focus
            // position won't be lost if the user got focus into the overlay.
            _this.closePanel();
        }));
        this._keyManager.change.pipe(takeUntil(this._destroy)).subscribe((/**
         * @return {?}
         */
        function () {
            if (_this._panelOpen && _this.panel) {
                // Delay the auto scrolling until all items have settled otherwise the item containers might
                // not exist yet
                _this._ngZone.onStable
                    .asObservable()
                    .pipe(take(1)).subscribe((/**
                 * @return {?}
                 */
                function () {
                    _this._scrollActiveOptionIntoView();
                }));
            }
            else if (!_this._panelOpen && !_this.isMultiSelect && _this._keyManager.activeItem) {
                _this._keyManager.activeItem._selectViaInteraction();
            }
        }));
    };
    /**
     * @private
     * @return {?}
     */
    NxDropdownComponent.prototype._resetOptions = /**
     * @private
     * @return {?}
     */
    function () {
        var _this = this;
        /** @type {?} */
        var changedOrDestroyed = merge(this.options.changes, this._destroy);
        this.optionSelectionChanges.pipe(takeUntil(changedOrDestroyed)).subscribe((/**
         * @param {?} event
         * @return {?}
         */
        function (event) {
            _this._onSelect(event.item, event.isUserInput);
            if (event.isUserInput && !_this.isMultiSelect && _this._panelOpen) {
                _this.closePanel();
            }
        }));
        // Listen to changes in the internal state of the options and react accordingly.
        // Handles cases like the labels of the selected options changing.
        merge.apply(void 0, __spread(this.options.map((/**
         * @param {?} option
         * @return {?}
         */
        function (option) { return option._stateChanges; })))).pipe(takeUntil(changedOrDestroyed))
            .subscribe((/**
         * @return {?}
         */
        function () {
            // defer it for the next cycle to not run in changed after checked errors
            // the combination of dropdown-item notifying parent and when the parent
            // tries to fetch the triggerValue from the child throws these errors
            setTimeout((/**
             * @return {?}
             */
            function () {
                _this._changeDetectorRef.markForCheck();
                _this.stateChanges.next();
            }));
        }));
        this._setOptionIds();
    };
    /** Records option IDs to pass to the aria-owns property. */
    /**
     * Records option IDs to pass to the aria-owns property.
     * @private
     * @return {?}
     */
    NxDropdownComponent.prototype._setOptionIds = /**
     * Records option IDs to pass to the aria-owns property.
     * @private
     * @return {?}
     */
    function () {
        this._optionIds = this.options.map((/**
         * @param {?} option
         * @return {?}
         */
        function (option) { return option.id; })).join(' ');
    };
    /** Invoked when an option is clicked. */
    /**
     * Invoked when an option is clicked.
     * @private
     * @param {?} option
     * @param {?} isUserInput
     * @return {?}
     */
    NxDropdownComponent.prototype._onSelect = /**
     * Invoked when an option is clicked.
     * @private
     * @param {?} option
     * @param {?} isUserInput
     * @return {?}
     */
    function (option, isUserInput) {
        /** @type {?} */
        var wasSelected = this._selectionModel.isSelected(option);
        if (option.value == null && !this.isMultiSelect) {
            option.deselect();
            this._selectionModel.clear();
            this._propagateChanges(option.value);
        }
        else {
            option.selected ? this._selectionModel.select(option) : this._selectionModel.deselect(option);
            if (isUserInput) {
                this._keyManager.setActiveItem(option);
            }
            if (this.isMultiSelect) {
                this._sortValues();
            }
        }
        if (wasSelected !== this._selectionModel.isSelected(option)) {
            this._propagateChanges();
        }
        this.stateChanges.next();
    };
    /**
     * @private
     * @return {?}
     */
    NxDropdownComponent.prototype._initializeSelection = /**
     * @private
     * @return {?}
     */
    function () {
        var _this = this;
        // Defer setting the value in order to avoid the "Expression
        // has changed after it was checked" errors from Angular.
        Promise.resolve().then((/**
         * @return {?}
         */
        function () {
            _this._setSelectionByValue(_this.ngControl ? _this.ngControl.value : _this._value);
        }));
    };
    /**
     * Sets the selected option based on a value. If no option can be
     * found with the designated value, the select trigger is cleared.
     */
    /**
     * Sets the selected option based on a value. If no option can be
     * found with the designated value, the select trigger is cleared.
     * @private
     * @param {?} value
     * @return {?}
     */
    NxDropdownComponent.prototype._setSelectionByValue = /**
     * Sets the selected option based on a value. If no option can be
     * found with the designated value, the select trigger is cleared.
     * @private
     * @param {?} value
     * @return {?}
     */
    function (value) {
        var _this = this;
        if (this.isMultiSelect && value) {
            if (!Array.isArray(value)) {
                throw getNxDropdownNonArrayValueError();
            }
            this._selectionModel.clear();
            value.forEach((/**
             * @param {?} currentValue
             * @return {?}
             */
            function (currentValue) { return _this._selectValue(currentValue); }));
            this._sortValues();
        }
        else {
            this._selectionModel.clear();
            /** @type {?} */
            var correspondingOption = this._selectValue(value);
            // Shift focus to the active item. Note that we shouldn't do this in multiple
            // mode, because we don't know what option the user interacted with last.
            if (correspondingOption) {
                this._keyManager.setActiveItem(correspondingOption);
            }
        }
        this._changeDetectorRef.markForCheck();
    };
    /**
     * Finds and selects and option based on its value.
     * @returns Option that has the corresponding value.
     */
    /**
     * Finds and selects and option based on its value.
     * @private
     * @param {?} value
     * @return {?} Option that has the corresponding value.
     */
    NxDropdownComponent.prototype._selectValue = /**
     * Finds and selects and option based on its value.
     * @private
     * @param {?} value
     * @return {?} Option that has the corresponding value.
     */
    function (value) {
        var _this = this;
        /** @type {?} */
        var correspondingOption = this.options.find((/**
         * @param {?} option
         * @return {?}
         */
        function (option) {
            try {
                // Treat null as a special reset value.
                return option.value != null && _this._compareWith(option.value, value);
            }
            catch (error) {
                if (isDevMode()) {
                    // Notify developers of errors in their comparator.
                    console.warn(error);
                }
                return false;
            }
        }));
        if (correspondingOption) {
            this._selectionModel.select(correspondingOption);
        }
        return correspondingOption;
    };
    /** Emits change event to set the model value. */
    /**
     * Emits change event to set the model value.
     * @private
     * @param {?=} fallbackValue
     * @return {?}
     */
    NxDropdownComponent.prototype._propagateChanges = /**
     * Emits change event to set the model value.
     * @private
     * @param {?=} fallbackValue
     * @return {?}
     */
    function (fallbackValue) {
        /** @type {?} */
        var valueToEmit = null;
        if (this.isMultiSelect) {
            valueToEmit = ((/** @type {?} */ (this.selected))).map((/**
             * @param {?} option
             * @return {?}
             */
            function (option) { return option.value; }));
        }
        else {
            valueToEmit = this.selected ? ((/** @type {?} */ (this.selected))).value : fallbackValue;
        }
        this._value = valueToEmit;
        this.valueChange.emit(valueToEmit);
        this._onChange(valueToEmit);
        this.selectionChange.emit(new NxDropdownSelectChange(this, valueToEmit));
        this._changeDetectorRef.markForCheck();
    };
    /** Sorts the selected values in the selected based on their order in the panel. */
    /**
     * Sorts the selected values in the selected based on their order in the panel.
     * @private
     * @return {?}
     */
    NxDropdownComponent.prototype._sortValues = /**
     * Sorts the selected values in the selected based on their order in the panel.
     * @private
     * @return {?}
     */
    function () {
        if (this.isMultiSelect) {
            /** @type {?} */
            var options_1 = this.options.toArray();
            this._selectionModel.sort((/**
             * @param {?} a
             * @param {?} b
             * @return {?}
             */
            function (a, b) { return options_1.indexOf(a) - options_1.indexOf(b); }));
            this.stateChanges.next();
        }
    };
    /** Adds a offset to the overlay position, so the formfield label and the dropdown panel header are vertically aligned. */
    /**
     * Adds a offset to the overlay position, so the formfield label and the dropdown panel header are vertically aligned.
     * @private
     * @return {?}
     */
    NxDropdownComponent.prototype._updatePositionOffset = /**
     * Adds a offset to the overlay position, so the formfield label and the dropdown panel header are vertically aligned.
     * @private
     * @return {?}
     */
    function () {
        /** @type {?} */
        var offset = 0;
        if (this.formFieldComponent !== null) {
            /** @type {?} */
            var formFieldRect = this.formFieldComponent.elementRef.nativeElement.getBoundingClientRect();
            /** @type {?} */
            var dropdownRect = this._elementRef.nativeElement.getBoundingClientRect();
            /** @type {?} */
            var panelHeader = this.overlayDir.overlayRef.overlayElement.querySelector('.nx-dropdown__panel-header');
            /** @type {?} */
            var panelHeaderPaddingTop = panelHeader ? parseInt(getComputedStyle(panelHeader).paddingTop, 10) : 0;
            offset = formFieldRect.top - dropdownRect.top - panelHeaderPaddingTop;
        }
        this._positions[0].offsetY = offset;
    };
    /** Focuses the select element. */
    /**
     * Focuses the select element.
     * @return {?}
     */
    NxDropdownComponent.prototype.focus = /**
     * Focuses the select element.
     * @return {?}
     */
    function () {
        this._elementRef.nativeElement.focus();
    };
    /** Opens the panel of the dropdown. */
    /**
     * Opens the panel of the dropdown.
     * @return {?}
     */
    NxDropdownComponent.prototype.openPanel = /**
     * Opens the panel of the dropdown.
     * @return {?}
     */
    function () {
        if (this.disabled || !this.options || !this.options.length || this._panelOpen) {
            return;
        }
        this._panelOpen = true;
        this._triggerRect = this.trigger.nativeElement.getBoundingClientRect();
        this._keyManager.withHorizontalOrientation(null);
        this._highlightCorrectOption();
        this._changeDetectorRef.markForCheck();
    };
    /** Closes the panel of the dropdown. */
    /**
     * Closes the panel of the dropdown.
     * @return {?}
     */
    NxDropdownComponent.prototype.closePanel = /**
     * Closes the panel of the dropdown.
     * @return {?}
     */
    function () {
        var _this = this;
        if (this._panelOpen) {
            this._panelOpen = false;
            this.isStable = false;
            this._keyManager.withHorizontalOrientation('ltr');
            this._changeDetectorRef.markForCheck();
            this._onTouched();
            this.openedChange.emit(false);
            // defer the focus if the dropdown triggers actions that detach
            // a template/view from the DOM to prevent changed after checked errors
            setTimeout((/**
             * @return {?}
             */
            function () { return _this.focus(); }));
        }
    };
    // calculate inital scrollTop when the dropdown opens
    // scrolls the selected item to the middle of the panel if possible
    // calculate inital scrollTop when the dropdown opens
    // scrolls the selected item to the middle of the panel if possible
    /**
     * @private
     * @return {?}
     */
    NxDropdownComponent.prototype._calculateScrollTop = 
    // calculate inital scrollTop when the dropdown opens
    // scrolls the selected item to the middle of the panel if possible
    /**
     * @private
     * @return {?}
     */
    function () {
        // reset the scrolltop to make calculation easier
        this.panelBody.nativeElement.scrollTop = 0;
        if (!this.empty) {
            /** @type {?} */
            var offset = this._getItemOffset(this._keyManager.activeItem);
            /** @type {?} */
            var panelHeight = this.panelBody.nativeElement.offsetHeight;
            /** @type {?} */
            var panelRect = this.panelBody.nativeElement.getBoundingClientRect();
            /** @type {?} */
            var middleOfPanel = panelRect.top + panelHeight / 2;
            if (offset > middleOfPanel) {
                // because we reset the scrollTop to 0 at the top we can simply take the middleOfPanel which is our
                // target position for the item and subtract it from the offset (which is now always relative to the viewport)
                this.panelBody.nativeElement.scrollTop = offset - middleOfPanel;
            }
        }
    };
    /** Scrolls the active option into view. */
    /**
     * Scrolls the active option into view.
     * @private
     * @return {?}
     */
    NxDropdownComponent.prototype._scrollActiveOptionIntoView = /**
     * Scrolls the active option into view.
     * @private
     * @return {?}
     */
    function () {
        if (!this.panelOpen || !this._keyManager.activeItem) {
            return;
        }
        /** @type {?} */
        var activeItem = this._keyManager.activeItem.containerElement.nativeElement;
        /** @type {?} */
        var panel = this.panelBody.nativeElement;
        /** @type {?} */
        var panelOffset = panel.offsetTop;
        // how much the overlay is repositioned on the page
        /** @type {?} */
        var panelTopScrollPosition = panel.scrollTop;
        /** @type {?} */
        var panelHeight = panel.clientHeight;
        /** @type {?} */
        var itemTop = activeItem.offsetTop - panelOffset;
        /** @type {?} */
        var itemBottom = activeItem.offsetTop - panelOffset + activeItem.getBoundingClientRect().height;
        // item half or less visible on top
        if (itemTop < panelTopScrollPosition) {
            this.panelBody.nativeElement.scrollTop = itemTop;
            // item half or less visible on bottom
        }
        else if (itemBottom > (panelTopScrollPosition + panelHeight)) {
            this.panelBody.nativeElement.scrollTop = itemBottom - panelHeight;
        }
    };
    /** @docs-private */
    /**
     * \@docs-private
     * @private
     * @param {?} item
     * @return {?}
     */
    NxDropdownComponent.prototype._getItemOffset = /**
     * \@docs-private
     * @private
     * @param {?} item
     * @return {?}
     */
    function (item) {
        /** @type {?} */
        var itemRect = item.containerElement.nativeElement.getBoundingClientRect();
        return itemRect.top + (itemRect.height / 2); // get position of the item's center
    };
    /**
     * @docs-private
     * Formfield Implementation
     */
    /**
     * \@docs-private
     * Formfield Implementation
     * @param {?} ids
     * @return {?}
     */
    NxDropdownComponent.prototype.setDescribedByIds = /**
     * \@docs-private
     * Formfield Implementation
     * @param {?} ids
     * @return {?}
     */
    function (ids) {
        this.ariaDescribedby = ids.join(' ');
    };
    /** @docs-private */
    /**
     * \@docs-private
     * @param {?} value
     * @return {?}
     */
    NxDropdownComponent.prototype.setAriaLabel = /**
     * \@docs-private
     * @param {?} value
     * @return {?}
     */
    function (value) {
        this._ariaLabel = value;
    };
    /**
     * @return {?}
     */
    NxDropdownComponent.prototype._getAriaLabel = /**
     * @return {?}
     */
    function () {
        return this._ariaLabel || (this.formFieldComponent ? this.formFieldComponent.label : null);
    };
    Object.defineProperty(NxDropdownComponent.prototype, "_isInOutlineField", {
        get: /**
         * @return {?}
         */
        function () {
            return this.formFieldComponent !== null
                && this.formFieldComponent.appearance === 'outline';
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NxDropdownComponent.prototype, "empty", {
        /**
         * @docs-private
         * Whether the select has a value.
         */
        get: /**
         * \@docs-private
         * Whether the select has a value.
         * @return {?}
         */
        function () {
            return !this._selectionModel || this._selectionModel.isEmpty();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NxDropdownComponent.prototype, "hasValue", {
        /** @docs-private */
        get: /**
         * \@docs-private
         * @return {?}
         */
        function () {
            return this._selectionModel.hasValue();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NxDropdownComponent.prototype, "shouldLabelFloat", {
        /** @docs-private */
        get: /**
         * \@docs-private
         * @return {?}
         */
        function () {
            return this.focused || !this.empty;
        },
        enumerable: true,
        configurable: true
    });
    /** End Formfield */
    /** ControlValueAccessor */
    /**
     * Sets the select's value. Part of the ControlValueAccessor interface
     * required to integrate with Angular's core forms API.
     *
     * @param value New value to be written to the model.
     */
    /** End Formfield */
    /** ControlValueAccessor */
    /**
     * Sets the select's value. Part of the ControlValueAccessor interface
     * required to integrate with Angular's core forms API.
     *
     * @param {?} value New value to be written to the model.
     * @return {?}
     */
    NxDropdownComponent.prototype.writeValue = /** End Formfield */
    /** ControlValueAccessor */
    /**
     * Sets the select's value. Part of the ControlValueAccessor interface
     * required to integrate with Angular's core forms API.
     *
     * @param {?} value New value to be written to the model.
     * @return {?}
     */
    function (value) {
        if (this.options) {
            this._setSelectionByValue(value);
        }
    };
    /**
     * @param {?} fn
     * @return {?}
     */
    NxDropdownComponent.prototype.registerOnChange = /**
     * @param {?} fn
     * @return {?}
     */
    function (fn) {
        this._onChange = fn;
    };
    /**
     * @param {?} fn
     * @return {?}
     */
    NxDropdownComponent.prototype.registerOnTouched = /**
     * @param {?} fn
     * @return {?}
     */
    function (fn) {
        this._onTouched = fn;
    };
    /**
     * Disables the select. Part of the ControlValueAccessor interface required
     * to integrate with Angular's core forms API.
     *
     * @param isDisabled Sets whether the component is disabled.
     */
    /**
     * Disables the select. Part of the ControlValueAccessor interface required
     * to integrate with Angular's core forms API.
     *
     * @param {?} isDisabled Sets whether the component is disabled.
     * @return {?}
     */
    NxDropdownComponent.prototype.setDisabledState = /**
     * Disables the select. Part of the ControlValueAccessor interface required
     * to integrate with Angular's core forms API.
     *
     * @param {?} isDisabled Sets whether the component is disabled.
     * @return {?}
     */
    function (isDisabled) {
        this.disabled = isDisabled;
        this._changeDetectorRef.markForCheck();
        this.stateChanges.next();
    };
    /** End ControlValueAccessor */
    /**
     * End ControlValueAccessor
     * @param {?} event
     * @return {?}
     */
    NxDropdownComponent.prototype._handleKeydown = /**
     * End ControlValueAccessor
     * @param {?} event
     * @return {?}
     */
    function (event) {
        this.panelOpen ? this._handleOpenKeydown(event) : this._handleClosedKeydown(event);
    };
    /**
     * @private
     * @param {?} event
     * @return {?}
     */
    NxDropdownComponent.prototype._handleClosedKeydown = /**
     * @private
     * @param {?} event
     * @return {?}
     */
    function (event) {
        /** @type {?} */
        var keyCode = event.keyCode;
        /** @type {?} */
        var isArrowKey = keyCode === DOWN_ARROW || keyCode === UP_ARROW ||
            keyCode === LEFT_ARROW || keyCode === RIGHT_ARROW;
        /** @type {?} */
        var isOpenKey = keyCode === ENTER || keyCode === SPACE;
        // Open the select on ALT + arrow key to match the native <select>
        if (isOpenKey || ((this.isMultiSelect || event.altKey) && isArrowKey)) {
            event.preventDefault(); // prevents the page from scrolling down when pressing space
            this.openPanel();
        }
        else if (!this.isMultiSelect && !this.disabled) {
            this._keyManager.onKeydown(event);
        }
    };
    /**
     * @private
     * @param {?} event
     * @return {?}
     */
    NxDropdownComponent.prototype._handleOpenKeydown = /**
     * @private
     * @param {?} event
     * @return {?}
     */
    function (event) {
        var _this = this;
        /** @type {?} */
        var keyCode = event.keyCode;
        // if has filter all events other than the listed ones should be ignored or handled in _onFilter()
        if (!([DOWN_ARROW, UP_ARROW, HOME, END, ENTER, LEFT_ARROW, RIGHT_ARROW, SHIFT, SPACE, TAB].indexOf(keyCode) >= 0)
            && this.showFilter) {
            return;
        }
        /** @type {?} */
        var isArrowKey = keyCode === DOWN_ARROW || keyCode === UP_ARROW;
        /** @type {?} */
        var manager = this._keyManager;
        /** @type {?} */
        var allHidden = this.options.map((/**
         * @param {?} option
         * @return {?}
         */
        function (option) { return option._hidden; })).every((/**
         * @param {?} option
         * @return {?}
         */
        function (option) { return Boolean(option); }));
        if (keyCode === HOME || keyCode === END) {
            event.preventDefault();
            keyCode === HOME ? manager.setFirstItemActive() : manager.setLastItemActive();
        }
        else if (isArrowKey && event.altKey) {
            // Close the select on ALT + arrow key to match the native <select>
            event.preventDefault();
            this.closePanel();
        }
        else if (keyCode === ENTER && manager.activeItem && !allHidden) {
            event.preventDefault();
            manager.activeItem._selectViaInteraction();
        }
        else if (keyCode === ENTER && allHidden) {
            event.preventDefault();
            this.closePanel();
        }
        else if (!this.showFilter && keyCode === SPACE && manager.activeItem) {
            event.preventDefault();
            manager.activeItem._selectViaInteraction();
        }
        else if (keyCode === TAB) {
            this.closePanel();
        }
        else {
            /** @type {?} */
            var previouslyFocusedIndex = manager.activeItemIndex;
            manager.onKeydown(event);
            this._ngZone.onStable
                .asObservable()
                .pipe(take(1), delay(251) // we need to defer to get the new activeItemIndex. delay > debouncing of the typeAhead
            ).subscribe((/**
             * @return {?}
             */
            function () {
                _this.isStable = true;
                _this._changeDetectorRef.detectChanges();
            }));
            if (this.isMultiSelect && isArrowKey && event.shiftKey && manager.activeItem &&
                manager.activeItemIndex !== previouslyFocusedIndex) {
                manager.activeItem._selectViaInteraction();
            }
        }
    };
    /** @docs-private */
    /**
     * \@docs-private
     * @param {?} value
     * @return {?}
     */
    NxDropdownComponent.prototype.formatValue = /**
     * \@docs-private
     * @param {?} value
     * @return {?}
     */
    function (value) {
        return this.valueFormatter(value);
    };
    /** Called when the user types in the filter input */
    /**
     * Called when the user types in the filter input
     * @param {?} event
     * @return {?}
     */
    NxDropdownComponent.prototype._onFilter = /**
     * Called when the user types in the filter input
     * @param {?} event
     * @return {?}
     */
    function (event) {
        event.preventDefault();
        this.currentFilter = event.target.value;
        this.filterChanges.next(event.target.value);
        /** @type {?} */
        var allHidden = this.options.map((/**
         * @param {?} option
         * @return {?}
         */
        function (option) { return option._hidden; })).every((/**
         * @param {?} option
         * @return {?}
         */
        function (option) { return Boolean(option); }));
        if (allHidden) {
            this._keyManager.setActiveItem(null);
        }
        else {
            this._keyManager.setFirstItemActive();
        }
    };
    Object.defineProperty(NxDropdownComponent.prototype, "triggerValue", {
        /**
         * @docs-private
         * The value displayed in the trigger.
         */
        get: /**
         * \@docs-private
         * The value displayed in the trigger.
         * @return {?}
         */
        function () {
            if (this.empty) {
                return '';
            }
            if (this.isMultiSelect) {
                /** @type {?} */
                var selectedOptions = this._selectionModel.selected.map((/**
                 * @param {?} option
                 * @return {?}
                 */
                function (option) { return option.viewValue; }));
                return selectedOptions.join(', ');
            }
            return this._selectionModel.selected[0].viewValue;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Highlights the selected item. If no option is selected, it will highlight
     * the first item instead.
     */
    /**
     * Highlights the selected item. If no option is selected, it will highlight
     * the first item instead.
     * @private
     * @return {?}
     */
    NxDropdownComponent.prototype._highlightCorrectOption = /**
     * Highlights the selected item. If no option is selected, it will highlight
     * the first item instead.
     * @private
     * @return {?}
     */
    function () {
        if (this._keyManager) {
            if (this.empty) {
                this._keyManager.setFirstItemActive();
            }
            else {
                this._keyManager.setActiveItem(this._selectionModel.selected[0]);
            }
        }
    };
    /**
     * Callback that is invoked when the overlay panel has been attached.
     */
    /**
     * Callback that is invoked when the overlay panel has been attached.
     * @return {?}
     */
    NxDropdownComponent.prototype._onAttached = /**
     * Callback that is invoked when the overlay panel has been attached.
     * @return {?}
     */
    function () {
        var _this = this;
        this.overlayDir.positionChange.pipe(take(1)).subscribe((/**
         * @return {?}
         */
        function () {
            /** @type {?} */
            var overlayRef = _this.overlayDir.overlayRef;
            /** @type {?} */
            var positionStrategy = (/** @type {?} */ (overlayRef.getConfig()
                .positionStrategy));
            _this._updatePositionOffset();
            positionStrategy.withPositions(_this._positions.slice());
            overlayRef.updatePosition();
            if (_this._keyManager.activeItem) {
                _this._calculateScrollTop();
            }
            _this._changeDetectorRef.markForCheck();
            _this.openedChange.emit(true);
            // If there is no item selected, the filter takes the focus.
            if (_this.showFilter && !_this._value) {
                _this.filterInput.nativeElement.focus();
            }
            else {
                _this.panelBody.nativeElement.focus();
            }
        }));
    };
    /**
     * @return {?}
     */
    NxDropdownComponent.prototype._onFocus = /**
     * @return {?}
     */
    function () {
        if (!this.disabled) {
            this._focused = true;
            this.stateChanges.next();
        }
    };
    /**
     * Calls the touched callback only if the panel is closed. Otherwise, the trigger will
     * "blur" to the panel when it opens, causing a false positive.
     */
    /**
     * Calls the touched callback only if the panel is closed. Otherwise, the trigger will
     * "blur" to the panel when it opens, causing a false positive.
     * @return {?}
     */
    NxDropdownComponent.prototype._onBlur = /**
     * Calls the touched callback only if the panel is closed. Otherwise, the trigger will
     * "blur" to the panel when it opens, causing a false positive.
     * @return {?}
     */
    function () {
        this._focused = false;
        if (this.filterInput && this.showFilter) {
            this._clearFilter();
        }
        if (!this.disabled && !this.panelOpen) {
            this._onTouched();
            this._changeDetectorRef.markForCheck();
            this.stateChanges.next();
        }
    };
    Object.defineProperty(NxDropdownComponent.prototype, "isFilterEmpty", {
        /** @docs-private */
        get: /**
         * \@docs-private
         * @return {?}
         */
        function () {
            return this.currentFilter.length === 0;
        },
        enumerable: true,
        configurable: true
    });
    /** @docs-private */
    /**
     * \@docs-private
     * @return {?}
     */
    NxDropdownComponent.prototype._clearFilter = /**
     * \@docs-private
     * @return {?}
     */
    function () {
        this.filterInput.nativeElement.value = '';
        this.currentFilter = '';
        this.filterChanges.next('');
    };
    /** @docs-private determines the `aria-activedescendant` to be set on the host. */
    /**
     * \@docs-private determines the `aria-activedescendant` to be set on the host.
     * @return {?}
     */
    NxDropdownComponent.prototype._getAriaActiveDescendant = /**
     * \@docs-private determines the `aria-activedescendant` to be set on the host.
     * @return {?}
     */
    function () {
        if (this.panelOpen && this._keyManager && this._keyManager.activeItem) {
            return this._keyManager.activeItem.id;
        }
        return null;
    };
    NxDropdownComponent.decorators = [
        { type: Component, args: [{
                    selector: 'nx-dropdown',
                    template: "\n<!-- input and stuff-->\n<div cdkOverlayOrigin\n    #origin=\"cdkOverlayOrigin\"\n    class=\"nx-dropdown__container\"\n    #trigger>\n  <div class=\"nx-dropdown__rendered\">\n    <ng-container *ngTemplateOutlet=\"closedDropdownLabel\"></ng-container>\n  </div>\n  <div class=\"nx-dropdown__icon\">\n    <nx-icon class=\"nx-dropdown__chevron\" name=\"chevron-down\"></nx-icon>\n  </div>\n</div>\n\n<ng-template #defaultClosedDropdownLabel>\n  <span *ngIf=\"triggerValue\">{{ triggerValue }}</span>\n</ng-template>\n\n<!-- overlay -->\n<ng-template\n  cdkConnectedOverlay\n  cdkConnectedOverlayHasBackdrop\n  cdkConnectedOverlayBackdropClass=\"cdk-overlay-transparent-backdrop\"\n  [cdkConnectedOverlayOrigin]=\"origin\"\n  [cdkConnectedOverlayOpen]=\"panelOpen\"\n  [cdkConnectedOverlayPositions]=\"_positions\"\n  [cdkConnectedOverlayMinWidth]=\"_triggerRect?.width\"\n  [cdkConnectedOverlayFlexibleDimensions]=\"true\"\n  [cdkConnectedOverlayViewportMargin]=\"_overlayViewportMargin\"\n  [cdkConnectedOverlayPush]=\"true\"\n  (backdropClick)=\"closePanel()\"\n  (attach)=\"_onAttached()\"\n  (detach)=\"closePanel()\">\n\n  <div class=\"nx-dropdown__panel\"\n      [class.has-filter]=\"showFilter\"\n      [class.nx-dropdown__panel--in-outline-field]=\"_isInOutlineField\"\n      (keydown)=\"_handleKeydown($event)\"\n      #panel>\n    <div class=\"nx-dropdown__panel-header\" *ngIf=\"label\">\n      {{ label }}\n    </div>\n    <div class=\"nx-dropdown__filter\" *ngIf=\"showFilter\">\n      <input class=\"nx-dropdown__filter-input\"\n             [class.is-filled]=\"!isFilterEmpty\"\n             #filterInput\n             type=\"text\"\n             (input)=\"_onFilter($event)\"\n             [placeholder]=\"filterPlaceholder\"\n      >\n      <span class=\"nx-dropdown__filter-icon\" *ngIf=\"!isFilterEmpty\" (click)=\"_clearFilter()\">\n        <nx-icon name=\"close\"></nx-icon>\n      </span>\n    </div>\n\n    <div class=\"nx-dropdown__panel-body\"\n         tabindex=\"-1\"\n         role=\"listbox\"\n         #panelBody\n         [class.is-stable]=\"isStable\"\n         [attr.aria-activedescendant]=\"_getAriaActiveDescendant()\"\n         [attr.aria-multiselectable]=\"isMultiSelect\"\n    >\n        <ng-content></ng-content>\n      </div>\n  </div>\n</ng-template>\n",
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    providers: [
                        { provide: NxDropdownControl, useExisting: NxDropdownComponent },
                        { provide: NxFormfieldControl, useExisting: NxDropdownComponent },
                    ],
                    host: {
                        'role': 'button',
                        '[class.nx-dropdown]': 'true',
                        '[class.is-filled]': 'hasValue',
                        '[class.has-focus]': 'focused',
                        '[class.nx-dropdown--negative]': '_negative',
                        '[class.nx-dropdown--disabled]': 'disabled',
                        '[attr.aria-describedby]': 'ariaDescribedby || null',
                        '[attr.aria-required]': 'required',
                        '[attr.aria-label]': '_getAriaLabel()',
                        'aria-haspopup': 'listbox',
                        '[attr.aria-expanded]': 'panelOpen',
                        '[attr.disabled]': 'disabled || null',
                        '[attr.tabindex]': 'tabIndex',
                        '(keydown)': '_handleKeydown($event)',
                        '(focus)': '_onFocus()',
                        '(blur)': '_onBlur()',
                        '(click)': 'openPanel()'
                    },
                    styles: [":host{display:block;width:100%}:host:focus{outline:0}:host(.nx-dropdown--negative):focus{font-weight:600}:host(.nx-dropdown--negative){color:#fff}.nx-dropdown__container{display:flex;justify-content:flex-end;align-items:center;height:100%;cursor:pointer}:host(.nx-dropdown--disabled) .nx-dropdown__container{cursor:not-allowed}.nx-dropdown__rendered{flex:1 1 auto;overflow:hidden;text-overflow:ellipsis;white-space:nowrap}.nx-dropdown__panel{box-shadow:0 2px 4px rgba(65,65,65,.5);border-radius:4px;min-width:100%}.nx-dropdown__panel ::ng-deep .nx-checkbox__label{font-size:20px;font-size:var(--dropdown-item-font-size,20px);line-height:28px;line-height:var(--dropdown-item-line-height,28px);font-weight:400;font-weight:var(--dropdown-item-font-weight,400);letter-spacing:.2px;letter-spacing:var(--dropdown-item-letter-spacing,.2px);display:flex;align-items:center}.nx-dropdown__panel:focus{outline:0}.nx-dropdown__panel--in-outline-field .nx-dropdown__panel-header{font-size:16px;font-size:var(--formfield-outline-label-font-size,16px);line-height:24px;line-height:var(--formfield-outline-label-line-height,24px);font-weight:600;font-weight:var(--formfield-outline-label-font-weight,600);letter-spacing:0;letter-spacing:var(--formfield-outline-label-letter-spacing,0)}.nx-dropdown__panel--in-outline-field .nx-dropdown__panel-body{max-height:calc(5 * (24px + 16px) + 16px);max-height:calc(5 * (var(--dropdown-item-outline-line-height,24px) + 16px) + 16px)}.nx-dropdown__panel--in-outline-field ::ng-deep .nx-dropdown-results__group-label{font-size:16px;font-size:var(--formfield-outline-label-font-size,16px);line-height:24px;line-height:var(--formfield-outline-label-line-height,24px);font-weight:var(--formfield-outline-label-font-weight,600);letter-spacing:0;letter-spacing:var(--formfield-outline-label-letter-spacing,0);font-style:normal;font-weight:700}.nx-dropdown__panel--in-outline-field ::ng-deep nx-dropdown-item .nx-dropdown-results__option,.nx-dropdown__panel--in-outline-field ::ng-deep nx-dropdown-item .nx-dropdown-results__option-label{font-size:16px;font-size:var(--dropdown-item-outline-font-size,16px);line-height:24px;line-height:var(--dropdown-item-outline-line-height,24px);font-weight:400;font-weight:var(--dropdown-item-outline-font-weight,400);letter-spacing:0;letter-spacing:var(--dropdown-item-outline-letter-spacing,0)}.nx-dropdown__panel--in-outline-field ::ng-deep nx-dropdown-item .nx-dropdown-results__option-checkicon{height:24px;height:var(--dropdown-item-outline-line-height,24px)}.nx-dropdown__panel--in-outline-field ::ng-deep .nx-dropdown__filter-input{font-size:16px;font-size:var(--formfield-outline-control-font-size,16px);line-height:24px;line-height:var(--formfield-outline-control-line-height,24px);font-weight:400;font-weight:var(--formfield-outline-control-font-weight,400);letter-spacing:0;letter-spacing:var(--formfield-outline-control-letter-spacing,0)}.nx-dropdown__panel--in-outline-field ::ng-deep .nx-dropdown__filter-input:empty{font-weight:300}.nx-dropdown__icon{font-size:24px;font-size:var(--dropdown-chevron-size,24px);line-height:0}.nx-dropdown__chevron{vertical-align:middle}.nx-dropdown__panel-header{font-size:12px;font-size:var(--formfield-label-font-size,12px);line-height:16px;line-height:var(--formfield-label-line-height,16px);font-weight:600;font-weight:var(--formfield-label-font-weight,600);letter-spacing:.5px;letter-spacing:var(--formfield-label-letter-spacing,.5px);color:#414141;color:var(--dropdown-panel-header-text-color,#414141);background-color:#ececec;background-color:var(--dropdown-panel-header-background-color,#ececec);padding:8px 32px;border-top-left-radius:4px;border-top-right-radius:4px;z-index:1}.nx-dropdown__panel-body{background-color:#fff;background-color:var(--dropdown-panel-background-color,#fff);max-height:calc(5 * (28px + 16px) + 16px);max-height:calc(5 * (var(--dropdown-item-line-height,28px) + 16px) + 16px);overflow-y:auto;outline:0}.nx-dropdown__filter{position:relative;padding:16px 32px 12px;background-color:#fff;background-color:var(--dropdown-panel-background-color,#fff)}.nx-dropdown__filter-input{font-size:20px;font-size:var(--formfield-control-font-size,20px);line-height:28px;line-height:var(--formfield-control-line-height,28px);font-weight:var(--formfield-control-font-weight,600);letter-spacing:.2px;letter-spacing:var(--formfield-control-letter-spacing,.2px);border:0;border-bottom:1px solid #767676;border-bottom:1px var(--dropdown-filter-input-border-color,#767676) solid;color:#414141;color:var(--dropdown-filter-input-text-color,#414141);width:100%;outline:0;background-color:transparent;padding:0 24px 3px 0;font-weight:300}.nx-dropdown__filter-input::-ms-clear{display:none}.nx-dropdown__panel.has-filter ::ng-deep nx-dropdown-item:first-of-type .nx-dropdown-results__option{padding-top:12px}.nx-dropdown__filter-icon{position:absolute;height:24px;right:32px;top:calc(16px + 1px);cursor:pointer}.nx-dropdown__filter-icon nx-icon{font-size:24px}.nx-dropdown__filter-input:focus{border-color:#007ab3;border-color:var(--dropdown-filter-input-active-border-color,#007ab3)}.nx-dropdown__filter-input.is-filled:focus{font-weight:600;color:#007ab3;color:var(--dropdown-filter-input-active-text-color,#007ab3);border-color:#007ab3;border-color:var(--dropdown-filter-input-active-border-color,#007ab3)}.nx-dropdown__filter-input.is-filled:focus+.nx-dropdown__filter-icon{color:#007ab3;color:var(--dropdown-filter-input-active-text-color,#007ab3)}@media screen and (-ms-high-contrast:active){.nx-dropdown__panel{box-shadow:0 0 0 1px windowText}.nx-dropdown__panel-header{border-bottom:1px solid windowText}.nx-dropdown__filter-input{border-bottom-color:buttonText}}"]
                }] }
    ];
    /** @nocollapse */
    NxDropdownComponent.ctorParameters = function () { return [
        { type: ChangeDetectorRef },
        { type: ElementRef },
        { type: NgZone },
        { type: String, decorators: [{ type: Attribute, args: ['tabindex',] }] },
        { type: NxFormfieldComponent, decorators: [{ type: Optional }] },
        { type: NgControl, decorators: [{ type: Self }, { type: Optional }] },
        { type: NgForm, decorators: [{ type: Optional }] },
        { type: FormGroupDirective, decorators: [{ type: Optional }] }
    ]; };
    NxDropdownComponent.propDecorators = {
        tabIndex: [{ type: Input }],
        _ariaLabel: [{ type: Input, args: ['nxAriaLabel',] }],
        value: [{ type: Input, args: ['nxValue',] }],
        disabled: [{ type: Input, args: ['nxDisabled',] }],
        required: [{ type: Input, args: ['nxRequired',] }],
        styles: [{ type: Input, args: ['nxStyle',] }],
        showFilter: [{ type: Input, args: ['nxShowFilter',] }],
        filterPlaceholder: [{ type: Input, args: ['nxFilterPlaceholder',] }],
        openedChange: [{ type: Output }],
        _openedStream: [{ type: Output, args: ['opened',] }],
        _closedStream: [{ type: Output, args: ['closed',] }],
        filterChanges: [{ type: Output, args: ['filterInput',] }],
        valueChange: [{ type: Output, args: ['nxValueChange',] }],
        selectionChange: [{ type: Output }],
        panel: [{ type: ViewChild, args: ['panel', { static: false },] }],
        panelBody: [{ type: ViewChild, args: ['panelBody', { static: false },] }],
        trigger: [{ type: ViewChild, args: ['trigger', { static: true },] }],
        filterInput: [{ type: ViewChild, args: ['filterInput', { static: false },] }],
        overlayDir: [{ type: ViewChild, args: [CdkConnectedOverlay, { static: true },] }],
        options: [{ type: ContentChildren, args: [NxDropdownItemComponent, { descendants: true },] }],
        groups: [{ type: ContentChildren, args: [NxDropdownGroupComponent,] }],
        _customClosedDropdownLabel: [{ type: ContentChild, args: [NxDropdownClosedLabelDirective, { static: false },] }],
        _defaultClosedDropdownLabel: [{ type: ViewChild, args: ['defaultClosedDropdownLabel', { static: true },] }],
        valueFormatter: [{ type: Input, args: ['nxValueFormatter',] }],
        compareWith: [{ type: Input }],
        filterFn: [{ type: Input }]
    };
    return NxDropdownComponent;
}(NxDropdownControl));
if (false) {
    /** @type {?} */
    NxDropdownComponent.prototype.readonly;
    /**
     * @type {?}
     * @private
     */
    NxDropdownComponent.prototype._selectionModel;
    /**
     * @type {?}
     * @protected
     */
    NxDropdownComponent.prototype._disabled;
    /**
     * @type {?}
     * @private
     */
    NxDropdownComponent.prototype._focused;
    /**
     * Whether or not the overlay panel is open.
     * @type {?}
     * @private
     */
    NxDropdownComponent.prototype._panelOpen;
    /**
     * \@docs-private
     * @type {?}
     */
    NxDropdownComponent.prototype.errorState;
    /**
     * \@docs-private
     * @type {?}
     */
    NxDropdownComponent.prototype.isStable;
    /**
     * Name of this control that is used inside the formfield component
     * \@docs-private
     * @type {?}
     */
    NxDropdownComponent.prototype.controlType;
    /**
     * Holds the value from nxValue.
     * @type {?}
     * @private
     */
    NxDropdownComponent.prototype._value;
    /**
     * The minimal space between the viewport and the overlay
     * @type {?}
     */
    NxDropdownComponent.prototype._overlayViewportMargin;
    /**
     * The last measured value for the trigger's client bounding rect.
     * @type {?}
     */
    NxDropdownComponent.prototype._triggerRect;
    /**
     * Holds the panelWidth after panel was attached.
     * @type {?}
     */
    NxDropdownComponent.prototype._panelWidth;
    /**
     * \@docs-private
     * Emits when internal state changes to inform formfield about it.
     * @type {?}
     */
    NxDropdownComponent.prototype.stateChanges;
    /**
     * The IDs of child options to be passed to the aria-owns attribute.
     * @type {?}
     */
    NxDropdownComponent.prototype._optionIds;
    /**
     * \@docs-private
     * @type {?}
     */
    NxDropdownComponent.prototype.ariaDescribedby;
    /**
     * @type {?}
     * @private
     */
    NxDropdownComponent.prototype._tabIndex;
    /**
     * \@docs-private
     * @type {?}
     */
    NxDropdownComponent.prototype.currentFilter;
    /**
     * Label to describe the component.
     * @type {?}
     */
    NxDropdownComponent.prototype._ariaLabel;
    /**
     * Whether the component is required. This adds an aria-required label to the component.
     * @type {?}
     */
    NxDropdownComponent.prototype.required;
    /**
     * @type {?}
     * @private
     */
    NxDropdownComponent.prototype._style;
    /**
     * Whether the dropdown should render in its negative style or not.
     * @type {?}
     */
    NxDropdownComponent.prototype._negative;
    /**
     * Whether the dropdown should be shown with an additional filter input.
     * @type {?}
     */
    NxDropdownComponent.prototype.showFilter;
    /**
     * Text displayed as placeholder for the filter.
     * @type {?}
     */
    NxDropdownComponent.prototype.filterPlaceholder;
    /**
     * Event emitted when the select panel has been toggled.
     * @type {?}
     */
    NxDropdownComponent.prototype.openedChange;
    /**
     * Event emitted when the select has been opened.
     * @type {?}
     */
    NxDropdownComponent.prototype._openedStream;
    /**
     * Event emitted when the select has been closed.
     * @type {?}
     */
    NxDropdownComponent.prototype._closedStream;
    /**
     * Event emitted when the user types in the filter input.
     * @type {?}
     */
    NxDropdownComponent.prototype.filterChanges;
    /**
     * Event that emits whenever the raw value of the select changes. This is here primarily
     * to facilitate the two-way binding for the `value` input.
     * \@docs-private
     * @type {?}
     */
    NxDropdownComponent.prototype.valueChange;
    /**
     * Event emitted when the selected value has been changed.
     * @type {?}
     */
    NxDropdownComponent.prototype.selectionChange;
    /**
     * \@docs-private
     * @type {?}
     */
    NxDropdownComponent.prototype.optionSelectionChanges;
    /**
     * This position config ensures that the top "start" corner of the overlay
     * is aligned with with the top "start" of the origin by default (overlapping
     * the trigger completely). If the panel cannot fit below the trigger, it
     * will fall back to a position above the trigger.
     * @type {?}
     */
    NxDropdownComponent.prototype._positions;
    /**
     * \@docs-private
     * Panel containing the select options.
     * @type {?}
     */
    NxDropdownComponent.prototype.panel;
    /**
     * \@docs-private
     * @type {?}
     */
    NxDropdownComponent.prototype.panelBody;
    /**
     * \@docs-private
     * @type {?}
     */
    NxDropdownComponent.prototype.trigger;
    /**
     * \@docs-private
     * @type {?}
     */
    NxDropdownComponent.prototype.filterInput;
    /**
     * \@docs-private
     * Overlay pane containing the options.
     * @type {?}
     */
    NxDropdownComponent.prototype.overlayDir;
    /**
     * \@docs-private
     * @type {?}
     */
    NxDropdownComponent.prototype.options;
    /**
     * \@docs-private
     * @type {?}
     */
    NxDropdownComponent.prototype.groups;
    /** @type {?} */
    NxDropdownComponent.prototype._customClosedDropdownLabel;
    /**
     * @type {?}
     * @private
     */
    NxDropdownComponent.prototype._defaultClosedDropdownLabel;
    /**
     * @type {?}
     * @private
     */
    NxDropdownComponent.prototype._closedDropdownLabel;
    /**
     * Emits whenever the component is destroyed.
     * @type {?}
     * @private
     */
    NxDropdownComponent.prototype._destroy;
    /**
     * @type {?}
     * @private
     */
    NxDropdownComponent.prototype._keyManager;
    /**
     * Function that transforms the value into a string.
     * This function is used for displaying and filtering the content
     * ( Default: (value) => value ? value.toString() : null; ).
     * @type {?}
     */
    NxDropdownComponent.prototype.valueFormatter;
    /**
     * Comparison function to specify which option is displayed. Defaults to object equality.
     * @type {?}
     * @private
     */
    NxDropdownComponent.prototype._compareWith;
    /**
     * @type {?}
     * @private
     */
    NxDropdownComponent.prototype._filterFn;
    /**
     * `View -> model callback called when value changes`
     * @type {?}
     */
    NxDropdownComponent.prototype._onChange;
    /**
     * `View -> model callback called when select has been touched`
     * @type {?}
     */
    NxDropdownComponent.prototype._onTouched;
    /**
     * @type {?}
     * @private
     */
    NxDropdownComponent.prototype._changeDetectorRef;
    /**
     * @type {?}
     * @private
     */
    NxDropdownComponent.prototype._elementRef;
    /**
     * @type {?}
     * @private
     */
    NxDropdownComponent.prototype._ngZone;
    /**
     * @type {?}
     * @private
     */
    NxDropdownComponent.prototype.formFieldComponent;
    /**
     * \@docs-private
     * @type {?}
     */
    NxDropdownComponent.prototype.ngControl;
    /**
     * @type {?}
     * @private
     */
    NxDropdownComponent.prototype._parentForm;
    /**
     * @type {?}
     * @private
     */
    NxDropdownComponent.prototype._parentFormGroup;
}

/**
 * @fileoverview added by tsickle
 * Generated from: dropdown.module.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var NxDropdownModule = /** @class */ (function () {
    function NxDropdownModule() {
    }
    NxDropdownModule.decorators = [
        { type: NgModule, args: [{
                    imports: [
                        CommonModule,
                        NxFormfieldModule,
                        NxCheckboxModule,
                        OverlayModule,
                        A11yModule,
                        NxIconModule,
                        ObserversModule
                    ],
                    declarations: [
                        NxDropdownComponent,
                        NxDropdownItemComponent,
                        NxDropdownGroupComponent,
                        NxDropdownClosedLabelDirective
                    ],
                    exports: [
                        NxDropdownComponent,
                        NxDropdownItemComponent,
                        NxDropdownGroupComponent,
                        NxDropdownClosedLabelDirective
                    ]
                },] }
    ];
    return NxDropdownModule;
}());

/**
 * @fileoverview added by tsickle
 * Generated from: public-api.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * Generated from: allianz-ngx-ndbx-dropdown.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

export { NxDropdownComponent, NxDropdownGroupComponent, NxDropdownItemChange, NxDropdownItemComponent, NxDropdownModule, NxDropdownSelectChange, NxDropdownControl as a, NxDropdownClosedLabelDirective as b };
//# sourceMappingURL=allianz-ngx-ndbx-dropdown.js.map
