"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const compiler_1 = require("@angular/compiler");
const parse_traverse_1 = require("./parse-traverse");
const utils_1 = require("./utils");
const element_selectors_1 = require("../data/element-selectors");
/**
 * gets a source file and returns the migrated string
 * @param attributeChange The attributes that should be migrated
 * @param htmlSource
 * @param fileName
 */
function migrateHtml(attributeChange, htmlSource, fileName) {
    const parser = new compiler_1.HtmlParser();
    const ast = parser.parse(htmlSource, '', { tokenizeExpansionForms: false, escapedString: false });
    const traverser = new parse_traverse_1.ParseTraverse();
    let hasChanged = null;
    traverser.traverse(ast, {
        pre(node) {
            const elChange = element_selectors_1.elementSelectorChanges.find((el) => {
                return (el.replace === node.name);
            });
            const inputChange = attributeChange.filter((el) => {
                if (el.whitelist && el.whitelist.elements) {
                    return (el.whitelist.elements.indexOf(node.name) !== -1);
                }
                else {
                    return true; // there is no whitelist we replace it in every tag.
                }
            });
            if (inputChange && node && node.attrs && node.attrs.length) {
                /* tslint:disable */
                let newAttrs = [];
                node.attrs.forEach((attr) => {
                    inputChange.forEach((ic) => {
                        if (attr && attr.name.indexOf(ic.replace) !== -1) { // replace only the attr to cover 'attr, (attr), [(attr)]'
                            if (ic.replaceWith !== '') {
                                attr.name = attr.name.toString().replace(ic.replace, ic.replaceWith);
                                attr.nodeName = attr.name.toString().replace(ic.replace, ic.replaceWith);
                            }
                            else {
                                attr.name = '';
                                attr.nodeName = '';
                            }
                            hasChanged = true;
                        }
                    });
                    if (attr.name !== '') {
                        newAttrs.push(attr);
                    }
                });
                node.attrs = newAttrs;
            }
            if (elChange && node.name === elChange.replace) {
                node.name = elChange.replaceWith;
                hasChanged = true;
            }
        }
    });
    if (hasChanged) {
        return utils_1.serializeNodes(ast.rootNodes).join('');
    }
    return null;
}
exports.migrateHtml = migrateHtml;
//# sourceMappingURL=migrate-html.js.map