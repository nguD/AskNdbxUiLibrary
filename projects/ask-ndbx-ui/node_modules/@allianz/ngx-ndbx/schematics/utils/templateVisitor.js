"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const ts = require("typescript");
const ng_decorators_1 = require("@angular/core/schematics/utils/ng_decorators");
const property_name_1 = require("@angular/core/schematics/utils/typescript/property_name");
const functions_1 = require("@angular/core/schematics/utils/typescript/functions");
const path_1 = require("path");
const fs_1 = require("fs");
const line_mappings_1 = require("@angular/core/schematics/utils/line_mappings");
class TemplateVisitor {
    constructor(typeChecker, logger) {
        this.typeChecker = typeChecker;
        this.logger = logger;
        this.resolvedTemplates = [];
    }
    visitNode(node) {
        if (node.kind === ts.SyntaxKind.ClassDeclaration) {
            this._visitClassDeclaration(node);
        }
        ts.forEachChild(node, n => this.visitNode(n));
    }
    _visitClassDeclaration(node) {
        if (!node.decorators || !node.decorators.length) {
            return;
        }
        const ngDecorators = ng_decorators_1.getAngularDecorators(this.typeChecker, node.decorators);
        const componentDecorator = ngDecorators.find(dec => dec.name === 'Component');
        // In case no "@Component" decorator could be found on the current class, skip.
        if (!componentDecorator) {
            return;
        }
        const decoratorCall = componentDecorator.node.expression;
        // In case the component decorator call is not valid, skip this class declaration.
        if (decoratorCall.arguments.length !== 1) {
            return;
        }
        const componentMetadata = functions_1.unwrapExpression(decoratorCall.arguments[0]);
        // Ensure that the component metadata is an object literal expression.
        if (!ts.isObjectLiteralExpression(componentMetadata)) {
            return;
        }
        const sourceFile = node.getSourceFile();
        const sourceFileName = sourceFile.fileName;
        // Walk through all component metadata properties and determine the referenced
        // HTML templates (either external or inline)
        componentMetadata.properties.forEach(property => {
            if (!ts.isPropertyAssignment(property)) {
                return;
            }
            const propertyName = property_name_1.getPropertyNameText(property.name);
            if (propertyName === 'template' && ts.isBinaryExpression(property.initializer)) {
                /**
                 *  for cases like we just notify that this needs a manual action
                 *   template: '<nx-dynamic-table nxType="">' +
                 '</nx-dynamic-table>' +
                 '<nx-checkbox-circle></nx-checkbox-circle>',
                 */
                this.logger.warn('Manual template migration required in : ' + sourceFileName);
            }
            // In case there is an inline template specified, ensure that the value is statically
            // analyzable by checking if the initializer is a string literal-like node.
            if (propertyName === 'template' && ts.isStringLiteralLike(property.initializer)) {
                // Need to add an offset of one to the start because the template quotes are
                // not part of the template content.
                const templateStartIdx = property.initializer.getStart();
                const filePath = path_1.resolve(sourceFileName);
                this.resolvedTemplates.push({
                    filePath: filePath,
                    container: node,
                    content: property.initializer.text,
                    inline: true,
                    start: templateStartIdx,
                    width: property.initializer.getWidth(),
                    getCharacterAndLineOfPosition: pos => ts.getLineAndCharacterOfPosition(sourceFile, pos + templateStartIdx)
                });
            }
            if (propertyName === 'templateUrl' && ts.isStringLiteralLike(property.initializer)) {
                const templatePath = path_1.resolve(path_1.dirname(sourceFileName), property.initializer.text);
                // In case the template does not exist in the file system, skip this
                // external template.
                if (!fs_1.existsSync(templatePath)) {
                    return;
                }
                const fileContent = fs_1.readFileSync(templatePath, 'utf8');
                const lineStartsMap = line_mappings_1.computeLineStartsMap(fileContent);
                this.resolvedTemplates.push({
                    filePath: templatePath,
                    container: node,
                    content: fileContent,
                    inline: false,
                    start: 0,
                    width: property.initializer.getWidth(),
                    getCharacterAndLineOfPosition: pos => line_mappings_1.getLineAndCharacterFromPosition(lineStartsMap, pos)
                });
            }
        });
    }
}
exports.TemplateVisitor = TemplateVisitor;
//# sourceMappingURL=templateVisitor.js.map