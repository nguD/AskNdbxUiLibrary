"use strict";
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
Object.defineProperty(exports, "__esModule", { value: true });
const ts = require("typescript");
const html_tags_1 = require("@angular/compiler/src/ml_parser/html_tags");
class SerializerVisitor {
    visitElement(element, _context) {
        if (html_tags_1.getHtmlTagDefinition(element.name).isVoid) {
            return `<${element.name}${this._visitAll(element.attrs, ' ')}/>`;
        }
        return `<${element.name}${this._visitAll(element.attrs, ' ')}>${this._visitAll(element.children)}</${element.name}>`;
    }
    visitAttribute(attribute, _context) {
        if (!attribute.value) {
            return `${attribute.name}`;
        }
        return `${attribute.name}="${attribute.value}"`;
    }
    visitText(text, _context) { return text.value; }
    visitComment(comment, _context) { return `<!--${comment.value}-->`; }
    visitExpansion(expansion, _context) {
        return `{${expansion.switchValue}, ${expansion.type},${this._visitAll(expansion.cases)}}`;
    }
    visitExpansionCase(expansionCase, _context) {
        return ` ${expansionCase.value} {${this._visitAll(expansionCase.expression)}}`;
    }
    _visitAll(nodes, join = '') {
        if (nodes.length === 0) {
            return '';
        }
        return join + nodes.map(a => a.visit(this, null)).join(join);
    }
}
const serializerVisitor = new SerializerVisitor();
function serializeNodes(nodes) {
    return nodes.map(node => node.visit(serializerVisitor, null));
}
exports.serializeNodes = serializeNodes;
function createStringLiteral(text, singleQuotes) {
    const literal = ts.createStringLiteral(text);
    // See: https://github.com/microsoft/TypeScript/blob/master/src/compiler/utilities.ts#L584-L590
    literal['singleQuote'] = singleQuotes;
    return literal;
}
exports.createStringLiteral = createStringLiteral;
function report(node, message) {
    const { line, character } = node.getSourceFile().getLineAndCharacterOfPosition(node.getStart());
    console.log(`MODIFYING: ${message} in ${node.getSourceFile().fileName} (${line + 1},${character + 1})`);
}
exports.report = report;
function modifyProperty(node) {
    let modify = false;
    const propertyAssignment = node;
    // check if this is the correct property assignment to modify
    if (propertyAssignment.parent && propertyAssignment.parent.kind === ts.SyntaxKind.ObjectLiteralExpression) {
        const objectLiteralAssignment = propertyAssignment.parent;
        if (objectLiteralAssignment.parent && objectLiteralAssignment.parent.kind === ts.SyntaxKind.CallExpression) {
            const callExpression = objectLiteralAssignment.parent;
            if (callExpression.parent.kind === ts.SyntaxKind.Decorator) {
                modify = true;
            }
        }
    }
    return { modify, propertyAssignment };
}
exports.modifyProperty = modifyProperty;
function isJsonAstObject(node) {
    return !!node && node.kind === 'object';
}
exports.isJsonAstObject = isJsonAstObject;
//# sourceMappingURL=utils.js.map