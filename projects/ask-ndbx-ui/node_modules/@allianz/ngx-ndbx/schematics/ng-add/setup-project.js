"use strict";
/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
Object.defineProperty(exports, "__esModule", { value: true });
const schematics_1 = require("@angular-devkit/schematics");
const schematics_2 = require("@angular/cdk/schematics");
const Chalk = require("chalk");
const config_1 = require("@schematics/angular/utility/config");
const core_1 = require("@angular-devkit/core");
const utils_1 = require("../utils/utils");
function default_1(options) {
    return schematics_1.chain([
        options && options.type && options.type === 'b2b' ? addExpertModule(options) && addExpertAppStyles(options) : schematics_1.noop(),
        addNdbxAppStyles(options),
        addCdkStyles(options),
        addCdkA11yStyles(options),
        addPonyfillToPolyfills(options),
        addNdbxScripts(options)
    ]);
}
exports.default = default_1;
function addExpertModule(options) {
    return (host) => {
        const workspace = config_1.getWorkspace(host);
        const project = schematics_2.getProjectFromWorkspace(workspace, options.project);
        schematics_2.addModuleImportToRootModule(host, 'NxExpertModule', '@allianz/ngx-ndbx/config', project);
        return host;
    };
}
function addNdbxAppStyles(options) {
    return addStyles(options, 'patternlab-minimal.css', '@import "@allianz/ndbx-styles/dist/patternlab-minimal.css";');
}
function addExpertAppStyles(options) {
    return addStyles(options, 'expert.css', '@import "@allianz/ngx-ndbx/themes/expert.css";');
}
function addCdkStyles(options) {
    return addStyles(options, 'overlay-prebuilt.css', '@import "@angular/cdk/overlay-prebuilt.css";');
}
function addCdkA11yStyles(options) {
    return addStyles(options, 'a11y-prebuilt.css', '@import "@angular/cdk/a11y-prebuilt.css";');
}
function addNdbxScripts(options) {
    return addScripts(options, 'what-input', 'node_modules/what-input/dist/what-input.js');
}
function addScripts(options, scriptName, scriptPath) {
    return (host) => {
        try {
            const angularJson = 'angular.json';
            if (!host.exists(angularJson)) {
                throw new Error(`Could not find ${angularJson}`);
            }
            const angularJsonFile = host.read(angularJson);
            if (!angularJsonFile) {
                throw new Error(`Failed to read ${angularJson} content`);
            }
            const jsonAst = core_1.parseJsonAst(angularJsonFile.toString());
            if (!utils_1.isJsonAstObject(jsonAst)) {
                throw new Error(`Failed to parse JSON for ${angularJson}`);
            }
            const workspace = config_1.getWorkspace(host);
            const project = schematics_2.getProjectFromWorkspace(workspace, options.project);
            const buildOptions = schematics_2.getProjectTargetOptions(project, 'build');
            if (!buildOptions.scripts) {
                buildOptions.scripts = [scriptPath];
            }
            else {
                const existingScripts = buildOptions.scripts.map((s) => typeof s === 'string' ? s : s.input);
                for (const path of existingScripts.entries()) {
                    // If the given asset is already specified in the scripts, we don't need to do anything.
                    if (path === scriptPath) {
                        return;
                    }
                }
                buildOptions.scripts.push({
                    input: scriptPath
                });
            }
            host.overwrite('angular.json', JSON.stringify(workspace, null, 2));
        }
        catch (e) {
            console.warn(Chalk.default.red(`Failed to add the script "${scriptName}" to scripts array of "angular.json" file.`));
        }
        return host;
    };
}
function addStyles(options, path, importString) {
    return (host) => {
        const workspace = config_1.getWorkspace(host);
        const project = schematics_2.getProjectFromWorkspace(workspace, options.project);
        const styleFilePath = schematics_2.getProjectStyleFile(project);
        if (!styleFilePath) {
            console.warn(Chalk.default.red(`Could not find the default style file for this project.`));
            console.warn(Chalk.default.red(`Please import '${path}' file in your CSS.`));
            return;
        }
        const buffer = host.read(styleFilePath);
        if (!buffer) {
            console.warn(Chalk.default.red(`Could not read the default style file within the project ` +
                `(${Chalk.default.italic(styleFilePath)})`));
            console.warn(Chalk.default.red(`Please import '${path}' file in your CSS.`));
            return;
        }
        const htmlContent = buffer.toString();
        const insertion = '\n' +
            `${importString}`;
        if (htmlContent.includes(insertion)) {
            return;
        }
        const recorder = host.beginUpdate(styleFilePath);
        recorder.insertLeft(htmlContent.length, insertion);
        host.commitUpdate(recorder);
    };
}
function addPonyfillToPolyfills(options) {
    return (host) => {
        const workspace = config_1.getWorkspace(host);
        const project = schematics_2.getProjectFromWorkspace(workspace, options.project);
        const buildOptions = schematics_2.getProjectTargetOptions(project, 'build');
        if (!buildOptions.polyfills) {
            throw new Error(`Could not find polyfills.ts in ${project.sourceRoot}`);
        }
        const polyfillsTs = buildOptions.polyfills;
        const polyfillsFile = host.read(polyfillsTs);
        if (!polyfillsFile) {
            throw new Error(`Failed to read ${polyfillsTs} content`);
        }
        const tsContent = polyfillsFile.toString();
        const insertion = '\n' + `import cssVars from 'css-vars-ponyfill';` + '\n' + 'cssVars({ watch: true, onlyLegacy: true, shadowDOM: true});' + '\n';
        if (tsContent.includes(insertion)) {
            return;
        }
        const recorder = host.beginUpdate(polyfillsTs);
        recorder.insertRight(tsContent.length, insertion);
        host.commitUpdate(recorder);
    };
}
//# sourceMappingURL=setup-project.js.map