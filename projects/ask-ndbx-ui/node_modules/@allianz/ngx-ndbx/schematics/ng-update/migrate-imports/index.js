"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const documentImportVisitor_1 = require("./documentImportVisitor");
const path_1 = require("path");
const schematics_1 = require("@angular-devkit/schematics");
const parse_tsconfig_1 = require("@angular/core/schematics/utils/typescript/parse_tsconfig");
const project_tsconfig_paths_1 = require("@angular/core/schematics/utils/project_tsconfig_paths");
const ts = require("typescript");
function default_1() {
    return (tree, context) => {
        const { buildPaths, testPaths } = project_tsconfig_paths_1.getProjectTsConfigPaths(tree);
        if (!buildPaths.length && !testPaths.length) {
            throw new schematics_1.SchematicsException(`Could not find any tsconfig file. Cannot run migrations.`);
        }
        const logger = context.logger;
        logger.info('-------- ngx-ndbx secondary entry point migration --------');
        logger.info('With version 8 we deprecated the main entry point @allianz/ngx-ndbx.');
        logger.info('All component imports will be done from secondary entry points now');
        logger.info('example import { NxButtonModule } from "@allianz/ngx-ndbx/button"');
        logger.info('The migration changes all imports for you.');
        logger.info('\n');
        [...buildPaths, ...testPaths].forEach(tsConfig => {
            runImportMigrations(tree, tsConfig);
        });
    };
}
exports.default = default_1;
const runImportMigrations = (tree, tsConfigPath) => {
    const parsed = parse_tsconfig_1.parseTsconfigFile(tsConfigPath, path_1.dirname(tsConfigPath));
    const host = ts.createCompilerHost(parsed.options, true);
    const printer = ts.createPrinter({
        newLine: ts.NewLineKind.LineFeed
    });
    const basePath = process.cwd();
    // We need to overwrite the host "readFile" method, as we want the TypeScript
    // program to be based on the file contents in the virtual file tree. Otherwise
    // if we run the migration for multiple tsconfig files which have intersecting
    // source files, it can end up updating query definitions multiple times.
    host.readFile = fileName => {
        const buffer = tree.read(path_1.relative(basePath, fileName));
        // Strip BOM as otherwise TSC methods (Ex: getWidth) will return an offset which
        // which breaks the CLI UpdateRecorder.
        // See: https://github.com/angular/angular/pull/30719
        return buffer ? buffer.toString().replace(/^\uFEFF/, '') : undefined;
    };
    const program = ts.createProgram(parsed.fileNames, parsed.options, host);
    const typeChecker = program.getTypeChecker();
    const visitor = new documentImportVisitor_1.DocumentImportVisitor(typeChecker);
    const sourceFiles = program.getSourceFiles().filter(f => !f.isDeclarationFile && !program.isSourceFileFromExternalLibrary(f));
    sourceFiles.forEach(sourceFile => {
        visitor.visitNode(sourceFile);
    });
    const { importsMap } = visitor;
    // go through each source file and update it according to the found metadata
    importsMap.forEach((resolvedImports, sourceFile) => {
        const mainEntryPoints = resolvedImports.mainEntryPointImports;
        const resolvedModules = resolvedImports.resolvedModules;
        const update = tree.beginUpdate(path_1.relative(basePath, sourceFile.fileName));
        const firstOldImport = mainEntryPoints[0];
        // remove all old import declarations
        mainEntryPoints.forEach(importNode => {
            update.remove(importNode.getStart(), importNode.getWidth());
        });
        // create new imports for each resolved module name like dropdown, card
        resolvedModules.forEach((elements, group) => {
            // create new import
            const newImportNode = createNewImport(elements, group);
            const newImport = printer.printNode(ts.EmitHint.Unspecified, newImportNode, sourceFile);
            update.insertRight(firstOldImport.getStart(), newImport + '\n');
        });
        tree.commitUpdate(update);
    });
};
const createNewImport = (elements, group) => {
    // we just assume if the old import was single quoted we also use single quotes
    const isSingleQuoteImport = elements[0].parent.parent.parent.moduleSpecifier.getText()[0] === `'`;
    const newImport = ts.createImportDeclaration(undefined, undefined, ts.createImportClause(undefined, ts.createNamedImports(elements)), createStringLiteral(`${documentImportVisitor_1.NDBX_IMPORT}/${group}`, isSingleQuoteImport));
    return newImport;
};
function createStringLiteral(text, singleQuotes) {
    const literal = ts.createStringLiteral(text);
    // See: https://github.com/microsoft/TypeScript/blob/master/src/compiler/utilities.ts#L584-L590
    literal['singleQuote'] = singleQuotes;
    return literal;
}
exports.createStringLiteral = createStringLiteral;
//# sourceMappingURL=index.js.map