"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const project_tsconfig_paths_1 = require("@angular/core/schematics/utils/project_tsconfig_paths");
const schematics_1 = require("@angular-devkit/schematics");
const ts = require("typescript");
const path_1 = require("path");
const parse_tsconfig_1 = require("@angular/core/schematics/utils/typescript/parse_tsconfig");
const documentVisitor_1 = require("./documentVisitor");
function default_1() {
    return (tree, context) => {
        const { buildPaths, testPaths } = project_tsconfig_paths_1.getProjectTsConfigPaths(tree);
        if (!buildPaths.length && !testPaths.length) {
            throw new schematics_1.SchematicsException(`Could not find any tsconfig file. Cannot run migrations.`);
        }
        const logger = context.logger;
        logger.info('-------- ngx-ndbx circle-toggle migration --------');
        logger.info('We try to migrate the project from checkbox circle and radio-circle');
        logger.info('to the circle toggle component as good as possible.');
        logger.info('This and the following migrations will change ');
        logger.info('imports and also updates your templates.');
        logger.info('Please check all custom css you used on the old components.');
        logger.info('\n');
        [...buildPaths, ...testPaths].forEach(tsConfig => {
            runCircleToggleMigration(tree, tsConfig);
        });
        return tree;
    };
}
exports.default = default_1;
const runCircleToggleMigration = (tree, tsConfigPath) => {
    const parsed = parse_tsconfig_1.parseTsconfigFile(tsConfigPath, path_1.dirname(tsConfigPath));
    const host = ts.createCompilerHost(parsed.options, true);
    const printer = ts.createPrinter({
        newLine: ts.NewLineKind.LineFeed
    });
    const basePath = process.cwd();
    // We need to overwrite the host "readFile" method, as we want the TypeScript
    // program to be based on the file contents in the virtual file tree. Otherwise
    // if we run the migration for multiple tsconfig files which have intersecting
    // source files, it can end up updating query definitions multiple times.
    host.readFile = fileName => {
        const buffer = tree.read(path_1.relative(basePath, fileName));
        // Strip BOM as otherwise TSC methods (Ex: getWidth) will return an offset which
        // which breaks the CLI UpdateRecorder.
        // See: https://github.com/angular/angular/pull/30719
        return buffer ? buffer.toString().replace(/^\uFEFF/, '') : undefined;
    };
    const program = ts.createProgram(parsed.fileNames, parsed.options, host);
    const typeChecker = program.getTypeChecker();
    // do the visiting stuff here
    // check imports
    const importVisitor = new documentVisitor_1.DocumentVisitor(typeChecker);
    // check for components and check templates (+ maybe css)
    // const templateVisitor = new NgComponentTemplateVisitor(typeChecker);
    const sourceFiles = program.getSourceFiles().filter(f => !f.isDeclarationFile && !program.isSourceFileFromExternalLibrary(f));
    sourceFiles.forEach(sourceFile => importVisitor.visitNode(sourceFile));
    const { importsMap, propertyMap } = importVisitor;
    importsMap.forEach((metadata, sourceFile) => {
        // if we didn't find any imports we can stop here
        if (metadata.namedImportsWithOldModule.length === 0) {
            return;
        }
        const update = tree.beginUpdate(path_1.relative(basePath, sourceFile.fileName));
        // we found a NamedImport with at least one occurence of NxCheckboxCircleModule or
        // NxRadioCircleModule. We filter both of them out and create a new updated import declaration
        // as replacement. Note: Replacing just namedImports or even only the importSpecifier doesn't
        // work unfortunately as comma separators would be left behind.
        metadata.namedImportsWithOldModule.forEach(namedImports => {
            let elements = [...namedImports.elements];
            elements = elements.filter(el => {
                const name = (el.propertyName || el.name).escapedText;
                return (name !== 'NxCheckboxCircleModule' || name !== 'NxRadioCircleModule');
            });
            const importDeclaration = namedImports.parent.parent;
            let newImportText = '';
            if (elements.length > 0) {
                const importClause = ts.createImportClause(undefined, ts.createNamedImports(elements));
                const newImport = ts.createImportDeclaration(undefined, undefined, importClause, importDeclaration.moduleSpecifier);
                newImportText = printer.printNode(ts.EmitHint.Unspecified, newImport, sourceFile);
            }
            update.remove(importDeclaration.getStart(), importDeclaration.getWidth());
            update.insertRight(importDeclaration.getStart(), newImportText);
        });
        // if there are any objects with a property assignment we assume we need to update as well
        // the main target are ngModule decorators and the configureTestingModule function in specs
        const propertyAssignments = propertyMap.get(sourceFile);
        if (propertyAssignments) {
            propertyAssignments.forEach(property => {
                const propertyElements = [...property.initializer.elements];
                const filteredElements = filterDepecratedModules(propertyElements);
                if (!metadata.hasCircleToggleImport) {
                    filteredElements.push(ts.createIdentifier('NxCircleToggleModule'));
                }
                let newPropertyText = '';
                if (filteredElements.length > 0) {
                    const newPropertyAssignment = ts.createPropertyAssignment(property.name, ts.createArrayLiteral(filteredElements, true));
                    newPropertyText = printer.printNode(ts.EmitHint.Unspecified, newPropertyAssignment, sourceFile);
                }
                update.remove(property.getStart(), property.getWidth());
                update.insertRight(property.getStart(), newPropertyText);
            });
        }
        // if we found any checkbox circle or radio circle imports and
        // circle toggle is not yet imported we add it to the document
        if (!metadata.hasCircleToggleImport) {
            const element = ts.createImportSpecifier(undefined, ts.createIdentifier('NxCircleToggleModule'));
            const namedBindings = ts.createNamedImports([element]);
            const importClause = ts.createImportClause(undefined, namedBindings);
            const circleToggleImport = ts.createImportDeclaration(undefined, undefined, importClause, ts.createStringLiteral('@allianz/ngx-ndbx/circle-toggle'));
            const newImport = printer.printNode(ts.EmitHint.Unspecified, circleToggleImport, sourceFile);
            update.insertLeft(sourceFile.getStart(), newImport + '\n');
        }
        tree.commitUpdate(update);
    });
};
// Filter the obsolete modules from the object
const filterDepecratedModules = (elements) => {
    return elements.filter((el) => (el.escapedText !== 'NxCheckboxCircleModule' && el.escapedText !== 'NxRadioCircleModule'));
};
//# sourceMappingURL=index.js.map