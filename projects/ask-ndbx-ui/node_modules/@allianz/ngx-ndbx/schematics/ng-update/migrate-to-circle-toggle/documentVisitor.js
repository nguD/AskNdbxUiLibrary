"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const ts = require("typescript");
const CIRCLE_TOGGLE_IDENTIFIER = 'NxCircleToggleModule';
const NDBX_IMPORT = '@allianz/ngx-ndbx';
class ModuleMetadata extends Map {
}
exports.ModuleMetadata = ModuleMetadata;
/**
 * Visitor which scans the source file for imports from NxCheckboxCircleModule, NxRadioCircleModule
 * and NxCircleModule as well as for any property assignments in objects which fit the ngModule and
 * configureTestingModule structure.
 */
class DocumentVisitor {
    constructor(typeChecker) {
        this.typeChecker = typeChecker;
        this.importsMap = new Map();
        this.propertyMap = new Map();
    }
    visitNode(node) {
        if (ts.isNamedImports(node)) {
            this.visitNamedImport(node);
        }
        if (ts.isPropertyAssignment(node)) {
            this.visitPropertyAssignment(node);
        }
        ts.forEachChild(node, n => this.visitNode(n));
    }
    visitNamedImport(node) {
        const importDeclaration = node.parent.parent;
        if (!importDeclaration.moduleSpecifier.text.includes(NDBX_IMPORT)) {
            return;
        }
        if (!node.elements || !node.elements.length) {
            return;
        }
        let importMetadata = this.importsMap.get(node.getSourceFile());
        if (!importMetadata) {
            importMetadata = {
                hasCircleToggleImport: false,
                namedImportsWithOldModule: []
            };
        }
        // check if we find CheckboxCircleModule or RadioCircleModule
        const oldImports = node.elements.filter(el => {
            const name = (el.propertyName || el.name).escapedText;
            return (name === 'NxCheckboxCircleModule' || name === 'NxRadioCircleModule');
        });
        const circleToggleImport = node.elements.filter(el => {
            const name = (el.propertyName || el.name).escapedText;
            return name === CIRCLE_TOGGLE_IDENTIFIER;
        });
        if (circleToggleImport.length > 0) {
            importMetadata.hasCircleToggleImport = true;
        }
        if (oldImports.length > 0) {
            importMetadata.namedImportsWithOldModule.push(node);
        }
        this.importsMap.set(node.getSourceFile(), importMetadata);
    }
    visitPropertyAssignment(node) {
        if (!ts.isIdentifier(node.name)) {
            return;
        }
        if (node.name.escapedText !== 'imports' && node.name.escapedText !== 'exports') {
            return;
        }
        if (!ts.isArrayLiteralExpression(node.initializer)) {
            return;
        }
        const nodesOfInterest = node.initializer.elements.filter((el) => (el.escapedText === 'NxCheckboxCircleModule' || el.escapedText === 'NxRadioCircleModule'));
        if (nodesOfInterest.length === 0) {
            return;
        }
        let metadata = this.propertyMap.get(node.getSourceFile());
        if (!metadata) {
            metadata = [];
        }
        metadata.push(node);
        this.propertyMap.set(node.getSourceFile(), metadata);
    }
}
exports.DocumentVisitor = DocumentVisitor;
//# sourceMappingURL=documentVisitor.js.map