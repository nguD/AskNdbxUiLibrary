"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const schematics_1 = require("@angular-devkit/schematics");
const project_tsconfig_paths_1 = require("@angular/core/schematics/utils/project_tsconfig_paths");
const parse_tsconfig_1 = require("@angular/core/schematics/utils/typescript/parse_tsconfig");
const path_1 = require("path");
const ts = require("typescript");
const templateVisitor_1 = require("../../utils/templateVisitor");
const analyze_template_1 = require("@angular/core/schematics/migrations/template-var-assignment/analyze_template");
const schematics_2 = require("@angular/cdk/schematics");
const core_1 = require("@angular-devkit/core");
const migrate_html_1 = require("../../utils/migrate-html");
const utils_1 = require("../../utils/utils");
const attribute_upgrade_data_1 = require("./data/attribute-upgrade-data");
function default_1() {
    return (tree, context) => {
        const { buildPaths, testPaths } = project_tsconfig_paths_1.getProjectTsConfigPaths(tree);
        if (!buildPaths.length && !testPaths.length) {
            throw new schematics_1.SchematicsException(`Could not find any tsconfig file. Cannot run migrations.`);
        }
        const logger = context.logger;
        logger.info('-------- ngx-ndbx deprecated property migration --------');
        logger.info('With version 9 we removed deprecations from version 8.');
        logger.info('Please refer to the changelog which properties are affected.');
        logger.info('\n');
        [...buildPaths, ...testPaths].forEach(tsConfig => {
            runAttributeMigrations(tree, tsConfig, context);
        });
    };
}
exports.default = default_1;
const runAttributeMigrations = (tree, tsConfigPath, context) => {
    const parsed = parse_tsconfig_1.parseTsconfigFile(tsConfigPath, path_1.dirname(tsConfigPath));
    const host = ts.createCompilerHost(parsed.options, true);
    const printer = ts.createPrinter({
        newLine: ts.NewLineKind.LineFeed
    });
    const basePath = process.cwd();
    // We need to overwrite the host "readFile" method, as we want the TypeScript
    // program to be based on the file contents in the virtual file tree. Otherwise
    // if we run the migration for multiple tsconfig files which have intersecting
    // source files, it can end up updating query definitions multiple times.
    host.readFile = fileName => {
        const buffer = tree.read(path_1.relative(basePath, fileName));
        // Strip BOM as otherwise TSC methods (Ex: getWidth) will return an offset which
        // which breaks the CLI UpdateRecorder.
        // See: https://github.com/angular/angular/pull/30719
        return buffer ? buffer.toString().replace(/^\uFEFF/, '') : undefined;
    };
    const program = ts.createProgram(parsed.fileNames, parsed.options, host);
    const sourceFiles = program.getSourceFiles().filter(f => !f.isDeclarationFile && !program.isSourceFileFromExternalLibrary(f));
    const typeChecker = program.getTypeChecker();
    const logger = context.logger;
    const templateVisitor = new templateVisitor_1.TemplateVisitor(typeChecker, logger);
    sourceFiles.forEach(sourceFile => templateVisitor.visitNode(sourceFile));
    const { resolvedTemplates } = templateVisitor;
    // go through each source file and update it according to the found metadata
    resolvedTemplates.forEach((template) => {
        const filePath = template.filePath;
        const nodes = analyze_template_1.analyzeResolvedTemplate(template);
        if (!nodes) {
            return;
        }
        const newHtmlContent = migrate_html_1.migrateHtml(attribute_upgrade_data_1.attributeChangeV9, template.content, template.container.getSourceFile().fileName);
        if (newHtmlContent) {
            if (template.inline) {
                const update = tree.beginUpdate(path_1.relative(basePath, template.container.getSourceFile().fileName));
                update.remove(template.start, template.width);
                const newHtmlContentSingleQuoted = printer.printNode(ts.EmitHint.Unspecified, utils_1.createStringLiteral(newHtmlContent, true), template.container.getSourceFile());
                update.insertRight(template.start, newHtmlContentSingleQuoted);
                tree.commitUpdate(update);
            }
            else {
                const displayFilePath = core_1.normalize(path_1.relative(basePath, filePath));
                tree.overwrite(path_1.relative(basePath, displayFilePath), newHtmlContent);
            }
        }
        // warning message for things that are changed in v10
        schematics_2.findInputsOnElementWithTag(template.content, 'title', ['nx-single-stepper', 'nx-multi-stepper', 'nx-progress-stepper'])
            .forEach(offset => {
            logger.warn('Found deprecated "title" input binding. Use "nx-label" component instead. '
                + template.container.getSourceFile().fileName
                + ':' + template.getCharacterAndLineOfPosition(template.start + offset).line);
        });
    });
};
//# sourceMappingURL=index.js.map