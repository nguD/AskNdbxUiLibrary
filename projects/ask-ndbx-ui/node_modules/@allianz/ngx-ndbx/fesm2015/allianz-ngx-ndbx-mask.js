import { CommonModule } from '@angular/common';
import { forwardRef, Directive, ElementRef, Input, Inject, NgModule } from '@angular/core';
import { NxFormfieldModule } from '@allianz/ngx-ndbx/formfield';
import { NG_VALUE_ACCESSOR, NG_VALIDATORS } from '@angular/forms';
import { coerceBooleanProperty } from '@angular/cdk/coercion';
import { NX_INPUT_VALUE_ACCESSOR } from '@allianz/ngx-ndbx/input';
import { BACKSPACE, DELETE } from '@angular/cdk/keycodes';
import { Subject } from 'rxjs';
import { countries, isValid } from 'iban';

/**
 * @fileoverview added by tsickle
 * Generated from: mask.directive.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const NX_MASK_VALUE_ACCESSOR = {
    provide: NG_VALUE_ACCESSOR,
    useExisting: forwardRef((/**
     * @return {?}
     */
    () => NxMaskDirective)),
    multi: true
};
/** @type {?} */
const NX_MASK_VALIDATORS = {
    provide: NG_VALIDATORS,
    useExisting: forwardRef((/**
     * @return {?}
     */
    () => NxMaskDirective)),
    multi: true
};
/**
 * Interface for saving the cursor information.
 * @record
 */
function CursorInfo() { }
if (false) {
    /** @type {?|undefined} */
    CursorInfo.prototype.selectionStart;
    /** @type {?|undefined} */
    CursorInfo.prototype.selectionEnd;
    /** @type {?|undefined} */
    CursorInfo.prototype.position;
}
class NxMaskDirective {
    /**
     * @param {?} _elementRef
     */
    constructor(_elementRef) {
        this._elementRef = _elementRef;
        this._separators = ['/', '(', ')', '.', ':', '-', ' ', '+', ','];
        this._dropSpecialCharacters = false;
        this._validateMask = true;
        /**
         * Emits the unmasked value before the value changes.
         */
        this.cvaModelChange = new Subject();
        this._onChangeCallback = (/**
         * @param {?} _
         * @return {?}
         */
        (_) => { });
        this._onTouchedCallback = (/**
         * @return {?}
         */
        () => { });
        this._validatorOnChange = (/**
         * @return {?}
         */
        () => { });
        this._afterInputHook = (/**
         * @param {?} event
         * @return {?}
         */
        (event) => { });
        this._beforePasteHook = (/**
         * @param {?} event
         * @return {?}
         */
        (event) => { });
    }
    /**
     * @private
     * @return {?}
     */
    _callOnChangeCallback() {
        if (!this.dropSpecialCharacters) {
            this._onChangeCallback(this._elementRef.nativeElement.value);
        }
        else {
            this._onChangeCallback(this.getUnmaskedValue());
        }
    }
    /**
     * Registers a function to be executed after the onInput handler.
     * The registered hook receives a `KeyboardEvent` from the onInput event handler as a parameter.
     *
     * **Note:** If you register a `afterInputHook`, you may also register a `beforePasteHook`
     * to perform similar changes for pasting.
     * @param {?} afterInput
     * @return {?}
     */
    registerAfterInputHook(afterInput) {
        this._afterInputHook = afterInput;
    }
    /**
     * Registers a function to be executed before the onPaste handler.
     * The registered hook receives a `ClipboardEvent` from the onPaste event handler as a parameter.
     * @param {?} beforePaste
     * @return {?}
     */
    registerBeforePasteHook(beforePaste) {
        this._beforePasteHook = beforePaste;
    }
    /**
     * Sets the mask.
     * @param {?} value
     * @return {?}
     */
    set mask(value) {
        if (!value) {
            value = '';
        }
        if (value !== this._mask) {
            this._mask = value;
            this.updateValue(this.getMaskedString(this._elementRef.nativeElement.value));
            this._callOnChangeCallback();
            this._validatorOnChange();
        }
    }
    /**
     * @return {?}
     */
    get mask() {
        return this._mask;
    }
    /**
     * Sets the mask (for programmatical use).
     *
     * No `_onChangeCallback()` will be called!
     * @param {?} value
     * @return {?}
     */
    setMask(value) {
        if (!value) {
            value = '';
        }
        if (value !== this._mask) {
            this._mask = value;
            this.updateValue(this.getMaskedString(this._elementRef.nativeElement.value));
            this._validatorOnChange();
        }
    }
    /**
     * Sets the case sensitivity of the mask.
     * @param {?} value
     * @return {?}
     */
    set convertTo(value) {
        this._convertTo = value;
        this.updateValue(this.getMaskedString(this._elementRef.nativeElement.value));
        this._callOnChangeCallback();
    }
    /**
     * @return {?}
     */
    get convertTo() {
        return this._convertTo;
    }
    /**
     * Sets the keys that are recognized as separators.
     * Default separators: / ( ) . : - + , and space.
     * @param {?} values
     * @return {?}
     */
    set separators(values) {
        this._separators = values;
        this.updateValue(this.getMaskedString(this._elementRef.nativeElement.value));
        this._validatorOnChange();
        this._callOnChangeCallback();
    }
    /**
     * @return {?}
     */
    get separators() {
        return this._separators;
    }
    /**
     * Whether the separators should be dropped in the control value accessor.
     * @param {?} value
     * @return {?}
     */
    set dropSpecialCharacters(value) {
        /** @type {?} */
        const newValue = coerceBooleanProperty(value);
        if (newValue !== this._dropSpecialCharacters) {
            this._dropSpecialCharacters = newValue;
            this.updateValue(this.getMaskedString(this._elementRef.nativeElement.value));
            this._callOnChangeCallback();
        }
    }
    /**
     * @return {?}
     */
    get dropSpecialCharacters() {
        return this._dropSpecialCharacters;
    }
    /**
     * Whether the mask validation should be applied on the input. Default: true.
     * @param {?} value
     * @return {?}
     */
    set validateMask(value) {
        /** @type {?} */
        const newValue = coerceBooleanProperty(value);
        if (newValue !== this._validateMask) {
            this._validateMask = newValue;
            this._validatorOnChange();
        }
    }
    /**
     * @return {?}
     */
    get validateMask() {
        return this._validateMask;
    }
    /**
     * \@docs-private
     * @return {?}
     */
    get elementRefValue() {
        return this._elementRef.nativeElement.value;
    }
    /**
     * Returns the unmasked value.
     * @return {?}
     */
    getUnmaskedValue() {
        /** @type {?} */
        const unmaskedValue = this.separators.reduce((/**
         * @param {?} unmasked
         * @param {?} separator
         * @return {?}
         */
        function (unmasked, separator) {
            return unmasked.split(separator).join('');
        }), this._elementRef.nativeElement.value);
        return unmaskedValue;
    }
    /**
     * this._cursor can be set to a new value in this function;
     * in _onInputChange() it is then used to set the cursor position.
     * @param {?} event
     * @return {?}
     */
    _onKeydown(event) {
        /** @type {?} */
        const keyCode = event.keyCode;
        /** @type {?} */
        const input = (/** @type {?} */ (event.target));
        /** @type {?} */
        const currentValue = this._elementRef.nativeElement.value;
        if (keyCode === BACKSPACE || keyCode === DELETE) {
            // if backspace pressed, cursor has to move one character to start
            /** @type {?} */
            const backspaceShift = keyCode === BACKSPACE ? 1 : 0;
            /** @type {?} */
            const lastCharacter = currentValue.substring(input.selectionStart - backspaceShift, input.selectionEnd - backspaceShift + 1);
            /** @type {?} */
            const selectionAtLastCharacter = (input.selectionStart === currentValue.length - 1 + backspaceShift);
            if (input.selectionStart !== input.selectionEnd) {
                /** @type {?} */
                let newPosition = input.selectionStart;
                // jump behind separators, but do not shift after the next character (=> don't use _calculateCursorShift())
                while (this.isSeparator(this.mask[newPosition])) {
                    newPosition++;
                }
                this._cursor = { position: newPosition };
            }
            else if (selectionAtLastCharacter) {
                // if last character is deleted: only delete last character, do not trigger input event again
                // (here the separator would be added again)
                this.updateValue(currentValue.substring(0, currentValue.length - 1));
                this._callOnChangeCallback();
                event.preventDefault();
            }
            else if (this.isSeparator(lastCharacter)) {
                // do not delete a separator, only set cursor position
                input.setSelectionRange(input.selectionStart - backspaceShift, input.selectionEnd - backspaceShift);
                event.preventDefault();
            }
            else {
                // for any other character: decrease cursor position by one (backspaceShift).
                // the input is modified and will be validated in _onInputChange().
                this._cursor = { position: input.selectionStart - backspaceShift };
            }
        }
        else {
            this._cursor = { selectionStart: input.selectionStart, selectionEnd: input.selectionEnd };
        }
    }
    /**
     * Returns the cursor position after a letter is entered at `selectionStart` position in the mask.
     * There are two cases to consider ('|' => cursor position where the character is entered, mask: 00:00:00):
     * - before the separators there is space for entering the letter: '12:3|4:5' => '12:30:|45'
     * - the letter has to be shifted and is entered after the separators: '12:34|:5' => '12:34:0|5'
     * @private
     * @param {?} position
     * @return {?}
     */
    _calculateCursorShift(position) {
        /** @type {?} */
        let shift = 0;
        // tracks if the entered letter was already placed in the current mask
        // and therefor was considered in the cursor calculation.
        /** @type {?} */
        let characterWasEntered = false;
        if (!this.isSeparator(this.mask[position + shift])) {
            shift++;
            characterWasEntered = true;
        }
        while (this.isSeparator(this.mask[position + shift])) {
            shift++;
        }
        if (!characterWasEntered) {
            shift++;
        }
        return shift;
    }
    /**
     * @private
     * @param {?} value
     * @param {?} maskedValue
     * @return {?}
     */
    _isStringAllowed(value, maskedValue) {
        if ((maskedValue === '0' && /^[0-9]{1}$/.test(value))
            || (maskedValue === 'A' && /^[a-zA-Z0-9]{1}$/.test(value))
            || (maskedValue === 'S' && /^[a-zA-Z]{1}$/.test(value))) {
            return true;
        }
        return false;
    }
    /**
     * Handles the onInput event.
     * `_beforeInputHook()` is called before the actual execution.
     *
     * @param {?} event
     * @return {?}
     */
    _onInputChange(event) {
        // _inputValue is updated in updateValue(), so I need to pick it up here to compare it to a new value
        /** @type {?} */
        const oldVal = this._inputValue;
        /** @type {?} */
        const input = (/** @type {?} */ (event.target));
        /** @type {?} */
        const newVal = this.getMaskedString(input.value);
        // if _pastedData was set in _onPaste(), use this value
        if (this._pastedData) {
            this.updateValue(this._pastedData);
            input.setSelectionRange(this._cursor.position, this._cursor.position);
            this._pastedData = null;
            this._cursor = null;
            this._callOnChangeCallback();
            return;
        }
        // do nothing if mask is already filled up
        if (oldVal.length === this._mask.length
            && newVal.length === this._mask.length
            && oldVal !== newVal
            && (this._cursor
                && this._cursor.selectionStart !== undefined
                && this._cursor.selectionStart === this._cursor.selectionEnd)) {
            this._elementRef.nativeElement.value = this.getMaskedString(oldVal);
            input.setSelectionRange(this._cursor.selectionStart, this._cursor.selectionEnd);
            this._cursor = null;
            return;
        }
        this.updateValue(newVal);
        // set new cursor position
        if (this._cursor && this._cursor.position !== undefined) {
            input.setSelectionRange(this._cursor.position, this._cursor.position);
            this._cursor = null;
        }
        else if (this._cursor && this._cursor.selectionStart !== undefined) {
            // only one character can be entered (except pasting, this is calculated in _onPaste())
            if (oldVal !== input.value) {
                /** @type {?} */
                const newPosition = this._cursor.selectionStart + this._calculateCursorShift(this._cursor.selectionStart);
                input.setSelectionRange(newPosition, newPosition);
                this._cursor = null;
            }
            else {
                // we always have to set the cursor position here even if nothing changed
                // because otherwise the cursor would jump to the end of the input.
                // if the cursor is placed in front of a separator and the user types a non-allowed character,
                // the cursor is supposed to jump over the separator.
                /** @type {?} */
                let currentPosition = this._cursor.selectionStart;
                while (this.isSeparator(this.mask[currentPosition])) {
                    currentPosition++;
                }
                input.setSelectionRange(currentPosition, currentPosition);
                this._cursor = null;
            }
        }
        this._afterInputHook(event);
        this._callOnChangeCallback();
    }
    /**
     * this._cursor and this._pastedData can be set to a new value in this function;
     * _cursor is used to set the cursor position after checking the masked input in _onInputChange().
     * _pastedData carries the valid part of the pasted value to _inInputChange();
     *
     * `_beforePasteHook()` is called before the actual execution.
     * @param {?} event
     * @return {?}
     */
    _onPaste(event) {
        /** @type {?} */
        const input = (/** @type {?} */ (event.target));
        /** @type {?} */
        const pastedData = (event.clipboardData || ((/** @type {?} */ (window))).clipboardData).getData('text');
        // saving these three values as if something is changed in the _beforePasteHook()
        // which causes the input value to be updated, this values will get lost.
        /** @type {?} */
        const selectionStart = input.selectionStart;
        /** @type {?} */
        const selectionEnd = input.selectionEnd;
        /** @type {?} */
        const oldValue = input.value;
        this._beforePasteHook(event);
        /** @type {?} */
        const maskedString = this.getMaskedString(pastedData, selectionStart);
        // if mask is already filled up (and no characters are selected with the cursor), do nothing
        if (input.value.length === this._mask.length
            && maskedString.length > 0
            && selectionStart === selectionEnd) {
            input.setSelectionRange(selectionStart, selectionEnd);
            this._cursor = null; // was set in _onKeydown(), but will not be used in this case; so reset it
            event.preventDefault();
            return;
        }
        // if length of newValue is >= mask: allow only to enter characters from a pasted value until mask is filled up
        // example: 12:|34: ("|" cursor position, mask: 00:00:00) => when pasting '567', only '56' fits in until input is filled up => 12:56:|34
        // get the pasted unmasked value from the pasted string (to cut all the invalid characters and separators)
        /** @type {?} */
        const pastedUnmaskedValue = this.separators.reduce((/**
         * @param {?} unmasked
         * @param {?} separator
         * @return {?}
         */
        (unmasked, separator) => unmasked.split(separator).join('')), maskedString);
        /** @type {?} */
        let newValue = this.getMaskedString(oldValue.substring(0, selectionStart)
            + pastedUnmaskedValue
            + oldValue.substring(selectionEnd, oldValue.length));
        if (newValue.length >= this._mask.length) {
            /** @type {?} */
            let newPosition = selectionStart;
            /** @type {?} */
            let i = 1;
            do {
                newValue = this.getMaskedString(oldValue.substring(0, selectionStart)
                    + pastedUnmaskedValue.substring(0, i)
                    + oldValue.substring(selectionEnd, oldValue.length));
                newPosition += this._calculateCursorShift(newPosition);
                i++;
            } while (newValue.length < this._mask.length);
            // save value for using it in _onInputChange()
            this._pastedData = newValue;
            this._cursor = {
                position: newPosition
            };
            return;
        }
        // if pasting is fine: save the cursor position for using them in _onInputChange()
        this._cursor = {
            position: selectionStart + maskedString.length
        };
    }
    /**
     * @private
     * @param {?} value
     * @return {?}
     */
    updateValue(value) {
        // Write UpperCase
        if (this._convertTo === 'upper') {
            value = value.toUpperCase();
        }
        else if (this._convertTo === 'lower') {
            value = value.toLowerCase();
        }
        this._elementRef.nativeElement.value = value;
        // _inputValue is needed for calculating the cursor shift in onInput()
        this._inputValue = value;
    }
    /**
     * \@docs-private
     * @param {?} inputValue
     * @param {?=} maskStartIndex
     * @return {?}
     */
    getMaskedString(inputValue, maskStartIndex = 0) {
        /** @type {?} */
        let formattedValue = '';
        /** @type {?} */
        let maskIndex = maskStartIndex;
        /** @type {?} */
        let inputIndex = 0;
        // insert if next in mask is separator
        while (this.isSeparator(this.mask[maskIndex])) {
            formattedValue += this.mask[maskIndex];
            maskIndex++;
        }
        while (inputIndex < inputValue.length) {
            // test if letters are valid
            if (this._isStringAllowed(inputValue[inputIndex], (/** @type {?} */ (this.mask[maskIndex])))) {
                formattedValue += inputValue[inputIndex];
                inputIndex++;
                maskIndex++;
            }
            else {
                inputIndex++;
            }
            // insert if next in mask is separator
            while (this.isSeparator(this.mask[maskIndex])) {
                formattedValue += this.mask[maskIndex];
                maskIndex++;
            }
        }
        return formattedValue;
    }
    /**
     * @private
     * @param {?} value
     * @return {?}
     */
    isSeparator(value) {
        return (this._separators.indexOf(value) !== -1);
    }
    // control value accessor
    /**
     * @param {?} value
     * @return {?}
     */
    writeValue(value) {
        if (!value) {
            value = '';
        }
        this.cvaModelChange.next(value);
        this.updateValue(this.getMaskedString(value));
    }
    /**
     * @param {?} onChange
     * @return {?}
     */
    registerOnChange(onChange) {
        this._onChangeCallback = onChange;
    }
    /**
     * @param {?} onTouched
     * @return {?}
     */
    registerOnTouched(onTouched) {
        this._onTouchedCallback = onTouched;
    }
    /**
     * \@docs-private
     * @param {?} fn
     * @return {?}
     */
    registerOnValidatorChange(fn) {
        this._validatorOnChange = fn;
    }
    /**
     * @return {?}
     */
    _validateFn() {
        /** @type {?} */
        const inputLength = this._elementRef.nativeElement.value.length;
        /** @type {?} */
        const maskLength = this._mask.length;
        if (inputLength !== maskLength) {
            return { nxMaskLengthError: { 'length': maskLength, 'actual': inputLength } };
        }
        return null;
    }
    /**
     * \@docs-private
     * @return {?}
     */
    validate() {
        return this.validateMask ? this._validateFn() : null;
    }
    /**
     * @return {?}
     */
    _touch() {
        this._onTouchedCallback();
    }
}
NxMaskDirective.decorators = [
    { type: Directive, args: [{
                selector: 'input[nxMask]',
                host: {
                    '(input)': '_onInputChange($event)',
                    '(keydown)': '_onKeydown($event)',
                    '(paste)': '_onPaste($event)',
                    '(blur)': '_touch()'
                },
                exportAs: 'nxMaskDirective',
                providers: [
                    NX_MASK_VALUE_ACCESSOR,
                    { provide: NX_INPUT_VALUE_ACCESSOR, useExisting: NxMaskDirective },
                    NX_MASK_VALIDATORS
                ]
            },] }
];
/** @nocollapse */
NxMaskDirective.ctorParameters = () => [
    { type: ElementRef }
];
NxMaskDirective.propDecorators = {
    mask: [{ type: Input, args: ['nxMask',] }],
    convertTo: [{ type: Input, args: ['nxConvertTo',] }],
    separators: [{ type: Input }],
    dropSpecialCharacters: [{ type: Input }],
    validateMask: [{ type: Input }]
};
if (false) {
    /**
     * @type {?}
     * @private
     */
    NxMaskDirective.prototype._mask;
    /**
     * @type {?}
     * @private
     */
    NxMaskDirective.prototype._separators;
    /**
     * @type {?}
     * @private
     */
    NxMaskDirective.prototype._dropSpecialCharacters;
    /**
     * @type {?}
     * @private
     */
    NxMaskDirective.prototype._validateMask;
    /**
     * @type {?}
     * @private
     */
    NxMaskDirective.prototype._convertTo;
    /**
     * _cursor is a helper for saving a position or a selectionRange (selectionStart + selectionEnd)
     * and then apply it later on (in _onInputChange()).
     *
     * _cursor.position is used for saving a position that is then applied without any changes.
     * if the position is saved, selectionStart and selectionEnd will be ignored in _onInputChange().
     * _cursor.selectionStart and selectionEnd is used for saving the current cursor position,
     * and a new cursor position is then calculated with this data.
     * @type {?}
     * @private
     */
    NxMaskDirective.prototype._cursor;
    /**
     * helper variable for saving the current value of the input element to compare it then with a new value.
     * @type {?}
     * @private
     */
    NxMaskDirective.prototype._inputValue;
    /**
     * helper variable for saving the masked string of a pasted value and then applying it in _onInputChange().
     * @type {?}
     * @private
     */
    NxMaskDirective.prototype._pastedData;
    /**
     * Emits the unmasked value before the value changes.
     * @type {?}
     */
    NxMaskDirective.prototype.cvaModelChange;
    /**
     * @type {?}
     * @private
     */
    NxMaskDirective.prototype._onChangeCallback;
    /**
     * @type {?}
     * @private
     */
    NxMaskDirective.prototype._onTouchedCallback;
    /**
     * @type {?}
     * @private
     */
    NxMaskDirective.prototype._validatorOnChange;
    /**
     * @type {?}
     * @private
     */
    NxMaskDirective.prototype._afterInputHook;
    /**
     * @type {?}
     * @private
     */
    NxMaskDirective.prototype._beforePasteHook;
    /**
     * @type {?}
     * @private
     */
    NxMaskDirective.prototype._elementRef;
}

/**
 * @fileoverview added by tsickle
 * Generated from: iban-mask.directive.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const NX_IBAN_MASK_VALIDATORS = {
    provide: NG_VALIDATORS,
    useExisting: forwardRef((/**
     * @return {?}
     */
    () => NxIbanMaskDirective)),
    multi: true
};
/**
 * To use the `NxIbanMaskDirective`, you have to install the **peer dependency** `iban.js`.
 */
class NxIbanMaskDirective {
    /**
     * @param {?} _elementRef
     * @param {?} maskDirective
     */
    constructor(_elementRef, maskDirective) {
        this._elementRef = _elementRef;
        this.maskDirective = maskDirective;
        this._afterInputHook = (/**
         * @param {?} event
         * @return {?}
         */
        (event) => {
            /** @type {?} */
            const input = (/** @type {?} */ (event.target));
            this._setCountryCode(input.value.substr(0, 2));
        });
        this._beforePasteHook = (/**
         * @param {?} event
         * @return {?}
         */
        (event) => {
            // change the country code here if necessary
            /** @type {?} */
            const input = (/** @type {?} */ (event.target));
            /** @type {?} */
            const pastedData = (event.clipboardData || ((/** @type {?} */ (window))).clipboardData).getData('text');
            /** @type {?} */
            const enteredCountryCode = (this.maskDirective.elementRefValue.substr(0, input.selectionStart)
                + this.maskDirective.getMaskedString(pastedData, input.selectionStart)).substr(0, 2);
            this._setCountryCode(enteredCountryCode);
        });
        this.maskDirective.registerAfterInputHook(this._afterInputHook);
        this.maskDirective.registerBeforePasteHook(this._beforePasteHook);
        this.maskDirective.cvaModelChange.subscribe((/**
         * @param {?} value
         * @return {?}
         */
        (value) => {
            /** @type {?} */
            const enteredCountryCode = this.maskDirective.getMaskedString(value).substr(0, 2);
            this._setCountryCode(enteredCountryCode);
        }));
    }
    /**
     * @private
     * @param {?} code
     * @return {?}
     */
    _setCountryCode(code) {
        code = code.toUpperCase();
        if (code.length === 2 && this._countryCode !== code) {
            if (this._countryCodeExists(code)) {
                this._countryCode = code;
                this.maskDirective.setMask(this._getMask(this._countryCode));
            }
            else {
                this._countryCode = null;
                this.maskDirective.setMask('SS');
            }
        }
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        // set only first two letters as I don't know a country yet
        this.maskDirective.mask = 'SS';
        this.maskDirective.convertTo = 'upper';
    }
    /**
     * @private
     * @param {?} countryCode
     * @return {?}
     */
    _getMask(countryCode) {
        // the countrySpecs of a country contain: countryCode ("DE"), length (22), structure ("F08F10")
        // and an example belonging to each country
        /** @type {?} */
        const countrySpecs = countries[countryCode];
        // 'SS' for country code + '00' for IBAN checksum
        /** @type {?} */
        let mask = 'SS00';
        // split up after every third character
        /** @type {?} */
        const characterDefs = countrySpecs['structure'].match(/.{1,3}/g);
        characterDefs.forEach((/**
         * @param {?} charDef
         * @return {?}
         */
        charDef => {
            /** @type {?} */
            const character = charDef[0];
            /** @type {?} */
            const count = Number(charDef.substring(1, 3));
            switch (character) {
                // [0-9]
                case 'F':
                    mask = mask + '0'.repeat(count);
                    break;
                // [0-9A-Za-z]
                case 'A':
                    mask = mask + 'A'.repeat(count);
                    break;
                // [A-Z]
                // 'S' in nxMask does accept also [a-z].
                // There is no option for only accepting capital letters at the moment.
                case 'U':
                    mask = mask + 'S'.repeat(count);
                    break;
            }
        }));
        // insert whitespaces after every 4 characters
        mask = mask.match(/.{1,4}/g).join(' ');
        return mask;
    }
    /**
     * @private
     * @param {?} countryCode
     * @return {?}
     */
    _countryCodeExists(countryCode) {
        return (!!countries[countryCode]);
    }
    /**
     * @private
     * @return {?}
     */
    _validateFn() {
        /** @type {?} */
        const enteredCountryCode = this._elementRef.nativeElement.value.substr(0, 2);
        if (enteredCountryCode.length === 2 && !this._countryCodeExists(enteredCountryCode)) {
            // immediately show error to user
            this.maskDirective._touch();
            return { nxIbanInvalidCountryError: 'no valid country code' };
        }
        if (!isValid(this.maskDirective.getUnmaskedValue())) {
            return { nxIbanParseError: 'no valid iban' };
        }
        return null;
    }
    /**
     * \@docs-private
     * @return {?}
     */
    validate() {
        return this.maskDirective.validateMask ? this._validateFn() : null;
    }
}
NxIbanMaskDirective.decorators = [
    { type: Directive, args: [{
                selector: 'input[nxIbanMask]',
                exportAs: 'nxIbanMaskDirective',
                providers: [
                    NX_IBAN_MASK_VALIDATORS
                ]
            },] }
];
/** @nocollapse */
NxIbanMaskDirective.ctorParameters = () => [
    { type: ElementRef },
    { type: NxMaskDirective, decorators: [{ type: Inject, args: [forwardRef((/**
                     * @return {?}
                     */
                    () => NxMaskDirective)),] }] }
];
if (false) {
    /**
     * @type {?}
     * @private
     */
    NxIbanMaskDirective.prototype._countryCode;
    /**
     * @type {?}
     * @private
     */
    NxIbanMaskDirective.prototype._afterInputHook;
    /**
     * @type {?}
     * @private
     */
    NxIbanMaskDirective.prototype._beforePasteHook;
    /**
     * @type {?}
     * @private
     */
    NxIbanMaskDirective.prototype._elementRef;
    /**
     * @type {?}
     * @private
     */
    NxIbanMaskDirective.prototype.maskDirective;
}

/**
 * @fileoverview added by tsickle
 * Generated from: mask.module.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class NxMaskModule {
}
NxMaskModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    CommonModule,
                    NxFormfieldModule
                ],
                declarations: [
                    NxMaskDirective,
                    NxIbanMaskDirective
                ],
                exports: [
                    NxFormfieldModule,
                    NxMaskDirective,
                    NxIbanMaskDirective
                ]
            },] }
];

/**
 * @fileoverview added by tsickle
 * Generated from: public-api.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * Generated from: allianz-ngx-ndbx-mask.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

export { NX_IBAN_MASK_VALIDATORS, NX_MASK_VALIDATORS, NX_MASK_VALUE_ACCESSOR, NxIbanMaskDirective, NxMaskDirective, NxMaskModule };
//# sourceMappingURL=allianz-ngx-ndbx-mask.js.map
