import { Injectable, ɵɵdefineInjectable } from '@angular/core';

/**
 * @fileoverview added by tsickle
 * Generated from: utils.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @param {?} value
 * @return {?}
 */
function isString(value) {
    return typeof value === 'string';
}
/**
 * @param {?} str
 * @param {?=} length
 * @param {?=} padCharacter
 * @return {?}
 */
function pad(str, length = 2, padCharacter = '0') {
    if (!isString(str) || str.length >= length) {
        return str;
    }
    while (str.length < length) {
        str = padCharacter + str;
    }
    return str;
}
// DATE -> YYYY-MM-DD
/**
 * @param {?} date
 * @return {?}
 */
function formatDate(date) {
    /** @type {?} */
    const dateOfBirth = [
        String(date.getFullYear()),
        pad(String(date.getMonth() + 1)),
        pad(String(date.getDate()))
    ].join('-');
    return dateOfBirth;
}
/**
 * @param {?} date
 * @return {?}
 */
function formatDateHuman(date) {
    /** @type {?} */
    const dateOfBirth = [
        pad(String(date.getDate())),
        pad(String(date.getMonth() + 1)),
        String(date.getFullYear())
    ].join('-');
    return dateOfBirth;
}
/*
  Purpose of this function is to allow a list of short keywords
  expand to longer bem class names with will then be applied to the classname value.

  This function will map a list of keys to values in a MAPPING list.
  Whatever value is found will replace the keyword.
  Every keyword not found will just transfered wiithmout modifying.
*/
/**
 * @param {?} value
 * @param {?=} DEFAULTS
 * @param {?=} MAPPING
 * @return {?}
 */
function mapClassNames(value, DEFAULTS = [], MAPPING = {}) {
    /** @type {?} */
    let sanitizedList = [...DEFAULTS];
    if (typeof value === 'string') {
        /** @type {?} */
        const mappedClasses = getClassNameList(value, MAPPING);
        sanitizedList = [...sanitizedList, ...mappedClasses];
    }
    return sanitizedList.join(' ').trim();
}
/**
 * @param {?} value
 * @param {?=} MAPPING
 * @return {?}
 */
function getClassNameList(value, MAPPING = {}) {
    /** @type {?} */
    let mappedClasses = [];
    if (typeof value === 'string') {
        /** @type {?} */
        const classNames = value.split(' ');
        /** @type {?} */
        const keys = Object.keys(MAPPING);
        mappedClasses = classNames.map((/**
         * @param {?} className
         * @return {?}
         */
        className => {
            if (keys.indexOf(className) > -1) {
                return MAPPING[className];
            }
            else {
                return className;
            }
        }));
    }
    return mappedClasses;
}
/**
 * @param {?} renderer
 * @param {?} element
 * @param {?} classes
 * @return {?}
 */
function appendClasses(renderer, element, classes) {
    if (renderer && element && classes) {
        classes.split(' ').forEach((/**
         * @param {?} item
         * @return {?}
         */
        item => {
            renderer.addClass(element.nativeElement, item);
        }));
    }
}
/**
 * @param {?} renderer
 * @param {?} element
 * @param {?} classes
 * @return {?}
 */
function removeClasses(renderer, element, classes) {
    if (renderer && element && classes) {
        classes.split(' ').forEach((/**
         * @param {?} item
         * @return {?}
         */
        item => {
            renderer.removeClass(element.nativeElement, item);
        }));
    }
}
// YYYY-MM-DD -> DATE
/**
 * @param {?} dateString
 * @return {?}
 */
function parseDate(dateString) {
    return new Date(dateString);
}
// Manually compose a font shorthand defintion as it's not
// guaranteed to be given by the computed style object.
/**
 * @param {?} style
 * @return {?}
 */
function getFontShorthand(style) {
    const { font, fontStyle, fontVariant, fontWeight, fontSize, lineHeight, fontFamily } = style;
    if (font.length > 0) {
        return font;
    }
    return `${fontStyle} ${fontVariant} ${fontWeight} ${fontSize}/${lineHeight} ${fontFamily}`;
}
/**
 * @param {?} number
 * @return {?}
 */
function numberOfDecimals(number) {
    /** @type {?} */
    const parsed = Number(number);
    if (Number.isNaN(parsed) || Number.isInteger(parsed)) {
        return 0;
    }
    /** @type {?} */
    const match = (parsed.toString()).match(/(?:\.(\d+))?(?:[eE]([+-]?\d+))?$/);
    if (!match[1]) {
        return 0;
    }
    return match[1].length;
}
/**
 * @param {?} value
 * @param {?=} min
 * @param {?=} max
 * @return {?}
 */
function clamp(value, min = 0, max = 1) {
    return Math.max(min, Math.min(max, value));
}
/**
 * Provider that defines when form controls have an error.
 */
class ErrorStateMatcher {
    /**
     * @param {?} control
     * @param {?} form
     * @return {?}
     */
    isErrorState(control, form) {
        return !!(control && control.invalid && (control.touched || (form && form.submitted)));
    }
}
ErrorStateMatcher.decorators = [
    { type: Injectable, args: [{ providedIn: 'root' },] }
];
/** @nocollapse */ ErrorStateMatcher.ngInjectableDef = ɵɵdefineInjectable({ factory: function ErrorStateMatcher_Factory() { return new ErrorStateMatcher(); }, token: ErrorStateMatcher, providedIn: "root" });

/**
 * @fileoverview added by tsickle
 * Generated from: public-api.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * Generated from: allianz-ngx-ndbx-utils.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

export { ErrorStateMatcher, appendClasses, clamp, formatDate, formatDateHuman, getClassNameList, getFontShorthand, isString, mapClassNames, numberOfDecimals, pad, parseDate, removeClasses };
//# sourceMappingURL=allianz-ngx-ndbx-utils.js.map
