import { __rest } from 'tslib';
import { DataSource } from '@angular/cdk/collections';
import { BehaviorSubject, merge, Subject } from 'rxjs';
import { take, map, takeUntil } from 'rxjs/operators';
import { FlatTreeControl, CdkTreeNode, CdkTreeNodeDef, CdkTree, CdkTreeNodeToggle, CdkTreeModule } from '@angular/cdk/tree';
import { Component, Directive, Input, ViewContainerRef, Renderer2, ElementRef, Optional, ViewEncapsulation, ChangeDetectionStrategy, ViewChild, NgModule } from '@angular/core';
import { Directionality } from '@angular/cdk/bidi';
import { coerceNumberProperty } from '@angular/cdk/coercion';
import { CommonModule } from '@angular/common';

/**
 * @fileoverview added by tsickle
 * Generated from: data-source/flat-data-source.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Tree flattener to convert a normal type of node to node with children & level information.
 * Transform nested nodes of type `T extends NxTreeNode` to flattened nodes of type `F extends NxFlatTreeNode`.
 *
 * For example, the input data of type `T` is nested, and contains its children data:
 *   SomeNode: {
 *     key: 'Fruits',
 *     children: [
 *       NodeOne: {
 *         key: 'Apple',
 *       },
 *       NodeTwo: {
 *        key: 'Pear',
 *      }
 *    ]
 *  }
 *  After flattener flatten the tree, the structure will become
 *  SomeNode: {
 *    key: 'Fruits',
 *    expandable: true,
 *    level: 1
 *  },
 *  NodeOne: {
 *    key: 'Apple',
 *    expandable: false,
 *    level: 2
 *  },
 *  NodeTwo: {
 *   key: 'Pear',
 *   expandable: false,
 *   level: 2
 * }
 * and the output flattened type is `F extends NxFlatTreeNode` with additional information.
 * @template T, F
 */
class NxTreeFlattener {
    /**
     * @param {?} node
     * @param {?} level
     * @return {?}
     */
    transformFunction(node, level) {
        const { children } = node, rest = __rest(node, ["children"]);
        return (/** @type {?} */ (Object.assign({}, rest, { level, expandable: Array.isArray(children) && children.length > 0 })));
    }
    /**
     * @param {?} node
     * @return {?}
     */
    getLevel(node) {
        return node.level;
    }
    /**
     * @param {?} node
     * @return {?}
     */
    isExpandable(node) {
        return node.expandable;
    }
    /**
     * @param {?} node
     * @return {?}
     */
    getChildren(node) {
        return (/** @type {?} */ (node.children));
    }
    /**
     * @param {?} node
     * @param {?} level
     * @param {?} resultNodes
     * @param {?} parentMap
     * @return {?}
     */
    _flattenNode(node, level, resultNodes, parentMap) {
        /** @type {?} */
        const flatNode = this.transformFunction(node, level);
        resultNodes.push(flatNode);
        if (this.isExpandable(flatNode)) {
            /** @type {?} */
            const childrenNodes = this.getChildren(node);
            if (Array.isArray(childrenNodes)) {
                this._flattenChildren(childrenNodes, level, resultNodes, parentMap);
            }
            else {
                childrenNodes.pipe(take(1)).subscribe((/**
                 * @param {?} children
                 * @return {?}
                 */
                children => {
                    this._flattenChildren(children, level, resultNodes, parentMap);
                }));
            }
        }
        return resultNodes;
    }
    /**
     * @param {?} children
     * @param {?} level
     * @param {?} resultNodes
     * @param {?} parentMap
     * @return {?}
     */
    _flattenChildren(children, level, resultNodes, parentMap) {
        children.forEach((/**
         * @param {?} child
         * @param {?} index
         * @return {?}
         */
        (child, index) => {
            /** @type {?} */
            const childParentMap = parentMap.slice();
            childParentMap.push(index != children.length - 1); // tslint:disable-line
            this._flattenNode(child, level + 1, resultNodes, childParentMap);
        }));
    }
    /**
     * Flatten a list of node type T to flattened version of node F.
     * Please note that type T may be nested, and the length of `structuredData` may be different
     * from that of returned list `F[]`.
     * @param {?} structuredData
     * @return {?}
     */
    flattenNodes(structuredData) {
        /** @type {?} */
        const resultNodes = [];
        structuredData.forEach((/**
         * @param {?} node
         * @return {?}
         */
        node => this._flattenNode(node, 0, resultNodes, [])));
        return resultNodes;
    }
    /**
     * Expand flattened node with current expansion status.
     * The returned list may have different length.
     * @param {?} nodes
     * @param {?} treeControl
     * @return {?}
     */
    expandFlattenedNodes(nodes, treeControl) {
        /** @type {?} */
        const results = [];
        /** @type {?} */
        const currentExpand = [];
        currentExpand[0] = true;
        nodes.forEach((/**
         * @param {?} node
         * @return {?}
         */
        node => {
            /** @type {?} */
            let expand = true;
            for (let i = 0; i <= this.getLevel(node); i++) {
                expand = expand && currentExpand[i];
            }
            if (expand) {
                results.push(node);
            }
            if (this.isExpandable(node)) {
                currentExpand[this.getLevel(node) + 1] = treeControl.isExpanded(node);
            }
        }));
        return results;
    }
}
/**
 * Data source for flat tree.
 * The data source need to handle expansion/collapsion of the tree node and change the data feed
 * to `NxTree`.
 * The nested tree nodes of type `T extends NxTreeNode` are flattened through `NxTreeFlattener`, and converted
 * to type `F extends NxFlatTreeNode` for `NxTree` to consume.
 * @template T, F
 */
class NxTreeFlatDataSource extends DataSource {
    /**
     * @param {?} treeControl
     * @param {?=} initialData
     */
    constructor(treeControl, initialData = []) {
        super();
        this.treeControl = treeControl;
        this._flattenedData = new BehaviorSubject([]);
        this._expandedData = new BehaviorSubject([]);
        this._data = new BehaviorSubject([]);
        this._treeFlattener = new NxTreeFlattener();
        this.data = initialData;
    }
    /**
     * @return {?}
     */
    get data() { return this._data.value; }
    /**
     * @param {?} value
     * @return {?}
     */
    set data(value) {
        this._data.next(value);
        this._flattenedData.next(this._treeFlattener.flattenNodes(this.data));
        this.treeControl.dataNodes = this._flattenedData.value;
    }
    /**
     * @param {?} collectionViewer
     * @return {?}
     */
    connect(collectionViewer) {
        /** @type {?} */
        const changes = [
            collectionViewer.viewChange,
            this.treeControl.expansionModel.changed,
            this._flattenedData
        ];
        return merge(...changes).pipe(map((/**
         * @return {?}
         */
        () => {
            this._expandedData.next(this._treeFlattener.expandFlattenedNodes(this._flattenedData.value, this.treeControl));
            return this._expandedData.value;
        })));
    }
    /**
     * @return {?}
     */
    disconnect() {
        // no op
    }
}
if (false) {
    /** @type {?} */
    NxTreeFlatDataSource.prototype._treeFlattener;
    /** @type {?} */
    NxTreeFlatDataSource.prototype._flattenedData;
    /** @type {?} */
    NxTreeFlatDataSource.prototype._expandedData;
    /** @type {?} */
    NxTreeFlatDataSource.prototype._data;
    /**
     * @type {?}
     * @private
     */
    NxTreeFlatDataSource.prototype.treeControl;
}

/**
 * @fileoverview added by tsickle
 * Generated from: data-source/flat-tree-control.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Flat tree control.
 * Able to expand/collapse a subtree recursively for flattened tree.
 * @template F
 */
class NxFlatTreeControl extends FlatTreeControl {
    constructor() {
        super((/**
         * @param {?} node
         * @return {?}
         */
        node => node.level), (/**
         * @param {?} node
         * @return {?}
         */
        node => node.expandable));
    }
}

/**
 * @fileoverview added by tsickle
 * Generated from: data-source/tree-node.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * This interface defines a single node of the trees data structure.
 * @record
 */
function NxTreeNode() { }
if (false) {
    /** @type {?|undefined} */
    NxTreeNode.prototype.children;
}
/**
 * Flat node with level information.
 * @record
 */
function NxFlatTreeNode() { }
if (false) {
    /** @type {?} */
    NxFlatTreeNode.prototype.expandable;
    /** @type {?} */
    NxFlatTreeNode.prototype.level;
}

/**
 * @fileoverview added by tsickle
 * Generated from: node.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Wrapper for the CdkTree node with NDBX design styles.
 * @template T
 */
class NxTreeNodeComponent extends CdkTreeNode {
}
NxTreeNodeComponent.decorators = [
    { type: Component, args: [{
                selector: 'nx-tree-node',
                exportAs: 'nxTreeNode',
                inputs: ['disabled', 'tabIndex'],
                host: {
                    '[attr.aria-expanded]': 'isExpanded',
                    '[attr.aria-level]': 'role === "treeitem" ? level : null',
                    '[attr.role]': 'role',
                    'class': 'nx-tree__node',
                    '[class.is-expanded]': 'isExpanded'
                },
                providers: [{ provide: CdkTreeNode, useExisting: NxTreeNodeComponent }],
                template: "<div class=\"nx-tree__node-box\">\n  <ng-content></ng-content>\n</div>\n"
            }] }
];
/**
 * Wrapper for the CdkTree node definition with NDBX design styles.
 * @template T
 */
class NxTreeNodeDefDirective extends CdkTreeNodeDef {
}
NxTreeNodeDefDirective.decorators = [
    { type: Directive, args: [{
                selector: '[nxTreeNodeDef]',
                inputs: [
                    'when: nxTreeNodeDefWhen'
                ],
                providers: [{ provide: CdkTreeNodeDef, useExisting: NxTreeNodeDefDirective }]
            },] }
];
NxTreeNodeDefDirective.propDecorators = {
    data: [{ type: Input, args: ['nxTreeNode',] }]
};
if (false) {
    /** @type {?} */
    NxTreeNodeDefDirective.prototype.data;
}

/**
 * @fileoverview added by tsickle
 * Generated from: outlet.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Outlet for nested CdkNode. Put `[nxTreeNodeOutlet]` on a tag to place children dataNodes
 * inside the outlet.
 */
class NxTreeNodeOutletDirective {
    /**
     * @param {?} viewContainer
     */
    constructor(viewContainer) {
        this.viewContainer = viewContainer;
    }
}
NxTreeNodeOutletDirective.decorators = [
    { type: Directive, args: [{
                selector: '[nxTreeNodeOutlet]'
            },] }
];
/** @nocollapse */
NxTreeNodeOutletDirective.ctorParameters = () => [
    { type: ViewContainerRef }
];
if (false) {
    /** @type {?} */
    NxTreeNodeOutletDirective.prototype.viewContainer;
}

/**
 * @fileoverview added by tsickle
 * Generated from: padding.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Regex used to split a string on its CSS units.
 * @type {?}
 */
const cssUnitPattern = /([A-Za-z%]+)$/;
/**
 * Indent for the children tree dataNodes.
 * This directive will add left-padding to the node to show hierarchy.
 * @template T
 */
class NxTreeNodePaddingDirective {
    /**
     * @param {?} _treeNode
     * @param {?} _tree
     * @param {?} _renderer
     * @param {?} _element
     * @param {?} _dir
     */
    constructor(_treeNode, _tree, _renderer, _element, _dir) {
        this._treeNode = _treeNode;
        this._tree = _tree;
        this._renderer = _renderer;
        this._element = _element;
        this._dir = _dir;
        /**
         * Subject that emits when the component has been destroyed.
         */
        this._destroyed = new Subject();
        /**
         * CSS units used for the indentation value.
         */
        this.indentUnits = 'px';
        this._offset = 0;
        this._indent = 24;
        this._setPadding();
        if (this._dir) {
            this._dir.change.pipe(takeUntil(this._destroyed)).subscribe((/**
             * @return {?}
             */
            () => this._setPadding()));
        }
    }
    /**
     * The level of depth of the tree node. The padding will be `level * indent` pixels.
     * @return {?}
     */
    get level() { return this._level; }
    /**
     * @param {?} value
     * @return {?}
     */
    set level(value) {
        this._level = coerceNumberProperty(value);
        this._setPadding();
    }
    /**
     * The offset is added once on top of each indent. Default number is 0.
     * @return {?}
     */
    get offset() { return this._offset; }
    /**
     * @param {?} value
     * @return {?}
     */
    set offset(value) {
        this._offset = coerceNumberProperty(value);
        this._setPadding();
    }
    /**
     * The indent for each level. Can be a number or a CSS string.
     * Default number 24px from material design menu sub-menu spec.
     * @return {?}
     */
    get indent() { return this._indent; }
    /**
     * @param {?} indent
     * @return {?}
     */
    set indent(indent) {
        /** @type {?} */
        let value = indent;
        /** @type {?} */
        let units = 'px';
        if (typeof indent === 'string') {
            /** @type {?} */
            const parts = indent.split(cssUnitPattern);
            value = parts[0];
            units = parts[1] || units;
        }
        this.indentUnits = units;
        this._indent = coerceNumberProperty(value);
        this._setPadding();
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this._destroyed.next();
        this._destroyed.complete();
    }
    /**
     * The padding indent value for the tree node. Returns a string with px numbers if not null.
     * @return {?}
     */
    _paddingIndent() {
        /** @type {?} */
        const nodeLevel = (this._treeNode.data && this._tree.treeControl.getLevel)
            ? this._tree.treeControl.getLevel(this._treeNode.data)
            : null;
        /** @type {?} */
        const level = this._level || nodeLevel;
        return level ? `${level * this._indent + this._offset}${this.indentUnits}` : null;
    }
    /**
     * @return {?}
     */
    _setPadding() {
        /** @type {?} */
        const padding = this._paddingIndent();
        /** @type {?} */
        const paddingProp = this._dir && this._dir.value === 'rtl' ? 'paddingRight' : 'paddingLeft';
        this._renderer.setStyle(this._element.nativeElement, paddingProp, padding);
    }
}
NxTreeNodePaddingDirective.decorators = [
    { type: Directive, args: [{
                selector: '[nxTreeNodePadding]',
            },] }
];
/** @nocollapse */
NxTreeNodePaddingDirective.ctorParameters = () => [
    { type: CdkTreeNode },
    { type: CdkTree },
    { type: Renderer2 },
    { type: ElementRef },
    { type: Directionality, decorators: [{ type: Optional }] }
];
NxTreeNodePaddingDirective.propDecorators = {
    level: [{ type: Input, args: ['nxTreeNodePadding',] }],
    offset: [{ type: Input, args: ['nxTreeNodePaddingOffset',] }],
    indent: [{ type: Input, args: ['nxTreeNodePaddingIndent',] }]
};
if (false) {
    /**
     * Subject that emits when the component has been destroyed.
     * @type {?}
     * @private
     */
    NxTreeNodePaddingDirective.prototype._destroyed;
    /**
     * CSS units used for the indentation value.
     * @type {?}
     */
    NxTreeNodePaddingDirective.prototype.indentUnits;
    /** @type {?} */
    NxTreeNodePaddingDirective.prototype._level;
    /** @type {?} */
    NxTreeNodePaddingDirective.prototype._offset;
    /** @type {?} */
    NxTreeNodePaddingDirective.prototype._indent;
    /**
     * @type {?}
     * @private
     */
    NxTreeNodePaddingDirective.prototype._treeNode;
    /**
     * @type {?}
     * @private
     */
    NxTreeNodePaddingDirective.prototype._tree;
    /**
     * @type {?}
     * @private
     */
    NxTreeNodePaddingDirective.prototype._renderer;
    /**
     * @type {?}
     * @private
     */
    NxTreeNodePaddingDirective.prototype._element;
    /**
     * @type {?}
     * @private
     */
    NxTreeNodePaddingDirective.prototype._dir;
}

/**
 * @fileoverview added by tsickle
 * Generated from: toggle.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Wrapper for the CdkTree's toggle with NDBX design styles.
 * @template T
 */
class NxTreeNodeToggleDirective extends CdkTreeNodeToggle {
    constructor() {
        super(...arguments);
        this.recursive = false;
    }
}
NxTreeNodeToggleDirective.decorators = [
    { type: Directive, args: [{
                selector: '[nxTreeNodeToggle]',
                providers: [{ provide: CdkTreeNodeToggle, useExisting: NxTreeNodeToggleDirective }]
            },] }
];
NxTreeNodeToggleDirective.propDecorators = {
    recursive: [{ type: Input, args: ['nxTreeNodeToggleRecursive',] }]
};
if (false) {
    /** @type {?} */
    NxTreeNodeToggleDirective.prototype.recursive;
}

/**
 * @fileoverview added by tsickle
 * Generated from: tree.component.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Wrapper for the CdkTable with NDBX design styles.
 * @template T
 */
class NxTreeComponent extends CdkTree {
}
NxTreeComponent.decorators = [
    { type: Component, args: [{
                selector: 'nx-tree',
                exportAs: 'nxTree',
                template: `<ng-container nxTreeNodeOutlet></ng-container>`,
                host: {
                    'class': 'nx-tree',
                    'role': 'tree',
                },
                encapsulation: ViewEncapsulation.None,
                changeDetection: ChangeDetectionStrategy.OnPush,
                providers: [{ provide: CdkTree, useExisting: NxTreeComponent }],
                styles: [":host.nx-tree{display:block}.nx-tree__node{display:block;overflow:hidden}"]
            }] }
];
NxTreeComponent.propDecorators = {
    _nodeOutlet: [{ type: ViewChild, args: [NxTreeNodeOutletDirective, { static: true },] }]
};
if (false) {
    /** @type {?} */
    NxTreeComponent.prototype._nodeOutlet;
}

/**
 * @fileoverview added by tsickle
 * Generated from: tree.module.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class NxTreeModule {
}
NxTreeModule.decorators = [
    { type: NgModule, args: [{
                imports: [CdkTreeModule, CommonModule],
                declarations: [NxTreeComponent, NxTreeNodeComponent, NxTreeNodeDefDirective,
                    NxTreeNodePaddingDirective, NxTreeNodeToggleDirective, NxTreeNodeOutletDirective],
                exports: [NxTreeComponent, NxTreeNodeComponent, NxTreeNodeDefDirective,
                    NxTreeNodePaddingDirective, NxTreeNodeToggleDirective, NxTreeNodeOutletDirective]
            },] }
];

/**
 * @fileoverview added by tsickle
 * Generated from: public-api.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * Generated from: allianz-ngx-ndbx-tree.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

export { NxFlatTreeControl, NxTreeComponent, NxTreeFlatDataSource, NxTreeModule, NxTreeNodeComponent, NxTreeNodeDefDirective, NxTreeNodeOutletDirective, NxTreeNodePaddingDirective, NxTreeNodeToggleDirective };
//# sourceMappingURL=allianz-ngx-ndbx-tree.js.map
