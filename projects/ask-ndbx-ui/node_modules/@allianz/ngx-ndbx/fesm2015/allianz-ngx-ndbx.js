import { NgModule, HostBinding, Component, ChangeDetectionStrategy, ChangeDetectorRef, ElementRef, EventEmitter, Optional, Self, ContentChildren, forwardRef, ContentChild, Output, Input, ViewChild, Renderer2, HostListener, ViewContainerRef, QueryList, Inject, Injectable, Directive, TemplateRef, NgZone, ViewChildren, isDevMode, Attribute, Host, InjectionToken, Injector, SkipSelf, ɵɵdefineInjectable, ɵɵinject, INJECTOR } from '@angular/core';
import { CommonModule, DOCUMENT } from '@angular/common';
import { coerceBooleanProperty, coerceNumberProperty } from '@angular/cdk/coercion';
import { NgControl, NgForm, FormGroupDirective, NG_VALUE_ACCESSOR, FormsModule, NG_VALIDATORS } from '@angular/forms';
import { Subject, merge, Subscription, fromEvent, defer, Observable, of, BehaviorSubject } from 'rxjs';
import { NxLabelComponent, NxLabelModule, NxErrorModule, NxErrorComponent } from '@allianz/ngx-ndbx/base';
import { ErrorStateMatcher, removeClasses, mapClassNames, getFontShorthand, pad, appendClasses } from '@allianz/ngx-ndbx/utils';
import { NxIconModule, NxIconComponent } from '@allianz/ngx-ndbx/icon';
import { ObserversModule } from '@angular/cdk/observers';
import { MappedStyles as MappedStyles$1 } from '@allianz/ngx-ndbx/core';
import { startWith, filter, tap, takeUntil, map, take, switchMap, delay, debounceTime, first, throttleTime } from 'rxjs/operators';
import { UniqueSelectionDispatcher, SelectionModel, DataSource } from '@angular/cdk/collections';
import { EventManager, DomSanitizer } from '@angular/platform-browser';
import { animation, style, animate, trigger, transition, useAnimation, query, animateChild, state } from '@angular/animations';
import { A11yModule, FocusTrapFactory, FocusMonitor, ActiveDescendantKeyManager, LiveAnnouncer, FocusKeyManager } from '@angular/cdk/a11y';
import { OverlayConfig, Overlay, OverlayModule, CdkConnectedOverlay, ViewportRuler, OverlayPositionBuilder } from '@angular/cdk/overlay';
import { TemplatePortal, BasePortalOutlet, CdkPortalOutlet, PortalModule, ComponentPortal, PortalInjector, CdkPortal } from '@angular/cdk/portal';
import { ENTER, SPACE, DELETE, BACKSPACE, DOWN_ARROW, UP_ARROW, LEFT_ARROW, RIGHT_ARROW, HOME, END, SHIFT, TAB, ESCAPE } from '@angular/cdk/keycodes';
import { Platform } from '@angular/cdk/platform';
import { NxFormfieldControl, NxFormfieldComponent, NxFormfieldModule, NxFormfieldErrorDirective } from '@allianz/ngx-ndbx/formfield';
import { NxCheckboxModule as NxCheckboxModule$1 } from '@allianz/ngx-ndbx/checkbox';
import { Directionality } from '@angular/cdk/bidi';
import { NxWordComponent as NxWordComponent$1 } from '@allianz/ngx-ndbx/natural-language-form';
import { NxPopoverModule as NxPopoverModule$1 } from '@allianz/ngx-ndbx/popover';
import { NxInputModule } from '@allianz/ngx-ndbx/input';
import { NxDropdownComponent as NxDropdownComponent$1 } from '@allianz/ngx-ndbx/dropdown';
import { NxGridModule } from '@allianz/ngx-ndbx/grid';
import { NxAutocompleteModule as NxAutocompleteModule$1 } from '@allianz/ngx-ndbx/autocomplete';
import { NxButtonModule as NxButtonModule$1 } from '@allianz/ngx-ndbx/button';
import { Decimal } from 'decimal.js';
import { CdkTableModule } from '@angular/cdk/table';
import { ScrollingModule } from '@angular/cdk/scrolling';
import { CdkAccordion, CdkAccordionItem } from '@angular/cdk/accordion';
import { NxExpansionPanelComponent as NxExpansionPanelComponent$1, NxAccordionDirective as NxAccordionDirective$1, NxAccordionModule as NxAccordionModule$1 } from '@allianz/ngx-ndbx/accordion';

/**
 * @fileoverview added by tsickle
 * Generated from: ndbx.module.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class NdbxModule {
    /**
     * @return {?}
     */
    static forRoot() {
        return {
            ngModule: NdbxModule
        };
    }
}
NdbxModule.decorators = [
    { type: NgModule, args: [{},] }
];

/**
 * @fileoverview added by tsickle
 * Generated from: button/button-base.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const DEFAULT_SIZE = 'medium';
/** @type {?} */
const DEFAULT_TYPE = 'primary';
/**
 * \@docs-private
 */
class NxButtonBase {
    /**
     * @param {?} _changeDetectorRef
     * @param {?} _elementRef
     */
    constructor(_changeDetectorRef, _elementRef) {
        this._changeDetectorRef = _changeDetectorRef;
        this._elementRef = _elementRef;
        /**
         * \@docs-private
         */
        this.type = DEFAULT_TYPE;
        /**
         * \@docs-private
         */
        this.size = DEFAULT_SIZE;
        this.negative = false;
        this.block = false;
    }
    /**
     * \@docs-private
     * @return {?}
     */
    get isPrimary() { return this.type === 'primary'; }
    /**
     * \@docs-private
     * @return {?}
     */
    get isSecondary() { return this.type === 'secondary'; }
    /**
     * \@docs-private
     * @return {?}
     */
    get isTertiary() { return this.type === 'tertiary'; }
    /**
     * \@docs-private
     * @return {?}
     */
    get isCta() { return this.type === 'cta'; }
    /**
     * \@docs-private
     * @return {?}
     */
    get isEmphasis() { return this.type === 'emphasis'; }
    /**
     * \@docs-private
     * @return {?}
     */
    get isLarge() { return this.size === 'large'; }
    /**
     * \@docs-private
     * @return {?}
     */
    get isMedium() { return this.size === 'medium'; }
    /**
     * \@docs-private
     * @return {?}
     */
    get isSmallMedium() { return this.size === 'small-medium'; }
    /**
     * \@docs-private
     * @return {?}
     */
    get isSmall() { return this.size === 'small'; }
    /**
     * \@docs-private
     * @return {?}
     */
    get isBlock() { return this.block; }
    /**
     * \@docs-private
     * @return {?}
     */
    get isNegative() { return this.negative; }
    /**
     * @param {?} value
     * @return {?}
     */
    set classNames(value) {
        if (this._classNames === value) {
            return;
        }
        this._classNames = value;
        const [type = null] = this._classNames.match(/primary|secondary|tertiary|cta|emphasis/) || [DEFAULT_TYPE];
        this.type = (/** @type {?} */ (type));
        const [size = null] = this._classNames.match(/small-medium|small|medium|large/) || [DEFAULT_SIZE];
        this.size = (/** @type {?} */ (size));
        this.negative = /negative/.test(this._classNames);
        this.block = /block/.test(this._classNames);
        this._changeDetectorRef.markForCheck();
    }
    /**
     * @return {?}
     */
    get classNames() {
        return this._classNames;
    }
    /**
     * \@docs-private
     * getter used for the modal component as a quickfix
     * since button got changed from directive to component the reference used by the ngOpenModelOnClick directive
     * for nxButtons is a reference to component instance instead of an element reference. As a workaround we need a
     * way to reach the elementRef of the component until the modal gets refactored.
     * @return {?}
     */
    get elementRef() {
        return this._elementRef;
    }
}
NxButtonBase.propDecorators = {
    isPrimary: [{ type: HostBinding, args: ['class.nx-button--primary',] }],
    isSecondary: [{ type: HostBinding, args: ['class.nx-button--secondary',] }],
    isTertiary: [{ type: HostBinding, args: ['class.nx-button--tertiary',] }],
    isCta: [{ type: HostBinding, args: ['class.nx-button--cta',] }],
    isEmphasis: [{ type: HostBinding, args: ['class.nx-button--emphasis',] }],
    isLarge: [{ type: HostBinding, args: ['class.nx-button--large',] }],
    isMedium: [{ type: HostBinding, args: ['class.nx-button--medium',] }],
    isSmallMedium: [{ type: HostBinding, args: ['class.nx-button--small-medium',] }],
    isSmall: [{ type: HostBinding, args: ['class.nx-button--small',] }],
    isBlock: [{ type: HostBinding, args: ['class.nx-button--block',] }],
    isNegative: [{ type: HostBinding, args: ['class.nx-button--negative',] }]
};
if (false) {
    /**
     * @type {?}
     * @private
     */
    NxButtonBase.prototype._classNames;
    /**
     * \@docs-private
     * @type {?}
     */
    NxButtonBase.prototype.type;
    /**
     * \@docs-private
     * @type {?}
     */
    NxButtonBase.prototype.size;
    /** @type {?} */
    NxButtonBase.prototype.negative;
    /** @type {?} */
    NxButtonBase.prototype.block;
    /**
     * @type {?}
     * @private
     */
    NxButtonBase.prototype._changeDetectorRef;
    /**
     * @type {?}
     * @private
     */
    NxButtonBase.prototype._elementRef;
}

/**
 * @fileoverview added by tsickle
 * Generated from: button/button.component.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class NxButtonComponent extends NxButtonBase {
    /**
     * @param {?} changeDetectorRef
     * @param {?} elementRef
     */
    constructor(changeDetectorRef, elementRef) {
        super(changeDetectorRef, elementRef);
    }
}
NxButtonComponent.decorators = [
    { type: Component, args: [{
                template: "<span class=\"nx-button__content-wrapper\">\n  <ng-content></ng-content>\n</span>\n",
                // tslint:disable-next-line:component-selector
                selector: 'button[nxButton]',
                changeDetection: ChangeDetectionStrategy.OnPush,
                inputs: ['classNames:nxButton'],
                styles: [":host{font-size:16px;font-size:var(--button-medium-font-size,16px);line-height:24px;line-height:var(--button-medium-line-height,24px);font-weight:600;font-weight:var(--button-medium-font-weight,600);letter-spacing:1px;letter-spacing:var(--button-medium-letter-spacing,1px);min-height:48px;min-height:var(--button-medium-height,48px);text-transform:uppercase;text-transform:var(--button-text-transform,uppercase);border-width:var(--button-border-width,2px);border-radius:4px;border-radius:var(--button-border-radius,4px);cursor:pointer;margin:0 0 24px;padding:10px 30px;padding:calc(12px - var(--button-border-width,2px)) calc(32px - var(--button-border-width,2px));transition:background-color .2s,border-color .2s,color .2s,box-shadow .2s;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;width:auto;-webkit-hyphens:none;-ms-hyphens:none;hyphens:none;vertical-align:middle;border:2px solid transparent}:host:disabled{cursor:not-allowed}:host:focus{outline:0}:host::-moz-focus-inner{border:0}:host-context([data-whatinput=keyboard]).nx-button--negative:focus,:host-context([data-whatinput=keyboard]):focus{box-shadow:0 0 0 2px #fff,0 0 0 6px #009de6;box-shadow:var(--focus-box-shadow,0 0 0 2px #fff,0 0 0 6px #009de6)}:host(.nx-button--primary){color:#fff;color:var(--button-primary-text-color,#fff);background-color:#007ab3;background-color:var(--button-primary-background-color,#007ab3);border-color:transparent;border-color:var(--button-primary-border-color,transparent)}:host(.nx-button--primary):hover:not(:disabled):not(:active){background-color:#006192;background-color:var(--button-primary-hover-background-color,#006192);color:#fff;color:var(--button-primary-hover-text-color,#fff);border-color:transparent;border-color:var(--button-primary-hover-border-color,transparent)}:host(.nx-button--primary):active{background-color:#003781;background-color:var(--button-primary-active-background-color,#003781);color:#fff;color:var(--button-primary-active-text-color,#fff);border-color:transparent;border-color:var(--button-primary-active-border-color,transparent)}:host(.nx-button--primary):disabled{background-color:rgba(0,122,179,.4);background-color:var(--button-primary-disabled-background-color,rgba(0,122,179,.4));color:rgba(255,255,255,.4);color:var(--button-primary-disabled-text-color,rgba(255,255,255,.4));border-color:transparent;border-color:var(--button-primary-disabled-border-color,transparent)}:host(.nx-button--primary.nx-button--negative){background-color:#fff;border-color:#fff;color:#006192}:host(.nx-button--primary.nx-button--negative):hover:not(:disabled):not(:active){background-color:#d9d9d9;border-color:#d9d9d9;color:#006192}:host(.nx-button--primary.nx-button--negative):active{background-color:#c2c2c2;border-color:#c2c2c2;color:#006192}:host(.nx-button--primary.nx-button--negative):disabled{background-color:rgba(255,255,255,.4);border-color:transparent;color:rgba(65,65,65,.3)}:host(.nx-button--secondary){color:#006192;color:var(--button-secondary-text-color,#006192);background-color:transparent;background-color:var(--button-secondary-background-color,transparent);border-color:#007ab3;border-color:var(--button-secondary-border-color,#007ab3)}:host(.nx-button--secondary):hover:not(:disabled):not(:active){background-color:#006192;background-color:var(--button-secondary-hover-background-color,#006192);color:#fff;color:var(--button-secondary-hover-text-color,#fff);border-color:transparent;border-color:var(--button-secondary-hover-border-color,transparent)}:host(.nx-button--secondary):active{background-color:#003781;background-color:var(--button-secondary-active-background-color,#003781);color:#fff;color:var(--button-secondary-active-text-color,#fff);border-color:transparent;border-color:var(--button-secondary-active-border-color,transparent)}:host(.nx-button--secondary):disabled{background-color:transparent;background-color:var(--button-secondary-disabled-background-color,transparent);color:rgba(0,97,146,.4);color:var(--button-secondary-disabled-text-color,rgba(0,97,146,.4));border-color:rgba(0,122,179,.4);border-color:var(--button-secondary-disabled-border-color,rgba(0,122,179,.4))}:host(.nx-button--secondary.nx-button--negative){color:#fff;border-color:#fff}:host(.nx-button--secondary.nx-button--negative):hover:not(:disabled):not(:active){background-color:#d9d9d9;border-color:#d9d9d9;color:#006192;color:var(--button-secondary-text-color,#006192)}:host(.nx-button--secondary.nx-button--negative):active{background-color:#c2c2c2;border-color:#c2c2c2;color:#006192;color:var(--button-secondary-text-color,#006192)}:host(.nx-button--secondary.nx-button--negative):disabled{background-color:transparent;border-color:rgba(255,255,255,.4);color:rgba(255,255,255,.4)}:host(.nx-button--tertiary){color:#006192;color:var(--button-tertiary-text-color,#006192);background-color:transparent;background-color:var(--button-tertiary-background-color,transparent);border-color:transparent;border-color:var(--button-tertiary-border-color,transparent)}:host(.nx-button--tertiary):hover:not(:disabled):not(:active){background-color:#ececec;background-color:var(--button-tertiary-hover-background-color,#ececec);color:#006192;color:var(--button-tertiary-hover-text-color,#006192);border-color:transparent;border-color:var(--button-tertiary-hover-border-color,transparent)}:host(.nx-button--tertiary):active{background-color:#d9d9d9;background-color:var(--button-tertiary-active-background-color,#d9d9d9);color:#006192;color:var(--button-tertiary-active-text-color,#006192);border-color:transparent;border-color:var(--button-tertiary-active-border-color,transparent)}:host(.nx-button--tertiary):disabled{background-color:transparent;background-color:var(--button-tertiary-disabled-background-color,transparent);color:rgba(0,97,146,.4);color:var(--button-tertiary-disabled-text-color,rgba(0,97,146,.4));border-color:transparent;border-color:var(--button-tertiary-disabled-border-color,transparent)}:host(.nx-button--tertiary.nx-button--negative){color:#fff}:host(.nx-button--tertiary.nx-button--negative):hover{background-color:#d9d9d9;color:#006192;color:var(--button-secondary-text-color,#006192)}:host(.nx-button--tertiary.nx-button--negative):active{background-color:#c2c2c2;color:#006192;color:var(--button-secondary-text-color,#006192)}:host(.nx-button--tertiary.nx-button--negative):disabled{background-color:transparent;color:rgba(255,255,255,.4)}:host(.nx-button--large){font-size:20px;font-size:var(--button-large-font-size,20px);line-height:24px;line-height:var(--button-large-line-height,24px);font-weight:600;font-weight:var(--button-large-font-weight,600);letter-spacing:1px;letter-spacing:var(--button-large-letter-spacing,1px);min-height:72px;min-height:var(--button-large-height,72px);padding:22px 46px;padding:calc(24px - var(--button-border-width,2px)) calc(48px - var(--button-border-width,2px))}@media (max-width:703px){:host{display:block;width:100%}:host(.nx-button--large){padding:22px 30px;padding:calc(24px - var(--button-border-width,2px)) calc(32px - var(--button-border-width,2px))}}:host(.nx-button--small-medium){display:inline-block;font-size:16px;font-size:var(--button-small-medium-font-size,16px);line-height:24px;line-height:var(--button-small-medium-line-height,24px);font-weight:600;font-weight:var(--button-small-medium-font-weight,600);letter-spacing:1px;letter-spacing:var(--button-small-medium-letter-spacing,1px);padding:6px 22px;padding:calc(8px - var(--button-border-width,2px)) calc(24px - var(--button-border-width,2px));text-transform:none;width:auto;min-height:40px;min-height:var(--button-small-medium-height,40px)}:host(.nx-button--small){font-size:14px;font-size:var(--button-small-font-size,14px);line-height:16px;line-height:var(--button-small-line-height,16px);font-weight:600;font-weight:var(--button-small-font-weight,600);letter-spacing:1px;letter-spacing:var(--button-small-letter-spacing,1px);min-height:32px;min-height:var(--button-small-height,32px);display:inline-block;padding:6px 14px;padding:calc(8px - var(--button-border-width,2px)) calc(16px - var(--button-border-width,2px));text-transform:none;width:auto}:host(.nx-button--cta){color:#fff;color:var(--button-cta-text-color,#fff);background-color:#3da556;background-color:var(--button-cta-background-color,#3da556);border-color:transparent;border-color:var(--button-cta-border-color,transparent)}:host(.nx-button--cta):hover:not(:disabled):not(:active){background-color:#348357;background-color:var(--button-cta-hover-background-color,#348357);color:#fff;color:var(--button-cta-hover-text-color,#fff);border-color:transparent;border-color:var(--button-cta-hover-border-color,transparent)}:host(.nx-button--cta):active{background-color:#276442;background-color:var(--button-cta-active-background-color,#276442);color:#fff;color:var(--button-cta-active-text-color,#fff);border-color:transparent;border-color:var(--button-cta-active-border-color,transparent)}:host(.nx-button--cta):disabled{background-color:rgba(61,165,86,.4);background-color:var(--button-cta-disabled-background-color,rgba(61,165,86,.4));color:rgba(255,255,255,.4);color:var(--button-cta-disabled-text-color,rgba(255,255,255,.4));border-color:transparent;border-color:var(--button-cta-disabled-border-color,transparent)}:host(.nx-button--emphasis){color:#fff;color:var(--button-emphasis-text-color,#fff);background-color:#f86200;background-color:var(--button-emphasis-background-color,#f86200);border-color:transparent;border-color:var(--button-emphasis-border-color,transparent)}:host(.nx-button--emphasis):hover:not(:disabled):not(:active){background-color:#e15200;background-color:var(--button-emphasis-hover-background-color,#e15200);color:#fff;color:var(--button-emphasis-hover-text-color,#fff);border-color:transparent;border-color:var(--button-emphasis-hover-border-color,transparent)}:host(.nx-button--emphasis):active{background-color:#c15500;background-color:var(--button-emphasis-active-background-color,#c15500);color:#fff;color:var(--button-emphasis-active-text-color,#fff);border-color:transparent;border-color:var(--button-emphasis-active-border-color,transparent)}:host(.nx-button--emphasis):disabled{background-color:rgba(248,98,0,.4);background-color:var(--button-emphasis-disabled-background-color,rgba(248,98,0,.4));color:rgba(255,255,255,.4);color:var(--button-emphasis-disabled-text-color,rgba(255,255,255,.4));border-color:transparent;border-color:var(--button-emphasis-disabled-border-color,transparent)}@media (min-width:704px){:host(.nx-button--block){display:block;width:100%}}:host .nx-button__content-wrapper{display:inline-flex;align-items:center;justify-content:center;vertical-align:bottom}:host([nxiconbutton]),:host([nxsidebartoggle]){padding:0;flex:0 0 auto}:host([nxiconbutton]).nx-button--small,:host([nxsidebartoggle]).nx-button--small{width:32px;width:var(--button-small-height,32px);font-size:16px;font-size:var(--icon-button-small-icon-size,16px)}:host([nxiconbutton]).nx-button--small-medium,:host([nxsidebartoggle]).nx-button--small-medium{width:40px;width:var(--button-small-medium-height,40px);font-size:24px;font-size:var(--icon-button-small-medium-icon-size,24px)}:host([nxiconbutton]).nx-button--medium,:host([nxsidebartoggle]).nx-button--medium{width:48px;width:var(--button-medium-height,48px);font-size:24px;font-size:var(--icon-button-medium-icon-size,24px)}:host([nxiconbutton]).nx-button--large,:host([nxsidebartoggle]).nx-button--large{width:72px;width:var(--button-large-height,72px);font-size:24px;font-size:var(--icon-button-large-icon-size,24px)}:host([nxbutton]).nx-button--small ::ng-deep nx-icon{font-size:16px;font-size:var(--button-small-icon-size,16px)}:host([nxbutton]).nx-button--small-medium ::ng-deep nx-icon{font-size:20px;font-size:var(--button-small-medium-icon-size,20px)}:host([nxbutton]).nx-button--medium ::ng-deep nx-icon{font-size:24px;font-size:var(--button-medium-icon-size,24px)}:host([nxbutton]).nx-button--large ::ng-deep nx-icon{font-size:24px;font-size:var(--button-large-icon-size,24px)}@media screen and (-ms-high-contrast:active){:host-context([data-whatinput=keyboard]).nx-button--negative:focus,:host-context([data-whatinput=keyboard]):focus{box-shadow:0 0 0 2px background,0 0 0 6px windowText}:host{background-color:buttonFace}:host .nx-button__content-wrapper{-ms-high-contrast-adjust:none}:host:disabled{color:GrayText;border-color:GrayText}}"]
            }] }
];
/** @nocollapse */
NxButtonComponent.ctorParameters = () => [
    { type: ChangeDetectorRef },
    { type: ElementRef }
];

/**
 * @fileoverview added by tsickle
 * Generated from: button/icon-button.component.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class NxIconButtonComponent extends NxButtonBase {
    /**
     * @param {?} changeDetectorRef
     * @param {?} elementRef
     */
    constructor(changeDetectorRef, elementRef) {
        super(changeDetectorRef, elementRef);
    }
}
NxIconButtonComponent.decorators = [
    { type: Component, args: [{
                // tslint:disable-next-line:component-selector
                selector: 'button[nxIconButton]',
                template: "<span class=\"nx-button__content-wrapper\">\n  <ng-content></ng-content>\n</span>\n",
                changeDetection: ChangeDetectionStrategy.OnPush,
                inputs: ['classNames:nxIconButton'],
                styles: [":host{font-size:16px;font-size:var(--button-medium-font-size,16px);line-height:24px;line-height:var(--button-medium-line-height,24px);font-weight:600;font-weight:var(--button-medium-font-weight,600);letter-spacing:1px;letter-spacing:var(--button-medium-letter-spacing,1px);min-height:48px;min-height:var(--button-medium-height,48px);text-transform:uppercase;text-transform:var(--button-text-transform,uppercase);border-width:var(--button-border-width,2px);border-radius:4px;border-radius:var(--button-border-radius,4px);cursor:pointer;margin:0 0 24px;padding:10px 30px;padding:calc(12px - var(--button-border-width,2px)) calc(32px - var(--button-border-width,2px));transition:background-color .2s,border-color .2s,color .2s,box-shadow .2s;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;width:auto;-webkit-hyphens:none;-ms-hyphens:none;hyphens:none;vertical-align:middle;border:2px solid transparent}:host:disabled{cursor:not-allowed}:host:focus{outline:0}:host::-moz-focus-inner{border:0}:host-context([data-whatinput=keyboard]).nx-button--negative:focus,:host-context([data-whatinput=keyboard]):focus{box-shadow:0 0 0 2px #fff,0 0 0 6px #009de6;box-shadow:var(--focus-box-shadow,0 0 0 2px #fff,0 0 0 6px #009de6)}:host(.nx-button--primary){color:#fff;color:var(--button-primary-text-color,#fff);background-color:#007ab3;background-color:var(--button-primary-background-color,#007ab3);border-color:transparent;border-color:var(--button-primary-border-color,transparent)}:host(.nx-button--primary):hover:not(:disabled):not(:active){background-color:#006192;background-color:var(--button-primary-hover-background-color,#006192);color:#fff;color:var(--button-primary-hover-text-color,#fff);border-color:transparent;border-color:var(--button-primary-hover-border-color,transparent)}:host(.nx-button--primary):active{background-color:#003781;background-color:var(--button-primary-active-background-color,#003781);color:#fff;color:var(--button-primary-active-text-color,#fff);border-color:transparent;border-color:var(--button-primary-active-border-color,transparent)}:host(.nx-button--primary):disabled{background-color:rgba(0,122,179,.4);background-color:var(--button-primary-disabled-background-color,rgba(0,122,179,.4));color:rgba(255,255,255,.4);color:var(--button-primary-disabled-text-color,rgba(255,255,255,.4));border-color:transparent;border-color:var(--button-primary-disabled-border-color,transparent)}:host(.nx-button--primary.nx-button--negative){background-color:#fff;border-color:#fff;color:#006192}:host(.nx-button--primary.nx-button--negative):hover:not(:disabled):not(:active){background-color:#d9d9d9;border-color:#d9d9d9;color:#006192}:host(.nx-button--primary.nx-button--negative):active{background-color:#c2c2c2;border-color:#c2c2c2;color:#006192}:host(.nx-button--primary.nx-button--negative):disabled{background-color:rgba(255,255,255,.4);border-color:transparent;color:rgba(65,65,65,.3)}:host(.nx-button--secondary){color:#006192;color:var(--button-secondary-text-color,#006192);background-color:transparent;background-color:var(--button-secondary-background-color,transparent);border-color:#007ab3;border-color:var(--button-secondary-border-color,#007ab3)}:host(.nx-button--secondary):hover:not(:disabled):not(:active){background-color:#006192;background-color:var(--button-secondary-hover-background-color,#006192);color:#fff;color:var(--button-secondary-hover-text-color,#fff);border-color:transparent;border-color:var(--button-secondary-hover-border-color,transparent)}:host(.nx-button--secondary):active{background-color:#003781;background-color:var(--button-secondary-active-background-color,#003781);color:#fff;color:var(--button-secondary-active-text-color,#fff);border-color:transparent;border-color:var(--button-secondary-active-border-color,transparent)}:host(.nx-button--secondary):disabled{background-color:transparent;background-color:var(--button-secondary-disabled-background-color,transparent);color:rgba(0,97,146,.4);color:var(--button-secondary-disabled-text-color,rgba(0,97,146,.4));border-color:rgba(0,122,179,.4);border-color:var(--button-secondary-disabled-border-color,rgba(0,122,179,.4))}:host(.nx-button--secondary.nx-button--negative){color:#fff;border-color:#fff}:host(.nx-button--secondary.nx-button--negative):hover:not(:disabled):not(:active){background-color:#d9d9d9;border-color:#d9d9d9;color:#006192;color:var(--button-secondary-text-color,#006192)}:host(.nx-button--secondary.nx-button--negative):active{background-color:#c2c2c2;border-color:#c2c2c2;color:#006192;color:var(--button-secondary-text-color,#006192)}:host(.nx-button--secondary.nx-button--negative):disabled{background-color:transparent;border-color:rgba(255,255,255,.4);color:rgba(255,255,255,.4)}:host(.nx-button--tertiary){color:#006192;color:var(--button-tertiary-text-color,#006192);background-color:transparent;background-color:var(--button-tertiary-background-color,transparent);border-color:transparent;border-color:var(--button-tertiary-border-color,transparent)}:host(.nx-button--tertiary):hover:not(:disabled):not(:active){background-color:#ececec;background-color:var(--button-tertiary-hover-background-color,#ececec);color:#006192;color:var(--button-tertiary-hover-text-color,#006192);border-color:transparent;border-color:var(--button-tertiary-hover-border-color,transparent)}:host(.nx-button--tertiary):active{background-color:#d9d9d9;background-color:var(--button-tertiary-active-background-color,#d9d9d9);color:#006192;color:var(--button-tertiary-active-text-color,#006192);border-color:transparent;border-color:var(--button-tertiary-active-border-color,transparent)}:host(.nx-button--tertiary):disabled{background-color:transparent;background-color:var(--button-tertiary-disabled-background-color,transparent);color:rgba(0,97,146,.4);color:var(--button-tertiary-disabled-text-color,rgba(0,97,146,.4));border-color:transparent;border-color:var(--button-tertiary-disabled-border-color,transparent)}:host(.nx-button--tertiary.nx-button--negative){color:#fff}:host(.nx-button--tertiary.nx-button--negative):hover{background-color:#d9d9d9;color:#006192;color:var(--button-secondary-text-color,#006192)}:host(.nx-button--tertiary.nx-button--negative):active{background-color:#c2c2c2;color:#006192;color:var(--button-secondary-text-color,#006192)}:host(.nx-button--tertiary.nx-button--negative):disabled{background-color:transparent;color:rgba(255,255,255,.4)}:host(.nx-button--large){font-size:20px;font-size:var(--button-large-font-size,20px);line-height:24px;line-height:var(--button-large-line-height,24px);font-weight:600;font-weight:var(--button-large-font-weight,600);letter-spacing:1px;letter-spacing:var(--button-large-letter-spacing,1px);min-height:72px;min-height:var(--button-large-height,72px);padding:22px 46px;padding:calc(24px - var(--button-border-width,2px)) calc(48px - var(--button-border-width,2px))}@media (max-width:703px){:host{display:block;width:100%}:host(.nx-button--large){padding:22px 30px;padding:calc(24px - var(--button-border-width,2px)) calc(32px - var(--button-border-width,2px))}}:host(.nx-button--small-medium){display:inline-block;font-size:16px;font-size:var(--button-small-medium-font-size,16px);line-height:24px;line-height:var(--button-small-medium-line-height,24px);font-weight:600;font-weight:var(--button-small-medium-font-weight,600);letter-spacing:1px;letter-spacing:var(--button-small-medium-letter-spacing,1px);padding:6px 22px;padding:calc(8px - var(--button-border-width,2px)) calc(24px - var(--button-border-width,2px));text-transform:none;width:auto;min-height:40px;min-height:var(--button-small-medium-height,40px)}:host(.nx-button--small){font-size:14px;font-size:var(--button-small-font-size,14px);line-height:16px;line-height:var(--button-small-line-height,16px);font-weight:600;font-weight:var(--button-small-font-weight,600);letter-spacing:1px;letter-spacing:var(--button-small-letter-spacing,1px);min-height:32px;min-height:var(--button-small-height,32px);display:inline-block;padding:6px 14px;padding:calc(8px - var(--button-border-width,2px)) calc(16px - var(--button-border-width,2px));text-transform:none;width:auto}:host(.nx-button--cta){color:#fff;color:var(--button-cta-text-color,#fff);background-color:#3da556;background-color:var(--button-cta-background-color,#3da556);border-color:transparent;border-color:var(--button-cta-border-color,transparent)}:host(.nx-button--cta):hover:not(:disabled):not(:active){background-color:#348357;background-color:var(--button-cta-hover-background-color,#348357);color:#fff;color:var(--button-cta-hover-text-color,#fff);border-color:transparent;border-color:var(--button-cta-hover-border-color,transparent)}:host(.nx-button--cta):active{background-color:#276442;background-color:var(--button-cta-active-background-color,#276442);color:#fff;color:var(--button-cta-active-text-color,#fff);border-color:transparent;border-color:var(--button-cta-active-border-color,transparent)}:host(.nx-button--cta):disabled{background-color:rgba(61,165,86,.4);background-color:var(--button-cta-disabled-background-color,rgba(61,165,86,.4));color:rgba(255,255,255,.4);color:var(--button-cta-disabled-text-color,rgba(255,255,255,.4));border-color:transparent;border-color:var(--button-cta-disabled-border-color,transparent)}:host(.nx-button--emphasis){color:#fff;color:var(--button-emphasis-text-color,#fff);background-color:#f86200;background-color:var(--button-emphasis-background-color,#f86200);border-color:transparent;border-color:var(--button-emphasis-border-color,transparent)}:host(.nx-button--emphasis):hover:not(:disabled):not(:active){background-color:#e15200;background-color:var(--button-emphasis-hover-background-color,#e15200);color:#fff;color:var(--button-emphasis-hover-text-color,#fff);border-color:transparent;border-color:var(--button-emphasis-hover-border-color,transparent)}:host(.nx-button--emphasis):active{background-color:#c15500;background-color:var(--button-emphasis-active-background-color,#c15500);color:#fff;color:var(--button-emphasis-active-text-color,#fff);border-color:transparent;border-color:var(--button-emphasis-active-border-color,transparent)}:host(.nx-button--emphasis):disabled{background-color:rgba(248,98,0,.4);background-color:var(--button-emphasis-disabled-background-color,rgba(248,98,0,.4));color:rgba(255,255,255,.4);color:var(--button-emphasis-disabled-text-color,rgba(255,255,255,.4));border-color:transparent;border-color:var(--button-emphasis-disabled-border-color,transparent)}@media (min-width:704px){:host(.nx-button--block){display:block;width:100%}}:host .nx-button__content-wrapper{display:inline-flex;align-items:center;justify-content:center;vertical-align:bottom}:host([nxiconbutton]),:host([nxsidebartoggle]){padding:0;flex:0 0 auto}:host([nxiconbutton]).nx-button--small,:host([nxsidebartoggle]).nx-button--small{width:32px;width:var(--button-small-height,32px);font-size:16px;font-size:var(--icon-button-small-icon-size,16px)}:host([nxiconbutton]).nx-button--small-medium,:host([nxsidebartoggle]).nx-button--small-medium{width:40px;width:var(--button-small-medium-height,40px);font-size:24px;font-size:var(--icon-button-small-medium-icon-size,24px)}:host([nxiconbutton]).nx-button--medium,:host([nxsidebartoggle]).nx-button--medium{width:48px;width:var(--button-medium-height,48px);font-size:24px;font-size:var(--icon-button-medium-icon-size,24px)}:host([nxiconbutton]).nx-button--large,:host([nxsidebartoggle]).nx-button--large{width:72px;width:var(--button-large-height,72px);font-size:24px;font-size:var(--icon-button-large-icon-size,24px)}:host([nxbutton]).nx-button--small ::ng-deep nx-icon{font-size:16px;font-size:var(--button-small-icon-size,16px)}:host([nxbutton]).nx-button--small-medium ::ng-deep nx-icon{font-size:20px;font-size:var(--button-small-medium-icon-size,20px)}:host([nxbutton]).nx-button--medium ::ng-deep nx-icon{font-size:24px;font-size:var(--button-medium-icon-size,24px)}:host([nxbutton]).nx-button--large ::ng-deep nx-icon{font-size:24px;font-size:var(--button-large-icon-size,24px)}@media screen and (-ms-high-contrast:active){:host-context([data-whatinput=keyboard]).nx-button--negative:focus,:host-context([data-whatinput=keyboard]):focus{box-shadow:0 0 0 2px background,0 0 0 6px windowText}:host{background-color:buttonFace}:host .nx-button__content-wrapper{-ms-high-contrast-adjust:none}:host:disabled{color:GrayText;border-color:GrayText}}"]
            }] }
];
/** @nocollapse */
NxIconButtonComponent.ctorParameters = () => [
    { type: ChangeDetectorRef },
    { type: ElementRef }
];

/**
 * @fileoverview added by tsickle
 * Generated from: button/button.module.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class NxButtonModule {
}
NxButtonModule.decorators = [
    { type: NgModule, args: [{
                declarations: [NxButtonComponent, NxIconButtonComponent],
                exports: [NxButtonComponent, NxIconButtonComponent]
            },] }
];

/**
 * @fileoverview added by tsickle
 * Generated from: button/public-api.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * Generated from: button/index.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * Generated from: checkbox/checkbox.component.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
let nextId = 0;
class NxCheckboxChangeEvent {
    /**
     * @param {?} checked
     * @param {?} value
     * @param {?} checkbox
     */
    constructor(checked, value, checkbox) {
        this.checked = checked;
        this.value = value;
        this.checkbox = checkbox;
    }
}
if (false) {
    /**
     * The checked value of the checkbox.
     * @type {?}
     */
    NxCheckboxChangeEvent.prototype.checked;
    /**
     * The value of the checkbox.
     * @type {?}
     */
    NxCheckboxChangeEvent.prototype.value;
    /**
     * The component instance of the checkbox which emitted the change event.
     * @type {?}
     */
    NxCheckboxChangeEvent.prototype.checkbox;
}
class NxCheckboxGroupComponent {
    /**
     * @param {?} _changeDetectorRef
     * @param {?} ngControl
     */
    constructor(_changeDetectorRef, ngControl) {
        this._changeDetectorRef = _changeDetectorRef;
        this.ngControl = ngControl;
        this._stateChanges = new Subject();
        this.selectionChange = new EventEmitter();
        this._id = `nx-checkbox-group-${nextId++}`;
        this._disabled = false;
        this._negative = false;
        this._onChange = (/**
         * @return {?}
         */
        () => { });
        this._onTouched = (/**
         * @return {?}
         */
        () => { });
        if (this.ngControl) {
            // Note: we provide the value accessor through here, instead of
            // the `providers` to avoid running into a circular import.
            this.ngControl.valueAccessor = this;
        }
    }
    /**
     * Sets the Id of the checkbox group.
     * @param {?} value
     * @return {?}
     */
    set id(value) {
        if (this._id !== value) {
            this._id = value;
            this._changeDetectorRef.markForCheck();
        }
    }
    /**
     * @return {?}
     */
    get id() {
        return this._id;
    }
    /**
     * Sets the name of the checkboxes inside the nx-checkbox-group.
     * @param {?} value
     * @return {?}
     */
    set name(value) {
        this._name = value;
        this._changeDetectorRef.markForCheck();
    }
    /**
     * @return {?}
     */
    get name() {
        return this._name;
    }
    /**
     * Disables all checkboxes inside the nx-checkbox-group.
     * @param {?} value
     * @return {?}
     */
    set disabled(value) {
        this._disabled = coerceBooleanProperty(value);
        if (this._label) {
            this._label.disabled = this._disabled;
        }
        this._stateChanges.next();
    }
    /**
     * @return {?}
     */
    get disabled() {
        return this._disabled;
    }
    /**
     * Set the negative styles for all the checkboxes inside the nx-checkbox-group
     * @param {?} value
     * @return {?}
     */
    set negative(value) {
        this._negative = coerceBooleanProperty(value);
        this._changeDetectorRef.markForCheck();
        this._stateChanges.next();
    }
    /**
     * @return {?}
     */
    get negative() {
        return this._negative;
    }
    /**
     * Sets the label size of the checkboxes inside the group
     * @param {?} value
     * @return {?}
     */
    set labelSize(value) {
        this._labelSize = value;
        this._stateChanges.next();
    }
    /**
     * @return {?}
     */
    get labelSize() {
        return this._labelSize;
    }
    /**
     * Whether the nx-checkbox-group are required.
     * @return {?}
     */
    get required() {
        return this._required;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set required(value) {
        this._required = coerceBooleanProperty(value);
    }
    /**
     * @return {?}
     */
    ngAfterContentInit() {
        if (this.ngControl) {
            if (!!this._value) {
                this._updateSelectedCheckboxFromValue();
            }
            this._value = this._checkboxes
                .filter((/**
             * @param {?} checkbox
             * @return {?}
             */
            checkbox => checkbox.checked))
                .map((/**
             * @param {?} cb
             * @return {?}
             */
            cb => cb.value));
        }
        this._updateSelectedCheckboxFromValue();
        this._checkboxes.changes.subscribe((/**
         * @return {?}
         */
        () => {
            this._value = this._checkboxes.filter((/**
             * @param {?} checkbox
             * @return {?}
             */
            checkbox => checkbox.checked)).map((/**
             * @param {?} cb
             * @return {?}
             */
            cb => cb.value));
            if (this.ngControl) {
                this.ngControl.control.setValue(this._value);
            }
            this._updateSelectedCheckboxFromValue();
        }));
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this._stateChanges.complete();
    }
    /**
     * @param {?} value
     * @return {?}
     */
    writeValue(value) {
        if (this._value !== value) {
            this._value = value;
            this._updateSelectedCheckboxFromValue();
        }
    }
    /**
     * @param {?} fn
     * @return {?}
     */
    registerOnChange(fn) {
        this._onChange = fn;
    }
    /**
     * @param {?} fn
     * @return {?}
     */
    registerOnTouched(fn) {
        this._onTouched = fn;
    }
    /**
     * @param {?} isDisabled
     * @return {?}
     */
    setDisabledState(isDisabled) {
        this.disabled = isDisabled;
    }
    /**
     * @private
     * @return {?}
     */
    _updateSelectedCheckboxFromValue() {
        if (this._checkboxes && this._checkboxes.length && !!this._value && this._value.length) {
            this._checkboxes.map((/**
             * @param {?} checkbox
             * @return {?}
             */
            checkbox => {
                checkbox.checked = this._value.indexOf(checkbox.value) !== -1;
            }));
        }
    }
    /**
     * \@docs-private
     * @param {?} value
     * @return {?}
     */
    change(value) {
        value = this._checkboxes.filter((/**
         * @param {?} checkbox
         * @return {?}
         */
        checkbox => checkbox.checked)).map((/**
         * @param {?} cb
         * @return {?}
         */
        cb => cb.value));
        this._onChange(value);
        if (this._onTouched) {
            this._onTouched();
        }
        this.selectionChange.emit(new NxCheckboxChangeEvent(value.checked, value.value, value));
    }
}
NxCheckboxGroupComponent.decorators = [
    { type: Component, args: [{
                selector: 'nx-checkbox-group',
                template: "<div>\n  <div class=\"nx-checkbox-group__label\">\n    <ng-content select=\"nx-label\"></ng-content>\n  </div>\n  <div class=\"nx-checkbox-group__errors\">\n    <ng-content select=\"nx-error\"></ng-content>\n  </div>\n  <div class=\"nx-checkbox-group__controls\">\n    <ng-content></ng-content>\n  </div>\n</div>\n",
                changeDetection: ChangeDetectionStrategy.OnPush,
                host: {
                    '[class.nx-checkbox-group]': 'true',
                    '[class.nx-checkbox-group--negative]': 'negative',
                    '[attr.id]': 'id',
                    '[attr.required]': 'required',
                    '[attr.disabled]': 'disabled || null',
                    '[attr.aria-labelledby]': 'this._label?.id  || null',
                    '[attr.role]': '"group"',
                },
                styles: [":host ::ng-deep nx-error{margin-bottom:8px}:host ::ng-deep nx-label{margin-bottom:16px;display:block}:host.nx-checkbox-group--negative ::ng-deep nx-error,:host.nx-checkbox-group--negative ::ng-deep nx-icon.nx-error__icon,:host.nx-checkbox-group--negative ::ng-deep nx-label{color:#fff}"]
            }] }
];
/** @nocollapse */
NxCheckboxGroupComponent.ctorParameters = () => [
    { type: ChangeDetectorRef },
    { type: NgControl, decorators: [{ type: Optional }, { type: Self }] }
];
NxCheckboxGroupComponent.propDecorators = {
    _checkboxes: [{ type: ContentChildren, args: [forwardRef((/**
                 * @return {?}
                 */
                () => NxCheckboxComponent)), { descendants: true },] }],
    _label: [{ type: ContentChild, args: [forwardRef((/**
                 * @return {?}
                 */
                () => NxLabelComponent)), { static: false },] }],
    selectionChange: [{ type: Output }],
    id: [{ type: Input }],
    name: [{ type: Input }],
    disabled: [{ type: Input }],
    negative: [{ type: Input }],
    labelSize: [{ type: Input }],
    required: [{ type: Input }]
};
if (false) {
    /** @type {?} */
    NxCheckboxGroupComponent.prototype._checkboxes;
    /** @type {?} */
    NxCheckboxGroupComponent.prototype._label;
    /** @type {?} */
    NxCheckboxGroupComponent.prototype._stateChanges;
    /** @type {?} */
    NxCheckboxGroupComponent.prototype.selectionChange;
    /**
     * @type {?}
     * @private
     */
    NxCheckboxGroupComponent.prototype._id;
    /**
     * @type {?}
     * @private
     */
    NxCheckboxGroupComponent.prototype._name;
    /**
     * @type {?}
     * @private
     */
    NxCheckboxGroupComponent.prototype._disabled;
    /**
     * @type {?}
     * @private
     */
    NxCheckboxGroupComponent.prototype._negative;
    /**
     * @type {?}
     * @private
     */
    NxCheckboxGroupComponent.prototype._labelSize;
    /**
     * @type {?}
     * @private
     */
    NxCheckboxGroupComponent.prototype._required;
    /**
     * @type {?}
     * @private
     */
    NxCheckboxGroupComponent.prototype._value;
    /**
     * @type {?}
     * @private
     */
    NxCheckboxGroupComponent.prototype._onChange;
    /**
     * @type {?}
     * @private
     */
    NxCheckboxGroupComponent.prototype._onTouched;
    /**
     * @type {?}
     * @private
     */
    NxCheckboxGroupComponent.prototype._changeDetectorRef;
    /** @type {?} */
    NxCheckboxGroupComponent.prototype.ngControl;
}
class NxCheckboxComponent {
    /**
     * @param {?} _changeDetectorRef
     * @param {?} _errorStateMatcher
     * @param {?} checkboxGroup
     * @param {?} ngControl
     * @param {?} _parentForm
     * @param {?} _parentFormGroup
     */
    constructor(_changeDetectorRef, _errorStateMatcher, checkboxGroup, ngControl, _parentForm, _parentFormGroup) {
        this._changeDetectorRef = _changeDetectorRef;
        this._errorStateMatcher = _errorStateMatcher;
        this.checkboxGroup = checkboxGroup;
        this.ngControl = ngControl;
        this._parentForm = _parentForm;
        this._parentFormGroup = _parentFormGroup;
        this._id = (nextId++).toString();
        this._disabled = false;
        this._negative = false;
        this._labelSize = 'small';
        this._checked = false;
        this._name = null;
        this._indeterminate = false;
        /**
         * An event emitted when the indeterminate value has changed
         */
        this.indeterminateChange = new EventEmitter(false);
        /**
         * An event emitted when the checked value has changed.
         *
         * Emits the boolean checked value of the changed checkbox.
         */
        this.checkedChange = new EventEmitter(false);
        /**
         * An event emitted when the checked value has changed.
         *
         * Emits a NxCheckboxChangeEvent.
         */
        this.checkboxChange = new EventEmitter();
        this.onChangeCallback = (/**
         * @param {?} _
         * @return {?}
         */
        (_) => { });
        this.onTouchedCallback = (/**
         * @return {?}
         */
        () => { });
        if (this.ngControl) {
            // Note: we provide the value accessor through here, instead of
            // the `providers` to avoid running into a circular import.
            this.ngControl.valueAccessor = this;
        }
    }
    /**
     * Id of the checkbox.
     *
     * If not set, the checkbox gets an incremented value by default.
     * @param {?} value
     * @return {?}
     */
    set id(value) {
        if (value !== this._id) {
            this._id = value;
            this._changeDetectorRef.markForCheck();
        }
    }
    /**
     * @return {?}
     */
    get id() {
        return `nx-checkbox-${this._id}`;
    }
    /**
     * Name of the checkbox.
     * @param {?} name
     * @return {?}
     */
    set name(name) {
        this._name = name;
    }
    /**
     * @return {?}
     */
    get name() {
        return (this.checkboxGroup && this.checkboxGroup.name) ? this.checkboxGroup.name : this._name;
    }
    /**
     * Whether the checkbox is disabled.
     * @param {?} value
     * @return {?}
     */
    set disabled(value) {
        /** @type {?} */
        const newValue = coerceBooleanProperty(value);
        if (newValue !== this._disabled) {
            this._disabled = newValue;
            this._changeDetectorRef.markForCheck();
        }
    }
    /**
     * @return {?}
     */
    get disabled() {
        return (this.checkboxGroup && this.checkboxGroup.disabled) ? this.checkboxGroup.disabled : this._disabled;
    }
    /**
     * Sets the label size of the checkbox. Default value: small
     * @param {?} value
     * @return {?}
     */
    set labelSize(value) {
        this._labelSize = value;
        this._changeDetectorRef.markForCheck();
    }
    /**
     * @return {?}
     */
    get labelSize() {
        return (this.checkboxGroup && this.checkboxGroup.labelSize) ? this.checkboxGroup.labelSize : this._labelSize;
    }
    /**
     * Whether the checkbox has negative styling.
     * @param {?} value
     * @return {?}
     */
    set negative(value) {
        /** @type {?} */
        const newValue = coerceBooleanProperty(value);
        if (newValue !== this._negative) {
            this._negative = newValue;
            this._changeDetectorRef.markForCheck();
        }
    }
    /**
     * @return {?}
     */
    get negative() {
        return (this.checkboxGroup && this.checkboxGroup.negative) ? this.checkboxGroup.negative : this._negative;
    }
    /**
     * Whether the checkbox is checked.
     * @param {?} value
     * @return {?}
     */
    set checked(value) {
        /** @type {?} */
        const newValue = coerceBooleanProperty(value);
        if (newValue !== this._checked) {
            if (this._indeterminate) {
                this._setIndeterminate(false);
            }
            this._setChecked(newValue);
        }
    }
    /**
     * @return {?}
     */
    get checked() {
        return this._checked;
    }
    /**
     * Whether the checkbox is indeterminated.
     * @param {?} value
     * @return {?}
     */
    set indeterminate(value) {
        /** @type {?} */
        const newValue = coerceBooleanProperty(value);
        if (this._indeterminate !== newValue) {
            if (this._checked) {
                this._setChecked(false);
            }
            this._setIndeterminate(newValue);
        }
        this._changeDetectorRef.markForCheck();
    }
    /**
     * @return {?}
     */
    get indeterminate() {
        return this._indeterminate;
    }
    /**
     * Whether the checkbox is required.
     * @return {?}
     */
    get required() {
        return this._required;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set required(value) {
        this._required = coerceBooleanProperty(value);
    }
    /**
     * Sets the value of the checkbox. Default value is the checked status.
     * @return {?}
     */
    get value() {
        return this._value ? this._value : this.checked.toString();
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set value(value) {
        this._value = value;
        this._changeDetectorRef.markForCheck();
    }
    /**
     * \@docs-private
     * @return {?}
     */
    get labelHasContent() {
        return !!this._checkboxLabelWrapper.nativeElement.innerHTML.trim();
    }
    /**
     * \@docs-private
     * Callback for when the content of the label has changed.
     * @return {?}
     */
    labelContentChanged() {
        this._changeDetectorRef.detectChanges();
    }
    /**
     * \@docs-private
     * @return {?}
     */
    _controlInvalid() {
        /** @type {?} */
        const parent = this._parentFormGroup || this._parentForm;
        /** @type {?} */
        let control = null;
        if (this.checkboxGroup && this.checkboxGroup.ngControl) {
            control = this.checkboxGroup.ngControl;
        }
        else {
            control = this.ngControl ? (/** @type {?} */ (this.ngControl.control)) : null;
        }
        return this._errorStateMatcher.isErrorState(control, parent);
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        if (this.checkboxGroup) {
            this.name = this.checkboxGroup.name;
            // when relevant properties of the parent like name and disabled change
            // we need to let change detection know that the template needs an update
            this._parentChangeSubscription = this.checkboxGroup._stateChanges.subscribe((/**
             * @return {?}
             */
            () => {
                this._changeDetectorRef.markForCheck();
            }));
        }
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        if (this._parentChangeSubscription) {
            this._parentChangeSubscription.unsubscribe();
        }
    }
    /**
     * @private
     * @param {?} value
     * @return {?}
     */
    _setIndeterminate(value) {
        this._indeterminate = value;
        this.indeterminateChange.emit(this._indeterminate);
        this._changeDetectorRef.markForCheck();
    }
    /**
     * @private
     * @param {?} value
     * @return {?}
     */
    _setChecked(value) {
        this._checked = value;
        this._changeDetectorRef.markForCheck();
    }
    /**
     * Toggles the checked state of the checkbox.
     * @return {?}
     */
    toggle() {
        this.checked = !this.checked;
        this.onChangeCallback(this.checked);
        if (this.checkboxGroup !== null) {
            this.checkboxGroup.change(this);
        }
    }
    /**
     * @param {?} value
     * @return {?}
     */
    writeValue(value) {
        if (value === null) {
            value = false;
        }
        if (value !== this.checked) {
            this.checked = value;
        }
    }
    /**
     * @param {?} onChange
     * @return {?}
     */
    registerOnChange(onChange) {
        this.onChangeCallback = onChange;
    }
    /**
     * @param {?} onTouched
     * @return {?}
     */
    registerOnTouched(onTouched) {
        this.onTouchedCallback = onTouched;
    }
    /**
     * @param {?} isDisabled
     * @return {?}
     */
    setDisabledState(isDisabled) {
        this.disabled = isDisabled;
    }
    /**
     * \@docs-private
     * @return {?}
     */
    touch() {
        this.onTouchedCallback();
    }
    /**
     * \@docs-private
     * @param {?} event
     * @return {?}
     */
    _onInputClick(event) {
        // stop the propagation of the native click on the checkbox input so that a click is not triggered twice
        event.stopPropagation();
        if (!this.disabled) {
            this.toggle();
            this.checkedChange.emit(this._checked);
            this.checkboxChange.emit(this._createChangeEvent(this._checked));
        }
    }
    /**
     * \@docs-private
     * @private
     * @param {?} checkedValue
     * @return {?}
     */
    _createChangeEvent(checkedValue) {
        /** @type {?} */
        const event = new NxCheckboxChangeEvent(checkedValue, this.value, this);
        event.checked = checkedValue;
        event.value = this.value;
        event.checkbox = this;
        return event;
    }
}
NxCheckboxComponent.decorators = [
    { type: Component, args: [{
                selector: 'nx-checkbox',
                template: "<input\n  type=\"checkbox\"\n  [id]=\"id\"\n  [name]=\"name\"\n  [checked]=\"checked\"\n  [indeterminate]=\"indeterminate\" [disabled]=\"disabled\"\n  (blur)=\"touch()\"\n  [attr.aria-labelledby]=\"id + '-label'\"\n  (click)=\"_onInputClick($event)\"\n  class=\"nx-checkbox__input\"\n  [value]=\"value\"\n>\n\n<label [id]=\"id + '-label'\" [attr.for]=\"id\" class=\"nx-checkbox__label\" [class.has-label]=\"labelHasContent\">\n    <span class=\"nx-checkbox__control\">\n        <nx-icon *ngIf=\"checked\" name=\"check\" aria-hidden=\"true\"></nx-icon>\n        <div *ngIf=\"indeterminate\" class=\"nx-checkbox__indeterminate-indicator\"></div>\n    </span>\n    <div class=\"nx-checkbox__label-text\" #checkboxLabelWrapper (cdkObserveContent)=\"labelContentChanged()\">\n        <ng-content></ng-content>\n    </div>\n</label>\n",
                changeDetection: ChangeDetectionStrategy.OnPush,
                host: {
                    '[class.nx-checkbox]': 'true',
                    '[class.disabled]': 'disabled',
                    '[class.nx-checkbox--label-large]': 'labelSize === "large"',
                    '[class.nx-checkbox--label-small]': 'labelSize === "small"',
                    '[class.nx-checkbox--negative]': 'negative',
                    '[class.has-error]': '_controlInvalid() || null',
                    '[attr.required]': 'required',
                    '[attr.aria-invalid]': '_controlInvalid() || null',
                },
                styles: [":host{display:block;position:relative;margin-bottom:16px}:host.has-error .nx-checkbox__input:checked+.nx-checkbox__label .nx-checkbox__control{background-color:#dc3149;background-color:var(--danger,#dc3149);border-color:#dc3149;border-color:var(--danger,#dc3149)}:host.has-error .nx-checkbox__control{border-color:#dc3149;border-color:var(--danger,#dc3149)}:host.has-error .nx-checkbox__indeterminate-indicator{background-color:#dc3149;background-color:var(--danger,#dc3149)}.nx-checkbox__input{opacity:0;position:absolute}.nx-checkbox__label{font-size:16px;font-size:var(--checkbox-small-label-font-size,16px);line-height:24px;line-height:var(--checkbox-small-label-line-height,24px);font-weight:400;font-weight:var(--checkbox-small-label-font-weight,400);letter-spacing:0;letter-spacing:var(--checkbox-small-label-letter-spacing,0);color:#414141;color:var(--checkbox-label-color,#414141);cursor:pointer;display:flex}:host(.nx-checkbox--label-large) .nx-checkbox__label{font-size:20px;font-size:var(--checkbox-large-label-font-size,20px);line-height:28px;line-height:var(--checkbox-large-label-line-height,28px);font-weight:400;font-weight:var(--checkbox-large-label-font-weight,400);letter-spacing:.2px;letter-spacing:var(--checkbox-large-label-letter-spacing,.2px)}:host(.nx-checkbox--label-large) .has-label .nx-checkbox__label-text{margin-top:0;margin-top:var(--checkbox-large-label-text-margin-top,0)}:host(.nx-checkbox--label-large) .has-label .nx-checkbox__control{margin-top:2px;margin-top:var(--checkbox-large-label-control-margin-top,2px)}:host(.nx-checkbox--label-large) .nx-checkbox__label-text{margin-left:12px;margin-left:var(--checkbox-large-label-text-margin-left,12px)}:host(.nx-checkbox--label-small) .has-label .nx-checkbox__label-text{margin-top:0;margin-top:var(--checkbox-small-label-text-margin-top,0)}:host(.nx-checkbox--label-small) .has-label .nx-checkbox__control{margin-top:0;margin-top:var(--checkbox-small-label-control-margin-top,0)}.nx-checkbox__label-text{padding:0;margin-left:12px;margin-left:var(--checkbox-small-label-text-margin-left,12px)}.nx-checkbox__label-text:empty{display:none}.nx-checkbox__control{background-color:transparent;background-color:var(--checkbox-background-color,transparent);border-width:var(--checkbox-border-width,2px);border-color:var(--checkbox-border-color,#767676);border-radius:4px;border-radius:var(--checkbox-border-radius,4px);color:#fff;color:var(--checkbox-icon-color,#fff);font-size:20px;font-size:var(--checkbox-icon-size,20px);height:24px;height:var(--checkbox-control-size,24px);width:24px;width:var(--checkbox-control-size,24px);min-width:24px;min-width:var(--checkbox-control-size,24px);display:flex;justify-content:center;align-items:center;z-index:0;cursor:pointer;border:2px solid #767676}.nx-checkbox__indeterminate-indicator{color:#007ab3;color:var(--checkbox-indeterminate-color,#007ab3);box-sizing:content-box;height:0;width:8px;border:1px solid;border-radius:2px}.nx-checkbox__input:checked+.nx-checkbox__label .nx-checkbox__control{background-color:#007ab3;background-color:var(--checkbox-selected-background-color,#007ab3);border-color:#007ab3;border-color:var(--checkbox-selected-border-color,#007ab3)}.nx-checkbox__input:disabled+.nx-checkbox__label .nx-checkbox__control{background-color:#ececec;background-color:var(--checkbox-disabled-background-color,#ececec);border-color:#c2c2c2;border-color:var(--checkbox-disabled-border-color,#c2c2c2);color:#fff;color:var(--checkbox-disabled-icon-color,#fff);cursor:not-allowed}.nx-checkbox__input:checked:disabled+.nx-checkbox__label .nx-checkbox__control{background-color:#c2c2c2;background-color:var(--checkbox-disabled-selected-background-color,#c2c2c2)}.nx-checkbox__input:disabled+.nx-checkbox__label{cursor:not-allowed;color:#c2c2c2;color:var(--checkbox-label-disabled-color,#c2c2c2)}.nx-checkbox__input:disabled+.nx-checkbox__label .nx-checkbox__indeterminate-indicator{color:#c2c2c2;color:var(--checkbox-disabled-border-color,#c2c2c2)}:host(.nx-checkbox--negative) .nx-checkbox__control{border-color:#fff;background-color:transparent}:host(.nx-checkbox--negative) .nx-checkbox__label{color:#fff}:host(.nx-checkbox--negative) .nx-checkbox__input:checked+.nx-checkbox__label .nx-checkbox__control{color:#000;background-color:#fff;border-color:#fff}:host(.nx-checkbox--negative) .nx-checkbox__input:checked:disabled+.nx-checkbox__label .nx-checkbox__control{color:rgba(255,255,255,.4);border-color:transparent;background-color:rgba(194,194,194,.4)}:host(.nx-checkbox--negative) .nx-checkbox__input:disabled+.nx-checkbox__label{color:rgba(255,255,255,.4)}:host(.nx-checkbox--negative) .nx-checkbox__input:disabled+.nx-checkbox__label .nx-checkbox__control{background-color:rgba(153,153,153,.4);border-color:rgba(217,217,217,.4)}:host(.nx-checkbox--negative) .nx-checkbox__input:disabled+.nx-checkbox__label .nx-checkbox__indeterminate-indicator{background-color:rgba(217,217,217,.4)}:host:not(.nx-checkbox--negative):not(.has-error):hover .nx-checkbox__input:not([disabled]):checked+.nx-checkbox__label .nx-checkbox__control{background-color:#006192;background-color:var(--checkbox-hover-background-color,#006192)}:host:not(.nx-checkbox--negative):not(.has-error):hover .nx-checkbox__input:not([disabled]):checked+.nx-checkbox__label .nx-checkbox__indeterminate-indicator{background-color:#006192;background-color:var(--checkbox-hover-background-color,#006192)}:host:not(.nx-checkbox--negative):not(.has-error):hover .nx-checkbox__input:not([disabled])+.nx-checkbox__label .nx-checkbox__control{border-color:#006192;border-color:var(--checkbox-hover-border-color,#006192)}:host:not(.nx-checkbox--negative):active .nx-checkbox__input:not([disabled]):checked+.nx-checkbox__label .nx-checkbox__control{background-color:#003781;background-color:var(--checkbox-active-background-color,#003781)}:host:not(.nx-checkbox--negative):active .nx-checkbox__input:not([disabled]):checked+.nx-checkbox__label .nx-checkbox__indeterminate-indicator{background-color:#003781;background-color:var(--checkbox-active-background-color,#003781)}:host:not(.nx-checkbox--negative):active .nx-checkbox__input:not([disabled])+.nx-checkbox__label .nx-checkbox__control{border-color:#003781;border-color:var(--checkbox-active-border-color,#003781)}:host-context([data-whatinput=keyboard]) .nx-checkbox__input:focus+.nx-checkbox__label .nx-checkbox__control{box-shadow:0 0 0 2px #fff,0 0 0 6px #009de6;box-shadow:var(--focus-box-shadow,0 0 0 2px #fff,0 0 0 6px #009de6)}@media screen and (-ms-high-contrast:active){:host-context([data-whatinput=keyboard]) .nx-checkbox__input:focus+.nx-checkbox__label .nx-checkbox__control{box-shadow:0 0 0 2px background,0 0 0 6px windowText}.nx-checkbox__input+.nx-checkbox__label .nx-checkbox__control{border-color:buttonText;background-color:buttonFace}.nx-checkbox__input+.nx-checkbox__label .nx-checkbox__label-text{color:buttonText}.nx-checkbox__input:checked+.nx-checkbox__label .nx-checkbox__control{background-color:highlight;border-color:highlight}.nx-checkbox__input:checked+.nx-checkbox__label .nx-checkbox__control nx-icon{color:highlightText}.nx-checkbox__input:indeterminate+.nx-checkbox__label .nx-checkbox__indeterminate-indicator{color:buttonText}.nx-checkbox__input:disabled+.nx-checkbox__label .nx-checkbox__control nx-icon,.nx-checkbox__input:disabled+.nx-checkbox__label .nx-checkbox__label-text{color:GrayText}.nx-checkbox__input:disabled:indeterminate+.nx-checkbox__label .nx-checkbox__indeterminate-indicator{color:GrayText}.nx-checkbox__input:disabled+.nx-checkbox__label .nx-checkbox__control{border-color:GrayText}.nx-checkbox__input:disabled:checked+.nx-checkbox__label .nx-checkbox__control{background-color:buttonFace}.nx-checkbox__input:disabled:checked+.nx-checkbox__label .nx-checkbox__control nx-icon{color:GrayText}}"]
            }] }
];
/** @nocollapse */
NxCheckboxComponent.ctorParameters = () => [
    { type: ChangeDetectorRef },
    { type: ErrorStateMatcher },
    { type: NxCheckboxGroupComponent, decorators: [{ type: Optional }] },
    { type: NgControl, decorators: [{ type: Self }, { type: Optional }] },
    { type: NgForm, decorators: [{ type: Optional }] },
    { type: FormGroupDirective, decorators: [{ type: Optional }] }
];
NxCheckboxComponent.propDecorators = {
    _checkboxLabelWrapper: [{ type: ViewChild, args: ['checkboxLabelWrapper', { static: true },] }],
    id: [{ type: Input }],
    name: [{ type: Input }],
    disabled: [{ type: Input }],
    labelSize: [{ type: Input }],
    negative: [{ type: Input }],
    checked: [{ type: Input }],
    indeterminate: [{ type: Input }],
    required: [{ type: Input }],
    value: [{ type: Input }],
    indeterminateChange: [{ type: Output }],
    checkedChange: [{ type: Output }],
    checkboxChange: [{ type: Output }]
};
if (false) {
    /**
     * @type {?}
     * @private
     */
    NxCheckboxComponent.prototype._parentChangeSubscription;
    /**
     * @type {?}
     * @private
     */
    NxCheckboxComponent.prototype._id;
    /**
     * @type {?}
     * @private
     */
    NxCheckboxComponent.prototype._disabled;
    /**
     * @type {?}
     * @private
     */
    NxCheckboxComponent.prototype._negative;
    /**
     * @type {?}
     * @private
     */
    NxCheckboxComponent.prototype._labelSize;
    /**
     * @type {?}
     * @private
     */
    NxCheckboxComponent.prototype._checked;
    /**
     * @type {?}
     * @private
     */
    NxCheckboxComponent.prototype._name;
    /**
     * \@docs-private
     * @type {?}
     */
    NxCheckboxComponent.prototype._checkboxLabelWrapper;
    /**
     * @type {?}
     * @private
     */
    NxCheckboxComponent.prototype._indeterminate;
    /**
     * @type {?}
     * @private
     */
    NxCheckboxComponent.prototype._required;
    /**
     * @type {?}
     * @private
     */
    NxCheckboxComponent.prototype._value;
    /**
     * An event emitted when the indeterminate value has changed
     * @type {?}
     */
    NxCheckboxComponent.prototype.indeterminateChange;
    /**
     * An event emitted when the checked value has changed.
     *
     * Emits the boolean checked value of the changed checkbox.
     * @type {?}
     */
    NxCheckboxComponent.prototype.checkedChange;
    /**
     * An event emitted when the checked value has changed.
     *
     * Emits a NxCheckboxChangeEvent.
     * @type {?}
     */
    NxCheckboxComponent.prototype.checkboxChange;
    /**
     * @type {?}
     * @private
     */
    NxCheckboxComponent.prototype.onChangeCallback;
    /**
     * @type {?}
     * @private
     */
    NxCheckboxComponent.prototype.onTouchedCallback;
    /**
     * @type {?}
     * @private
     */
    NxCheckboxComponent.prototype._changeDetectorRef;
    /**
     * @type {?}
     * @private
     */
    NxCheckboxComponent.prototype._errorStateMatcher;
    /** @type {?} */
    NxCheckboxComponent.prototype.checkboxGroup;
    /** @type {?} */
    NxCheckboxComponent.prototype.ngControl;
    /**
     * @type {?}
     * @private
     */
    NxCheckboxComponent.prototype._parentForm;
    /**
     * @type {?}
     * @private
     */
    NxCheckboxComponent.prototype._parentFormGroup;
}

/**
 * @fileoverview added by tsickle
 * Generated from: checkbox/checkbox.module.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class NxCheckboxModule {
}
NxCheckboxModule.decorators = [
    { type: NgModule, args: [{
                declarations: [
                    NxCheckboxComponent,
                    NxCheckboxGroupComponent
                ],
                exports: [
                    NxCheckboxComponent,
                    NxCheckboxGroupComponent,
                    NxLabelModule,
                    NxErrorModule
                ],
                imports: [
                    CommonModule,
                    NxIconModule,
                    ObserversModule
                ]
            },] }
];

/**
 * @fileoverview added by tsickle
 * Generated from: checkbox/public-api.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * Generated from: radio-button/radio-button.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * The change event object emitted by the radio group and radio button.
 */
class NxRadioChange {
    /**
     * The NxRadioComponent that emits the change event. NxRadioChange object can be instantiated with source radio component and a value.
     * @param {?} source
     * @param {?} value
     */
    constructor(source, value) {
        this.source = source;
        this.value = value;
    }
}
if (false) {
    /** @type {?} */
    NxRadioChange.prototype.source;
    /** @type {?} */
    NxRadioChange.prototype.value;
}
/** @type {?} */
let nextId$1 = 0;
class NxRadioGroupComponent {
    /**
     * @param {?} _changeDetectorRef
     * @param {?} ngControl
     * @param {?} _parentForm
     * @param {?} _parentFormGroup
     */
    constructor(_changeDetectorRef, ngControl, _parentForm, _parentFormGroup) {
        this._changeDetectorRef = _changeDetectorRef;
        this.ngControl = ngControl;
        this._parentForm = _parentForm;
        this._parentFormGroup = _parentFormGroup;
        // emits when the internal state changes on properties which are relevant
        // for the radio buttons so that they can mark themself for check
        this._stateChanges = new Subject();
        this._id = `nx-radio-group-${nextId$1++}`;
        this._disabled = false;
        this._negative = false;
        this._required = false;
        /**
         * An event is dispatched on each group value change.
         */
        this.groupValueChange = new EventEmitter();
        this._name = `nx-radio-group-${nextId$1++}`;
        this._value = null;
        // The currently selected radio button; should match _value
        this._selected = null;
        this._onChange = (/**
         * @return {?}
         */
        () => { });
        this._onTouched = (/**
         * @return {?}
         */
        () => { });
        if (this.ngControl) {
            // Note: we provide the value accessor through here, instead of
            // the `providers` to avoid running into a circular import.
            this.ngControl.valueAccessor = this;
        }
    }
    /**
     * Sets the Id of the radio group.
     * @param {?} value
     * @return {?}
     */
    set id(value) {
        if (this._id !== value) {
            this._id = value;
            this._changeDetectorRef.markForCheck();
        }
    }
    /**
     * @return {?}
     */
    get id() {
        return this._id;
    }
    /**
     * Whether every radio button in this group should be disabled.
     * @param {?} value
     * @return {?}
     */
    set disabled(value) {
        this._disabled = coerceBooleanProperty(value);
        // inform childs about the change where CD should be triggered
        this._stateChanges.next();
    }
    /**
     * @return {?}
     */
    get disabled() {
        return this._disabled;
    }
    /**
     * Whether the radio group should have negative styling.
     * @param {?} value
     * @return {?}
     */
    set negative(value) {
        this._negative = coerceBooleanProperty(value);
        this._changeDetectorRef.markForCheck();
    }
    /**
     * @return {?}
     */
    get negative() {
        return this._negative;
    }
    /**
     * Sets if at least an option should be selected.
     * @param {?} value
     * @return {?}
     */
    set required(value) {
        this._required = coerceBooleanProperty(value);
        this._stateChanges.next();
    }
    /**
     * @return {?}
     */
    get required() {
        return this._required;
    }
    /**
     * @return {?}
     */
    get name() {
        return this._name;
    }
    // this is also the name attribute, which is mandatory in conjunction with ngModel, hence no nx prefix
    /**
     * Sets the name of this radio group, which is mandatory in conjunction with ngModel (Default: null).
     * @param {?} value
     * @return {?}
     */
    set name(value) {
        this._name = value;
        this._stateChanges.next();
    }
    /**
     * @return {?}
     */
    get value() { return this._value; }
    /**
     * Sets the value of the selected radion button in this group (Default: null).
     * @param {?} newValue
     * @return {?}
     */
    set value(newValue) {
        if (this._value !== newValue) {
            // Set this before proceeding to ensure no circular loop occurs with selection.
            this._value = newValue;
            this._updateSelectedRadioFromValue();
            this._checkSelectedRadioButton();
        }
    }
    /**
     * @return {?}
     */
    ngAfterContentInit() {
        this._updateSelectedRadioFromValue();
        this._checkSelectedRadioButton();
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this._stateChanges.complete();
    }
    /**
     * @param {?} value
     * @return {?}
     */
    writeValue(value) {
        this.value = value;
    }
    /**
     * @param {?} fn
     * @return {?}
     */
    registerOnChange(fn) {
        this._onChange = fn;
    }
    /**
     * @param {?} fn
     * @return {?}
     */
    registerOnTouched(fn) {
        this._onTouched = fn;
    }
    /**
     * \@docs-private this is meant to be called by the radio buttons in this group
     * @param {?} value
     * @return {?}
     */
    change(value) {
        this.value = value;
        this._onChange(value);
        this.groupValueChange.emit(new NxRadioChange(this._selected, this._value));
    }
    /**
     * \@docs-private this is meant to be called by the radio buttons in this group.
     * @return {?}
     */
    touch() {
        if (this._onTouched) {
            this._onTouched();
        }
    }
    /**
     * @param {?} isDisabled
     * @return {?}
     */
    setDisabledState(isDisabled) {
        this.disabled = isDisabled;
    }
    /**
     * @private
     * @return {?}
     */
    _updateSelectedRadioFromValue() {
        // If the value already matches the selected radio, do nothing.
        /** @type {?} */
        const isAlreadySelected = this._selected != null && this._selected.value === this._value;
        if (this._radios != null && !isAlreadySelected) {
            this._selected = null;
            this._radios.forEach((/**
             * @param {?} radio
             * @return {?}
             */
            radio => {
                radio.checked = this.value === radio.value;
                if (radio.checked) {
                    this._selected = radio;
                }
            }));
        }
    }
    /**
     * @private
     * @return {?}
     */
    _checkSelectedRadioButton() {
        if (this._selected && !this._selected.checked) {
            this._selected.checked = true;
        }
    }
}
NxRadioGroupComponent.decorators = [
    { type: Component, args: [{
                selector: 'nx-radio-group',
                template: "<div>\n  <div class=\"nx-radio-group__label\">\n    <ng-content select=\"nx-label\"></ng-content>\n  </div>\n  <div class=\"nx-radio-group__errors\">\n    <ng-content select=\"nx-error\"></ng-content>\n  </div>\n  <div class=\"nx-radio-group__controls\">\n    <ng-content></ng-content>\n  </div>\n</div>\n",
                changeDetection: ChangeDetectionStrategy.OnPush,
                host: {
                    'role': 'radiogroup',
                    '[attr.id]': 'id',
                    '[attr.required]': 'required',
                    '[class.nx-radio-group--negative]': 'negative',
                    '[attr.aria-labelledby]': 'this._label?.id  || null'
                },
                styles: [":host ::ng-deep nx-error{margin-bottom:8px}:host ::ng-deep nx-label{margin-bottom:16px;display:block}"]
            }] }
];
/** @nocollapse */
NxRadioGroupComponent.ctorParameters = () => [
    { type: ChangeDetectorRef },
    { type: NgControl, decorators: [{ type: Optional }, { type: Self }] },
    { type: NgForm, decorators: [{ type: Optional }] },
    { type: FormGroupDirective, decorators: [{ type: Optional }] }
];
NxRadioGroupComponent.propDecorators = {
    _label: [{ type: ContentChild, args: [forwardRef((/**
                 * @return {?}
                 */
                () => NxLabelComponent)), { static: false },] }],
    id: [{ type: Input, args: ['id',] }],
    disabled: [{ type: Input, args: ['nxDisabled',] }],
    negative: [{ type: Input }],
    required: [{ type: Input }],
    groupValueChange: [{ type: Output, args: ['nxGroupValueChange',] }],
    _radios: [{ type: ContentChildren, args: [forwardRef((/**
                 * @return {?}
                 */
                () => NxRadioComponent)), { descendants: true },] }],
    name: [{ type: Input }],
    value: [{ type: Input, args: ['nxValue',] }]
};
if (false) {
    /** @type {?} */
    NxRadioGroupComponent.prototype._label;
    /** @type {?} */
    NxRadioGroupComponent.prototype._stateChanges;
    /**
     * @type {?}
     * @private
     */
    NxRadioGroupComponent.prototype._id;
    /**
     * @type {?}
     * @private
     */
    NxRadioGroupComponent.prototype._disabled;
    /**
     * @type {?}
     * @private
     */
    NxRadioGroupComponent.prototype._negative;
    /**
     * @type {?}
     * @private
     */
    NxRadioGroupComponent.prototype._required;
    /**
     * An event is dispatched on each group value change.
     * @type {?}
     */
    NxRadioGroupComponent.prototype.groupValueChange;
    /**
     * @type {?}
     * @private
     */
    NxRadioGroupComponent.prototype._name;
    /**
     * @type {?}
     * @private
     */
    NxRadioGroupComponent.prototype._value;
    /**
     * @type {?}
     * @private
     */
    NxRadioGroupComponent.prototype._selected;
    /** @type {?} */
    NxRadioGroupComponent.prototype._radios;
    /**
     * @type {?}
     * @private
     */
    NxRadioGroupComponent.prototype._onChange;
    /**
     * @type {?}
     * @private
     */
    NxRadioGroupComponent.prototype._onTouched;
    /**
     * @type {?}
     * @private
     */
    NxRadioGroupComponent.prototype._changeDetectorRef;
    /** @type {?} */
    NxRadioGroupComponent.prototype.ngControl;
    /** @type {?} */
    NxRadioGroupComponent.prototype._parentForm;
    /** @type {?} */
    NxRadioGroupComponent.prototype._parentFormGroup;
}
class NxRadioComponent {
    /**
     * @param {?} radioGroup
     * @param {?} _changeDetectorRef
     */
    constructor(radioGroup, _changeDetectorRef) {
        this.radioGroup = radioGroup;
        this._changeDetectorRef = _changeDetectorRef;
        this._id = `nx-radio-${nextId$1++}`;
        this._name = null;
        this._labelSize = 'big';
        this._negative = false;
        /**
         * An event is dispatched on each value change.
         */
        this.valueChange = new EventEmitter();
        this._value = null;
        this._checked = false;
        this._disabled = false;
        this._required = false;
        this.onChangeCallback = (/**
         * @param {?} _
         * @return {?}
         */
        (_) => { });
        this.onTouchedCallback = (/**
         * @return {?}
         */
        () => { });
    }
    /**
     * Sets the id of the radio component.
     * @param {?} value
     * @return {?}
     */
    set id(value) {
        if (this._id !== value) {
            this._id = value;
            this._changeDetectorRef.markForCheck();
        }
    }
    /**
     * @return {?}
     */
    get id() {
        return this._id;
    }
    /**
     * \@docs-private
     * @return {?}
     */
    get inputId() {
        return `${this.id}-input`;
    }
    /**
     * \@docs-private
     * @return {?}
     */
    get labelId() {
        return `${this.id}-label`;
    }
    // this is also the name attribute, which is mandatory in conjunction with ngModel, hence no nx prefix
    /**
     * Sets the name of this radio component, which is mandatory in conjunction with ngModel (Default: null).
     * @param {?} value
     * @return {?}
     */
    set name(value) {
        if (this._name !== value) {
            this._name = value;
            this._changeDetectorRef.markForCheck();
        }
    }
    /**
     * @return {?}
     */
    get name() {
        return (this.radioGroup && this.radioGroup.name) ? this.radioGroup.name : this._name;
    }
    /**
     * Sets the label size of the radio button.
     * The default value is `big`.
     * @param {?} value
     * @return {?}
     */
    set labelSize(value) {
        if (this._labelSize !== value) {
            this._labelSize = value;
            this._changeDetectorRef.markForCheck();
        }
    }
    /**
     * @return {?}
     */
    get labelSize() {
        return this._labelSize;
    }
    /**
     * Whether the negative set of styles should be used.
     *
     * If the radio button is placed in a radio group, the negative value
     * is overwritten by the group's negative value.
     * @param {?} value
     * @return {?}
     */
    set negative(value) {
        /** @type {?} */
        const newValue = coerceBooleanProperty(value);
        if (this._negative !== newValue) {
            this._negative = newValue;
            this._changeDetectorRef.markForCheck();
        }
    }
    /**
     * @return {?}
     */
    get negative() {
        return this.radioGroup ? this.radioGroup.negative : this._negative;
    }
    /**
     * @return {?}
     */
    get value() {
        return this._value;
    }
    /**
     * \@docs-private
     * @return {?}
     */
    get labelHasContent() {
        return !!this._radioLabelWrapper.nativeElement.innerHTML.trim();
    }
    /**
     * \@docs-private
     * Callback for when the content of the label has changed.
     * @return {?}
     */
    labelContentChanged() {
        this._changeDetectorRef.detectChanges();
    }
    /**
     * Sets the value of the form control element (Default: null).
     * @param {?} value
     * @return {?}
     */
    set value(value) {
        if (value !== this._value) {
            this._value = value;
            this.onChangeCallback(value);
        }
    }
    /**
     * \@docs-private
     * @return {?}
     */
    get checked() {
        return this._checked;
    }
    /**
     * Whether the radio component is selected.
     * @param {?} value
     * @return {?}
     */
    set checked(value) {
        if (this._checked !== value) {
            this._checked = value;
            this._changeDetectorRef.markForCheck();
        }
    }
    /**
     * \@docs-private
     * @return {?}
     */
    get disabled() {
        return this._disabled || (this.radioGroup && this.radioGroup.disabled);
    }
    /**
     * Whether the radio button should be disabled or not.
     * @param {?} value
     * @return {?}
     */
    set disabled(value) {
        this._disabled = coerceBooleanProperty(value);
        this._changeDetectorRef.markForCheck();
    }
    /**
     * \@docs-private
     * @return {?}
     */
    get required() {
        return this._required || (this.radioGroup && this.radioGroup.required);
    }
    /**
     * Sets if at least a radio button should be selected.
     * @param {?} value
     * @return {?}
     */
    set required(value) {
        this._required = value;
        // needed when the outer component is set to onPush because it is a native property
        // on the host element
        this._changeDetectorRef.markForCheck();
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        if (this.radioGroup) {
            this.name = this.radioGroup.name;
            // when relevant properties of the parent like name and disabled change
            // we need to let change detection know that the template needs an update
            this._parentChangeSubscription = this.radioGroup._stateChanges.subscribe((/**
             * @return {?}
             */
            () => {
                this._changeDetectorRef.markForCheck();
            }));
            if (this.radioGroup.value === this._value) {
                this._checked = true;
            }
        }
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        if (this._parentChangeSubscription) {
            this._parentChangeSubscription.unsubscribe();
        }
    }
    /**
     * @param {?} value
     * @return {?}
     */
    writeValue(value) {
        if (value === this._value) {
            this._checked = true;
            this._changeDetectorRef.markForCheck();
        }
    }
    /**
     * @param {?} onChange
     * @return {?}
     */
    registerOnChange(onChange) {
        this.onChangeCallback = onChange;
    }
    /**
     * @param {?} onTouched
     * @return {?}
     */
    registerOnTouched(onTouched) {
        this.onTouchedCallback = onTouched;
    }
    /**
     * \@docs-private
     * @return {?}
     */
    touch() {
        this.onTouchedCallback();
        if (this.radioGroup) {
            this.radioGroup.touch();
        }
    }
    /**
     * @param {?} event
     * @return {?}
     */
    _onInputChange(event) {
        event.stopPropagation();
        this._checked = true;
        this.valueChange.emit(new NxRadioChange(this, this._value));
        this.onChangeCallback(this.value);
        if (this.radioGroup && this.value !== this.radioGroup.value) {
            this.radioGroup.change(this.value);
        }
    }
    /**
     * @param {?} event
     * @return {?}
     */
    _onInputClick(event) {
        // make sure click event propagation on the visually hidden input
        // are stopped to prevent multiple events bubbling up.
        event.stopPropagation();
    }
    /**
     * \@docs-private
     * @return {?}
     */
    _controlInvalid() {
        /** @type {?} */
        const form = this.radioGroup && (this.radioGroup._parentFormGroup || this.radioGroup._parentForm);
        return !!(this.radioGroup && this.radioGroup.ngControl && this.radioGroup.ngControl.invalid
            && (this.radioGroup.ngControl.touched || (form && form.submitted)));
    }
}
NxRadioComponent.decorators = [
    { type: Component, args: [{
                selector: 'nx-radio',
                template: "<input\n  type=\"radio\"\n  [id]=\"inputId\"\n  [attr.name]=\"name\"\n  [disabled]=\"disabled\"\n  (blur)=\"touch()\"\n  (change)=\"_onInputChange($event)\"\n  (click)=\"_onInputClick($event)\"\n  [checked]=\"checked\"\n  [attr.aria-labelledby]=\"labelId\"\n  class=\"nx-radio__input\">\n<label [id]=\"labelId\" [attr.for]=\"inputId\" class=\"nx-radio__label\" [class.has-label]=\"labelHasContent\">\n    <div class=\"nx-radio__circle\">\n      <div *ngIf=\"checked\" class=\"nx-radio__dot\"></div>\n    </div>\n    <span class=\"nx-radio__label--text\" #radioLabelWrapper (cdkObserveContent)=\"labelContentChanged()\">\n      <ng-content></ng-content>\n    </span>\n</label>\n",
                changeDetection: ChangeDetectionStrategy.OnPush,
                providers: [
                    {
                        provide: NG_VALUE_ACCESSOR,
                        useExisting: forwardRef((/**
                         * @return {?}
                         */
                        () => NxRadioComponent)),
                        multi: true
                    }
                ],
                host: {
                    '[attr.required]': 'required',
                    '[class.nx-radio-button--small-label]': 'labelSize === "small"',
                    '[class.nx-radio-button--big-label]': 'labelSize === "big"',
                    '[class.nx-radio--negative]': 'negative',
                    '[class.has-error]': '_controlInvalid() || null',
                    '[attr.aria-invalid]': '_controlInvalid() || null',
                },
                styles: [":host{display:block;position:relative}.nx-radio__input{opacity:0;position:absolute}:host(.nx-radio-button--small-label) .nx-radio__label{font-size:16px;font-size:var(--radio-button-small-label-font-size,16px);line-height:24px;line-height:var(--radio-button-small-label-line-height,24px);font-weight:400;font-weight:var(--radio-button-small-label-font-weight,400);letter-spacing:0;letter-spacing:var(--radio-button-small-label-letter-spacing,0)}:host(.nx-radio-button--small-label) .nx-radio__label.has-label .nx-radio__circle{margin-top:0;margin-top:var(--radio-button-small-circle-margin-top,0)}:host(.nx-radio-button--small-label) .nx-radio__label--text:not(:empty){margin-left:12px;margin-left:var(--radio-button-small-label-margin-left,12px);margin-top:0;margin-top:var(--radio-button-small-label-margin-top,0)}:host(.nx-radio-button--big-label) .nx-radio__label{font-size:20px;font-size:var(--radio-button-large-label-font-size,20px);line-height:28px;line-height:var(--radio-button-large-label-line-height,28px);font-weight:400;font-weight:var(--radio-button-large-label-font-weight,400);letter-spacing:.2px;letter-spacing:var(--radio-button-large-label-letter-spacing,.2px)}:host(.nx-radio-button--big-label) .nx-radio__label.has-label .nx-radio__circle{margin-top:2px;margin-top:var(--radio-button-large-circle-margin-top,2px)}:host(.nx-radio-button--big-label) .nx-radio__label--text:not(:empty){margin-left:12px;margin-left:var(--radio-button-large-label-margin-left,12px);margin-top:0;margin-top:var(--radio-button-large-label-margin-top,0)}:host.nx-radio--negative .nx-radio__label--text{color:#fff}:host.nx-radio--negative .nx-radio__circle{border-color:#fff}:host.nx-radio--negative .nx-radio__input:checked+.nx-radio__label .nx-radio__circle{border-color:#fff;background-color:transparent}:host.nx-radio--negative .nx-radio__input:checked+.nx-radio__label .nx-radio__dot{background:#fff}:host.nx-radio--negative .nx-radio__input:disabled+.nx-radio__label{opacity:.4}.nx-radio__label{color:#414141;color:var(--radio-button-label-color,#414141);cursor:pointer;display:flex;position:relative}.nx-radio__circle{border-color:var(--radio-button-circle-color,#767676);border-radius:50%;width:24px;min-width:24px;height:24px;position:relative;display:flex;justify-content:center;align-items:center;border:2px solid #767676}.nx-radio__dot{width:8px;width:var(--radio-button-dot-size,8px);height:8px;height:var(--radio-button-dot-size,8px);background-color:transparent;background-color:var(--radio-button-dot-background-color,transparent);border-radius:50%;transition:background-color .2s}.nx-radio__input:checked+.nx-radio__label .nx-radio__circle{border-color:#007ab3;border-color:var(--radio-button-selected-circle-color,#007ab3);background-color:transparent;background-color:var(--radio-button-selected-background-color,transparent)}.nx-radio__input:checked+.nx-radio__label .nx-radio__dot{background-color:#007ab3;background-color:var(--radio-button-selected-dot-color,#007ab3)}.nx-radio__input:disabled+.nx-radio__label{cursor:not-allowed;color:#c2c2c2;color:var(--radio-button-disabled-text-color,#c2c2c2)}.nx-radio__input:disabled+.nx-radio__label .nx-radio__circle{border-color:#c2c2c2;border-color:var(--radio-button-disabled-border-color,#c2c2c2)}.nx-radio__input:checked:disabled+.nx-radio__label .nx-radio__circle{background-color:transparent;background-color:var(--radio-button-disabled-selected-background-color,transparent)}.nx-radio__input:checked:disabled+.nx-radio__label .nx-radio__dot{background-color:#c2c2c2;background-color:var(--radio-button-disabled-selected-dot-color,#c2c2c2)}:host.has-error .nx-radio__input+.nx-radio__label .nx-radio__circle{border-color:#dc3149;border-color:var(--danger,#dc3149)}:host.has-error .nx-radio__input+.nx-radio__label .nx-radio__dot{background-color:#dc3149;background-color:var(--danger,#dc3149)}:host-context([data-whatinput=keyboard]) .nx-radio__input:focus+.nx-radio__label .nx-radio__circle{box-shadow:0 0 0 2px #fff,0 0 0 6px #009de6;box-shadow:var(--focus-box-shadow,0 0 0 2px #fff,0 0 0 6px #009de6)}:host:not(.nx-radio--negative):not(.has-error) .nx-radio__input:not(:disabled)+.nx-radio__label:hover .nx-radio__circle{border-color:#006192;border-color:var(--radio-button-hover-circle-color,#006192)}:host:not(.nx-radio--negative):not(.has-error) .nx-radio__input:not(:disabled):checked+.nx-radio__label:hover .nx-radio__dot{background-color:#006192;background-color:var(--radio-button-hover-dot-color,#006192)}:host:not(.nx-radio--negative):not(.has-error) .nx-radio__input:not(:disabled)+.nx-radio__label:active .nx-radio__circle{border-color:#006192;border-color:var(--radio-button-hover-circle-color,#006192)}:host:not(.nx-radio--negative):not(.has-error) .nx-radio__input:not(:disabled):checked+.nx-radio__label:active .nx-radio__dot{background-color:#006192;background-color:var(--radio-button-hover-dot-color,#006192)}@media screen and (-ms-high-contrast:active){:host-context([data-whatinput=keyboard]) .nx-radio__input:focus+.nx-radio__label .nx-radio__circle{box-shadow:0 0 0 2px background,0 0 0 6px windowText}.nx-radio__label{color:buttonText}.nx-radio__circle{border-color:buttonText;background-color:buttonFace}.nx-radio__input:checked+.nx-radio__label .nx-radio__circle{border-color:highlight}.nx-radio__input:checked+.nx-radio__label .nx-radio__dot{background-color:highlight}.nx-radio__input:disabled+.nx-radio__label{color:GrayText}.nx-radio__input:disabled+.nx-radio__label .nx-radio__circle{border-color:GrayText}.nx-radio__input:checked:disabled+.nx-radio__label .nx-radio__dot{background-color:GrayText}}"]
            }] }
];
/** @nocollapse */
NxRadioComponent.ctorParameters = () => [
    { type: NxRadioGroupComponent, decorators: [{ type: Optional }] },
    { type: ChangeDetectorRef }
];
NxRadioComponent.propDecorators = {
    _radioLabelWrapper: [{ type: ViewChild, args: ['radioLabelWrapper', { static: true },] }],
    id: [{ type: Input, args: ['id',] }],
    name: [{ type: Input, args: ['name',] }],
    labelSize: [{ type: Input }],
    negative: [{ type: Input }],
    valueChange: [{ type: Output, args: ['nxValueChange',] }],
    value: [{ type: Input, args: ['nxValue',] }],
    checked: [{ type: Input, args: ['nxChecked',] }],
    disabled: [{ type: Input, args: ['nxDisabled',] }],
    required: [{ type: Input }]
};
if (false) {
    /**
     * \@docs-private
     * @type {?}
     */
    NxRadioComponent.prototype._radioLabelWrapper;
    /**
     * @type {?}
     * @private
     */
    NxRadioComponent.prototype._parentChangeSubscription;
    /**
     * @type {?}
     * @private
     */
    NxRadioComponent.prototype._id;
    /**
     * @type {?}
     * @private
     */
    NxRadioComponent.prototype._name;
    /**
     * @type {?}
     * @private
     */
    NxRadioComponent.prototype._labelSize;
    /**
     * @type {?}
     * @private
     */
    NxRadioComponent.prototype._negative;
    /**
     * An event is dispatched on each value change.
     * @type {?}
     */
    NxRadioComponent.prototype.valueChange;
    /**
     * @type {?}
     * @private
     */
    NxRadioComponent.prototype._value;
    /**
     * @type {?}
     * @private
     */
    NxRadioComponent.prototype._checked;
    /**
     * @type {?}
     * @private
     */
    NxRadioComponent.prototype._disabled;
    /**
     * @type {?}
     * @private
     */
    NxRadioComponent.prototype._required;
    /**
     * @type {?}
     * @private
     */
    NxRadioComponent.prototype.onChangeCallback;
    /**
     * @type {?}
     * @private
     */
    NxRadioComponent.prototype.onTouchedCallback;
    /** @type {?} */
    NxRadioComponent.prototype.radioGroup;
    /**
     * @type {?}
     * @private
     */
    NxRadioComponent.prototype._changeDetectorRef;
}

/**
 * @fileoverview added by tsickle
 * Generated from: radio-button/radio-button.module.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class NxRadioModule {
}
NxRadioModule.decorators = [
    { type: NgModule, args: [{
                declarations: [
                    NxRadioComponent,
                    NxRadioGroupComponent
                ],
                exports: [
                    NxRadioComponent,
                    NxRadioGroupComponent,
                    NxErrorModule,
                    NxLabelModule
                ],
                imports: [
                    CommonModule,
                    NxIconModule,
                    ObserversModule
                ]
            },] }
];

/**
 * @fileoverview added by tsickle
 * Generated from: radio-button/public-api.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * Generated from: copytext/copytext.component.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const DEFAULT_TYPE$1 = 'normal';
class NxCopytextComponent {
    constructor() {
        /**
         * \@docs-private
         */
        this.type = DEFAULT_TYPE$1;
        /**
         * \@docs-private
         */
        this.negative = false;
    }
    /**
     * Sets the type and whether the negative set of styling should be used.
     *
     * You can combine the values of type NxCopytextType and 'negative'.
     *
     * Default type: 'normal'
     * @param {?} value
     * @return {?}
     */
    set classNames(value) {
        if (this._classNames === value) {
            return;
        }
        this._classNames = value;
        const [type = null] = this._classNames.match(/small|medium|normal|large/) || [DEFAULT_TYPE$1];
        this.type = (/** @type {?} */ (type));
        this.negative = !!this._classNames.match(/negative/);
    }
    /**
     * @return {?}
     */
    get classNames() {
        return this._classNames;
    }
}
NxCopytextComponent.decorators = [
    { type: Component, args: [{
                // tslint:disable-next-line:component-selector
                selector: 'p[nxCopytext]',
                template: `<ng-content></ng-content>`,
                changeDetection: ChangeDetectionStrategy.OnPush,
                host: {
                    '[class.nx-copy]': 'true',
                    '[class.nx-copy--small]': 'type === "small"',
                    '[class.nx-copy--medium]': 'type === "medium"',
                    '[class.nx-copy--normal]': 'type === "normal"',
                    '[class.nx-copy--large]': 'type === "large"',
                    '[class.nx-copy--negative]': 'negative',
                },
                styles: [":host{margin:0 0 32px;font-size:16px;font-size:var(--paragraph-03-font-size,16px);line-height:24px;line-height:var(--paragraph-03-line-height,24px);font-weight:400;font-weight:var(--paragraph-03-font-weight,400);letter-spacing:0;letter-spacing:var(--paragraph-03-letter-spacing,0)}:host.nx-copy.nx-copy{font-weight:400}:host(.nx-copy--negative){color:#fff}:host(.nx-copy--small){font-size:12px;font-size:var(--paragraph-05-font-size,12px);line-height:16px;line-height:var(--paragraph-05-line-height,16px);font-weight:600;font-weight:var(--paragraph-05-font-weight,600);letter-spacing:.5px;letter-spacing:var(--paragraph-05-letter-spacing,.5px)}:host(.nx-copy--medium){font-size:14px;font-size:var(--paragraph-04-font-size,14px);line-height:20px;line-height:var(--paragraph-04-line-height,20px);font-weight:600;font-weight:var(--paragraph-04-font-weight,600);letter-spacing:.2px;letter-spacing:var(--paragraph-04-letter-spacing,.2px)}:host(.nx-copy--large){font-size:18px;font-size:var(--paragraph-02-font-size,18px);line-height:24px;line-height:var(--paragraph-02-line-height,24px);font-weight:400;font-weight:var(--paragraph-02-font-weight,400);letter-spacing:.2px;letter-spacing:var(--paragraph-02-letter-spacing,.2px)}"]
            }] }
];
NxCopytextComponent.propDecorators = {
    classNames: [{ type: Input, args: ['nxCopytext',] }]
};
if (false) {
    /**
     * @type {?}
     * @private
     */
    NxCopytextComponent.prototype._classNames;
    /**
     * \@docs-private
     * @type {?}
     */
    NxCopytextComponent.prototype.type;
    /**
     * \@docs-private
     * @type {?}
     */
    NxCopytextComponent.prototype.negative;
}

/**
 * @fileoverview added by tsickle
 * Generated from: copytext/copytext.module.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class NxCopytextModule {
}
NxCopytextModule.decorators = [
    { type: NgModule, args: [{
                declarations: [NxCopytextComponent],
                exports: [NxCopytextComponent]
            },] }
];

/**
 * @fileoverview added by tsickle
 * Generated from: copytext/public-api.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * Generated from: headline/headline.component.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const DEFAULT_TYPE$2 = 'section';
class NxHeadlineComponent {
    constructor() {
        /**
         * \@docs-private
         */
        this.type = DEFAULT_TYPE$2;
        /**
         * \@docs-private
         */
        this.negative = false;
    }
    /**
     * Changes the type of the headline which affects the visual appearance.
     * You can combine a HeadlineType and 'negative'.
     * @param {?} value
     * @return {?}
     */
    set classNames(value) {
        if (this._classNames === value) {
            return;
        }
        this._classNames = value;
        /** @type {?} */
        const typeRegex = /page-bold-caps|page|section|subsection-large|subsection-medium|subsection-small|subsection-xsmall/;
        const [type = null] = this._classNames.match(typeRegex) || [DEFAULT_TYPE$2];
        this.type = (/** @type {?} */ (type));
        this.negative = !!this._classNames.match(/negative/);
    }
    /**
     * @return {?}
     */
    get classNames() {
        return this._classNames;
    }
}
NxHeadlineComponent.decorators = [
    { type: Component, args: [{
                // tslint:disable-next-line:component-selector
                selector: '[nxHeadline]',
                template: `<ng-content></ng-content>`,
                host: {
                    '[class.nx-heading--page]': 'type === "page"',
                    '[class.nx-heading--page-bold-caps]': 'type === "page-bold-caps"',
                    '[class.nx-heading--section]': 'type === "section"',
                    '[class.nx-heading--subsection-large]': 'type === "subsection-large"',
                    '[class.nx-heading--subsection-medium]': 'type === "subsection-medium"',
                    '[class.nx-heading--subsection-small]': 'type === "subsection-small"',
                    '[class.nx-heading--subsection-xsmall]': 'type === "subsection-xsmall"',
                    '[class.nx-heading--negative]': 'negative',
                },
                styles: [":host{margin:0}:host ::ng-deep .nx-link,:host ::ng-deep nx-link a,:host a{color:#006192;color:var(--link-color,#006192);font-size:inherit;font-weight:600;line-height:inherit;letter-spacing:inherit;text-decoration:none}:host(.nx-heading--page){font-size:54px;font-size:var(--heading-01-font-size,54px);line-height:60px;line-height:var(--heading-01-line-height,60px);font-weight:300;font-weight:var(--heading-01-font-weight,300);letter-spacing:.3px;letter-spacing:var(--heading-01-letter-spacing,.3px);margin-bottom:40px}@media (max-width:703px){:host(.nx-heading--page){font-size:40px;font-size:var(--heading-01-mobile-font-size,40px);line-height:48px;line-height:var(--heading-01-mobile-line-height,48px);font-weight:300;font-weight:var(--heading-01-mobile-font-weight,300);letter-spacing:.3px;letter-spacing:var(--heading-01-mobile-letter-spacing,.3px)}}:host(.nx-heading--section){font-size:40px;font-size:var(--heading-02-font-size,40px);line-height:48px;line-height:var(--heading-02-line-height,48px);font-weight:300;font-weight:var(--heading-02-font-weight,300);letter-spacing:.3px;letter-spacing:var(--heading-02-letter-spacing,.3px);margin-bottom:48px}@media (max-width:703px){:host(.nx-heading--section){font-size:35px;font-size:var(--heading-02-mobile-font-size,35px);line-height:40px;line-height:var(--heading-02-mobile-line-height,40px);font-weight:300;font-weight:var(--heading-02-mobile-font-weight,300);letter-spacing:.3px;letter-spacing:var(--heading-02-mobile-letter-spacing,.3px)}}:host(.nx-heading--subsection-large){font-size:30px;font-size:var(--heading-03-font-size,30px);line-height:36px;line-height:var(--heading-03-line-height,36px);font-weight:300;font-weight:var(--heading-03-font-weight,300);letter-spacing:.3px;letter-spacing:var(--heading-03-letter-spacing,.3px);margin-bottom:32px}@media (max-width:703px){:host(.nx-heading--subsection-large){font-size:26px;font-size:var(--heading-03-mobile-font-size,26px);line-height:32px;line-height:var(--heading-03-mobile-line-height,32px);font-weight:300;font-weight:var(--heading-03-mobile-font-weight,300);letter-spacing:.3px;letter-spacing:var(--heading-03-mobile-letter-spacing,.3px)}}:host(.nx-heading--subsection-medium){font-size:26px;font-size:var(--heading-04-font-size,26px);line-height:32px;line-height:var(--heading-04-line-height,32px);font-weight:300;font-weight:var(--heading-04-font-weight,300);letter-spacing:.3px;letter-spacing:var(--heading-04-letter-spacing,.3px);margin-bottom:40px}@media (max-width:703px){:host(.nx-heading--subsection-medium){font-size:24px;font-size:var(--heading-04-mobile-font-size,24px);line-height:32px;line-height:var(--heading-04-mobile-line-height,32px);font-weight:600;font-weight:var(--heading-04-mobile-font-weight,600);letter-spacing:.2px;letter-spacing:var(--heading-04-mobile-letter-spacing,.2px)}}:host(.nx-heading--subsection-small){font-size:24px;font-size:var(--heading-05-font-size,24px);line-height:32px;line-height:var(--heading-05-line-height,32px);font-weight:600;font-weight:var(--heading-05-font-weight,600);letter-spacing:.2px;letter-spacing:var(--heading-05-letter-spacing,.2px);margin-bottom:32px}@media (max-width:703px){:host(.nx-heading--subsection-small){font-size:20px;font-size:var(--heading-05-mobile-font-size,20px);line-height:28px;line-height:var(--heading-05-mobile-line-height,28px);font-weight:300;font-weight:var(--heading-05-mobile-font-weight,300);letter-spacing:.2px;letter-spacing:var(--heading-05-mobile-letter-spacing,.2px)}}:host(.nx-heading--subsection-xsmall){font-size:20px;font-size:var(--heading-06-font-size,20px);line-height:28px;line-height:var(--heading-06-line-height,28px);font-weight:300;font-weight:var(--heading-06-font-weight,300);letter-spacing:.2px;letter-spacing:var(--heading-06-letter-spacing,.2px);margin-bottom:24px}@media (max-width:703px){:host(.nx-heading--subsection-xsmall){font-size:18px;font-size:var(--heading-06-mobile-font-size,18px);line-height:28px;line-height:var(--heading-06-mobile-line-height,28px);font-weight:300;font-weight:var(--heading-06-mobile-font-weight,300);letter-spacing:.2px;letter-spacing:var(--heading-06-mobile-letter-spacing,.2px)}}:host(.nx-heading--negative){color:#fff}:host(.nx-heading--negative) ::ng-deep a{color:#fff}:host(.nx-heading--page-bold-caps){font-size:54px;font-size:var(--heading-01-font-size,54px);line-height:60px;line-height:var(--heading-01-line-height,60px);font-weight:var(--heading-01-font-weight,300);letter-spacing:.3px;letter-spacing:var(--heading-01-letter-spacing,.3px);font-weight:700;text-transform:uppercase;margin-bottom:8px}@media (max-width:703px){:host(.nx-heading--page-bold-caps){font-size:40px;font-size:var(--heading-01-mobile-font-size,40px);line-height:48px;line-height:var(--heading-01-mobile-line-height,48px);font-weight:var(--heading-01-mobile-font-weight,300);letter-spacing:.3px;letter-spacing:var(--heading-01-mobile-letter-spacing,.3px);font-weight:700;text-transform:uppercase}}"]
            }] }
];
NxHeadlineComponent.propDecorators = {
    classNames: [{ type: Input, args: ['nxHeadline',] }]
};
if (false) {
    /**
     * @type {?}
     * @private
     */
    NxHeadlineComponent.prototype._classNames;
    /**
     * \@docs-private
     * @type {?}
     */
    NxHeadlineComponent.prototype.type;
    /**
     * \@docs-private
     * @type {?}
     */
    NxHeadlineComponent.prototype.negative;
}

/**
 * @fileoverview added by tsickle
 * Generated from: headline/headline.module.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class NxHeadlineModule {
}
NxHeadlineModule.decorators = [
    { type: NgModule, args: [{
                declarations: [NxHeadlineComponent],
                exports: [NxHeadlineComponent]
            },] }
];

/**
 * @fileoverview added by tsickle
 * Generated from: headline/public-api.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * Generated from: link/link.component.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const MAPPING = {
    'black': 'nx-link--black',
    'negative': 'nx-link--negative',
    'text': 'nx-link--text',
    'block': 'nx-link--block',
    'icon-right': 'nx-link--icon-right'
};
/** @type {?} */
const DEFAULT_CLASSES = ['nx-link'];
class NxLinkComponent extends MappedStyles$1 {
    /**
     * @param {?} _elementRef
     * @param {?} _renderer
     * @param {?} _changeDetectorRef
     */
    constructor(_elementRef, _renderer, _changeDetectorRef) {
        super(MAPPING, DEFAULT_CLASSES, _elementRef, _renderer);
        this._renderer = _renderer;
        this._changeDetectorRef = _changeDetectorRef;
        this._size = 'small';
    }
    /**
     * Sets the size of the link. Default: 'small'.
     * @param {?} value
     * @return {?}
     */
    set size(value) {
        if (this._size !== value) {
            this._size = value;
            this._changeDetectorRef.markForCheck();
        }
    }
    /**
     * @return {?}
     */
    get size() {
        return this._size;
    }
    /**
     * @return {?}
     */
    ngAfterContentInit() {
        // Add a specific link class that the css gets more specific than the nx-icon css
        /** @type {?} */
        const icons = this.elementRef.nativeElement.querySelectorAll('nx-icon');
        for (let i = 0; i < icons.length; i++) {
            this._renderer.addClass(icons[i], 'nx-link__icon');
        }
    }
    /**
     * \@docs-private
     * getter used for the modal component as a quickfix
     * since button got changed from directive to component the reference used by the ngOpenModelOnClick directive
     * for nxButtons is a reference to component instance instead of an element reference. As a workaround we need a
     * way to reach the elementRef of the component until the modal gets refactored.
     * @return {?}
     */
    get elementRef() {
        return this._elementRef;
    }
}
NxLinkComponent.decorators = [
    { type: Component, args: [{
                selector: 'nx-link',
                changeDetection: ChangeDetectionStrategy.OnPush,
                template: '<ng-content></ng-content>',
                inputs: ['classNames: nxStyle'],
                host: {
                    '[class.nx-link--small]': 'this.size === "small"',
                    '[class.nx-link--large]': 'this.size === "large"'
                },
                styles: [":host{color:#006192;color:var(--link-color,#006192);display:inline-block;cursor:pointer;position:relative;text-decoration:none;transition:color .2s,box-shadow .2s;-webkit-hyphens:none;-ms-hyphens:none;hyphens:none}:host:hover{color:#008ed6;color:var(--link-hover-color,#008ed6)}:host::ng-deep a:active{color:#003781;color:var(--link-active-color,#003781)}:host::ng-deep a{display:flex;align-items:center}:host.nx-link--small{font-size:16px;font-size:var(--link-small-font-size,16px);line-height:24px;line-height:var(--link-small-line-height,24px);font-weight:600;font-weight:var(--link-small-font-weight,600);letter-spacing:1px;letter-spacing:var(--link-small-letter-spacing,1px)}:host.nx-link--large{font-size:30px;font-size:var(--link-large-font-size,30px);line-height:36px;line-height:var(--link-large-line-height,36px);font-weight:600;font-weight:var(--link-large-font-weight,600);letter-spacing:.3px;letter-spacing:var(--link-large-letter-spacing,.3px)}:host-context([data-whatinput=keyboard])::ng-deep a:focus{border-radius:4px;outline:0;box-shadow:0 0 0 2px #fff,0 0 0 6px #009de6;box-shadow:var(--focus-box-shadow,0 0 0 2px #fff,0 0 0 6px #009de6)}:host(.nx-link--negative){color:#fff}:host(.nx-link--negative):hover{color:#c2c2c2}:host(.nx-link--negative)::ng-deep a:active{color:#999}:host(.nx-link--negative)::ng-deep a[aria-disabled],:host(.nx-link--negative)::ng-deep a[disabled]{color:rgba(255,255,255,.4)}:host(.nx-link--black){color:#414141;color:var(--link-black-color,#414141)}:host(.nx-link--black):hover{color:#999;color:var(--link-black-hover-color,#999)}:host(.nx-link--black)::ng-deep a:active{color:#5b5b5b;color:var(--link-black-active-color,#5b5b5b)}:host(.nx-link--black)::ng-deep a[aria-disabled],:host(.nx-link--black)::ng-deep a[disabled]{color:#c2c2c2;color:var(--link-black-disabled-color,#c2c2c2)}:host.nx-link--text{font-weight:700;text-transform:none;letter-spacing:normal;border-radius:4px;font-size:inherit;line-height:inherit}:host.nx-link--text ::ng-deep a{display:inline-flex}:host::ng-deep .c-icon,:host::ng-deep nx-icon.nx-link__icon{margin:0 8px 0 0}:host::ng-deep .c-icon::before,:host::ng-deep nx-icon.nx-link__icon::before{line-height:inherit;font-size:inherit}:host.nx-link--small ::ng-deep .c-icon,:host.nx-link--small ::ng-deep nx-icon.nx-link__icon{font-size:24px;font-size:var(--link-small-icon-size,24px)}:host.nx-link--large ::ng-deep .c-icon,:host.nx-link--large ::ng-deep nx-icon.nx-link__icon{font-size:32px;font-size:var(--link-large-icon-size,32px)}:host(.nx-link--icon-right)::ng-deep .c-icon,:host(.nx-link--icon-right)::ng-deep nx-icon.nx-link__icon{order:2;margin:0 0 0 8px}:host::ng-deep a[aria-disabled],:host::ng-deep a[disabled]{cursor:not-allowed;color:rgba(0,97,146,.4);color:var(--link-disabled-color,rgba(0,97,146,.4))}:host::ng-deep a[aria-disabled]:focus,:host::ng-deep a[disabled]:focus{outline:0;box-shadow:none}@media screen and (-ms-high-contrast:active){:host-context([data-whatinput=keyboard])::ng-deep a:focus{box-shadow:0 0 0 2px background,0 0 0 6px windowText}:host::ng-deep a[aria-disabled],:host::ng-deep a[disabled]{color:GrayText}}"]
            }] }
];
/** @nocollapse */
NxLinkComponent.ctorParameters = () => [
    { type: ElementRef },
    { type: Renderer2 },
    { type: ChangeDetectorRef }
];
NxLinkComponent.propDecorators = {
    icon: [{ type: ContentChild, args: [NxIconComponent, { static: false },] }],
    size: [{ type: Input }]
};
if (false) {
    /**
     * @type {?}
     * @private
     */
    NxLinkComponent.prototype._size;
    /**
     * \@docs-private
     * @type {?}
     */
    NxLinkComponent.prototype.icon;
    /**
     * Sets the style of the link, thereby altering the visual appearance.
     *
     * You can use any combination of 'black', 'icon-right', 'negative', 'text' and 'block' (deprecated).
     * @type {?}
     */
    NxLinkComponent.prototype.classNames;
    /**
     * @type {?}
     * @protected
     */
    NxLinkComponent.prototype._renderer;
    /**
     * @type {?}
     * @private
     */
    NxLinkComponent.prototype._changeDetectorRef;
}

/**
 * @fileoverview added by tsickle
 * Generated from: link/link.module.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class NxLinkModule {
}
NxLinkModule.decorators = [
    { type: NgModule, args: [{
                declarations: [NxLinkComponent],
                exports: [NxLinkComponent]
            },] }
];

/**
 * @fileoverview added by tsickle
 * Generated from: link/public-api.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * Generated from: circle-toggle/circle-toggle/toggle-button.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * \@docs-private
 * @abstract
 */
class ToggleButton {
}
if (false) {
    /** @type {?} */
    ToggleButton.prototype.id;
    /** @type {?} */
    ToggleButton.prototype.value;
    /** @type {?} */
    ToggleButton.prototype.checked;
    /** @type {?} */
    ToggleButton.prototype.name;
    /** @type {?} */
    ToggleButton.prototype.negative;
    /** @type {?} */
    ToggleButton.prototype.disabled;
    /** @type {?} */
    ToggleButton.prototype.tabIndex;
    /** @type {?} */
    ToggleButton.prototype.checkedChange;
    /** @type {?} */
    ToggleButton.prototype.selectionChange;
    /** @type {?} */
    ToggleButton.prototype.toggleButton;
    /**
     * @abstract
     * @param {?} event
     * @return {?}
     */
    ToggleButton.prototype.toggle = function (event) { };
    /**
     * @abstract
     * @return {?}
     */
    ToggleButton.prototype.setGroupSelection = function () { };
}

/**
 * @fileoverview added by tsickle
 * Generated from: circle-toggle/circle-toggle-group/circle-toggle-group.component.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
let nextId$2 = 0;
class NxCircleToggleGroupComponent {
    /**
     * @param {?} _changeDetectorRef
     */
    constructor(_changeDetectorRef) {
        this._changeDetectorRef = _changeDetectorRef;
        this._id = `nx-circle-toggle-group-${nextId$2++}`;
        this._destroyed = new Subject();
        /**
         * An event emitted when the selection changes. Outputs the value of the currently selected button.
         */
        this.valueChange = new EventEmitter();
        this._name = `toggle-group-${nextId$2++}`;
        this._negative = false;
        this._responsive = true;
        this.onChangeCallback = (/**
         * @param {?} value
         * @return {?}
         */
        (value) => { });
        this.onTouchedCallback = (/**
         * @return {?}
         */
        () => { });
    }
    /**
     * Id of the circle toggle group.
     *
     * If not set, the circle toggle group gets an incremented value by default.
     * @param {?} value
     * @return {?}
     */
    set id(value) {
        this._id = value;
        this._changeDetectorRef.markForCheck();
    }
    /**
     * @return {?}
     */
    get id() {
        return this._id;
    }
    /**
     * Name that is used for accessibility.
     * @param {?} value
     * @return {?}
     */
    set name(value) {
        this._name = value;
        this.updateToggleButtonsNames();
        this._changeDetectorRef.markForCheck();
    }
    /**
     * @return {?}
     */
    get name() {
        return this._name;
    }
    /**
     * Whether the circle toggle group is disabled.
     * @param {?} value
     * @return {?}
     */
    set disabled(value) {
        /** @type {?} */
        const newValue = coerceBooleanProperty(value);
        if (this._disabled !== newValue) {
            this._disabled = newValue;
            this._changeDetectorRef.markForCheck();
        }
        if (this.buttons) {
            this.buttons.forEach((/**
             * @param {?} button
             * @return {?}
             */
            button => button.disabled = value));
        }
    }
    /**
     * @return {?}
     */
    get disabled() {
        return this._disabled;
    }
    /**
     * Whether the circle toggle group uses the negative styling.
     * @param {?} value
     * @return {?}
     */
    set negative(value) {
        /** @type {?} */
        const newValue = coerceBooleanProperty(value);
        if (this.negative !== newValue) {
            this._negative = newValue;
        }
        if (this.buttons) {
            this.buttons.forEach((/**
             * @param {?} button
             * @return {?}
             */
            button => button.negative = value));
        }
    }
    /**
     * @return {?}
     */
    get negative() {
        return this._negative;
    }
    /**
     * The value of the selected circle toggle in the circle toggle group.
     * @param {?} value
     * @return {?}
     */
    set value(value) {
        this.writeValue(value);
    }
    /**
     * @return {?}
     */
    get value() {
        return this._value;
    }
    /**
     * Whether the circle toggle group has a responsive behavior.
     * @param {?} value
     * @return {?}
     */
    set responsive(value) {
        /** @type {?} */
        const newValue = coerceBooleanProperty(value);
        if (newValue !== this.responsive) {
            this._responsive = newValue;
            this._changeDetectorRef.markForCheck();
        }
    }
    /**
     * @return {?}
     */
    get responsive() {
        return this._responsive;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    writeValue(value) {
        if (this.value !== value) {
            this._value = value;
            this.notifySelectedChild(value);
        }
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this._destroyed.next();
        this._destroyed.complete();
    }
    /**
     * @return {?}
     */
    ngAfterViewInit() {
        this.subscribeToSelectionChanges();
        // react if a content child is deleted, added etc.
        this.buttons.changes
            .pipe(startWith(this.buttons), filter((/**
         * @param {?} toggles
         * @return {?}
         */
        toggles => toggles.length > 0)), tap((/**
         * @param {?} toggles
         * @return {?}
         */
        toggles => Promise.resolve().then((/**
         * @return {?}
         */
        () => {
            toggles.forEach((/**
             * @param {?} toggle
             * @return {?}
             */
            toggle => toggle.toggleButton.resetClasses()));
            this.buttons.first.toggleButton.setFirstButton();
            this.buttons.last.toggleButton.setLastButton();
        })))), takeUntil(this._destroyed))
            .subscribe((/**
         * @return {?}
         */
        () => this.subscribeToSelectionChanges()));
    }
    /**
     * \@docs-private
     * @return {?}
     */
    subscribeToSelectionChanges() {
        /** @type {?} */
        const changedOrDestroyed = merge(this.buttons.changes, this._destroyed);
        merge(...this.buttons.map((/**
         * @param {?} button
         * @return {?}
         */
        button => button.selectionChange)))
            .pipe(takeUntil(changedOrDestroyed))
            .subscribe((/**
         * @param {?} change
         * @return {?}
         */
        (change) => {
            this.onChangeCallback(change.value);
            this.valueChange.emit(change.value);
        }));
    }
    /**
     * \@docs-private
     * inform the selected button if the group selection is set programattically at the beginning
     * @param {?} newValue
     * @return {?}
     */
    notifySelectedChild(newValue) {
        if (this.buttons) {
            /** @type {?} */
            const selected = this.buttons.find((/**
             * @param {?} button
             * @return {?}
             */
            (button) => button.value === newValue));
            if (selected) {
                selected.setGroupSelection();
            }
        }
    }
    /**
     * \@docs-private
     * @return {?}
     */
    updateToggleButtonsNames() {
        if (this.buttons) {
            this.buttons.forEach((/**
             * @param {?} button
             * @return {?}
             */
            button => button.name = this.name));
        }
    }
    /**
     * @param {?} fn
     * @return {?}
     */
    registerOnChange(fn) {
        this.onChangeCallback = fn;
    }
    /**
     * @param {?} fn
     * @return {?}
     */
    registerOnTouched(fn) {
        this.onTouchedCallback = fn;
    }
    /**
     * @param {?} isDisabled
     * @return {?}
     */
    setDisabledState(isDisabled) {
        this.disabled = isDisabled;
    }
    /**
     * \@docs-private
     * @return {?}
     */
    get selectedButton() {
        return this.buttons ? this.buttons.find((/**
         * @param {?} button
         * @return {?}
         */
        button => button.checked)) : null;
    }
    /**
     * \@docs-private
     * @return {?}
     */
    get buttons() {
        return this._buttons;
    }
}
NxCircleToggleGroupComponent.decorators = [
    { type: Component, args: [{
                selector: 'nx-circle-toggle-group',
                template: `<ng-content></ng-content>`,
                changeDetection: ChangeDetectionStrategy.OnPush,
                providers: [
                    {
                        provide: NG_VALUE_ACCESSOR,
                        useExisting: forwardRef((/**
                         * @return {?}
                         */
                        () => NxCircleToggleGroupComponent)),
                        multi: true
                    }
                ],
                host: {
                    '[class.is-responsive]': 'responsive',
                    '[class.is-disabled]': 'disabled',
                    '[attr.aria-disabled]': 'disabled',
                    '[attr.aria-labelledby]': 'name',
                    '[attr.name]': 'name',
                    '[attr.id]': 'id',
                    '[class.nx-circle-toggle-group]': 'true',
                    'role': 'radiogroup'
                },
                styles: [":host{display:flex;flex-wrap:wrap;flex-direction:column;justify-content:space-around}@media (min-width:320px){:host{flex-direction:row}}:host(.is-responsive){flex-direction:column}@media (min-width:704px){:host(.is-responsive){flex-direction:row}}"]
            }] }
];
/** @nocollapse */
NxCircleToggleGroupComponent.ctorParameters = () => [
    { type: ChangeDetectorRef }
];
NxCircleToggleGroupComponent.propDecorators = {
    _buttons: [{ type: ContentChildren, args: [ToggleButton,] }],
    valueChange: [{ type: Output }],
    name: [{ type: Input }],
    disabled: [{ type: Input }],
    negative: [{ type: Input }],
    value: [{ type: Input }],
    responsive: [{ type: Input }]
};
if (false) {
    /**
     * @type {?}
     * @private
     */
    NxCircleToggleGroupComponent.prototype._buttons;
    /**
     * @type {?}
     * @private
     */
    NxCircleToggleGroupComponent.prototype._id;
    /**
     * @type {?}
     * @private
     */
    NxCircleToggleGroupComponent.prototype._destroyed;
    /**
     * An event emitted when the selection changes. Outputs the value of the currently selected button.
     * @type {?}
     */
    NxCircleToggleGroupComponent.prototype.valueChange;
    /**
     * @type {?}
     * @private
     */
    NxCircleToggleGroupComponent.prototype._name;
    /**
     * @type {?}
     * @private
     */
    NxCircleToggleGroupComponent.prototype._disabled;
    /** @type {?} */
    NxCircleToggleGroupComponent.prototype._negative;
    /**
     * @type {?}
     * @private
     */
    NxCircleToggleGroupComponent.prototype._value;
    /**
     * @type {?}
     * @private
     */
    NxCircleToggleGroupComponent.prototype._responsive;
    /**
     * @type {?}
     * @private
     */
    NxCircleToggleGroupComponent.prototype.onChangeCallback;
    /**
     * @type {?}
     * @private
     */
    NxCircleToggleGroupComponent.prototype.onTouchedCallback;
    /**
     * @type {?}
     * @private
     */
    NxCircleToggleGroupComponent.prototype._changeDetectorRef;
}

/**
 * @fileoverview added by tsickle
 * Generated from: circle-toggle/mobile-toggle-button/mobile-toggle-button.component.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * \@docs-private
 */
class NxMobileToggleButtonComponent {
    /**
     * @param {?} _changeDetectorRef
     */
    constructor(_changeDetectorRef) {
        this._changeDetectorRef = _changeDetectorRef;
        this.checked = false;
        this.negative = false;
        this.disabled = false;
    }
    /**
     * \@docs-private
     * @return {?}
     */
    setFirstButton() {
        this.isFirst = true;
        this._changeDetectorRef.markForCheck();
    }
    /**
     * \@docs-private
     * @return {?}
     */
    setLastButton() {
        this.isLast = true;
        this._changeDetectorRef.markForCheck();
    }
    /**
     * \@docs-private
     * @return {?}
     */
    resetClasses() {
        this.isFirst = false;
        this.isLast = false;
        this._changeDetectorRef.markForCheck();
    }
}
NxMobileToggleButtonComponent.decorators = [
    { type: Component, args: [{
                selector: 'nx-mobile-toggle-button',
                template: "<nx-icon class=\"nx-toggle-button__mobile-check\" name=\"check\" aria-hidden=\"true\"></nx-icon>\n<!-- If there is no label defined, use the circleText instead -->\n<span class=\"nx-toggle-button__label-text\"><ng-template *ngIf=\"label; then labelContent else circleTextContent\"></ng-template></span>\n<span *ngIf=\"hint\" class=\"nx-toggle-button__label-hint\">({{hint}})</span>\n\n<ng-template #labelContent>{{label}}</ng-template>\n<ng-template #circleTextContent>{{circleText}}</ng-template>\n",
                changeDetection: ChangeDetectionStrategy.OnPush,
                host: {
                    '[class.is-disabled]': 'disabled',
                    '[class.is-negative]': 'negative',
                    '[class.is-first]': 'isFirst',
                    '[class.is-last]': 'isLast',
                    '[class.is-flipped]': 'checked'
                },
                styles: [":host{display:none;position:relative;transition:background-color .2s,border-color .2s,color .2s;flex-direction:row;border-width:1px 2px;border-color:#007ab3;border-color:var(--circle-toggle-border-color,#007ab3);border-style:solid;padding:11px 31px;width:100%;justify-content:center;align-items:center;cursor:pointer}:host:not(.is-flipped):not(.is-disabled):hover{background-color:#006192;background-color:var(--circle-toggle-hover-background-color,#006192);border-color:#006192;border-color:var(--circle-toggle-hover-border-color,#006192)}:host:not(.is-flipped):not(.is-disabled):hover .nx-toggle-button__label-hint,:host:not(.is-flipped):not(.is-disabled):hover .nx-toggle-button__label-text{color:#fff;color:var(--circle-toggle-hover-icon-color,#fff)}@media (max-width:703px){:host-context(.is-responsive){display:flex}}.nx-toggle-button__label-hint{color:#007ab3;color:var(--circle-toggle-icon-color,#007ab3);font-size:14px;font-size:var(--circle-toggle-hint-mobile-font-size,14px);line-height:20px;line-height:var(--circle-toggle-hint-mobile-line-height,20px);font-weight:300;font-weight:var(--circle-toggle-hint-mobile-font-weight,300);letter-spacing:.2px;letter-spacing:var(--circle-toggle-hint-mobile-letter-spacing,.2px)}.nx-toggle-button__label-text{color:#007ab3;color:var(--circle-toggle-icon-color,#007ab3);font-size:14px;font-size:var(--circle-toggle-label-mobile-font-size,14px);line-height:20px;line-height:var(--circle-toggle-label-mobile-line-height,20px);font-weight:var(--circle-toggle-label-mobile-font-weight,400);letter-spacing:.2px;letter-spacing:var(--circle-toggle-label-mobile-letter-spacing,.2px);padding-top:0;padding-right:4px;font-weight:600}.nx-toggle-button__mobile-check{font-size:24px;height:24px;display:inline-block;opacity:0;margin-right:8px;color:#fff;color:var(--circle-toggle-checkmark-color,#fff)}:host(.is-first){border-top-width:2px;border-radius:4px 4px 0 0}:host(.is-last){border-bottom-width:2px;border-radius:0 0 4px 4px}:host(.is-flipped){background-color:#007ab3;background-color:var(--circle-toggle-selected-background-color,#007ab3)}:host(.is-flipped) .nx-toggle-button__label-hint,:host(.is-flipped) .nx-toggle-button__label-text{color:#fff;color:var(--circle-toggle-selected-icon-color,#fff)}:host(.is-flipped) .nx-toggle-button__mobile-check{opacity:1}:host(.is-negative){border-color:#fff}:host(.is-negative) .nx-toggle-button__label-hint,:host(.is-negative) .nx-toggle-button__label-text,:host(.is-negative) .nx-toggle-button__mobile-check{color:#fff}:host(.is-negative):not(.is-flipped):not(.is-disabled):hover{background-color:#d9d9d9;border-color:#d9d9d9}:host(.is-negative):not(.is-flipped):not(.is-disabled):hover .nx-toggle-button__label-hint,:host(.is-negative):not(.is-flipped):not(.is-disabled):hover .nx-toggle-button__label-text{color:#006192}:host(.is-negative.is-flipped){background-color:#fff}:host(.is-negative.is-flipped) .nx-toggle-button__label-hint,:host(.is-negative.is-flipped) .nx-toggle-button__label-text,:host(.is-negative.is-flipped) .nx-toggle-button__mobile-check{color:#007ab3}:host(.is-disabled){opacity:.4;cursor:not-allowed}@media screen and (-ms-high-contrast:active){:host,:host(.is-negative){background-color:buttonFace;border-color:buttonText}:host .nx-toggle-button__label-hint,:host .nx-toggle-button__label-text,:host .nx-toggle-button__mobile-check,:host(.is-negative) .nx-toggle-button__label-hint,:host(.is-negative) .nx-toggle-button__label-text,:host(.is-negative) .nx-toggle-button__mobile-check{color:buttonText;-ms-high-contrast-adjust:none}:host(.is-flipped),:host(.is-negative.is-flipped){background-color:highlight}:host(.is-flipped) .nx-toggle-button__label-hint,:host(.is-flipped) .nx-toggle-button__label-text,:host(.is-flipped) .nx-toggle-button__mobile-check,:host(.is-negative.is-flipped) .nx-toggle-button__label-hint,:host(.is-negative.is-flipped) .nx-toggle-button__label-text,:host(.is-negative.is-flipped) .nx-toggle-button__mobile-check{color:highlightText}:host(.is-disabled){opacity:1;border-color:GrayText;color:GrayText}:host(.is-disabled).is-flipped .nx-toggle-button__mobile-check{color:GrayText}}"]
            }] }
];
/** @nocollapse */
NxMobileToggleButtonComponent.ctorParameters = () => [
    { type: ChangeDetectorRef }
];
NxMobileToggleButtonComponent.propDecorators = {
    checked: [{ type: Input }],
    negative: [{ type: Input }],
    disabled: [{ type: Input }],
    hint: [{ type: Input }],
    label: [{ type: Input }],
    circleText: [{ type: Input }]
};
if (false) {
    /** @type {?} */
    NxMobileToggleButtonComponent.prototype.checked;
    /** @type {?} */
    NxMobileToggleButtonComponent.prototype.negative;
    /** @type {?} */
    NxMobileToggleButtonComponent.prototype.disabled;
    /** @type {?} */
    NxMobileToggleButtonComponent.prototype.hint;
    /** @type {?} */
    NxMobileToggleButtonComponent.prototype.label;
    /** @type {?} */
    NxMobileToggleButtonComponent.prototype.circleText;
    /**
     * \@docs-private
     * @type {?}
     */
    NxMobileToggleButtonComponent.prototype.isFirst;
    /**
     * \@docs-private
     * @type {?}
     */
    NxMobileToggleButtonComponent.prototype.isLast;
    /**
     * @type {?}
     * @private
     */
    NxMobileToggleButtonComponent.prototype._changeDetectorRef;
}

/**
 * @fileoverview added by tsickle
 * Generated from: circle-toggle/circle-toggle/circle-toggle.component.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class ToggleChangeEvent {
    /**
     * @param {?} button
     * @param {?} value
     */
    constructor(button, value) {
        this.button = button;
        this.value = value;
    }
}
if (false) {
    /**
     * A toggle button
     * @type {?}
     */
    ToggleChangeEvent.prototype.button;
    /**
     * The value of the toggle button that is sent with the event.
     * @type {?}
     */
    ToggleChangeEvent.prototype.value;
}
/** @type {?} */
let nextId$3 = 0;
class NxCircleToggleComponent extends ToggleButton {
    /**
     * @param {?} toggleGroup
     * @param {?} _checkedDispatcher
     * @param {?} _changeDetectorRef
     */
    constructor(/** @docs-private */ toggleGroup, _checkedDispatcher, _changeDetectorRef) {
        super();
        this.toggleGroup = toggleGroup;
        this._checkedDispatcher = _checkedDispatcher;
        this._changeDetectorRef = _changeDetectorRef;
        this._id = `toggle-button-${nextId$3++}`;
        /**
         * \@docs-private
         */
        this.inGroup = false;
        this._name = null;
        /**
         * An event that is emitted when the checked state fo the circle toggle changes.
         */
        this.checkedChange = new EventEmitter();
        /**
         * An event that is emitted when the checked state of the circle toggle changes.
         * The event object contains the circle toggle itself and its value (see ToggleChangeEvent).
         */
        this.selectionChange = new EventEmitter();
        this._checked = false;
        this._value = null;
        this._iconName = null;
        this._svg = null;
        this._svgChecked = null;
        this._circleText = null;
        this._label = null;
        this._hint = null;
        this._hover = false;
        /**
         * touched is set to true on touch devices.
         */
        this._touched = false;
        this._removeUniqueSelectionListener = (/**
         * @return {?}
         */
        () => { });
        this.onChangeCallback = (/**
         * @param {?} checked
         * @return {?}
         */
        (checked) => { });
        this.onTouchedCallback = (/**
         * @return {?}
         */
        () => { });
        if (this.toggleGroup) {
            this.name = this.toggleGroup.name;
        }
    }
    /**
     * Id of the circle toggle.
     *
     * If not set, the circle toggle gets an incremented value by default.
     * @param {?} value
     * @return {?}
     */
    set id(value) {
        this._id = value;
        this._changeDetectorRef.markForCheck();
    }
    /**
     * @return {?}
     */
    get id() {
        return this._id;
    }
    /**
     * Name that is used for accessibility.
     * @param {?} value
     * @return {?}
     */
    set name(value) {
        this._name = value;
        this._changeDetectorRef.markForCheck();
    }
    /**
     * @return {?}
     */
    get name() {
        return this._name;
    }
    /**
     * Whether the circle toggle is checked.
     * @param {?} value
     * @return {?}
     */
    set checked(value) {
        /** @type {?} */
        const newValue = coerceBooleanProperty(value);
        if (this.checked !== newValue) {
            this._checked = newValue;
            this._changeDetectorRef.markForCheck();
        }
    }
    /**
     * @return {?}
     */
    get checked() {
        return this._checked;
    }
    /**
     * The value that is used in the model.
     * @param {?} newValue
     * @return {?}
     */
    set value(newValue) {
        this._value = newValue;
        this._changeDetectorRef.markForCheck();
    }
    /**
     * @return {?}
     */
    get value() {
        return this._value;
    }
    /**
     * Id of the icon that should be displayed.
     * @param {?} name
     * @return {?}
     */
    set iconName(name) {
        this._iconName = name;
        this._changeDetectorRef.markForCheck();
    }
    /**
     * @return {?}
     */
    get iconName() {
        return this._iconName;
    }
    /**
     * SVG that is displayed if the circle toggle is unchecked.
     * @param {?} src
     * @return {?}
     */
    set svg(src) {
        this._svg = src;
        this._changeDetectorRef.markForCheck();
    }
    /**
     * @return {?}
     */
    get svg() {
        return this._svg;
    }
    /**
     * SVG that is displayed if the circle toggle is checked.
     * @param {?} src
     * @return {?}
     */
    set svgChecked(src) {
        this._svgChecked = src;
        this._changeDetectorRef.markForCheck();
    }
    /**
     * @return {?}
     */
    get svgChecked() {
        return this._svgChecked;
    }
    /**
     * A text that is displayed inside the circle toggle.
     * @param {?} value
     * @return {?}
     */
    set circleText(value) {
        if (value !== this._circleText) {
            this._circleText = value;
            this._changeDetectorRef.markForCheck();
        }
    }
    /**
     * @return {?}
     */
    get circleText() {
        return this._circleText;
    }
    /**
     * Label displayed below the circle.
     * @param {?} value
     * @return {?}
     */
    set label(value) {
        this._label = value;
        this._changeDetectorRef.markForCheck();
    }
    /**
     * @return {?}
     */
    get label() {
        return this._label;
    }
    /**
     * Additional hint displayed below the label.
     * @param {?} value
     * @return {?}
     */
    set hint(value) {
        this._hint = value;
        this._changeDetectorRef.markForCheck();
    }
    /**
     * @return {?}
     */
    get hint() {
        return this._hint;
    }
    /**
     * Whether the circle toggle uses the negative set of styling.
     * @param {?} value
     * @return {?}
     */
    set negative(value) {
        /** @type {?} */
        const newValue = coerceBooleanProperty(value);
        if (this.negative !== newValue) {
            this._negative = newValue;
            this._changeDetectorRef.markForCheck();
        }
    }
    /**
     * @return {?}
     */
    get negative() {
        return this._negative;
    }
    /**
     * Whether the circle toggle has a responsive behavior.
     * @param {?} value
     * @return {?}
     */
    set responsive(value) {
        /** @type {?} */
        const newValue = coerceBooleanProperty(value);
        if (this.responsive !== newValue) {
            this._responsive = newValue;
            this._changeDetectorRef.markForCheck();
        }
    }
    /**
     * @return {?}
     */
    get responsive() {
        return this._responsive;
    }
    /**
     * Whether the circle toggle is disabled.
     * @param {?} value
     * @return {?}
     */
    set disabled(value) {
        /** @type {?} */
        const newValue = coerceBooleanProperty(value);
        if (this.disabled !== newValue) {
            this._disabled = newValue;
            this._changeDetectorRef.markForCheck();
        }
    }
    /**
     * @return {?}
     */
    get disabled() {
        return this._disabled;
    }
    /**
     * \@docs-private
     * @return {?}
     */
    onMouseEnter() {
        if (!this._touched) {
            this._hover = true;
        }
    }
    /**
     * \@docs-private
     * @return {?}
     */
    onMouseLeave() {
        if (!this._touched) {
            this._hover = false;
        }
    }
    /**
     * \@docs-private
     * @return {?}
     */
    onTouchStart() {
        this._touched = true;
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        if (this.toggleGroup) {
            this.attachListenerForGroup();
        }
    }
    /**
     * @return {?}
     */
    ngAfterViewInit() {
        if (this.toggleGroup) {
            Promise.resolve().then((/**
             * @return {?}
             */
            () => {
                this.inGroup = true;
                this.negative = this.toggleGroup.negative;
                this.disabled = this.toggleGroup.disabled;
                this.responsive = this.toggleGroup.responsive;
                this.id = this.toggleGroup.id + `-button-${nextId$3++}`;
            }));
        }
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        // function returned by the listener
        this._removeUniqueSelectionListener();
    }
    /**
     * \@docs-private
     * @return {?}
     */
    attachListenerForGroup() {
        this._removeUniqueSelectionListener =
            this._checkedDispatcher.listen((/**
             * @param {?} groupId
             * @param {?} buttonId
             * @return {?}
             */
            (groupId, buttonId) => {
                if (this.id !== buttonId && groupId === this.toggleGroup.id) {
                    this.checked = false;
                }
            }));
    }
    /**
     * @param {?} newValue
     * @return {?}
     */
    writeValue(newValue) {
        this.checked = newValue;
    }
    /**
     * @param {?} fn
     * @return {?}
     */
    registerOnChange(fn) {
        this.onChangeCallback = fn;
    }
    /**
     * @param {?} fn
     * @return {?}
     */
    registerOnTouched(fn) {
        this.onTouchedCallback = fn;
    }
    /**
     * @param {?} isDisabled
     * @return {?}
     */
    setDisabledState(isDisabled) {
        this.disabled = isDisabled;
    }
    /**
     * \@docs-private
     * @param {?} event
     * @return {?}
     */
    toggle(event) {
        event.preventDefault();
        event.stopPropagation();
        if ((this.toggleGroup && this.checked) || this.disabled) {
            return;
        }
        else {
            this.checked = !this.checked;
            this.onChangeCallback(this.checked);
            this.checkedChange.emit(this.checked);
            this.selectionChange.emit(new ToggleChangeEvent(this, this.value));
            if (this.toggleGroup) {
                this._checkedDispatcher.notify(this.toggleGroup.id, this.id);
            }
        }
    }
    /**
     * \@docs-private
     *
     * method called by the group if the internal value of the group is changed programatically,
     * does not trigger change emission
     * @return {?}
     */
    setGroupSelection() {
        // propagate changes only if the value in the group is different than the button checked value
        if (!this.checked) {
            this.checked = !this.checked;
            this.onChangeCallback(this.checked);
            this._checkedDispatcher.notify(this.toggleGroup.id, this.id);
        }
    }
    /**
     * \@docs-private
     * @return {?}
     */
    get svgButton() {
        return !!this.svg && !!this.svgChecked;
    }
    /**
     * \@docs-private
     * @return {?}
     */
    get svgUrl() {
        /** @type {?} */
        let useFilledSvg = this.checked || (!this.disabled && this._hover);
        if (this.negative) {
            useFilledSvg = !useFilledSvg;
        }
        return useFilledSvg ? this.svgChecked : this.svg;
    }
    /**
     * \@docs-private
     * @return {?}
     */
    get type() {
        return this.toggleGroup ? 'radio' : 'checkbox';
    }
    /**
     * \@docs-private
     * @param {?} event
     * @return {?}
     */
    handleEnterKey(event) {
        if (!this.toggleGroup) {
            this.toggle(event);
        }
    }
}
NxCircleToggleComponent.decorators = [
    { type: Component, args: [{
                selector: 'nx-circle-toggle',
                template: "<input [id]=\"id + '-input'\"\n       class=\"nx-circle-toggle__input\"\n       [attr.aria-labelledby]=\"id + '-label'\"\n       [type]=\"type\"\n       [attr.name]=\"name\"\n       [checked]=\"checked\"\n       [disabled]= \"disabled\"\n       [attr.aria-checked]=\"checked\"\n       (keydown.enter)=\"handleEnterKey($event)\"\n       (click)=\"toggle($event)\">\n<label class=\"nx-circle-toggle__label\"\n  [for]=\"id + '-input'\"\n  [id]=\"id + '-label'\">\n    <nx-icon-toggle-button\n      [label]=\"label\"\n      [hint]=\"hint\"\n      [checked]=\"checked\"\n      [icon]=\"iconName\"\n      [negative]=\"negative\"\n      [svg]=\"svgUrl\"\n      [disabled]=\"disabled\"\n      [inGroup]=\"inGroup\"\n      [touched]=\"_touched\"\n      [circleText]=\"circleText\">\n    </nx-icon-toggle-button>\n    <!-- The mobile toggle button is needed for the responsive mobile version of the component.\n    The display swtich is handled in the css. -->\n    <nx-mobile-toggle-button\n      [label]=\"label\"\n      [hint]=\"hint\"\n      [checked]=\"checked\"\n      [negative]=\"negative\"\n      [disabled]=\"disabled\"\n      [circleText]=\"circleText\">\n    </nx-mobile-toggle-button>\n</label>",
                changeDetection: ChangeDetectionStrategy.OnPush,
                providers: [
                    {
                        provide: ToggleButton,
                        useExisting: forwardRef((/**
                         * @return {?}
                         */
                        () => NxCircleToggleComponent))
                    },
                    {
                        provide: NG_VALUE_ACCESSOR,
                        useExisting: forwardRef((/**
                         * @return {?}
                         */
                        () => NxCircleToggleComponent)),
                        multi: true
                    }
                ],
                host: {
                    '[class.nx-toggle-circle]': 'true',
                    '[class.in-group]': 'inGroup',
                    '[class.is-disabled]': 'disabled',
                    '[class.is-responsive]': 'responsive'
                },
                styles: [":host{display:inline-block;vertical-align:top;position:relative}:host:not(.is-responsive){opacity:.9999}:host .nx-circle-toggle__input{opacity:0;position:absolute}:host:not(.in-group){margin-right:64px}@media (max-width:703px){:host:not(.in-group){margin-right:48px}}:host-context([data-whatinput=keyboard]) .nx-circle-toggle__input:focus+.nx-circle-toggle__label ::ng-deep .nx-toggle-circle__check-focus,:host-context([data-whatinput=keyboard]) .nx-circle-toggle__input:focus+.nx-circle-toggle__label ::ng-deep .nx-toggle-circle__icon-wrapper{box-shadow:0 0 0 2px #fff,0 0 0 6px #009de6;box-shadow:var(--focus-box-shadow,0 0 0 2px #fff,0 0 0 6px #009de6)}@media screen and (-ms-high-contrast:active){:host-context([data-whatinput=keyboard]) .nx-circle-toggle__input:focus+.nx-circle-toggle__label ::ng-deep .nx-toggle-circle__check-focus,:host-context([data-whatinput=keyboard]) .nx-circle-toggle__input:focus+.nx-circle-toggle__label ::ng-deep .nx-toggle-circle__icon-wrapper{box-shadow:0 0 0 2px background,0 0 0 6px windowText}}:host-context([data-whatinput=keyboard]) .nx-circle-toggle__input:focus+.nx-circle-toggle__label ::ng-deep nx-mobile-toggle-button{box-shadow:0 0 0 2px #fff,0 0 0 6px #009de6;box-shadow:var(--focus-box-shadow,0 0 0 2px #fff,0 0 0 6px #009de6);z-index:1}@media screen and (-ms-high-contrast:active){:host-context([data-whatinput=keyboard]) .nx-circle-toggle__input:focus+.nx-circle-toggle__label ::ng-deep nx-mobile-toggle-button{box-shadow:0 0 0 2px background,0 0 0 6px windowText}}"]
            }] }
];
/** @nocollapse */
NxCircleToggleComponent.ctorParameters = () => [
    { type: NxCircleToggleGroupComponent, decorators: [{ type: Optional }] },
    { type: UniqueSelectionDispatcher },
    { type: ChangeDetectorRef }
];
NxCircleToggleComponent.propDecorators = {
    name: [{ type: Input }],
    checkedChange: [{ type: Output }],
    selectionChange: [{ type: Output }],
    checked: [{ type: Input }],
    value: [{ type: Input }],
    iconName: [{ type: Input, args: ['icon',] }],
    svg: [{ type: Input }],
    svgChecked: [{ type: Input }],
    circleText: [{ type: Input }],
    label: [{ type: Input }],
    hint: [{ type: Input }],
    negative: [{ type: Input }],
    responsive: [{ type: Input }],
    disabled: [{ type: Input }],
    toggleButton: [{ type: ViewChild, args: [NxMobileToggleButtonComponent, { static: true },] }],
    onMouseEnter: [{ type: HostListener, args: ['mouseenter',] }],
    onMouseLeave: [{ type: HostListener, args: ['mouseleave',] }],
    onTouchStart: [{ type: HostListener, args: ['touchstart',] }]
};
if (false) {
    /**
     * @type {?}
     * @private
     */
    NxCircleToggleComponent.prototype._id;
    /**
     * \@docs-private
     * @type {?}
     */
    NxCircleToggleComponent.prototype.inGroup;
    /**
     * @type {?}
     * @private
     */
    NxCircleToggleComponent.prototype._name;
    /**
     * An event that is emitted when the checked state fo the circle toggle changes.
     * @type {?}
     */
    NxCircleToggleComponent.prototype.checkedChange;
    /**
     * An event that is emitted when the checked state of the circle toggle changes.
     * The event object contains the circle toggle itself and its value (see ToggleChangeEvent).
     * @type {?}
     */
    NxCircleToggleComponent.prototype.selectionChange;
    /** @type {?} */
    NxCircleToggleComponent.prototype._checked;
    /**
     * @type {?}
     * @private
     */
    NxCircleToggleComponent.prototype._value;
    /**
     * @type {?}
     * @private
     */
    NxCircleToggleComponent.prototype._iconName;
    /**
     * @type {?}
     * @private
     */
    NxCircleToggleComponent.prototype._svg;
    /**
     * @type {?}
     * @private
     */
    NxCircleToggleComponent.prototype._svgChecked;
    /**
     * @type {?}
     * @private
     */
    NxCircleToggleComponent.prototype._circleText;
    /**
     * @type {?}
     * @private
     */
    NxCircleToggleComponent.prototype._label;
    /**
     * @type {?}
     * @private
     */
    NxCircleToggleComponent.prototype._hint;
    /**
     * @type {?}
     * @private
     */
    NxCircleToggleComponent.prototype._negative;
    /**
     * @type {?}
     * @private
     */
    NxCircleToggleComponent.prototype._responsive;
    /**
     * @type {?}
     * @private
     */
    NxCircleToggleComponent.prototype._disabled;
    /**
     * \@docs-private
     * @type {?}
     */
    NxCircleToggleComponent.prototype.toggleButton;
    /**
     * @type {?}
     * @private
     */
    NxCircleToggleComponent.prototype._hover;
    /**
     * touched is set to true on touch devices.
     * @type {?}
     */
    NxCircleToggleComponent.prototype._touched;
    /** @type {?} */
    NxCircleToggleComponent.prototype._removeUniqueSelectionListener;
    /**
     * @type {?}
     * @private
     */
    NxCircleToggleComponent.prototype.onChangeCallback;
    /**
     * @type {?}
     * @private
     */
    NxCircleToggleComponent.prototype.onTouchedCallback;
    /**
     * \@docs-private
     * @type {?}
     */
    NxCircleToggleComponent.prototype.toggleGroup;
    /**
     * @type {?}
     * @private
     */
    NxCircleToggleComponent.prototype._checkedDispatcher;
    /**
     * @type {?}
     * @private
     */
    NxCircleToggleComponent.prototype._changeDetectorRef;
}

/**
 * @fileoverview added by tsickle
 * Generated from: circle-toggle/icon-toggle-button/icon-toggle-button.component.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * \@docs-private
 */
class NxIconToggleButtonComponent {
    constructor() {
        this.inGroup = true;
    }
}
NxIconToggleButtonComponent.decorators = [
    { type: Component, args: [{
                selector: 'nx-icon-toggle-button',
                template: "<div class=\"nx-toggle-circle__icon-wrapper\">\n  <ng-container *ngIf=\"!inGroup\">\n    <span class=\"nx-toggle-circle__check-icon\">\n      <nx-icon name=\"check\"></nx-icon>\n    </span>\n    <div class=\"nx-toggle-circle__check-focus\"></div>\n  </ng-container>\n  <span class=\"nx-toggle-circle__icon\">\n    <nx-icon size=\"m\" *ngIf=\"icon\" [name]=\"icon\"></nx-icon>\n    <img *ngIf=\"svgUrl\" class=\"nx-toggle-circle__icon-image\" [src]=\"svgUrl\" />\n    <span *ngIf=\"circleText\" class=\"nx-toggle-circle__content-text\">{{circleText}}</span>\n  </span>\n</div>\n<span [class.is-label-bold]=\"hint\" class=\"nx-toggle-circle__label-text\">{{label}}</span>\n<span *ngIf=\"hint\" class=\"nx-toggle-circle__label-hint\">{{hint}}</span>\n",
                changeDetection: ChangeDetectionStrategy.OnPush,
                host: {
                    '[class.nx-circle-button]': 'true',
                    '[class.is-flipped]': 'checked',
                    '[class.has-checkmark]': '!inGroup',
                    '[class.is-disabled]': 'disabled',
                    '[class.is-negative]': 'negative',
                    '[class.is-touched]': 'touched'
                },
                styles: ["@media (max-width:703px){:host-context(.is-responsive){display:none}}:host{display:flex;flex-direction:column;padding:0;align-items:center;cursor:pointer;position:relative}:host .nx-toggle-circle__label-text{font-size:16px;font-size:var(--circle-toggle-label-font-size,16px);line-height:24px;line-height:var(--circle-toggle-label-line-height,24px);font-weight:400;font-weight:var(--circle-toggle-label-font-weight,400);letter-spacing:0;letter-spacing:var(--circle-toggle-label-letter-spacing,0);color:#414141;color:var(--circle-toggle-label-color,#414141);position:relative;display:inline-block;padding-top:12px;max-width:16rem;z-index:1}@media (max-width:703px){:host .nx-toggle-circle__label-text{font-size:14px;font-size:var(--circle-toggle-label-mobile-font-size,14px);line-height:20px;line-height:var(--circle-toggle-label-mobile-line-height,20px);font-weight:400;font-weight:var(--circle-toggle-label-mobile-font-weight,400);letter-spacing:.2px;letter-spacing:var(--circle-toggle-label-mobile-letter-spacing,.2px)}}:host .is-label-bold{font-weight:700}:host .nx-toggle-circle__icon-wrapper{height:80px;width:80px;border-radius:50%;border-color:var(--circle-toggle-border-color,#007ab3);display:flex;align-items:center;justify-content:center;transition:background-color .2s,border-color .2s,box-shadow .2s;border:2px solid #007ab3}@media (max-width:703px){:host .is-label-bold{font-weight:400}:host .nx-toggle-circle__icon-wrapper{height:64px;width:64px}:host .nx-toggle-circle__icon-wrapper .nx-toggle-circle__icon nx-icon{font-size:40px}}:host .nx-toggle-circle__check-icon{background-color:#3da556;background-color:var(--circle-toggle-checkmark-background-color,#3da556);color:#fff;color:var(--circle-toggle-checkmark-color,#fff);border-color:var(--circle-toggle-checkmark-border-color,#fff);border-radius:50%;font-size:24px;width:32px;height:32px;position:absolute;top:-8px;right:calc(50% - 48px);transition:opacity .3s;z-index:1;opacity:0;display:flex;justify-content:center;align-items:center;border:2px solid #fff}:host .nx-toggle-circle__check-focus{border-radius:50%;width:28px;height:28px;position:absolute;top:-6px;right:calc(50% - 48px + 2px);z-index:-1;opacity:0;transition:box-shadow .2s}:host .nx-toggle-circle__content-text{font-size:24px;font-size:var(--circle-toggle-content-text-font-size,24px);line-height:32px;line-height:var(--circle-toggle-content-text-line-height,32px);font-weight:400;font-weight:var(--circle-toggle-content-text-font-weight,400);letter-spacing:.2px;letter-spacing:var(--circle-toggle-content-text-letter-spacing,.2px);color:#006192;color:var(--circle-toggle-content-text-color,#006192)}@media (max-width:703px){:host .nx-toggle-circle__content-text{font-size:20px;font-size:var(--circle-toggle-content-text-mobile-font-size,20px);line-height:28px;line-height:var(--circle-toggle-content-text-mobile-line-height,28px);font-weight:400;font-weight:var(--circle-toggle-content-text-mobile-font-weight,400);letter-spacing:.2px;letter-spacing:var(--circle-toggle-content-text-mobile-letter-spacing,.2px)}:host .nx-toggle-circle__label-hint .nx-toggle-circle__icon-wrapper{width:64px;height:64px}:host .nx-toggle-circle__label-hint .nx-toggle-circle__icon nx-icon{font-size:32px}:host .nx-toggle-circle__label-hint .nx-toggle-circle__check-icon{right:calc(50% - 40px)}:host .nx-toggle-circle__label-hint .nx-toggle-circle__icon-image{width:64px;height:64px}}:host .nx-toggle-circle__label-hint{font-size:16px;font-size:var(--circle-toggle-hint-font-size,16px);line-height:24px;line-height:var(--circle-toggle-hint-line-height,24px);font-weight:400;font-weight:var(--circle-toggle-hint-font-weight,400);letter-spacing:0;letter-spacing:var(--circle-toggle-hint-letter-spacing,0);color:#414141;color:var(--circle-toggle-hint-color,#414141);display:inline-block;transition:color .2s;z-index:1}@media (max-width:703px){:host .nx-toggle-circle__label-hint{font-size:14px;font-size:var(--circle-toggle-hint-mobile-font-size,14px);line-height:20px;line-height:var(--circle-toggle-hint-mobile-line-height,20px);font-weight:300;font-weight:var(--circle-toggle-hint-mobile-font-weight,300);letter-spacing:.2px;letter-spacing:var(--circle-toggle-hint-mobile-letter-spacing,.2px)}}:host .nx-toggle-circle__icon{display:flex;justify-content:center;align-content:center}:host .nx-toggle-circle__icon nx-icon{color:#007ab3;color:var(--circle-toggle-icon-color,#007ab3)}:host .nx-toggle-circle__icon-image{pointer-events:none;position:relative;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}:host(.is-flipped) .nx-toggle-circle__icon-wrapper{background-color:#007ab3;background-color:var(--circle-toggle-selected-background-color,#007ab3);border-color:#007ab3;border-color:var(--circle-toggle-selected-border-color,#007ab3)}:host(.is-flipped) .nx-toggle-circle__icon nx-icon{color:#fff;color:var(--circle-toggle-selected-icon-color,#fff)}:host(.is-flipped) .nx-toggle-circle__content-text{color:#fff;color:var(--circle-toggle-selected-content-text-color,#fff)}:host(.is-flipped) .nx-toggle-circle__check-focus,:host(.is-flipped) .nx-toggle-circle__check-icon{opacity:1}:host:not(.is-disabled):not(.is-negative):not(.is-touched):hover .nx-toggle-circle__icon-wrapper{border-color:#006192;border-color:var(--circle-toggle-hover-border-color,#006192);background-color:#006192;background-color:var(--circle-toggle-hover-background-color,#006192)}:host:not(.is-disabled):not(.is-negative):not(.is-touched):hover:not(.is-flipped) .nx-toggle-circle__icon-wrapper{border-color:#007ab3;border-color:var(--circle-toggle-selected-border-color,#007ab3);background-color:#007ab3;background-color:var(--circle-toggle-selected-background-color,#007ab3)}:host:not(.is-disabled):not(.is-negative):not(.is-touched):hover .nx-toggle-circle__content-text{color:#fff;color:var(--circle-toggle-hover-icon-color,#fff)}:host:not(.is-disabled):not(.is-negative):not(.is-touched):hover .nx-toggle-circle__icon nx-icon{color:#fff;color:var(--circle-toggle-hover-icon-color,#fff)}:host:hover.is-flipped:not(.has-checkmark){cursor:auto}:host(.is-disabled){opacity:.4;cursor:not-allowed}:host(.is-negative) .nx-toggle-circle__icon-wrapper{border-color:#fff;background-color:transparent}:host(.is-negative) .nx-toggle-circle__content-text,:host(.is-negative) .nx-toggle-circle__icon nx-icon,:host(.is-negative) .nx-toggle-circle__label-hint,:host(.is-negative) .nx-toggle-circle__label-text{color:#fff}:host(.is-negative):not(.is-disabled):not(.is-touched):hover .nx-toggle-circle__icon-wrapper,:host(.is-negative.is-flipped) .nx-toggle-circle__icon-wrapper{border-color:#fff;background-color:#fff}:host(.is-negative):not(.is-disabled):not(.is-touched):hover .nx-toggle-circle__icon nx-icon,:host(.is-negative.is-flipped) .nx-toggle-circle__icon nx-icon{color:#007ab3}:host(.is-negative):not(.is-disabled):not(.is-touched):hover .nx-toggle-circle__content-text,:host(.is-negative.is-flipped) .nx-toggle-circle__content-text{color:#006192}@media screen and (-ms-high-contrast:active){.nx-toggle-circle__icon-wrapper{border-color:buttonText;background-color:buttonFace}.nx-toggle-circle__content-text{-ms-high-contrast-adjust:none}.nx-toggle-circle__label-hint,.nx-toggle-circle__label-text{color:buttonText}:host(.is-negative):not(.is-flipped):not(.is-disabled):not(.is-touched) .nx-toggle-circle__content-text,:host(.is-negative):not(.is-flipped):not(.is-disabled):not(.is-touched) .nx-toggle-circle__icon nx-icon,:host:not(.is-flipped) .nx-toggle-circle__content-text,:host:not(.is-flipped) .nx-toggle-circle__icon nx-icon{color:buttonText}:host(.is-flipped) .nx-toggle-circle__icon-wrapper,:host(.is-negative.is-flipped) .nx-toggle-circle__icon-wrapper{background:highlight;border-color:highlight;color:highlightText}:host(.is-flipped) .nx-toggle-circle__content-text,:host(.is-flipped) .nx-toggle-circle__icon nx-icon,:host(.is-negative.is-flipped) .nx-toggle-circle__content-text,:host(.is-negative.is-flipped) .nx-toggle-circle__icon nx-icon{color:highlightText}:host(.is-flipped) .nx-toggle-circle__check-icon,:host(.is-negative.is-flipped) .nx-toggle-circle__check-icon{border-color:windowText;color:windowText}:host.is-negative:not(.is-disabled):not(.is-touched):hover.is-flipped .nx-toggle-circle__content-text,:host.is-negative:not(.is-disabled):not(.is-touched):hover.is-flipped .nx-toggle-circle__icon nx-icon,:host:not(.is-disabled):not(.is-touched):hover.is-flipped .nx-toggle-circle__content-text,:host:not(.is-disabled):not(.is-touched):hover.is-flipped .nx-toggle-circle__icon nx-icon{color:highlightText}:host.is-negative:not(.is-disabled):not(.is-touched):hover:not(.is-flipped) .nx-toggle-circle__content-text,:host.is-negative:not(.is-disabled):not(.is-touched):hover:not(.is-flipped) .nx-toggle-circle__icon nx-icon,:host:not(.is-disabled):not(.is-touched):hover:not(.is-flipped) .nx-toggle-circle__content-text,:host:not(.is-disabled):not(.is-touched):hover:not(.is-flipped) .nx-toggle-circle__icon nx-icon{color:buttonText}:host(.is-disabled),:host(.is-disabled.is-flipped),:host(.is-disabled.is-flipped):hover{opacity:1}:host(.is-disabled) .nx-toggle-circle__icon-wrapper,:host(.is-disabled.is-flipped) .nx-toggle-circle__icon-wrapper,:host(.is-disabled.is-flipped):hover .nx-toggle-circle__icon-wrapper{border-color:GrayText;background:buttonFace;color:GrayText}:host(.is-disabled) .nx-toggle-circle__icon-wrapper .nx-toggle-circle__content-text,:host(.is-disabled) .nx-toggle-circle__icon-wrapper .nx-toggle-circle__icon nx-icon,:host(.is-disabled.is-flipped) .nx-toggle-circle__icon-wrapper .nx-toggle-circle__content-text,:host(.is-disabled.is-flipped) .nx-toggle-circle__icon-wrapper .nx-toggle-circle__icon nx-icon,:host(.is-disabled.is-flipped):hover .nx-toggle-circle__icon-wrapper .nx-toggle-circle__content-text,:host(.is-disabled.is-flipped):hover .nx-toggle-circle__icon-wrapper .nx-toggle-circle__icon nx-icon{color:GrayText}:host(.is-disabled) .nx-toggle-circle__check-icon,:host(.is-disabled.is-flipped) .nx-toggle-circle__check-icon,:host(.is-disabled.is-flipped):hover .nx-toggle-circle__check-icon{border-color:GrayText;color:GrayText}:host(.is-disabled) .nx-toggle-circle__label-hint,:host(.is-disabled) .nx-toggle-circle__label-text,:host(.is-disabled.is-flipped) .nx-toggle-circle__label-hint,:host(.is-disabled.is-flipped) .nx-toggle-circle__label-text,:host(.is-disabled.is-flipped):hover .nx-toggle-circle__label-hint,:host(.is-disabled.is-flipped):hover .nx-toggle-circle__label-text{color:GrayText}}"]
            }] }
];
NxIconToggleButtonComponent.propDecorators = {
    inGroup: [{ type: Input }],
    hint: [{ type: Input }],
    label: [{ type: Input }],
    checked: [{ type: Input }],
    icon: [{ type: Input }],
    svgUrl: [{ type: Input, args: ['svg',] }],
    disabled: [{ type: Input }],
    negative: [{ type: Input }],
    touched: [{ type: Input }],
    circleText: [{ type: Input }]
};
if (false) {
    /** @type {?} */
    NxIconToggleButtonComponent.prototype.inGroup;
    /** @type {?} */
    NxIconToggleButtonComponent.prototype.hint;
    /** @type {?} */
    NxIconToggleButtonComponent.prototype.label;
    /** @type {?} */
    NxIconToggleButtonComponent.prototype.checked;
    /** @type {?} */
    NxIconToggleButtonComponent.prototype.icon;
    /** @type {?} */
    NxIconToggleButtonComponent.prototype.svgUrl;
    /** @type {?} */
    NxIconToggleButtonComponent.prototype.disabled;
    /** @type {?} */
    NxIconToggleButtonComponent.prototype.negative;
    /** @type {?} */
    NxIconToggleButtonComponent.prototype.touched;
    /** @type {?} */
    NxIconToggleButtonComponent.prototype.circleText;
}

/**
 * @fileoverview added by tsickle
 * Generated from: circle-toggle/circle-toggle.module.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class NxCircleToggleModule {
}
NxCircleToggleModule.decorators = [
    { type: NgModule, args: [{
                declarations: [
                    NxCircleToggleGroupComponent,
                    NxCircleToggleComponent,
                    NxIconToggleButtonComponent,
                    NxMobileToggleButtonComponent
                ],
                exports: [
                    NxCircleToggleGroupComponent,
                    NxIconToggleButtonComponent,
                    NxCircleToggleComponent,
                    NxMobileToggleButtonComponent
                ],
                imports: [
                    CommonModule,
                    NxIconModule
                ]
            },] }
];

/**
 * @fileoverview added by tsickle
 * Generated from: circle-toggle/public-api.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * Generated from: list/list.component.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const DEFAULT_TYPE$3 = 'normal';
class NxListComponent {
    constructor() {
        /**
         * \@docs-private
         */
        this.negative = false;
        /**
         * \@docs-private
         */
        this.orderedCircle = false;
    }
    /**
     * Sets the visual appearance of the list. You can combine different values:
     *
     * xsmall | small | normal: The listed input values are expanded to the underlying BEM conform styles based
     * on modifiers. Defaults to normal.
     *
     * negative: Display the list with a negative set of styling.
     *
     * ordered-circle: Display the list item numbers in a color filled circle.
     * @param {?} value
     * @return {?}
     */
    set classNames(value) {
        if (this._classNames === value) {
            return;
        }
        this._classNames = value;
        const [type = null] = this._classNames.match(/xsmall|small|normal/) || [DEFAULT_TYPE$3];
        this.type = (/** @type {?} */ (type));
        this.negative = !!this._classNames.match(/negative/);
        this.orderedCircle = !!this._classNames.match(/ordered-circle/);
    }
    /**
     * @return {?}
     */
    get classNames() {
        return this._classNames;
    }
}
NxListComponent.decorators = [
    { type: Component, args: [{
                // tslint:disable-next-line:component-selector
                selector: 'ul[nxList], ol[nxList]',
                template: '<ng-content></ng-content>',
                changeDetection: ChangeDetectionStrategy.OnPush,
                host: {
                    '[class.nx-list--xsmall]': 'type === "xsmall"',
                    '[class.nx-list--small]': 'type === "small"',
                    '[class.nx-list--normal]': 'type === "normal"',
                    '[class.nx-list--negative]': 'negative',
                    '[class.nx-list--ordered-circle]': 'orderedCircle',
                },
                styles: [":host{color:#414141;color:var(--list-text-color,#414141);list-style:none;margin-bottom:32px;padding:0;counter-reset:list}:host(.nx-list--normal){font-size:18px;font-size:var(--paragraph-02-font-size,18px);line-height:24px;line-height:var(--paragraph-02-line-height,24px);font-weight:400;font-weight:var(--paragraph-02-font-weight,400);letter-spacing:.2px;letter-spacing:var(--paragraph-02-letter-spacing,.2px)}:host(.nx-list--small){font-size:16px;font-size:var(--paragraph-03-font-size,16px);line-height:24px;line-height:var(--paragraph-03-line-height,24px);font-weight:400;font-weight:var(--paragraph-03-font-weight,400);letter-spacing:0;letter-spacing:var(--paragraph-03-letter-spacing,0)}:host(.nx-list--xsmall){font-size:14px;font-size:var(--paragraph-04-font-size,14px);line-height:20px;line-height:var(--paragraph-04-line-height,20px);font-weight:600;font-weight:var(--paragraph-04-font-weight,600);letter-spacing:.2px;letter-spacing:var(--paragraph-04-letter-spacing,.2px)}:host(.nx-list--negative){color:#fff}:host(.nx-list--negative) ::ng-deep .nx-list__icon{color:#fff}:host ::ng-deep .nx-list__icon{position:absolute;left:0;font-size:24px;font-size:var(--list-icon-size,24px);color:#5a5360;color:var(--list-icon-color,#5a5360);top:50%;transform:translateY(-50%);line-height:24px;line-height:var(--list-icon-size,24px);height:24px;height:var(--list-icon-size,24px)}:host ::ng-deep li{margin-bottom:16px;padding-left:36px;padding-left:calc(var(--list-icon-size,24px) + 12px);position:relative}:host(ul) ::ng-deep>li:not([nxlisticon]):before{background-color:#5a5360;background-color:var(--list-icon-color,#5a5360);border-radius:50%;content:\"\";display:inline-block;height:8px;width:8px;margin-right:16px;position:absolute;margin-left:-24px;margin-left:calc(-1 * var(--list-icon-size,24px));margin-top:8px;margin-top:calc((var(--paragraph-02-line-height,24px) - 8px)/ 2);transform:translateX(-50%)}:host(ul.nx-list--small) ::ng-deep>li:not([nxlisticon]):before{margin-top:8px;margin-top:calc((var(--paragraph-03-line-height,24px) - 8px)/ 2)}:host(ul.nx-list--xsmall) ::ng-deep>li:not([nxlisticon]):before{margin-top:6px;margin-top:calc((var(--paragraph-04-line-height,20px) - 8px)/ 2)}:host(ol) ::ng-deep>li:not([nxlisticon]):before{counter-increment:list;content:counter(list);position:absolute;font-size:inherit;font-weight:700;display:inline-block;width:24px;width:var(--list-icon-size,24px);text-align:center;left:0}:host ::ng-deep li>::ng-deep ol,:host ::ng-deep li>::ng-deep ul{margin-bottom:16px;margin-top:16px}:host(ol.nx-list--ordered-circle) ::ng-deep>li:not([nxlisticon]):before{width:24px;width:var(--list-circle-size,24px);font-size:16px;font-size:var(--paragraph-03-font-size,16px);line-height:24px;line-height:var(--paragraph-03-line-height,24px);font-weight:400;font-weight:var(--paragraph-03-font-weight,400);letter-spacing:0;letter-spacing:var(--paragraph-03-letter-spacing,0);color:#fff;color:var(--list-circle-text-color,#fff);left:0;top:50%;transform:translateY(-50%);z-index:2}@media screen and (-ms-high-contrast:active){:host(ul) ::ng-deep>li:not([nxlisticon]):before{background-color:windowText}:host(ol.nx-list--ordered-circle) ::ng-deep>li:not([nxlisticon]):before{border:1px solid windowText;border-radius:50%}:host(ol.nx-list--ordered-circle) ::ng-deep>li:not([nxlisticon]):after{color:windowText}}:host(ol.nx-list--ordered-circle) ::ng-deep>li:not([nxlisticon]):after{border-radius:50%;width:24px;width:var(--list-circle-size,24px);height:24px;height:var(--list-circle-size,24px);background-color:#5a5360;background-color:var(--list-icon-color,#5a5360);left:0;top:50%;transform:translateY(-50%);content:'';position:absolute}:host(ol.nx-list--ordered-circle.nx-list--negative)::ng-deep>li:not([nxlisticon]):after{background-color:#fff}:host(ol.nx-list--ordered-circle.nx-list--negative)::ng-deep>li:not([nxlisticon]):before{color:#5a5360}:host(ul.nx-list--negative) ::ng-deep>li:not([nxlisticon]):before{background-color:#fff}"]
            }] }
];
NxListComponent.propDecorators = {
    classNames: [{ type: Input, args: ['nxList',] }]
};
if (false) {
    /**
     * @type {?}
     * @private
     */
    NxListComponent.prototype._classNames;
    /**
     * \@docs-private
     * @type {?}
     */
    NxListComponent.prototype.type;
    /**
     * \@docs-private
     * @type {?}
     */
    NxListComponent.prototype.negative;
    /**
     * \@docs-private
     * @type {?}
     */
    NxListComponent.prototype.orderedCircle;
}

/**
 * @fileoverview added by tsickle
 * Generated from: list/list-icon.component.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class NxListIconComponent {
}
NxListIconComponent.decorators = [
    { type: Component, args: [{
                // tslint:disable-next-line:component-selector
                selector: 'li[nxListIcon]',
                template: `
    <span class="nx-list__icon">
      <nx-icon [name]='name'></nx-icon>
    </span>
    <ng-content></ng-content>`
            }] }
];
NxListIconComponent.propDecorators = {
    viewRefPrefix: [{ type: ViewChild, args: ['viewRefPrefix', { read: ViewContainerRef, static: false },] }],
    name: [{ type: Input, args: ['nxListIcon',] }]
};
if (false) {
    /**
     * \@docs-private
     * @type {?}
     */
    NxListIconComponent.prototype.viewRefPrefix;
    /**
     * Sets the name of the icon to be displayed.
     * @type {?}
     */
    NxListIconComponent.prototype.name;
}

/**
 * @fileoverview added by tsickle
 * Generated from: list/list.module.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class NxListModule {
}
NxListModule.decorators = [
    { type: NgModule, args: [{
                declarations: [NxListComponent, NxListIconComponent],
                imports: [NxIconModule],
                exports: [NxListComponent, NxListIconComponent],
                bootstrap: [NxIconComponent]
            },] }
];

/**
 * @fileoverview added by tsickle
 * Generated from: list/public-api.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * Generated from: radio-toggle/radio-toggle-button-base.component.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
let nextId$4 = 0;
/**
 * \@docs-private
 */
class NxRadioToggleButtonBaseComponent {
    /**
     * @param {?} renderer
     */
    constructor(renderer) {
        this.renderer = renderer;
        /**
         * \@docs-private
         */
        this.toggleButtonId = 'nx-radio-toggle-button-' + nextId$4++;
    }
    /**
     * \@docs-private
     * @param {?} event
     * @return {?}
     */
    triggerInputClick(event) {
        event.stopPropagation();
        this.toggleInput.nativeElement.click();
    }
    /**
     * \@docs-private
     * @return {?}
     */
    setFirstButton() {
        this.renderer.addClass(this.labelContainer.nativeElement, 'nx-radio-toggle__label-container--first');
    }
    /**
     * \@docs-private
     * @return {?}
     */
    setLastButton() {
        this.renderer.addClass(this.labelContainer.nativeElement, 'nx-radio-toggle__label-container--last');
    }
    /**
     * \@docs-private
     * @return {?}
     */
    resetClasses() {
        removeClasses(this.renderer, this.labelContainer, 'nx-radio-toggle__label-container--first nx-radio-toggle__label-container--last');
    }
}
NxRadioToggleButtonBaseComponent.propDecorators = {
    value: [{ type: Input, args: ['nxValue',] }],
    labelContainer: [{ type: ViewChild, args: ['toggleButtonLabelContainer', { static: true },] }],
    toggleInput: [{ type: ViewChild, args: ['toggleInput', { static: true },] }]
};
if (false) {
    /**
     * \@docs-private
     * @type {?}
     */
    NxRadioToggleButtonBaseComponent.prototype.toggleButtonId;
    /**
     * \@docs-private
     * @type {?}
     */
    NxRadioToggleButtonBaseComponent.prototype.value;
    /**
     * \@docs-private
     * @type {?}
     */
    NxRadioToggleButtonBaseComponent.prototype.labelContainer;
    /**
     * \@docs-private
     * @type {?}
     */
    NxRadioToggleButtonBaseComponent.prototype.toggleInput;
    /**
     * \@docs-private
     * @type {?}
     * @protected
     */
    NxRadioToggleButtonBaseComponent.prototype.renderer;
}

/**
 * @fileoverview added by tsickle
 * Generated from: radio-toggle/radio-toggle.component.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
let nextId$5 = 0;
/** @type {?} */
const MAPPING$1 = {
    'negative': 'nx-radio-toggle--negative',
    'small': 'nx-radio-toggle--small',
};
class NxRadioToggleComponent {
    /**
     * @param {?} renderer
     * @param {?} _changeDetectorRef
     * @param {?} ngControl
     * @param {?} _errorStateMatcher
     * @param {?} _parentForm
     * @param {?} _parentFormGroup
     */
    constructor(renderer, _changeDetectorRef, ngControl, _errorStateMatcher, _parentForm, _parentFormGroup) {
        this.renderer = renderer;
        this._changeDetectorRef = _changeDetectorRef;
        this.ngControl = ngControl;
        this._errorStateMatcher = _errorStateMatcher;
        this._parentForm = _parentForm;
        this._parentFormGroup = _parentFormGroup;
        this._toggleId = (nextId$5++).toString();
        this._destroyed = new Subject();
        this._disabled = false;
        /**
         * \@docs-private
         */
        this.errorState = false;
        // emits to signal children to run change detection
        this._disableChange = new Subject();
        /**
         * \@docs-private
         */
        this.toggleButtons = new QueryList();
        this.onTouchedCallback = (/**
         * @return {?}
         */
        () => { });
        this.onChangeCallback = (/**
         * @param {?} option
         * @return {?}
         */
        (option) => { });
        if (this.ngControl) {
            // Note: we provide the value accessor through here, instead of
            // the `providers` to avoid running into a circular import.
            this.ngControl.valueAccessor = this;
        }
    }
    /**
     * Sets the component to the disabled state.
     * @param {?} value
     * @return {?}
     */
    set disabled(value) {
        /** @type {?} */
        const coerced = coerceBooleanProperty(value);
        if (this._disabled !== coerced) {
            this._disabled = coerced;
            this._disableChange.next();
        }
    }
    /**
     * @return {?}
     */
    get disabled() {
        return this._disabled;
    }
    /**
     * Sets the name used for accessibility.
     * @param {?} value
     * @return {?}
     */
    set name(value) {
        if (this._name !== value) {
            this._name = value;
            this._changeDetectorRef.markForCheck();
        }
    }
    /**
     * @return {?}
     */
    get name() {
        return this._name;
    }
    /**
     * @return {?}
     */
    ngAfterViewInit() {
        this.subscribeToToggleButtonsChange();
    }
    /**
     * @return {?}
     */
    ngAfterContentInit() {
        /** @type {?} */
        const changedOrDestroyed = merge(this.toggleButtons.changes, this._destroyed);
        merge(...this.toggleButtons.map((/**
         * @param {?} button
         * @return {?}
         */
        (button) => button.onChecked)))
            .pipe(takeUntil(changedOrDestroyed))
            .subscribe((/**
         * @param {?} change
         * @return {?}
         */
        (change) => {
            this._selection = change.value;
            this.onChangeCallback(this._selection);
        }));
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this._destroyed.next();
        this._destroyed.complete();
        this._disableChange.complete();
    }
    /**
     * @return {?}
     */
    ngDoCheck() {
        if (this.ngControl) {
            // We need to re-evaluate this on every change detection cycle, because there are some
            // error triggers that we can't subscribe to (e.g. parent form submissions). This means
            // that whatever logic is in here has to be super lean or we risk destroying the performance.
            this.updateErrorState();
        }
    }
    /**
     * \@docs-private
     * @return {?}
     */
    subscribeToToggleButtonsChange() {
        this.toggleButtons.changes
            .pipe(startWith(this.toggleButtons), filter((/**
         * @param {?} toggles
         * @return {?}
         */
        toggles => toggles.length > 0)), takeUntil(this._destroyed)).subscribe((/**
         * @param {?} toggles
         * @return {?}
         */
        (toggles) => {
            toggles.forEach((/**
             * @param {?} toggle
             * @return {?}
             */
            toggle => {
                toggle.resetClasses();
                if (toggle.value === this.selection) {
                    // We need to defer the selection for the edge case that the button with the value of this.selection
                    // didn't exist yet but was added afterwards to prevent changed after checked errors
                    setTimeout((/**
                     * @return {?}
                     */
                    () => toggle.select()));
                }
            }));
            toggles.first.setFirstButton();
            toggles.last.setLastButton();
        }));
    }
    /**
     * @param {?} onChangeCallback
     * @return {?}
     */
    registerOnChange(onChangeCallback) {
        this.onChangeCallback = onChangeCallback;
    }
    /**
     * @param {?} onTouchedCallback
     * @return {?}
     */
    registerOnTouched(onTouchedCallback) {
        this.onTouchedCallback = onTouchedCallback;
    }
    /**
     * Preselects the respective options.
     * @param {?} value
     * @return {?}
     */
    writeValue(value) {
        this._selection = value;
        /** @type {?} */
        const correspondingButton = this.toggleButtons.find((/**
         * @param {?} button
         * @return {?}
         */
        (button) => button.value === this._selection));
        if (correspondingButton) {
            ((/** @type {?} */ (correspondingButton))).select();
        }
    }
    /**
     * @param {?} isDisabled
     * @return {?}
     */
    setDisabledState(isDisabled) {
        this.disabled = isDisabled;
    }
    /**
     * \@docs-private
     * @return {?}
     */
    get id() {
        return `nx-radio-toggle-${this._toggleId}`;
    }
    /**
     * Sets the modifiers for the component.
     * @param {?} value
     * @return {?}
     */
    set style(value) {
        /** @type {?} */
        const modifierClasses = mapClassNames(value, [], MAPPING$1);
        modifierClasses.split(' ')
            .forEach((/**
         * @param {?} className
         * @return {?}
         */
        className => this.renderer.addClass(this.toggleContainer.nativeElement, className)));
    }
    /**
     * \@docs-private
     * @param {?} selection
     * @return {?}
     */
    set selection(selection) {
        this._selection = selection;
        this.onChangeCallback(selection);
    }
    /**
     * @return {?}
     */
    get selection() {
        return this._selection;
    }
    /**
     * \@docs-private
     * @param {?} value
     * @return {?}
     */
    change(value) {
        this.onChangeCallback(value);
        if (this.onTouchedCallback) {
            this.onTouchedCallback();
        }
    }
    /**
     * \@docs-private
     * @return {?}
     */
    updateErrorState() {
        /** @type {?} */
        const oldState = this.errorState;
        /** @type {?} */
        const parent = this._parentFormGroup || this._parentForm;
        /** @type {?} */
        const control = this.ngControl ? (/** @type {?} */ (this.ngControl.control)) : null;
        /** @type {?} */
        const newState = this._errorStateMatcher.isErrorState(control, parent);
        if (newState !== oldState) {
            this.errorState = newState;
        }
    }
}
NxRadioToggleComponent.decorators = [
    { type: Component, args: [{
                selector: 'nx-radio-toggle',
                template: "<div #toggleContainer class=\"nx-radio-toggle\" role=\"radiogroup\" [attr.aria-label]=\"name\">\n   <ng-content></ng-content>\n</div>\n",
                changeDetection: ChangeDetectionStrategy.OnPush,
                styles: [":host{display:block}.nx-radio-toggle{display:flex;height:100%}@media (max-width:703px){.nx-radio-toggle{flex-direction:column;text-align:center;width:100%;justify-content:center;align-items:center}}"]
            }] }
];
/** @nocollapse */
NxRadioToggleComponent.ctorParameters = () => [
    { type: Renderer2 },
    { type: ChangeDetectorRef },
    { type: NgControl, decorators: [{ type: Optional }, { type: Self }] },
    { type: ErrorStateMatcher },
    { type: NgForm, decorators: [{ type: Optional }] },
    { type: FormGroupDirective, decorators: [{ type: Optional }] }
];
NxRadioToggleComponent.propDecorators = {
    disabled: [{ type: Input, args: ['nxDisabled',] }],
    toggleContainer: [{ type: ViewChild, args: ['toggleContainer', { static: true },] }],
    name: [{ type: Input, args: ['nxName',] }],
    toggleButtons: [{ type: ContentChildren, args: [NxRadioToggleButtonBaseComponent,] }],
    writeValue: [{ type: Input, args: ['nxSelection',] }],
    style: [{ type: Input, args: ['nxStyle',] }]
};
if (false) {
    /**
     * @type {?}
     * @private
     */
    NxRadioToggleComponent.prototype._toggleId;
    /**
     * @type {?}
     * @private
     */
    NxRadioToggleComponent.prototype._selection;
    /**
     * @type {?}
     * @private
     */
    NxRadioToggleComponent.prototype._destroyed;
    /**
     * @type {?}
     * @private
     */
    NxRadioToggleComponent.prototype._disabled;
    /**
     * \@docs-private
     * @type {?}
     */
    NxRadioToggleComponent.prototype.errorState;
    /** @type {?} */
    NxRadioToggleComponent.prototype._disableChange;
    /**
     * @type {?}
     * @private
     */
    NxRadioToggleComponent.prototype.toggleContainer;
    /**
     * @type {?}
     * @private
     */
    NxRadioToggleComponent.prototype._name;
    /**
     * \@docs-private
     * @type {?}
     */
    NxRadioToggleComponent.prototype.toggleButtons;
    /**
     * @type {?}
     * @private
     */
    NxRadioToggleComponent.prototype.onTouchedCallback;
    /**
     * @type {?}
     * @private
     */
    NxRadioToggleComponent.prototype.onChangeCallback;
    /**
     * @type {?}
     * @private
     */
    NxRadioToggleComponent.prototype.renderer;
    /**
     * @type {?}
     * @private
     */
    NxRadioToggleComponent.prototype._changeDetectorRef;
    /**
     * \@docs-private
     * @type {?}
     */
    NxRadioToggleComponent.prototype.ngControl;
    /**
     * @type {?}
     * @private
     */
    NxRadioToggleComponent.prototype._errorStateMatcher;
    /**
     * @type {?}
     * @private
     */
    NxRadioToggleComponent.prototype._parentForm;
    /**
     * @type {?}
     * @private
     */
    NxRadioToggleComponent.prototype._parentFormGroup;
}

/**
 * @fileoverview added by tsickle
 * Generated from: radio-toggle/radio-toggle-button.component.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * \@docs-private
 */
class NxRadioToggleButtonChange {
    /**
     * @param {?} source
     * @param {?} value
     */
    constructor(source, value) {
        this.source = source;
        this.value = value;
    }
}
if (false) {
    /** @type {?} */
    NxRadioToggleButtonChange.prototype.source;
    /** @type {?} */
    NxRadioToggleButtonChange.prototype.value;
}
class NxRadioToggleButtonComponent extends NxRadioToggleButtonBaseComponent {
    /**
     * @param {?} radioToggle
     * @param {?} renderer
     * @param {?} _changeDetectorRef
     * @param {?} _toggleDispatcher
     */
    constructor(radioToggle, 
    /** @docs-private */
    renderer, _changeDetectorRef, _toggleDispatcher) {
        super(renderer);
        this.radioToggle = radioToggle;
        this._changeDetectorRef = _changeDetectorRef;
        this._toggleDispatcher = _toggleDispatcher;
        /**
         * \@docs-private
         */
        // emits when the button is checked to notify the group
        this.onChecked = new Subject();
        this._destroyed = new Subject();
        this._disabled = false;
        this._selected = false;
        /**
         * Unregister function for _expansionDispatcher.
         */
        this._removeUniqueSelectionListener = (/**
         * @return {?}
         */
        () => { });
        this._removeUniqueSelectionListener = this._toggleDispatcher.listen((/**
         * @param {?} id
         * @param {?} radioToggleId
         * @return {?}
         */
        (id, radioToggleId) => {
            if (this.radioToggle && this.radioToggle.id === radioToggleId && this.id !== id) {
                this._selected = false;
                // need to let change detector know in case that the select() function was called on another button
                this._changeDetectorRef.markForCheck();
            }
        }));
        this.radioToggle._disableChange.pipe(takeUntil(this._destroyed)).subscribe((/**
         * @return {?}
         */
        () => {
            this._changeDetectorRef.markForCheck();
        }));
    }
    /**
     * \@docs-private
     * @param {?} value
     * @return {?}
     */
    set disabled(value) {
        this._disabled = coerceBooleanProperty(value);
        this._changeDetectorRef.markForCheck();
    }
    /**
     * @return {?}
     */
    get disabled() {
        return this._disabled || (this.radioToggle && this.radioToggle.disabled);
    }
    /**
     * Sets the checked state and notify siblings and the parent group about the change
     * @param {?} value
     * @return {?}
     */
    // Only use this if you want the onChecked event to be fired, this will inform the parent about the change!
    // To select a button without firing the event use the select() function
    set selected(value) {
        if (this._selected !== value) {
            this._selected = value;
            if (this._selected) {
                this._notifySiblings();
                this._emitCheckedEvent();
                if (this.radioToggle !== null) {
                    this.radioToggle.change(this.value);
                }
            }
            this._changeDetectorRef.markForCheck();
        }
    }
    /**
     * @return {?}
     */
    get selected() {
        return this._selected;
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this._removeUniqueSelectionListener();
        this._destroyed.next();
        this._destroyed.complete();
    }
    /**
     * \@docs-private
     * @return {?}
     */
    get toggleId() {
        return this.radioToggle.id;
    }
    /**
     * \@docs-private
     * @return {?}
     */
    get id() {
        return this.toggleButtonId;
    }
    /**
     * @private
     * @return {?}
     */
    _notifySiblings() {
        /** @type {?} */
        const toggleId = this.radioToggle ? this.radioToggle.id : this.id;
        this._toggleDispatcher.notify(this.id, toggleId);
    }
    /**
     * @private
     * @return {?}
     */
    _emitCheckedEvent() {
        this.onChecked.next(new NxRadioToggleButtonChange(this, this.value));
    }
    // Does NOT emit the onChecked event. Useful when you need to set initial
    // state. Used by the parent to set checked states on initialization and during
    // writeValue() changes.
    /**
     * \@docs-private
     * @return {?}
     */
    select() {
        if (!this._selected) {
            this._selected = true;
            this._notifySiblings();
        }
        this._changeDetectorRef.markForCheck();
    }
    /**
     * \@docs-private
     * @return {?}
     */
    onKeyupSpace() {
        this._selected = false;
        this._notifySiblings();
    }
    /**
     * \@docs-private
     * @return {?}
     */
    _controlInvalid() {
        return !!(this.radioToggle && this.radioToggle.errorState);
    }
}
NxRadioToggleButtonComponent.decorators = [
    { type: Component, args: [{
                selector: 'nx-radio-toggle-button',
                changeDetection: ChangeDetectionStrategy.OnPush,
                template: "<input [attr.id]=\"toggleButtonId\"\n    #toggleInput\n    [attr.name]=\"toggleId\"\n    [checked]=\"selected\"\n    class=\"nx-radio-toggle__input\"\n    type=\"radio\"\n    (click)=\"selected = true\"\n    [disabled]=\"disabled\">\n<div (click)=\"triggerInputClick($event)\" #toggleButtonLabelContainer class=\"nx-radio-toggle__label-container\">\n  <label [attr.for]=\"toggleButtonId\" class=\"nx-radio-toggle__label\">\n      <nx-icon class=\"nx-toggle-button__mobile-check\" name=\"check\" aria-hidden=\"true\"></nx-icon>\n      <ng-content></ng-content>\n  </label>\n</div>\n\n\n",
                providers: [
                    {
                        provide: NxRadioToggleButtonBaseComponent, useExisting: forwardRef((/**
                         * @return {?}
                         */
                        () => NxRadioToggleButtonComponent))
                    }
                ],
                host: {
                    '[class.has-error]': '_controlInvalid() || null',
                    '[attr.aria-invalid]': '_controlInvalid() || null'
                },
                styles: [":host{display:flex;position:relative;flex-direction:row}:host.has-error .nx-radio-toggle__input:checked+.nx-radio-toggle__label-container{border-color:#dc3149;border-color:var(--danger,#dc3149);background-color:#dc3149;background-color:var(--danger,#dc3149)}:host.has-error .nx-radio-toggle__label-container{border-color:#dc3149;border-color:var(--danger,#dc3149);color:#dc3149;color:var(--danger,#dc3149)}:host.has-error:hover .nx-radio-toggle__label-container{color:#fff}.nx-radio-toggle__input{opacity:0;position:absolute}.nx-radio-toggle__input:active+.nx-radio-toggle__label-container{background-color:#003781;background-color:var(--toggle-button-active-background-color,#003781);border-color:#003781;border-color:var(--toggle-button-active-border-color,#003781);color:#fff;color:var(--toggle-button-active-text-color,#fff)}.nx-radio-toggle__input:checked:disabled+.nx-radio-toggle__label-container{background-color:rgba(0,122,179,.4);background-color:var(--toggle-button-disabled-selected-background-color,rgba(0,122,179,.4));border-color:transparent;border-color:var(--toggle-button-disabled-selected-border-color,transparent);color:rgba(255,255,255,.4);color:var(--toggle-button-disabled-selected-text-color,rgba(255,255,255,.4))}.nx-radio-toggle__input:disabled+.nx-radio-toggle__label-container{background-color:#fff;background-color:var(--toggle-button-disabled-background-color,#fff);border-color:rgba(0,122,179,.4);border-color:var(--toggle-button-disabled-border-color,rgba(0,122,179,.4));color:rgba(0,97,146,.4);color:var(--toggle-button-disabled-text-color,rgba(0,97,146,.4));cursor:not-allowed}.nx-radio-toggle__input:disabled+.nx-radio-toggle__label-container .nx-radio-toggle__label{cursor:not-allowed}@media screen and (-ms-high-contrast:active){.nx-radio-toggle__input:disabled+.nx-radio-toggle__label-container{border-color:GrayText;color:GrayText}}.nx-radio-toggle__input:checked+.nx-radio-toggle__label-container{background-color:#007ab3;background-color:var(--toggle-button-selected-background-color,#007ab3);border-color:#007ab3;border-color:var(--toggle-button-selected-border-color,#007ab3);color:#fff;color:var(--toggle-button-selected-text-color,#fff);cursor:default}.nx-radio-toggle__input:checked+.nx-radio-toggle__label-container .nx-radio-toggle__label{cursor:default}.nx-toggle-button__mobile-check{display:none;font-size:24px;margin-right:8px;height:24px}:host-context(.nx-radio-toggle--small) .nx-radio-toggle__label-container{font-size:14px;font-size:var(--toggle-button-small-font-size,14px);line-height:16px;line-height:var(--toggle-button-small-line-height,16px);font-weight:600;font-weight:var(--toggle-button-small-font-weight,600);letter-spacing:1px;letter-spacing:var(--toggle-button-small-letter-spacing,1px);min-height:16px;padding:6px;text-transform:none}.nx-radio-toggle{-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;cursor:pointer}.nx-radio-toggle__label-container.nx-radio-toggle__label-container--first{border-radius:4px 0 0 4px;border-width:2px 0 2px 2px}@media (max-width:703px){:host{width:100%}.nx-radio-toggle__input:checked+.nx-radio-toggle__label-container .nx-toggle-button__mobile-check{display:inline-block}:host-context(.nx-radio-toggle--small) .nx-radio-toggle__label-container{font-size:16px;font-size:var(--toggle-button-large-font-size,16px);line-height:24px;line-height:var(--toggle-button-large-line-height,24px);font-weight:600;font-weight:var(--toggle-button-large-font-weight,600);letter-spacing:1px;letter-spacing:var(--toggle-button-large-letter-spacing,1px);padding:11px 31px}.nx-radio-toggle__label-container.nx-radio-toggle__label-container--first{border-width:2px 2px 1px;border-radius:4px 4px 0 0}}.nx-radio-toggle__label-container.nx-radio-toggle__label-container--last{border-top-right-radius:4px;border-bottom-right-radius:4px;border-width:2px}.nx-radio-toggle__label-container{font-size:16px;font-size:var(--toggle-button-large-font-size,16px);line-height:24px;line-height:var(--toggle-button-large-line-height,24px);font-weight:600;font-weight:var(--toggle-button-large-font-weight,600);letter-spacing:1px;letter-spacing:var(--toggle-button-large-letter-spacing,1px);padding:10px 30px;color:#006192;color:var(--toggle-button-unselected-text-color,#006192);background-color:transparent;background-color:var(--toggle-button-unselected-background-color,transparent);border-color:#007ab3;border-color:var(--toggle-button-unselected-border-color,#007ab3);border-style:solid;border-radius:0;border-width:2px 0 2px 2px;cursor:pointer;flex-grow:1;text-align:center;text-transform:uppercase;text-transform:var(--button-text-transform,uppercase);transition:background-color .2s,border-color .2s,color .2s;display:flex;align-items:center;height:100%;min-height:24px}@media (max-width:703px){.nx-radio-toggle__label-container.nx-radio-toggle__label-container--last{border-width:1px 2px 2px;border-radius:0 0 4px 4px}.nx-radio-toggle__label-container.nx-radio-toggle__label-container--last.nx-radio-toggle__label-container--first{border-radius:4px;border-width:2px}.nx-radio-toggle__label-container{border-width:1px 2px;justify-content:center;padding:11px 31px}}.nx-radio-toggle__label-container:hover{background-color:#006192;background-color:var(--toggle-button-hover-background-color,#006192);border-color:#006192;border-color:var(--toggle-button-hover-border-color,#006192);color:#fff;color:var(--toggle-button-hover-text-color,#fff)}@media screen and (-ms-high-contrast:active){.nx-radio-toggle__input:checked+.nx-radio-toggle__label-container{background-color:highlight;border-color:buttonText}.nx-radio-toggle__input:checked+.nx-radio-toggle__label-container .nx-radio-toggle__label{-ms-high-contrast-adjust:none;color:highlightText}.nx-radio-toggle__label-container{border-color:buttonText;background-color:buttonFace;color:buttonText}.nx-radio-toggle__label-container .nx-radio-toggle__label{-ms-high-contrast-adjust:none}}:host-context(.nx-radio-toggle--negative) .nx-radio-toggle__input:focus+.nx-radio-toggle__label-container{background-color:#d9d9d9;border-color:#d9d9d9;color:#007ab3}:host-context(.nx-radio-toggle--negative) .nx-radio-toggle__input:active+.nx-radio-toggle__label-container{background-color:#c2c2c2;border-color:#c2c2c2;color:#007ab3}:host-context(.nx-radio-toggle--negative) .nx-radio-toggle__input:disabled:checked+.nx-radio-toggle__label-container{background-color:rgba(255,255,255,.4);border-color:transparent;color:rgba(65,65,65,.4)}:host-context(.nx-radio-toggle--negative) .nx-radio-toggle__input:disabled+.nx-radio-toggle__label-container{background-color:transparent;border-color:rgba(255,255,255,.4);color:rgba(255,255,255,.4)}:host-context(.nx-radio-toggle--negative) .nx-radio-toggle__input:checked+.nx-radio-toggle__label-container{background-color:#fff;border-color:#fff;color:#006192}:host-context(.nx-radio-toggle--negative) .nx-radio-toggle__label-container{border-color:#fff;color:#fff}:host-context(.nx-radio-toggle--negative) .nx-radio-toggle__label-container:hover{background-color:#d9d9d9;border-color:#d9d9d9;color:#006192}.nx-radio-toggle__label{display:flex;align-items:center;cursor:pointer}:host-context([data-whatinput=keyboard]) .nx-radio-toggle__input:focus+.nx-radio-toggle__label-container{box-shadow:0 0 0 2px #fff,0 0 0 6px #009de6;box-shadow:var(--focus-box-shadow,0 0 0 2px #fff,0 0 0 6px #009de6);z-index:1}@media screen and (-ms-high-contrast:active){:host-context([data-whatinput=keyboard]) .nx-radio-toggle__input:focus+.nx-radio-toggle__label-container{box-shadow:0 0 0 2px background,0 0 0 6px windowText}}"]
            }] }
];
/** @nocollapse */
NxRadioToggleButtonComponent.ctorParameters = () => [
    { type: NxRadioToggleComponent, decorators: [{ type: Inject, args: [forwardRef((/**
                     * @return {?}
                     */
                    () => NxRadioToggleComponent)),] }] },
    { type: Renderer2 },
    { type: ChangeDetectorRef },
    { type: UniqueSelectionDispatcher }
];
NxRadioToggleButtonComponent.propDecorators = {
    disabled: [{ type: Input, args: ['nxDisabled',] }],
    selected: [{ type: Input, args: ['nxSelected',] }],
    onKeyupSpace: [{ type: HostListener, args: ['keyup.space',] }]
};
if (false) {
    /**
     * \@docs-private
     * @type {?}
     */
    NxRadioToggleButtonComponent.prototype.onChecked;
    /**
     * @type {?}
     * @private
     */
    NxRadioToggleButtonComponent.prototype._destroyed;
    /**
     * @type {?}
     * @private
     */
    NxRadioToggleButtonComponent.prototype._disabled;
    /**
     * @type {?}
     * @private
     */
    NxRadioToggleButtonComponent.prototype._selected;
    /**
     * Unregister function for _expansionDispatcher.
     * @type {?}
     * @private
     */
    NxRadioToggleButtonComponent.prototype._removeUniqueSelectionListener;
    /**
     * @type {?}
     * @private
     */
    NxRadioToggleButtonComponent.prototype.radioToggle;
    /**
     * @type {?}
     * @private
     */
    NxRadioToggleButtonComponent.prototype._changeDetectorRef;
    /**
     * @type {?}
     * @private
     */
    NxRadioToggleButtonComponent.prototype._toggleDispatcher;
}

/**
 * @fileoverview added by tsickle
 * Generated from: radio-toggle/radio-toggle.module.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class NxRadioToggleModule {
}
NxRadioToggleModule.decorators = [
    { type: NgModule, args: [{
                declarations: [NxRadioToggleComponent, NxRadioToggleButtonComponent],
                exports: [NxRadioToggleComponent, NxRadioToggleButtonComponent],
                imports: [CommonModule, FormsModule, NxIconModule]
            },] }
];

/**
 * @fileoverview added by tsickle
 * Generated from: radio-toggle/public-api.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * Generated from: spinner/spinner.component.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const DEFAULT_SIZE$1 = 'small';
class NxSpinnerComponent {
    /**
     * @param {?} _changeDetectorRef
     */
    constructor(_changeDetectorRef) {
        this._changeDetectorRef = _changeDetectorRef;
        this._size = DEFAULT_SIZE$1;
        this._negative = false;
    }
    /**
     * Sets the size of the spinner. Default is 'small'.
     * @param {?} value
     * @return {?}
     */
    set size(value) {
        if (value !== this._size) {
            this._size = value;
            this._changeDetectorRef.markForCheck();
        }
    }
    /**
     * @return {?}
     */
    get size() {
        return this._size;
    }
    /**
     * Whether the spinner should use a negative styling.
     * @param {?} value
     * @return {?}
     */
    set negative(value) {
        if (value !== this._negative) {
            this._negative = coerceBooleanProperty(value);
            this._changeDetectorRef.markForCheck();
        }
    }
    /**
     * @return {?}
     */
    get negative() {
        return this._negative;
    }
}
NxSpinnerComponent.decorators = [
    { type: Component, args: [{
                selector: 'nx-spinner',
                template: "<div class=\"nx-spinner__spin-block\">\n  <div class=\"nx-spinner__edge-left\"></div>\n  <div class=\"nx-spinner__edge-right\"></div>\n</div>",
                changeDetection: ChangeDetectionStrategy.OnPush,
                host: {
                    '[class.nx-spinner--small]': 'size === "small"',
                    '[class.nx-spinner--medium]': 'size === "medium"',
                    '[class.nx-spinner--large]': 'size === "large"',
                    '[class.nx-spinner--negative]': 'negative',
                    '[attr.role]': '"status"',
                    '[attr.aria-busy]': '"true"',
                    '[attr.aria-live]': '"assertive"',
                },
                styles: ["@-webkit-keyframes spin{0%{transform:rotate(45deg)}100%{transform:rotate(405deg)}}@keyframes spin{0%{transform:rotate(45deg)}100%{transform:rotate(405deg)}}:host{position:relative;display:block}:host(.nx-spinner--small){width:16px;height:16px}:host(.nx-spinner--medium){width:24px;height:24px}:host(.nx-spinner--large){width:40px;height:40px}.nx-spinner__spin-block{width:100%;height:100%;transform:rotate(45deg);border-style:solid;border-radius:50%;border-color:#007ab3 #ececec #ececec;border-color:var(--spinner-background-color,#ececec);border-top-color:var(--spinner-indicator-color,#007ab3);-webkit-animation-name:spin;animation-name:spin;-webkit-animation-duration:.8s;animation-duration:.8s;-webkit-animation-iteration-count:infinite;animation-iteration-count:infinite;-webkit-animation-timing-function:linear;animation-timing-function:linear}:host(.nx-spinner--small) .nx-spinner__spin-block{border-width:calc(1.6px)}:host(.nx-spinner--medium) .nx-spinner__spin-block{border-width:calc(2.4px)}:host(.nx-spinner--large) .nx-spinner__spin-block{border-width:calc(4px)}.nx-spinner__edge-left,.nx-spinner__edge-right{width:12%;height:12%;border-radius:50%;background-color:#007ab3;background-color:var(--spinner-indicator-color,#007ab3);position:absolute;top:4%}.nx-spinner__edge-left{left:4%}.nx-spinner__edge-right{right:4%}:host(.nx-spinner--negative) .nx-spinner__spin-block{border-color:#fff rgba(250,247,239,.35) rgba(250,247,239,.35)}:host(.nx-spinner--negative) .nx-spinner__edge-left,:host(.nx-spinner--negative) .nx-spinner__edge-right{background-color:#fff}@media screen and (-ms-high-contrast:active){.nx-spinner__spin-block{border-color:window highlight highlight}}"]
            }] }
];
/** @nocollapse */
NxSpinnerComponent.ctorParameters = () => [
    { type: ChangeDetectorRef }
];
NxSpinnerComponent.propDecorators = {
    size: [{ type: Input, args: ['nxSize',] }],
    negative: [{ type: Input }]
};
if (false) {
    /**
     * @type {?}
     * @private
     */
    NxSpinnerComponent.prototype._size;
    /**
     * @type {?}
     * @private
     */
    NxSpinnerComponent.prototype._negative;
    /**
     * @type {?}
     * @private
     */
    NxSpinnerComponent.prototype._changeDetectorRef;
}

/**
 * @fileoverview added by tsickle
 * Generated from: spinner/spinner.module.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class NxSpinnerModule {
}
NxSpinnerModule.decorators = [
    { type: NgModule, args: [{
                declarations: [
                    NxSpinnerComponent
                ],
                imports: [
                    CommonModule
                ],
                exports: [
                    NxSpinnerComponent
                ],
                bootstrap: [],
                providers: []
            },] }
];

/**
 * @fileoverview added by tsickle
 * Generated from: spinner/public-api.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * Generated from: modal/modal.service.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * \@docs-private
 */
class NxModalService {
    constructor() {
        this.subject = new Subject();
        this.close$ = this.subject.asObservable();
    }
    /**
     * @return {?}
     */
    close() {
        this.subject.next();
    }
}
NxModalService.decorators = [
    { type: Injectable }
];
if (false) {
    /**
     * @type {?}
     * @private
     */
    NxModalService.prototype.subject;
    /** @type {?} */
    NxModalService.prototype.close$;
}

/**
 * @fileoverview added by tsickle
 * Generated from: modal/animations.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const fadeIn = animation([
    style({ opacity: 0 }),
    animate('300ms', style({ opacity: 1 }))
]);
/** @type {?} */
const fadeOut = animation(animate('300ms', style({ opacity: 0 })));
/** @type {?} */
const scaleUp = animation([
    style({ transform: 'scale(1)', opacity: 1 }),
    animate('250ms', style({ transform: 'scale(1.3)', opacity: 0 }))
]);
/** @type {?} */
const scaleDown = animation([
    style({ transform: 'scale(1.3)', opacity: 0 }),
    animate('250ms', style({ transform: 'scale(1)', opacity: 1 }))
]);

/**
 * @fileoverview added by tsickle
 * Generated from: modal/modal.component.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Container for the action buttons in a modal. Has a fixed position at the bottom of the modal on scroll.
 */
class NxModalActionsDirective {
}
NxModalActionsDirective.decorators = [
    { type: Directive, args: [{
                selector: '[nxModalActions]',
                host: {
                    '[class.nx-modal__actions]': 'true'
                }
            },] }
];
/**
 * Scrollable container for the content of a modal.
 */
class NxModalContentDirective {
}
NxModalContentDirective.decorators = [
    { type: Directive, args: [{
                selector: '[nxModalContent]',
                host: {
                    '[class.nx-modal__content]': 'true'
                }
            },] }
];
class NxModalComponent {
    /**
     * @param {?} modalService
     * @param {?} eventManager
     * @param {?} _changeDetectorRef
     */
    constructor(modalService, eventManager, _changeDetectorRef) {
        this.modalService = modalService;
        this.eventManager = eventManager;
        this._changeDetectorRef = _changeDetectorRef;
        this._closeButtonLabel = 'Close dialog';
        /**
         * Whether the modal view should close when the user hits the escape key.
         * Default is true.
         */
        this.hideOnEsc = true;
        /**
         * Whether the modal view should close when the user clicks on the backdrop.
         * Default is true.
         */
        this.hideOnClickOutside = true;
        /**
         * Whether the modal view should have a close icon in the upper right corner.
         * Default is true.
         */
        this.showCloseIcon = true;
        /**
         * An event emitted when the user clicks on the backdrop or uses the built-in close button.
         * This event can be applied in conjunction with the custom open state handling
         * of a modal to close it when requested by the user.
         */
        this.closeEvent = new EventEmitter();
        this.closeSubscription = Subscription.EMPTY;
        this.removeEventListener = undefined;
    }
    /**
     * Sets the 'aria-label' of the modal close button needed for accessibility.
     *
     * Default value is 'Close dialog'.
     * @param {?} value
     * @return {?}
     */
    set closeButtonLabel(value) {
        if (value !== this._closeButtonLabel) {
            this._closeButtonLabel = value;
            this._changeDetectorRef.markForCheck();
        }
    }
    /**
     * @return {?}
     */
    get closeButtonLabel() {
        return this._closeButtonLabel;
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.closeSubscription = this.modalService.close$.subscribe((/**
         * @return {?}
         */
        () => this.closeEvent.emit()));
        this.removeEventListener = this.eventManager.addGlobalEventListener('window', 'keyup.esc', (/**
         * @return {?}
         */
        () => {
            if (this.hideOnEsc) {
                this.modalService.close();
            }
        }));
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this.removeEventListener();
        this.closeSubscription.unsubscribe();
    }
    /**
     * \@docs-private
     * @return {?}
     */
    clickOutsideModal() {
        if (this.hideOnClickOutside) {
            this.modalService.close();
        }
    }
    /**
     * \@docs-private
     * @return {?}
     */
    closeButtonClick() {
        this.modalService.close();
    }
    /**
     * \@docs-private
     * @param {?} evt
     * @return {?}
     */
    cancelClick(evt) {
        evt.stopPropagation();
    }
}
NxModalComponent.decorators = [
    { type: Component, args: [{
                selector: 'nx-modal',
                template: "<div class=\"nx-modal\" role=\"dialog\" cdkTrapFocus cdkTrapFocusAutoCapture cdkFocusInitial>\n  <div class=\"nx-modal__backdrop\" (click)=\"clickOutsideModal()\">\n    <div class=\"nx-modal__position\">\n      <div class=\"nx-modal__container\" (click)=\"cancelClick($event)\" [@scaleUpDown]>\n\n        <button\n          (click)=\"closeButtonClick()\"\n          *ngIf=\"showCloseIcon\"\n          [attr.aria-label]=\"closeButtonLabel\"\n          class=\"nx-modal__close\"\n          type=\"button\">\n          <nx-icon name=\"close\"></nx-icon>\n        </button>\n\n        <div class=\"nx-modal__content-wrapper\">\n          <ng-container *ngIf=\"body else projectContent\">\n            <ng-container *ngTemplateOutlet=\"body\"></ng-container>\n          </ng-container>\n\n          <ng-template #projectContent>\n            <ng-content></ng-content>\n          </ng-template>\n        </div>\n      </div>\n    </div>\n  </div>\n</div>\n",
                changeDetection: ChangeDetectionStrategy.OnPush,
                animations: [
                    trigger('fadeInOut', [
                        transition(':enter', [
                            useAnimation(fadeIn),
                            query('@scaleUpDown', [
                                animateChild()
                            ])
                        ]),
                        transition(':leave', [
                            query('@scaleUpDown', [
                                animateChild()
                            ]),
                            useAnimation(fadeOut)
                        ])
                    ]),
                    trigger('scaleUpDown', [
                        transition(':enter', useAnimation(scaleDown)),
                        transition(':leave', useAnimation(scaleUp))
                    ])
                ],
                host: {
                    '[@fadeInOut]': '',
                    '[class.nx-modal--fixed-width]': 'size === "fixed"'
                },
                styles: [":host{position:relative;z-index:1000}.nx-modal{display:flex;position:fixed;width:100vw;height:100vh;top:0;bottom:0;left:0;right:0;z-index:1000;align-items:center;justify-content:center;transition:opacity .3s}.nx-modal__backdrop{background-color:rgba(0,0,0,.35);height:100%;left:0;position:absolute;top:0;width:100%;z-index:-1}.nx-modal__position{position:absolute;display:inline-block;top:50%;left:50%;transform:translate(-50%,-50%);z-index:20}.nx-modal__container{border-radius:4px;box-shadow:0 8px 24px rgba(65,65,65,.35);background:#fff;background:var(--modal-background-color,#fff);color:#414141;color:var(--modal-text-color,#414141)}.nx-modal__content-wrapper{padding:40px 40px 48px;max-height:calc(100vh - 48px);overflow-y:auto}@media (max-width:703px){.nx-modal__content-wrapper{max-height:70vh;padding:40px 32px 48px}}.nx-modal__close{background-color:transparent;border:none;cursor:pointer;position:absolute;top:16px;right:16px;height:24px;outline:0;padding:0;color:#414141;color:var(--modal-close-icon-color,#414141)}.nx-modal__close nx-icon{font-size:24px}.nx-modal__close::-moz-focus-inner{border:0}:host-context([data-whatinput=keyboard]) .nx-modal__close:focus{box-shadow:0 0 0 2px #fff,0 0 0 6px #009de6;box-shadow:var(--focus-box-shadow,0 0 0 2px #fff,0 0 0 6px #009de6);border-radius:4px}@media (max-width:703px){.nx-modal__position{width:100%}.nx-modal__container{position:relative;max-width:calc(100vw - 16px);max-height:70vh;margin:0 auto}}:host(.nx-modal--fixed-width) .nx-modal__container{width:736px;max-width:calc(100vw - 16px)}::ng-deep .nx-modal__actions{height:72px;border-top:1px solid #d9d9d9;border-top:1px solid var(--modal-actions-border-color,#d9d9d9);display:flex;align-items:center;justify-content:flex-end;padding:0 40px;position:absolute;bottom:0;left:0;width:100%;border-bottom-left-radius:4px;border-bottom-right-radius:4px;background:#fff;background:var(--modal-actions-background-color,#fff)}::ng-deep .nx-modal__content{overflow-y:auto;max-height:calc(100vh - 72px - 48px)}@media (max-width:703px){::ng-deep .nx-modal__content{max-height:calc(70vh - 72px - 48px)}}@media screen and (-ms-high-contrast:active){:host-context([data-whatinput=keyboard]) .nx-modal__close:focus{box-shadow:0 0 0 2px background,0 0 0 6px windowText}.nx-modal__content-wrapper,::ng-deep .nx-modal__actions{border:2px solid windowText}}"]
            }] }
];
/** @nocollapse */
NxModalComponent.ctorParameters = () => [
    { type: NxModalService },
    { type: EventManager },
    { type: ChangeDetectorRef }
];
NxModalComponent.propDecorators = {
    closeButtonLabel: [{ type: Input }],
    body: [{ type: Input, args: ['nxBody',] }],
    hideOnEsc: [{ type: Input, args: ['nxHideOnEsc',] }],
    hideOnClickOutside: [{ type: Input, args: ['nxHideOnClickOutside',] }],
    showCloseIcon: [{ type: Input, args: ['nxShowCloseIcon',] }],
    size: [{ type: Input, args: ['nxSize',] }],
    closeEvent: [{ type: Output, args: ['nxClose',] }]
};
if (false) {
    /**
     * @type {?}
     * @private
     */
    NxModalComponent.prototype._closeButtonLabel;
    /**
     * A template reference variable pointing to the template
     * which contains the content of the modal view.
     * @type {?}
     */
    NxModalComponent.prototype.body;
    /**
     * Whether the modal view should close when the user hits the escape key.
     * Default is true.
     * @type {?}
     */
    NxModalComponent.prototype.hideOnEsc;
    /**
     * Whether the modal view should close when the user clicks on the backdrop.
     * Default is true.
     * @type {?}
     */
    NxModalComponent.prototype.hideOnClickOutside;
    /**
     * Whether the modal view should have a close icon in the upper right corner.
     * Default is true.
     * @type {?}
     */
    NxModalComponent.prototype.showCloseIcon;
    /**
     * Controls the width of the dialog.
     * On `auto` the width is controlled by the content width,
     * on `fixed` the dialog gets a fixed width of 736px if the viewport is big enough.
     * @type {?}
     */
    NxModalComponent.prototype.size;
    /**
     * An event emitted when the user clicks on the backdrop or uses the built-in close button.
     * This event can be applied in conjunction with the custom open state handling
     * of a modal to close it when requested by the user.
     * @type {?}
     */
    NxModalComponent.prototype.closeEvent;
    /**
     * @type {?}
     * @private
     */
    NxModalComponent.prototype.closeSubscription;
    /**
     * @type {?}
     * @private
     */
    NxModalComponent.prototype.removeEventListener;
    /**
     * @type {?}
     * @private
     */
    NxModalComponent.prototype.modalService;
    /**
     * @type {?}
     * @private
     */
    NxModalComponent.prototype.eventManager;
    /**
     * @type {?}
     * @private
     */
    NxModalComponent.prototype._changeDetectorRef;
}

/**
 * @fileoverview added by tsickle
 * Generated from: modal/modal-open-on-click.directive.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class NxOpenModalOnClickDirective {
    /**
     * @param {?} templateRef
     * @param {?} viewContainer
     * @param {?} modalService
     */
    constructor(templateRef, viewContainer, modalService) {
        this.templateRef = templateRef;
        this.viewContainer = viewContainer;
        this.modalService = modalService;
        /**
         * \@docs-private
         */
        this.clickHandler = (/**
         * @param {?} event
         * @return {?}
         */
        (event) => {
            this.viewContainer.clear();
            // instantiate the template onto which this directive is applied
            /** @type {?} */
            const viewRef = this.viewContainer.createEmbeddedView(this.templateRef);
            // we need to mark the viewRef explicitly if the modal is used inside another
            // component that is using onPush change detection
            viewRef.markForCheck();
            event.preventDefault();
            event.stopPropagation();
        });
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.subscription = this.modalService.close$.subscribe((/**
         * @return {?}
         */
        () => this.viewContainer.clear()));
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this.elements.forEach((/**
         * @param {?} el
         * @return {?}
         */
        el => {
            if (el.removeEventListener) {
                el.removeEventListener('click', this.clickHandler);
            }
        }));
        this.subscription.unsubscribe();
    }
    /**
     * One or multiple template reference variables pointing to elements
     * which should trigger opening the modal on click.
     *
     * Value: A single template reference variable or an array of template reference variables.
     * @param {?} elements
     * @return {?}
     */
    set nxOpenModalOnClick(elements) {
        // also support the case where only one element is passed, check for the length property to be sure elements is an array
        if (elements.length) {
            this.elements = elements;
        }
        else {
            this.elements = [elements];
        }
        // add a click event listener to any element passed as property to this directive
        this.elements.forEach((/**
         * @param {?} el
         * @return {?}
         */
        el => {
            if (el.addEventListener) {
                el.addEventListener('click', this.clickHandler);
                // workaround until refactoring: if the reference is a component
                // reference the component has to implement a getter to its own elementRef
            }
            else if (el.elementRef) {
                el.elementRef.nativeElement.addEventListener('click', this.clickHandler);
            }
            else {
                console.warn(`nxOpenModalOnClick: Given Element doesn't appear to be an ElementRef.`, el);
            }
        }));
    }
}
NxOpenModalOnClickDirective.decorators = [
    { type: Directive, args: [{ selector: '[nxOpenModalOnClick]' },] }
];
/** @nocollapse */
NxOpenModalOnClickDirective.ctorParameters = () => [
    { type: TemplateRef },
    { type: ViewContainerRef },
    { type: NxModalService }
];
NxOpenModalOnClickDirective.propDecorators = {
    nxOpenModalOnClick: [{ type: Input }]
};
if (false) {
    /**
     * \@docs-private
     * @type {?}
     */
    NxOpenModalOnClickDirective.prototype.elements;
    /**
     * @type {?}
     * @private
     */
    NxOpenModalOnClickDirective.prototype.subscription;
    /**
     * \@docs-private
     * @type {?}
     */
    NxOpenModalOnClickDirective.prototype.clickHandler;
    /**
     * @type {?}
     * @private
     */
    NxOpenModalOnClickDirective.prototype.templateRef;
    /**
     * @type {?}
     * @private
     */
    NxOpenModalOnClickDirective.prototype.viewContainer;
    /**
     * @type {?}
     * @private
     */
    NxOpenModalOnClickDirective.prototype.modalService;
}

/**
 * @fileoverview added by tsickle
 * Generated from: modal/modal.module.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class NxModalModule {
    // define the modal service on root level as an application wide singleton,
    // assuming that we only display one modal at a time, which seems quite reasonable
    // this is static and named "forRoot" by convention
    /**
     * @return {?}
     */
    static forRoot() {
        return {
            ngModule: NxModalModule,
            providers: [NxModalService]
        };
    }
}
NxModalModule.decorators = [
    { type: NgModule, args: [{
                imports: [CommonModule, A11yModule, NxIconModule],
                declarations: [
                    NxModalComponent,
                    NxOpenModalOnClickDirective,
                    NxModalActionsDirective,
                    NxModalContentDirective
                ],
                exports: [
                    NxModalComponent,
                    NxOpenModalOnClickDirective,
                    NxModalActionsDirective,
                    NxModalContentDirective
                ],
            },] }
];

/**
 * @fileoverview added by tsickle
 * Generated from: modal/public-api.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * Generated from: modal/index.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * Generated from: switcher/switcher.component.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
let nextId$6 = 0;
class NxSwitcherComponent {
    /**
     * @param {?} _changeDetectorRef
     * @param {?} ngControl
     * @param {?} _errorStateMatcher
     * @param {?} _parentForm
     * @param {?} _parentFormGroup
     */
    constructor(_changeDetectorRef, ngControl, _errorStateMatcher, _parentForm, _parentFormGroup) {
        this._changeDetectorRef = _changeDetectorRef;
        this.ngControl = ngControl;
        this._errorStateMatcher = _errorStateMatcher;
        this._parentForm = _parentForm;
        this._parentFormGroup = _parentFormGroup;
        this._id = `nx-switcher-${nextId$6++}`;
        /**
         * \@docs-private
         */
        this.errorState = false;
        this._labelPosition = 'right';
        this._name = null;
        this._checked = false;
        this._big = false;
        this._labelSize = 'large';
        this._negative = false;
        this._disabled = false;
        /**
         * An event is dispatched each time the switcher value is changed
         */
        this.checkedChange = new EventEmitter();
        this.onChangeCallback = (/**
         * @param {?} _
         * @return {?}
         */
        (_) => { });
        this.onTouchedCallback = (/**
         * @return {?}
         */
        () => { });
        if (this.ngControl) {
            // Note: we provide the value accessor through here, instead of
            // the `providers` to avoid running into a circular import.
            this.ngControl.valueAccessor = this;
        }
    }
    /**
     * Sets the id of the switcher
     * @param {?} value
     * @return {?}
     */
    set id(value) {
        this._id = value;
        this._changeDetectorRef.markForCheck();
    }
    /**
     * @return {?}
     */
    get id() {
        return this._id;
    }
    /**
     * Specifies the placement of the label
     * @param {?} value
     * @return {?}
     */
    set labelPosition(value) {
        this._labelPosition = value;
        this._changeDetectorRef.markForCheck();
    }
    /**
     * @return {?}
     */
    get labelPosition() {
        return this._labelPosition;
    }
    /**
     * Sets the label text of the switcher
     * @param {?} value
     * @return {?}
     */
    set name(value) {
        this._name = value;
        this._changeDetectorRef.markForCheck();
    }
    /**
     * @return {?}
     */
    get name() {
        return this._name;
    }
    /**
     * Whether the switcher is checked (on) or unchecked (off)
     * @param {?} value
     * @return {?}
     */
    set checked(value) {
        this._checked = value;
        this._changeDetectorRef.markForCheck();
    }
    /**
     * @return {?}
     */
    get checked() {
        return this._checked;
    }
    /**
     * Whether the big switcher is used
     * @param {?} value
     * @return {?}
     */
    set big(value) {
        /** @type {?} */
        const newValue = coerceBooleanProperty(value);
        this._big = newValue;
        this._changeDetectorRef.markForCheck();
    }
    /**
     * @return {?}
     */
    get big() {
        return this._big;
    }
    /**
     * Sets the size of the label
     * @param {?} value
     * @return {?}
     */
    set labelSize(value) {
        this._labelSize = value;
        this._changeDetectorRef.markForCheck();
    }
    /**
     * @return {?}
     */
    get labelSize() {
        return this._labelSize;
    }
    /**
     * Whether the style for a dark background is used
     * @param {?} value
     * @return {?}
     */
    set negative(value) {
        /** @type {?} */
        const newValue = coerceBooleanProperty(value);
        this._negative = newValue;
        this._changeDetectorRef.markForCheck();
    }
    /**
     * @return {?}
     */
    get negative() {
        return this._negative;
    }
    /**
     * Whether the switcher is in the disabled state
     * @param {?} value
     * @return {?}
     */
    set disabled(value) {
        /** @type {?} */
        const newValue = coerceBooleanProperty(value);
        this._disabled = newValue;
        this._changeDetectorRef.markForCheck();
    }
    /**
     * @return {?}
     */
    get disabled() {
        return this._disabled;
    }
    /**
     * Allows to toggle between the states
     * @return {?}
     */
    toggle() {
        if (!this.disabled) {
            this.checked = !this.checked;
            this.onChangeCallback(this.checked);
            this.checkedChange.emit(this.checked);
            if (this.onTouchedCallback) {
                this.onTouchedCallback();
            }
        }
    }
    /**
     * @param {?} value
     * @return {?}
     */
    writeValue(value) {
        if (value === null) {
            value = false;
        }
        if (value !== this.checked) {
            this.checked = value;
        }
    }
    /**
     * @param {?} fn
     * @return {?}
     */
    registerOnChange(fn) {
        this.onChangeCallback = fn;
    }
    /**
     * @param {?} fn
     * @return {?}
     */
    registerOnTouched(fn) {
        this.onTouchedCallback = fn;
    }
    /**
     * @return {?}
     */
    ngDoCheck() {
        if (this.ngControl) {
            // We need to re-evaluate this on every change detection cycle, because there are some
            // error triggers that we can't subscribe to (e.g. parent form submissions). This means
            // that whatever logic is in here has to be super lean or we risk destroying the performance.
            this.updateErrorState();
        }
    }
    /**
     * @param {?} isDisabled
     * @return {?}
     */
    setDisabledState(isDisabled) {
        this.disabled = isDisabled;
    }
    /**
     * \@docs-private
     * @return {?}
     */
    touch() {
        this.onTouchedCallback();
    }
    /**
     * \@docs-private
     * @return {?}
     */
    updateErrorState() {
        /** @type {?} */
        const oldState = this.errorState;
        /** @type {?} */
        const parent = this._parentFormGroup || this._parentForm;
        /** @type {?} */
        const control = this.ngControl ? (/** @type {?} */ (this.ngControl.control)) : null;
        /** @type {?} */
        const newState = this._errorStateMatcher.isErrorState(control, parent);
        if (newState !== oldState) {
            this.errorState = newState;
        }
    }
    /**
     * \@docs-private
     * @return {?}
     */
    get labelHasContent() {
        return !!this._switcherLabelWrapper.nativeElement.innerHTML.trim();
    }
    /**
     * \@docs-private
     * Callback for when the content of the label has changed.
     * @return {?}
     */
    labelContentChanged() {
        this._changeDetectorRef.detectChanges();
    }
}
NxSwitcherComponent.decorators = [
    { type: Component, args: [{
                selector: 'nx-switcher',
                template: "<input type=\"checkbox\" [id]=\"id\" [attr.name]=\"name\" [disabled]=\"disabled\" [checked]=\"checked\" (click)=\"toggle()\" (blur)=\"touch()\"\n  role=\"switch\"\n  [attr.aria-checked]=\"checked\"\n  class=\"nx-switcher__input\">\n<label [attr.for]=\"id\" class=\"nx-switcher__label\" [class.has-label]=\"labelHasContent\">\n  <div class=\"nx-switcher__toggle\">\n    <div class=\"nx-switcher__dot\">\n      <nx-icon *ngIf=\"big\" name=\"check\"></nx-icon>\n    </div>\n  </div>\n  <div class=\"nx-switcher__label-text\" #switcherLabelWrapper (cdkObserveContent)=\"labelContentChanged()\">\n    <ng-content></ng-content>\n  </div>\n</label>\n\n",
                changeDetection: ChangeDetectionStrategy.OnPush,
                host: {
                    /* the host id should be set to null, otherwise nx-switcher and its <input> get the same id
                        and on label click the input click is not triggered (double id problem) */
                    '[attr.id]': 'null',
                    '[class.is-negative]': 'negative',
                    '[class.is-checked]': 'checked',
                    '[class.is-big]': 'big',
                    '[class.nx-switcher--small-label]': 'labelSize === "small"',
                    '[class.nx-switcher--large-label]': 'labelSize === "large"',
                    '[class.is-disabled]': 'disabled',
                    '[class.is-swapped]': 'labelPosition === "left"',
                    '[class.has-error]': 'errorState',
                    '[attr.aria-invalid]': 'errorState'
                },
                styles: [":host{position:relative;display:flex}:host(.is-swapped) .nx-switcher__label{flex-direction:row-reverse}:host(.is-swapped) .nx-switcher__label.has-label .nx-switcher__toggle{margin-left:12px}.nx-switcher__input{opacity:0;position:absolute}.nx-switcher__label{font-size:20px;font-size:var(--switcher-large-font-size,20px);line-height:28px;line-height:var(--switcher-large-line-height,28px);font-weight:400;font-weight:var(--switcher-large-font-weight,400);letter-spacing:.2px;letter-spacing:var(--switcher-large-letter-spacing,.2px);cursor:pointer;display:flex;position:relative}.nx-switcher__toggle{position:relative;display:inline-block;width:48px;min-width:48px;height:24px;background-color:#767676;background-color:var(--switcher-unchecked-background-color,#767676);border-radius:16px;transition:background-color .2s}:host(:not(.is-swapped)) .has-label .nx-switcher__toggle{margin-right:12px}.nx-switcher__dot{position:absolute;height:20px;width:20px;left:2px;bottom:2px;background-color:#fff;background-color:var(--switcher-dot-background-color,#fff);border-radius:16px;transform:translate(0);transition:transform .2s}:host(.is-checked) .nx-switcher__dot{transform:translate(24px)}:host(.is-checked) .nx-switcher__toggle{background-color:#007ab3;background-color:var(--switcher-checked-background-color,#007ab3)}:host(.is-checked.is-negative) .nx-switcher__toggle{background-color:rgba(255,255,255,.4)}:host(.is-big) .nx-switcher__toggle{width:56px;min-width:56px;height:32px}:host(.is-big) .nx-switcher__dot{height:28px;width:28px}:host(.is-big) nx-icon{position:absolute;top:2px;left:2px;font-size:24px;opacity:0;color:#006192;color:var(--switcher-checked-icon-color,#006192)}:host(.is-big).is-checked nx-icon{opacity:1;transition:opacity .2s}:host(.is-big).nx-switcher--large-label .has-label .nx-switcher__label-text{margin-top:2px;margin-top:var(--switcher-big-large-label-text-margin-top,2px)}:host(.is-big).nx-switcher--large-label .has-label .nx-switcher__toggle{margin-top:0;margin-top:var(--switcher-big-large-label-control-margin-top,0)}:host(.is-big).nx-switcher--small-label .has-label .nx-switcher__label-text{margin-top:4px;margin-top:var(--switcher-big-small-label-text-margin-top,4px)}:host(.is-big).nx-switcher--small-label .has-label .nx-switcher__toggle{margin-top:0;margin-top:var(--switcher-big-small-label-control-margin-top,0)}:host(.nx-switcher--large-label) .has-label .nx-switcher__label-text{margin-top:0;margin-top:var(--switcher-large-label-text-margin-top,0)}:host(.nx-switcher--large-label) .has-label .nx-switcher__toggle{margin-top:2px;margin-top:var(--switcher-large-label-control-margin-top,2px)}:host(.nx-switcher--small-label) .nx-switcher__label{font-size:16px;font-size:var(--switcher-small-font-size,16px);line-height:24px;line-height:var(--switcher-small-line-height,24px);font-weight:400;font-weight:var(--switcher-small-font-weight,400);letter-spacing:0;letter-spacing:var(--switcher-small-letter-spacing,0)}:host(.nx-switcher--small-label) .has-label .nx-switcher__label-text{margin-top:0;margin-top:var(--switcher-small-label-text-margin-top,0)}:host(.nx-switcher--small-label) .has-label .nx-switcher__toggle{margin-top:0;margin-top:var(--switcher-small-label-control-margin-top,0)}:host(.is-negative) .nx-switcher__label{color:#fff}:host(.is-negative) .nx-switcher__dot{background-color:#fff}:host(.is-negative) .nx-switcher__toggle{background-color:rgba(255,255,255,.4)}:host-context([data-whatinput=keyboard]) .nx-switcher__input:focus+.nx-switcher__label .nx-switcher__toggle{box-shadow:0 0 0 2px #fff,0 0 0 6px #009de6;box-shadow:var(--focus-box-shadow,0 0 0 2px #fff,0 0 0 6px #009de6)}:host(.is-disabled) .nx-switcher__toggle{background-color:#c2c2c2;background-color:var(--switcher-disabled-background-color,#c2c2c2)}:host(.is-disabled) .nx-switcher__dot{background-color:#dadada;background-color:var(--switcher-disabled-dot-background-color,#dadada)}:host(.is-disabled) .nx-switcher__label{cursor:not-allowed;color:#c2c2c2;color:var(--switcher-disabled-text-color,#c2c2c2)}:host(.is-disabled) nx-icon{color:#c2c2c2;color:var(--switcher-disabled-icon-color,#c2c2c2)}:host(.has-error) .nx-switcher__toggle{background-color:#dc3149;background-color:var(--danger,#dc3149)}@media screen and (-ms-high-contrast:active){:host-context([data-whatinput=keyboard]) .nx-switcher__input:focus+.nx-switcher__label .nx-switcher__toggle{box-shadow:0 0 0 2px background,0 0 0 6px windowText}.nx-switcher__label{color:buttonText}.nx-switcher__toggle{color:highlightText;background-color:highlight}:host:not(.is-checked) .nx-switcher__toggle{background-color:buttonFace;border:2px solid buttonText;color:buttonText}:host:not(.is-checked) .nx-switcher__dot{left:0;bottom:0;box-shadow:0 0 0 2px buttonText;background-color:buttonText}:host(.is-checked) .nx-switcher__dot{background-color:highlightText}:host(.is-checked) .nx-switcher__dot nx-icon{color:highlight}:host(.is-disabled) .nx-switcher__label{color:GrayText}:host(.is-disabled) .nx-switcher__toggle{color:GrayText}:host(.is-disabled) .nx-switcher__dot{opacity:1;background-color:GrayText}:host(.is-disabled):not(.is-checked) .nx-switcher__toggle{border:2px solid GrayText}:host(.is-disabled):not(.is-checked) .nx-switcher__dot{box-shadow:0 0 0 2px GrayText}:host(.is-disabled).is-checked .nx-switcher__toggle{background-color:GrayText}:host(.is-disabled).is-checked .nx-switcher__dot{background-color:window}:host(.is-disabled).is-checked .nx-switcher__dot nx-icon{color:GrayText}}"]
            }] }
];
/** @nocollapse */
NxSwitcherComponent.ctorParameters = () => [
    { type: ChangeDetectorRef },
    { type: NgControl, decorators: [{ type: Optional }, { type: Self }] },
    { type: ErrorStateMatcher },
    { type: NgForm, decorators: [{ type: Optional }] },
    { type: FormGroupDirective, decorators: [{ type: Optional }] }
];
NxSwitcherComponent.propDecorators = {
    _switcherLabelWrapper: [{ type: ViewChild, args: ['switcherLabelWrapper', { static: true },] }],
    id: [{ type: Input }],
    labelPosition: [{ type: Input }],
    name: [{ type: Input }],
    checked: [{ type: Input }],
    big: [{ type: Input, args: ['nxBig',] }],
    labelSize: [{ type: Input }],
    negative: [{ type: Input, args: ['nxNegative',] }],
    disabled: [{ type: Input }],
    checkedChange: [{ type: Output, args: ['checkedChange',] }]
};
if (false) {
    /**
     * @type {?}
     * @private
     */
    NxSwitcherComponent.prototype._id;
    /**
     * \@docs-private
     * @type {?}
     */
    NxSwitcherComponent.prototype.errorState;
    /**
     * \@docs-private
     * @type {?}
     */
    NxSwitcherComponent.prototype._switcherLabelWrapper;
    /**
     * @type {?}
     * @private
     */
    NxSwitcherComponent.prototype._labelPosition;
    /**
     * @type {?}
     * @private
     */
    NxSwitcherComponent.prototype._name;
    /**
     * @type {?}
     * @private
     */
    NxSwitcherComponent.prototype._checked;
    /**
     * @type {?}
     * @private
     */
    NxSwitcherComponent.prototype._big;
    /**
     * @type {?}
     * @private
     */
    NxSwitcherComponent.prototype._labelSize;
    /**
     * @type {?}
     * @private
     */
    NxSwitcherComponent.prototype._negative;
    /**
     * @type {?}
     * @private
     */
    NxSwitcherComponent.prototype._disabled;
    /**
     * An event is dispatched each time the switcher value is changed
     * @type {?}
     */
    NxSwitcherComponent.prototype.checkedChange;
    /**
     * @type {?}
     * @private
     */
    NxSwitcherComponent.prototype.onChangeCallback;
    /**
     * @type {?}
     * @private
     */
    NxSwitcherComponent.prototype.onTouchedCallback;
    /**
     * @type {?}
     * @private
     */
    NxSwitcherComponent.prototype._changeDetectorRef;
    /** @type {?} */
    NxSwitcherComponent.prototype.ngControl;
    /**
     * @type {?}
     * @private
     */
    NxSwitcherComponent.prototype._errorStateMatcher;
    /**
     * @type {?}
     * @private
     */
    NxSwitcherComponent.prototype._parentForm;
    /**
     * @type {?}
     * @private
     */
    NxSwitcherComponent.prototype._parentFormGroup;
}

/**
 * @fileoverview added by tsickle
 * Generated from: switcher/switcher.module.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class NxSwitcherModule {
}
NxSwitcherModule.decorators = [
    { type: NgModule, args: [{
                declarations: [NxSwitcherComponent],
                exports: [NxSwitcherComponent],
                imports: [CommonModule, NxIconModule, ObserversModule]
            },] }
];

/**
 * @fileoverview added by tsickle
 * Generated from: switcher/public-api.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * Generated from: popover/popover-content.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Popover content that will be rendered lazily
 * after the popover is opened for the first time.
 */
class NxPopoverContentDirective {
    /**
     * @param {?} _template
     */
    constructor(_template) {
        this._template = _template;
    }
}
NxPopoverContentDirective.decorators = [
    { type: Directive, args: [{
                selector: 'ng-template[nxPopoverContent]'
            },] }
];
/** @nocollapse */
NxPopoverContentDirective.ctorParameters = () => [
    { type: TemplateRef }
];
if (false) {
    /** @type {?} */
    NxPopoverContentDirective.prototype._template;
}

/**
 * @fileoverview added by tsickle
 * Generated from: popover/popover.component.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class NxPopoverComponent {
    constructor() {
        /**
         * Event emitted when the popover is closed.
         */
        this.closed = new EventEmitter();
        /**
         * \@docs-private
         */
        this.closeButtonClick = new Subject();
        /**
         * \@docs-private
         */
        this.showCloseButton = false;
        /**
         * \@docs-private
         */
        this.arrowStyle = {};
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this.closed.complete();
    }
    // emit to notify the popover trigger directive that the close button was clicked
    /**
     * \@docs-private
     * @return {?}
     */
    emitCloseButtonClick() {
        this.closeButtonClick.next();
    }
    /**
     * \@docs-private
     * @param {?} $event
     * @return {?}
     */
    _onCloseKeyup($event) {
        if ($event && ($event.keyCode === ENTER || $event.keyCode === SPACE)) {
            this.emitCloseButtonClick();
        }
        $event.preventDefault();
    }
    /**
     * \@docs-private
     * @return {?}
     */
    emitClosedEvent() {
        this.closed.emit();
    }
    /**
     * \@docs-private
     * @return {?}
     */
    get classList() {
        if (this.direction) {
            return [`nx-popover--${this.direction}`];
        }
    }
    /**
     * Prevent the popover from closing when the user clicks on the popover content.
     * @param {?} event
     * @return {?}
     */
    _onClick(event) {
        event.stopPropagation();
    }
}
NxPopoverComponent.decorators = [
    { type: Component, args: [{
                selector: 'nx-popover',
                template: "<ng-template>\n  <div [ngClass]=\"classList\" role=\"tooltip\" aria-hidden=\"false\" (click)=\"_onClick($event)\">\n    <div class=\"nx-popover__content\" tabindex=\"0\">\n        <div class=\"nx-popover__arrow\" [ngStyle]=\"arrowStyle\">\n          </div>\n      <span\n          aria-label=\"close\"\n          tabindex=\"0\"\n          role=\"button\"\n          class=\"nx-popover__close-icon\"\n          (click)=\"emitCloseButtonClick()\"\n          (keyup)=\"_onCloseKeyup($event)\"\n          *ngIf=\"showCloseButton\">\n        <nx-icon aria-hidden=\"true\" name=\"close\"></nx-icon>\n        </span>\n\n      <span [id]=\"id\">\n        <ng-content></ng-content>\n        <ng-container [ngTemplateOutlet]=\"_lazyContent?._template\"></ng-container>\n      </span>\n    </div>\n  </div>\n</ng-template>\n",
                changeDetection: ChangeDetectionStrategy.OnPush,
                exportAs: 'nxPopover',
                styles: [".nx-popover__content{font-size:16px;font-size:var(--popover-content-font-size,16px);line-height:24px;line-height:var(--popover-content-line-height,24px);font-weight:400;font-weight:var(--popover-content-font-weight,400);letter-spacing:0;letter-spacing:var(--popover-content-letter-spacing,0);background-color:#fff;background-color:var(--popover-background-color,#fff);color:#414141;color:var(--popover-text-color,#414141);border:1px solid #d9d9d9;border:1px solid var(--popover-border-color,#d9d9d9);border-radius:4px;box-shadow:0 2px 4px rgba(65,65,65,.5);padding:23px;display:inline-block}.nx-popover__content:focus{outline:0}.nx-popover__content::-moz-focus-inner{border:0}.nx-popover__close-icon{display:flex;position:absolute;top:4px;right:4px;cursor:pointer;font-size:16px;font-size:var(--popover-close-icon-size,16px);color:#d9d9d9;color:var(--popover-close-icon-color,#d9d9d9);border-radius:2px}.nx-popover__close-icon:focus{outline:0}.nx-popover__close-icon::-moz-focus-inner{border:0}::ng-deep [data-whatinput=keyboard] .nx-popover__close-icon:focus,::ng-deep [data-whatinput=keyboard] .nx-popover__content:focus{box-shadow:0 0 0 2px #fff,0 0 0 6px #009de6;box-shadow:var(--focus-box-shadow,0 0 0 2px #fff,0 0 0 6px #009de6)}@media screen and (-ms-high-contrast:active){::ng-deep [data-whatinput=keyboard] .nx-popover__close-icon:focus,::ng-deep [data-whatinput=keyboard] .nx-popover__content:focus{box-shadow:0 0 0 2px background,0 0 0 6px windowText}}.nx-popover__arrow{width:12px;height:12px;background-color:inherit;position:absolute;transform:translate(-50%,0);border-top:1px solid #d9d9d9;border-top:1px solid var(--popover-border-color,#d9d9d9);border-left:1px solid #d9d9d9;border-left:1px solid var(--popover-border-color,#d9d9d9)}.nx-popover--top .nx-popover__arrow{transform:translate(-50%,0) rotate(225deg);bottom:-5px;box-shadow:2px 2px 1px 1px #fff,-2px -2px 4px rgba(65,65,65,.5);box-shadow:2px 2px 1px 1px var(--popover-background-color,#fff),-2px -2px 4px rgba(65,65,65,.5)}.nx-popover--right .nx-popover__arrow{transform:translate(0,-50%) rotate(-45deg);left:-5px}.nx-popover--bottom .nx-popover__arrow{transform:translate(-50%,0) rotate(45deg);top:-5px}.nx-popover--left .nx-popover__arrow{transform:translate(0,-50%) rotate(135deg);right:-5px}"]
            }] }
];
/** @nocollapse */
NxPopoverComponent.ctorParameters = () => [];
NxPopoverComponent.propDecorators = {
    templateRef: [{ type: ViewChild, args: [TemplateRef, { static: false },] }],
    _lazyContent: [{ type: ContentChild, args: [NxPopoverContentDirective, { static: false },] }],
    closed: [{ type: Output, args: ['nxClosed',] }]
};
if (false) {
    /**
     * \@docs-private
     * @type {?}
     */
    NxPopoverComponent.prototype.templateRef;
    /**
     * Content that will be rendered lazily.
     * @type {?}
     */
    NxPopoverComponent.prototype._lazyContent;
    /**
     * Event emitted when the popover is closed.
     * @type {?}
     */
    NxPopoverComponent.prototype.closed;
    /**
     * \@docs-private
     * @type {?}
     */
    NxPopoverComponent.prototype.closeButtonClick;
    /**
     * \@docs-private
     * @type {?}
     */
    NxPopoverComponent.prototype.id;
    /**
     * \@docs-private
     * @type {?}
     */
    NxPopoverComponent.prototype.direction;
    /**
     * \@docs-private
     * @type {?}
     */
    NxPopoverComponent.prototype.showCloseButton;
    /**
     * \@docs-private
     * @type {?}
     */
    NxPopoverComponent.prototype.arrowStyle;
}

/**
 * @fileoverview added by tsickle
 * Generated from: popover/popover-trigger.directive.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
let nextId$7 = 0;
/** @type {?} */
const fallbacks = [
    {
        originX: 'start',
        originY: 'bottom',
        overlayX: 'start',
        overlayY: 'top',
        offsetX: 0,
        offsetY: 16
    },
    {
        originX: 'end',
        originY: 'top',
        overlayX: 'end',
        overlayY: 'bottom',
        offsetX: 0,
        offsetY: -16
    },
    {
        originX: 'center',
        originY: 'bottom',
        overlayX: 'center',
        overlayY: 'top',
        offsetX: 0,
        offsetY: 16
    },
    {
        originX: 'end',
        originY: 'bottom',
        overlayX: 'end',
        overlayY: 'top',
        offsetX: 0,
        offsetY: 16
    },
    {
        originX: 'end',
        originY: 'center',
        overlayX: 'start',
        overlayY: 'center',
        offsetX: 16,
        offsetY: 0
    },
    {
        originX: 'start',
        originY: 'center',
        overlayX: 'end',
        overlayY: 'center',
        offsetX: -16,
        offsetY: 0
    },
    {
        originX: 'center',
        originY: 'top',
        overlayX: 'center',
        overlayY: 'bottom',
        offsetX: 0,
        offsetY: -16
    },
    {
        originX: 'start',
        originY: 'top',
        overlayX: 'start',
        overlayY: 'bottom',
        offsetX: 0,
        offsetY: -16
    }
];
class NxPopoverTriggerDirective {
    /**
     * @param {?} overlay
     * @param {?} elementRef
     * @param {?} viewContainerRef
     * @param {?} eventManager
     * @param {?} _focusTrapFactory
     * @param {?} _focusMonitor
     * @param {?} _ngZone
     * @param {?} _platform
     * @param {?} _document
     */
    constructor(overlay, elementRef, viewContainerRef, eventManager, _focusTrapFactory, _focusMonitor, _ngZone, _platform, _document) {
        this.overlay = overlay;
        this.elementRef = elementRef;
        this.viewContainerRef = viewContainerRef;
        this.eventManager = eventManager;
        this._focusTrapFactory = _focusTrapFactory;
        this._focusMonitor = _focusMonitor;
        this._ngZone = _ngZone;
        this._platform = _platform;
        this._document = _document;
        this._destroyed = new Subject();
        this._show = false;
        this._closeable = null;
        /**
         * Element that was focused before the Popover was opened. Save this to restore upon close.
         */
        this._elementFocusedBeforePopoverWasOpened = null;
        this._manualListeners = new Map();
        /**
         * \@docs-private
         */
        this.id = 'nx-popover-' + nextId$7++;
        /**
         * An event is emitted if the visibility status of the popover changes.
         */
        this.changeShow = new EventEmitter();
        this._closeOnClickOutside = true;
        /**
         * Sets the desired direction to open the popover. E.g., right, left, bottom, top
         */
        this.direction = 'right';
        /**
         * Whether the popover will be opened automatically.
         */
        this.popoverInitialVisible = false;
        /**
         * An event is emitted when the visibility of the popopver changes.
         */
        this.visibleChange = new EventEmitter();
        /**
         * Whether the popover opens in modal state.
         */
        this.modal = false;
        // If nxPopoverTrigger equals to 'hover' the popover opens on mouseenter and closes on mouseout.
        // If nxPopoverTrigger equals to 'click' the popover opens on click and closes on a click of the close icon or pressing ESC key.
        // If nxPopoverTrigger equals to 'manual' the popover opens only when programatically requested.
        /**
         * Sets the way to trigger the popover. Options are hover, click, manual
         */
        this.trigger = 'click';
        /**
         * Sets the scroll strategy. 'close' closes the popover on scroll while 'reposition' scrolls the popover with the origin.
         */
        this.scrollStrategy = 'close';
        this._documentClickObservable = fromEvent(document, 'click');
        /** @type {?} */
        const element = elementRef.nativeElement;
        if (!this._platform.IOS && !this._platform.ANDROID) {
            this._manualListeners
                .set('mouseenter', (/**
             * @return {?}
             */
            () => {
                if (this.trigger === 'hover') {
                    this.show = true;
                }
            }))
                .set('mouseleave', (/**
             * @return {?}
             */
            () => {
                if (this.trigger === 'hover') {
                    this.show = false;
                }
            }))
                .set('keydown', (/**
             * @param {?} event
             * @return {?}
             */
            (event) => {
                switch (event.keyCode) {
                    case SPACE:
                    case ENTER:
                        this.handleClick();
                        break;
                    default:
                        return;
                }
            }));
        }
        else {
            this._manualListeners.set('touchstart', (/**
             * @return {?}
             */
            () => {
                if (this.trigger === 'hover') {
                    this.show = true;
                }
            }));
        }
        this._manualListeners.forEach((/**
         * @param {?} listener
         * @param {?} event
         * @return {?}
         */
        (listener, event) => element.addEventListener(event, listener)));
        this._focusMonitor.monitor(element).pipe(takeUntil(this._destroyed)).subscribe((/**
         * @param {?} origin
         * @return {?}
         */
        origin => {
            if (origin === 'keyboard' && this.trigger === 'hover') {
                this._ngZone.run((/**
                 * @return {?}
                 */
                () => this.show = true));
            }
        }));
    }
    /**
     * Whether to show or hide the popover.
     * @param {?} value
     * @return {?}
     */
    set show(value) {
        value = coerceBooleanProperty(value);
        if (this._show !== value) {
            this._show = value;
            if (this._show) {
                this.openPopover();
            }
            else {
                this.closePopover();
            }
        }
    }
    /**
     * @return {?}
     */
    get show() {
        return this._show;
    }
    /**
     * Whether to show a close button. By default a close icon is only shown for trigger type click.
     * @param {?} value
     * @return {?}
     */
    set closeable(value) {
        this._closeable = coerceBooleanProperty(value);
        if (this.popover) {
            this.popover.showCloseButton = this.isCloseable();
        }
    }
    /**
     * @return {?}
     */
    get closeable() {
        return this._closeable;
    }
    /**
     * Whether the popover should be closed on click outside of the popover in the trigger modes 'manual' and 'click'.
     * @param {?} value
     * @return {?}
     */
    set closeOnClickOutside(value) {
        this._closeOnClickOutside = coerceBooleanProperty(value);
    }
    /**
     * @return {?}
     */
    get closeOnClickOutside() {
        return this._closeOnClickOutside;
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.popover.showCloseButton = this.isCloseable();
    }
    /**
     * @return {?}
     */
    ngAfterViewInit() {
        this.popover.id = this.id;
        this.eventManager.addGlobalEventListener('window', 'keyup.esc', (/**
         * @return {?}
         */
        () => {
            if (this.isOpen) {
                this.show = false;
            }
        }));
        this.popover.closeButtonClick.pipe(takeUntil(this._destroyed)).subscribe((/**
         * @return {?}
         */
        () => {
            this.show = false;
        }));
        if (this.popoverInitialVisible || this._show) {
            this.show = true;
        }
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this.show = false;
        // Clean up the event listeners set in the constructor
        this._manualListeners.forEach((/**
         * @param {?} listener
         * @param {?} event
         * @return {?}
         */
        (listener, event) => {
            this.elementRef.nativeElement.removeEventListener(event, listener);
        }));
        this._manualListeners.clear();
        this._destroyed.next();
        this._destroyed.complete();
    }
    /**
     * \@docs-private
     * @return {?}
     */
    get isOpen() {
        return this.overlayRef && this.createOverlay().hasAttached();
    }
    /**
     * \@docs-private
     * @return {?}
     */
    isCloseable() {
        return (this.trigger === 'click' && this._closeable === null) || this._closeable;
    }
    /**
     * Update the popover with the given position strategy.
     * @return {?}
     */
    updatePosition() {
        if (this._positionStrategy) {
            this._positionStrategy.apply();
        }
    }
    /**
     * \@docs-private
     * @return {?}
     */
    handleClick() {
        if (this.trigger === 'click') {
            this.show = !this.isOpen;
        }
        else if (this.trigger === 'hover') {
            this.show = true;
        }
    }
    /**
     * Open the popover instance.
     * @return {?}
     */
    open() {
        this.show = true;
    }
    /**
     * Close the popover instance.
     * @return {?}
     */
    close() {
        this.show = false;
    }
    /**
     * Toggle the popover instance.
     * @return {?}
     */
    toggle() {
        this.show = !this.show;
    }
    /**
     * @private
     * @return {?}
     */
    openPopover() {
        if (!this.createOverlay().hasAttached()) {
            this._embeddedViewRef = this.createOverlay().attach(this.portal);
            /** @type {?} */
            const element = (/** @type {?} */ (this._embeddedViewRef.rootNodes[0]));
            this._focusTrap = this._focusTrapFactory.create(element);
            this._elementFocusedBeforePopoverWasOpened = this.elementRef.nativeElement;
            this._autoFocusFirstTabbableElement(element);
            // attach a close click listener only if it makes sense (ignore it on hover e.g.)
            if (this.shouldReactOnClickOutside()) {
                this.waitForClose();
            }
        }
    }
    /**
     * Autofocus the first tabbable element inside of the popover, if there is not a tabbable element,
     * focus the popover instead.
     * @private
     * @param {?} element
     * @return {?}
     */
    _autoFocusFirstTabbableElement(element) {
        this._focusTrap.focusInitialElementWhenReady().then((/**
         * @param {?} hasMovedFocus
         * @return {?}
         */
        hasMovedFocus => {
            // If we didn't find any focusable elements inside the popover, focus the
            // container so the user can't tab into other elements behind it.
            if (!hasMovedFocus) {
                element.focus();
            }
        }));
    }
    /**
     * @private
     * @return {?}
     */
    shouldReactOnClickOutside() {
        return (!this.modal && this.closeOnClickOutside);
    }
    // detaches the overlay
    // we are listening to the detachments observable which will then emit the nxClosed event
    // on the popover component
    /**
     * @private
     * @return {?}
     */
    closePopover() {
        if (this.overlayRef) {
            this._returnFocusAfterPopover();
            this.overlayRef.detach();
            this._embeddedViewRef = null;
            this._focusTrap.destroy();
        }
    }
    /**
     * @private
     * @return {?}
     */
    createOverlay() {
        if (!this.overlayRef) {
            this.portal = new TemplatePortal(this.popover.templateRef, this.viewContainerRef);
            /** @type {?} */
            const overlayState = new OverlayConfig();
            overlayState.positionStrategy = this.getPosition();
            this._positionStrategy = overlayState.positionStrategy;
            if (this.scrollStrategy === 'reposition') {
                overlayState.scrollStrategy = this.overlay.scrollStrategies.reposition();
            }
            else {
                overlayState.scrollStrategy = this.overlay.scrollStrategies.close();
            }
            overlayState.scrollStrategy.enable();
            if (this.modal && this.trigger === 'click') {
                overlayState.hasBackdrop = true;
            }
            this.overlayRef = this.overlay.create(overlayState);
            this.subscribeToPositions((/** @type {?} */ (overlayState.positionStrategy)));
            this._subscribeToAttach();
            this._subscribeToDetach();
            if (this.modal) {
                this._subscribeToBackdropClick();
            }
        }
        return this.overlayRef;
    }
    /**
     * @private
     * @param {?} position
     * @return {?}
     */
    subscribeToPositions(position) {
        position.positionChanges.pipe(takeUntil(this._destroyed)).subscribe((/**
         * @param {?} change
         * @return {?}
         */
        change => {
            /** @type {?} */
            const pair = change.connectionPair;
            this.positionOverlay(pair);
            this.positionArrow(pair);
            // These position changes arrive too late,
            // We have to trigger the change detection manually
            // as it's detached from any render hierarchy
            // and only updated by the overlay when attached.
            if (this._embeddedViewRef && !this._embeddedViewRef.destroyed) {
                this._embeddedViewRef.detectChanges();
            }
        }));
    }
    // for modal popovers close the popover on backdrop clicks
    /**
     * @private
     * @return {?}
     */
    _subscribeToBackdropClick() {
        this.overlayRef.backdropClick().pipe(takeUntil(this._destroyed)).subscribe((/**
         * @param {?} event
         * @return {?}
         */
        (event) => {
            this.show = false;
        }));
    }
    // Emit the nxClosed and the show status change event on the popover component when the overlay detaches
    /**
     * @private
     * @return {?}
     */
    _subscribeToDetach() {
        this.overlayRef.detachments().pipe(takeUntil(this._destroyed)).subscribe((/**
         * @param {?} data
         * @return {?}
         */
        data => {
            // This is an exception: when the popover is closed by a scrolling event,
            // then only the detached method is called but the show state variable remains unchanged.
            if (this.show) {
                this.show = false;
            }
            this.changeShow.emit(this._show);
            this.popover.emitClosedEvent();
        }));
    }
    /**
     * @private
     * @return {?}
     */
    _subscribeToAttach() {
        this.overlayRef.attachments().pipe(takeUntil(this._destroyed)).subscribe((/**
         * @param {?} data
         * @return {?}
         */
        data => {
            this.changeShow.emit(this._show);
        }));
    }
    // subscribe to document clicks when trigger='click' to close the popover on clicks on the background
    /**
     * @private
     * @return {?}
     */
    waitForClose() {
        return this._documentClickObservable
            .pipe(map((/**
         * @param {?} event
         * @return {?}
         */
        event => event.target)), filter((/**
         * @param {?} target
         * @return {?}
         */
        target => !this.elementRef.nativeElement.contains(target))), takeUntil(this.popover.closed))
            .subscribe((/**
         * @return {?}
         */
        () => {
            this.show = false;
        }));
    }
    /**
     * @private
     * @param {?} pair
     * @return {?}
     */
    positionOverlay(pair) {
        if (pair.originX === 'end' && pair.overlayX === 'start') {
            this.popover.direction = 'right';
        }
        else if (pair.originY === 'bottom' && pair.overlayY === 'top') {
            this.popover.direction = 'bottom';
        }
        else if (pair.originX === 'start' && pair.overlayX === 'end') {
            this.popover.direction = 'left';
        }
        else if (pair.originY === 'top' && pair.overlayY === 'bottom') {
            this.popover.direction = 'top';
        }
    }
    /**
     * @private
     * @param {?} pair
     * @return {?}
     */
    positionArrow(pair) {
        /** @type {?} */
        const parentElementPositionX = this.elementRef.nativeElement.getBoundingClientRect().left;
        /** @type {?} */
        const parentElementWidth = this.elementRef.nativeElement.getBoundingClientRect().width / 2;
        /** @type {?} */
        const parentElementLeftOffset = this.overlayRef.overlayElement.parentElement.offsetLeft;
        /** @type {?} */
        const overlayElementLeftOffset = this.overlayRef.overlayElement.offsetLeft;
        // calculation for x position of the parent element. In this case, overlay left offset is the one thing to consider.
        /** @type {?} */
        const targetPosition = (parentElementPositionX + parentElementWidth) - (parentElementLeftOffset + overlayElementLeftOffset);
        if (pair.originX === pair.overlayX) {
            /** @type {?} */
            const direction = 'left';
            /** @type {?} */
            const arrowStyle = {};
            arrowStyle[direction] = targetPosition + 'px';
            this.popover.arrowStyle = arrowStyle;
        }
        if ((pair.originY === 'bottom' || pair.originY === 'top') && pair.overlayX === 'center') {
            this.popover.arrowStyle = { left: targetPosition + 'px' };
        }
        if ((pair.originX === 'end' || pair.originX === 'start') && pair.overlayY === 'center') {
            this.popover.arrowStyle = { top: '50%' };
        }
    }
    /**
     * @private
     * @return {?}
     */
    getPosition() {
        /** @type {?} */
        let positions;
        /** @type {?} */
        let offsetX = 0;
        /** @type {?} */
        let offsetY = 0;
        if (this.direction === 'top') {
            positions = [{
                    overlayX: 'center',
                    overlayY: 'bottom',
                    originX: 'center',
                    originY: 'top'
                }];
            offsetX = 0;
            offsetY = -20;
        }
        else if (this.direction === 'right') {
            positions = [{
                    overlayX: 'start',
                    overlayY: 'center',
                    originX: 'end',
                    originY: 'center'
                }];
            offsetX = 20;
            offsetY = 0;
        }
        else if (this.direction === 'bottom') {
            positions = [{
                    overlayX: 'center',
                    overlayY: 'top',
                    originX: 'center',
                    originY: 'bottom'
                }];
            offsetX = 0;
            offsetY = 20;
        }
        else if (this.direction === 'left') {
            positions = [{
                    overlayX: 'end',
                    overlayY: 'center',
                    originX: 'start',
                    originY: 'center'
                }];
            offsetX = -20;
            offsetY = 0;
        }
        return this.overlay.position().flexibleConnectedTo(this.elementRef)
            .withPositions([...positions, ...fallbacks])
            .withDefaultOffsetX(offsetX)
            .withDefaultOffsetY(offsetY);
    }
    /**
     * Returns the focus to the element focused before the Popover was open.
     * @private
     * @return {?}
     */
    _returnFocusAfterPopover() {
        /** @type {?} */
        const toFocus = this._elementFocusedBeforePopoverWasOpened;
        // We need the extra check, because IE can set the `activeElement` to null in some cases.
        if (toFocus && typeof toFocus.focus === 'function') {
            toFocus.focus();
        }
    }
}
NxPopoverTriggerDirective.decorators = [
    { type: Directive, args: [{
                selector: '[nxPopoverTriggerFor]',
                exportAs: 'nxPopoverTrigger',
                host: {
                    '(click)': 'handleClick()',
                    'aria-haspopup': 'true',
                    '[attr.aria-expanded]': 'isOpen',
                    '[attr.aria-describedby]': 'isOpen ? id : null'
                }
            },] }
];
/** @nocollapse */
NxPopoverTriggerDirective.ctorParameters = () => [
    { type: Overlay },
    { type: ElementRef },
    { type: ViewContainerRef },
    { type: EventManager },
    { type: FocusTrapFactory },
    { type: FocusMonitor },
    { type: NgZone },
    { type: Platform },
    { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [DOCUMENT,] }] }
];
NxPopoverTriggerDirective.propDecorators = {
    changeShow: [{ type: Output, args: ['nxPopoverShowChange',] }],
    show: [{ type: Input, args: ['nxPopoverShow',] }],
    closeable: [{ type: Input, args: ['nxPopoverCloseable',] }],
    closeOnClickOutside: [{ type: Input }],
    popover: [{ type: Input, args: ['nxPopoverTriggerFor',] }],
    direction: [{ type: Input, args: ['nxPopoverDirection',] }],
    popoverInitialVisible: [{ type: Input, args: ['nxPopoverInitialVisible',] }],
    visibleChange: [{ type: Input, args: ['nxPopoverVisibleChange',] }],
    modal: [{ type: Input, args: ['nxPopoverModal',] }],
    trigger: [{ type: Input, args: ['nxPopoverTrigger',] }],
    scrollStrategy: [{ type: Input, args: ['nxPopoverScrollStrategy',] }]
};
if (false) {
    /**
     * @type {?}
     * @private
     */
    NxPopoverTriggerDirective.prototype.overlayRef;
    /**
     * @type {?}
     * @private
     */
    NxPopoverTriggerDirective.prototype.portal;
    /**
     * @type {?}
     * @private
     */
    NxPopoverTriggerDirective.prototype._destroyed;
    /**
     * @type {?}
     * @private
     */
    NxPopoverTriggerDirective.prototype._show;
    /**
     * @type {?}
     * @private
     */
    NxPopoverTriggerDirective.prototype._closeable;
    /**
     * @type {?}
     * @private
     */
    NxPopoverTriggerDirective.prototype._positionStrategy;
    /**
     * @type {?}
     * @private
     */
    NxPopoverTriggerDirective.prototype._embeddedViewRef;
    /**
     * @type {?}
     * @private
     */
    NxPopoverTriggerDirective.prototype._documentClickObservable;
    /**
     * The class that traps and manages focus within the popover.
     * @type {?}
     * @private
     */
    NxPopoverTriggerDirective.prototype._focusTrap;
    /**
     * Element that was focused before the Popover was opened. Save this to restore upon close.
     * @type {?}
     * @private
     */
    NxPopoverTriggerDirective.prototype._elementFocusedBeforePopoverWasOpened;
    /**
     * @type {?}
     * @private
     */
    NxPopoverTriggerDirective.prototype._manualListeners;
    /**
     * \@docs-private
     * @type {?}
     */
    NxPopoverTriggerDirective.prototype.id;
    /**
     * An event is emitted if the visibility status of the popover changes.
     * @type {?}
     */
    NxPopoverTriggerDirective.prototype.changeShow;
    /**
     * @type {?}
     * @private
     */
    NxPopoverTriggerDirective.prototype._closeOnClickOutside;
    /**
     * Links the trigger with the popover to open.
     * @type {?}
     */
    NxPopoverTriggerDirective.prototype.popover;
    /**
     * Sets the desired direction to open the popover. E.g., right, left, bottom, top
     * @type {?}
     */
    NxPopoverTriggerDirective.prototype.direction;
    /**
     * Whether the popover will be opened automatically.
     * @type {?}
     */
    NxPopoverTriggerDirective.prototype.popoverInitialVisible;
    /**
     * An event is emitted when the visibility of the popopver changes.
     * @type {?}
     */
    NxPopoverTriggerDirective.prototype.visibleChange;
    /**
     * Whether the popover opens in modal state.
     * @type {?}
     */
    NxPopoverTriggerDirective.prototype.modal;
    /**
     * Sets the way to trigger the popover. Options are hover, click, manual
     * @type {?}
     */
    NxPopoverTriggerDirective.prototype.trigger;
    /**
     * Sets the scroll strategy. 'close' closes the popover on scroll while 'reposition' scrolls the popover with the origin.
     * @type {?}
     */
    NxPopoverTriggerDirective.prototype.scrollStrategy;
    /**
     * @type {?}
     * @private
     */
    NxPopoverTriggerDirective.prototype.overlay;
    /**
     * @type {?}
     * @private
     */
    NxPopoverTriggerDirective.prototype.elementRef;
    /**
     * @type {?}
     * @private
     */
    NxPopoverTriggerDirective.prototype.viewContainerRef;
    /**
     * @type {?}
     * @private
     */
    NxPopoverTriggerDirective.prototype.eventManager;
    /**
     * @type {?}
     * @private
     */
    NxPopoverTriggerDirective.prototype._focusTrapFactory;
    /**
     * @type {?}
     * @private
     */
    NxPopoverTriggerDirective.prototype._focusMonitor;
    /**
     * @type {?}
     * @private
     */
    NxPopoverTriggerDirective.prototype._ngZone;
    /**
     * @type {?}
     * @private
     */
    NxPopoverTriggerDirective.prototype._platform;
    /**
     * @type {?}
     * @private
     */
    NxPopoverTriggerDirective.prototype._document;
}

/**
 * @fileoverview added by tsickle
 * Generated from: popover/popover.module.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class NxPopoverModule {
}
NxPopoverModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    CommonModule,
                    OverlayModule,
                    NxIconModule
                ],
                declarations: [
                    NxPopoverTriggerDirective,
                    NxPopoverComponent,
                    NxPopoverContentDirective
                ],
                exports: [
                    NxPopoverTriggerDirective,
                    NxPopoverComponent,
                    NxPopoverContentDirective
                ]
            },] }
];

/**
 * @fileoverview added by tsickle
 * Generated from: popover/public-api.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * Generated from: popover/index.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * Generated from: taglist/tag.component.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class NxTagComponent {
    /**
     * @param {?} _changeDetectorRef
     */
    constructor(_changeDetectorRef) {
        this._changeDetectorRef = _changeDetectorRef;
        this._tabindex = -1;
        /**
         * An event is dispatched each time when the tag is clicked.
         */
        this.clicked = new EventEmitter();
        /**
         * An event is dispatched each time when the tag is removed.
         */
        this.removed = new EventEmitter();
    }
    /**
     * Whether the tag is removeable.
     * @param {?} value
     * @return {?}
     */
    set removable(value) {
        this._removable = coerceBooleanProperty(value);
        this._changeDetectorRef.markForCheck();
    }
    /**
     * @return {?}
     */
    get removable() {
        return this._removable;
    }
    /**
     * Sets the tab-index of a tag. Default value: -1.
     *
     * If `nxAllowTagDeletion` of the taglist is set to true, the default value is 0.
     * @param {?} value
     * @return {?}
     */
    set tabindex(value) {
        this._tabindex = coerceNumberProperty(value);
        this._changeDetectorRef.markForCheck();
    }
    /**
     * @return {?}
     */
    get tabindex() {
        return this.removable ? 0 : this._tabindex;
    }
    /**
     * Sets the value of the tag.
     * @param {?} value
     * @return {?}
     */
    set value(value) {
        if (this._value !== value) {
            this._value = value;
            this._changeDetectorRef.markForCheck();
        }
    }
    /**
     * @return {?}
     */
    get value() {
        return this._value;
    }
    /**
     * \@docs-private
     * @param {?} event
     * @return {?}
     */
    // Emit the removed event that the parent can remove the value
    removeClickHandler(event) {
        event.stopPropagation();
        this.removed.emit(this.value);
    }
    /**
     * \@docs-private
     * @param {?} event
     * @return {?}
     */
    removeKeyHandler(event) {
        if (this.removable && (event.keyCode === DELETE || event.keyCode === BACKSPACE)) {
            event.preventDefault();
            event.stopPropagation();
            this.removed.emit(this.value);
        }
        if (event.keyCode === ENTER) {
            this.clicked.emit(this.value);
        }
    }
    /**
     * \@docs-private
     * @return {?}
     */
    tagClickHandler() {
        this.clicked.emit(this.value);
    }
}
NxTagComponent.decorators = [
    { type: Component, args: [{
                selector: 'nx-tag',
                template: "{{ value }}\n<span role=\"link\" aria-label=\"close\" class=\"nx-tag__close\" *ngIf=\"removable\"\n    (click)=\"removeClickHandler($event)\">\n    <nx-icon class=\"nx-tag__close-icon\" name=\"close\"></nx-icon>\n</span>",
                changeDetection: ChangeDetectionStrategy.OnPush,
                host: {
                    '(click)': 'tagClickHandler()',
                    '(keydown)': 'removeKeyHandler($event)',
                    '[attr.tabindex]': 'tabindex'
                },
                styles: [":host{font-size:14px;font-size:var(--taglist-font-size,14px);line-height:16px;line-height:var(--taglist-line-height,16px);font-weight:600;font-weight:var(--taglist-font-weight,600);letter-spacing:1px;letter-spacing:var(--taglist-letter-spacing,1px);height:auto;max-width:100%;color:#767676;color:var(--taglist-color,#767676);background-color:transparent;background-color:var(--taglist-background-color,transparent);padding:6px 14px;display:flex;align-items:center;border:2px solid #d9d9d9;border:2px solid var(--taglist-border-color,#d9d9d9);border-radius:4px;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;transition:background-color .2s,box-shadow .2s;cursor:pointer}:host:hover{border-color:#c2c2c2;border-color:var(--taglist-hover-border-color,#c2c2c2);color:#5b5b5b;color:var(--taglist-hover-color,#5b5b5b);background-color:#ececec;background-color:var(--taglist-hover-background-color,#ececec)}:host:focus{outline:transparent solid 2px}:host-context([data-whatinput=keyboard]):focus{box-shadow:0 0 0 2px #fff,0 0 0 6px #009de6;box-shadow:var(--focus-box-shadow,0 0 0 2px #fff,0 0 0 6px #009de6)}.nx-tag__close-icon{outline:0;display:block;font-size:16px;font-size:var(--taglist-close-icon-size,16px)}.nx-tag__close{margin-left:8px}:host-context(.nx-taglist--keyword){padding:14px 22px}@media screen and (-ms-high-contrast:active){:host-context([data-whatinput=keyboard]):focus{box-shadow:0 0 0 2px background,0 0 0 6px windowText}:host,:host:focus,:host:hover{color:buttonText;background-color:buttonFace;border-color:buttonText;-ms-high-contrast-adjust:none}}"]
            }] }
];
/** @nocollapse */
NxTagComponent.ctorParameters = () => [
    { type: ChangeDetectorRef }
];
NxTagComponent.propDecorators = {
    removable: [{ type: Input }],
    tabindex: [{ type: Input }],
    value: [{ type: Input }],
    clicked: [{ type: Output }],
    removed: [{ type: Output }]
};
if (false) {
    /**
     * @type {?}
     * @private
     */
    NxTagComponent.prototype._removable;
    /**
     * @type {?}
     * @private
     */
    NxTagComponent.prototype._tabindex;
    /**
     * @type {?}
     * @private
     */
    NxTagComponent.prototype._value;
    /**
     * An event is dispatched each time when the tag is clicked.
     * @type {?}
     */
    NxTagComponent.prototype.clicked;
    /**
     * An event is dispatched each time when the tag is removed.
     * @type {?}
     */
    NxTagComponent.prototype.removed;
    /**
     * @type {?}
     * @private
     */
    NxTagComponent.prototype._changeDetectorRef;
}

/**
 * @fileoverview added by tsickle
 * Generated from: taglist/taglist.component.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class NxTaglistComponent {
    /**
     * @param {?} _changeDetectorRef
     */
    constructor(_changeDetectorRef) {
        this._changeDetectorRef = _changeDetectorRef;
        /**
         * An event is dispatched each time when the list of tags changed.
         */
        this.tagsChange = new EventEmitter();
        /**
         * An event is dispatched each time when a tag is clicked.
         */
        this.tagClickEvent = new EventEmitter();
        this._tags = [];
        this._tabindex = -1;
        this._allowTagDeletion = true;
        this._isKeywordList = false;
        this._labelProperty = 'nxTaglistLabel';
        this._valueFormatterFn = (/**
         * @param {?} value
         * @return {?}
         */
        (value) => value);
        this._onChange = (/**
         * @return {?}
         */
        () => { });
        this._onTouched = (/**
         * @return {?}
         */
        () => { });
    }
    /**
     * Sets the list of tags.
     * @param {?} value
     * @return {?}
     */
    set tags(value) {
        this._tags = value;
        this._changeDetectorRef.markForCheck();
    }
    /**
     * @return {?}
     */
    get tags() {
        return this._tags;
    }
    /**
     * Sets the tabindex of the contained tags. Default value: -1.
     * @param {?} value
     * @return {?}
     */
    set tabindex(value) {
        this._tabindex = coerceNumberProperty(value);
        this._changeDetectorRef.markForCheck();
    }
    /**
     * @return {?}
     */
    get tabindex() {
        return this.allowTagDeletion ? 0 : this._tabindex;
    }
    /**
     * Whether the tags can be removed from the list. Default: true.
     * @param {?} value
     * @return {?}
     */
    set allowTagDeletion(value) {
        this._allowTagDeletion = coerceBooleanProperty(value);
        this._changeDetectorRef.markForCheck();
    }
    /**
     * @return {?}
     */
    get allowTagDeletion() {
        return this._allowTagDeletion;
    }
    /**
     * Whether the tags can be styled as keywords.
     * @param {?} value
     * @return {?}
     */
    set isKeywordList(value) {
        this._isKeywordList = coerceBooleanProperty(value);
        this._changeDetectorRef.markForCheck();
    }
    /**
     * @return {?}
     */
    get isKeywordList() {
        return this._isKeywordList;
    }
    /**
     * Sets the label property, in case tags represent objects.
     * @param {?} value
     * @return {?}
     */
    set labelProp(value) {
        if (this._labelProperty !== value) {
            this._labelProperty = value;
            this._changeDetectorRef.markForCheck();
        }
    }
    /**
     * @return {?}
     */
    get labelProp() {
        return this._labelProperty;
    }
    /**
     * Sets the label property to improve accessibility.
     * @param {?} value
     * @return {?}
     */
    set labelledby(value) {
        if (this._ariaLabelledBy !== value) {
            this._ariaLabelledBy = value;
            this._changeDetectorRef.markForCheck();
        }
    }
    /**
     * @return {?}
     */
    get labelledby() {
        return this._ariaLabelledBy;
    }
    /**
     * Sets the customization function for tag value.
     * @param {?} fn
     * @return {?}
     */
    set valueFormatter(fn) {
        this._valueFormatterFn = fn;
        this._changeDetectorRef.markForCheck();
    }
    /**
     * @return {?}
     */
    get valueFormatter() {
        return this._valueFormatterFn;
    }
    /**
     * Allows to delete a tag given index. Takes index of the tag to be deleted as a parameter
     * @param {?} index
     * @param {?} value
     * @return {?}
     */
    delete(index, value) {
        if (this.allowTagDeletion) {
            this.tags = [
                ...this.tags.slice(0, index),
                ...this.tags.slice(index + 1)
            ];
            // focus next element after deletion
            if (this.tagChildren.toArray()[index + 1]) {
                this.tagChildren.toArray()[index + 1].nativeElement.focus();
            }
            this._onChange(this.tags);
            this.tagsChange.emit(this.tags);
        }
    }
    /**
     * Allows to add a tag. Takes tag object as an input
     * @param {?} tag
     * @return {?}
     */
    addTag(tag) {
        if (!tag) {
            return;
        }
        // make sure tag is either string or has the configured label prop and is not yet in the list
        if ((typeof tag === 'string' && this.tags.indexOf(tag) === -1) ||
            (tag[this.labelProp] && this.tags.filter((/**
             * @param {?} t
             * @return {?}
             */
            (t) => t[this.labelProp] === tag[this.labelProp])).length < 1)) {
            this.tags = [...this.tags, tag];
            this._onChange(this.tags);
            this.tagsChange.emit(this.tags);
        }
    }
    /**
     * Allows to clear the tag list.
     * @return {?}
     */
    clearTags() {
        this.tags = [];
        this._onChange(this.tags);
        this.tagsChange.emit(this.tags);
    }
    /**
     * \@docs-private
     * @param {?} tags
     * @return {?}
     */
    writeValue(tags) {
        this.tags = tags;
    }
    /**
     * @param {?} fn
     * @return {?}
     */
    registerOnChange(fn) {
        this._onChange = fn;
    }
    /**
     * @param {?} fn
     * @return {?}
     */
    registerOnTouched(fn) {
        this._onTouched = fn;
    }
    /**
     * \@docs-private
     * @param {?} tag
     * @return {?}
     */
    renderTag(tag) {
        /** @type {?} */
        const tagStr = typeof tag === 'string' ? tag : tag[this.labelProp];
        return this.valueFormatter(tagStr);
    }
    /**
     * \@docs-private
     * @param {?} index
     * @param {?} value
     * @return {?}
     */
    tagClick(index, value) {
        this.tagClickEvent.emit(this.tags[index]);
    }
}
NxTaglistComponent.decorators = [
    { type: Component, args: [{
                selector: 'nx-taglist',
                template: "  <ul class=\"nx-taglist\" *ngIf=\"tags.length > 0\">\n    <li class=\"nx-taglist__list-item\" tabindex=\"-1\" *ngFor=\"let tag of tags; let i = index\">\n      <nx-tag [value]=\"renderTag(tag)\" [removable]=\"allowTagDeletion\" [tabindex]=\"tabindex\" (clicked)=\"tagClick(i, $event)\" (removed)=\"delete(i, $event)\"></nx-tag>\n  </li>\n  </ul>\n  <ng-content *ngIf=\"tags.length < 1\"></ng-content>\n",
                changeDetection: ChangeDetectionStrategy.OnPush,
                providers: [
                    {
                        provide: NG_VALUE_ACCESSOR,
                        useExisting: forwardRef((/**
                         * @return {?}
                         */
                        () => NxTaglistComponent)),
                        multi: true
                    }
                ],
                host: {
                    '[class.nx-taglist--keyword]': 'isKeywordList',
                    '[attr.aria-labelledby]': 'labelledby || null',
                    '[attr.tabindex]': '-1'
                },
                styles: [":host{position:relative;min-height:32px;margin-bottom:32px;display:flex;justify-content:space-between}:host:focus{outline:0}.nx-taglist{display:flex;flex-wrap:wrap}.nx-taglist__list-item{list-style:none;margin-right:12px;margin-bottom:12px;flex-wrap:wrap;display:flex}@media (max-width:703px){.nx-taglist--keyword{justify-content:center}}"]
            }] }
];
/** @nocollapse */
NxTaglistComponent.ctorParameters = () => [
    { type: ChangeDetectorRef }
];
NxTaglistComponent.propDecorators = {
    tagsChange: [{ type: Output, args: ['nxTagsChange',] }],
    tagClickEvent: [{ type: Output, args: ['nxTagClick',] }],
    tagChildren: [{ type: ViewChildren, args: [NxTagComponent, { read: ElementRef },] }],
    tags: [{ type: Input, args: ['nxTags',] }],
    tabindex: [{ type: Input }],
    allowTagDeletion: [{ type: Input, args: ['nxAllowTagDeletion',] }],
    isKeywordList: [{ type: Input, args: ['nxIsKeywordList',] }],
    labelProp: [{ type: Input, args: ['nxLabelProperty',] }],
    labelledby: [{ type: Input, args: ['aria-labelledby',] }],
    valueFormatter: [{ type: Input, args: ['nxValueFormatter',] }]
};
if (false) {
    /**
     * An event is dispatched each time when the list of tags changed.
     * @type {?}
     */
    NxTaglistComponent.prototype.tagsChange;
    /**
     * An event is dispatched each time when a tag is clicked.
     * @type {?}
     */
    NxTaglistComponent.prototype.tagClickEvent;
    /**
     * \@docs-private
     * @type {?}
     */
    NxTaglistComponent.prototype.tagChildren;
    /**
     * @type {?}
     * @private
     */
    NxTaglistComponent.prototype._tags;
    /**
     * @type {?}
     * @private
     */
    NxTaglistComponent.prototype._tabindex;
    /**
     * @type {?}
     * @private
     */
    NxTaglistComponent.prototype._allowTagDeletion;
    /**
     * @type {?}
     * @private
     */
    NxTaglistComponent.prototype._isKeywordList;
    /**
     * @type {?}
     * @private
     */
    NxTaglistComponent.prototype._labelProperty;
    /**
     * @type {?}
     * @private
     */
    NxTaglistComponent.prototype._ariaLabelledBy;
    /**
     * @type {?}
     * @private
     */
    NxTaglistComponent.prototype._valueFormatterFn;
    /**
     * @type {?}
     * @private
     */
    NxTaglistComponent.prototype._onChange;
    /**
     * @type {?}
     * @private
     */
    NxTaglistComponent.prototype._onTouched;
    /**
     * @type {?}
     * @private
     */
    NxTaglistComponent.prototype._changeDetectorRef;
}

/**
 * @fileoverview added by tsickle
 * Generated from: taglist/taglist.module.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class NxTaglistModule {
}
NxTaglistModule.decorators = [
    { type: NgModule, args: [{
                declarations: [NxTaglistComponent, NxTagComponent],
                exports: [NxTaglistComponent, NxTagComponent],
                imports: [CommonModule, NxIconModule]
            },] }
];

/**
 * @fileoverview added by tsickle
 * Generated from: taglist/public-api.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * Generated from: image/image.directive.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class NxImageDirective {
    constructor() {
        console.warn('Directive nxImg which was used together with nxFigure ' +
            'is now deprecated and not required anymore. Please remove it from your ' +
            'tag. Check the documentation for more details.');
    }
}
NxImageDirective.decorators = [
    { type: Directive, args: [{
                selector: 'img[nxImg]'
            },] }
];
/** @nocollapse */
NxImageDirective.ctorParameters = () => [];

/**
 * @fileoverview added by tsickle
 * Generated from: image/figure.component.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const DEFAULT_SIZE$2 = 'auto';
class NxFigureComponent {
    /**
     * Sets the type of the visual appearance of the image.
     * The default value  is 'auto'.
     * @param {?} value
     * @return {?}
     */
    set classNames(value) {
        if (this._classNames === value) {
            return;
        }
        this._classNames = value;
        /** @type {?} */
        const sizeRegex = /^(auto|1by1|1dot8by1|1dot2by1|1by1dot1|2dot6by1)$/;
        const [size = null] = this._classNames.match(sizeRegex) || [DEFAULT_SIZE$2];
        this.size = (/** @type {?} */ (size));
        this.rounded = !!this._classNames.match(/rounded/);
    }
    /**
     * @return {?}
     */
    get classNames() {
        return this._classNames;
    }
}
NxFigureComponent.decorators = [
    { type: Component, args: [{
                // tslint:disable-next-line:component-selector
                selector: 'figure[nxFigure]',
                template: '<ng-content></ng-content>',
                changeDetection: ChangeDetectionStrategy.OnPush,
                host: {
                    '[class.nx-image--auto]': 'size === "auto" && !rounded',
                    '[class.nx-image--1by1]': 'size === "1by1"',
                    '[class.nx-image--1dot8by1]': 'size === "1dot8by1"',
                    '[class.nx-image--1dot2by1]': 'size === "1dot2by1"',
                    '[class.nx-image--1by1dot1]': 'size === "1by1dot1"',
                    '[class.nx-image--2dot6by1]': 'size === "2dot6by1"',
                    '[class.nx-image--rounded]': 'rounded'
                },
                styles: [":host{display:block;position:relative;line-height:0}:host ::ng-deep img{display:block;font-family:\"object-fit: cover;\";-o-object-fit:cover;object-fit:cover;height:100%;width:100%}:host(.nx-image--auto) ::ng-deep img{height:auto}:host(:not(.nx-image--auto)) ::ng-deep img{position:absolute;top:0;left:0}:host(.nx-image--rounded){padding-top:100%}:host(.nx-image--rounded) ::ng-deep img{border-radius:50%;bottom:0;left:0;position:absolute;right:0;top:0}:host(.nx-image--1by1){padding-top:100%}:host(.nx-image--1dot8by1){padding-top:55.55556%}:host(.nx-image--1dot2by1){padding-top:83.33333%}:host(.nx-image--1by1dot1){padding-top:110%}:host(.nx-image--2dot6by1){padding-top:38.46154%}:host(.nx-image--1by1dot4){padding-top:140%}"]
            }] }
];
NxFigureComponent.propDecorators = {
    classNames: [{ type: Input, args: ['nxFigure',] }]
};
if (false) {
    /**
     * @type {?}
     * @private
     */
    NxFigureComponent.prototype._classNames;
    /**
     * \@docs-private
     * @type {?}
     */
    NxFigureComponent.prototype.rounded;
    /**
     * \@docs-private
     * @type {?}
     */
    NxFigureComponent.prototype.size;
}

/**
 * @fileoverview added by tsickle
 * Generated from: image/image.module.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class NxImageModule {
}
NxImageModule.decorators = [
    { type: NgModule, args: [{
                declarations: [NxFigureComponent, NxImageDirective],
                exports: [NxFigureComponent, NxImageDirective]
            },] }
];

/**
 * @fileoverview added by tsickle
 * Generated from: image/public-api.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * Generated from: video/video.component.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
// note that this currently only supports youtube videos
class NxVideoComponent {
    /**
     * @param {?} sanitizer
     * @param {?} _changeDetectorRef
     */
    constructor(sanitizer, _changeDetectorRef) {
        this.sanitizer = sanitizer;
        this._changeDetectorRef = _changeDetectorRef;
        this._videoId = null;
        this._altText = '';
        this._playButtonAriaLabel = '';
        this._previewImageSrc = null;
        this._showPlayerControls = true;
        this._allowFullScreen = true;
        this._interfaceLanguage = null;
        /**
         * \@docs-private
         */
        this.showPlayer = false;
    }
    /**
     * Sets the id of the YouTube video.
     * @param {?} value
     * @return {?}
     */
    set videoId(value) {
        if (this._videoId !== value) {
            this._videoId = value;
            this._changeDetectorRef.markForCheck();
        }
    }
    /**
     * @return {?}
     */
    get videoId() {
        return this._videoId;
    }
    /**
     * Sets the value of the alt attribute for the preview image.
     * @param {?} value
     * @return {?}
     */
    set altText(value) {
        if (this._altText !== value) {
            this._altText = value;
            this._changeDetectorRef.markForCheck();
        }
    }
    /**
     * @return {?}
     */
    get altText() {
        return this._altText;
    }
    /**
     * Sets the value of the aria-label attribute on the play button (Default: Play Video).
     * @param {?} value
     * @return {?}
     */
    set nxPlayButtonAriaLabel(value) {
        if (this._playButtonAriaLabel !== value) {
            this._playButtonAriaLabel = value;
            this._changeDetectorRef.markForCheck();
        }
    }
    /**
     * @return {?}
     */
    get nxPlayButtonAriaLabel() {
        return this._playButtonAriaLabel;
    }
    /**
     * Sets the preview image. If this is not provided, an image from YouTube will be used as default.
     * @param {?} value
     * @return {?}
     */
    set previewImageSrc(value) {
        if (this._previewImageSrc !== value) {
            this._previewImageSrc = value;
            this._changeDetectorRef.markForCheck();
        }
    }
    /**
     * @return {?}
     */
    get previewImageSrc() {
        return this._previewImageSrc;
    }
    /**
     * Sets player controls. If set to false, player controls are not available.
     * @param {?} value
     * @return {?}
     */
    set showPlayerControls(value) {
        this._showPlayerControls = coerceBooleanProperty(value);
        this._changeDetectorRef.markForCheck();
    }
    /**
     * @return {?}
     */
    get showPlayerControls() {
        return this._showPlayerControls;
    }
    /**
     * Sets fullscreen option. If set to false, fullscreen option is not available.
     * @param {?} value
     * @return {?}
     */
    set allowFullScreen(value) {
        this._allowFullScreen = coerceBooleanProperty(value);
        this._changeDetectorRef.markForCheck();
    }
    /**
     * @return {?}
     */
    get allowFullScreen() {
        return this._allowFullScreen;
    }
    /**
     * Sets interface language. Can be used to override the interface language determined by YouTube.
     * @param {?} value
     * @return {?}
     */
    set interfaceLanguage(value) {
        if (this._interfaceLanguage !== value) {
            this._interfaceLanguage = value;
            this._changeDetectorRef.markForCheck();
        }
    }
    /**
     * @return {?}
     */
    get interfaceLanguage() {
        return this._interfaceLanguage;
    }
    /**
     * \@docs-private
     * @return {?}
     */
    select() {
        this.showPlayer = true;
        this._changeDetectorRef.markForCheck();
    }
    /**
     * Returns the safe resource URL of the YouTube video, given video id.
     * @return {?}
     */
    get videoSrc() {
        /** @type {?} */
        let url = `https://www.youtube.com/embed/${this.videoId}?rel=0&showinfo=0&autoplay=1`;
        if (!this.showPlayerControls) {
            url += '&controls=0';
        }
        if (!this.allowFullScreen) {
            url += '&fs=0';
        }
        if (this.interfaceLanguage) {
            url += `&hl=${this.interfaceLanguage}`;
        }
        return this.sanitizer.bypassSecurityTrustResourceUrl(url);
    }
    /**
     * Returns the preview image source URL, given video id.
     * @return {?}
     */
    get imgSrc() {
        return this.previewImageSrc ? this.previewImageSrc : `https://img.youtube.com/vi/${this.videoId}/sddefault.jpg`;
    }
    /**
     * Returns the labels for the control buttons.
     * @return {?}
     */
    get playButtonAriaLabel() {
        /** @type {?} */
        const defaultLabel = this.altText ? `${this.altText} - Play Video` : 'Play Video';
        return this.nxPlayButtonAriaLabel ? this.nxPlayButtonAriaLabel : defaultLabel;
    }
}
NxVideoComponent.decorators = [
    { type: Component, args: [{
                selector: 'nx-video',
                template: "<div class=\"nx-video\">\n  <div class=\"nx-video__iframe\">\n\n    <div *ngIf=\"!showPlayer\">\n\n      <button class=\"nx-video__play-button\"\n              (click)=\"select()\"\n              [attr.aria-label]=\"playButtonAriaLabel\"\n              (keydown.enter)=\"select()\">\n        <nx-icon class=\"nx-video__high-contrast-icon\" name=\"play\" size=\"s\"></nx-icon>\n      </button>\n      <img [src]=\"imgSrc\" class=\"nx-video__thumbnail\"\n           [alt]=\"altText\"\n           (click)=\"select()\"\n           (keydown.enter)=\"select()\">\n\n    </div>\n    <div *ngIf=\"videoId && showPlayer\">\n      <iframe title=\"video\" class=\"nx-video__iframe\" [attr.allowfullscreen]=\"allowFullScreen\" [src]=\"videoSrc\"></iframe>\n    </div>\n\n  </div>\n</div>\n",
                changeDetection: ChangeDetectionStrategy.OnPush,
                styles: [".nx-video{position:relative;padding-bottom:56.25%;overflow:hidden;width:100%;height:auto}.nx-video__iframe{position:absolute;top:0;left:0;width:100%;height:100%;border:none}.nx-video__thumbnail{position:absolute;cursor:pointer;width:100%;top:50%;left:50%;transform:translate(-50%,-50%);opacity:.7}.nx-video__play-button{border:none;background:url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0naHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcnIHhtbG5zOnhsaW5rPSdodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rJyB3aWR0aD0nODhweCcgaGVpZ2h0PSc1NnB4JyB2aWV3Qm94PScwIDAgODggNTYnIHZlcnNpb249JzEuMSc+PHRpdGxlPkF0b20gLyBNZWRpYSAvIFlvdVR1YmUgUGxheWVyIC8gW0Fzc2V0c10gLyBQbGF5IEJ1dHRvbjwvdGl0bGU+PGRlc2M+Q3JlYXRlZCB3aXRoIFNrZXRjaC48L2Rlc2M+PGRlZnM+PHJlY3QgaWQ9J3BhdGgtMScgeD0nMCcgeT0nMCcgd2lkdGg9Jzg4JyBoZWlnaHQ9JzU2JyByeD0nOCcvPjxmaWx0ZXIgeD0nLTQwLjklJyB5PSctNjQuMyUnIHdpZHRoPScxODEuOCUnIGhlaWdodD0nMjI4LjYlJyBmaWx0ZXJVbml0cz0nb2JqZWN0Qm91bmRpbmdCb3gnIGlkPSdmaWx0ZXItMic+PGZlT2Zmc2V0IGR4PScwJyBkeT0nMCcgaW49J1NvdXJjZUFscGhhJyByZXN1bHQ9J3NoYWRvd09mZnNldE91dGVyMScvPjxmZUdhdXNzaWFuQmx1ciBzdGREZXZpYXRpb249JzEyJyBpbj0nc2hhZG93T2Zmc2V0T3V0ZXIxJyByZXN1bHQ9J3NoYWRvd0JsdXJPdXRlcjEnLz48ZmVDb2xvck1hdHJpeCB2YWx1ZXM9JzAgMCAwIDAgMCAgIDAgMCAwIDAgMCAgIDAgMCAwIDAgMCAgMCAwIDAgMC41IDAnIHR5cGU9J21hdHJpeCcgaW49J3NoYWRvd0JsdXJPdXRlcjEnLz48L2ZpbHRlcj48L2RlZnM+PGcgaWQ9J0F0b20tLy1NZWRpYS0vLVlvdVR1YmUtUGxheWVyLS8tW0Fzc2V0c10tLy1QbGF5LUJ1dHRvbicgc3Ryb2tlPSdub25lJyBzdHJva2Utd2lkdGg9JzEnIGZpbGw9J25vbmUnIGZpbGwtcnVsZT0nZXZlbm9kZCc+PGcgaWQ9J0JhY2tncm91bmQnIG9wYWNpdHk9JzAuODAxMjM0MTQ5Jz48dXNlIGZpbGw9J2JsYWNrJyBmaWxsLW9wYWNpdHk9JzEnIGZpbHRlcj0ndXJsKCNmaWx0ZXItMiknIHhsaW5rOmhyZWY9JyNwYXRoLTEnLz48dXNlIGZpbGw9JyM0MTQxNDEnIGZpbGwtcnVsZT0nZXZlbm9kZCcgeGxpbms6aHJlZj0nI3BhdGgtMScvPjwvZz48cGF0aCBkPSdNNTQuMjExMTQ1NiwyOC44OTQ0MjcyIEwzMy40NDcyMTM2LDM5LjI3NjM5MzIgQzMyLjk1MzIzNTEsMzkuNTIzMzgyNSAzMi4zNTI1NjIxLDM5LjMyMzE1ODEgMzIuMTA1NTcyOCwzOC44MjkxNzk2IEMzMi4wMzYxNDUxLDM4LjY5MDMyNDIgMzIsMzguNTM3MjExMSAzMiwzOC4zODE5NjYgTDMyLDE3LjYxODAzNCBDMzIsMTcuMDY1NzQ5MiAzMi40NDc3MTUzLDE2LjYxODAzNCAzMywxNi42MTgwMzQgQzMzLjE1NTI0NTEsMTYuNjE4MDM0IDMzLjMwODM1ODIsMTYuNjU0MTc5MSAzMy40NDcyMTM2LDE2LjcyMzYwNjggTDU0LjIxMTE0NTYsMjcuMTA1NTcyOCBDNTQuNzA1MTI0MSwyNy4zNTI1NjIxIDU0LjkwNTM0ODUsMjcuOTUzMjM1MSA1NC42NTgzNTkyLDI4LjQ0NzIxMzYgQzU0LjU2MTU5NTUsMjguNjQwNzQxIDU0LjQwNDY3MywyOC43OTc2NjM1IDU0LjIxMTE0NTYsMjguODk0NDI3MiBaJyBpZD0nVHJpYW5nbGUnIGZpbGw9JyNGRkZGRkYnLz48L2c+PC9zdmc+) center no-repeat;cursor:pointer;position:absolute;width:88px;height:56px;z-index:1;border-radius:4px}.nx-video__play-button::-moz-focus-inner{border:0}.nx-video__play-button:focus{outline:0}.nx-video__high-contrast-icon{display:none}.nx-video__play-button,.nx-video__play-button:before{top:50%;left:50%;transform:translate(-50%,-50%)}:host-context([data-whatinput=keyboard]) .nx-video__play-button:focus{box-shadow:0 0 0 2px #fff,0 0 0 6px #009de6;box-shadow:var(--focus-box-shadow,0 0 0 2px #fff,0 0 0 6px #009de6)}@media screen and (-ms-high-contrast:active){.nx-video__play-button{background:buttonFace;border:1px solid buttonText;color:buttonText}.nx-video__high-contrast-icon{display:inline-flex;vertical-align:middle}:host-context([data-whatinput=keyboard]) .nx-video__play-button:focus{box-shadow:0 0 0 2px background,0 0 0 6px windowText}}"]
            }] }
];
/** @nocollapse */
NxVideoComponent.ctorParameters = () => [
    { type: DomSanitizer },
    { type: ChangeDetectorRef }
];
NxVideoComponent.propDecorators = {
    videoId: [{ type: Input, args: ['nxVideoId',] }],
    altText: [{ type: Input, args: ['nxAltText',] }],
    nxPlayButtonAriaLabel: [{ type: Input, args: ['nxPlayButtonAriaLabel',] }],
    previewImageSrc: [{ type: Input, args: ['nxPreviewImageSrc',] }],
    showPlayerControls: [{ type: Input, args: ['nxShowPlayerControls',] }],
    allowFullScreen: [{ type: Input, args: ['nxAllowFullScreen',] }],
    interfaceLanguage: [{ type: Input, args: ['nxInterfaceLanguage',] }]
};
if (false) {
    /**
     * @type {?}
     * @private
     */
    NxVideoComponent.prototype._videoId;
    /**
     * @type {?}
     * @private
     */
    NxVideoComponent.prototype._altText;
    /**
     * @type {?}
     * @private
     */
    NxVideoComponent.prototype._playButtonAriaLabel;
    /**
     * @type {?}
     * @private
     */
    NxVideoComponent.prototype._previewImageSrc;
    /**
     * @type {?}
     * @private
     */
    NxVideoComponent.prototype._showPlayerControls;
    /**
     * @type {?}
     * @private
     */
    NxVideoComponent.prototype._allowFullScreen;
    /**
     * @type {?}
     * @private
     */
    NxVideoComponent.prototype._interfaceLanguage;
    /**
     * \@docs-private
     * @type {?}
     */
    NxVideoComponent.prototype.showPlayer;
    /**
     * @type {?}
     * @private
     */
    NxVideoComponent.prototype.sanitizer;
    /**
     * @type {?}
     * @private
     */
    NxVideoComponent.prototype._changeDetectorRef;
}

/**
 * @fileoverview added by tsickle
 * Generated from: video/video.module.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class NxVideoModule {
}
NxVideoModule.decorators = [
    { type: NgModule, args: [{
                declarations: [NxVideoComponent],
                exports: [NxVideoComponent],
                imports: [CommonModule, NxIconModule]
            },] }
];

/**
 * @fileoverview added by tsickle
 * Generated from: video/public-api.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * Generated from: dropdown/dropdown-errors.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Returns an exception to be thrown when attempting to change a select's `multiple` option
 * after initialization.
 * \@docs-private
 * @return {?}
 */
function getNxDropdownDynamicMultipleError() {
    return Error('Cannot change `multiselect` mode of select after initialization.');
}
/**
 * Returns an exception to be thrown when attempting to assign a non-array value to a select
 * in `multiselect` mode. Note that `undefined` and `null` are still valid values to allow for
 * resetting the value.
 * \@docs-private
 * @return {?}
 */
function getNxDropdownNonArrayValueError() {
    return Error('Value must be an array in multiselect mode.');
}
/**
 * Returns an exception to be thrown when assigning a non-function value to the comparator
 * used to determine if a value corresponds to an option. Note that whether the function
 * actually takes two values and returns a boolean is not checked.
 * @return {?}
 */
function getNxDropdownNonFunctionValueError() {
    return Error('`compareWith` must be a function.');
}

/**
 * @fileoverview added by tsickle
 * Generated from: dropdown/dropdown.control.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @abstract
 */
class NxDropdownControl extends NxFormfieldControl {
    constructor() {
        super(...arguments);
        /**
         * Whether the dropdown should allow multi selection and additional checkboxes are shown.
         *
         * Note: Please make sure the value you bind is an array. If not an error is thrown!
         */
        this.isMultiSelect = false;
    }
}
NxDropdownControl.propDecorators = {
    isMultiSelect: [{ type: Input, args: ['nxIsMultiselect',] }]
};
if (false) {
    /**
     * Whether the dropdown should allow multi selection and additional checkboxes are shown.
     *
     * Note: Please make sure the value you bind is an array. If not an error is thrown!
     * @type {?}
     */
    NxDropdownControl.prototype.isMultiSelect;
    /**
     * \@docs-private
     * @abstract
     * @param {?} value
     * @return {?}
     */
    NxDropdownControl.prototype.formatValue = function (value) { };
}

/**
 * @fileoverview added by tsickle
 * Generated from: dropdown/group/dropdown-group.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class NxDropdownGroupComponent {
}
NxDropdownGroupComponent.decorators = [
    { type: Component, args: [{
                selector: 'nx-dropdown-group',
                template: "<div class=\"nx-dropdown-results__group\">\n  <div class=\"nx-dropdown-results__group-label\">{{label}}</div>\n  <ng-content></ng-content>\n</div>\n",
                changeDetection: ChangeDetectionStrategy.OnPush,
                styles: [":host{display:block}:host:first-child .nx-dropdown-results__group{background:rgba(236,236,236,.5);background:var(--dropdown-group-section-background-color,rgba(236,236,236,.5))}:host:first-child .nx-dropdown-results__group-label{padding-top:16px}.nx-dropdown-results__group-label{font-size:12px;font-size:var(--formfield-label-font-size,12px);line-height:16px;line-height:var(--formfield-label-line-height,16px);font-weight:var(--formfield-label-font-weight,600);letter-spacing:.5px;letter-spacing:var(--formfield-label-letter-spacing,.5px);font-style:italic;font-weight:700;padding:24px 32px 16px}"]
            }] }
];
NxDropdownGroupComponent.propDecorators = {
    label: [{ type: Input, args: ['nxLabel',] }]
};
if (false) {
    /**
     * Label displayed in the group.
     * @type {?}
     */
    NxDropdownGroupComponent.prototype.label;
}

/**
 * @fileoverview added by tsickle
 * Generated from: dropdown/item/dropdown-item.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class NxDropdownItemChange {
    /**
     * @param {?} item
     * @param {?=} isUserInput
     */
    constructor(item, isUserInput = false) {
        this.item = item;
        this.isUserInput = isUserInput;
    }
}
if (false) {
    /**
     * Reference to the option that emitted the event.
     * @type {?}
     */
    NxDropdownItemChange.prototype.item;
    /**
     * Whether the change in the option's value was a result of a user action.
     * @type {?}
     */
    NxDropdownItemChange.prototype.isUserInput;
}
/**
 * the unique id counter
 * @type {?}
 */
let nextId$8 = 0;
class NxDropdownItemComponent {
    /**
     * @param {?} _dropdown
     * @param {?} group
     * @param {?} _changeDetectorRef
     * @param {?} _elementRef
     */
    constructor(_dropdown, group, _changeDetectorRef, _elementRef) {
        this._dropdown = _dropdown;
        this.group = group;
        this._changeDetectorRef = _changeDetectorRef;
        this._elementRef = _elementRef;
        this._hidden = false;
        this._mostRecentViewValue = '';
        this._id = `nx-dropdown-item-${nextId$8++}`;
        this._selected = false;
        /**
         * Emits whenever the component is destroyed.
         */
        this._destroy = new Subject();
        /**
         * Event emitted when the option is selected or deselected.
         */
        // tslint:disable-next-line:no-output-on-prefix
        this.onSelectionChange = new EventEmitter();
        /**
         * Emits when the state of the option changes and any parents have to be notified.
         */
        this._stateChanges = new Subject();
        ((/** @type {?} */ (this._dropdown))).filterChanges.pipe(takeUntil(this._destroy)).subscribe((/**
         * @param {?} value
         * @return {?}
         */
        (value) => {
            this._showOrHideByFilter(value);
        }));
        // reset the hidden state when dropdown closes that on next open the user is seeing the full list again
        ((/** @type {?} */ (this._dropdown)))._closedStream.pipe(takeUntil(this._destroy)).subscribe((/**
         * @return {?}
         */
        () => {
            this._hidden = false;
        }));
    }
    /**
     * The unique ID of the option.
     * @return {?}
     */
    get id() { return this._id; }
    /**
     * Whether the item is selected.
     * @return {?}
     */
    get selected() {
        return this._selected;
    }
    /**
     * Whether the item is active.
     * @return {?}
     */
    get active() {
        return this._active;
    }
    /**
     * \@docs-private
     * Whether the parent dropdown is in multiselect mode.
     * @return {?}
     */
    get multiselect() {
        return this._dropdown && this._dropdown.isMultiSelect;
    }
    /**
     * @return {?}
     */
    ngAfterViewChecked() {
        // Since the parent dropdown component could be using the item's label to display the selected values
        // and it doesn't have a way of knowing if the item's label has changed
        // we have to check for changes in the DOM ourselves and dispatch an event. These checks are
        // relatively cheap, however we still limit them only to selected options in order to avoid
        // hitting the DOM too often.
        if (this._selected) {
            /** @type {?} */
            const viewValue = this.viewValue;
            if (viewValue !== this._mostRecentViewValue) {
                this._mostRecentViewValue = viewValue;
                this._stateChanges.next();
            }
        }
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this._stateChanges.complete();
        this._destroy.next();
        this._destroy.complete();
    }
    /**
     * @param {?} event
     * @return {?}
     */
    _onClick(event) {
        /* preventDefault to stop triggering the event twice when you click on the checkbox or the label inside the item */
        event.preventDefault();
        event.stopPropagation();
        this._selectViaInteraction();
    }
    /**
     * `Selects the option while indicating the selection came from the user. Used to
     * determine if the select's view -> model callback should be invoked.`
     * @return {?}
     */
    _selectViaInteraction() {
        this._selected = this.multiselect ? !this._selected : true;
        this._changeDetectorRef.markForCheck();
        this._emitSelectionChangeEvent(true);
    }
    /**
     * \@docs-private
     * @return {?}
     */
    show() {
        this._hidden = false;
        this._changeDetectorRef.markForCheck();
    }
    /**
     * \@docs-private
     * @return {?}
     */
    hide() {
        this._hidden = true;
        this._changeDetectorRef.markForCheck();
    }
    /**
     * @private
     * @param {?} search
     * @return {?}
     */
    _showOrHideByFilter(search) {
        /** @type {?} */
        const constraint = ((/** @type {?} */ (this._dropdown))).filterFn(search, this.viewValue);
        this._hidden = constraint ? false : true;
        this._changeDetectorRef.markForCheck();
    }
    /**
     * @return {?}
     */
    get _formattedValue() {
        return ((/** @type {?} */ (this._dropdown))).valueFormatter(this.value);
    }
    /**
     * \@docs-private
     * @return {?}
     */
    get viewValue() {
        return (this._elementRef.nativeElement.textContent || '').trim();
    }
    /**
     * \@docs-private
     * @return {?}
     */
    get elementRef() {
        return this._elementRef;
    }
    /**
     * @return {?}
     */
    select() {
        if (!this._selected) {
            this._selected = true;
            this._changeDetectorRef.markForCheck();
            this._emitSelectionChangeEvent();
        }
    }
    /**
     * \@docs-private
     * @return {?}
     */
    deselect() {
        if (this._selected) {
            this._selected = false;
            this._changeDetectorRef.markForCheck();
            this._emitSelectionChangeEvent();
        }
    }
    /**
     * \@docs-private
     * @return {?}
     */
    focus() {
        this._elementRef.nativeElement.focus();
    }
    /**
     * @private
     * @param {?=} isUserInput
     * @return {?}
     */
    _emitSelectionChangeEvent(isUserInput = false) {
        this.onSelectionChange.emit(new NxDropdownItemChange(this, isUserInput));
    }
    /**
     * \@docs-private
     * @return {?}
     */
    setActiveStyles() {
        this._active = true;
        this._changeDetectorRef.markForCheck();
    }
    /**
     * \@docs-private
     * @return {?}
     */
    setInactiveStyles() {
        this._active = false;
        this._changeDetectorRef.markForCheck();
    }
    /**
     * Returns the list item's text label. Implemented as a part of the ListKeyManagerOption.
     * \@docs-private
     * @return {?}
     */
    getLabel() {
        return this.viewValue;
    }
    /**
     * @param {?} element
     * @return {?}
     */
    _isContentEmpty(element) {
        return element.children.length === 0 && !element.textContent.trim();
    }
    /**
     * @return {?}
     */
    _onLabelChange() {
        // trigger change detection when the label content changes for the case that ng-content was empty before.
        // this is also important when the label comes in deferred, e.g. by a delayed observable,
        // then first the default label derived from the value is shown
        // and after the value from the async observable is ready we need to trigger change detection that the derived label
        // gets hidden again.
        // Notice(!): the event of (cdkObserveContent) is run outside of the ngZone
        // We run detectChanges directly here as markForCheck wasn't enough to always trigger change detection correctly
        this._changeDetectorRef.detectChanges();
    }
}
NxDropdownItemComponent.decorators = [
    { type: Component, args: [{
                selector: 'nx-dropdown-item',
                template: "<div #container class=\"nx-dropdown-results__option\"\n     [ngClass]=\"{'nx-dropdown-results__option--selected': selected}\">\n\n   <nx-checkbox *ngIf=\"multiselect\" [checked]=\"selected\">\n      <ng-container *ngTemplateOutlet=\"contentTemplate\"></ng-container>\n    </nx-checkbox>\n\n    <span *ngIf=\"!multiselect\" class=\"nx-dropdown-results__option-checkicon\">\n       <nx-icon name=\"check\" aria-hidden=\"true\"></nx-icon>\n    </span>\n\n    <ng-container *ngIf=\"!multiselect\">\n      <ng-container *ngTemplateOutlet=\"contentTemplate\"></ng-container>\n    </ng-container>\n</div>\n\n<ng-template #contentTemplate>\n  <div class=\"nx-dropdown-results__option-label\" >\n    <span #content (cdkObserveContent)=\"_onLabelChange()\">\n      <ng-content></ng-content>\n    </span>\n    <ng-container *ngIf=\"_isContentEmpty(content)\">\n      {{_formattedValue}}\n    </ng-container>\n  </div>\n</ng-template>\n",
                changeDetection: ChangeDetectionStrategy.OnPush,
                host: {
                    '[id]': 'id',
                    'role': 'option',
                    '[attr.aria-selected]': 'selected.toString()',
                    '[class.nx-hidden]': '_hidden',
                    '[class.nx-dropdown-item--active]': 'active',
                    '[class.nx-selected]': 'selected',
                    '[class.nx-multiselect]': 'multiselect',
                    '(click)': '_onClick($event)'
                },
                styles: [":host{display:block}:host(.nx-hidden){display:none}:host:first-child .nx-dropdown-results__option{padding-top:16px}:host:last-child .nx-dropdown-results__option{padding-bottom:16px}nx-checkbox{margin-bottom:0}.nx-dropdown-results__option{font-size:20px;font-size:var(--dropdown-item-font-size,20px);line-height:28px;line-height:var(--dropdown-item-line-height,28px);font-weight:400;font-weight:var(--dropdown-item-font-weight,400);letter-spacing:.2px;letter-spacing:var(--dropdown-item-letter-spacing,.2px);padding:8px 32px 8px 8px;cursor:pointer;position:relative;display:flex;max-width:100%;white-space:nowrap}.nx-dropdown-results__option-label{padding:0 12px;margin:0 -12px;color:#414141;color:var(--dropdown-item-text-color,#414141);white-space:pre-line}@media screen and (-ms-high-contrast:active){.nx-dropdown-results__option-label{-ms-high-contrast-adjust:none;color:buttonText;background-color:buttonFace;border-radius:4px}}:host(.nx-multiselect) .nx-dropdown-results__option{display:block;padding-left:32px}:host(.nx-selected):hover .nx-dropdown-results__option-checkicon,:host(.nx-selected):hover .nx-dropdown-results__option-label,:host:hover .nx-dropdown-results__option-label{color:#006192;color:var(--hover-primary,#006192)}@media screen and (-ms-high-contrast:active){:host(.nx-dropdown-item--active):not(.nx-multiselect) .nx-dropdown-results__option-label,:host:hover .nx-dropdown-results__option-label{color:highlightText;background-color:highlight}:host(.nx-dropdown-item--active):not(.nx-multiselect) .nx-dropdown-results__option-checkicon{-ms-high-contrast-adjust:none;color:highlightText;background:highlight;z-index:1}}:host(.nx-selected) .nx-dropdown-results__option-checkicon{opacity:1}:host(.nx-selected) .nx-dropdown-results__option-label{color:#414141;color:var(--dropdown-item-selected-color,#414141)}.nx-dropdown-results__option-checkicon{opacity:0;margin-right:8px;height:28px;height:var(--dropdown-item-line-height,28px);color:#414141;color:var(--dropdown-item-checkmark-color,#414141)}.nx-dropdown-results__option-checkicon nx-icon{line-height:28px;line-height:var(--dropdown-item-line-height,28px);font-size:16px}\n:host-context([data-whatinput=\"keyboard\"] .nx-dropdown__panel-body.is-stable).nx-dropdown-item--active .nx-dropdown-results__option .nx-dropdown-results__option-label {\n  border-radius: 4px;\n  box-shadow: 0 0 0 2px #ffffff, 0 0 0 6px #009DE6;\n  box-shadow: var(--focus-box-shadow, 0 0 0 2px #ffffff, 0 0 0 6px #009DE6); }\n  @media screen and (-ms-high-contrast: active) {\n    :host-context([data-whatinput=\"keyboard\"] .nx-dropdown__panel-body.is-stable).nx-dropdown-item--active .nx-dropdown-results__option .nx-dropdown-results__option-label {\n      box-shadow: 0 0 0 2px background, 0 0 0 6px windowText; } }\n\n\n:host-context([data-whatinput=\"keyboard\"] .nx-dropdown__panel-body.is-stable).nx-multiselect.nx-dropdown-item--active .nx-dropdown-results__option .nx-dropdown-results__option-label {\n  box-shadow: none; }\n  @media screen and (-ms-high-contrast: active) {\n    :host-context([data-whatinput=\"keyboard\"] .nx-dropdown__panel-body.is-stable).nx-multiselect.nx-dropdown-item--active .nx-dropdown-results__option .nx-dropdown-results__option-label {\n      box-shadow: none; } }\n\n:host-context([data-whatinput=\"keyboard\"] .nx-dropdown__panel-body.is-stable).nx-multiselect.nx-dropdown-item--active ::ng-deep .nx-checkbox__label {\n  border-radius: 4px;\n  box-shadow: 0 0 0 2px #ffffff, 0 0 0 6px #009DE6;\n  box-shadow: var(--focus-box-shadow, 0 0 0 2px #ffffff, 0 0 0 6px #009DE6); }\n  @media screen and (-ms-high-contrast: active) {\n    :host-context([data-whatinput=\"keyboard\"] .nx-dropdown__panel-body.is-stable).nx-multiselect.nx-dropdown-item--active ::ng-deep .nx-checkbox__label {\n      box-shadow: 0 0 0 2px background, 0 0 0 6px windowText; } }\n\n:host(.nx-selected.nx-dropdown-item--active) .nx-dropdown-results__option-label{padding-left:24px;margin-left:-24px}:host ::ng-deep .nx-checkbox__label{padding:0 4px;margin:0 -4px}"]
            }] }
];
/** @nocollapse */
NxDropdownItemComponent.ctorParameters = () => [
    { type: NxDropdownControl, decorators: [{ type: Inject, args: [NxDropdownControl,] }] },
    { type: NxDropdownGroupComponent, decorators: [{ type: Optional }] },
    { type: ChangeDetectorRef },
    { type: ElementRef }
];
NxDropdownItemComponent.propDecorators = {
    value: [{ type: Input, args: ['nxValue',] }],
    onSelectionChange: [{ type: Output }],
    containerElement: [{ type: ViewChild, args: ['container', { static: true },] }]
};
if (false) {
    /** @type {?} */
    NxDropdownItemComponent.prototype._hidden;
    /**
     * @type {?}
     * @private
     */
    NxDropdownItemComponent.prototype._mostRecentViewValue;
    /**
     * @type {?}
     * @private
     */
    NxDropdownItemComponent.prototype._id;
    /**
     * The value of the dropdown item.
     * You can't use undefined, null and '' (empty strings)
     * as they are sentinel values signalling empty data.
     * @type {?}
     */
    NxDropdownItemComponent.prototype.value;
    /**
     * @type {?}
     * @private
     */
    NxDropdownItemComponent.prototype._selected;
    /**
     * @type {?}
     * @private
     */
    NxDropdownItemComponent.prototype._active;
    /**
     * Emits whenever the component is destroyed.
     * @type {?}
     * @private
     */
    NxDropdownItemComponent.prototype._destroy;
    /**
     * Event emitted when the option is selected or deselected.
     * @type {?}
     */
    NxDropdownItemComponent.prototype.onSelectionChange;
    /**
     * Emits when the state of the option changes and any parents have to be notified.
     * @type {?}
     */
    NxDropdownItemComponent.prototype._stateChanges;
    /**
     * \@docs-private
     * The wrapping div in the template. Used by dropdown to use the container height for scrolling.
     * @type {?}
     */
    NxDropdownItemComponent.prototype.containerElement;
    /**
     * @type {?}
     * @private
     */
    NxDropdownItemComponent.prototype._dropdown;
    /**
     * \@docs-private
     * @type {?}
     */
    NxDropdownItemComponent.prototype.group;
    /**
     * @type {?}
     * @private
     */
    NxDropdownItemComponent.prototype._changeDetectorRef;
    /**
     * @type {?}
     * @private
     */
    NxDropdownItemComponent.prototype._elementRef;
}

/**
 * @fileoverview added by tsickle
 * Generated from: dropdown/closed-label.directive.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
// This Directive solely purpose is to mark given ng-template and project it into the required destination.
class NxDropdownClosedLabelDirective {
    /**
     * @param {?} templateRef
     */
    constructor(templateRef) {
        this.templateRef = templateRef;
    }
}
NxDropdownClosedLabelDirective.decorators = [
    { type: Directive, args: [{
                selector: '[nxClosedLabel]'
            },] }
];
/** @nocollapse */
NxDropdownClosedLabelDirective.ctorParameters = () => [
    { type: TemplateRef }
];
if (false) {
    /** @type {?} */
    NxDropdownClosedLabelDirective.prototype.templateRef;
}

/**
 * @fileoverview added by tsickle
 * Generated from: dropdown/dropdown.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Change event object that is emitted when the select value has changed.
 * @template T
 */
class NxDropdownSelectChange {
    /**
     * @param {?} source
     * @param {?} value
     */
    constructor(source, value) {
        this.source = source;
        this.value = value;
    }
}
if (false) {
    /**
     * Reference to the select that emitted the change event.
     * @type {?}
     */
    NxDropdownSelectChange.prototype.source;
    /**
     * Current value of the select that emitted the event.
     * @type {?}
     */
    NxDropdownSelectChange.prototype.value;
}
/**
 * @return {?}
 */
function getPositions() {
    return [{
            originX: 'start',
            originY: 'top',
            overlayX: 'start',
            overlayY: 'top'
        }, {
            originX: 'start',
            originY: 'center',
            overlayX: 'start',
            overlayY: 'center'
        }, {
            originX: 'start',
            originY: 'bottom',
            overlayX: 'start',
            overlayY: 'bottom'
        }];
}
class NxDropdownComponent extends NxDropdownControl {
    /**
     * @param {?} _changeDetectorRef
     * @param {?} _elementRef
     * @param {?} _ngZone
     * @param {?} tabIndex
     * @param {?} formFieldComponent
     * @param {?} ngControl
     * @param {?} _parentForm
     * @param {?} _parentFormGroup
     */
    constructor(_changeDetectorRef, _elementRef, _ngZone, tabIndex, formFieldComponent, ngControl, _parentForm, _parentFormGroup) {
        super();
        this._changeDetectorRef = _changeDetectorRef;
        this._elementRef = _elementRef;
        this._ngZone = _ngZone;
        this.formFieldComponent = formFieldComponent;
        this.ngControl = ngControl;
        this._parentForm = _parentForm;
        this._parentFormGroup = _parentFormGroup;
        // The dropdown currently doesn't support readonly of the NxFormfieldControl so we hardcode it here
        this.readonly = false;
        this._disabled = false;
        this._focused = false;
        /**
         * Whether or not the overlay panel is open.
         */
        this._panelOpen = false;
        /**
         * \@docs-private
         */
        this.errorState = false;
        /**
         * \@docs-private
         */
        this.isStable = false;
        /**
         * Name of this control that is used inside the formfield component
         * \@docs-private
         */
        this.controlType = 'nx-dropdown';
        /**
         * The minimal space between the viewport and the overlay
         */
        this._overlayViewportMargin = 16;
        /**
         * \@docs-private
         * Emits when internal state changes to inform formfield about it.
         */
        this.stateChanges = new Subject();
        /**
         * The IDs of child options to be passed to the aria-owns attribute.
         */
        this._optionIds = '';
        this._tabIndex = 0;
        /**
         * \@docs-private
         */
        this.currentFilter = '';
        /**
         * Label to describe the component.
         */
        this._ariaLabel = '';
        this._style = '';
        /**
         * Whether the dropdown should render in its negative style or not.
         */
        this._negative = false;
        /**
         * Whether the dropdown should be shown with an additional filter input.
         */
        this.showFilter = false;
        /**
         * Text displayed as placeholder for the filter.
         */
        this.filterPlaceholder = '';
        /**
         * Event emitted when the select panel has been toggled.
         */
        this.openedChange = new EventEmitter();
        /**
         * Event emitted when the select has been opened.
         */
        this._openedStream = this.openedChange.pipe(filter((/**
         * @param {?} o
         * @return {?}
         */
        o => o)), map((/**
         * @return {?}
         */
        () => { })));
        /**
         * Event emitted when the select has been closed.
         */
        this._closedStream = this.openedChange.pipe(filter((/**
         * @param {?} o
         * @return {?}
         */
        o => !o)), map((/**
         * @return {?}
         */
        () => { })));
        /**
         * Event emitted when the user types in the filter input.
         */
        this.filterChanges = new Subject();
        /**
         * Event that emits whenever the raw value of the select changes. This is here primarily
         * to facilitate the two-way binding for the `value` input.
         * \@docs-private
         */
        this.valueChange = new EventEmitter();
        /**
         * Event emitted when the selected value has been changed.
         */
        this.selectionChange = new EventEmitter();
        /**
         * \@docs-private
         */
        this.optionSelectionChanges = defer((/**
         * @return {?}
         */
        () => {
            if (this.options) {
                return merge(...this.options.map((/**
                 * @param {?} option
                 * @return {?}
                 */
                option => option.onSelectionChange)));
            }
            return this._ngZone.onStable
                .asObservable()
                .pipe(take(1), switchMap((/**
             * @return {?}
             */
            () => this.optionSelectionChanges)));
        }));
        /**
         * Emits whenever the component is destroyed.
         */
        this._destroy = new Subject();
        /**
         * Function that transforms the value into a string.
         * This function is used for displaying and filtering the content
         * ( Default: (value) => value ? value.toString() : null; ).
         */
        this.valueFormatter = (/**
         * @param {?} value
         * @return {?}
         */
        (value) => {
            return value == null ? '' : value.toString();
        });
        /**
         * Comparison function to specify which option is displayed. Defaults to object equality.
         */
        this._compareWith = (/**
         * @param {?} o1
         * @param {?} o2
         * @return {?}
         */
        (o1, o2) => o1 === o2);
        this._filterFn = (/**
         * @param {?} search
         * @param {?} itemValue
         * @return {?}
         */
        (search, itemValue) => {
            return itemValue.toLocaleLowerCase().indexOf(search.toLocaleLowerCase()) >= 0;
        });
        /**
         * `View -> model callback called when value changes`
         */
        this._onChange = (/**
         * @return {?}
         */
        () => { });
        /**
         * `View -> model callback called when select has been touched`
         */
        this._onTouched = (/**
         * @return {?}
         */
        () => { });
        if (this.ngControl) {
            // Note: we provide the value accessor through here, instead of
            // the `providers` to avoid running into a circular import.
            this.ngControl.valueAccessor = this;
        }
        this._positions = getPositions();
        this.tabIndex = parseInt(tabIndex, 10) || 0;
    }
    /**
     * @return {?}
     */
    get tabIndex() { return this.disabled ? -1 : this._tabIndex; }
    /**
     * @param {?} value
     * @return {?}
     */
    set tabIndex(value) {
        // If the specified tabIndex value is null or undefined, fall back to the default value.
        this._tabIndex = value != null ? value : 0;
    }
    /**
     * Selected value
     * @return {?}
     */
    get value() { return this._value; }
    /**
     * @param {?} newValue
     * @return {?}
     */
    set value(newValue) {
        if (newValue !== this._value) {
            this.writeValue(newValue);
            this._value = newValue;
            this._onChange(newValue);
        }
    }
    /**
     * Whether the dropdown is disabled.
     * @return {?}
     */
    get disabled() {
        return this._disabled;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set disabled(value) {
        this._disabled = value;
    }
    /**
     * If set to 'negative', the component is displayed with the negative set of styles.
     * @param {?} value
     * @return {?}
     */
    set styles(value) {
        if (this._style === value) {
            return;
        }
        this._style = value;
        this._negative = !!this._style.match(/negative/);
    }
    /**
     * \@docs-private
     * @return {?}
     */
    get closedDropdownLabel() {
        return this._closedDropdownLabel;
    }
    /**
     * \@docs-private
     * The currently selected option.
     * @return {?}
     */
    get selected() {
        return this.isMultiSelect ? this._selectionModel.selected : this._selectionModel.selected[0];
    }
    /**
     * \@docs-private
     * @return {?}
     */
    get panelOpen() {
        return this._panelOpen;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set panelOpen(value) {
        this._panelOpen = value;
    }
    /**
     * \@docs-private
     * @return {?}
     */
    get label() {
        return this.formFieldComponent ? this.formFieldComponent.label : '';
    }
    /**
     * Function to compare the option values with the selected values. The first argument
     * is a value from an option. The second is a value from the selection. A boolean
     * should be returned.
     * @return {?}
     */
    get compareWith() { return this._compareWith; }
    /**
     * @param {?} fn
     * @return {?}
     */
    set compareWith(fn) {
        if (typeof fn !== 'function') {
            throw getNxDropdownNonFunctionValueError();
        }
        this._compareWith = fn;
        if (this._selectionModel) {
            // A different comparator means the selection could change.
            this._initializeSelection();
        }
    }
    /**
     * Function to be used when the user types into the search filter. The first argument is the user input,
     * the second argument is the dropdown item value. The dropdown items will use this function to set their
     * visibility state.
     * A boolean should be returned.
     * @return {?}
     */
    get filterFn() { return this._filterFn; }
    /**
     * @param {?} fn
     * @return {?}
     */
    set filterFn(fn) {
        if (typeof fn !== 'function') {
            throw getNxDropdownNonFunctionValueError();
        }
        this._filterFn = fn;
    }
    /**
     * \@docs-private
     * Whether the select is focused.
     * @return {?}
     */
    get focused() {
        return this._focused || this.panelOpen;
    }
    /**
     * \@docs-private
     * @return {?}
     */
    get elementRef() {
        return this._elementRef;
    }
    /**
     * @return {?}
     */
    ngDoCheck() {
        if (this.ngControl) {
            this.updateErrorState();
        }
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this._selectionModel = new SelectionModel(this.isMultiSelect);
    }
    /**
     * @return {?}
     */
    ngAfterContentInit() {
        this._closedDropdownLabel =
            this._customClosedDropdownLabel && this._customClosedDropdownLabel.templateRef || this._defaultClosedDropdownLabel;
        this._initKeyManager();
        this._selectionModel.changed.pipe(takeUntil(this._destroy)).subscribe((/**
         * @param {?} event
         * @return {?}
         */
        event => {
            event.added.forEach((/**
             * @param {?} option
             * @return {?}
             */
            option => option.select()));
            event.removed.forEach((/**
             * @param {?} option
             * @return {?}
             */
            option => option.deselect()));
        }));
        this.options.changes.pipe(startWith(null), takeUntil(this._destroy)).subscribe((/**
         * @return {?}
         */
        () => {
            this._resetOptions();
            this._initializeSelection();
        }));
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this._destroy.next();
        this._destroy.complete();
    }
    /**
     * \@docs-private
     * @param {?} control
     * @param {?} form
     * @return {?}
     */
    isErrorState(control, form) {
        return !!(control && control.invalid && (control.touched || (form && form.submitted)));
    }
    /**
     * \@docs-private
     * @return {?}
     */
    updateErrorState() {
        /** @type {?} */
        const oldState = this.errorState;
        /** @type {?} */
        const parent = this._parentFormGroup || this._parentForm;
        /** @type {?} */
        const control = this.ngControl ? (/** @type {?} */ (this.ngControl.control)) : null;
        /** @type {?} */
        const newState = this.isErrorState(control, parent);
        if (newState !== oldState) {
            this.errorState = newState;
            this.stateChanges.next();
        }
    }
    /**
     * Sets up a key manager to listen to keyboard events on the overlay panel.
     * @private
     * @return {?}
     */
    _initKeyManager() {
        this._keyManager = new ActiveDescendantKeyManager(this.options)
            .withTypeAhead()
            .withWrap()
            .withVerticalOrientation()
            .withHorizontalOrientation('ltr')
            .skipPredicate((/**
         * @param {?} item
         * @return {?}
         */
        item => item._hidden));
        this._keyManager.tabOut.pipe(takeUntil(this._destroy)).subscribe((/**
         * @return {?}
         */
        () => {
            // Restore focus to the trigger before closing. Ensures that the focus
            // position won't be lost if the user got focus into the overlay.
            this.closePanel();
        }));
        this._keyManager.change.pipe(takeUntil(this._destroy)).subscribe((/**
         * @return {?}
         */
        () => {
            if (this._panelOpen && this.panel) {
                // Delay the auto scrolling until all items have settled otherwise the item containers might
                // not exist yet
                this._ngZone.onStable
                    .asObservable()
                    .pipe(take(1)).subscribe((/**
                 * @return {?}
                 */
                () => {
                    this._scrollActiveOptionIntoView();
                }));
            }
            else if (!this._panelOpen && !this.isMultiSelect && this._keyManager.activeItem) {
                this._keyManager.activeItem._selectViaInteraction();
            }
        }));
    }
    /**
     * @private
     * @return {?}
     */
    _resetOptions() {
        /** @type {?} */
        const changedOrDestroyed = merge(this.options.changes, this._destroy);
        this.optionSelectionChanges.pipe(takeUntil(changedOrDestroyed)).subscribe((/**
         * @param {?} event
         * @return {?}
         */
        event => {
            this._onSelect(event.item, event.isUserInput);
            if (event.isUserInput && !this.isMultiSelect && this._panelOpen) {
                this.closePanel();
            }
        }));
        // Listen to changes in the internal state of the options and react accordingly.
        // Handles cases like the labels of the selected options changing.
        merge(...this.options.map((/**
         * @param {?} option
         * @return {?}
         */
        option => option._stateChanges)))
            .pipe(takeUntil(changedOrDestroyed))
            .subscribe((/**
         * @return {?}
         */
        () => {
            // defer it for the next cycle to not run in changed after checked errors
            // the combination of dropdown-item notifying parent and when the parent
            // tries to fetch the triggerValue from the child throws these errors
            setTimeout((/**
             * @return {?}
             */
            () => {
                this._changeDetectorRef.markForCheck();
                this.stateChanges.next();
            }));
        }));
        this._setOptionIds();
    }
    /**
     * Records option IDs to pass to the aria-owns property.
     * @private
     * @return {?}
     */
    _setOptionIds() {
        this._optionIds = this.options.map((/**
         * @param {?} option
         * @return {?}
         */
        option => option.id)).join(' ');
    }
    /**
     * Invoked when an option is clicked.
     * @private
     * @param {?} option
     * @param {?} isUserInput
     * @return {?}
     */
    _onSelect(option, isUserInput) {
        /** @type {?} */
        const wasSelected = this._selectionModel.isSelected(option);
        if (option.value == null && !this.isMultiSelect) {
            option.deselect();
            this._selectionModel.clear();
            this._propagateChanges(option.value);
        }
        else {
            option.selected ? this._selectionModel.select(option) : this._selectionModel.deselect(option);
            if (isUserInput) {
                this._keyManager.setActiveItem(option);
            }
            if (this.isMultiSelect) {
                this._sortValues();
            }
        }
        if (wasSelected !== this._selectionModel.isSelected(option)) {
            this._propagateChanges();
        }
        this.stateChanges.next();
    }
    /**
     * @private
     * @return {?}
     */
    _initializeSelection() {
        // Defer setting the value in order to avoid the "Expression
        // has changed after it was checked" errors from Angular.
        Promise.resolve().then((/**
         * @return {?}
         */
        () => {
            this._setSelectionByValue(this.ngControl ? this.ngControl.value : this._value);
        }));
    }
    /**
     * Sets the selected option based on a value. If no option can be
     * found with the designated value, the select trigger is cleared.
     * @private
     * @param {?} value
     * @return {?}
     */
    _setSelectionByValue(value) {
        if (this.isMultiSelect && value) {
            if (!Array.isArray(value)) {
                throw getNxDropdownNonArrayValueError();
            }
            this._selectionModel.clear();
            value.forEach((/**
             * @param {?} currentValue
             * @return {?}
             */
            (currentValue) => this._selectValue(currentValue)));
            this._sortValues();
        }
        else {
            this._selectionModel.clear();
            /** @type {?} */
            const correspondingOption = this._selectValue(value);
            // Shift focus to the active item. Note that we shouldn't do this in multiple
            // mode, because we don't know what option the user interacted with last.
            if (correspondingOption) {
                this._keyManager.setActiveItem(correspondingOption);
            }
        }
        this._changeDetectorRef.markForCheck();
    }
    /**
     * Finds and selects and option based on its value.
     * @private
     * @param {?} value
     * @return {?} Option that has the corresponding value.
     */
    _selectValue(value) {
        /** @type {?} */
        const correspondingOption = this.options.find((/**
         * @param {?} option
         * @return {?}
         */
        (option) => {
            try {
                // Treat null as a special reset value.
                return option.value != null && this._compareWith(option.value, value);
            }
            catch (error) {
                if (isDevMode()) {
                    // Notify developers of errors in their comparator.
                    console.warn(error);
                }
                return false;
            }
        }));
        if (correspondingOption) {
            this._selectionModel.select(correspondingOption);
        }
        return correspondingOption;
    }
    /**
     * Emits change event to set the model value.
     * @private
     * @param {?=} fallbackValue
     * @return {?}
     */
    _propagateChanges(fallbackValue) {
        /** @type {?} */
        let valueToEmit = null;
        if (this.isMultiSelect) {
            valueToEmit = ((/** @type {?} */ (this.selected))).map((/**
             * @param {?} option
             * @return {?}
             */
            option => option.value));
        }
        else {
            valueToEmit = this.selected ? ((/** @type {?} */ (this.selected))).value : fallbackValue;
        }
        this._value = valueToEmit;
        this.valueChange.emit(valueToEmit);
        this._onChange(valueToEmit);
        this.selectionChange.emit(new NxDropdownSelectChange(this, valueToEmit));
        this._changeDetectorRef.markForCheck();
    }
    /**
     * Sorts the selected values in the selected based on their order in the panel.
     * @private
     * @return {?}
     */
    _sortValues() {
        if (this.isMultiSelect) {
            /** @type {?} */
            const options = this.options.toArray();
            this._selectionModel.sort((/**
             * @param {?} a
             * @param {?} b
             * @return {?}
             */
            (a, b) => options.indexOf(a) - options.indexOf(b)));
            this.stateChanges.next();
        }
    }
    /**
     * Adds a offset to the overlay position, so the formfield label and the dropdown panel header are vertically aligned.
     * @private
     * @return {?}
     */
    _updatePositionOffset() {
        /** @type {?} */
        let offset = 0;
        if (this.formFieldComponent !== null) {
            /** @type {?} */
            const formFieldRect = this.formFieldComponent.elementRef.nativeElement.getBoundingClientRect();
            /** @type {?} */
            const dropdownRect = this._elementRef.nativeElement.getBoundingClientRect();
            /** @type {?} */
            const panelHeader = this.overlayDir.overlayRef.overlayElement.querySelector('.nx-dropdown__panel-header');
            /** @type {?} */
            const panelHeaderPaddingTop = panelHeader ? parseInt(getComputedStyle(panelHeader).paddingTop, 10) : 0;
            offset = formFieldRect.top - dropdownRect.top - panelHeaderPaddingTop;
        }
        this._positions[0].offsetY = offset;
    }
    /**
     * Focuses the select element.
     * @return {?}
     */
    focus() {
        this._elementRef.nativeElement.focus();
    }
    /**
     * Opens the panel of the dropdown.
     * @return {?}
     */
    openPanel() {
        if (this.disabled || !this.options || !this.options.length || this._panelOpen) {
            return;
        }
        this._panelOpen = true;
        this._triggerRect = this.trigger.nativeElement.getBoundingClientRect();
        this._keyManager.withHorizontalOrientation(null);
        this._highlightCorrectOption();
        this._changeDetectorRef.markForCheck();
    }
    /**
     * Closes the panel of the dropdown.
     * @return {?}
     */
    closePanel() {
        if (this._panelOpen) {
            this._panelOpen = false;
            this.isStable = false;
            this._keyManager.withHorizontalOrientation('ltr');
            this._changeDetectorRef.markForCheck();
            this._onTouched();
            this.openedChange.emit(false);
            // defer the focus if the dropdown triggers actions that detach
            // a template/view from the DOM to prevent changed after checked errors
            setTimeout((/**
             * @return {?}
             */
            () => this.focus()));
        }
    }
    // calculate inital scrollTop when the dropdown opens
    // scrolls the selected item to the middle of the panel if possible
    /**
     * @private
     * @return {?}
     */
    _calculateScrollTop() {
        // reset the scrolltop to make calculation easier
        this.panelBody.nativeElement.scrollTop = 0;
        if (!this.empty) {
            /** @type {?} */
            const offset = this._getItemOffset(this._keyManager.activeItem);
            /** @type {?} */
            const panelHeight = this.panelBody.nativeElement.offsetHeight;
            /** @type {?} */
            const panelRect = this.panelBody.nativeElement.getBoundingClientRect();
            /** @type {?} */
            const middleOfPanel = panelRect.top + panelHeight / 2;
            if (offset > middleOfPanel) {
                // because we reset the scrollTop to 0 at the top we can simply take the middleOfPanel which is our
                // target position for the item and subtract it from the offset (which is now always relative to the viewport)
                this.panelBody.nativeElement.scrollTop = offset - middleOfPanel;
            }
        }
    }
    /**
     * Scrolls the active option into view.
     * @private
     * @return {?}
     */
    _scrollActiveOptionIntoView() {
        if (!this.panelOpen || !this._keyManager.activeItem) {
            return;
        }
        /** @type {?} */
        const activeItem = this._keyManager.activeItem.containerElement.nativeElement;
        /** @type {?} */
        const panel = this.panelBody.nativeElement;
        /** @type {?} */
        const panelOffset = panel.offsetTop;
        // how much the overlay is repositioned on the page
        /** @type {?} */
        const panelTopScrollPosition = panel.scrollTop;
        /** @type {?} */
        const panelHeight = panel.clientHeight;
        /** @type {?} */
        const itemTop = activeItem.offsetTop - panelOffset;
        /** @type {?} */
        const itemBottom = activeItem.offsetTop - panelOffset + activeItem.getBoundingClientRect().height;
        // item half or less visible on top
        if (itemTop < panelTopScrollPosition) {
            this.panelBody.nativeElement.scrollTop = itemTop;
            // item half or less visible on bottom
        }
        else if (itemBottom > (panelTopScrollPosition + panelHeight)) {
            this.panelBody.nativeElement.scrollTop = itemBottom - panelHeight;
        }
    }
    /**
     * \@docs-private
     * @private
     * @param {?} item
     * @return {?}
     */
    _getItemOffset(item) {
        /** @type {?} */
        const itemRect = item.containerElement.nativeElement.getBoundingClientRect();
        return itemRect.top + (itemRect.height / 2); // get position of the item's center
    }
    /**
     * \@docs-private
     * Formfield Implementation
     * @param {?} ids
     * @return {?}
     */
    setDescribedByIds(ids) {
        this.ariaDescribedby = ids.join(' ');
    }
    /**
     * \@docs-private
     * @param {?} value
     * @return {?}
     */
    setAriaLabel(value) {
        this._ariaLabel = value;
    }
    /**
     * @return {?}
     */
    _getAriaLabel() {
        return this._ariaLabel || (this.formFieldComponent ? this.formFieldComponent.label : null);
    }
    /**
     * @return {?}
     */
    get _isInOutlineField() {
        return this.formFieldComponent !== null
            && this.formFieldComponent.appearance === 'outline';
    }
    /**
     * \@docs-private
     * Whether the select has a value.
     * @return {?}
     */
    get empty() {
        return !this._selectionModel || this._selectionModel.isEmpty();
    }
    /**
     * \@docs-private
     * @return {?}
     */
    get hasValue() {
        return this._selectionModel.hasValue();
    }
    /**
     * \@docs-private
     * @return {?}
     */
    get shouldLabelFloat() {
        return this.focused || !this.empty;
    }
    /** End Formfield */
    /** ControlValueAccessor */
    /**
     * Sets the select's value. Part of the ControlValueAccessor interface
     * required to integrate with Angular's core forms API.
     *
     * @param {?} value New value to be written to the model.
     * @return {?}
     */
    writeValue(value) {
        if (this.options) {
            this._setSelectionByValue(value);
        }
    }
    /**
     * @param {?} fn
     * @return {?}
     */
    registerOnChange(fn) {
        this._onChange = fn;
    }
    /**
     * @param {?} fn
     * @return {?}
     */
    registerOnTouched(fn) {
        this._onTouched = fn;
    }
    /**
     * Disables the select. Part of the ControlValueAccessor interface required
     * to integrate with Angular's core forms API.
     *
     * @param {?} isDisabled Sets whether the component is disabled.
     * @return {?}
     */
    setDisabledState(isDisabled) {
        this.disabled = isDisabled;
        this._changeDetectorRef.markForCheck();
        this.stateChanges.next();
    }
    /**
     * End ControlValueAccessor
     * @param {?} event
     * @return {?}
     */
    _handleKeydown(event) {
        this.panelOpen ? this._handleOpenKeydown(event) : this._handleClosedKeydown(event);
    }
    /**
     * @private
     * @param {?} event
     * @return {?}
     */
    _handleClosedKeydown(event) {
        /** @type {?} */
        const keyCode = event.keyCode;
        /** @type {?} */
        const isArrowKey = keyCode === DOWN_ARROW || keyCode === UP_ARROW ||
            keyCode === LEFT_ARROW || keyCode === RIGHT_ARROW;
        /** @type {?} */
        const isOpenKey = keyCode === ENTER || keyCode === SPACE;
        // Open the select on ALT + arrow key to match the native <select>
        if (isOpenKey || ((this.isMultiSelect || event.altKey) && isArrowKey)) {
            event.preventDefault(); // prevents the page from scrolling down when pressing space
            this.openPanel();
        }
        else if (!this.isMultiSelect && !this.disabled) {
            this._keyManager.onKeydown(event);
        }
    }
    /**
     * @private
     * @param {?} event
     * @return {?}
     */
    _handleOpenKeydown(event) {
        /** @type {?} */
        const keyCode = event.keyCode;
        // if has filter all events other than the listed ones should be ignored or handled in _onFilter()
        if (!([DOWN_ARROW, UP_ARROW, HOME, END, ENTER, LEFT_ARROW, RIGHT_ARROW, SHIFT, SPACE, TAB].indexOf(keyCode) >= 0)
            && this.showFilter) {
            return;
        }
        /** @type {?} */
        const isArrowKey = keyCode === DOWN_ARROW || keyCode === UP_ARROW;
        /** @type {?} */
        const manager = this._keyManager;
        /** @type {?} */
        const allHidden = this.options.map((/**
         * @param {?} option
         * @return {?}
         */
        option => option._hidden)).every((/**
         * @param {?} option
         * @return {?}
         */
        option => Boolean(option)));
        if (keyCode === HOME || keyCode === END) {
            event.preventDefault();
            keyCode === HOME ? manager.setFirstItemActive() : manager.setLastItemActive();
        }
        else if (isArrowKey && event.altKey) {
            // Close the select on ALT + arrow key to match the native <select>
            event.preventDefault();
            this.closePanel();
        }
        else if (keyCode === ENTER && manager.activeItem && !allHidden) {
            event.preventDefault();
            manager.activeItem._selectViaInteraction();
        }
        else if (keyCode === ENTER && allHidden) {
            event.preventDefault();
            this.closePanel();
        }
        else if (!this.showFilter && keyCode === SPACE && manager.activeItem) {
            event.preventDefault();
            manager.activeItem._selectViaInteraction();
        }
        else if (keyCode === TAB) {
            this.closePanel();
        }
        else {
            /** @type {?} */
            const previouslyFocusedIndex = manager.activeItemIndex;
            manager.onKeydown(event);
            this._ngZone.onStable
                .asObservable()
                .pipe(take(1), delay(251) // we need to defer to get the new activeItemIndex. delay > debouncing of the typeAhead
            ).subscribe((/**
             * @return {?}
             */
            () => {
                this.isStable = true;
                this._changeDetectorRef.detectChanges();
            }));
            if (this.isMultiSelect && isArrowKey && event.shiftKey && manager.activeItem &&
                manager.activeItemIndex !== previouslyFocusedIndex) {
                manager.activeItem._selectViaInteraction();
            }
        }
    }
    /**
     * \@docs-private
     * @param {?} value
     * @return {?}
     */
    formatValue(value) {
        return this.valueFormatter(value);
    }
    /**
     * Called when the user types in the filter input
     * @param {?} event
     * @return {?}
     */
    _onFilter(event) {
        event.preventDefault();
        this.currentFilter = event.target.value;
        this.filterChanges.next(event.target.value);
        /** @type {?} */
        const allHidden = this.options.map((/**
         * @param {?} option
         * @return {?}
         */
        option => option._hidden)).every((/**
         * @param {?} option
         * @return {?}
         */
        option => Boolean(option)));
        if (allHidden) {
            this._keyManager.setActiveItem(null);
        }
        else {
            this._keyManager.setFirstItemActive();
        }
    }
    /**
     * \@docs-private
     * The value displayed in the trigger.
     * @return {?}
     */
    get triggerValue() {
        if (this.empty) {
            return '';
        }
        if (this.isMultiSelect) {
            /** @type {?} */
            const selectedOptions = this._selectionModel.selected.map((/**
             * @param {?} option
             * @return {?}
             */
            option => option.viewValue));
            return selectedOptions.join(', ');
        }
        return this._selectionModel.selected[0].viewValue;
    }
    /**
     * Highlights the selected item. If no option is selected, it will highlight
     * the first item instead.
     * @private
     * @return {?}
     */
    _highlightCorrectOption() {
        if (this._keyManager) {
            if (this.empty) {
                this._keyManager.setFirstItemActive();
            }
            else {
                this._keyManager.setActiveItem(this._selectionModel.selected[0]);
            }
        }
    }
    /**
     * Callback that is invoked when the overlay panel has been attached.
     * @return {?}
     */
    _onAttached() {
        this.overlayDir.positionChange.pipe(take(1)).subscribe((/**
         * @return {?}
         */
        () => {
            /** @type {?} */
            const overlayRef = this.overlayDir.overlayRef;
            /** @type {?} */
            const positionStrategy = (/** @type {?} */ (overlayRef.getConfig()
                .positionStrategy));
            this._updatePositionOffset();
            positionStrategy.withPositions(this._positions.slice());
            overlayRef.updatePosition();
            if (this._keyManager.activeItem) {
                this._calculateScrollTop();
            }
            this._changeDetectorRef.markForCheck();
            this.openedChange.emit(true);
            // If there is no item selected, the filter takes the focus.
            if (this.showFilter && !this._value) {
                this.filterInput.nativeElement.focus();
            }
            else {
                this.panelBody.nativeElement.focus();
            }
        }));
    }
    /**
     * @return {?}
     */
    _onFocus() {
        if (!this.disabled) {
            this._focused = true;
            this.stateChanges.next();
        }
    }
    /**
     * Calls the touched callback only if the panel is closed. Otherwise, the trigger will
     * "blur" to the panel when it opens, causing a false positive.
     * @return {?}
     */
    _onBlur() {
        this._focused = false;
        if (this.filterInput && this.showFilter) {
            this._clearFilter();
        }
        if (!this.disabled && !this.panelOpen) {
            this._onTouched();
            this._changeDetectorRef.markForCheck();
            this.stateChanges.next();
        }
    }
    /**
     * \@docs-private
     * @return {?}
     */
    get isFilterEmpty() {
        return this.currentFilter.length === 0;
    }
    /**
     * \@docs-private
     * @return {?}
     */
    _clearFilter() {
        this.filterInput.nativeElement.value = '';
        this.currentFilter = '';
        this.filterChanges.next('');
    }
    /**
     * \@docs-private determines the `aria-activedescendant` to be set on the host.
     * @return {?}
     */
    _getAriaActiveDescendant() {
        if (this.panelOpen && this._keyManager && this._keyManager.activeItem) {
            return this._keyManager.activeItem.id;
        }
        return null;
    }
}
NxDropdownComponent.decorators = [
    { type: Component, args: [{
                selector: 'nx-dropdown',
                template: "\n<!-- input and stuff-->\n<div cdkOverlayOrigin\n    #origin=\"cdkOverlayOrigin\"\n    class=\"nx-dropdown__container\"\n    #trigger>\n  <div class=\"nx-dropdown__rendered\">\n    <ng-container *ngTemplateOutlet=\"closedDropdownLabel\"></ng-container>\n  </div>\n  <div class=\"nx-dropdown__icon\">\n    <nx-icon class=\"nx-dropdown__chevron\" name=\"chevron-down\"></nx-icon>\n  </div>\n</div>\n\n<ng-template #defaultClosedDropdownLabel>\n  <span *ngIf=\"triggerValue\">{{ triggerValue }}</span>\n</ng-template>\n\n<!-- overlay -->\n<ng-template\n  cdkConnectedOverlay\n  cdkConnectedOverlayHasBackdrop\n  cdkConnectedOverlayBackdropClass=\"cdk-overlay-transparent-backdrop\"\n  [cdkConnectedOverlayOrigin]=\"origin\"\n  [cdkConnectedOverlayOpen]=\"panelOpen\"\n  [cdkConnectedOverlayPositions]=\"_positions\"\n  [cdkConnectedOverlayMinWidth]=\"_triggerRect?.width\"\n  [cdkConnectedOverlayFlexibleDimensions]=\"true\"\n  [cdkConnectedOverlayViewportMargin]=\"_overlayViewportMargin\"\n  [cdkConnectedOverlayPush]=\"true\"\n  (backdropClick)=\"closePanel()\"\n  (attach)=\"_onAttached()\"\n  (detach)=\"closePanel()\">\n\n  <div class=\"nx-dropdown__panel\"\n      [class.has-filter]=\"showFilter\"\n      [class.nx-dropdown__panel--in-outline-field]=\"_isInOutlineField\"\n      (keydown)=\"_handleKeydown($event)\"\n      #panel>\n    <div class=\"nx-dropdown__panel-header\" *ngIf=\"label\">\n      {{ label }}\n    </div>\n    <div class=\"nx-dropdown__filter\" *ngIf=\"showFilter\">\n      <input class=\"nx-dropdown__filter-input\"\n             [class.is-filled]=\"!isFilterEmpty\"\n             #filterInput\n             type=\"text\"\n             (input)=\"_onFilter($event)\"\n             [placeholder]=\"filterPlaceholder\"\n      >\n      <span class=\"nx-dropdown__filter-icon\" *ngIf=\"!isFilterEmpty\" (click)=\"_clearFilter()\">\n        <nx-icon name=\"close\"></nx-icon>\n      </span>\n    </div>\n\n    <div class=\"nx-dropdown__panel-body\"\n         tabindex=\"-1\"\n         role=\"listbox\"\n         #panelBody\n         [class.is-stable]=\"isStable\"\n         [attr.aria-activedescendant]=\"_getAriaActiveDescendant()\"\n         [attr.aria-multiselectable]=\"isMultiSelect\"\n    >\n        <ng-content></ng-content>\n      </div>\n  </div>\n</ng-template>\n",
                changeDetection: ChangeDetectionStrategy.OnPush,
                providers: [
                    { provide: NxDropdownControl, useExisting: NxDropdownComponent },
                    { provide: NxFormfieldControl, useExisting: NxDropdownComponent },
                ],
                host: {
                    'role': 'button',
                    '[class.nx-dropdown]': 'true',
                    '[class.is-filled]': 'hasValue',
                    '[class.has-focus]': 'focused',
                    '[class.nx-dropdown--negative]': '_negative',
                    '[class.nx-dropdown--disabled]': 'disabled',
                    '[attr.aria-describedby]': 'ariaDescribedby || null',
                    '[attr.aria-required]': 'required',
                    '[attr.aria-label]': '_getAriaLabel()',
                    'aria-haspopup': 'listbox',
                    '[attr.aria-expanded]': 'panelOpen',
                    '[attr.disabled]': 'disabled || null',
                    '[attr.tabindex]': 'tabIndex',
                    '(keydown)': '_handleKeydown($event)',
                    '(focus)': '_onFocus()',
                    '(blur)': '_onBlur()',
                    '(click)': 'openPanel()'
                },
                styles: [":host{display:block;width:100%}:host:focus{outline:0}:host(.nx-dropdown--negative):focus{font-weight:600}:host(.nx-dropdown--negative){color:#fff}.nx-dropdown__container{display:flex;justify-content:flex-end;align-items:center;height:100%;cursor:pointer}:host(.nx-dropdown--disabled) .nx-dropdown__container{cursor:not-allowed}.nx-dropdown__rendered{flex:1 1 auto;overflow:hidden;text-overflow:ellipsis;white-space:nowrap}.nx-dropdown__panel{box-shadow:0 2px 4px rgba(65,65,65,.5);border-radius:4px;min-width:100%}.nx-dropdown__panel ::ng-deep .nx-checkbox__label{font-size:20px;font-size:var(--dropdown-item-font-size,20px);line-height:28px;line-height:var(--dropdown-item-line-height,28px);font-weight:400;font-weight:var(--dropdown-item-font-weight,400);letter-spacing:.2px;letter-spacing:var(--dropdown-item-letter-spacing,.2px);display:flex;align-items:center}.nx-dropdown__panel:focus{outline:0}.nx-dropdown__panel--in-outline-field .nx-dropdown__panel-header{font-size:16px;font-size:var(--formfield-outline-label-font-size,16px);line-height:24px;line-height:var(--formfield-outline-label-line-height,24px);font-weight:600;font-weight:var(--formfield-outline-label-font-weight,600);letter-spacing:0;letter-spacing:var(--formfield-outline-label-letter-spacing,0)}.nx-dropdown__panel--in-outline-field .nx-dropdown__panel-body{max-height:calc(5 * (24px + 16px) + 16px);max-height:calc(5 * (var(--dropdown-item-outline-line-height,24px) + 16px) + 16px)}.nx-dropdown__panel--in-outline-field ::ng-deep .nx-dropdown-results__group-label{font-size:16px;font-size:var(--formfield-outline-label-font-size,16px);line-height:24px;line-height:var(--formfield-outline-label-line-height,24px);font-weight:var(--formfield-outline-label-font-weight,600);letter-spacing:0;letter-spacing:var(--formfield-outline-label-letter-spacing,0);font-style:normal;font-weight:700}.nx-dropdown__panel--in-outline-field ::ng-deep nx-dropdown-item .nx-dropdown-results__option,.nx-dropdown__panel--in-outline-field ::ng-deep nx-dropdown-item .nx-dropdown-results__option-label{font-size:16px;font-size:var(--dropdown-item-outline-font-size,16px);line-height:24px;line-height:var(--dropdown-item-outline-line-height,24px);font-weight:400;font-weight:var(--dropdown-item-outline-font-weight,400);letter-spacing:0;letter-spacing:var(--dropdown-item-outline-letter-spacing,0)}.nx-dropdown__panel--in-outline-field ::ng-deep nx-dropdown-item .nx-dropdown-results__option-checkicon{height:24px;height:var(--dropdown-item-outline-line-height,24px)}.nx-dropdown__panel--in-outline-field ::ng-deep .nx-dropdown__filter-input{font-size:16px;font-size:var(--formfield-outline-control-font-size,16px);line-height:24px;line-height:var(--formfield-outline-control-line-height,24px);font-weight:400;font-weight:var(--formfield-outline-control-font-weight,400);letter-spacing:0;letter-spacing:var(--formfield-outline-control-letter-spacing,0)}.nx-dropdown__panel--in-outline-field ::ng-deep .nx-dropdown__filter-input:empty{font-weight:300}.nx-dropdown__icon{font-size:24px;font-size:var(--dropdown-chevron-size,24px);line-height:0}.nx-dropdown__chevron{vertical-align:middle}.nx-dropdown__panel-header{font-size:12px;font-size:var(--formfield-label-font-size,12px);line-height:16px;line-height:var(--formfield-label-line-height,16px);font-weight:600;font-weight:var(--formfield-label-font-weight,600);letter-spacing:.5px;letter-spacing:var(--formfield-label-letter-spacing,.5px);color:#414141;color:var(--dropdown-panel-header-text-color,#414141);background-color:#ececec;background-color:var(--dropdown-panel-header-background-color,#ececec);padding:8px 32px;border-top-left-radius:4px;border-top-right-radius:4px;z-index:1}.nx-dropdown__panel-body{background-color:#fff;background-color:var(--dropdown-panel-background-color,#fff);max-height:calc(5 * (28px + 16px) + 16px);max-height:calc(5 * (var(--dropdown-item-line-height,28px) + 16px) + 16px);overflow-y:auto;outline:0}.nx-dropdown__filter{position:relative;padding:16px 32px 12px;background-color:#fff;background-color:var(--dropdown-panel-background-color,#fff)}.nx-dropdown__filter-input{font-size:20px;font-size:var(--formfield-control-font-size,20px);line-height:28px;line-height:var(--formfield-control-line-height,28px);font-weight:var(--formfield-control-font-weight,600);letter-spacing:.2px;letter-spacing:var(--formfield-control-letter-spacing,.2px);border:0;border-bottom:1px solid #767676;border-bottom:1px var(--dropdown-filter-input-border-color,#767676) solid;color:#414141;color:var(--dropdown-filter-input-text-color,#414141);width:100%;outline:0;background-color:transparent;padding:0 24px 3px 0;font-weight:300}.nx-dropdown__filter-input::-ms-clear{display:none}.nx-dropdown__panel.has-filter ::ng-deep nx-dropdown-item:first-of-type .nx-dropdown-results__option{padding-top:12px}.nx-dropdown__filter-icon{position:absolute;height:24px;right:32px;top:calc(16px + 1px);cursor:pointer}.nx-dropdown__filter-icon nx-icon{font-size:24px}.nx-dropdown__filter-input:focus{border-color:#007ab3;border-color:var(--dropdown-filter-input-active-border-color,#007ab3)}.nx-dropdown__filter-input.is-filled:focus{font-weight:600;color:#007ab3;color:var(--dropdown-filter-input-active-text-color,#007ab3);border-color:#007ab3;border-color:var(--dropdown-filter-input-active-border-color,#007ab3)}.nx-dropdown__filter-input.is-filled:focus+.nx-dropdown__filter-icon{color:#007ab3;color:var(--dropdown-filter-input-active-text-color,#007ab3)}@media screen and (-ms-high-contrast:active){.nx-dropdown__panel{box-shadow:0 0 0 1px windowText}.nx-dropdown__panel-header{border-bottom:1px solid windowText}.nx-dropdown__filter-input{border-bottom-color:buttonText}}"]
            }] }
];
/** @nocollapse */
NxDropdownComponent.ctorParameters = () => [
    { type: ChangeDetectorRef },
    { type: ElementRef },
    { type: NgZone },
    { type: String, decorators: [{ type: Attribute, args: ['tabindex',] }] },
    { type: NxFormfieldComponent, decorators: [{ type: Optional }] },
    { type: NgControl, decorators: [{ type: Self }, { type: Optional }] },
    { type: NgForm, decorators: [{ type: Optional }] },
    { type: FormGroupDirective, decorators: [{ type: Optional }] }
];
NxDropdownComponent.propDecorators = {
    tabIndex: [{ type: Input }],
    _ariaLabel: [{ type: Input, args: ['nxAriaLabel',] }],
    value: [{ type: Input, args: ['nxValue',] }],
    disabled: [{ type: Input, args: ['nxDisabled',] }],
    required: [{ type: Input, args: ['nxRequired',] }],
    styles: [{ type: Input, args: ['nxStyle',] }],
    showFilter: [{ type: Input, args: ['nxShowFilter',] }],
    filterPlaceholder: [{ type: Input, args: ['nxFilterPlaceholder',] }],
    openedChange: [{ type: Output }],
    _openedStream: [{ type: Output, args: ['opened',] }],
    _closedStream: [{ type: Output, args: ['closed',] }],
    filterChanges: [{ type: Output, args: ['filterInput',] }],
    valueChange: [{ type: Output, args: ['nxValueChange',] }],
    selectionChange: [{ type: Output }],
    panel: [{ type: ViewChild, args: ['panel', { static: false },] }],
    panelBody: [{ type: ViewChild, args: ['panelBody', { static: false },] }],
    trigger: [{ type: ViewChild, args: ['trigger', { static: true },] }],
    filterInput: [{ type: ViewChild, args: ['filterInput', { static: false },] }],
    overlayDir: [{ type: ViewChild, args: [CdkConnectedOverlay, { static: true },] }],
    options: [{ type: ContentChildren, args: [NxDropdownItemComponent, { descendants: true },] }],
    groups: [{ type: ContentChildren, args: [NxDropdownGroupComponent,] }],
    _customClosedDropdownLabel: [{ type: ContentChild, args: [NxDropdownClosedLabelDirective, { static: false },] }],
    _defaultClosedDropdownLabel: [{ type: ViewChild, args: ['defaultClosedDropdownLabel', { static: true },] }],
    valueFormatter: [{ type: Input, args: ['nxValueFormatter',] }],
    compareWith: [{ type: Input }],
    filterFn: [{ type: Input }]
};
if (false) {
    /** @type {?} */
    NxDropdownComponent.prototype.readonly;
    /**
     * @type {?}
     * @private
     */
    NxDropdownComponent.prototype._selectionModel;
    /**
     * @type {?}
     * @protected
     */
    NxDropdownComponent.prototype._disabled;
    /**
     * @type {?}
     * @private
     */
    NxDropdownComponent.prototype._focused;
    /**
     * Whether or not the overlay panel is open.
     * @type {?}
     * @private
     */
    NxDropdownComponent.prototype._panelOpen;
    /**
     * \@docs-private
     * @type {?}
     */
    NxDropdownComponent.prototype.errorState;
    /**
     * \@docs-private
     * @type {?}
     */
    NxDropdownComponent.prototype.isStable;
    /**
     * Name of this control that is used inside the formfield component
     * \@docs-private
     * @type {?}
     */
    NxDropdownComponent.prototype.controlType;
    /**
     * Holds the value from nxValue.
     * @type {?}
     * @private
     */
    NxDropdownComponent.prototype._value;
    /**
     * The minimal space between the viewport and the overlay
     * @type {?}
     */
    NxDropdownComponent.prototype._overlayViewportMargin;
    /**
     * The last measured value for the trigger's client bounding rect.
     * @type {?}
     */
    NxDropdownComponent.prototype._triggerRect;
    /**
     * Holds the panelWidth after panel was attached.
     * @type {?}
     */
    NxDropdownComponent.prototype._panelWidth;
    /**
     * \@docs-private
     * Emits when internal state changes to inform formfield about it.
     * @type {?}
     */
    NxDropdownComponent.prototype.stateChanges;
    /**
     * The IDs of child options to be passed to the aria-owns attribute.
     * @type {?}
     */
    NxDropdownComponent.prototype._optionIds;
    /**
     * \@docs-private
     * @type {?}
     */
    NxDropdownComponent.prototype.ariaDescribedby;
    /**
     * @type {?}
     * @private
     */
    NxDropdownComponent.prototype._tabIndex;
    /**
     * \@docs-private
     * @type {?}
     */
    NxDropdownComponent.prototype.currentFilter;
    /**
     * Label to describe the component.
     * @type {?}
     */
    NxDropdownComponent.prototype._ariaLabel;
    /**
     * Whether the component is required. This adds an aria-required label to the component.
     * @type {?}
     */
    NxDropdownComponent.prototype.required;
    /**
     * @type {?}
     * @private
     */
    NxDropdownComponent.prototype._style;
    /**
     * Whether the dropdown should render in its negative style or not.
     * @type {?}
     */
    NxDropdownComponent.prototype._negative;
    /**
     * Whether the dropdown should be shown with an additional filter input.
     * @type {?}
     */
    NxDropdownComponent.prototype.showFilter;
    /**
     * Text displayed as placeholder for the filter.
     * @type {?}
     */
    NxDropdownComponent.prototype.filterPlaceholder;
    /**
     * Event emitted when the select panel has been toggled.
     * @type {?}
     */
    NxDropdownComponent.prototype.openedChange;
    /**
     * Event emitted when the select has been opened.
     * @type {?}
     */
    NxDropdownComponent.prototype._openedStream;
    /**
     * Event emitted when the select has been closed.
     * @type {?}
     */
    NxDropdownComponent.prototype._closedStream;
    /**
     * Event emitted when the user types in the filter input.
     * @type {?}
     */
    NxDropdownComponent.prototype.filterChanges;
    /**
     * Event that emits whenever the raw value of the select changes. This is here primarily
     * to facilitate the two-way binding for the `value` input.
     * \@docs-private
     * @type {?}
     */
    NxDropdownComponent.prototype.valueChange;
    /**
     * Event emitted when the selected value has been changed.
     * @type {?}
     */
    NxDropdownComponent.prototype.selectionChange;
    /**
     * \@docs-private
     * @type {?}
     */
    NxDropdownComponent.prototype.optionSelectionChanges;
    /**
     * This position config ensures that the top "start" corner of the overlay
     * is aligned with with the top "start" of the origin by default (overlapping
     * the trigger completely). If the panel cannot fit below the trigger, it
     * will fall back to a position above the trigger.
     * @type {?}
     */
    NxDropdownComponent.prototype._positions;
    /**
     * \@docs-private
     * Panel containing the select options.
     * @type {?}
     */
    NxDropdownComponent.prototype.panel;
    /**
     * \@docs-private
     * @type {?}
     */
    NxDropdownComponent.prototype.panelBody;
    /**
     * \@docs-private
     * @type {?}
     */
    NxDropdownComponent.prototype.trigger;
    /**
     * \@docs-private
     * @type {?}
     */
    NxDropdownComponent.prototype.filterInput;
    /**
     * \@docs-private
     * Overlay pane containing the options.
     * @type {?}
     */
    NxDropdownComponent.prototype.overlayDir;
    /**
     * \@docs-private
     * @type {?}
     */
    NxDropdownComponent.prototype.options;
    /**
     * \@docs-private
     * @type {?}
     */
    NxDropdownComponent.prototype.groups;
    /** @type {?} */
    NxDropdownComponent.prototype._customClosedDropdownLabel;
    /**
     * @type {?}
     * @private
     */
    NxDropdownComponent.prototype._defaultClosedDropdownLabel;
    /**
     * @type {?}
     * @private
     */
    NxDropdownComponent.prototype._closedDropdownLabel;
    /**
     * Emits whenever the component is destroyed.
     * @type {?}
     * @private
     */
    NxDropdownComponent.prototype._destroy;
    /**
     * @type {?}
     * @private
     */
    NxDropdownComponent.prototype._keyManager;
    /**
     * Function that transforms the value into a string.
     * This function is used for displaying and filtering the content
     * ( Default: (value) => value ? value.toString() : null; ).
     * @type {?}
     */
    NxDropdownComponent.prototype.valueFormatter;
    /**
     * Comparison function to specify which option is displayed. Defaults to object equality.
     * @type {?}
     * @private
     */
    NxDropdownComponent.prototype._compareWith;
    /**
     * @type {?}
     * @private
     */
    NxDropdownComponent.prototype._filterFn;
    /**
     * `View -> model callback called when value changes`
     * @type {?}
     */
    NxDropdownComponent.prototype._onChange;
    /**
     * `View -> model callback called when select has been touched`
     * @type {?}
     */
    NxDropdownComponent.prototype._onTouched;
    /**
     * @type {?}
     * @private
     */
    NxDropdownComponent.prototype._changeDetectorRef;
    /**
     * @type {?}
     * @private
     */
    NxDropdownComponent.prototype._elementRef;
    /**
     * @type {?}
     * @private
     */
    NxDropdownComponent.prototype._ngZone;
    /**
     * @type {?}
     * @private
     */
    NxDropdownComponent.prototype.formFieldComponent;
    /**
     * \@docs-private
     * @type {?}
     */
    NxDropdownComponent.prototype.ngControl;
    /**
     * @type {?}
     * @private
     */
    NxDropdownComponent.prototype._parentForm;
    /**
     * @type {?}
     * @private
     */
    NxDropdownComponent.prototype._parentFormGroup;
}

/**
 * @fileoverview added by tsickle
 * Generated from: dropdown/dropdown.module.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class NxDropdownModule {
}
NxDropdownModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    CommonModule,
                    NxFormfieldModule,
                    NxCheckboxModule$1,
                    OverlayModule,
                    A11yModule,
                    NxIconModule,
                    ObserversModule
                ],
                declarations: [
                    NxDropdownComponent,
                    NxDropdownItemComponent,
                    NxDropdownGroupComponent,
                    NxDropdownClosedLabelDirective
                ],
                exports: [
                    NxDropdownComponent,
                    NxDropdownItemComponent,
                    NxDropdownGroupComponent,
                    NxDropdownClosedLabelDirective
                ]
            },] }
];

/**
 * @fileoverview added by tsickle
 * Generated from: dropdown/public-api.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * Generated from: dropdown/index.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * Generated from: autocomplete/autocomplete-option.component.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Option selected event
 */
class NxAutocompleteOptionSelected {
    /**
     * @param {?} source
     * @param {?=} isUserInput
     */
    constructor(source, isUserInput = false) {
        this.source = source;
        this.isUserInput = isUserInput;
    }
}
if (false) {
    /**
     * The option that is selected or deselected.
     * @type {?}
     */
    NxAutocompleteOptionSelected.prototype.source;
    /**
     * Whether the input was triggered by the user.
     * @type {?}
     */
    NxAutocompleteOptionSelected.prototype.isUserInput;
}
/**
 * Option IDs need to be unique across components, so this counter exists outside of
 * the component definition.
 * @type {?}
 */
let _uniqueIdCounter = 0;
class NxAutocompleteOptionComponent {
    /**
     * @param {?} elementRef
     * @param {?} _changeDetectorRef
     */
    constructor(elementRef, _changeDetectorRef) {
        this.elementRef = elementRef;
        this._changeDetectorRef = _changeDetectorRef;
        this._id = `nx-autocomplete-option-${_uniqueIdCounter++}`;
        this._selected = false;
        this._active = false;
        this._disabled = false;
        /**
         * Event emitted when the option is selected or deselected.
         */
        this.onSelectionChange = new EventEmitter();
    }
    /**
     * Id of the autocomplete option. By default it is set to an incremented value.
     * @return {?}
     */
    get id() {
        return this._id;
    }
    /**
     * Whether or not the option is currently selected.
     * @return {?}
     */
    get selected() { return this._selected; }
    /**
     * Whether or not the option is currently active and ready to be selected.
     * An active option displays styles as if it is focused, but the
     * focus is actually retained somewhere else. This comes in handy
     * for components like autocomplete where focus must remain on the input.
     * @return {?}
     */
    get active() {
        return this._active;
    }
    /**
     * Whether the option is disabled.
     * @return {?}
     */
    get disabled() { return this._disabled; }
    /**
     * @param {?} value
     * @return {?}
     */
    set disabled(value) {
        /** @type {?} */
        const newValue = coerceBooleanProperty(value);
        if (this._disabled !== newValue) {
            this._disabled = newValue;
        }
    }
    /**
     * Ensures the option is selected when activated from the keyboard.
     * @param {?} event
     * @return {?}
     */
    _handleKeydown(event) {
        if (event.keyCode === ENTER || event.keyCode === SPACE) {
            this._selectViaInteraction();
            // Prevent the page from scrolling down and form submits.
            event.preventDefault();
        }
    }
    /**
     * `Selects the option while indicating the selection came from the user. Used to
     * determine if the select's view -> model callback should be invoked.`
     * @return {?}
     */
    _selectViaInteraction() {
        if (!this.disabled) {
            this._selected = true;
            this._changeDetectorRef.markForCheck();
            this._emitSelectionChangeEvent(true);
        }
    }
    /**
     * Returns the correct tabindex for the option depending on disabled state.
     * @return {?}
     */
    _getTabIndex() {
        return this.disabled ? '-1' : '0';
    }
    /**
     * Emits the selection change event.
     * @private
     * @param {?=} isUserInput
     * @return {?}
     */
    _emitSelectionChangeEvent(isUserInput = false) {
        this.onSelectionChange.emit(new NxAutocompleteOptionSelected(this, isUserInput));
    }
    /**
     * \@docs-private
     * @return {?}
     */
    get viewValue() {
        return (this.elementRef.nativeElement.textContent || '').trim();
    }
    /**
     * \@docs-private
     * This method sets display styles on the option to make it appear
     * active. This is used by the ActiveDescendantKeyManager so key
     * events will display the proper options as active on arrow key events.
     * @return {?}
     */
    setActiveStyles() {
        if (!this._active) {
            this._active = true;
            this._changeDetectorRef.markForCheck();
        }
    }
    /**
     * \@docs-private
     * This method removes display styles on the option that made it appear
     * active. This is used by the ActiveDescendantKeyManager so key
     * events will display the proper options as active on arrow key events.
     * @return {?}
     */
    setInactiveStyles() {
        if (this._active) {
            this._active = false;
            this._changeDetectorRef.markForCheck();
        }
    }
    /**
     * \@docs-private
     * Gets the label to be used when determining whether the option should be focused.
     * @return {?}
     */
    getLabel() {
        return this.viewValue;
    }
    /**
     * Selects the option.
     * @return {?}
     */
    select() {
        this._selected = true;
        this._changeDetectorRef.markForCheck();
        this._emitSelectionChangeEvent();
    }
    /**
     * Deselects the option.
     * @return {?}
     */
    deselect() {
        this._selected = false;
        this._changeDetectorRef.markForCheck();
        this._emitSelectionChangeEvent();
    }
    /**
     * \@docs-private
     * Sets focus onto this option.
     * @return {?}
     */
    focus() {
        /** @type {?} */
        const element = this.elementRef.nativeElement;
        if (typeof element.focus === 'function') {
            element.focus();
        }
    }
}
NxAutocompleteOptionComponent.decorators = [
    { type: Component, args: [{
                selector: 'nx-autocomplete-option',
                template: "<div class=\"nx-autocomplete-option\" [class.nx-active]=\"active\">\n  <div class=\"nx-autocomplete-option__label\">\n    <ng-content></ng-content>\n  </div>\n</div>\n",
                host: {
                    'role': 'option',
                    '[attr.tabindex]': '_getTabIndex()',
                    '[id]': 'id',
                    '[attr.aria-selected]': 'selected.toString()',
                    '[attr.aria-disabled]': 'disabled.toString()',
                    '(click)': '_selectViaInteraction()',
                    '(keydown)': '_handleKeydown($event)',
                    '[class.nx-active]': 'active',
                    '[class.nx-disabled]': 'disabled',
                    '[style.display]': '\'block\'' // needed for to be able to calculate offset height
                },
                changeDetection: ChangeDetectionStrategy.OnPush,
                styles: [":host:focus{outline:0}:host:first-child .nx-autocomplete-option{padding-top:16px}:host:last-child .nx-autocomplete-option{padding-bottom:16px}.nx-autocomplete-option{font-size:20px;font-size:var(--dropdown-item-font-size,20px);line-height:28px;line-height:var(--dropdown-item-line-height,28px);font-weight:400;font-weight:var(--dropdown-item-font-weight,400);letter-spacing:.2px;letter-spacing:var(--dropdown-item-letter-spacing,.2px);padding:8px 32px;cursor:pointer;position:relative;display:flex;max-width:100%;white-space:nowrap}.nx-autocomplete-option.nx-active,.nx-autocomplete-option:hover{color:#007ab3}.nx-autocomplete-option__label{padding:0 12px;margin:0 -12px;color:#414141;color:var(--dropdown-item-text-color,#414141)}:host-context([data-whatinput=keyboard]) .nx-autocomplete-option.nx-active .nx-autocomplete-option__label{border-radius:4px;box-shadow:0 0 0 2px #fff,0 0 0 6px #009de6;box-shadow:var(--focus-box-shadow,0 0 0 2px #fff,0 0 0 6px #009de6)}@media screen and (-ms-high-contrast:active){.nx-autocomplete-option.nx-active .nx-autocomplete-option__label,.nx-autocomplete-option:hover .nx-autocomplete-option__label{color:highlightText;background-color:highlight;border-radius:4px}.nx-autocomplete-option__label{-ms-high-contrast-adjust:none;color:buttonText;background-color:buttonFace;border-radius:4px}:host-context([data-whatinput=keyboard]) .nx-autocomplete-option.nx-active .nx-autocomplete-option__label{box-shadow:0 0 0 2px background,0 0 0 6px windowText}}"]
            }] }
];
/** @nocollapse */
NxAutocompleteOptionComponent.ctorParameters = () => [
    { type: ElementRef },
    { type: ChangeDetectorRef }
];
NxAutocompleteOptionComponent.propDecorators = {
    disabled: [{ type: Input }],
    value: [{ type: Input }],
    onSelectionChange: [{ type: Output }]
};
if (false) {
    /**
     * @type {?}
     * @private
     */
    NxAutocompleteOptionComponent.prototype._id;
    /**
     * @type {?}
     * @private
     */
    NxAutocompleteOptionComponent.prototype._selected;
    /**
     * @type {?}
     * @private
     */
    NxAutocompleteOptionComponent.prototype._active;
    /**
     * @type {?}
     * @private
     */
    NxAutocompleteOptionComponent.prototype._disabled;
    /**
     * The value of the autocomplete option.
     * @type {?}
     */
    NxAutocompleteOptionComponent.prototype.value;
    /**
     * Event emitted when the option is selected or deselected.
     * @type {?}
     */
    NxAutocompleteOptionComponent.prototype.onSelectionChange;
    /**
     * \@docs-private
     * @type {?}
     */
    NxAutocompleteOptionComponent.prototype.elementRef;
    /**
     * @type {?}
     * @private
     */
    NxAutocompleteOptionComponent.prototype._changeDetectorRef;
}

/**
 * @fileoverview added by tsickle
 * Generated from: autocomplete/autocomplete.component.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Autocomplete IDs need to be unique across components, so this counter exists outside of
 * the component definition.
 * @type {?}
 */
let _uniqueAutocompleteIdCounter = 0;
/**
 * Event object that is emitted when an autocomplete option is selected.
 */
class NxAutocompleteSelectedEvent {
    /**
     * @param {?} source
     * @param {?} option
     */
    constructor(source, option) {
        this.source = source;
        this.option = option;
    }
}
if (false) {
    /**
     * Reference to the autocomplete panel that emitted the event.
     * @type {?}
     */
    NxAutocompleteSelectedEvent.prototype.source;
    /**
     * Option that was selected.
     * @type {?}
     */
    NxAutocompleteSelectedEvent.prototype.option;
}
class NxAutocompleteComponent {
    /**
     * @param {?} _changeDetectorRef
     * @param {?} _elementRef
     * @param {?} formFieldComponent
     */
    constructor(_changeDetectorRef, _elementRef, formFieldComponent) {
        this._changeDetectorRef = _changeDetectorRef;
        this._elementRef = _elementRef;
        this.formFieldComponent = formFieldComponent;
        /**
         * Whether the autocomplete panel should be visible, depending on option length.
         */
        this.showPanel = false;
        this._isOpen = false;
        this._items = null;
        this._hasItems = false;
        /**
         * Event that is emitted whenever an option from the list is selected.
         */
        this.optionSelected = new EventEmitter();
        /**
         * Event that is emitted when the autocomplete panel is opened.
         */
        this.opened = new EventEmitter();
        /**
         * Event that is emitted when the autocomplete panel is closed.
         */
        this.closed = new EventEmitter();
        this._classList = {};
        /**
         * Unique ID to be used by autocomplete trigger's "aria-owns" property.
         */
        this.id = `nx-autocomplete-${_uniqueAutocompleteIdCounter++}`;
        // As autocomplete option can hold any value, we might need a converter
        // to get a string representation, which can be stored in input. Default value ? value.toString() : null.
        /**
         * Value to string converter.
         */
        this.valueFormatter = (/**
         * @param {?} value
         * @return {?}
         */
        (value) => value ? value.toString() : null);
    }
    /**
     * Whether the autocomplete panel is open.
     * @return {?}
     */
    get isOpen() { return this._isOpen && this.showPanel; }
    /**
     * Items observable. If given, autocomplete takes care of the options and ng-content is discarderd
     * @param {?} val
     * @return {?}
     */
    set items(val) {
        this._hasItems = true;
        if (Array.isArray(val)) {
            this._items = val;
        }
        else if (val instanceof Observable) {
            if (this._itemsSubscription) {
                this._itemsSubscription.unsubscribe();
            }
            this._itemsSubscription = val.subscribe((/**
             * @param {?} itms
             * @return {?}
             */
            (itms) => {
                this._items = itms;
                this._changeDetectorRef.markForCheck();
                // and check visibility in next cycle, when options are set
                setTimeout((/**
                 * @return {?}
                 */
                () => this._setVisibility()));
            }));
        }
        else if (val === null) {
            this._items = val;
        }
        else {
            throw new Error('Invalid argument for autocomplete items. It has to be Array<string> or Observable<Array<string>>');
        }
    }
    /**
     * @return {?}
     */
    get items() {
        return this._items;
    }
    /**
     * \@docs-private
     * Is items observable set
     * @return {?}
     */
    get hasItems() {
        return this._hasItems;
    }
    /**
     * Autocomplete options
     * @return {?}
     */
    get options() {
        return this.hasItems ? this._vOptions : this._cOptions;
    }
    /**
     * Takes classes set on the host nx-autocomplete element and applies them to the panel
     * inside the overlay container to allow for easy styling.
     * @param {?} value
     * @return {?}
     */
    set classList(value) {
        if (value && value.length) {
            value.split(' ').forEach((/**
             * @param {?} className
             * @return {?}
             */
            className => this._classList[className.trim()] = true));
            this._elementRef.nativeElement.className = '';
        }
    }
    /**
     * @return {?}
     */
    ngAfterViewInit() {
        this._keyManager = new ActiveDescendantKeyManager(this.options).withWrap();
        this._setVisibility();
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        if (this._itemsSubscription) {
            this._itemsSubscription.unsubscribe();
        }
    }
    /**
     * Sets the panel scrollTop. This allows us to manually scroll to display options
     * above or below the fold, as they are not actually being focused when active.
     * @param {?} scrollTop
     * @return {?}
     */
    _setScrollTop(scrollTop) {
        if (this.panel) {
            this.panel.nativeElement.scrollTop = scrollTop;
        }
    }
    /**
     * Returns the panel's scrollTop.
     * @return {?}
     */
    _getScrollTop() {
        return this.panel ? this.panel.nativeElement.scrollTop : 0;
    }
    /**
     * Panel should hide itself when the option list is empty.
     * @return {?}
     */
    _setVisibility() {
        this.showPanel = !!(this.options && this.options.length);
        this._classList['nx-autocomplete-visible'] = this.showPanel;
        this._classList['nx-autocomplete-hidden'] = !this.showPanel;
        this._changeDetectorRef.markForCheck();
    }
    /**
     * Emits the `select` event.
     * @param {?} option
     * @return {?}
     */
    _emitSelectEvent(option) {
        /** @type {?} */
        const event = new NxAutocompleteSelectedEvent(this, option);
        this.optionSelected.emit(event);
    }
    /**
     * @return {?}
     */
    get _isInOutlineField() {
        return this.formFieldComponent !== null
            && this.formFieldComponent.appearance === 'outline';
    }
}
NxAutocompleteComponent.decorators = [
    { type: Component, args: [{
                selector: 'nx-autocomplete',
                template: "<ng-template>\n  <div class=\"nx-autocomplete-panel\" role=\"listbox\" [id]=\"id\" [ngClass]=\"_classList\"\n  [class.nx-autocomplete-panel--in-outline-field]=\"_isInOutlineField\" #panel>\n    <ng-container *ngIf=\"hasItems\">\n      <nx-autocomplete-option *ngFor=\"let item of items\" [value]=\"item\">\n        {{item}}\n      </nx-autocomplete-option>\n    </ng-container>\n    <ng-container *ngIf=\"!hasItems\">\n      <ng-content></ng-content>\n    </ng-container>\n  </div>\n</ng-template>\n",
                changeDetection: ChangeDetectionStrategy.OnPush,
                exportAs: 'nxAutocomplete',
                host: {
                    'class': 'nx-autocomplete'
                },
                styles: [":host ::ng-deep .c-input::-ms-clear{width:0;height:0}.nx-autocomplete-panel{background-color:#fff;box-shadow:0 2px 4px rgba(65,65,65,.5);overflow-y:auto;overflow-x:hidden;max-height:280px;width:100%;border-radius:4px}.nx-autocomplete-panel.nx-autocomplete-visible{visibility:visible}.nx-autocomplete-panel.nx-autocomplete-hidden{visibility:hidden}.nx-autocomplete-panel--in-outline-field ::ng-deep nx-autocomplete-option .nx-autocomplete-option,.nx-autocomplete-panel--in-outline-field ::ng-deep nx-autocomplete-option .nx-autocomplete-option__label{font-size:16px;font-size:var(--dropdown-item-outline-font-size,16px);line-height:24px;line-height:var(--dropdown-item-outline-line-height,24px);font-weight:400;font-weight:var(--dropdown-item-outline-font-weight,400);letter-spacing:0;letter-spacing:var(--dropdown-item-outline-letter-spacing,0)}@media screen and (-ms-high-contrast:active){.nx-autocomplete-panel{box-shadow:0 0 0 1px windowText}}"]
            }] }
];
/** @nocollapse */
NxAutocompleteComponent.ctorParameters = () => [
    { type: ChangeDetectorRef },
    { type: ElementRef },
    { type: NxFormfieldComponent, decorators: [{ type: Optional }] }
];
NxAutocompleteComponent.propDecorators = {
    template: [{ type: ViewChild, args: [TemplateRef, { static: false },] }],
    panel: [{ type: ViewChild, args: ['panel', { static: false },] }],
    items: [{ type: Input }],
    optionSelected: [{ type: Output }],
    opened: [{ type: Output }],
    closed: [{ type: Output }],
    _vOptions: [{ type: ViewChildren, args: [NxAutocompleteOptionComponent,] }],
    _cOptions: [{ type: ContentChildren, args: [NxAutocompleteOptionComponent, { descendants: true },] }],
    classList: [{ type: Input, args: ['class',] }],
    valueFormatter: [{ type: Input, args: ['nxValueFormatter',] }]
};
if (false) {
    /**
     * Manages active item in option list based on key events.
     * @type {?}
     */
    NxAutocompleteComponent.prototype._keyManager;
    /**
     * Whether the autocomplete panel should be visible, depending on option length.
     * @type {?}
     */
    NxAutocompleteComponent.prototype.showPanel;
    /** @type {?} */
    NxAutocompleteComponent.prototype._isOpen;
    /**
     * \@docs-private
     * @type {?}
     */
    NxAutocompleteComponent.prototype.template;
    /**
     * \@docs-private
     * Element for the panel containing the autocomplete options.
     * @type {?}
     */
    NxAutocompleteComponent.prototype.panel;
    /**
     * @type {?}
     * @private
     */
    NxAutocompleteComponent.prototype._items;
    /**
     * @type {?}
     * @private
     */
    NxAutocompleteComponent.prototype._itemsSubscription;
    /**
     * @type {?}
     * @private
     */
    NxAutocompleteComponent.prototype._hasItems;
    /**
     * Event that is emitted whenever an option from the list is selected.
     * @type {?}
     */
    NxAutocompleteComponent.prototype.optionSelected;
    /**
     * Event that is emitted when the autocomplete panel is opened.
     * @type {?}
     */
    NxAutocompleteComponent.prototype.opened;
    /**
     * Event that is emitted when the autocomplete panel is closed.
     * @type {?}
     */
    NxAutocompleteComponent.prototype.closed;
    /**
     * Autocomplete options in view - ie from items
     * @type {?}
     * @private
     */
    NxAutocompleteComponent.prototype._vOptions;
    /**
     * Autocomplete options in content - ie user provided
     * @type {?}
     * @private
     */
    NxAutocompleteComponent.prototype._cOptions;
    /** @type {?} */
    NxAutocompleteComponent.prototype._classList;
    /**
     * Unique ID to be used by autocomplete trigger's "aria-owns" property.
     * @type {?}
     */
    NxAutocompleteComponent.prototype.id;
    /**
     * Value to string converter.
     * @type {?}
     */
    NxAutocompleteComponent.prototype.valueFormatter;
    /**
     * @type {?}
     * @private
     */
    NxAutocompleteComponent.prototype._changeDetectorRef;
    /**
     * @type {?}
     * @private
     */
    NxAutocompleteComponent.prototype._elementRef;
    /**
     * @type {?}
     * @private
     */
    NxAutocompleteComponent.prototype.formFieldComponent;
}

/**
 * @fileoverview added by tsickle
 * Generated from: autocomplete/autocomplete-trigger.directive.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Provider that allows the autocomplete to register as a ControlValueAccessor.
 * \@docs-private
 * @type {?}
 */
const NX_AUTOCOMPLETE_VALUE_ACCESSOR = {
    provide: NG_VALUE_ACCESSOR,
    useExisting: forwardRef((/**
     * @return {?}
     */
    () => NxAutocompleteTriggerDirective)),
    multi: true
};
/**
 * Creates an error to be thrown when attempting to use an autocomplete trigger without a panel.
 * @return {?}
 */
function getNxAutocompleteMissingPanelError() {
    return Error('Attempting to open an undefined instance of `nx-autocomplete`. ' +
        'Make sure that the id passed to the `nxAutocomplete` is correct and that ' +
        'you\'re attempting to open it after the ngAfterContentInit hook.');
}
class NxAutocompleteTriggerDirective {
    /**
     * @param {?} _element
     * @param {?} _overlay
     * @param {?} _viewContainerRef
     * @param {?} _zone
     * @param {?} _changeDetectorRef
     * @param {?} _dir
     * @param {?} _nxFormField
     * @param {?} _nxWordField
     * @param {?} _document
     * @param {?=} _viewportRuler
     */
    constructor(_element, _overlay, _viewContainerRef, _zone, _changeDetectorRef, _dir, _nxFormField, _nxWordField, _document, _viewportRuler) {
        this._element = _element;
        this._overlay = _overlay;
        this._viewContainerRef = _viewContainerRef;
        this._zone = _zone;
        this._changeDetectorRef = _changeDetectorRef;
        this._dir = _dir;
        this._nxFormField = _nxFormField;
        this._nxWordField = _nxWordField;
        this._document = _document;
        this._viewportRuler = _viewportRuler;
        this._componentDestroyed = false;
        /**
         * Whether or not the label state is being overridden.
         */
        this._manuallyFloatingLabel = false;
        /**
         * Subscription to viewport size changes.
         */
        this._viewportSubscription = Subscription.EMPTY;
        /**
         * Stream of keyboard events that can close the panel.
         */
        this._closeKeyEventStream = new Subject();
        /**
         * Value changes
         */
        this._valueChanges = new Subject();
        this._itemsCb = null;
        this._debounce = 400;
        this._autocompleteDisabled = false;
        this._overlayAttached = false;
        /**
         * Stream of autocomplete option selections.
         */
        this.optionSelections = defer((/**
         * @return {?}
         */
        () => {
            if (this.autocomplete && this.autocomplete.options) {
                return merge(...this.autocomplete.options.map((/**
                 * @param {?} option
                 * @return {?}
                 */
                option => option.onSelectionChange)));
            }
            // If there are any subscribers before `ngAfterViewInit`, the `autocomplete` will be undefined.
            // Return a stream that we'll replace with the real one once everything is in place.
            return this._zone.onStable
                .asObservable()
                .pipe(take(1), switchMap((/**
             * @return {?}
             */
            () => this.optionSelections)));
        }));
        /**
         * `View -> model callback called when value changes`
         */
        this._onChange = (/**
         * @param {?} val
         * @return {?}
         */
        (val) => {
            this._valueChanges.next(val);
        });
        /**
         * `View -> model callback called when autocomplete has been touched`
         */
        this._onTouched = (/**
         * @return {?}
         */
        () => { });
    }
    /**
     * The items callback. Called with input value, must return Observable of Array of strings
     * @param {?} val
     * @return {?}
     */
    set itemsCb(val) {
        if (typeof val === 'function') {
            this._itemsCb = val;
        }
        else {
            throw new Error('Wrong value type for nxAutocompleteItems');
        }
    }
    /**
     * @return {?}
     */
    get itemsCb() {
        return this._itemsCb;
    }
    /**
     * Debounce in ms before items callback is triggered. Defaults to 400
     * @param {?} val
     * @return {?}
     */
    set debounce(val) {
        this._debounce = coerceNumberProperty(val);
    }
    /**
     * Whether autocomplete functionality is disabled.
     * @param {?} val
     * @return {?}
     */
    set autocompleteDisabled(val) {
        this._autocompleteDisabled = val;
        this._bindAutocompleteItems();
    }
    /**
     * @return {?}
     */
    get autocompleteDisabled() {
        return this._autocompleteDisabled;
    }
    /**
     * Whether or not the autocomplete panel is open.
     * @return {?}
     */
    get panelOpen() {
        return this._overlayAttached && this.autocomplete.showPanel;
    }
    /**
     * The currently active option, coerced to NxAutocompleteOptionComponent type.
     * @return {?}
     */
    get activeOption() {
        if (this.autocomplete && this.autocomplete._keyManager) {
            return this.autocomplete._keyManager.activeItem;
        }
        return null;
    }
    /**
     * Stream of clicks outside of the autocomplete panel.
     * @private
     * @return {?}
     */
    get _outsideClickStream() {
        if (!this._document) {
            return of(null);
        }
        return merge(fromEvent(this._document, 'click'), fromEvent(this._document, 'touchend'))
            .pipe(filter((/**
         * @param {?} event
         * @return {?}
         */
        (event) => {
            /** @type {?} */
            const clickTarget = (/** @type {?} */ (event.target));
            /** @type {?} */
            const formField = this._formField ?
                this._formField.elementRef.nativeElement : null;
            return this._overlayAttached &&
                clickTarget !== this._element.nativeElement &&
                (!formField || !formField.contains(clickTarget)) &&
                (!!this._overlayRef && !this._overlayRef.overlayElement.contains(clickTarget));
        })));
    }
    /**
     * @private
     * @return {?}
     */
    get _formField() {
        if (this._nxFormField) {
            return this._nxFormField;
        }
        else if (this._nxWordField) {
            return this._nxWordField;
        }
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this._viewportSubscription.unsubscribe();
        this._componentDestroyed = true;
        this._destroyPanel();
        this._closeKeyEventStream.complete();
        if (this._controlValueChangesSubscription) {
            this._controlValueChangesSubscription.unsubscribe();
        }
        if (this._itemsSubscription) {
            this._itemsSubscription.unsubscribe();
        }
    }
    /**
     * @return {?}
     */
    ngOnChanges() {
        this._bindAutocompleteItems();
    }
    /**
     * @return {?}
     */
    ngAfterViewInit() {
        this._bindAutocompleteItems();
    }
    /**
     * Binds or rebinds the autocomplete items. Prerequisites:
     * - items callback has to be defined
     * - autocomplete panel has to be bound
     * @private
     * @return {?}
     */
    _bindAutocompleteItems() {
        if (this._controlValueChangesSubscription) {
            this._controlValueChangesSubscription.unsubscribe();
        }
        if (typeof this._itemsCb === 'function' && this.autocomplete && !this.autocompleteDisabled) {
            /** @type {?} */
            const itemsSubject = new Subject();
            this.autocomplete.items = itemsSubject;
            /** @type {?} */
            const valueChanges = this._formField &&
                this._formField._control &&
                this._formField._control.ngControl &&
                this._formField._control.ngControl.valueChanges ?
                this._formField._control.ngControl.valueChanges : this._valueChanges;
            this._controlValueChangesSubscription = valueChanges.pipe(debounceTime(this._debounce))
                .subscribe((/**
             * @param {?} input
             * @return {?}
             */
            (input) => {
                if (this._itemsSubscription) {
                    this._itemsSubscription.unsubscribe();
                }
                this._itemsSubscription = this._itemsCb(input).pipe(first()).subscribe((/**
                 * @param {?} result
                 * @return {?}
                 */
                (result) => {
                    itemsSubject.next(result);
                }), (/**
                 * @param {?} err
                 * @return {?}
                 */
                (err) => {
                    // On error reset
                    // TODO: Log error?
                    itemsSubject.next([]);
                }));
            }));
        }
    }
    /**
     * Opens the autocomplete suggestion panel.
     * @return {?}
     */
    openPanel() {
        if (!this.autocompleteDisabled) {
            this._attachOverlay();
            this._floatLabel();
        }
    }
    /**
     * Closes the autocomplete suggestion panel.
     * @return {?}
     */
    closePanel() {
        this._resetLabel();
        if (!this._overlayAttached) {
            return;
        }
        if (this.panelOpen) {
            // Only emit if the panel was visible.
            this.autocomplete.closed.emit();
        }
        this.autocomplete._isOpen = this._overlayAttached = false;
        if (this._overlayRef && this._overlayRef.hasAttached()) {
            this._overlayRef.detach();
            this._closingActionsSubscription.unsubscribe();
        }
        // Note that in some cases this can end up being called after the component is destroyed.
        // Add a check to ensure that we don't try to run change detection on a destroyed view.
        if (!this._componentDestroyed) {
            // We need to trigger change detection manually, because
            // `fromEvent` doesn't seem to do it at the proper time.
            // This ensures that the label is reset when the
            // user clicks outside.
            this._changeDetectorRef.detectChanges();
        }
    }
    /**
     * A stream of actions that should close the autocomplete panel, including
     * when an option is selected, on blur, and when TAB is pressed.
     * @return {?}
     */
    get panelClosingActions() {
        return merge(this.optionSelections, this.autocomplete._keyManager.tabOut.pipe(filter((/**
         * @return {?}
         */
        () => this._overlayAttached))), this._closeKeyEventStream, this._outsideClickStream, this._overlayRef ?
            this._overlayRef.detachments().pipe(filter((/**
             * @return {?}
             */
            () => this._overlayAttached))) :
            of());
    }
    // Implemented as part of ControlValueAccessor.
    /**
     * @param {?} value
     * @return {?}
     */
    writeValue(value) {
        Promise.resolve(null).then((/**
         * @return {?}
         */
        () => this._setTriggerValue(value)));
    }
    // Implemented as part of ControlValueAccessor.
    /**
     * @param {?} fn
     * @return {?}
     */
    registerOnChange(fn) {
        this._onChange = fn;
    }
    // Implemented as part of ControlValueAccessor.
    /**
     * @param {?} fn
     * @return {?}
     */
    registerOnTouched(fn) {
        this._onTouched = fn;
    }
    // Implemented as part of ControlValueAccessor.
    /**
     * @param {?} isDisabled
     * @return {?}
     */
    setDisabledState(isDisabled) {
        this._element.nativeElement.disabled = isDisabled;
    }
    /**
     * @param {?} event
     * @return {?}
     */
    _handleKeydown(event) {
        /** @type {?} */
        const keyCode = event.keyCode;
        // Prevent the default action on all escape key presses. This is here primarily to bring IE
        // in line with other browsers. By default, pressing escape on IE will cause it to revert
        // the input value to the one that it had on focus, however it won't dispatch any events
        // which means that the model value will be out of sync with the view.
        if (keyCode === ESCAPE) {
            event.preventDefault();
        }
        // Close when pressing ESCAPE or ALT + UP_ARROW, based on the a11y guidelines.
        // See: https://www.w3.org/TR/wai-aria-practices-1.1/#textbox-keyboard-interaction
        if (this.panelOpen && (keyCode === ESCAPE || (keyCode === UP_ARROW && event.altKey))) {
            this._resetActiveItem();
            this._closeKeyEventStream.next();
            event.stopPropagation();
        }
        else if (this.activeOption && keyCode === ENTER && this.panelOpen) {
            this.activeOption._selectViaInteraction();
            this._resetActiveItem();
            event.preventDefault();
        }
        else {
            /** @type {?} */
            const prevActiveItem = this.autocomplete._keyManager.activeItem;
            /** @type {?} */
            const isArrowKey = keyCode === UP_ARROW || keyCode === DOWN_ARROW;
            if (this.panelOpen || keyCode === TAB) {
                this.autocomplete._keyManager.onKeydown(event);
            }
            else if (isArrowKey && this._isFieldEnabled()) {
                this.openPanel();
            }
            if (isArrowKey || this.autocomplete._keyManager.activeItem !== prevActiveItem) {
                this._scrollToOption();
            }
        }
    }
    /**
     * @param {?} event
     * @return {?}
     */
    _handleInput(event) {
        /** @type {?} */
        const target = (/** @type {?} */ (event.target));
        /** @type {?} */
        let value = target.value;
        // Based on `NumberValueAccessor` from forms.
        if (target.type === 'number') {
            value = value === '' ? null : parseFloat(value);
        }
        // If the input has a placeholder, IE will fire the `input` event on page load,
        // focus and blur, in addition to when the user actually changed the value. To
        // filter out all of the extra events, we save the value on focus and between
        // `input` events, and we check whether it changed.
        // See: https://connect.microsoft.com/IE/feedback/details/885747/
        if (this._isFieldEnabled() && this._previousValue !== value &&
            document.activeElement === event.target) {
            this._previousValue = value;
            this._onChange(value);
            this.openPanel();
        }
    }
    /**
     * @return {?}
     */
    _handleFocus() {
        if (this._isFieldEnabled()) {
            this._previousValue = this._element.nativeElement.value;
            this.openPanel();
        }
    }
    /**
     * In "auto" mode, the label will animate down as soon as focus is lost.
     * This causes the value to jump when selecting an option with the mouse.
     * This method manually floats the label until the panel can be closed.
     * @private
     * @return {?}
     */
    _floatLabel() {
        if (this._nxFormField && this._nxFormField.floatLabel === 'auto') {
            this._nxFormField.floatLabel = 'always';
            this._manuallyFloatingLabel = true;
        }
    }
    /**
     * If the label has been manually elevated, return it to its normal state.
     * @private
     * @return {?}
     */
    _resetLabel() {
        if (this._manuallyFloatingLabel) {
            this._nxFormField.floatLabel = 'auto';
            this._manuallyFloatingLabel = false;
        }
    }
    /**
     * Given that we are not actually focusing active options, we must manually adjust scroll
     * to reveal options below the fold. First, we find the offset of the option from the top
     * of the panel. If that offset is below the fold, the new scrollTop will be the offset -
     * the panel height + the option height, so the active option will be just visible at the
     * bottom of the panel. If that offset is above the top of the visible panel, the new scrollTop
     * will become the offset. If that offset is visible within the panel already, the scrollTop is
     * not adjusted.
     * @private
     * @return {?}
     */
    _scrollToOption() {
        if (this.autocomplete.options.length === 0) {
            return;
        }
        /** @type {?} */
        let optionOffset = 0;
        /** @type {?} */
        const optionHeight = this.autocomplete.options.first.elementRef.nativeElement.offsetHeight;
        if (this.autocomplete._keyManager.activeItem) {
            optionOffset = this.autocomplete._keyManager.activeItem.elementRef.nativeElement.offsetTop;
        }
        /** @type {?} */
        const newScrollPosition = _getOptionScrollPosition(optionOffset, optionHeight, this.autocomplete._getScrollTop(), this.autocomplete.panel.nativeElement.offsetHeight);
        this.autocomplete._setScrollTop(newScrollPosition);
    }
    /**
     * This method listens to a stream of panel closing actions and resets the
     * stream every time the option list changes.
     * @private
     * @return {?}
     */
    _subscribeToClosingActions() {
        /** @type {?} */
        const firstStable = this._zone.onStable.asObservable().pipe(take(1));
        /** @type {?} */
        const optionChanges = this.autocomplete.options.changes.pipe(tap((/**
         * @return {?}
         */
        () => this._positionStrategy.reapplyLastPosition())), 
        // Defer emitting to the stream until the next tick, because changing
        // bindings in here will cause "changed after checked" errors.
        delay(0));
        // When the zone is stable initially, and when the option list changes...
        return merge(firstStable, optionChanges)
            .pipe(
        // create a new stream of panelClosingActions, replacing any previous streams
        // that were created, and flatten it so our stream only emits closing events...
        switchMap((/**
         * @return {?}
         */
        () => {
            this._resetActiveItem();
            this.autocomplete._setVisibility();
            return this.panelClosingActions;
        })), 
        // when the first closing event occurs...
        take(1))
            // set the value, close the panel, and complete.
            .subscribe((/**
         * @param {?} event
         * @return {?}
         */
        event => this._setValueAndClose(event)));
    }
    /**
     * Destroys the autocomplete suggestion panel.
     * @private
     * @return {?}
     */
    _destroyPanel() {
        if (this._overlayRef) {
            this.closePanel();
            this._overlayRef.dispose();
            this._overlayRef = null;
        }
    }
    /**
     * @private
     * @param {?} value
     * @return {?}
     */
    _setTriggerValue(value) {
        /** @type {?} */
        const toDisplay = this.autocomplete && this.autocomplete.valueFormatter ?
            this.autocomplete.valueFormatter(value) :
            value;
        // Simply falling back to an empty string if the display value is falsy does not work properly.
        // The display value can also be the number zero and shouldn't fall back to an empty string.
        /** @type {?} */
        const inputValue = toDisplay != null ? toDisplay : '';
        // If it's used within a `NxFormField` or `NxWord`, we should set it through the property so it can go
        // through change detection.
        if (this._formField) {
            this._formField._control.value = inputValue;
        }
        else {
            this._element.nativeElement.value = inputValue;
        }
    }
    /**
     * This method closes the panel, and if a value is specified, also sets the associated
     * control to that value. It will also mark the control as dirty if this interaction
     * stemmed from the user.
     * @private
     * @param {?} event
     * @return {?}
     */
    _setValueAndClose(event) {
        if (event && event.source) {
            this._clearPreviousSelectedOption(event.source);
            this._setTriggerValue(event.source.value);
            this._onChange(event.source.value);
            this._element.nativeElement.focus();
            this.autocomplete._emitSelectEvent(event.source);
        }
        this.closePanel();
    }
    /**
     * Clear any previous selected option and emit a selection change event for this option
     * @private
     * @param {?} skip
     * @return {?}
     */
    _clearPreviousSelectedOption(skip) {
        this.autocomplete.options.forEach((/**
         * @param {?} option
         * @return {?}
         */
        option => {
            if (option !== skip && option.selected) {
                option.deselect();
            }
        }));
    }
    /**
     * @private
     * @return {?}
     */
    _attachOverlay() {
        if (!this.autocomplete) {
            throw getNxAutocompleteMissingPanelError();
        }
        if (!this._overlayRef) {
            this._portal = new TemplatePortal(this.autocomplete.template, this._viewContainerRef);
            this._overlayRef = this._overlay.create(this._getOverlayConfig());
            if (this._viewportRuler) {
                this._viewportSubscription = this._viewportRuler.change().subscribe((/**
                 * @return {?}
                 */
                () => {
                    if (this.panelOpen && this._overlayRef) {
                        this._overlayRef.updateSize({ minWidth: this._getHostWidth() });
                    }
                }));
            }
        }
        else {
            /** Update the panel width, in case the host width has changed */
            this._overlayRef.updateSize({ minWidth: this._getHostWidth() });
        }
        if (this._overlayRef && !this._overlayRef.hasAttached()) {
            this._overlayRef.attach(this._portal);
            this._closingActionsSubscription = this._subscribeToClosingActions();
        }
        /** @type {?} */
        const wasOpen = this.panelOpen;
        this.autocomplete._setVisibility();
        this.autocomplete._isOpen = this._overlayAttached = true;
        // We need to do an extra `panelOpen` check in here, because the
        // autocomplete won't be shown if there are no options.
        if (this.panelOpen && wasOpen !== this.panelOpen) {
            this.autocomplete.opened.emit();
        }
    }
    /**
     * @private
     * @return {?}
     */
    _getOverlayConfig() {
        return new OverlayConfig({
            positionStrategy: this._getOverlayPosition(),
            scrollStrategy: this._scrollStrategy(),
            minWidth: this._getHostWidth(),
            direction: this._dir ? this._dir.value : 'ltr'
        });
    }
    /**
     * @private
     * @return {?}
     */
    _getOverlayPosition() {
        this._positionStrategy = this._overlay.position()
            .flexibleConnectedTo(this._getConnectedElement())
            .withViewportMargin(16)
            .withPush(false)
            .withPositions([
            {
                originX: 'start',
                originY: 'bottom',
                overlayX: 'start',
                overlayY: 'top'
            },
            {
                originX: 'start',
                originY: 'top',
                overlayX: 'start',
                overlayY: 'bottom',
            }
        ]);
        return this._positionStrategy;
    }
    /**
     * @private
     * @return {?}
     */
    _scrollStrategy() {
        return this._overlay.scrollStrategies.reposition();
    }
    /**
     * @private
     * @return {?}
     */
    _getConnectedElement() {
        return this._formField ? this._formField.getConnectedOverlayOrigin() : this._element;
    }
    /**
     * Returns the width of the input element, so the panel min-width can match it.
     * @private
     * @return {?}
     */
    _getHostWidth() {
        return this._getConnectedElement().nativeElement.getBoundingClientRect().width;
    }
    /**
     * Resets the active item to -1 so arrow events will activate the
     * correct options, or to 0 if the consumer opted into it.
     * @private
     * @return {?}
     */
    _resetActiveItem() {
        this.autocomplete._keyManager.setActiveItem(-1);
    }
    /**
     * Determines whether the panel can be opened.
     * @private
     * @return {?}
     */
    _isFieldEnabled() {
        /** @type {?} */
        const element = this._element.nativeElement;
        return !element.readOnly && !element.disabled;
    }
}
NxAutocompleteTriggerDirective.decorators = [
    { type: Directive, args: [{
                selector: `input[nxAutocomplete], textarea[nxAutocomplete]`,
                host: {
                    'role': 'combobox',
                    'autocomplete': 'off',
                    'aria-autocomplete': 'list',
                    '[attr.aria-activedescendant]': 'activeOption?.id',
                    '[attr.aria-expanded]': 'panelOpen.toString()',
                    '[attr.aria-owns]': 'autocomplete?.id',
                    // Note: we use `focusin`, as opposed to `focus`, in order to open the panel
                    // a little earlier. This avoids issues where IE delays the focusing of the input.
                    '(focusin)': '_handleFocus()',
                    '(blur)': '_onTouched()',
                    '(input)': '_handleInput($event)',
                    '(keydown)': '_handleKeydown($event)',
                },
                exportAs: 'nxAutocompleteTrigger',
                providers: [NX_AUTOCOMPLETE_VALUE_ACCESSOR]
            },] }
];
/** @nocollapse */
NxAutocompleteTriggerDirective.ctorParameters = () => [
    { type: ElementRef },
    { type: Overlay },
    { type: ViewContainerRef },
    { type: NgZone },
    { type: ChangeDetectorRef },
    { type: Directionality, decorators: [{ type: Optional }] },
    { type: NxFormfieldComponent, decorators: [{ type: Optional }, { type: Host }] },
    { type: NxWordComponent$1, decorators: [{ type: Optional }, { type: Host }] },
    { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [DOCUMENT,] }] },
    { type: ViewportRuler }
];
NxAutocompleteTriggerDirective.propDecorators = {
    autocomplete: [{ type: Input, args: ['nxAutocomplete',] }],
    itemsCb: [{ type: Input, args: ['nxAutocompleteItems',] }],
    debounce: [{ type: Input, args: ['nxAutocompleteDebounce',] }],
    autocompleteDisabled: [{ type: Input, args: ['nxAutocompleteDisabled',] }]
};
if (false) {
    /**
     * @type {?}
     * @private
     */
    NxAutocompleteTriggerDirective.prototype._overlayRef;
    /**
     * @type {?}
     * @private
     */
    NxAutocompleteTriggerDirective.prototype._portal;
    /**
     * @type {?}
     * @private
     */
    NxAutocompleteTriggerDirective.prototype._componentDestroyed;
    /**
     * Old value of the native input. Used to work around issues with the `input` event on IE.
     * @type {?}
     * @private
     */
    NxAutocompleteTriggerDirective.prototype._previousValue;
    /**
     * Strategy that is used to position the panel.
     * @type {?}
     * @private
     */
    NxAutocompleteTriggerDirective.prototype._positionStrategy;
    /**
     * Whether or not the label state is being overridden.
     * @type {?}
     * @private
     */
    NxAutocompleteTriggerDirective.prototype._manuallyFloatingLabel;
    /**
     * The subscription for closing actions (some are bound to document).
     * @type {?}
     * @private
     */
    NxAutocompleteTriggerDirective.prototype._closingActionsSubscription;
    /**
     * Subscription to viewport size changes.
     * @type {?}
     * @private
     */
    NxAutocompleteTriggerDirective.prototype._viewportSubscription;
    /**
     * Subscription to control value changes
     * @type {?}
     * @private
     */
    NxAutocompleteTriggerDirective.prototype._controlValueChangesSubscription;
    /**
     * Subscription to items observable
     * @type {?}
     * @private
     */
    NxAutocompleteTriggerDirective.prototype._itemsSubscription;
    /**
     * Stream of keyboard events that can close the panel.
     * @type {?}
     * @private
     */
    NxAutocompleteTriggerDirective.prototype._closeKeyEventStream;
    /**
     * Value changes
     * @type {?}
     * @private
     */
    NxAutocompleteTriggerDirective.prototype._valueChanges;
    /**
     * The autocomplete panel to be attached to this trigger.
     * @type {?}
     */
    NxAutocompleteTriggerDirective.prototype.autocomplete;
    /**
     * @type {?}
     * @private
     */
    NxAutocompleteTriggerDirective.prototype._itemsCb;
    /**
     * @type {?}
     * @private
     */
    NxAutocompleteTriggerDirective.prototype._debounce;
    /**
     * @type {?}
     * @private
     */
    NxAutocompleteTriggerDirective.prototype._autocompleteDisabled;
    /**
     * @type {?}
     * @private
     */
    NxAutocompleteTriggerDirective.prototype._overlayAttached;
    /**
     * Stream of autocomplete option selections.
     * @type {?}
     */
    NxAutocompleteTriggerDirective.prototype.optionSelections;
    /**
     * `View -> model callback called when value changes`
     * @type {?}
     */
    NxAutocompleteTriggerDirective.prototype._onChange;
    /**
     * `View -> model callback called when autocomplete has been touched`
     * @type {?}
     */
    NxAutocompleteTriggerDirective.prototype._onTouched;
    /**
     * @type {?}
     * @private
     */
    NxAutocompleteTriggerDirective.prototype._element;
    /**
     * @type {?}
     * @private
     */
    NxAutocompleteTriggerDirective.prototype._overlay;
    /**
     * @type {?}
     * @private
     */
    NxAutocompleteTriggerDirective.prototype._viewContainerRef;
    /**
     * @type {?}
     * @private
     */
    NxAutocompleteTriggerDirective.prototype._zone;
    /**
     * @type {?}
     * @private
     */
    NxAutocompleteTriggerDirective.prototype._changeDetectorRef;
    /**
     * @type {?}
     * @private
     */
    NxAutocompleteTriggerDirective.prototype._dir;
    /**
     * @type {?}
     * @private
     */
    NxAutocompleteTriggerDirective.prototype._nxFormField;
    /**
     * @type {?}
     * @private
     */
    NxAutocompleteTriggerDirective.prototype._nxWordField;
    /**
     * @type {?}
     * @private
     */
    NxAutocompleteTriggerDirective.prototype._document;
    /**
     * @type {?}
     * @private
     */
    NxAutocompleteTriggerDirective.prototype._viewportRuler;
}
/**
 * Determines the position to which to scroll a panel in order for an option to be into view.
 * \@docs-private
 * @param {?} optionOffset Option offset
 * @param {?} optionHeight Height of the options.
 * @param {?} currentScrollPosition Current scroll position of the panel.
 * @param {?} panelHeight Height of the panel.
 * @return {?}
 */
function _getOptionScrollPosition(optionOffset, optionHeight, currentScrollPosition, panelHeight) {
    if (optionOffset < currentScrollPosition) {
        return optionOffset;
    }
    if (optionOffset + optionHeight > currentScrollPosition + panelHeight) {
        return Math.max(0, optionOffset - panelHeight + optionHeight);
    }
    return currentScrollPosition;
}

/**
 * @fileoverview added by tsickle
 * Generated from: autocomplete/autocomplete.module.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class NxAutocompleteModule {
}
NxAutocompleteModule.decorators = [
    { type: NgModule, args: [{
                declarations: [NxAutocompleteComponent, NxAutocompleteOptionComponent, NxAutocompleteTriggerDirective],
                exports: [NxAutocompleteComponent, NxAutocompleteOptionComponent, NxAutocompleteTriggerDirective],
                imports: [CommonModule, OverlayModule, A11yModule]
            },] }
];

/**
 * @fileoverview added by tsickle
 * Generated from: autocomplete/public-api.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * Generated from: autocomplete/index.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * Generated from: natural-language-form/word.component.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class NxWordComponent {
    /**
     * @param {?} elementRef
     * @param {?} _changeDetectorRef
     * @param {?} _renderer
     * @param {?} _overlay
     * @param {?} _viewContainerRef
     * @param {?} _overlayPositionBuilder
     */
    constructor(elementRef, _changeDetectorRef, _renderer, _overlay, _viewContainerRef, _overlayPositionBuilder) {
        this.elementRef = elementRef;
        this._changeDetectorRef = _changeDetectorRef;
        this._renderer = _renderer;
        this._overlay = _overlay;
        this._viewContainerRef = _viewContainerRef;
        this._overlayPositionBuilder = _overlayPositionBuilder;
        this.subscription = Subscription.EMPTY;
        this.subscriptionValues = Subscription.EMPTY;
        /**
         * \@docs-private
         */
        this.inputChanges = new Subject();
        this._hasErrors = false;
        /**
         * \@docs-private
         */
        this.currentTextWidth = 0;
        // this will apply different min-widths to our component through our styles
        /**
         * Provide a hint for a minimal width. The actual size will be determined for inputs for each change.
         */
        this.size = 'regular';
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.setupErrorPopover();
    }
    /**
     * @return {?}
     */
    ngAfterContentInit() {
        this._validateControlChild();
        this.subscription = this._control.stateChanges.pipe(startWith(null)).subscribe((/**
         * @return {?}
         */
        () => {
            this._hasErrors = this._control.errorState;
            this.updateErrorPopoverState();
            this._changeDetectorRef.markForCheck();
        }));
        // if we have a ngcontrol available stick to its valueChanges subject
        if (this._control.ngControl) {
            this.subscriptionValues = this._control.ngControl.valueChanges.subscribe((/**
             * @param {?} value
             * @return {?}
             */
            value => {
                this.updateCurrentTextWidth();
                this.inputChanges.next();
            }));
            // in any other case it is a bre input and input changes are signaled through simple state changes
        }
        else {
            this.subscriptionValues = this._control.stateChanges.subscribe((/**
             * @param {?} value
             * @return {?}
             */
            value => {
                this.updateCurrentTextWidth();
                this.inputChanges.next();
            }));
        }
        this._control.setAriaLabel(this.label);
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this.subscription.unsubscribe();
    }
    /**
     * \@docs-private
     * Calculate the width of the full text given by the input,
     * that value is bound to this component so it can grow.
     * The involved input is known to have a width of 100% an will fit the additional space given
     * which completes the auto growing behavior.
     * @return {?}
     */
    updateCurrentTextWidth() {
        // provide the canvas only lazy
        if (!this.measureCanvas) {
            this.measureCanvas = this._renderer.createElement('canvas');
        }
        /** @type {?} */
        const ctx = this.measureCanvas.getContext('2d');
        /** @type {?} */
        const inputRef = this._control.elementRef;
        /** @type {?} */
        const styles = window.getComputedStyle(inputRef.nativeElement);
        ctx.font = getFontShorthand(styles);
        /** @type {?} */
        const metrics = ctx.measureText(this._control.value);
        // add 1px (cursor width) to prevent jumping of the text on blur.
        /** @type {?} */
        const newWidth = metrics.width + parseInt(styles.paddingRight, 10) + parseInt(styles.paddingLeft, 10) + 1;
        // This should be injected via @Host to get an exact reference to NxNaturalLanguageFormComponent
        // Works as promised as long as there is not other tag around the word. Not expected but possible.
        /** @type {?} */
        const parent = this.elementRef.nativeElement.parentElement;
        /** @type {?} */
        const parentMeasurement = parent.getBoundingClientRect();
        // Limit to own given minimal width
        this.currentTextWidth = Math.max(parseInt(styles.minWidth, 10), newWidth);
        // Limit to container width
        this.currentTextWidth = Math.min(this.currentTextWidth, parentMeasurement.width);
        if (this._overlayRef.hasAttached()) {
            this._overlayState.positionStrategy.apply();
        }
    }
    /**
     * \@docs-private
     * @return {?}
     */
    repositionError() {
        if (this._overlayRef.hasAttached()) {
            this._overlayState.positionStrategy.apply();
        }
    }
    // Fail if the required control is missing.
    /**
     * @protected
     * @return {?}
     */
    _validateControlChild() {
        if (!this._control) {
            throw new Error('NxWordComponent requires an NxFormfieldControl compatible input.');
        }
    }
    /**
     * \@docs-private
     * @return {?}
     */
    getConnectedOverlayOrigin() {
        return this.elementRef;
    }
    /**
     * \@docs-private
     * @return {?}
     */
    get isFocused() {
        return this._control.focused;
    }
    /**
     * \@docs-private
     * @return {?}
     */
    get isFilled() {
        return !this._control.empty;
    }
    /**
     * \@docs-private
     * @return {?}
     */
    get hasDropdown() {
        return Boolean(this._dropdown);
    }
    /**
     * @return {?}
     */
    updateErrorPopoverState() {
        if (this._hasErrors && this._errorChildren.length > 0) {
            this.showPopover();
        }
        else {
            this.hidePopover();
        }
    }
    /**
     * @return {?}
     */
    setupErrorPopover() {
        /** @type {?} */
        const positionStrategy = this._overlayPositionBuilder
            .flexibleConnectedTo(this.elementRef)
            .withLockedPosition(true)
            .withFlexibleDimensions(false)
            .withPush(true)
            .withPositions([{
                originX: 'center',
                originY: 'top',
                overlayX: 'center',
                overlayY: 'bottom'
            },
            {
                originX: 'center',
                originY: 'bottom',
                overlayX: 'center',
                overlayY: 'top'
            }])
            .withDefaultOffsetY(-8);
        this._overlayState = new OverlayConfig();
        this._overlayState.positionStrategy = positionStrategy;
        this._overlayState.scrollStrategy = this._overlay.scrollStrategies.reposition();
        this._overlayRef = this._overlay.create(this._overlayState);
        ((/** @type {?} */ (this._overlayState.positionStrategy))).positionChanges.subscribe((/**
         * @param {?} change
         * @return {?}
         */
        change => {
            /** @type {?} */
            const pair = change.connectionPair;
            this.positionArrow(pair);
            // These position changes arrive too late,
            // We have to trigger the change detection manually
            // as it's detached from any render hierarchy
            // and only updated by the overlay when attached.
            if (this._embeddedViewRef && !this._embeddedViewRef.destroyed) {
                this._embeddedViewRef.detectChanges();
            }
        }));
    }
    /**
     * @private
     * @param {?} pair
     * @return {?}
     */
    positionArrow(pair) {
        /** @type {?} */
        const parentElementPositionX = this.elementRef.nativeElement.getBoundingClientRect().left;
        /** @type {?} */
        const parentElementWidth = this.elementRef.nativeElement.getBoundingClientRect().width / 2;
        /** @type {?} */
        const parentElementLeftOffset = this._overlayRef.overlayElement.parentElement.offsetLeft;
        /** @type {?} */
        const overlayElementLeftOffset = this._overlayRef.overlayElement.offsetLeft;
        // calculation for x position of the parent element. In this case, overlay left offset is the one thing to consider.
        /** @type {?} */
        const targetPosition = (parentElementPositionX + parentElementWidth) - (parentElementLeftOffset + overlayElementLeftOffset);
        if (pair.originY === 'top' && pair.overlayY === 'bottom') {
            this._popover.direction = 'top';
        }
        else {
            this._popover.direction = 'bottom';
        }
        this._popover.arrowStyle = { left: targetPosition + 'px' };
    }
    /**
     * @return {?}
     */
    showPopover() {
        if (!this._overlayRef.hasAttached()) {
            /** @type {?} */
            const tooltipPortal = new TemplatePortal(this._popover.templateRef, this._viewContainerRef);
            this._embeddedViewRef = this._overlayRef.attach(tooltipPortal);
        }
    }
    /**
     * @return {?}
     */
    hidePopover() {
        this._overlayRef.detach();
    }
}
NxWordComponent.decorators = [
    { type: Component, args: [{
                selector: 'nx-word',
                template: "<div>\n  <!-- We only allow formfield controls here -->\n  <div *ngIf=\"!hasDropdown\" class=\"nx-word__inner-wrapper\">\n    <ng-content select=\"[nxInput]\"></ng-content>\n  </div>\n  <ng-content select=\"nx-dropdown\"></ng-content>\n</div>\n\n<nx-popover #popover>\n  <ng-content select=\"[nxError]\"></ng-content>\n</nx-popover>",
                host: {
                    '[class.size-short]': 'size == "short"',
                    '[class.size-regular]': 'size == "regular"',
                    '[class.size-long]': 'size == "long"',
                    '[class.has-error]': '_hasErrors',
                    '[class.is-focused]': 'isFocused',
                    '[class.is-filled]': 'isFilled',
                    '[class.has-dropdown]': 'hasDropdown',
                },
                changeDetection: ChangeDetectionStrategy.OnPush,
                styles: [":host{display:inline-block;position:relative;font-weight:400;text-align:center;-webkit-hyphens:none;-ms-hyphens:none;hyphens:none;width:100%;margin:0 4px}:host .nx-word__inner-wrapper{border-bottom:2px solid #d9d9d9}:host.size-short{min-width:80px}:host.size-regular{min-width:152px}:host.size-long{min-width:360px}@media (max-width:991px){:host.size-long{min-width:280px}}@media (max-width:703px){:host.size-long{min-width:248px}}:host ::ng-deep .c-input{display:inline-block;text-align:inherit;font-size:inherit;line-height:inherit;background:0 0;color:inherit;border:none;outline:0;margin:0;width:100%;max-width:100%;height:auto;box-shadow:none;padding:0 8px}:host ::ng-deep .c-input.is-focused{outline:0;box-shadow:none}:host ::ng-deep .c-input.is-filled,:host ::ng-deep .c-input.is-focused{color:#006192;color:var(--natural-language-form-active-color,#006192);font-weight:400}:host ::ng-deep .c-input.is-disabled{cursor:not-allowed}:host ::ng-deep .c-input::-ms-clear{display:none}:host ::ng-deep nx-dropdown{position:relative;border-bottom:2px solid #d9d9d9}:host ::ng-deep nx-dropdown .nx-dropdown__container{font-size:inherit;margin-bottom:-2px}:host ::ng-deep nx-dropdown.has-focus,:host ::ng-deep nx-dropdown.is-filled{color:#006192;color:var(--natural-language-form-active-color,#006192);border-color:#007ab3;border-color:var(--natural-language-form-active-border-color,#007ab3)}:host ::ng-deep nx-dropdown .nx-dropdown__icon{line-height:inherit}:host ::ng-deep .nx-word__input-wrapper{width:100%}:host(.is-filled) .nx-word__inner-wrapper,:host(.is-focused) .nx-word__inner-wrapper{border-color:#007ab3;border-color:var(--natural-language-form-active-border-color,#007ab3)}:host(.has-error) .nx-word__inner-wrapper{border-color:#dc3149;border-color:var(--natural-language-form-error-border-color,#dc3149)}:host.has-error ::ng-deep nx-dropdown{color:#dc3149;color:var(--natural-language-form-error-color,#dc3149);border-color:#dc3149;border-color:var(--natural-language-form-error-border-color,#dc3149)}:host.has-error ::ng-deep .c-input.has-error{color:#dc3149;color:var(--natural-language-form-error-color,#dc3149)}:host-context(.is-negative) ::ng-deep .nx-dropdown,:host-context(.is-negative) ::ng-deep nx-dropdown,:host-context(.is-negative) ::ng-deep nx-dropdown.is-filled{border-color:#fff;color:#fff}:host-context(.is-negative) ::ng-deep .c-input,:host-context(.is-negative) ::ng-deep .c-input.has-error{color:#fff}:host-context(.is-negative) .nx-word__inner-wrapper{border-color:#fff}.nx-word__inner-wrapper{height:52px;height:var(--natural-language-form-large-line-height,52px)}@media (max-width:991px){:host ::ng-deep nx-dropdown .nx-dropdown__container{font-size:26px}.nx-word__inner-wrapper{height:36px;height:var(--natural-language-form-small-line-height,36px)}}:host-context(.nx-natural-language-form--small) .nx-word__inner-wrapper{height:36px;height:var(--natural-language-form-small-line-height,36px)}@media screen and (-ms-high-contrast:active){.nx-word__inner-wrapper,::ng-deep nx-dropdown{border-bottom-color:buttonText}}"]
            }] }
];
/** @nocollapse */
NxWordComponent.ctorParameters = () => [
    { type: ElementRef },
    { type: ChangeDetectorRef },
    { type: Renderer2 },
    { type: Overlay },
    { type: ViewContainerRef },
    { type: OverlayPositionBuilder }
];
NxWordComponent.propDecorators = {
    _control: [{ type: ContentChild, args: [NxFormfieldControl, { static: false },] }],
    _errorChildren: [{ type: ContentChildren, args: [NxFormfieldErrorDirective,] }],
    _popover: [{ type: ViewChild, args: ['popover', { static: true },] }],
    _dropdown: [{ type: ContentChild, args: [NxDropdownComponent$1, { static: false },] }],
    currentTextWidth: [{ type: HostBinding, args: ['style.width.px',] }],
    size: [{ type: Input, args: ['nxSize',] }],
    label: [{ type: Input, args: ['nxLabel',] }]
};
if (false) {
    /**
     * @type {?}
     * @private
     */
    NxWordComponent.prototype.subscription;
    /**
     * @type {?}
     * @private
     */
    NxWordComponent.prototype.subscriptionValues;
    /**
     * @type {?}
     * @private
     */
    NxWordComponent.prototype.measureCanvas;
    /**
     * \@docs-private
     * @type {?}
     */
    NxWordComponent.prototype.inputChanges;
    /** @type {?} */
    NxWordComponent.prototype._hasErrors;
    /**
     * @type {?}
     * @private
     */
    NxWordComponent.prototype._overlayRef;
    /**
     * @type {?}
     * @private
     */
    NxWordComponent.prototype._embeddedViewRef;
    /**
     * @type {?}
     * @private
     */
    NxWordComponent.prototype._overlayState;
    /** @type {?} */
    NxWordComponent.prototype._control;
    /** @type {?} */
    NxWordComponent.prototype._errorChildren;
    /** @type {?} */
    NxWordComponent.prototype._popover;
    /** @type {?} */
    NxWordComponent.prototype._dropdown;
    /**
     * \@docs-private
     * @type {?}
     */
    NxWordComponent.prototype.currentTextWidth;
    /**
     * Provide a hint for a minimal width. The actual size will be determined for inputs for each change.
     * @type {?}
     */
    NxWordComponent.prototype.size;
    /**
     * A word doesn't have a set place to show labels.
     * In order to be accessible, you have to provide a label with this property.
     * It will be attached to the given input through `aria-label`.
     * @type {?}
     */
    NxWordComponent.prototype.label;
    /**
     * \@docs-private
     * @type {?}
     */
    NxWordComponent.prototype.elementRef;
    /**
     * @type {?}
     * @private
     */
    NxWordComponent.prototype._changeDetectorRef;
    /**
     * @type {?}
     * @private
     */
    NxWordComponent.prototype._renderer;
    /**
     * @type {?}
     * @private
     */
    NxWordComponent.prototype._overlay;
    /**
     * @type {?}
     * @private
     */
    NxWordComponent.prototype._viewContainerRef;
    /**
     * @type {?}
     * @private
     */
    NxWordComponent.prototype._overlayPositionBuilder;
}

/**
 * @fileoverview added by tsickle
 * Generated from: natural-language-form/natural-language-form.component.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const DEFAULT_SIZE$3 = 'large';
class NxNaturalLanguageFormComponent {
    /**
     * @param {?} _changeDetectorRef
     */
    constructor(_changeDetectorRef) {
        this._changeDetectorRef = _changeDetectorRef;
        this._negative = false;
        /**
         * \@docs-private
         */
        this.resizeEvent$ = new Subject();
        /**
         * \@docs-private
         */
        this.updatePopoversSubscription = Subscription.EMPTY;
        /**
         * \@docs-private
         */
        this._size = DEFAULT_SIZE$3;
    }
    /**
     * Whether the negative set of stylings should be used.
     * @param {?} value
     * @return {?}
     */
    set negative(value) {
        this._negative = coerceBooleanProperty(value);
    }
    /**
     * @return {?}
     */
    get negative() {
        return this._negative;
    }
    /**
     * Sets the size of the NLF. Default value: large
     * @param {?} value
     * @return {?}
     */
    set size(value) {
        this._size = value;
        this._changeDetectorRef.markForCheck();
    }
    /**
     * @return {?}
     */
    get size() {
        return this._size;
    }
    /**
     * \@docs-private
     * @param {?} event
     * @return {?}
     */
    onResize(event) {
        this.resizeEvent$.next();
    }
    /**
     * @return {?}
     */
    ngAfterContentInit() {
        // Collect all words and listen for changes so we can update any open error popover
        // which would otherwise get wrongly positioned.
        /** @type {?} */
        const subjects = this._words.map((/**
         * @param {?} word
         * @return {?}
         */
        (word) => word.inputChanges));
        /** @type {?} */
        const source = merge(...subjects);
        this.updatePopoversSubscription = source.subscribe((/**
         * @return {?}
         */
        () => {
            this.updatePositionPopovers();
        }));
        this.resizeObservable = this.resizeEvent$.pipe(throttleTime(500), delay(100));
        this.resizeObservable.subscribe((/**
         * @return {?}
         */
        () => this.resizeWords()));
    }
    /**
     * \@docs-private
     * @return {?}
     */
    resizeWords() {
        this._words.forEach((/**
         * @param {?} word
         * @return {?}
         */
        (word) => {
            word.updateCurrentTextWidth();
        }));
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this.updatePopoversSubscription.unsubscribe();
    }
    /**
     * \@docs-private
     * @return {?}
     */
    updatePositionPopovers() {
        if (this._words) {
            this._words.forEach((/**
             * @param {?} word
             * @return {?}
             */
            (word) => {
                word.repositionError();
            }));
        }
    }
}
NxNaturalLanguageFormComponent.decorators = [
    { type: Component, args: [{
                selector: 'nx-natural-language-form',
                template: "<div class=\"nx-natural-language-form__wrapper\">\n    <ng-content></ng-content>\n</div>",
                changeDetection: ChangeDetectionStrategy.OnPush,
                host: {
                    '[class.is-negative]': 'negative',
                    '[class.nx-natural-language-form--small]': 'size === "small"',
                    '[class.nx-natural-language-form--large]': 'size === "large"',
                },
                styles: [":host{display:block;font-size:40px;font-size:var(--natural-language-form-large-font-size,40px);line-height:52px;line-height:var(--natural-language-form-large-line-height,52px);font-weight:300;font-weight:var(--natural-language-form-large-font-weight,300);letter-spacing:.3px;letter-spacing:var(--natural-language-form-large-letter-spacing,.3px);color:#414141;color:var(--natural-language-form-text-color,#414141);padding-top:72px;padding-bottom:80px}:host ::ng-deep .c-input{font-size:inherit;line-height:inherit}:host ::ng-deep nx-word+nx-word{margin-left:2px}:host.is-negative{color:#fff}@media (max-width:991px){:host{font-size:26px;font-size:var(--natural-language-form-small-font-size,26px);line-height:36px;line-height:var(--natural-language-form-small-line-height,36px);font-weight:300;font-weight:var(--natural-language-form-small-font-weight,300);letter-spacing:.3px;letter-spacing:var(--natural-language-form-small-letter-spacing,.3px)}}.nx-natural-language-form__wrapper{display:flex;flex-wrap:wrap}.nx-natural-language-form__wrapper>::ng-deep *{margin-bottom:8px}:host(.nx-natural-language-form--small){font-size:26px;font-size:var(--natural-language-form-small-font-size,26px);line-height:36px;line-height:var(--natural-language-form-small-line-height,36px);font-weight:300;font-weight:var(--natural-language-form-small-font-weight,300);letter-spacing:.3px;letter-spacing:var(--natural-language-form-small-letter-spacing,.3px)}:host(.nx-natural-language-form--small) ::ng-deep .c-input{font-size:inherit;line-height:inherit}"]
            }] }
];
/** @nocollapse */
NxNaturalLanguageFormComponent.ctorParameters = () => [
    { type: ChangeDetectorRef }
];
NxNaturalLanguageFormComponent.propDecorators = {
    _words: [{ type: ContentChildren, args: [NxWordComponent,] }],
    negative: [{ type: Input, args: ['nxNegative',] }],
    size: [{ type: Input }],
    onResize: [{ type: HostListener, args: ['window:orientationchange', ['$event'],] }, { type: HostListener, args: ['window:resize', ['$event'],] }]
};
if (false) {
    /**
     * @type {?}
     * @private
     */
    NxNaturalLanguageFormComponent.prototype._negative;
    /**
     * \@docs-private
     * @type {?}
     */
    NxNaturalLanguageFormComponent.prototype.resizeEvent$;
    /**
     * \@docs-private
     * @type {?}
     */
    NxNaturalLanguageFormComponent.prototype.resizeObservable;
    /** @type {?} */
    NxNaturalLanguageFormComponent.prototype._words;
    /**
     * \@docs-private
     * @type {?}
     */
    NxNaturalLanguageFormComponent.prototype.updatePopoversSubscription;
    /**
     * \@docs-private
     * @type {?}
     * @private
     */
    NxNaturalLanguageFormComponent.prototype._size;
    /**
     * @type {?}
     * @private
     */
    NxNaturalLanguageFormComponent.prototype._changeDetectorRef;
}

/**
 * @fileoverview added by tsickle
 * Generated from: natural-language-form/natural-language-form.module.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class NxNaturalLanguageFormModule {
}
NxNaturalLanguageFormModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    CommonModule,
                    NxInputModule,
                    NxPopoverModule$1
                ],
                declarations: [
                    NxNaturalLanguageFormComponent,
                    NxWordComponent
                ],
                exports: [
                    NxNaturalLanguageFormComponent,
                    NxWordComponent
                ]
            },] }
];

/**
 * @fileoverview added by tsickle
 * Generated from: natural-language-form/public-api.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * Generated from: message/message/message.component.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const ICONS = {
    info: 'info-circle',
    error: 'exclamation-triangle',
    success: 'check-circle',
    warning: 'exclamation-circle'
};
class NxMessageComponent {
    /**
     * @param {?} _changeDetectorRef
     */
    constructor(_changeDetectorRef) {
        this._changeDetectorRef = _changeDetectorRef;
        this._context = 'regular';
        this._showIcon = false;
        this._closable = false;
        this._closeButtonLabel = 'Close dialog';
        /**
         * Event emitted when the close icon of the message has been clicked.
         */
        this.closeEvent = new EventEmitter();
    }
    /**
     * Sets the context of the message.
     * The message box will color accordingly. Default: 'regular'
     * @param {?} value
     * @return {?}
     */
    set context(value) {
        if (value !== this._context) {
            this._context = value;
            this._icon = this.getIconName();
            this._changeDetectorRef.markForCheck();
        }
    }
    /**
     * @return {?}
     */
    get context() {
        return this._context;
    }
    /**
     * Whether an icon that belongs to the context of the message should be displayed.
     *
     * **Important:** The `showIcon` attribute should always be set to `true` due to deprecation.
     *
     * @deprecated The `showIcon` attribute should be always true in future. Messages without an icon are deprecated.
     * \@deletion-target 9.0.0
     *
     * @param {?} value
     * @return {?}
     */
    set showIcon(value) {
        this._showIcon = coerceBooleanProperty(value);
        this._changeDetectorRef.markForCheck();
    }
    /**
     * @return {?}
     */
    get showIcon() {
        return this._showIcon;
    }
    /**
     * Whether a message should have a close icon in order to be dismissed.
     * @param {?} value
     * @return {?}
     */
    set closable(value) {
        /** @type {?} */
        const newValue = coerceBooleanProperty(value);
        if (newValue !== this._closable) {
            this._closable = newValue;
            this._changeDetectorRef.markForCheck();
        }
    }
    /**
     * @return {?}
     */
    get closable() {
        return this._closable;
    }
    /**
     * \@docs-private
     * @return {?}
     */
    get icon() {
        return this._icon;
    }
    /**
     * Sets the label of the close button of the message.
     * @param {?} value
     * @return {?}
     */
    set closeButtonLabel(value) {
        if (value !== this._closeButtonLabel) {
            this._closeButtonLabel = value;
            this._changeDetectorRef.markForCheck();
        }
    }
    /**
     * @return {?}
     */
    get closeButtonLabel() {
        return this._closeButtonLabel;
    }
    /**
     * \@docs-private
     * @return {?}
     */
    _emitCloseEvent() {
        this.closeEvent.emit();
    }
    /**
     * \@docs-private
     * @return {?}
     */
    getIconName() {
        if (this._context === 'info') {
            return ICONS.info;
        }
        else if (this._context === 'error') {
            return ICONS.error;
        }
        else if (this._context === 'success') {
            return ICONS.success;
        }
        else if (this._context === 'warning') {
            return ICONS.warning;
        }
        return '';
    }
}
NxMessageComponent.decorators = [
    { type: Component, args: [{
                selector: 'nx-message',
                template: "<nx-icon *ngIf=\"showIcon && context !== 'regular'\"\n         class=\"nx-message__icon\"\n         [name]=\"icon\"\n         size=\"s\">\n</nx-icon>\n<button\n  *ngIf=\"closable\"\n  (click)=\"_emitCloseEvent()\"\n  [attr.aria-label]=\"closeButtonLabel\"\n  tabindex=\"0\"\n  class=\"nx-message__close-icon\">\n    <nx-icon\n      name=\"close\"\n      size=\"s\"\n      aria-hidden=\"true\">\n    </nx-icon>\n</button>\n\n\n<div class=\"nx-message__content-wrapper\">\n  <div class=\"nx-message__content\">\n    <ng-content></ng-content>\n  </div>\n</div>\n",
                changeDetection: ChangeDetectionStrategy.OnPush,
                exportAs: 'nxMessage',
                host: {
                    '[class.context-info]': 'context === "info"',
                    '[class.context-error]': 'context === "error"',
                    '[class.context-success]': 'context === "success"',
                    '[class.context-warning]': 'context === "warning"',
                    '[class.nx-message--closable]': 'closable'
                },
                styles: [":host{font-size:16px;font-size:var(--message-font-size,16px);line-height:24px;line-height:var(--message-line-height,24px);font-weight:400;font-weight:var(--message-font-weight,400);letter-spacing:0;letter-spacing:var(--message-letter-spacing,0);color:#414141;color:var(--message-text-color,#414141);border-radius:4px;border-radius:var(--message-border-radius,4px);width:100%;display:flex;align-items:flex-start;text-align:left;position:relative;border:1px solid;padding:23px;margin:12px 0}.nx-message__content-wrapper{max-width:100%}:host,:host(.context-regular){border-color:#414141;border-color:var(--message-regular-border-color,#414141);background-color:#fff;background-color:var(--message-regular-background-color,#fff)}:host(.context-info){border-color:#496ebd;border-color:var(--message-info-border-color,#496ebd);background-color:#ecf0f8;background-color:var(--message-info-background-color,#ecf0f8)}:host(.context-info) .nx-message__icon{color:#496ebd;color:var(--message-info-icon-color,#496ebd)}:host(.context-error){border-color:#dc3149;border-color:var(--message-error-border-color,#dc3149);background-color:#fbeaec;background-color:var(--message-error-background-color,#fbeaec)}:host(.context-error) .nx-message__icon{color:#dc3149;color:var(--message-error-icon-color,#dc3149)}:host(.context-success){border-color:#1e8927;border-color:var(--message-success-border-color,#1e8927);background-color:#e8f3e9;background-color:var(--message-success-background-color,#e8f3e9)}:host(.context-success) .nx-message__icon{color:#1e8927;color:var(--message-success-icon-color,#1e8927)}:host(.context-warning){border-color:#efbe25;border-color:var(--message-warning-border-color,#efbe25);background-color:#fdf8e9;background-color:var(--message-warning-background-color,#fdf8e9)}:host(.context-warning) .nx-message__icon{color:#efbe25;color:var(--message-warning-icon-color,#efbe25)}.nx-message__icon{margin-right:16px}@media (max-width:703px){:host{padding:31px;display:block}:host(.context-error) .nx-message__icon~.nx-message__content-wrapper .nx-message__content,:host(.context-info) .nx-message__icon~.nx-message__content-wrapper .nx-message__content,:host(.context-success) .nx-message__icon~.nx-message__content-wrapper .nx-message__content,:host(.context-warning) .nx-message__icon~.nx-message__content-wrapper .nx-message__content{display:inline;margin-left:31px}.nx-message__icon{position:absolute}}:host(.nx-message--closable){padding-right:39px}@media (max-width:703px){:host(.nx-message--closable){padding-right:31px}}.nx-message__close-icon{position:absolute;top:16px;right:16px;cursor:pointer;background-color:transparent;border:none;outline:0;padding:0;display:flex;align-items:center}.nx-message__close-icon nx-icon{color:#414141;color:var(--message-close-icon-color,#414141);font-size:16px}:host-context([data-whatinput=keyboard]) .nx-message__close-icon:focus{box-shadow:0 0 0 2px #fff,0 0 0 6px #009de6;box-shadow:var(--focus-box-shadow,0 0 0 2px #fff,0 0 0 6px #009de6);border-radius:4px}@media screen and (-ms-high-contrast:active){:host(.context-error) .nx-message__icon,:host(.context-info) .nx-message__icon,:host(.context-success) .nx-message__icon,:host(.context-warning) .nx-message__icon{color:windowText}:host-context([data-whatinput=keyboard]) .nx-message__close-icon:focus{box-shadow:0 0 0 2px background,0 0 0 6px windowText}}"]
            }] }
];
/** @nocollapse */
NxMessageComponent.ctorParameters = () => [
    { type: ChangeDetectorRef }
];
NxMessageComponent.propDecorators = {
    context: [{ type: Input, args: ['nxContext',] }],
    showIcon: [{ type: Input }],
    closable: [{ type: Input }],
    closeButtonLabel: [{ type: Input }],
    closeEvent: [{ type: Output, args: ['close',] }]
};
if (false) {
    /**
     * @type {?}
     * @private
     */
    NxMessageComponent.prototype._context;
    /**
     * @type {?}
     * @private
     */
    NxMessageComponent.prototype._showIcon;
    /**
     * @type {?}
     * @private
     */
    NxMessageComponent.prototype._closable;
    /**
     * @type {?}
     * @private
     */
    NxMessageComponent.prototype._icon;
    /**
     * @type {?}
     * @private
     */
    NxMessageComponent.prototype._closeButtonLabel;
    /**
     * Event emitted when the close icon of the message has been clicked.
     * @type {?}
     */
    NxMessageComponent.prototype.closeEvent;
    /**
     * @type {?}
     * @private
     */
    NxMessageComponent.prototype._changeDetectorRef;
}

/**
 * @fileoverview added by tsickle
 * Generated from: message/message-toast/message-toast-animations.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Animations used by the Message Toast.
 * \@docs-private
 * @type {?}
 */
const messageToastAnimations = {
    toastState: trigger('state', [
        state('initial, void, hidden', style({ opacity: 0, transform: 'translateY(100%)' })),
        state('visible', style({ opacity: 1 })),
        transition('* => visible', animate('300ms cubic-bezier(0, 0, 0.2, 1)', style({ opacity: 1, transform: 'translateY(0)' }))),
        transition('* => hidden', animate('300ms cubic-bezier(0, 0, 0.2, 1)', style({ opacity: 0, transform: 'translateY(200%)' }))),
    ])
};

/**
 * @fileoverview added by tsickle
 * Generated from: message/message-toast/message-toast-config.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Configuration used when opening a message toast.
 */
class NxMessageToastConfig {
    constructor() {
        /**
         * The politeness level for the LiveAnnouncer announcement.
         *
         *  Default value: 'polite'.
         */
        this.politeness = 'polite';
        /**
         * Message to be announced by the LiveAnnouncer. When opening a toast message without a custom
         * component or template, the announcement message will default to the specified message.
         *
         * Default value: ''.
         */
        this.announcementMessage = '';
        /**
         * The length of time in milliseconds to wait before automatically dismissing the message toast.
         *
         * Default value: 3000.
         */
        this.duration = 3000;
        /**
         * Context of the message toast.
         *
         * Default value: 'info'.
         */
        this.context = 'info';
    }
}
if (false) {
    /**
     * The politeness level for the LiveAnnouncer announcement.
     *
     *  Default value: 'polite'.
     * @type {?}
     */
    NxMessageToastConfig.prototype.politeness;
    /**
     * Message to be announced by the LiveAnnouncer. When opening a toast message without a custom
     * component or template, the announcement message will default to the specified message.
     *
     * Default value: ''.
     * @type {?}
     */
    NxMessageToastConfig.prototype.announcementMessage;
    /**
     * The length of time in milliseconds to wait before automatically dismissing the message toast.
     *
     * Default value: 3000.
     * @type {?}
     */
    NxMessageToastConfig.prototype.duration;
    /**
     * Context of the message toast.
     *
     * Default value: 'info'.
     * @type {?}
     */
    NxMessageToastConfig.prototype.context;
}
/**
 * \@docs-private
 * Needed so that the user text data can be injected in the message toastcomponent
 */
class NxMessageToastData {
    /**
     * @param {?} data
     */
    constructor(data) {
        this.data = data;
    }
}
if (false) {
    /** @type {?} */
    NxMessageToastData.prototype.data;
}

/**
 * @fileoverview added by tsickle
 * Generated from: message/message-toast/message-toast.component.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const ICONS$1 = {
    info: 'info-circle',
    success: 'check-circle',
};
/**
 * Internal component that wraps user-provided message toastcontent.
 * \@docs-private
 */
class NxMessageToastComponent extends BasePortalOutlet {
    /**
     * @param {?} _ngZone
     * @param {?} _changeDetectorRef
     * @param {?} config
     * @param {?=} data
     */
    constructor(_ngZone, _changeDetectorRef, config, data) {
        super();
        this._ngZone = _ngZone;
        this._changeDetectorRef = _changeDetectorRef;
        this.config = config;
        this.data = data;
        /**
         * Whether the component has been destroyed.
         */
        this._destroyed = false;
        /**
         * Subject for notifying that the message toasthas exited from view.
         */
        this._onExit = new Subject();
        /**
         * Subject for notifying that the message toasthas finished entering the view.
         */
        this._onEnter = new Subject();
        /**
         * The state of the message toastanimations.
         */
        this._animationState = 'void';
        this._context = this.config.context;
        this._setAriaLabels();
    }
    /**
     * Attach a component portal as content to this message toastcontainer.
     * @template T
     * @param {?} portal
     * @return {?}
     */
    attachComponentPortal(portal) {
        this._assertNotAttached();
        return this._portalOutlet.attachComponentPortal(portal);
    }
    /**
     * Attach a template portal as content to this message toastcontainer.
     * @template C
     * @param {?} portal
     * @return {?}
     */
    attachTemplatePortal(portal) {
        this._assertNotAttached();
        return this._portalOutlet.attachTemplatePortal(portal);
    }
    /**
     * Handle end of animations, updating the state of the notification.
     * @param {?} event
     * @return {?}
     */
    onAnimationEnd(event) {
        const { fromState, toState } = event;
        if ((toState === 'void' && fromState !== 'void') || toState === 'hidden') {
            this._completeExit();
        }
        if (toState === 'visible') {
            // Note: we shouldn't use `this` inside the zone callback,
            // because it can cause a memory leak.
            /** @type {?} */
            const onEnter = this._onEnter;
            this._ngZone.run((/**
             * @return {?}
             */
            () => {
                onEnter.next();
                onEnter.complete();
            }));
        }
    }
    /**
     * Begin animation of message toastentrance into view.
     * @return {?}
     */
    enter() {
        if (!this._destroyed) {
            this._animationState = 'visible';
            this._changeDetectorRef.detectChanges();
        }
    }
    /**
     * Begin animation of the message toastexiting from view.
     * @return {?}
     */
    exit() {
        // Note: this one transitions to `hidden`, rather than `void`, in order to handle the case
        // where multiple notifications are opened in quick succession (e.g. two consecutive calls to
        // `NxMessageToastService.open`).
        this._animationState = 'hidden';
    }
    /**
     * Makes sure the exit callbacks have been invoked when the element is destroyed.
     * @return {?}
     */
    ngOnDestroy() {
        this._destroyed = true;
        this._completeExit();
    }
    /**
     * Waits for the zone to settle before removing the element. Helps prevent
     * errors where we end up removing an element which is in the middle of an animation.
     * @private
     * @return {?}
     */
    _completeExit() {
        this._ngZone.onMicrotaskEmpty.asObservable().pipe(take(1)).subscribe((/**
         * @return {?}
         */
        () => {
            this._onExit.next();
            this._onExit.complete();
        }));
    }
    /**
     * Asserts that no content is already attached to the container.
     * @private
     * @return {?}
     */
    _assertNotAttached() {
        if (this._portalOutlet.hasAttached()) {
            throw Error('Attempting to attach message toastcontent after content is already attached');
        }
    }
    /**
     * @return {?}
     */
    _getIconName() {
        return this._context === 'success' ? ICONS$1.success : ICONS$1.info;
    }
    /**
     * @return {?}
     */
    _setAriaLabels() {
        // Based on the ARIA spec, `alert` and `status` roles have an
        // implicit `assertive` and `polite` politeness respectively.
        if (this.config.politeness === 'assertive' && !this.config.announcementMessage) {
            this._role = 'alert';
        }
        else if (this.config.politeness === 'off') {
            this._role = null;
        }
        else {
            this._role = 'status';
        }
    }
}
NxMessageToastComponent.decorators = [
    { type: Component, args: [{
                selector: 'nx-message-toast',
                template: "<nx-icon class=\"nx-message__icon\" [name]=\"_getIconName()\" size=\"s\">\n</nx-icon>\n\n<div class=\"nx-message__content-wrapper\">\n    <!-- Used when opening from a template -->\n    <ng-template cdkPortalOutlet></ng-template>\n    <!-- Used when opening only with custom text-->\n    <ng-container *ngIf=\"data\">{{data.data}}</ng-container>\n</div>\n",
                host: {
                    '[attr.role]': '_role',
                    '[class.context-info]': '_context === "info"',
                    '[class.context-success]': '_context === "success"',
                    '[@state]': '_animationState',
                    '(@state.done)': 'onAnimationEnd($event)'
                },
                animations: [messageToastAnimations.toastState],
                styles: [":host{font-size:16px;font-size:var(--message-font-size,16px);line-height:24px;line-height:var(--message-line-height,24px);font-weight:400;font-weight:var(--message-font-weight,400);letter-spacing:0;letter-spacing:var(--message-letter-spacing,0);color:#414141;color:var(--message-text-color,#414141);border-radius:4px;border-radius:var(--message-border-radius,4px);width:100%;display:flex;align-items:flex-start;text-align:left;position:relative;border:1px solid;padding:23px 23px 23px 63px;margin:12px 0;box-shadow:0 2px 4px rgba(65,65,65,.5);box-shadow:var(--message-box-shadow,0 2px 4px rgba(65,65,65,.5));max-width:352px}@media (max-width:703px){:host{padding:23px 23px 23px 63px;display:block}}:host(.context-info){border-color:#496ebd;border-color:var(--message-info-border-color,#496ebd);background-color:#ecf0f8;background-color:var(--message-info-background-color,#ecf0f8)}:host(.context-info) .nx-message__icon{color:#496ebd;color:var(--message-info-icon-color,#496ebd)}:host(.context-success){border-color:#1e8927;border-color:var(--message-success-border-color,#1e8927);background-color:#e8f3e9;background-color:var(--message-success-background-color,#e8f3e9)}:host(.context-success) .nx-message__icon{color:#1e8927;color:var(--message-success-icon-color,#1e8927)}@media screen and (-ms-high-contrast:active){:host(.context-info) .nx-message__icon,:host(.context-success) .nx-message__icon{color:windowText}}.nx-message__icon{position:absolute;top:23px;left:23px}"]
            }] }
];
/** @nocollapse */
NxMessageToastComponent.ctorParameters = () => [
    { type: NgZone },
    { type: ChangeDetectorRef },
    { type: NxMessageToastConfig },
    { type: NxMessageToastData }
];
NxMessageToastComponent.propDecorators = {
    _portalOutlet: [{ type: ViewChild, args: [CdkPortalOutlet, { static: true },] }]
};
if (false) {
    /**
     * Whether the component has been destroyed.
     * @type {?}
     * @private
     */
    NxMessageToastComponent.prototype._destroyed;
    /**
     * The portal outlet inside of this container into which the message toastcontent will be loaded.
     * @type {?}
     */
    NxMessageToastComponent.prototype._portalOutlet;
    /**
     * Subject for notifying that the message toasthas exited from view.
     * @type {?}
     */
    NxMessageToastComponent.prototype._onExit;
    /**
     * Subject for notifying that the message toasthas finished entering the view.
     * @type {?}
     */
    NxMessageToastComponent.prototype._onEnter;
    /**
     * The state of the message toastanimations.
     * @type {?}
     */
    NxMessageToastComponent.prototype._animationState;
    /**
     * ARIA role for the message toastcontainer.
     * @type {?}
     */
    NxMessageToastComponent.prototype._role;
    /** @type {?} */
    NxMessageToastComponent.prototype._context;
    /**
     * @type {?}
     * @private
     */
    NxMessageToastComponent.prototype._ngZone;
    /**
     * @type {?}
     * @private
     */
    NxMessageToastComponent.prototype._changeDetectorRef;
    /**
     * The message toastconfiguration.
     * @type {?}
     */
    NxMessageToastComponent.prototype.config;
    /**
     * Injected data into the notifciation.
     * @type {?}
     */
    NxMessageToastComponent.prototype.data;
}

/**
 * @fileoverview added by tsickle
 * Generated from: message/message.module.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class NxMessageModule {
}
NxMessageModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    CommonModule,
                    NxIconModule,
                    OverlayModule,
                    PortalModule
                ],
                declarations: [
                    NxMessageComponent,
                    NxMessageToastComponent
                ],
                exports: [
                    NxMessageComponent
                ],
                entryComponents: [
                    NxMessageToastComponent
                ]
            },] }
];

/**
 * @fileoverview added by tsickle
 * Generated from: message/message-toast/message-toast-ref.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Maximum amount of milliseconds that can be passed into setTimeout.
 * @type {?}
 */
const MAX_TIMEOUT = Math.pow(2, 31) - 1;
class NxMessageToastRef {
    /**
     * @param {?} toastInstance
     * @param {?} _overlayRef
     */
    constructor(toastInstance, _overlayRef) {
        this._overlayRef = _overlayRef;
        /**
         * Subject for notifying the user that the message toasthas been dismissed.
         */
        this._afterDismissed = new Subject();
        /**
         * Subject for notifying the user that the message toasthas opened and appeared.
         */
        this._afterOpened = new Subject();
        this.toastInstance = toastInstance;
        toastInstance._onExit.subscribe((/**
         * @return {?}
         */
        () => this._finishDismiss()));
    }
    /**
     * Dismisses the message toast.
     * @return {?}
     */
    dismiss() {
        if (!this._afterDismissed.closed) {
            this.toastInstance.exit();
        }
        clearTimeout(this._durationTimeoutId);
    }
    /**
     * Dismisses the message toastafter some duration
     * @param {?} duration
     * @return {?}
     */
    _dismissAfter(duration) {
        // Note that we need to cap the duration to the maximum value for setTimeout, because
        // it'll revert to 1 if somebody passes in something greater (e.g. `Infinity`). See #17234.
        this._durationTimeoutId = setTimeout((/**
         * @return {?}
         */
        () => this.dismiss()), Math.min(duration, MAX_TIMEOUT));
    }
    /**
     * Marks the message toastas opened
     * @return {?}
     */
    _open() {
        if (!this._afterOpened.closed) {
            this._afterOpened.next();
            this._afterOpened.complete();
        }
    }
    /**
     * Cleans up the DOM after closing.
     * @private
     * @return {?}
     */
    _finishDismiss() {
        this._overlayRef.dispose();
        this._afterDismissed.next();
        this._afterDismissed.complete();
    }
    /**
     * Gets an observable that is notified when the message toastis finished closing.
     * @return {?}
     */
    afterDismissed() {
        return this._afterDismissed.asObservable();
    }
    /**
     * Gets an observable that is notified when the message toasthas opened and appeared.
     * @return {?}
     */
    afterOpened() {
        return this.toastInstance._onEnter;
    }
}
if (false) {
    /**
     * The instance of the component making up the content of the message toast.
     * \@docs-private
     * @type {?}
     */
    NxMessageToastRef.prototype.toastInstance;
    /**
     * Subject for notifying the user that the message toasthas been dismissed.
     * @type {?}
     * @private
     */
    NxMessageToastRef.prototype._afterDismissed;
    /**
     * Subject for notifying the user that the message toasthas opened and appeared.
     * @type {?}
     * @private
     */
    NxMessageToastRef.prototype._afterOpened;
    /**
     * Timeout ID for the duration setTimeout call. Used to clear the timeout if the message toastis
     * dismissed before the duration passes.
     * @type {?}
     * @private
     */
    NxMessageToastRef.prototype._durationTimeoutId;
    /**
     * @type {?}
     * @private
     */
    NxMessageToastRef.prototype._overlayRef;
}

/**
 * @fileoverview added by tsickle
 * Generated from: message/message-toast/message-toast.service.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Injection token that can be used to specify default message toast.
 * @type {?}
 */
const NX_MESSAGE_TOAST_DEFAULT_CONFIG = new InjectionToken('NX_MESSAGE_TOAST_DEFAULT_CONFIG');
/**
 * A service for dispatching and displaying toast messages.
 */
class NxMessageToastService {
    /**
     * @param {?} _overlay
     * @param {?} _injector
     * @param {?} _live
     * @param {?} _parentMessageToastService
     * @param {?} _defaultConfig
     */
    constructor(_overlay, _injector, _live, _parentMessageToastService, _defaultConfig) {
        this._overlay = _overlay;
        this._injector = _injector;
        this._live = _live;
        this._parentMessageToastService = _parentMessageToastService;
        this._defaultConfig = _defaultConfig;
        /**
         * Reference to the current message toast in the view *at this level* (in the Angular injector tree).
         * If there is a parent message toast service, all operations should delegate to that parent
         * via `_oldToastMessageRef`.
         */
        this._toastRefAtThisLevel = null;
    }
    /**
     * Reference to the currently opened message toastat *any* level.
     * @return {?}
     */
    get _oldToastMessageRef() {
        /** @type {?} */
        const parent = this._parentMessageToastService;
        return parent ? parent._oldToastMessageRef : this._toastRefAtThisLevel;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set _oldToastMessageRef(value) {
        if (this._parentMessageToastService) {
            this._parentMessageToastService._oldToastMessageRef = value;
        }
        else {
            this._toastRefAtThisLevel = value;
        }
    }
    /**
     * Creates and dispatches a message toastwith a custom text.
     *
     * @param {?} text Text to be used for the message toast.
     * @param {?=} config Extra configuration for the message toast.
     * @return {?}
     */
    open(text, config) {
        /** @type {?} */
        const currentConfig = Object.assign({}, new NxMessageToastConfig(), this._defaultConfig, config);
        /** @type {?} */
        const overlayRef = this._createOverlay(currentConfig);
        /** @type {?} */
        const injector = this._createInjector(currentConfig, new NxMessageToastData(text), this._injector);
        /** @type {?} */
        const componentPortal = new ComponentPortal(NxMessageToastComponent, undefined, injector);
        /** @type {?} */
        const componentRef = overlayRef.attach(componentPortal);
        /** @type {?} */
        const toastRef = new NxMessageToastRef(componentRef.instance, overlayRef);
        this._animateToast(toastRef, currentConfig);
        this._oldToastMessageRef = toastRef;
        return this._oldToastMessageRef;
    }
    /**
     * Creates and dispatches a message toastwith a custom template for the content.
     *
     * @param {?} template Template to be used for the message toast.
     * @param {?=} config Extra configuration for the message toast.
     * @return {?}
     */
    openFromTemplate(template, config) {
        /** @type {?} */
        const currentConfig = Object.assign({}, new NxMessageToastConfig(), this._defaultConfig, config);
        /** @type {?} */
        const overlayRef = this._createOverlay(currentConfig);
        /** @type {?} */
        const container = this._attachToastComponent(overlayRef, currentConfig);
        /** @type {?} */
        const toastRef = new NxMessageToastRef(container, overlayRef);
        /** @type {?} */
        const portal = new TemplatePortal(template, (/** @type {?} */ (null)), toastRef);
        container.attachTemplatePortal(portal);
        this._animateToast(toastRef, currentConfig);
        this._oldToastMessageRef = toastRef;
        return this._oldToastMessageRef;
    }
    // Attaches the message toastcontainer component to the overlay.
    /**
     * @private
     * @param {?} overlayRef
     * @param {?} config
     * @return {?}
     */
    _attachToastComponent(overlayRef, config) {
        /** @type {?} */
        const injector = this._createInjector(config, null, this._injector);
        /** @type {?} */
        const containerPortal = new ComponentPortal(NxMessageToastComponent, null, injector);
        /** @type {?} */
        const containerRef = overlayRef.attach(containerPortal);
        containerRef.instance.config = config;
        return containerRef.instance;
    }
    // Creates a new overlay and places it in the correct place.
    /**
     * @private
     * @param {?} config
     * @return {?}
     */
    _createOverlay(config) {
        /** @type {?} */
        const overlayConfig = new OverlayConfig();
        /** @type {?} */
        const positionStrategy = this._overlay.position().global();
        positionStrategy.bottom('0');
        positionStrategy.centerHorizontally();
        overlayConfig.positionStrategy = positionStrategy;
        return this._overlay.create(overlayConfig);
    }
    /**
     * Animates the old message toastout and the new one in.
     * @private
     * @param {?} toastRef
     * @param {?} config
     * @return {?}
     */
    _animateToast(toastRef, config) {
        // When the message toastis dismissed, clear the reference to it.
        toastRef.afterDismissed().subscribe((/**
         * @return {?}
         */
        () => {
            // Clear the message toastref if it hasn't already been replaced by a newer message toast.
            if (this._oldToastMessageRef === toastRef) {
                this._oldToastMessageRef = null;
            }
            if (config.announcementMessage) {
                this._live.clear();
            }
        }));
        if (this._oldToastMessageRef) {
            // If a message toastis opened, dismiss it and enter the
            // new message toastafter exit animation is complete.
            this._oldToastMessageRef.afterDismissed().subscribe((/**
             * @return {?}
             */
            () => {
                toastRef.toastInstance.enter();
            }));
            this._oldToastMessageRef.dismiss();
        }
        else {
            // If no message toastis in view, enter the message toast.
            toastRef.toastInstance.enter();
        }
        // If a message toastduration is provided, set up dismiss based on after the message toastis opened.
        if (config.duration && config.duration > 0) {
            toastRef.afterOpened().subscribe((/**
             * @return {?}
             */
            () => toastRef._dismissAfter((/** @type {?} */ (config.duration)))));
        }
        if (config.announcementMessage) {
            this._live.announce(config.announcementMessage, config.politeness);
        }
    }
    /**
     * @private
     * @param {?} config
     * @param {?} data
     * @param {?} injector
     * @return {?}
     */
    _createInjector(config, data, injector) {
        /** @type {?} */
        const tokens = new WeakMap();
        tokens.set(NxMessageToastConfig, config);
        tokens.set(NxMessageToastData, data);
        return new PortalInjector(injector, tokens);
    }
    /**
     * Dismisses the currently visible message toast.
     * @return {?}
     */
    dismiss() {
        if (this._oldToastMessageRef) {
            this._oldToastMessageRef.dismiss();
        }
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        if (this._toastRefAtThisLevel) {
            this._toastRefAtThisLevel.dismiss();
        }
    }
}
NxMessageToastService.decorators = [
    { type: Injectable, args: [{ providedIn: NxMessageModule },] }
];
/** @nocollapse */
NxMessageToastService.ctorParameters = () => [
    { type: Overlay },
    { type: Injector },
    { type: LiveAnnouncer },
    { type: NxMessageToastService, decorators: [{ type: Optional }, { type: SkipSelf }] },
    { type: NxMessageToastConfig, decorators: [{ type: Optional }, { type: Inject, args: [NX_MESSAGE_TOAST_DEFAULT_CONFIG,] }] }
];
/** @nocollapse */ NxMessageToastService.ngInjectableDef = ɵɵdefineInjectable({ factory: function NxMessageToastService_Factory() { return new NxMessageToastService(ɵɵinject(Overlay), ɵɵinject(INJECTOR), ɵɵinject(LiveAnnouncer), ɵɵinject(NxMessageToastService, 12), ɵɵinject(NX_MESSAGE_TOAST_DEFAULT_CONFIG, 8)); }, token: NxMessageToastService, providedIn: NxMessageModule });
if (false) {
    /**
     * Reference to the current message toast in the view *at this level* (in the Angular injector tree).
     * If there is a parent message toast service, all operations should delegate to that parent
     * via `_oldToastMessageRef`.
     * @type {?}
     * @private
     */
    NxMessageToastService.prototype._toastRefAtThisLevel;
    /**
     * @type {?}
     * @private
     */
    NxMessageToastService.prototype._overlay;
    /**
     * @type {?}
     * @private
     */
    NxMessageToastService.prototype._injector;
    /**
     * @type {?}
     * @private
     */
    NxMessageToastService.prototype._live;
    /**
     * @type {?}
     * @private
     */
    NxMessageToastService.prototype._parentMessageToastService;
    /**
     * @type {?}
     * @private
     */
    NxMessageToastService.prototype._defaultConfig;
}

/**
 * @fileoverview added by tsickle
 * Generated from: message/public-api.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * Generated from: message/index.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * Generated from: page-search/page-search.component.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class NxPageSearchComponent {
    /**
     * @param {?} _changeDetectorRef
     */
    constructor(_changeDetectorRef) {
        this._changeDetectorRef = _changeDetectorRef;
        /**
         * An event emitted when the user clicks the search button.
         */
        this.buttonClick = new EventEmitter();
        this._buttonLabel = null;
        this._hideSearchButton = false;
        this._buttonLayout = '12,12,12,2';
        this._contentLayout = null;
    }
    /**
     * Sets the text label of the button.
     * @param {?} value
     * @return {?}
     */
    set buttonLabel(value) {
        if (this._buttonLabel !== value) {
            this._buttonLabel = value;
            this._changeDetectorRef.markForCheck();
        }
    }
    /**
     * @return {?}
     */
    get buttonLabel() {
        return this._buttonLabel;
    }
    /**
     * Whether the search button should be hidden.
     * @param {?} value
     * @return {?}
     */
    set hideSearchButton(value) {
        this._hideSearchButton = coerceBooleanProperty(value);
        this._changeDetectorRef.markForCheck();
    }
    /**
     * @return {?}
     */
    get hideSearchButton() {
        return this._hideSearchButton;
    }
    /**
     * Layout of the search button inside of a NxGrid. Default: 12,12,12,2.
     * @param {?} value
     * @return {?}
     */
    set buttonLayout(value) {
        if (this._buttonLayout !== value) {
            this._buttonLayout = value;
            this._changeDetectorRef.markForCheck();
        }
    }
    /**
     * @return {?}
     */
    get buttonLayout() {
        return this._buttonLayout;
    }
    /**
     * Layout of the content area inside of a NxGrid. Default: 12,12,12,10 | 12 (if search button is hidden).
     * @param {?} value
     * @return {?}
     */
    set contentLayout(value) {
        if (this._contentLayout !== value) {
            this._contentLayout = value;
            this._changeDetectorRef.markForCheck();
        }
    }
    /**
     * @return {?}
     */
    get contentLayout() {
        if (this._contentLayout) {
            return this._contentLayout;
        }
        return !this.hideSearchButton ? '12,12,12,10' : '12';
    }
    /**
     * \@docs-private
     * @return {?}
     */
    onButtonClick() {
        this.buttonClick.emit();
    }
}
NxPageSearchComponent.decorators = [
    { type: Component, args: [{
                selector: 'nx-page-search',
                template: "<div class=\"nx-pagesearch\">\n  <div nxLayout=\"grid\">\n    <div nxRow>\n      <div [nxCol]=\"contentLayout\" class=\"nx-pagesearch--content\">\n        <ng-content></ng-content>\n      </div>\n      <div [nxCol]=\"buttonLayout\" *ngIf=\"!hideSearchButton\" class=\"nx-pagesearch__actions\">\n        <button nxButton=\"primary medium\" (click)=\"onButtonClick()\" type=\"button\">{{buttonLabel}}</button>\n      </div>\n    </div>\n  </div>\n</div>\n",
                changeDetection: ChangeDetectionStrategy.OnPush,
                host: {
                    '[attr.role]': '"search"'
                },
                styles: [".nx-pagesearch{padding:32px 0;background:#fff;background:var(--page-search-background-color,#fff);box-shadow:0 2px 4px rgba(65,65,65,.5);box-shadow:var(--page-search-box-shadow,0 2px 4px rgba(65,65,65,.5))}.nx-pagesearch ::ng-deep .nx-formfield__wrapper{padding-bottom:0}.nx-pagesearch ::ng-deep .c-input{height:auto;font-size:30px;font-size:var(--page-search-font-size,30px);line-height:36px;line-height:var(--page-search-line-height,36px);font-weight:600;font-weight:var(--page-search-font-weight,600);letter-spacing:.3px;letter-spacing:var(--page-search-letter-spacing,.3px)}.nx-pagesearch ::ng-deep .c-input.is-filled{font-weight:600}.nx-pagesearch ::ng-deep .c-input::-webkit-input-placeholder{font-weight:300}.nx-pagesearch ::ng-deep .c-input::-moz-placeholder{font-weight:300}.nx-pagesearch ::ng-deep .c-input:-ms-input-placeholder{font-weight:300}.nx-pagesearch ::ng-deep .c-input::-ms-input-placeholder{font-weight:300}.nx-pagesearch ::ng-deep .c-input::placeholder{font-weight:300}.nx-pagesearch ::ng-deep .nx-formfield__input-container{align-items:center}.nx-pagesearch ::ng-deep .nx-formfield__prefix,.nx-pagesearch ::ng-deep .nx-formfield__suffix{color:#007ab3;color:var(--page-search-icon-color,#007ab3)}.nx-pagesearch ::ng-deep .nx-formfield__suffix{cursor:pointer}.nx-pagesearch ::ng-deep button{margin:0}.nx-pagesearch ::ng-deep .nx-icon--auto{font-size:24px}.nx-pagesearch .nx-pagesearch__actions{display:flex;align-items:center;margin-top:0}@media (max-width:991px){.nx-pagesearch .nx-pagesearch__actions{margin-top:16px}}"]
            }] }
];
/** @nocollapse */
NxPageSearchComponent.ctorParameters = () => [
    { type: ChangeDetectorRef }
];
NxPageSearchComponent.propDecorators = {
    buttonClick: [{ type: Output, args: ['nxButtonClick',] }],
    buttonLabel: [{ type: Input, args: ['nxButtonLabel',] }],
    hideSearchButton: [{ type: Input, args: ['nxHideSearchButton',] }],
    buttonLayout: [{ type: Input, args: ['nxButtonLayout',] }],
    contentLayout: [{ type: Input, args: ['nxContentLayout',] }]
};
if (false) {
    /**
     * An event emitted when the user clicks the search button.
     * @type {?}
     */
    NxPageSearchComponent.prototype.buttonClick;
    /**
     * @type {?}
     * @private
     */
    NxPageSearchComponent.prototype._buttonLabel;
    /**
     * @type {?}
     * @private
     */
    NxPageSearchComponent.prototype._hideSearchButton;
    /**
     * @type {?}
     * @private
     */
    NxPageSearchComponent.prototype._buttonLayout;
    /**
     * @type {?}
     * @private
     */
    NxPageSearchComponent.prototype._contentLayout;
    /**
     * @type {?}
     * @private
     */
    NxPageSearchComponent.prototype._changeDetectorRef;
}

/**
 * @fileoverview added by tsickle
 * Generated from: page-search/page-search.module.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class NxPageSearchModule {
}
NxPageSearchModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    CommonModule,
                    NxAutocompleteModule$1,
                    NxFormfieldModule,
                    NxButtonModule$1,
                    NxGridModule
                ],
                declarations: [
                    NxPageSearchComponent
                ],
                exports: [
                    NxPageSearchComponent
                ]
            },] }
];

/**
 * @fileoverview added by tsickle
 * Generated from: page-search/public-api.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * Generated from: rating/rating.component.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class NxRatingComponent {
    /**
     * @param {?} _changeDetectorRef
     */
    constructor(_changeDetectorRef) {
        this._changeDetectorRef = _changeDetectorRef;
        this._value = 0;
        this._disabled = false;
        this._negative = false;
        this._startLabel = null;
        this._endLabel = null;
        this._ariaLabel = ['1/5', '2/5', '3/5', '4/5', '5/5'];
        /**
         * An event is dispatched each time when the rating changes.
         */
        this.valueChange = new EventEmitter();
        this.onTouchedCallback = (/**
         * @return {?}
         */
        () => { });
        this.onChangeCallback = (/**
         * @param {?} option
         * @return {?}
         */
        (option) => { });
    }
    /**
     * Sets the selected rating 1 - 5.
     * @param {?} newValue
     * @return {?}
     */
    set value(newValue) {
        this._value = coerceNumberProperty(newValue);
        this._changeDetectorRef.markForCheck();
    }
    /**
     * @return {?}
     */
    get value() {
        return this._value;
    }
    /**
     * Whether the rating component should be disabled.
     * @param {?} newValue
     * @return {?}
     */
    set disabled(newValue) {
        if (this._disabled === newValue) {
            return;
        }
        this._disabled = coerceBooleanProperty(newValue);
        this._changeDetectorRef.markForCheck();
    }
    /**
     * @return {?}
     */
    get disabled() {
        return this._disabled;
    }
    /**
     * Whether the negative colors be used.
     * @param {?} newValue
     * @return {?}
     */
    set negative(newValue) {
        if (this._negative === newValue) {
            return;
        }
        this._negative = coerceBooleanProperty(newValue);
        this._changeDetectorRef.markForCheck();
    }
    /**
     * @return {?}
     */
    get negative() {
        return this._negative;
    }
    /**
     * Sets the label painted at the start of the rating component.
     * @param {?} newValue
     * @return {?}
     */
    set startLabel(newValue) {
        this._startLabel = newValue;
        this._changeDetectorRef.markForCheck();
    }
    /**
     * @return {?}
     */
    get startLabel() {
        return this._startLabel;
    }
    /**
     * Sets the label painted at the end of the rating component.
     * @param {?} newValue
     * @return {?}
     */
    set endLabel(newValue) {
        this._endLabel = newValue;
        this._changeDetectorRef.markForCheck();
    }
    /**
     * @return {?}
     */
    get endLabel() {
        return this._endLabel;
    }
    /**
     * @param {?} newAriaLabels
     * @return {?}
     */
    set ariaLabel(newAriaLabels) {
        this._ariaLabel = newAriaLabels;
        this._changeDetectorRef.markForCheck();
    }
    /**
     * @return {?}
     */
    get ariaLabel() {
        return this._ariaLabel;
    }
    /**
     * Whether the given rating is selected.
     * @param {?} index
     * @return {?}
     */
    isSelected(index) {
        return index <= this.value;
    }
    /**
     * Allows to set the rating.
     * @param {?} value
     * @return {?}
     */
    setSelection(value) {
        if (!this.disabled) {
            this.value = value;
            this.valueChange.emit(value);
            this.onTouchedCallback();
            this.onChangeCallback(this.value);
        }
    }
    /**
     * \@docs-private
     * @param {?} event
     * @param {?} rating
     * @return {?}
     */
    handleKeyUp(event, rating) {
        /** @type {?} */
        const keyCode = event.keyCode;
        event.preventDefault();
        event.stopPropagation();
        if (keyCode === ENTER) {
            this.setSelection(rating);
        }
        if (keyCode === RIGHT_ARROW) {
            this.value = Math.min(this.value + 1, 5);
            /** @type {?} */
            const elementRef = this.icons.toArray()[this.value - 1];
            elementRef.nativeElement.focus();
        }
        if (keyCode === LEFT_ARROW) {
            this.value = Math.max(this.value - 1, 1);
            /** @type {?} */
            const elementRef = this.icons.toArray()[this.value - 1];
            elementRef.nativeElement.focus();
        }
    }
    /**
     * @param {?} value
     * @return {?}
     */
    writeValue(value) {
        this.value = value;
    }
    /**
     * @param {?} callback
     * @return {?}
     */
    registerOnChange(callback) {
        this.onChangeCallback = callback;
    }
    /**
     * @param {?} callback
     * @return {?}
     */
    registerOnTouched(callback) {
        this.onTouchedCallback = callback;
    }
    /**
     * @param {?} isDisabled
     * @return {?}
     */
    setDisabledState(isDisabled) {
        this.disabled = isDisabled;
    }
    /**
     * \@docs-private
     * @param {?} rating
     * @return {?}
     */
    getAriaLabel(rating) {
        return this.ariaLabel[rating - 1];
    }
    /**
     * \@docs-private
     * @param {?} rating
     * @return {?}
     */
    getIconName(rating) {
        return 'star' + ((!this.isSelected(rating)) ? '-o' : '');
    }
}
NxRatingComponent.decorators = [
    { type: Component, args: [{
                selector: 'nx-rating',
                template: "  <div class=\"nx-rating__container\" role=\"radiogroup\">\n    <nx-icon *ngFor=\"let rating of [1,2,3,4,5]\"\n      (click)=\"setSelection(rating)\"\n      (keyup)=\"handleKeyUp($event, rating)\"\n      role=\"radio\"\n      [attr.aria-label]=\"getAriaLabel(rating)\"\n      [attr.aria-checked]=\"isSelected(rating)\"\n      [tabindex]=\"disabled ? -1 : 0\"\n      class=\"nx-rating__icon\"\n      [name]=\"getIconName(rating)\"\n      size=\"m\">\n    </nx-icon>\n  </div>\n  <div class=\"nx-rating__label\" *ngIf=\"startLabel || endLabel\">\n    <span class=\"nx-rating__label--start\">{{startLabel}}</span>\n    <span class=\"nx-rating__label--end\">{{endLabel}}</span>\n  </div>\n",
                changeDetection: ChangeDetectionStrategy.OnPush,
                providers: [
                    {
                        provide: NG_VALUE_ACCESSOR,
                        useExisting: forwardRef((/**
                         * @return {?}
                         */
                        () => NxRatingComponent)),
                        multi: true
                    }
                ],
                host: {
                    '[class.nx-rating--negative]': 'negative',
                    '[class.nx-rating--disabled]': 'disabled',
                },
                styles: [":host{display:inline-block}:host(.nx-rating--negative) .nx-rating__icon,:host(.nx-rating--negative) .nx-rating__label{color:#fff}:host(.nx-rating--disabled){cursor:not-allowed;outline:0}:host(.nx-rating--disabled) .nx-rating__label{color:#c2c2c2;color:var(--rating-disabled-label-color,#c2c2c2)}:host(.nx-rating--disabled) .nx-rating__icon{color:#c2c2c2;color:var(--rating-disabled-icon-color,#c2c2c2);cursor:not-allowed}.nx-rating__container{display:flex}.nx-rating__label{display:flex;font-size:16px;font-size:var(--rating-label-font-size,16px);line-height:24px;line-height:var(--rating-label-line-height,24px);font-weight:400;font-weight:var(--rating-label-font-weight,400);letter-spacing:0;letter-spacing:var(--rating-label-letter-spacing,0);color:#414141;color:var(--rating-label-color,#414141)}.nx-rating__label--end{margin-left:auto}.nx-rating__icon{font-size:40px;font-size:var(--rating-icon-size,40px);color:#414141;color:var(--rating-icon-color,#414141);width:auto;background:0 0;border:none;margin-right:16px;cursor:pointer;outline:0}.nx-rating__icon:last-child{margin-right:0}:host-context([data-whatinput=keyboard]) .nx-rating__icon:focus{box-shadow:0 0 0 2px #fff,0 0 0 6px #009de6;box-shadow:var(--focus-box-shadow,0 0 0 2px #fff,0 0 0 6px #009de6);border-radius:4px}@media screen and (-ms-high-contrast:active){:host-context([data-whatinput=keyboard]) .nx-rating__icon:focus{box-shadow:0 0 0 2px background,0 0 0 6px windowText}.nx-rating__icon{color:buttonText}:host(.nx-rating--disabled) .nx-rating__icon,:host(.nx-rating--disabled) .nx-rating__label{color:GrayText}.nx-rating__label{-ms-high-contrast-adjust:none}}"]
            }] }
];
/** @nocollapse */
NxRatingComponent.ctorParameters = () => [
    { type: ChangeDetectorRef }
];
NxRatingComponent.propDecorators = {
    value: [{ type: Input, args: ['nxValue',] }],
    disabled: [{ type: Input, args: ['nxDisabled',] }],
    negative: [{ type: Input, args: ['nxNegative',] }],
    startLabel: [{ type: Input, args: ['nxStartLabel',] }],
    endLabel: [{ type: Input, args: ['nxEndLabel',] }],
    ariaLabel: [{ type: Input, args: ['nxAriaLabel',] }],
    valueChange: [{ type: Output, args: ['nxValueChange',] }],
    icons: [{ type: ViewChildren, args: [NxIconComponent, { read: ElementRef },] }]
};
if (false) {
    /**
     * @type {?}
     * @private
     */
    NxRatingComponent.prototype._value;
    /**
     * @type {?}
     * @private
     */
    NxRatingComponent.prototype._disabled;
    /**
     * @type {?}
     * @private
     */
    NxRatingComponent.prototype._negative;
    /**
     * @type {?}
     * @private
     */
    NxRatingComponent.prototype._startLabel;
    /**
     * @type {?}
     * @private
     */
    NxRatingComponent.prototype._endLabel;
    /**
     * @type {?}
     * @private
     */
    NxRatingComponent.prototype._ariaLabel;
    /**
     * An event is dispatched each time when the rating changes.
     * @type {?}
     */
    NxRatingComponent.prototype.valueChange;
    /**
     * \@docs-private
     * @type {?}
     */
    NxRatingComponent.prototype.icons;
    /**
     * @type {?}
     * @private
     */
    NxRatingComponent.prototype.onTouchedCallback;
    /**
     * @type {?}
     * @private
     */
    NxRatingComponent.prototype.onChangeCallback;
    /**
     * @type {?}
     * @private
     */
    NxRatingComponent.prototype._changeDetectorRef;
}

/**
 * @fileoverview added by tsickle
 * Generated from: rating/rating.module.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class NxRatingModule {
}
NxRatingModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    CommonModule,
                    NxIconModule
                ],
                declarations: [
                    NxRatingComponent
                ],
                exports: [
                    NxRatingComponent
                ]
            },] }
];

/**
 * @fileoverview added by tsickle
 * Generated from: rating/public-api.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * Generated from: rating/index.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * Generated from: number-stepper/number-stepper-intl.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class NxNumberStepperIntl {
    constructor() {
        /**
         * Stream that emits whenever the labels here are changed. Use this to notify
         * components if the labels have changed after initialization.
         */
        this.changes = new Subject();
        /**
         * The aria label for the decrement '-' button
         */
        this.decrementAriaLabel = 'Decrement';
        /**
         * The aria label for the increment '+' button
         */
        this.incrementAriaLabel = 'Increment';
    }
}
NxNumberStepperIntl.decorators = [
    { type: Injectable }
];
if (false) {
    /**
     * Stream that emits whenever the labels here are changed. Use this to notify
     * components if the labels have changed after initialization.
     * @type {?}
     */
    NxNumberStepperIntl.prototype.changes;
    /**
     * The aria label for the decrement '-' button
     * @type {?}
     */
    NxNumberStepperIntl.prototype.decrementAriaLabel;
    /**
     * The aria label for the increment '+' button
     * @type {?}
     */
    NxNumberStepperIntl.prototype.incrementAriaLabel;
}

/**
 * @fileoverview added by tsickle
 * Generated from: number-stepper/auto-resize.directive.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * \@docs-private
 */
class NxAutoResizeDirective {
    /**
     * @param {?} _element
     * @param {?} _renderer
     * @param {?} _cdr
     */
    constructor(_element, _renderer, _cdr) {
        this._element = _element;
        this._renderer = _renderer;
        this._cdr = _cdr;
        this._resize = true;
        this.updateInputWidth = this.updateInputWidth.bind(this);
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set resize(value) {
        this._resize = coerceBooleanProperty(value);
        if (this._resize) {
            this._addEventListener();
            this.updateInputWidth();
        }
        else {
            this._removeEventListener();
        }
    }
    /**
     * @return {?}
     */
    get resize() {
        return this._resize;
    }
    /**
     * @return {?}
     */
    ngAfterViewInit() {
        if (this.resize) {
            this._addEventListener();
        }
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this._removeEventListener();
    }
    /**
     * @return {?}
     */
    updateInputWidth() {
        /** @type {?} */
        const measureCanvas = this._renderer.createElement('canvas');
        /** @type {?} */
        const ctx = measureCanvas.getContext('2d');
        /** @type {?} */
        const styles = window.getComputedStyle(this._element.nativeElement);
        ctx.font = getFontShorthand(styles);
        /** @type {?} */
        const metrics = ctx.measureText(this._element.nativeElement.value);
        /** @type {?} */
        const padding = this.sumStyles(styles.paddingLeft, styles.paddingRight);
        /** @type {?} */
        const border = this.sumStyles(styles.borderLeftWidth, styles.borderRightWidth);
        // the pixels are needed, because despite the correct calculation the last pixels of a number are always cut
        /** @type {?} */
        const newWidth = metrics.width + padding + border + 16;
        // Limit to own given minimal width
        /** @type {?} */
        const parsed = parseFloat(styles.minWidth);
        this.width = Math.max(Number.isNaN(parsed) ? 0 : parsed, newWidth);
        // needed when the outer component is onPush
        this._cdr.markForCheck();
    }
    /**
     * @return {?}
     */
    _addEventListener() {
        this._element.nativeElement.addEventListener('input', this.updateInputWidth, true);
        this._element.nativeElement.addEventListener('change', this.updateInputWidth, true);
    }
    /**
     * @return {?}
     */
    _removeEventListener() {
        this._element.nativeElement.removeEventListener('input', this.updateInputWidth, true);
        this._element.nativeElement.removeEventListener('change', this.updateInputWidth, true);
    }
    /**
     * @param {?} left
     * @param {?} right
     * @return {?}
     */
    sumStyles(left, right) {
        left = parseInt(left, 10);
        right = parseInt(right, 10);
        left = Number.isNaN(left) ? 0 : left;
        right = Number.isNaN(right) ? 0 : right;
        return left + right;
    }
}
NxAutoResizeDirective.decorators = [
    { type: Directive, args: [{
                selector: 'input[nxAutoResize]'
            },] }
];
/** @nocollapse */
NxAutoResizeDirective.ctorParameters = () => [
    { type: ElementRef },
    { type: Renderer2 },
    { type: ChangeDetectorRef }
];
NxAutoResizeDirective.propDecorators = {
    width: [{ type: HostBinding, args: ['style.width.px',] }],
    resize: [{ type: Input, args: ['nxAutoResize',] }]
};
if (false) {
    /** @type {?} */
    NxAutoResizeDirective.prototype.width;
    /**
     * @type {?}
     * @private
     */
    NxAutoResizeDirective.prototype._resize;
    /**
     * @type {?}
     * @private
     */
    NxAutoResizeDirective.prototype._element;
    /**
     * @type {?}
     * @private
     */
    NxAutoResizeDirective.prototype._renderer;
    /**
     * @type {?}
     * @private
     */
    NxAutoResizeDirective.prototype._cdr;
}

/**
 * @fileoverview added by tsickle
 * Generated from: number-stepper/number-stepper.component.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const SIZE_MAPPING = {
    big: 'nx-stepper--big',
    normal: ''
};
/** @type {?} */
const DEFAULT_CLASSES$1 = ['nx-stepper'];
/** @type {?} */
const INPUT_CLASSES = ['nx-stepper__input'];
/** @type {?} */
const ALLOWED_CHARACTERS = new RegExp(/^-?[0-9]\d*(\.\d+)?$/g);
/** @type {?} */
const CUSTOM_VALUE_ACCESSOR = {
    provide: NG_VALUE_ACCESSOR,
    useExisting: forwardRef((/**
     * @return {?}
     */
    () => NxNumberStepperComponent)),
    multi: true
};
/** @type {?} */
const CUSTOM_VALIDATOR = {
    provide: NG_VALIDATORS,
    useExisting: forwardRef((/**
     * @return {?}
     */
    () => NxNumberStepperComponent)),
    multi: true
};
/** @type {?} */
let nextUniqueId = 0;
class NxNumberStepperComponent extends MappedStyles$1 {
    /**
     * @param {?} _changeDetectorRef
     * @param {?} _renderer
     * @param {?} _elementRef
     * @param {?} _intl
     */
    constructor(_changeDetectorRef, _renderer, _elementRef, _intl) {
        super(SIZE_MAPPING, DEFAULT_CLASSES$1, _elementRef, _renderer);
        this._changeDetectorRef = _changeDetectorRef;
        this._intl = _intl;
        this._step = 1;
        this._min = 0;
        this._max = 100;
        this._value = 0;
        this._label = null;
        this._resize = false;
        this._negative = false;
        this._leadingZero = true;
        /**
         * \@docs-private
         */
        this.inputClassNames = mapClassNames('regular', INPUT_CLASSES);
        /**
         * \@docs-private
         */
        this.inputId = `nx-number-stepper-${nextUniqueId++}`;
        /**
         * \@docs-private
         */
        this.ariaDescribedBy = null;
        /**
         * An event emitted on value change.
         */
        this.valueChange = new EventEmitter();
        this.onChangeCallback = (/**
         * @param {?} _
         * @return {?}
         */
        (_) => { });
        /**
         * \@docs-private
         */
        this.onTouchedCallback = (/**
         * @return {?}
         */
        () => { });
        this._intlSubscription = this._intl.changes.subscribe((/**
         * @return {?}
         */
        () => this._changeDetectorRef.markForCheck()));
    }
    /**
     * Whether the input should be resized. Default: false
     * @param {?} value
     * @return {?}
     */
    set resize(value) {
        this._resize = coerceBooleanProperty(value);
        this._changeDetectorRef.markForCheck();
    }
    /**
     * @return {?}
     */
    get resize() {
        return this._resize;
    }
    /**
     * @return {?}
     */
    get label() {
        return this._label;
    }
    /**
     * Defines the the label shown above the stepper input.
     * @param {?} value
     * @return {?}
     */
    set label(value) {
        if (this._label !== value) {
            this._label = value;
            this._changeDetectorRef.markForCheck();
        }
    }
    /**
     * Sets the step size. Default: 1
     * @param {?} value
     * @return {?}
     */
    set step(value) {
        // only internal changes no need to call markForCheck
        this._step = Number(value);
    }
    /**
     * @return {?}
     */
    get step() {
        return this._step;
    }
    /**
     * Sets the minimum accepted number. Default: 0
     * @param {?} value
     * @return {?}
     */
    set min(value) {
        this._min = Number(value);
    }
    /**
     * @return {?}
     */
    get min() {
        return this._min;
    }
    /**
     * Sets the maximum accepted number. Default: 100
     * @param {?} value
     * @return {?}
     */
    set max(value) {
        this._max = Number(value);
    }
    /**
     * @return {?}
     */
    get max() {
        return this._max;
    }
    /**
     * @return {?}
     */
    get value() {
        return this._value;
    }
    /**
     * Sets the value of the number-stepper.
     * @param {?} value
     * @return {?}
     */
    set value(value) {
        this._value = value;
        if (this._value !== null) {
            this.setInputValue(this._value);
        }
        else {
            this.setInputValue(0);
        }
        this._changeDetectorRef.markForCheck();
    }
    /**
     * Whether the negative set of styling should be used.
     * @param {?} value
     * @return {?}
     */
    set negative(value) {
        if (this._negative !== value) {
            this._negative = coerceBooleanProperty(value);
            this._changeDetectorRef.markForCheck();
        }
    }
    /**
     * @return {?}
     */
    get negative() {
        return this._negative;
    }
    /**
     * Whether the number stepper value should have a leading zero.
     *
     * Default value is true.
     * @param {?} value
     * @return {?}
     */
    set leadingZero(value) {
        if (this._leadingZero !== value) {
            this._leadingZero = coerceBooleanProperty(value);
            this.setInputValue(this.value);
            this._changeDetectorRef.markForCheck();
        }
    }
    /**
     * @return {?}
     */
    get leadingZero() {
        return this._leadingZero;
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.setInputValue(this._value);
    }
    /**
     * @return {?}
     */
    ngAfterViewInit() {
        if (this.ngContentWrapper) {
            this.ariaDescribedBy = this.ngContentWrapper.nativeElement.children.length > 0 ? `label-for-${this.inputId}` : null;
        }
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this._intlSubscription.unsubscribe();
    }
    /**
     * \@docs-private
     * @param {?} value
     * @return {?}
     */
    setInputValue(value) {
        if (this.leadingZero) {
            this.numberInputValue = pad(value.toString(), 2);
        }
        else {
            this.numberInputValue = value.toString();
        }
        // use timeout to get the current value of numberInputValue
        setTimeout((/**
         * @return {?}
         */
        () => {
            this.triggerResize();
        }));
    }
    /* ControlValueAccessor Implementations */
    /**
     * @param {?} value
     * @return {?}
     */
    writeValue(value) {
        this.value = value;
    }
    /**
     * @param {?} onChange
     * @return {?}
     */
    registerOnChange(onChange) {
        this.onChangeCallback = onChange;
    }
    /**
     * @param {?} onTouched
     * @return {?}
     */
    registerOnTouched(onTouched) {
        this.onTouchedCallback = onTouched;
    }
    /**
     * \@docs-private
     * @param {?} event
     * @return {?}
     */
    onInputChange(event) {
        if (!this.validateUserInput(event.target.value)) {
            this._value = null;
        }
        else {
            this._value = Number(event.target.value);
        }
        // setInputValue() should be called so that numberInputValue is updated with the user input
        if (this._value !== null) {
            this.setInputValue(this._value);
        }
        this.valueChange.emit(this._value);
        this.onChangeCallback(this._value);
    }
    /**
     * \@docs-private
     * @param {?} input
     * @return {?}
     */
    validateUserInput(input) {
        return !!input.match(ALLOWED_CHARACTERS);
    }
    /**
     * \@docs-private
     * @return {?}
     */
    incrementOnClick() {
        this._increment();
        this.onTouchedCallback();
    }
    /**
     * \@docs-private
     * @return {?}
     */
    incrementOnKey() {
        this._increment();
    }
    /**
     * \@docs-private
     * @return {?}
     */
    _increment() {
        /** @type {?} */
        let newValue;
        if (this.isBetweenLimits(this._value)) {
            newValue = this.getNextGreaterValue(this._value);
        }
        else {
            newValue = this.enforceLimits(this._value);
        }
        this.value = newValue;
        this.valueChange.emit(this._value);
        this.onChangeCallback(this._value);
    }
    /**
     * \@docs-private
     * @return {?}
     */
    triggerResize() {
        if (this.resize) {
            this.autoResize.updateInputWidth();
            this._changeDetectorRef.markForCheck();
        }
    }
    /**
     * \@docs-private
     * @return {?}
     */
    decrementOnClick() {
        this._decrement();
        this.onTouchedCallback();
    }
    /**
     * \@docs-private
     * @return {?}
     */
    decrementOnKey() {
        this._decrement();
    }
    /**
     * \@docs-private
     * @return {?}
     */
    _decrement() {
        /** @type {?} */
        let newValue;
        if (this.isBetweenLimits(this._value)) {
            newValue = this.getNextLowerValue(this._value);
        }
        else {
            newValue = this.enforceLimits(this._value);
        }
        this.value = newValue;
        this.valueChange.emit(this._value);
        this.onChangeCallback(this._value);
    }
    /**
     * \@docs-private
     * @param {?} value
     * @return {?}
     */
    enforceLimits(value) {
        if (value > this._max) {
            return this._max;
        }
        else if (value < this._min) {
            return this._min;
        }
        return value;
    }
    /**
     * \@docs-private
     * @param {?} start
     * @return {?}
     */
    getNextLowerValue(start) {
        // if there is an invalid input start is null
        if (!start) {
            start = 0;
        }
        /** @type {?} */
        let next;
        if (this.isValidStep(start)) {
            next = (new Decimal(start).minus(new Decimal(this._step))).toNumber();
        }
        else {
            next = new Decimal(start).toNearest(this._step, Decimal.ROUND_DOWN).toNumber();
        }
        return this.enforceLimits(next);
    }
    /**
     * \@docs-private
     * @param {?} start
     * @return {?}
     */
    getNextGreaterValue(start) {
        /** @type {?} */
        let next;
        if (!start) {
            start = 0;
        }
        if (this.isValidStep(start)) {
            next = (new Decimal(start).plus(new Decimal(this._step))).toNumber();
        }
        else {
            next = new Decimal(start).toNearest(this._step, Decimal.ROUND_UP).toNumber();
        }
        return this.enforceLimits(next);
    }
    /**
     * \@docs-private
     * @param {?} value
     * @return {?}
     */
    isBetweenLimits(value) {
        return value <= this._max && value >= this._min;
    }
    /**
     * \@docs-private
     * @return {?}
     */
    isMinimum() {
        return this._value === this._min;
    }
    /**
     * \@docs-private
     * @return {?}
     */
    isMaximum() {
        return this._value === this._max;
    }
    /**
     * \@docs-private
     * @param {?} value
     * @return {?}
     */
    isValidStep(value) {
        if (value === null) {
            value = new Decimal(0);
        }
        /** @type {?} */
        const min = new Decimal(this._min);
        /** @type {?} */
        const valueDec = new Decimal(value);
        /** @type {?} */
        const checkValue = (min.minus(valueDec)).mod(new Decimal(this._step)).toNumber();
        if (this.isBetweenLimits(value) && ((this.isMinimum() || this.isMaximum()) ||
            checkValue === 0)) {
            return true;
        }
        return false;
    }
    /**
     * \@docs-private
     * @param {?} value
     * @return {?}
     */
    userInputToNumber(value) {
        /** @type {?} */
        const current = value === '' ? 0 : value;
        return parseInt(current, 10);
    }
    /**
     * @return {?}
     */
    _validateFn() {
        // the manual user input must match min + n * step, e.g. minimum 1 step 2: 1, 3, 5, 7 etc.
        if (!this.isValidStep(this._value)) {
            return { nxNumberStepperStepError: 'Value is not a valid step' };
        }
        else if (this._value === null) {
            return { nxNumberStepperFormatError: 'Not a valid number' };
        }
        return null;
    }
    /**
     * \@docs-private
     * @param {?} c
     * @return {?}
     */
    validate(c) {
        return this._validateFn();
    }
    /**
     * @return {?}
     */
    get _buttonType() {
        return 'secondary' + (this.negative ? ' negative' : '');
    }
}
NxNumberStepperComponent.decorators = [
    { type: Component, args: [{
                selector: 'nx-number-stepper',
                template: "<div *ngIf=\"label\" class=\"nx-stepper__label\">\n  <label [for]=\"inputId\">\n    {{label}}\n  </label>\n</div>\n<div class=\"nx-stepper__label\" #customLabel *ngIf=\"!label\" [id]=\"ariaDescribedBy\">\n  <ng-content></ng-content>\n</div>\n<div class=\"nx-stepper__input-container\">\n  <button\n    [attr.aria-label]=\"_intl.decrementAriaLabel\"\n    [nxButton]=\"_buttonType\"\n    class=\"nx-stepper__down nx-stepper__control\"\n    (click)=\"decrementOnClick()\"\n    [disabled]=\"value <= min\"\n    type=\"button\">\n    <nx-icon name=\"minus\" size=\"s\"></nx-icon>\n  </button>\n  <div class=\"nx-stepper__input-wrapper\">\n    <div class=\"nx-stepper__inner-wrapper\">\n        <ng-content select=\"nx-number-stepper-prefix\"></ng-content>\n\n        <input [nxAutoResize]=\"resize\" [value]=\"numberInputValue\"\n        [attr.aria-describedby]=\"ariaDescribedBy\"\n        [id]=\"inputId\" [ngClass]=\"inputClassNames\"\n        (input)=\"onInputChange($event)\"\n        (keydown.arrowup)=\"incrementOnKey()\"\n        (keydown.arrowdown)=\"decrementOnKey()\"\n        (blur)=\"onTouchedCallback()\"/>\n\n        <ng-content select=\"nx-number-stepper-suffix\"></ng-content>\n    </div>\n    <div class=\"nx-stepper__input-underline\"></div>\n  </div>\n\n  <button\n    [attr.aria-label]=\"_intl.incrementAriaLabel\"\n    [nxButton]=\"_buttonType\"\n    class=\"nx-stepper__up nx-stepper__control\"\n    (click)=\"incrementOnClick()\"\n    [disabled]=\"value >= max\"\n    type=\"button\">\n    <nx-icon name=\"plus\" size=\"s\"></nx-icon>\n  </button>\n</div>\n",
                changeDetection: ChangeDetectionStrategy.OnPush,
                inputs: ['classNames: nxSize'],
                host: {
                    '[class.is-negative]': 'negative'
                },
                providers: [CUSTOM_VALUE_ACCESSOR, CUSTOM_VALIDATOR],
                styles: [":host{display:block}:host input{padding:0}.nx-stepper__input-container{align-items:flex-end;display:flex;margin-top:12px}.nx-stepper__label{display:flex;font-size:20px;font-size:var(--number-stepper-label-font-size,20px);line-height:28px;line-height:var(--number-stepper-label-line-height,28px);font-weight:400;font-weight:var(--number-stepper-label-font-weight,400);letter-spacing:.2px;letter-spacing:var(--number-stepper-label-letter-spacing,.2px)}.nx-stepper__control{width:32px;height:32px;min-height:32px;font-size:24px;margin:0;padding:0}.nx-stepper__input{width:56px;min-width:56px}.nx-stepper__input,::ng-deep .nx-stepper__prefix,::ng-deep .nx-stepper__suffix{font-size:20px;font-size:var(--number-stepper-small-font-size,20px);line-height:28px;line-height:var(--number-stepper-small-line-height,28px);font-weight:400;font-weight:var(--number-stepper-small-font-weight,400);letter-spacing:.2px;letter-spacing:var(--number-stepper-small-letter-spacing,.2px);color:#414141;color:var(--number-stepper-color,#414141);background:0 0;outline:0;border:0;text-align:center}::ng-deep .nx-stepper__suffix{margin-left:4px}::ng-deep .nx-stepper__prefix{margin-right:4px}.nx-stepper__input-wrapper{display:flex;align-items:center;flex-direction:column;margin:0 16px}.nx-stepper__inner-wrapper{height:28px;display:flex;align-items:baseline}.nx-stepper__input-underline{width:100%;margin-top:2px;height:2px;background:#414141;background:var(--number-stepper-underline-color,#414141)}:host.nx-stepper--big .nx-stepper__control{width:72px;min-height:48px;margin-bottom:0}:host.nx-stepper--big .nx-stepper__input{width:72px;min-width:72px}:host.nx-stepper--big .nx-stepper__input,:host.nx-stepper--big ::ng-deep .nx-stepper__prefix,:host.nx-stepper--big ::ng-deep .nx-stepper__suffix{font-size:40px;font-size:var(--number-stepper-large-font-size,40px);line-height:48px;line-height:var(--number-stepper-large-line-height,48px);font-weight:400;font-weight:var(--number-stepper-large-font-weight,400);letter-spacing:.3px;letter-spacing:var(--number-stepper-large-letter-spacing,.3px);height:48px;padding:0;margin-bottom:0}:host.nx-stepper--big .nx-stepper__input-wrapper{margin:0 24px}:host.nx-stepper--big .nx-stepper__input-underline{margin-top:-2px}:host.nx-stepper--big .nx-stepper__inner-wrapper{height:48px}:host.is-negative .nx-stepper__label,:host.is-negative ::ng-deep .nx-stepper__prefix,:host.is-negative ::ng-deep .nx-stepper__suffix{color:#fff}:host.is-negative .nx-stepper__input{color:#fff}:host.is-negative .nx-stepper__input-underline{background:#fff}@media screen and (-ms-high-contrast:active){button.nx-stepper__control:disabled{border-color:GrayText;color:GrayText;opacity:1}.nx-stepper__input{color:buttonText}::ng-deep .nx-stepper__prefix,::ng-deep .nx-stepper__suffix,:host.nx-stepper--big ::ng-deep .nx-stepper__prefix,:host.nx-stepper--big ::ng-deep .nx-stepper__suffix{-ms-high-contrast-adjust:none;color:windowText}.nx-stepper__inner-wrapper{background:buttonFace}.nx-stepper__input-underline{background:buttonText}}"]
            }] }
];
/** @nocollapse */
NxNumberStepperComponent.ctorParameters = () => [
    { type: ChangeDetectorRef },
    { type: Renderer2 },
    { type: ElementRef },
    { type: NxNumberStepperIntl }
];
NxNumberStepperComponent.propDecorators = {
    ngContentWrapper: [{ type: ViewChild, args: ['customLabel', { static: false },] }],
    autoResize: [{ type: ViewChild, args: [NxAutoResizeDirective, { static: true },] }],
    valueChange: [{ type: Output, args: ['nxValueChange',] }],
    resize: [{ type: Input, args: ['nxResize',] }],
    label: [{ type: Input, args: ['nxLabel',] }],
    step: [{ type: Input, args: ['nxStep',] }],
    min: [{ type: Input, args: ['nxMin',] }],
    max: [{ type: Input, args: ['nxMax',] }],
    value: [{ type: Input, args: ['nxValue',] }],
    negative: [{ type: Input }],
    leadingZero: [{ type: Input }]
};
if (false) {
    /**
     * @type {?}
     * @private
     */
    NxNumberStepperComponent.prototype._step;
    /**
     * @type {?}
     * @private
     */
    NxNumberStepperComponent.prototype._min;
    /**
     * @type {?}
     * @private
     */
    NxNumberStepperComponent.prototype._max;
    /**
     * @type {?}
     * @private
     */
    NxNumberStepperComponent.prototype._value;
    /**
     * @type {?}
     * @private
     */
    NxNumberStepperComponent.prototype._label;
    /**
     * @type {?}
     * @private
     */
    NxNumberStepperComponent.prototype._resize;
    /**
     * @type {?}
     * @private
     */
    NxNumberStepperComponent.prototype._intlSubscription;
    /**
     * @type {?}
     * @private
     */
    NxNumberStepperComponent.prototype._negative;
    /**
     * @type {?}
     * @private
     */
    NxNumberStepperComponent.prototype._leadingZero;
    /**
     * \@docs-private
     * @type {?}
     */
    NxNumberStepperComponent.prototype.numberInputValue;
    /**
     * Defines the size of the number stepper.
     *
     * Values: big | normal. Default: normal
     * @type {?}
     */
    NxNumberStepperComponent.prototype.classNames;
    /**
     * \@docs-private
     * @type {?}
     */
    NxNumberStepperComponent.prototype.inputClassNames;
    /**
     * \@docs-private
     * @type {?}
     */
    NxNumberStepperComponent.prototype.inputId;
    /**
     * \@docs-private
     * @type {?}
     */
    NxNumberStepperComponent.prototype.inputWidth;
    /**
     * \@docs-private
     * @type {?}
     */
    NxNumberStepperComponent.prototype.ariaDescribedBy;
    /**
     * \@docs-private
     * @type {?}
     */
    NxNumberStepperComponent.prototype.ngContentWrapper;
    /**
     * \@docs-private
     * @type {?}
     */
    NxNumberStepperComponent.prototype.autoResize;
    /**
     * An event emitted on value change.
     * @type {?}
     */
    NxNumberStepperComponent.prototype.valueChange;
    /**
     * @type {?}
     * @private
     */
    NxNumberStepperComponent.prototype.onChangeCallback;
    /**
     * \@docs-private
     * @type {?}
     */
    NxNumberStepperComponent.prototype.onTouchedCallback;
    /**
     * @type {?}
     * @private
     */
    NxNumberStepperComponent.prototype._changeDetectorRef;
    /** @type {?} */
    NxNumberStepperComponent.prototype._intl;
}

/**
 * @fileoverview added by tsickle
 * Generated from: number-stepper/number-stepper-prefix.directive.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Directive used to pass a suffix to the number stepper.
 */
class NxNumberStepperPrefixDirective {
}
NxNumberStepperPrefixDirective.decorators = [
    { type: Directive, args: [{
                // tslint:disable-next-line:directive-selector
                selector: 'nx-number-stepper-prefix',
                host: {
                    'class': 'nx-stepper__prefix'
                }
            },] }
];

/**
 * @fileoverview added by tsickle
 * Generated from: number-stepper/number-stepper-suffix.directive.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Directive used to pass a suffix to the number stepper.
 */
class NxNumberStepperSuffixDirective {
}
NxNumberStepperSuffixDirective.decorators = [
    { type: Directive, args: [{
                // tslint:disable-next-line:directive-selector
                selector: 'nx-number-stepper-suffix',
                host: {
                    'class': 'nx-stepper__suffix'
                }
            },] }
];

/**
 * @fileoverview added by tsickle
 * Generated from: number-stepper/number-stepper.module.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class NxNumberStepperModule {
}
NxNumberStepperModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    NxInputModule,
                    FormsModule,
                    NxIconModule,
                    NxButtonModule$1,
                    CommonModule
                ],
                exports: [
                    NxNumberStepperComponent,
                    NxAutoResizeDirective,
                    NxNumberStepperPrefixDirective,
                    NxNumberStepperSuffixDirective
                ],
                declarations: [
                    NxNumberStepperComponent,
                    NxAutoResizeDirective,
                    NxNumberStepperPrefixDirective,
                    NxNumberStepperSuffixDirective
                ],
                providers: [NxNumberStepperIntl],
            },] }
];

/**
 * @fileoverview added by tsickle
 * Generated from: number-stepper/public-api.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * Generated from: pagination/pagination-texts.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Interface for providing custom labels in a simple pagination.
 * With an implementation you can localize your pagination with the NX_PAGINATION_TEXTS injection token.
 * @record
 */
function IPaginationTexts() { }
if (false) {
    /**
     * Label that should replace 'previous'.
     * @type {?}
     */
    IPaginationTexts.prototype.previous;
    /**
     * Label that should replace 'next'.
     * @type {?}
     */
    IPaginationTexts.prototype.next;
    /**
     * Label that should replace 'first'.
     *
     * Optional attribute needed only for the advanced pagination.
     * @type {?|undefined}
     */
    IPaginationTexts.prototype.first;
    /**
     * Label that should replace 'last'.
     *
     * Optional attribute needed only for the advanced pagination.
     * @type {?|undefined}
     */
    IPaginationTexts.prototype.last;
    /**
     * Label that should replace 'of'.
     * @type {?}
     */
    IPaginationTexts.prototype.ofLabel;
    /**
     * Label that should replace the aria label.
     * @type {?}
     */
    IPaginationTexts.prototype.ariaLabel;
}
/** @type {?} */
const DefaultPaginationTexts = {
    previous: 'Previous',
    next: 'Next',
    first: 'First',
    last: 'Last',
    ofLabel: 'of',
    ariaLabel: 'Please select your page'
};
/**
 * InjectionToken for pagination that can be used to override default locale code.
 * @type {?}
 */
const NX_PAGINATION_TEXTS = new InjectionToken('nx-pagination-texts');

/**
 * @fileoverview added by tsickle
 * Generated from: pagination/pagination-utils.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * \@docs-private
 */
class NxPaginationUtils {
    constructor() {
        this._pagesMobile = 3;
        this._elipsisText = '...';
        this._classExpanded = 'expanded-view';
    }
    /**
     * @param {?} currentPage
     * @param {?} totalPages
     * @return {?}
     */
    getPages(currentPage, totalPages) {
        /** @type {?} */
        let pages = [];
        /** @type {?} */
        let start = [];
        /** @type {?} */
        let middle = [];
        /** @type {?} */
        let end = [];
        // First array -> start
        start = this.getStartArray(currentPage, totalPages);
        // Second array -> middle
        middle = this.getMiddleArray(currentPage, totalPages);
        // Third array -> end
        end = this.getEndArray(currentPage, totalPages);
        pages = [...start, ...middle, ...end];
        return pages;
    }
    /**
     * @param {?} currentPage
     * @param {?} totalPages
     * @return {?}
     */
    getMiddleArray(currentPage, totalPages) {
        /** @type {?} */
        let pageNumber = currentPage < 6 ? 4 : currentPage - 1;
        /** @type {?} */
        const middle = [];
        while (middle.length < 3 &&
            pageNumber >= 2 &&
            pageNumber <= totalPages - 3 &&
            (pageNumber <= currentPage + 1 && pageNumber >= currentPage - 1)) {
            middle.push(this.createPaginationItem(pageNumber, pageNumber));
            pageNumber++;
        }
        return middle;
    }
    /**
     * @param {?} currentPage
     * @param {?} totalPages
     * @return {?}
     */
    getEndArray(currentPage, totalPages) {
        /** @type {?} */
        const end = [];
        /** @type {?} */
        let currentItemToShow = totalPages <= 3 ? totalPages + 1 :
            totalPages <= 6 ? totalPages - (totalPages - 4) : totalPages - 2;
        /** @type {?} */
        const showEllipsis = currentPage < totalPages - 4;
        while (currentItemToShow <= totalPages) {
            /** @type {?} */
            const endItem = end.length === 0 && showEllipsis ?
                this.createPaginationItem(this._elipsisText, currentItemToShow, true) :
                this.createPaginationItem(currentItemToShow, currentItemToShow, true);
            end.push(endItem);
            currentItemToShow++;
        }
        return end;
    }
    /**
     * @param {?} currentPage
     * @param {?} totalPages
     * @return {?}
     */
    getStartArray(currentPage, totalPages) {
        /** @type {?} */
        let counterPages = 0;
        /** @type {?} */
        const start = [];
        /** @type {?} */
        const maxSizeArray = 3;
        while (counterPages < maxSizeArray && counterPages < totalPages) {
            /** @type {?} */
            const startItem = counterPages === 2 && currentPage > 5 ?
                this.createPaginationItem(this._elipsisText, counterPages, true) :
                this.createPaginationItem(counterPages + 1, counterPages + 1, true);
            start.push(startItem);
            counterPages++;
        }
        return start;
    }
    /**
     * @param {?} currentPage
     * @param {?} totalPages
     * @return {?}
     */
    getMobilePages(currentPage, totalPages) {
        // if we have less pages than the number we want to display take all
        if (totalPages < this._pagesMobile) {
            return Array.from(Array(totalPages).keys()).map((/**
             * @param {?} item
             * @return {?}
             */
            item => this.createPaginationItem(item + 1, item + 1)));
        }
        switch (currentPage) {
            // first page active
            case 1:
                return [1, 2, 3].map((/**
                 * @param {?} item
                 * @return {?}
                 */
                item => this.createPaginationItem(item, item)));
            // last page active
            case totalPages:
                return [totalPages - 2, totalPages - 1, totalPages].map((/**
                 * @param {?} item
                 * @return {?}
                 */
                item => this.createPaginationItem(item, item)));
            // any other page active
            default:
                return [currentPage - 1, currentPage, currentPage + 1].map((/**
                 * @param {?} item
                 * @return {?}
                 */
                item => this.createPaginationItem(item, item)));
        }
    }
    /**
     * @private
     * @param {?} label
     * @param {?} value
     * @param {?=} classExpanded
     * @return {?}
     */
    createPaginationItem(label, value, classExpanded) {
        return { label: label, value: value, class: classExpanded ? this._classExpanded : '' };
    }
}
NxPaginationUtils.decorators = [
    { type: Injectable }
];
if (false) {
    /**
     * @type {?}
     * @private
     */
    NxPaginationUtils.prototype._pagesMobile;
    /**
     * @type {?}
     * @private
     */
    NxPaginationUtils.prototype._elipsisText;
    /**
     * @type {?}
     * @private
     */
    NxPaginationUtils.prototype._classExpanded;
}

/**
 * @fileoverview added by tsickle
 * Generated from: pagination/pagination.component.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * \@docs-private
 * @record
 */
function Page() { }
if (false) {
    /** @type {?} */
    Page.prototype.label;
    /** @type {?} */
    Page.prototype.value;
    /** @type {?} */
    Page.prototype.class;
}
class NxPaginationComponent {
    /**
     * @param {?} paginationTexts
     * @param {?} paginationUtilsService
     * @param {?} _changeDetectorRef
     */
    constructor(paginationTexts, paginationUtilsService, _changeDetectorRef) {
        this.paginationUtilsService = paginationUtilsService;
        this._changeDetectorRef = _changeDetectorRef;
        this._type = 'simple';
        /**
         * \@docs-private
         */
        this.totalNumberPages = 0;
        /**
         * An event emitted when the previous page button is clicked.
         */
        this.nxGoPrev = new EventEmitter();
        /**
         * An event emitted when the next page button is clicked
         */
        this.nxGoNext = new EventEmitter();
        /**
         * An event emitted when a page number is clicked.
         * Provides the number of the page as parameter.
         */
        this.nxGoPage = new EventEmitter();
        this.paginationTexts = paginationTexts || DefaultPaginationTexts;
    }
    /**
     * @return {?}
     */
    get page() { return this._page; }
    /**
     * Sets the current page.
     * @param {?} value
     * @return {?}
     */
    set page(value) {
        this._page = value;
        this._changeDetectorRef.markForCheck();
    }
    /**
     * @return {?}
     */
    get count() { return this._count; }
    /**
     * Number of total items over all pages.
     * @param {?} value
     * @return {?}
     */
    set count(value) {
        this._count = value;
        this.totalNumberPages = this.calculateTotalPages();
        this._changeDetectorRef.markForCheck();
    }
    /**
     * @return {?}
     */
    get perPage() { return this._perPage; }
    /**
     * Sets the number of items you want to show per page.
     * @param {?} value
     * @return {?}
     */
    set perPage(value) {
        this._perPage = value;
        this.totalNumberPages = this.calculateTotalPages();
        this._changeDetectorRef.markForCheck();
    }
    /**
     * @return {?}
     */
    get type() { return this._type; }
    /**
     * Determines the type of pagination.
     *
     * Values: simple | advanced, default: simple.
     * @param {?} value
     * @return {?}
     */
    set type(value) {
        this._type = value;
        this._changeDetectorRef.markForCheck();
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.totalNumberPages = this.calculateTotalPages();
    }
    /**
     * @return {?}
     */
    ngAfterContentInit() {
        if (this.type === 'advanced' && (!this.paginationTexts.last || !this.paginationTexts.first)) {
            console.warn('Please define aria labels for the last and first arrows.');
        }
    }
    /**
     * Returns the number of the first page.
     * @return {?}
     */
    getMin() {
        return this.totalNumberPages > 0 ? 1 : 0;
    }
    /**
     * Returns the number of the last page.
     * @return {?}
     */
    getMax() {
        /** @type {?} */
        let max = this._perPage * this._page;
        if (max > this._count) {
            max = this._count;
        }
        return max;
    }
    /**
     * Returns the total number of pages
     * @return {?}
     */
    calculateTotalPages() {
        return Math.ceil(this._count / this._perPage) || 0;
    }
    /**
     * Directs to the page with number n.
     * @param {?} n
     * @return {?}
     */
    onPage(n) {
        this.nxGoPage.emit(n);
    }
    /**
     * Directs to the previous page.
     * @return {?}
     */
    onPrev() {
        if (!this._isPaginationPreviousDisabled()) {
            this.nxGoPrev.emit();
        }
    }
    /**
     * Directs to the next page.
     * @return {?}
     */
    onNext() {
        if (!this._isPaginationNextDisabled()) {
            this.nxGoNext.emit();
        }
    }
    /**
     * Directs to the first page.
     * @return {?}
     */
    onFirst() {
        if (!this._isPaginationPreviousDisabled()) {
            this.onPage(1);
        }
    }
    /**
     * Directs to the last page.
     * @return {?}
     */
    onLast() {
        if (!this._isPaginationNextDisabled()) {
            this.onPage(this.totalNumberPages);
        }
    }
    /**
     * Returns if the current page is the last page.
     * @return {?}
     */
    lastPage() {
        return this._perPage * this._page >= this._count;
    }
    /**
     * \@docs-private
     * @return {?}
     */
    getPages() {
        return this.paginationUtilsService.getPages(this._page, this.totalNumberPages);
    }
    /**
     * \@docs-private
     * @return {?}
     */
    getMobilePages() {
        return this.paginationUtilsService.getMobilePages(this._page, this.totalNumberPages);
    }
    /**
     * \@docs-private
     * @param {?} page
     * @return {?}
     */
    getPaginationItemClasses(page) {
        /** @type {?} */
        const classes = {
            'is-ellipsis': page.label === '...',
            'nx-pagination__item--expanded-view': page.class === 'expanded-view'
        };
        return classes;
    }
    /**
     * \@docs-private
     * @param {?} page
     * @return {?}
     */
    getPaginationNumberClasses(page) {
        /** @type {?} */
        const classes = {
            'is-active': page.value === this.page,
            'nx-pagination__ellipsis': page.label === '...',
            'nx-pagination__link': page.label !== '...'
        };
        return classes;
    }
    /**
     * Returns true, if `nxCount` is greater than 0, else false.
     * @return {?}
     */
    isPaginationVisible() {
        return this.count > 0;
    }
    /**
     * Returns true, if `nxCount` is greater than 0 and the type of pagination is 'simple', else false.
     * @return {?}
     */
    isPaginationCompactVisible() {
        return this.type.includes('simple') && this.count > 0;
    }
    /**
     * \@docs-private
     * @return {?}
     */
    isPaginationContainerVisible() {
        return this.type.includes('advanced');
    }
    /**
     * @return {?}
     */
    _isPaginationPreviousDisabled() {
        return this.page === this.getMin();
    }
    /**
     * @return {?}
     */
    _isPaginationNextDisabled() {
        return this.page === this.totalNumberPages;
    }
}
NxPaginationComponent.decorators = [
    { type: Component, args: [{
                selector: 'nx-pagination',
                template: "<nav *ngIf=\"isPaginationVisible()\"  aria-label=\"Page navigation\" class=\"nx-pagination\" >\n  <ul *ngIf=\"isPaginationContainerVisible()\"  [attr.aria-label]=\"paginationTexts.ariaLabel\" class=\"nx-pagination__container\">\n    <li class=\"nx-pagination__item\">\n      <button\n        [attr.aria-label]=\"paginationTexts.first\"\n        [class.is-disabled]=\"_isPaginationPreviousDisabled()\"\n        [tabindex]=\"_isPaginationPreviousDisabled() ? -1 : 0\"\n        class=\"nx-pagination__link nx-pagination__link--first\"\n        (click)=\"onFirst()\">\n        <nx-icon class=\"nx-pagination__arrow\" name=\"arrow-first\"></nx-icon>\n      </button>\n    </li>\n    <li class=\"nx-pagination__item nx-pagination__item-previous\">\n      <button\n        [attr.aria-label]=\"paginationTexts.previous\"\n        [class.is-disabled]=\"_isPaginationPreviousDisabled()\"\n        [tabindex]=\"_isPaginationPreviousDisabled() ? -1 : 0\"\n        class=\"nx-pagination__link nx-pagination__link--previous\"\n        (click)=\"onPrev()\">\n        <nx-icon class=\"nx-pagination__arrow\" name=\"arrow-left\"></nx-icon>\n      </button>\n    </li>\n    <li *ngFor=\"let pageNum of getPages()\" class=\"nx-pagination__item nx-pagination__item--desktop\" [ngClass]=\"getPaginationItemClasses(pageNum)\">\n      <button class=\"nx-pagination--number\"\n        *ngIf=\"pageNum.label !== '...'\"\n        (click)=\"onPage(pageNum.value)\"\n        [attr.aria-current]=\"(pageNum.value === page) ? 'page' : ''\"\n        [ngClass]=\"getPaginationNumberClasses(pageNum)\">\n        {{ pageNum.label }}\n      </button>\n      <span *ngIf=\"pageNum.label === '...'\">\n        {{ pageNum.label }}\n      </span>\n    </li>\n    <li *ngFor=\"let pageNum of getMobilePages()\" class=\"nx-pagination__item nx-pagination__item--mobile\" [ngClass]=\"getPaginationItemClasses(pageNum)\">\n      <button class=\"nx-pagination--number\"\n        (click)=\"onPage(pageNum.value)\"\n        [attr.aria-current]=\"(pageNum.value === page) ? 'page' : ''\"\n        [ngClass]=\"getPaginationNumberClasses(pageNum)\">\n        {{ pageNum.label }}\n      </button>\n    </li>\n    <li class=\"nx-pagination__item nx-pagination__item-next\">\n      <button\n        [attr.aria-label]=\"paginationTexts.next\"\n        [class.is-disabled]=\"_isPaginationNextDisabled()\"\n        [tabindex]=\"_isPaginationNextDisabled() ? -1 : 0\"\n        class=\"nx-pagination__link nx-pagination__link--next\"\n        (click)=\"onNext()\">\n        <nx-icon class=\"nx-pagination__arrow\" name=\"arrow-right\"></nx-icon>\n      </button>\n    </li>\n    <li class=\"nx-pagination__item\">\n      <button\n        [attr.aria-label]=\"paginationTexts.last\"\n        [class.is-disabled]=\"_isPaginationNextDisabled()\"\n        [tabindex]=\"_isPaginationNextDisabled() ? -1 : 0\"\n        class=\"nx-pagination__link nx-pagination__link--last\"\n        (click)=\"onLast()\">\n        <nx-icon class=\"nx-pagination__arrow\" name=\"arrow-last\"></nx-icon>\n      </button>\n    </li>\n  </ul>\n</nav>\n<nav *ngIf=\"isPaginationCompactVisible()\" [attr.aria-label]=\"paginationTexts.ariaLabel\" class=\"nx-pagination-compact\" >\n  <button [attr.aria-label]=\"paginationTexts.previous\"\n    class=\"nx-pagination-compact__previous\"\n    [class.is-disabled]=\"_isPaginationPreviousDisabled()\"\n    [tabindex]=\"_isPaginationPreviousDisabled() ? -1 : 0\"\n\n    (click)=\"onPrev()\">\n    <nx-icon class=\"nx-pagination__arrow\" name=\"arrow-left\"></nx-icon>\n    <span class=\"nx-pagination-compact__direction-label\">\n      {{ paginationTexts.previous }}\n    </span>\n  </button>\n  <div class=\"nx-pagination-compact__display\">\n      <span class=\"nx-pagination-compact__current-page\">{{ page }}</span>\n      <span class=\"nx-pagination-compact__page-separator\"> {{ paginationTexts.ofLabel }} </span>\n      <span class=\"nx-pagination-compact__total-pages\">{{ totalNumberPages }}</span>\n  </div>\n  <button\n    class=\"nx-pagination-compact__next\"\n    [class.is-disabled]=\"_isPaginationNextDisabled()\"\n    [tabindex]=\"_isPaginationNextDisabled() ? -1 : 0\"\n    [attr.aria-label]=\"paginationTexts.next\"\n    (click)=\"onNext()\">\n    <span class=\"nx-pagination-compact__direction-label\"> {{ paginationTexts.next }} </span>\n    <nx-icon class=\"nx-pagination__arrow\" name=\"arrow-right\"></nx-icon>\n  </button>\n</nav>\n",
                changeDetection: ChangeDetectionStrategy.OnPush,
                styles: [":host button:focus{outline:0}:host button::-moz-focus-inner{border:0}.nx-pagination__container{display:flex;font-size:16px;font-size:var(--pagination-font-size,16px);line-height:24px;line-height:var(--pagination-line-height,24px);font-weight:400;font-weight:var(--pagination-font-weight,400);letter-spacing:0;letter-spacing:var(--pagination-letter-spacing,0);margin:8px 0;padding:0}@media (min-width:704px){.nx-pagination__container{margin:8px 0 40px}}.nx-pagination__item{margin:0 16px;list-style:none;font-weight:600;font-weight:var(--pagination-item-font-weight,600)}.nx-pagination__item:first-child,.nx-pagination__item:last-child{margin:0}.nx-pagination__item.is-ellipsis{color:#414141;color:var(--pagination-text-color,#414141)}.nx-pagination__item--expanded-view{display:block}.nx-pagination__link{color:#006192;color:var(--pagination-link-color,#006192);padding:0;text-decoration:none;background-color:transparent;border:0;cursor:pointer}.nx-pagination__link.is-active{color:#414141;color:var(--pagination-text-color,#414141);font-weight:700;cursor:default}nx-icon.nx-pagination__arrow{font-size:24px;font-size:var(--pagination-icon-size,24px)}.nx-pagination-compact{display:flex;font-size:16px;font-size:var(--pagination-font-size,16px);line-height:24px;line-height:var(--pagination-line-height,24px);font-weight:400;font-weight:var(--pagination-font-weight,400);letter-spacing:0;letter-spacing:var(--pagination-letter-spacing,0);margin:16px 0;padding:0}@media (min-width:704px){.nx-pagination-compact{margin:40px 0}}.nx-pagination-compact__display{color:#414141;color:var(--pagination-text-color,#414141);display:flex}.nx-pagination-compact__current-page{font-weight:700;margin-right:8px}.nx-pagination-compact__total-pages{margin-left:8px}.nx-pagination-compact__next,.nx-pagination-compact__previous,.nx-pagination__arrow-first,.nx-pagination__arrow-last{color:#006192;color:var(--pagination-link-color,#006192);font-weight:600;font-weight:var(--pagination-icon-font-weight,600);text-decoration:none;text-transform:uppercase;display:flex;align-items:center;padding:0;background-color:transparent;cursor:pointer;border:0}.nx-pagination-compact__previous{margin-right:32px}.nx-pagination-compact__next{margin-left:32px}.nx-pagination-compact__direction-label{font-size:16px;font-size:var(--pagination-compact-direction-font-size,16px);line-height:24px;line-height:var(--pagination-compact-direction-line-height,24px);font-weight:600;font-weight:var(--pagination-compact-direction-font-weight,600);letter-spacing:1px;letter-spacing:var(--pagination-compact-direction-letter-spacing,1px)}.nx-pagination-compact__direction-label:first-child{margin-right:8px}.nx-pagination-compact__direction-label:last-child{margin-left:8px}.nx-pagination-compact__next.is-disabled,.nx-pagination-compact__previous.is-disabled,.nx-pagination__link.is-disabled{color:rgba(0,97,146,.4);color:var(--pagination-link-disabled-color,rgba(0,97,146,.4));cursor:not-allowed}:host-context([data-whatinput=keyboard]) .nx-pagination--number:focus,:host-context([data-whatinput=keyboard]) .nx-pagination-compact__next:focus,:host-context([data-whatinput=keyboard]) .nx-pagination-compact__previous:focus,:host-context([data-whatinput=keyboard]) .nx-pagination__link:focus{box-shadow:0 0 0 2px #fff,0 0 0 6px #009de6;box-shadow:var(--focus-box-shadow,0 0 0 2px #fff,0 0 0 6px #009de6);border-radius:4px}@media screen and (-ms-high-contrast:active){.nx-pagination__link.is-active{border-bottom:4px solid windowText}.nx-pagination-compact__next.is-disabled,.nx-pagination-compact__previous.is-disabled,.nx-pagination__link.is-disabled{color:GrayText}:host-context([data-whatinput=keyboard]) .nx-pagination--number:focus,:host-context([data-whatinput=keyboard]) .nx-pagination-compact__next:focus,:host-context([data-whatinput=keyboard]) .nx-pagination-compact__previous:focus,:host-context([data-whatinput=keyboard]) .nx-pagination__link:focus{box-shadow:0 0 0 2px background,0 0 0 6px windowText}}.nx-pagination__link--first,.nx-pagination__link--last,.nx-pagination__link--next,.nx-pagination__link--previous{display:flex;align-items:center}.nx-pagination__item-next{margin-right:8px}.nx-pagination__item-previous{margin-left:8px}.nx-pagination-compact__direction-label,.nx-pagination__item--desktop,.nx-pagination__link--first,.nx-pagination__link--last{display:block}.nx-pagination__item--mobile{display:none}@media (max-width:703px){.nx-pagination-compact__direction-label,.nx-pagination__item--desktop,.nx-pagination__link--first,.nx-pagination__link--last{display:none}.nx-pagination__item--mobile{display:block}}"]
            }] }
];
/** @nocollapse */
NxPaginationComponent.ctorParameters = () => [
    { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [NX_PAGINATION_TEXTS,] }] },
    { type: NxPaginationUtils },
    { type: ChangeDetectorRef }
];
NxPaginationComponent.propDecorators = {
    page: [{ type: Input, args: ['nxPage',] }],
    count: [{ type: Input, args: ['nxCount',] }],
    perPage: [{ type: Input, args: ['nxPerPage',] }],
    type: [{ type: Input, args: ['nxType',] }],
    nxGoPrev: [{ type: Output }],
    nxGoNext: [{ type: Output }],
    nxGoPage: [{ type: Output }]
};
if (false) {
    /**
     * @type {?}
     * @private
     */
    NxPaginationComponent.prototype._page;
    /**
     * @type {?}
     * @private
     */
    NxPaginationComponent.prototype._count;
    /**
     * @type {?}
     * @private
     */
    NxPaginationComponent.prototype._perPage;
    /**
     * @type {?}
     * @private
     */
    NxPaginationComponent.prototype._type;
    /**
     * \@docs-private
     * @type {?}
     */
    NxPaginationComponent.prototype.paginationTexts;
    /**
     * \@docs-private
     * @type {?}
     */
    NxPaginationComponent.prototype.totalNumberPages;
    /**
     * An event emitted when the previous page button is clicked.
     * @type {?}
     */
    NxPaginationComponent.prototype.nxGoPrev;
    /**
     * An event emitted when the next page button is clicked
     * @type {?}
     */
    NxPaginationComponent.prototype.nxGoNext;
    /**
     * An event emitted when a page number is clicked.
     * Provides the number of the page as parameter.
     * @type {?}
     */
    NxPaginationComponent.prototype.nxGoPage;
    /**
     * @type {?}
     * @private
     */
    NxPaginationComponent.prototype.paginationUtilsService;
    /**
     * @type {?}
     * @private
     */
    NxPaginationComponent.prototype._changeDetectorRef;
}

/**
 * @fileoverview added by tsickle
 * Generated from: pagination/pagination.module.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class NxPaginationModule {
}
NxPaginationModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    CommonModule, NxIconModule
                ],
                declarations: [
                    NxPaginationComponent
                ],
                exports: [
                    NxPaginationComponent
                ],
                providers: [
                    NxPaginationUtils
                ]
            },] }
];

/**
 * @fileoverview added by tsickle
 * Generated from: pagination/public-api.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * Generated from: pagination/index.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * Generated from: dynamic-table/tabledata-source.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class TableDataSource extends DataSource {
    /**
     * @param {?} _datachange
     */
    constructor(_datachange) {
        super();
        this._datachange = _datachange;
    }
    /**
     * \@docs-private Connect function called by the table to retrieve one stream containing the data to render.
     * @return {?}
     */
    connect() {
        return this._datachange;
    }
    /**
     * \@docs-private
     * @return {?}
     */
    disconnect() { }
}
if (false) {
    /**
     * @type {?}
     * @private
     */
    TableDataSource.prototype._datachange;
}

/**
 * @fileoverview added by tsickle
 * Generated from: dynamic-table/dynamic-table.component.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class NxDynamicTableComponent {
    /**
     * @param {?} el
     * @param {?} _changeDetectorRef
     */
    constructor(el, _changeDetectorRef) {
        this.el = el;
        this._changeDetectorRef = _changeDetectorRef;
        this._dataChange = new BehaviorSubject([]);
        /**
         * An event is dispatched when a row is clicked.
         */
        this.nxRowClick = new EventEmitter();
    }
    /**
     * Sets the data that it will show in the table.
     * @param {?} value
     * @return {?}
     */
    set data(value) {
        this._data = value
            .filter((/**
         * @param {?} element
         * @return {?}
         */
        element => element));
        // If user dont pass displayedColumns the table will show all data and the name of columns will be the key of data
        if (!this._displayedColumns) {
            /** @type {?} */
            const keys = [];
            /** @type {?} */
            const cArray = [];
            // For catch keys of data Objects and assing title, key and type string by default to displayedColumns
            this._data
                .forEach((/**
             * @param {?} element
             * @return {?}
             */
            element => {
                for (const key in element) {
                    if (keys.indexOf(key) === -1) {
                        keys.push(key);
                        cArray.push({ title: key, key: key, type: 'string' });
                    }
                }
            }));
            this._columnKeys = keys;
            this._displayedColumns = cArray;
            // need to call markForCheck as the setter changes displayedColumns here
            // sidenote: isn't needed for the data itself as it gets passed to the cdk-table
            // by the datasource observable
            this._changeDetectorRef.markForCheck();
        }
        this._dataChange.next(this._data);
    }
    /**
     * @return {?}
     */
    get data() {
        return this._data;
    }
    /**
     * Sets the name order and type of columns.
     * @param {?} value
     * @return {?}
     */
    set displayedColumns(value) {
        this._displayedColumns = value;
        this._columnKeys = value.map((/**
         * @param {?} column
         * @return {?}
         */
        column => column.key));
        this._changeDetectorRef.markForCheck();
    }
    /**
     * @return {?}
     */
    get displayedColumns() {
        return this._displayedColumns;
    }
    /**
     * \@docs-private
     * @return {?}
     */
    get dataSource() {
        return this._dataSource;
    }
    /**
     * \@docs-private
     * @return {?}
     */
    get columnKeys() {
        return this._columnKeys;
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        if (!this._data) {
            this._data = [];
            this._dataChange.next(this._data);
        }
        this._dataSource = new TableDataSource(this._dataChange);
    }
    /**
     * \@docs-private
     * @param {?} row
     * @return {?}
     */
    handleRowClick(row) {
        this.nxRowClick.emit(row);
    }
    /**
     * \@docs-private
     * @param {?} element
     * @return {?}
     */
    isNumeric(element) {
        if (element.type === 'numeric') {
            return true;
        }
        return false;
    }
}
NxDynamicTableComponent.decorators = [
    { type: Component, args: [{
                selector: 'nx-dynamic-table',
                template: "<div class=\"nx-table__container\" *ngIf=\"data && data.length > 0\">\n  <div class=\"nx-table__scroll\">\n    <cdk-table [dataSource]=\"dataSource\" class=\"nx-table\">\n      <!-- Column Definition -->\n      <ng-container *ngFor=\"let element of displayedColumns\" cdkColumnDef=\"{{element.key}}\">\n        <cdk-header-cell *cdkHeaderCellDef class=\"nx-table__header-cell\"\n                         [ngClass]=\"{'nx-table__header-cell--number': isNumeric(element) }\">\n          <div class=\"nx-table__header-title--block\">\n            <span class=\"nx-table__header-title\"> {{element.title}}</span>\n          </div>\n        </cdk-header-cell>\n        <cdk-cell *cdkCellDef=\"let row\" class=\"nx-table__cell\"\n                  [ngClass]=\"{'nx-table__cell--number': isNumeric(element) }\" [innerHTML]=\"row[element.key]\"></cdk-cell>\n      </ng-container>\n\n      <!-- Header and Row Declarations -->\n      <cdk-header-row *cdkHeaderRowDef=\"columnKeys\" class=\"nx-table__header-row\"></cdk-header-row>\n      <cdk-row *cdkRowDef=\"let row; columns: columnKeys\" class=\"nx-table__row\"\n               (dblclick)=\"handleRowClick(row)\"></cdk-row>\n\n    </cdk-table>\n  </div>\n</div>\n<div class=\"nx-table__appendix\" *ngIf=\"data.length === 0\">\n  <ng-content></ng-content>\n</div>\n",
                changeDetection: ChangeDetectionStrategy.OnPush,
                styles: [".nx-table{font-size:16px;font-size:var(--table-cell-font-size,16px);line-height:24px;line-height:var(--table-cell-line-height,24px);font-weight:400;font-weight:var(--table-cell-font-weight,400);letter-spacing:0;letter-spacing:var(--table-cell-letter-spacing,0);color:#414141;color:var(--table-cell-color,#414141);text-align:left;width:100%;display:table}.nx-table__container{margin:32px 0}.nx-table__scroll{max-width:100%;overflow:hidden;overflow-x:auto}.nx-table__header-cell{font-size:16px;font-size:var(--table-header-cell-font-size,16px);line-height:24px;line-height:var(--table-header-cell-line-height,24px);font-weight:600;font-weight:var(--table-header-cell-font-weight,600);letter-spacing:0;letter-spacing:var(--table-header-cell-letter-spacing,0);color:#414141;color:var(--table-header-cell-color,#414141);background:0 0;background:var(--table-header-cell-background-color,transparent);border-top:1px solid #d9d9d9;border-top:1px solid var(--table-cell-border-top-color,#d9d9d9);border-bottom:2px solid #414141;border-bottom:2px solid var(--table-header-border-bottom-color,#414141);padding:23px 16px 22px;position:relative}.nx-table__header-cell--number{display:flex;position:relative}.nx-table__header-cell--number .nx-table__header-title--block{justify-content:flex-end}.nx-table__cell--number,.nx-table__header-cell--number{text-align:right}.nx-table__header-row,.nx-table__row{display:table-row;vertical-align:inherit;background-color:transparent}.nx-table__row{background:0 0;background:var(--table-row-background-color,transparent)}.nx-table__cell{border-bottom:1px solid #d9d9d9;border-bottom:1px solid var(--table-header-border-top-color,#d9d9d9);padding:24px 16px 23px;vertical-align:top}.nx-table__row:last-child .nx-table__cell{padding-bottom:22px;border-bottom:2px solid #414141;border-bottom:2px solid var(--table-header-border-bottom-color,#414141)}.nx-table__cell,.nx-table__header-cell{display:table-cell;vertical-align:inherit}"]
            }] }
];
/** @nocollapse */
NxDynamicTableComponent.ctorParameters = () => [
    { type: ElementRef },
    { type: ChangeDetectorRef }
];
NxDynamicTableComponent.propDecorators = {
    data: [{ type: Input, args: ['nxData',] }],
    displayedColumns: [{ type: Input, args: ['nxDisplayedColumns',] }],
    nxRowClick: [{ type: Output }]
};
if (false) {
    /**
     * @type {?}
     * @private
     */
    NxDynamicTableComponent.prototype._dataChange;
    /**
     * @type {?}
     * @private
     */
    NxDynamicTableComponent.prototype._dataSource;
    /**
     * @type {?}
     * @private
     */
    NxDynamicTableComponent.prototype._data;
    /**
     * @type {?}
     * @private
     */
    NxDynamicTableComponent.prototype._displayedColumns;
    /**
     * @type {?}
     * @private
     */
    NxDynamicTableComponent.prototype._columnKeys;
    /**
     * An event is dispatched when a row is clicked.
     * @type {?}
     */
    NxDynamicTableComponent.prototype.nxRowClick;
    /**
     * @type {?}
     * @private
     */
    NxDynamicTableComponent.prototype.el;
    /**
     * @type {?}
     * @private
     */
    NxDynamicTableComponent.prototype._changeDetectorRef;
}

/**
 * @fileoverview added by tsickle
 * Generated from: dynamic-table/dynamic-table.module.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class NxDynamicTableModule {
}
NxDynamicTableModule.decorators = [
    { type: NgModule, args: [{
                declarations: [NxDynamicTableComponent],
                exports: [NxDynamicTableComponent],
                imports: [CommonModule, CdkTableModule, ScrollingModule]
            },] }
];

/**
 * @fileoverview added by tsickle
 * Generated from: dynamic-table/public-api.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * Generated from: accordion/accordion.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const DEFAULT_TYPE$4 = 'regular';
class NxAccordionDirective extends CdkAccordion {
    constructor() {
        super(...arguments);
        this._style = 'regular';
        this._negative = null;
    }
    /**
     * Value for the styling that should be chosen.
     * Default value: 'regular'
     * @param {?} value
     * @return {?}
     */
    set style(value) {
        value = value ? value : DEFAULT_TYPE$4;
        const [newValue] = value.match(/regular|light/) || [DEFAULT_TYPE$4];
        this._style = (/** @type {?} */ (newValue));
    }
    /**
     * @return {?}
     */
    get style() {
        return this._style;
    }
    /**
     * Whether the negative set of styles should be used.
     * @param {?} value
     * @return {?}
     */
    set negative(value) {
        this._negative = coerceBooleanProperty(value);
    }
    /**
     * @return {?}
     */
    get negative() {
        return this._negative;
    }
}
NxAccordionDirective.decorators = [
    { type: Directive, args: [{
                // tslint:disable-next-line:directive-selector
                selector: 'nx-accordion',
                host: {
                    '[class.nx-accordion]': 'true',
                    'role': 'presentation'
                }
            },] }
];
NxAccordionDirective.propDecorators = {
    style: [{ type: Input, args: ['nxStyle',] }],
    negative: [{ type: Input }]
};
if (false) {
    /**
     * @type {?}
     * @private
     */
    NxAccordionDirective.prototype._style;
    /**
     * @type {?}
     * @private
     */
    NxAccordionDirective.prototype._negative;
}

/**
 * @fileoverview added by tsickle
 * Generated from: accordion/accordion-animations.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const nxAccordionAnimations = {
    bodyExpansion: trigger('bodyExpansion', [
        state('closed', style({ height: '0px', visibility: 'hidden' })),
        state('open', style({ height: '*', visibility: 'visible' })),
        transition('open <=> closed', animate('.5s cubic-bezier(0.86, 0, 0.07, 1)'))
    ]),
    indicatorRotate: trigger('indicatorRotate', [
        state('closed', style({ transform: 'rotate(0deg)' })),
        state('open', style({ transform: 'rotate(180deg)' })),
        transition('open <=> closed', animate('.3s ease')),
    ])
};

/**
 * @fileoverview added by tsickle
 * Generated from: accordion/expansion-panel-body.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class NxExpansionPanelBodyDirective {
    /**
     * @param {?} _template
     */
    constructor(_template) {
        this._template = _template;
    }
}
NxExpansionPanelBodyDirective.decorators = [
    { type: Directive, args: [{ selector: '[nxExpansionPanelBody]' },] }
];
/** @nocollapse */
NxExpansionPanelBodyDirective.ctorParameters = () => [
    { type: TemplateRef }
];
if (false) {
    /** @type {?} */
    NxExpansionPanelBodyDirective.prototype._template;
}

/**
 * @fileoverview added by tsickle
 * Generated from: accordion/expansion-panel.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
let nextId$9 = 0;
/** @type {?} */
const DEFAULT_TYPE$5 = 'regular';
const ɵ0 = undefined;
class NxExpansionPanelComponent extends CdkAccordionItem {
    /**
     * @param {?} accordion
     * @param {?} _changeDetectorRef
     * @param {?} _expansionDispatcher
     * @param {?} _viewContainerRef
     */
    constructor(accordion, _changeDetectorRef, _expansionDispatcher, _viewContainerRef) {
        super(accordion, _changeDetectorRef, _expansionDispatcher);
        this._viewContainerRef = _viewContainerRef;
        this._negative = null;
        this._accordionStyle = DEFAULT_TYPE$5;
        this._style = null;
        this._headerId = `nx-expansion-panel-header-${nextId$9++}`;
        /**
         * Stream that emits for changes in `\@Input` properties.
         */
        this._inputChanges = new Subject();
        this.accordion = accordion;
    }
    /**
     * Whether the negative set of styles should be used.
     * @param {?} value
     * @return {?}
     */
    set negative(value) {
        this._negative = coerceBooleanProperty(value);
    }
    /**
     * @return {?}
     */
    get negative() {
        return this._negative;
    }
    /**
     * Value for the styling that should be chosen.
     * Default value: 'regular'.
     * @param {?} value
     * @return {?}
     */
    set style(value) {
        value = value ? value : DEFAULT_TYPE$5;
        const [newValue] = value.match(/regular|light/) || [DEFAULT_TYPE$5];
        this._style = (/** @type {?} */ (newValue));
        this._accordionStyle = (/** @type {?} */ (newValue));
    }
    /**
     * @return {?}
     */
    get style() {
        return this._style;
    }
    /**
     * \@docs-private
     * @return {?}
     */
    get portal() {
        return this._portal;
    }
    /**
     * @return {?}
     */
    ngAfterContentInit() {
        if (this.lazyContent) {
            // Render the content as soon as the panel becomes open.
            this.opened.pipe(startWith(null), filter((/**
             * @return {?}
             */
            () => this.expanded && !this._portal)), take(1)).subscribe((/**
             * @return {?}
             */
            () => {
                this._portal = new TemplatePortal(this.lazyContent._template, this._viewContainerRef);
            }));
        }
        // Inherit appearance given by the accordion (if any).
        if (Boolean(this.accordion)) {
            if (this.style === null && this.accordion.style !== null) {
                this.style = this.accordion.style;
            }
            if (this.negative === null && this.accordion.negative !== null) {
                this.negative = this.accordion.negative;
            }
        }
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        this._inputChanges.next(changes);
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        super.ngOnDestroy();
        this._inputChanges.complete();
    }
    /**
     * \@docs-private
     * @return {?}
     */
    getOpenState() {
        return this.expanded ? 'open' : 'closed';
    }
}
NxExpansionPanelComponent.decorators = [
    { type: Component, args: [{
                selector: 'nx-expansion-panel',
                exportAs: 'NxExpansionPanelComponent',
                template: "<ng-content select=\"nx-expansion-panel-header\"></ng-content>\n\n<div class=\"nx-expansion-panel__content\" role=\"region\" [@bodyExpansion]=\"getOpenState()\"\n  [attr.aria-labelledby]=\"_headerId\" [id]=\"id\">\n  <div class=\"nx-expansion-panel__body\">\n    <ng-content></ng-content>\n    <ng-template [cdkPortalOutlet]=\"portal\"></ng-template>\n  </div>\n</div>",
                changeDetection: ChangeDetectionStrategy.OnPush,
                animations: [nxAccordionAnimations.bodyExpansion],
                host: {
                    '[class.nx-expanded]': 'expanded',
                    '[class.nx-expansion-panel--light]': '_accordionStyle === "light"',
                    '[class.nx-expansion-panel--regular]': '_accordionStyle === "regular"',
                    '[class.nx-expansion-panel--negative]': 'negative',
                    '[class.is-disabled]': 'disabled',
                },
                providers: [
                    // Provide NxAccordionDirective as undefined to prevent nested expansion panels from registering
                    // to the same accordion.
                    { provide: NxAccordionDirective, useValue: ɵ0 },
                ],
                styles: [":host{display:block}:host(.nx-expansion-panel--negative) ::ng-deep div.nx-expansion-panel__body *{color:#fff}.nx-expansion-panel__content{overflow:hidden;display:block}.nx-expansion-panel__body{font-size:16px;font-size:var(--accordion-body-font-size,16px);line-height:24px;line-height:var(--accordion-body-line-height,24px);font-weight:400;font-weight:var(--accordion-body-font-weight,400);letter-spacing:0;letter-spacing:var(--accordion-body-letter-spacing,0);padding:24px 88px 32px 32px;padding:var(--accordion-regular-body-padding,24px 88px 32px 32px)}:host(.nx-expansion-panel--regular){margin-top:16px;margin-top:var(--accordion-regular-header-top-margin,16px)}:host(.nx-expansion-panel--regular) ::ng-deep .nx-expansion-panel__header-content{box-shadow:inset 0 1px 0 0 transparent;box-shadow:inset 0 1px 0 0 var(--accordion-regular-border-color,transparent)}:host(.nx-expansion-panel--regular):last-child,:host(.nx-expansion-panel--regular):only-child{box-shadow:0 1px 0 0 transparent;box-shadow:0 1px 0 0 var(--accordion-regular-border-color,transparent)}@media (max-width:703px){.nx-expansion-panel__body{padding:24px 16px 32px}:host(.nx-expansion-panel--regular){margin-top:0}:host(.nx-expansion-panel--regular) ::ng-deep .nx-expansion-panel__header-content{box-shadow:inset 0 1px 0 0 #d9d9d9}:host(.nx-expansion-panel--regular):last-child ::ng-deep .nx-expansion-panel__header-content,:host(.nx-expansion-panel--regular):only-child ::ng-deep .nx-expansion-panel__header-content{box-shadow:inset 0 1px 0 0 #d9d9d9,inset 0 -1px 0 0 #d9d9d9}:host(.nx-expansion-panel--regular).nx-expanded ::ng-deep .nx-expansion-panel__header-content{box-shadow:inset 0 1px 0 0 #d9d9d9,inset 0 -1px 0 0 #d9d9d9}}:host(.nx-expansion-panel--light) .nx-expansion-panel__body{padding:24px 88px 32px 32px;padding:var(--accordion-light-body-padding,24px 88px 32px 32px)}:host(.nx-expansion-panel--light):not(.nx-expansion-panel--negative) ::ng-deep .nx-expansion-panel__header-content{box-shadow:inset 0 1px 0 0 #d9d9d9}:host(.nx-expansion-panel--light):not(.nx-expansion-panel--negative):last-child,:host(.nx-expansion-panel--light):not(.nx-expansion-panel--negative):only-child{box-shadow:0 1px 0 0 #d9d9d9}:host(.nx-expansion-panel--light.nx-expansion-panel--negative){color:#fff}:host(.nx-expansion-panel--light.nx-expansion-panel--negative) ::ng-deep .nx-expansion-panel__header-content{box-shadow:inset 0 1px 0 0 #fff}:host(.nx-expansion-panel--light.nx-expansion-panel--negative):last-child,:host(.nx-expansion-panel--light.nx-expansion-panel--negative):only-child{box-shadow:0 1px 0 0 #fff}@media screen and (-ms-high-contrast:active){:host{border-color:windowText;color:buttonText}:host.nx-expansion-panel--regular{border:1px solid buttonText}:host.is-disabled{border-color:GrayText}:host.nx-expansion-panel--light.nx-expansion-panel--negative ::ng-deep .nx-expansion-panel__header-content,:host.nx-expansion-panel--light:not(.nx-expansion-panel--negative) ::ng-deep .nx-expansion-panel__header-content{box-shadow:inset 0 1px 0 0 windowText}:host.nx-expansion-panel--light.nx-expansion-panel--negative:last-child,:host.nx-expansion-panel--light.nx-expansion-panel--negative:only-child,:host.nx-expansion-panel--light:not(.nx-expansion-panel--negative):last-child,:host.nx-expansion-panel--light:not(.nx-expansion-panel--negative):only-child{box-shadow:0 1px 0 0 windowText}}"]
            }] }
];
/** @nocollapse */
NxExpansionPanelComponent.ctorParameters = () => [
    { type: NxAccordionDirective, decorators: [{ type: Optional }, { type: SkipSelf }] },
    { type: ChangeDetectorRef },
    { type: UniqueSelectionDispatcher },
    { type: ViewContainerRef }
];
NxExpansionPanelComponent.propDecorators = {
    negative: [{ type: Input }],
    style: [{ type: Input, args: ['nxStyle',] }],
    lazyContent: [{ type: ContentChild, args: [NxExpansionPanelBodyDirective, { static: false },] }]
};
if (false) {
    /**
     * @type {?}
     * @private
     */
    NxExpansionPanelComponent.prototype._negative;
    /** @type {?} */
    NxExpansionPanelComponent.prototype._accordionStyle;
    /**
     * @type {?}
     * @private
     */
    NxExpansionPanelComponent.prototype._style;
    /**
     * \@docs-private
     * @type {?}
     */
    NxExpansionPanelComponent.prototype.lazyContent;
    /**
     * @type {?}
     * @private
     */
    NxExpansionPanelComponent.prototype._portal;
    /**
     * \@docs-private
     * @type {?}
     */
    NxExpansionPanelComponent.prototype.accordion;
    /** @type {?} */
    NxExpansionPanelComponent.prototype._headerId;
    /**
     * Stream that emits for changes in `\@Input` properties.
     * @type {?}
     */
    NxExpansionPanelComponent.prototype._inputChanges;
    /**
     * @type {?}
     * @private
     */
    NxExpansionPanelComponent.prototype._viewContainerRef;
}

/**
 * @fileoverview added by tsickle
 * Generated from: accordion/expansion-panel-header.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class NxExpansionPanelHeaderComponent {
    /**
     * @param {?} panel
     * @param {?} _changeDetectorRef
     */
    constructor(panel, _changeDetectorRef) {
        this.panel = panel;
        this._changeDetectorRef = _changeDetectorRef;
        this._parentChangeSubscription = Subscription.EMPTY;
        this._parentChangeSubscription = merge(panel.opened, panel.closed, panel._inputChanges.pipe(filter((/**
         * @param {?} changes
         * @return {?}
         */
        changes => !!(changes.hideToggle || changes.disabled)))))
            .subscribe((/**
         * @return {?}
         */
        () => this._changeDetectorRef.markForCheck()));
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this._parentChangeSubscription.unsubscribe();
    }
    /**
     * \@docs-private
     * @return {?}
     */
    isExpanded() {
        return this.panel.expanded;
    }
    /**
     * \@docs-private
     * @return {?}
     */
    getOpenState() {
        return this.panel.getOpenState();
    }
    /**
     * @return {?}
     */
    _getPanelId() {
        return this.panel.id;
    }
    /**
     * Toggle the expansion panel.
     * @return {?}
     */
    toggle() {
        this.panel.toggle();
    }
    /**
     * \@docs-private
     * @param {?} event
     * @return {?}
     */
    keydown(event) {
        switch (event.keyCode) {
            case SPACE:
            case ENTER:
                event.preventDefault();
                this.toggle();
                break;
            default:
                return;
        }
    }
}
NxExpansionPanelHeaderComponent.decorators = [
    { type: Component, args: [{
                selector: 'nx-expansion-panel-header',
                template: "<div class=\"nx-expansion-panel__header-content\">\n  <ng-content select=\"nx-expansion-panel-title\"></ng-content>\n  <ng-content select=\"nx-expansion-panel-description\"></ng-content>\n  <nx-icon\n    [@indicatorRotate]=\"getOpenState()\"\n    class=\"nx-expansion-panel__chevron\"\n    name=\"chevron-down\">\n  </nx-icon>\n</div>",
                changeDetection: ChangeDetectionStrategy.OnPush,
                animations: [nxAccordionAnimations.indicatorRotate],
                host: {
                    '[class.nx-expanded]': 'isExpanded()',
                    'class': 'nx-expansion-panel__header',
                    'role': 'button',
                    '[attr.id]': 'panel._headerId',
                    '[attr.tabindex]': 'panel.disabled ? -1 : 0',
                    '[attr.aria-controls]': '_getPanelId()',
                    '[attr.aria-expanded]': 'isExpanded()',
                    '[attr.aria-disabled]': 'panel.disabled',
                    '[class.is-disabled]': 'panel.disabled',
                    '(keydown)': 'keydown($event)',
                    '(click)': 'toggle()'
                },
                styles: [":host:focus{outline:0}.nx-expansion-panel__header-content{width:100%;cursor:pointer;align-items:center;display:flex;justify-content:space-between;position:relative;outline:0;border:none;color:#414141;color:var(--accordion-regular-header-text-color,#414141);background:#f5f5f5;background:var(--accordion-regular-header-background-color,#f5f5f5);padding:24px 32px;padding:var(--accordion-regular-header-padding,24px 32px)}:host-context(.nx-expansion-panel--regular):not(.is-disabled) .nx-expansion-panel__header-content:hover{color:#414141;color:var(--accordion-regular-header-hover-text-color,#414141)}:host-context(.nx-expansion-panel--regular):not(.is-disabled) .nx-expansion-panel__header-content:hover .nx-expansion-panel__chevron{color:#006192;color:var(--accordion-regular-hover-chevron-color,#006192)}::ng-deep .nx-expansion-panel__header-title{font-size:26px;font-size:var(--accordion-regular-font-size,26px);line-height:32px;line-height:var(--accordion-regular-line-height,32px);font-weight:300;font-weight:var(--accordion-regular-font-weight,300);letter-spacing:.3px;letter-spacing:var(--accordion-regular-letter-spacing,.3px);text-align:left;margin-right:32px}@media (max-width:703px){.nx-expansion-panel__header-content{padding:16px}::ng-deep .nx-expansion-panel__header-title{font-size:20px;font-size:var(--accordion-regular-mobile-font-size,20px);line-height:28px;line-height:var(--accordion-regular-mobile-line-height,28px);font-weight:400;font-weight:var(--accordion-regular-mobile-font-weight,400);letter-spacing:.2px;letter-spacing:var(--accordion-regular-mobile-letter-spacing,.2px);margin-right:16px}}.nx-expansion-panel__chevron{pointer-events:none;font-size:24px;font-size:var(--accordion-chevron-size,24px)}:host(:not(.is-disabled)) .nx-expansion-panel__chevron{color:#006192;color:var(--accordion-regular-chevron-color,#006192)}:host-context(.nx-expansion-panel--light) .nx-expansion-panel__header-content{padding:24px 32px;padding:var(--accordion-light-header-padding,24px 32px);margin-top:0;background:0 0}:host-context(.nx-expansion-panel--light) .nx-expansion-panel__chevron{color:#006192;color:var(--accordion-light-chevron-color,#006192)}:host-context(.nx-expansion-panel--light) ::ng-deep .nx-expansion-panel__header-title{font-size:20px;font-size:var(--accordion-light-font-size,20px);line-height:28px;line-height:var(--accordion-light-line-height,28px);font-weight:400;font-weight:var(--accordion-light-font-weight,400);letter-spacing:.2px;letter-spacing:var(--accordion-light-letter-spacing,.2px)}@media (max-width:703px){:host-context(.nx-expansion-panel--light) ::ng-deep .nx-expansion-panel__header-title{font-size:14px;font-size:var(--accordion-light-mobile-font-size,14px);line-height:20px;line-height:var(--accordion-light-mobile-line-height,20px);font-weight:600;font-weight:var(--accordion-light-mobile-font-weight,600);letter-spacing:.2px;letter-spacing:var(--accordion-light-mobile-letter-spacing,.2px)}}:host-context(.nx-expansion-panel--light:not(.nx-expansion-panel--negative)) .nx-expansion-panel__header-content{color:#006192;color:var(--accordion-light-header-text-color,#006192)}:host-context(.nx-expansion-panel--light:not(.nx-expansion-panel--negative)):not(.is-disabled) .nx-expansion-panel__header-content:hover{color:#006192;color:var(--accordion-light-header-hover-text-color,#006192)}:host-context(.nx-expansion-panel--light:not(.nx-expansion-panel--negative)):not(.is-disabled) .nx-expansion-panel__header-content:hover .nx-expansion-panel__chevron{color:#006192;color:var(--accordion-light-hover-chevron-color,#006192)}:host-context(.nx-expansion-panel--light.nx-expansion-panel--negative) .nx-expansion-panel__header-content{color:#fff}:host-context(.nx-expansion-panel--light.nx-expansion-panel--negative) .nx-expansion-panel__chevron{color:#fff}:host.is-disabled.is-disabled .nx-expansion-panel__chevron,:host.is-disabled.is-disabled .nx-expansion-panel__header-content{cursor:not-allowed;color:#c2c2c2;color:var(--accordion-disabled-color,#c2c2c2)}:host-context([data-whatinput=keyboard]):focus .nx-expansion-panel__header-content{box-shadow:0 0 0 2px #fff,0 0 0 6px #009de6;box-shadow:var(--focus-box-shadow,0 0 0 2px #fff,0 0 0 6px #009de6);z-index:1}@media screen and (-ms-high-contrast:active){:host-context([data-whatinput=keyboard]):focus .nx-expansion-panel__header-content{box-shadow:0 0 0 2px background,0 0 0 6px windowText}:host{-ms-high-contrast-adjust:none}:host-context(.nx-expansion-panel--light.nx-expansion-panel--negative) .nx-expansion-panel__header-content,:host-context(.nx-expansion-panel--light.nx-expansion-panel--negative):not(.is-disabled) .nx-expansion-panel__header-content:hover,:host-context(.nx-expansion-panel--light:not(.nx-expansion-panel--negative)) .nx-expansion-panel__header-content,:host-context(.nx-expansion-panel--light:not(.nx-expansion-panel--negative)):not(.is-disabled) .nx-expansion-panel__header-content:hover,:host-context(.nx-expansion-panel--regular):not(.is-disabled) .nx-expansion-panel__header-content,:host-context(.nx-expansion-panel--regular):not(.is-disabled):not(.is-disabled) .nx-expansion-panel__header-content:hover{color:buttonText;background-color:buttonFace}:host-context(.nx-expansion-panel--light.nx-expansion-panel--negative) .nx-expansion-panel__header-content .nx-expansion-panel__chevron,:host-context(.nx-expansion-panel--light.nx-expansion-panel--negative):not(.is-disabled) .nx-expansion-panel__header-content:hover .nx-expansion-panel__chevron,:host-context(.nx-expansion-panel--light:not(.nx-expansion-panel--negative)) .nx-expansion-panel__header-content .nx-expansion-panel__chevron,:host-context(.nx-expansion-panel--light:not(.nx-expansion-panel--negative)):not(.is-disabled) .nx-expansion-panel__header-content:hover .nx-expansion-panel__chevron,:host-context(.nx-expansion-panel--regular):not(.is-disabled) .nx-expansion-panel__header-content .nx-expansion-panel__chevron,:host-context(.nx-expansion-panel--regular):not(.is-disabled):not(.is-disabled) .nx-expansion-panel__header-content:hover .nx-expansion-panel__chevron{color:buttonText}:host.is-disabled.is-disabled .nx-expansion-panel__header-content{color:GrayText;background-color:buttonFace}:host.is-disabled.is-disabled .nx-expansion-panel__header-content .nx-expansion-panel__chevron{color:GrayText}}"]
            }] }
];
/** @nocollapse */
NxExpansionPanelHeaderComponent.ctorParameters = () => [
    { type: NxExpansionPanelComponent, decorators: [{ type: Host }] },
    { type: ChangeDetectorRef }
];
if (false) {
    /**
     * @type {?}
     * @private
     */
    NxExpansionPanelHeaderComponent.prototype._parentChangeSubscription;
    /**
     * \@docs-private
     * @type {?}
     */
    NxExpansionPanelHeaderComponent.prototype.panel;
    /**
     * @type {?}
     * @private
     */
    NxExpansionPanelHeaderComponent.prototype._changeDetectorRef;
}
/**
 * This directive is to be used inside of the NxExpansionPanelHeader component.
 */
class NxExpansionPanelDescriptionDirective {
}
NxExpansionPanelDescriptionDirective.decorators = [
    { type: Directive, args: [{
                // tslint:disable-next-line:directive-selector
                selector: 'nx-expansion-panel-description',
                host: {
                    class: 'nx-expansion-panel__header-description'
                }
            },] }
];
/**
 * This directive is to be used inside of the NxExpansionPanelHeader component.
 */
class NxExpansionPanelTitleDirective {
}
NxExpansionPanelTitleDirective.decorators = [
    { type: Directive, args: [{
                // tslint:disable-next-line:directive-selector
                selector: 'nx-expansion-panel-title',
                host: {
                    class: 'nx-expansion-panel__header-title'
                }
            },] }
];

/**
 * @fileoverview added by tsickle
 * Generated from: accordion/accordion.module.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class NxAccordionModule {
}
NxAccordionModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    CommonModule,
                    PortalModule,
                    NxIconModule
                ],
                exports: [
                    NxAccordionDirective,
                    NxExpansionPanelComponent,
                    NxExpansionPanelHeaderComponent,
                    NxExpansionPanelDescriptionDirective,
                    NxExpansionPanelTitleDirective,
                    NxExpansionPanelBodyDirective
                ],
                declarations: [
                    NxAccordionDirective,
                    NxExpansionPanelComponent,
                    NxExpansionPanelHeaderComponent,
                    NxExpansionPanelDescriptionDirective,
                    NxExpansionPanelTitleDirective,
                    NxExpansionPanelBodyDirective
                ],
                providers: [],
            },] }
];

/**
 * @fileoverview added by tsickle
 * Generated from: accordion/public-api.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * Generated from: accordion/index.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * Generated from: tabs/tab-group-base.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * \@docs-private
 * @abstract
 */
class NxTabGroupBase {
}

/**
 * @fileoverview added by tsickle
 * Generated from: tabs/tab-header-outlet.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * \@docs-private
 */
class NxTabHeaderOutletComponent {
    /**
     * @param {?} _tabGroup
     */
    constructor(_tabGroup) {
        this._tabGroup = _tabGroup;
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this._appearanceSubscription = ((/** @type {?} */ (this._tabGroup)))._appearanceChange.subscribe((/**
         * @return {?}
         */
        () => {
            this.detach();
        }));
        this.attach();
    }
    /**
     * @return {?}
     */
    attach() {
        this._outlet.insert(this.content);
    }
    /**
     * @return {?}
     */
    detach() {
        /** @type {?} */
        const index = this._outlet.indexOf(this.content);
        if (index !== -1) {
            this._outlet.detach(index);
        }
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this._appearanceSubscription.unsubscribe();
    }
}
NxTabHeaderOutletComponent.decorators = [
    { type: Component, args: [{
                selector: 'nx-tab-header-outlet',
                template: '<ng-container #outlet></ng-container>'
            }] }
];
/** @nocollapse */
NxTabHeaderOutletComponent.ctorParameters = () => [
    { type: NxTabGroupBase }
];
NxTabHeaderOutletComponent.propDecorators = {
    _outlet: [{ type: ViewChild, args: ['outlet', { static: true, read: ViewContainerRef },] }],
    content: [{ type: Input }]
};
if (false) {
    /** @type {?} */
    NxTabHeaderOutletComponent.prototype._outlet;
    /** @type {?} */
    NxTabHeaderOutletComponent.prototype.content;
    /**
     * @type {?}
     * @private
     */
    NxTabHeaderOutletComponent.prototype._appearanceSubscription;
    /**
     * @type {?}
     * @private
     */
    NxTabHeaderOutletComponent.prototype._tabGroup;
}

/**
 * @fileoverview added by tsickle
 * Generated from: tabs/tab-label.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * \@docs-private
 */
class NxTabLabelDirective extends CdkPortal {
}
NxTabLabelDirective.decorators = [
    { type: Directive, args: [{ selector: '[nxTabLabel]' },] }
];

/**
 * @fileoverview added by tsickle
 * Generated from: tabs/tab-content.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Decorates the `ng-template` tags and reads out the template from it.
 */
class NxTabContentDirective {
    /**
     * @param {?} template
     */
    constructor(/** @docs-private */ template) {
        this.template = template;
    }
}
NxTabContentDirective.decorators = [
    { type: Directive, args: [{ selector: '[nxTabContent]' },] }
];
/** @nocollapse */
NxTabContentDirective.ctorParameters = () => [
    { type: TemplateRef }
];
if (false) {
    /**
     * \@docs-private
     * @type {?}
     */
    NxTabContentDirective.prototype.template;
}

/**
 * @fileoverview added by tsickle
 * Generated from: tabs/tab.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class NxTabComponent {
    /**
     * @param {?} _tabGroup
     */
    constructor(_tabGroup) {
        this._tabGroup = _tabGroup;
        this._disabled = false;
        /**
         * Emits whenever the internal state of the tab changes.
         */
        this._stateChanges = new Subject();
        /**
         * Whether the tab is currently active.
         */
        this.isActive = false;
        if (!this._tabGroup) {
            throw Error(`The nx-tab element has to be wrapped in a nx-tab-group to work.
      Please provide a nx-tab-group element and place your tabs inside it.`);
        }
    }
    /**
     * Content for the tab label given by `<ng-template nxTabLabel>`.
     * \@docs-private
     *
     * @return {?}
     */
    get templateLabel() { return this._templateLabel; }
    /**
     * @param {?} value
     * @return {?}
     */
    set templateLabel(value) {
        // Only update the templateLabel via query if there is actually
        // a nxTabLabel found. This works around an issue where a user may have
        // manually set `templateLabel` during creation mode, which would then get clobbered
        // by `undefined` when this query resolves.
        if (value) {
            this._templateLabel = value;
        }
    }
    /**
     * Sets the label of the tab shown in the tablist.
     * @return {?}
     */
    get label() {
        return this._label;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set label(value) {
        if (this._label !== value) {
            this._label = value;
        }
    }
    /**
     * Sets the tab to disabled.
     * @return {?}
     */
    get disabled() {
        return (this._tabGroup && ((/** @type {?} */ (this._tabGroup))).disabled) ?
            ((/** @type {?} */ (this._tabGroup))).disabled : this._disabled;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set disabled(value) {
        if (this._disabled !== value) {
            this._disabled = value;
        }
    }
    /**
     * \@docs-private
     * @return {?}
     */
    get headerViewRef() {
        return this._headerViewRef;
    }
    /**
     * \@docs-private
     * @return {?}
     */
    get contentViewRef() {
        // for lazy loading we only create the viewref when it is asked for
        if (!this._contentViewRef) {
            /** @type {?} */
            const contentTemplate = this._explicitContent || this._implicitContent;
            this._contentViewRef = contentTemplate.createEmbeddedView({});
        }
        return this._contentViewRef;
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        if (changes.hasOwnProperty('label') || changes.hasOwnProperty('disabled')) {
            this._stateChanges.next();
        }
    }
    /**
     * @return {?}
     */
    ngAfterContentInit() {
        if (this.templateLabel) {
            this._headerViewRef = this.templateLabel.createEmbeddedView({});
        }
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this._stateChanges.complete();
        this._contentViewRef.destroy();
        if (this._headerViewRef) {
            this._headerViewRef.destroy();
        }
    }
}
NxTabComponent.decorators = [
    { type: Component, args: [{
                selector: 'nx-tab',
                exportAs: 'nxTab',
                template: "<ng-template><ng-content></ng-content></ng-template>\n",
                changeDetection: ChangeDetectionStrategy.OnPush
            }] }
];
/** @nocollapse */
NxTabComponent.ctorParameters = () => [
    { type: NxTabGroupBase, decorators: [{ type: Inject, args: [NxTabGroupBase,] }, { type: Optional }, { type: Host }] }
];
NxTabComponent.propDecorators = {
    templateLabel: [{ type: ContentChild, args: [NxTabLabelDirective, { read: TemplateRef, static: true },] }],
    _implicitContent: [{ type: ViewChild, args: [TemplateRef, { static: true },] }],
    _explicitContent: [{ type: ContentChild, args: [NxTabContentDirective, { read: TemplateRef, static: true },] }],
    label: [{ type: Input }],
    disabled: [{ type: Input }]
};
if (false) {
    /**
     * @type {?}
     * @private
     */
    NxTabComponent.prototype._label;
    /**
     * @type {?}
     * @private
     */
    NxTabComponent.prototype._disabled;
    /**
     * Emits whenever the internal state of the tab changes.
     * @type {?}
     */
    NxTabComponent.prototype._stateChanges;
    /**
     * @type {?}
     * @private
     */
    NxTabComponent.prototype._templateLabel;
    /**
     * Template inside the NxTab view that contains an `<ng-content>`.
     * @type {?}
     */
    NxTabComponent.prototype._implicitContent;
    /**
     * Template provided in the tab content that will be used if present, used to enable lazy-loading
     * @type {?}
     */
    NxTabComponent.prototype._explicitContent;
    /**
     * @type {?}
     * @private
     */
    NxTabComponent.prototype._headerViewRef;
    /**
     * @type {?}
     * @private
     */
    NxTabComponent.prototype._contentViewRef;
    /**
     * Whether the tab is currently active.
     * @type {?}
     */
    NxTabComponent.prototype.isActive;
    /**
     * @type {?}
     * @private
     */
    NxTabComponent.prototype._tabGroup;
}

/**
 * @fileoverview added by tsickle
 * Generated from: tabs/tab-body.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * \@docs-private
 */
class NxTabBodyComponent {
    /**
     * @param {?} _tabGroup
     */
    constructor(_tabGroup) {
        this._tabGroup = _tabGroup;
        this._active = false;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set active(value) {
        this._active = coerceBooleanProperty(value);
        if (this._active) {
            this.attach();
        }
        else {
            this.detach();
        }
    }
    /**
     * @return {?}
     */
    get active() {
        return this._active;
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this._appearanceSubscription = ((/** @type {?} */ (this._tabGroup)))._appearanceChange.subscribe((/**
         * @return {?}
         */
        () => {
            this.detach();
        }));
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this._appearanceSubscription.unsubscribe();
    }
    /**
     * @return {?}
     */
    attach() {
        this._outlet.insert(this.tab.contentViewRef);
    }
    /**
     * @return {?}
     */
    detach() {
        /** @type {?} */
        const index = this._outlet.indexOf(this.tab.contentViewRef);
        if (index !== -1) {
            this._outlet.detach(index);
        }
    }
}
NxTabBodyComponent.decorators = [
    { type: Component, args: [{
                selector: 'nx-tab-body',
                template: "<ng-container #outlet></ng-container>",
                changeDetection: ChangeDetectionStrategy.OnPush,
                styles: [":host{display:block}"]
            }] }
];
/** @nocollapse */
NxTabBodyComponent.ctorParameters = () => [
    { type: NxTabGroupBase }
];
NxTabBodyComponent.propDecorators = {
    _outlet: [{ type: ViewChild, args: ['outlet', { static: true, read: ViewContainerRef },] }],
    tab: [{ type: Input }],
    active: [{ type: Input }]
};
if (false) {
    /**
     * @type {?}
     * @private
     */
    NxTabBodyComponent.prototype._appearanceSubscription;
    /** @type {?} */
    NxTabBodyComponent.prototype._outlet;
    /** @type {?} */
    NxTabBodyComponent.prototype.tab;
    /**
     * @type {?}
     * @private
     */
    NxTabBodyComponent.prototype._active;
    /**
     * @type {?}
     * @private
     */
    NxTabBodyComponent.prototype._tabGroup;
}

/**
 * @fileoverview added by tsickle
 * Generated from: tabs/tab-label-wrapper.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * \@docs-private
 */
class NxTabLabelWrapperDirective {
    /**
     * @param {?} elementRef
     */
    constructor(elementRef) {
        this.elementRef = elementRef;
        this._disabled = false;
    }
    /**
     * Whether the tab group is disabled. Default: false.
     * @return {?}
     */
    get disabled() {
        return this._disabled;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set disabled(value) {
        /** @type {?} */
        const newValue = coerceBooleanProperty(value);
        if (this.disabled !== newValue) {
            this._disabled = newValue;
        }
    }
    /**
     * @return {?}
     */
    focus() {
        this.elementRef.nativeElement.focus();
    }
}
NxTabLabelWrapperDirective.decorators = [
    { type: Directive, args: [{ selector: '[nxTabLabelWrapper]' },] }
];
/** @nocollapse */
NxTabLabelWrapperDirective.ctorParameters = () => [
    { type: ElementRef }
];
NxTabLabelWrapperDirective.propDecorators = {
    disabled: [{ type: Input }]
};
if (false) {
    /**
     * @type {?}
     * @private
     */
    NxTabLabelWrapperDirective.prototype._disabled;
    /** @type {?} */
    NxTabLabelWrapperDirective.prototype.elementRef;
}

/**
 * @fileoverview added by tsickle
 * Generated from: tabs/tab-header.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * \@docs-private
 */
class NxTabHeaderComponent {
    /**
     * @param {?} _changeDetectorRef
     */
    constructor(_changeDetectorRef) {
        this._changeDetectorRef = _changeDetectorRef;
        this._selectedIndex = 0;
        this._autoselect = true;
        this.selectFocusedIndex = new EventEmitter();
        this.indexFocused = new EventEmitter();
    }
    /**
     * @return {?}
     */
    get selectedIndex() {
        return this._selectedIndex;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set selectedIndex(value) {
        this._selectedIndex = value;
        if (this._keyManager) {
            this._keyManager.updateActiveItem(value);
        }
    }
    /**
     * @return {?}
     */
    get focusIndex() {
        return this._keyManager ? this._keyManager.activeItemIndex : 0;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set focusIndex(value) {
        if (!this._isValidIndex(value) || this.focusIndex === value || !this._keyManager) {
            return;
        }
        this._keyManager.setActiveItem(value);
    }
    /**
     * @return {?}
     */
    get autoselect() {
        return this._autoselect;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set autoselect(value) {
        this._autoselect = value;
    }
    /**
     * @return {?}
     */
    ngAfterContentInit() {
        this._keyManager = new FocusKeyManager(this.labels).withHorizontalOrientation('ltr').withWrap();
        this._keyManager.updateActiveItem(0);
        this._changeDetectorRef.markForCheck();
    }
    /**
     * @private
     * @param {?} idx
     * @return {?}
     */
    _isValidIndex(idx) {
        if (!this.labels) {
            return true;
        }
        /** @type {?} */
        const tab = this.labels.toArray()[idx] || null;
        return !!tab && !tab.disabled;
    }
    /**
     * Handles keyboard inputs on the labels
     * If autoselect is enabled the tab gets changed immediately
     * If autoselect is disabled only the focus changes but the user still has to select the item
     * by himself
     * @param {?} event
     * @return {?}
     */
    handleKeydown(event) {
        switch (event.keyCode) {
            case HOME:
                this._keyManager.setFirstItemActive();
                event.preventDefault();
                break;
            case END:
                this._keyManager.setLastItemActive();
                event.preventDefault();
                break;
            case ENTER:
            case SPACE:
                this.selectFocusedIndex.emit(this._keyManager.activeItemIndex);
                event.preventDefault();
                break;
            default:
                this._keyManager.onKeydown(event);
        }
        if (this.autoselect) {
            this.selectFocusedIndex.emit(this._keyManager.activeItemIndex);
        }
        else if (event.keyCode !== ENTER && event.keyCode !== SPACE) {
            this.indexFocused.emit(this._keyManager.activeItemIndex);
        }
    }
}
NxTabHeaderComponent.decorators = [
    { type: Component, args: [{
                selector: 'nx-tab-header',
                template: "<div class=\"nx-tab-header\" (keydown)=\"handleKeydown($event)\" role=\"tablist\">\n  <ng-content></ng-content>\n</div>",
                changeDetection: ChangeDetectionStrategy.OnPush,
                styles: [":host{display:block}.nx-tab-header{display:flex;align-items:flex-end;justify-content:center;padding:60px 0}"]
            }] }
];
/** @nocollapse */
NxTabHeaderComponent.ctorParameters = () => [
    { type: ChangeDetectorRef }
];
NxTabHeaderComponent.propDecorators = {
    selectedIndex: [{ type: Input }],
    autoselect: [{ type: Input }],
    selectFocusedIndex: [{ type: Output }],
    indexFocused: [{ type: Output }],
    labels: [{ type: ContentChildren, args: [NxTabLabelWrapperDirective,] }]
};
if (false) {
    /**
     * @type {?}
     * @private
     */
    NxTabHeaderComponent.prototype._keyManager;
    /**
     * @type {?}
     * @private
     */
    NxTabHeaderComponent.prototype._selectedIndex;
    /**
     * @type {?}
     * @private
     */
    NxTabHeaderComponent.prototype._autoselect;
    /** @type {?} */
    NxTabHeaderComponent.prototype.selectFocusedIndex;
    /** @type {?} */
    NxTabHeaderComponent.prototype.indexFocused;
    /** @type {?} */
    NxTabHeaderComponent.prototype.labels;
    /**
     * @type {?}
     * @private
     */
    NxTabHeaderComponent.prototype._changeDetectorRef;
}

/**
 * @fileoverview added by tsickle
 * Generated from: tabs/tab-group.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class NxTabChangeEvent {
}
if (false) {
    /**
     * The index of the selected or focused tab.
     * @type {?}
     */
    NxTabChangeEvent.prototype.index;
    /**
     * The component instance of the selected or focused tab.
     * @type {?}
     */
    NxTabChangeEvent.prototype.tab;
}
/** @type {?} */
let nextId$a = 0;
/** @type {?} */
const MOBILE_BREAKPOINT = 480;
class NxTabGroupComponent {
    /**
     * @param {?} _changeDetectorRef
     */
    constructor(_changeDetectorRef) {
        this._changeDetectorRef = _changeDetectorRef;
        this._selectedIndex = null;
        this._negative = false;
        this._disabled = false;
        this._indexToSelect = 0;
        this._autoselect = true;
        this._mobileAccordion = true;
        this._showAccordion = false;
        /**
         * An event emitted when the selected tab has changed.
         */
        this.selectedIndexChange = new EventEmitter();
        /**
         * An event emitted when the selected tab has changed.
         */
        this.selectedTabChange = new EventEmitter();
        /**
         * An event emitted when focus has changed within a tab group.
         *
         * **Note:** is not supported in mobile view.
         */
        this.focusChange = new EventEmitter();
        /**
         * Subscription to tabs being added/removed.
         */
        this._tabsSubscription = Subscription.EMPTY;
        /**
         * Subscription to changes in the tab labels.
         */
        this._tabLabelSubscription = Subscription.EMPTY;
        this._disabledTabsCache = [];
        this._appearanceChange = new Subject();
        this._groupId = nextId$a++;
    }
    /**
     * Sets the selected tab.
     * @return {?}
     */
    get selectedIndex() {
        return this._selectedIndex;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set selectedIndex(value) {
        this._indexToSelect = coerceNumberProperty(value, null);
    }
    /**
     * Whether the negative set of styling should be used.
     * @return {?}
     */
    get negative() {
        return this._negative;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set negative(value) {
        if (value !== this._negative) {
            this._negative = coerceBooleanProperty(value);
        }
    }
    /**
     * Whether the tab group is disabled. Default: false.
     * @return {?}
     */
    get disabled() {
        return this._disabled;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set disabled(value) {
        if (value !== this._disabled) {
            this._disabled = coerceBooleanProperty(value);
        }
    }
    /**
     * Whether the tab should be immediately selected on focus.
     * @return {?}
     */
    get autoselect() {
        return this._autoselect;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set autoselect(value) {
        this._autoselect = coerceBooleanProperty(value);
    }
    /**
     * Whether the tabs should to accordion on mobile viewports.
     * @return {?}
     */
    get mobileAccordion() {
        return this._mobileAccordion;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set mobileAccordion(value) {
        this._mobileAccordion = coerceBooleanProperty(value);
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this._switchAppearance(window.innerWidth);
    }
    /**
     * @return {?}
     */
    ngAfterContentInit() {
        this._subscribeToTabLabels();
        // Subscribe to changes in the amount of tabs, in order to be
        // able to re-render the content as new tabs are added or removed.
        this._tabsSubscription = this.tabs.changes.subscribe((/**
         * @return {?}
         */
        () => {
            /** @type {?} */
            const indexToSelect = this._clampTabIndex(this._indexToSelect);
            // Maintain the previously-selected tab if a new tab is added or removed and there is no
            // explicit change that selects a different tab.
            if (indexToSelect === this._selectedIndex) {
                /** @type {?} */
                const tabs = this.tabs.toArray();
                for (let i = 0; i < tabs.length; i++) {
                    if (tabs[i].isActive) {
                        // Assign both to the `_indexToSelect` and `_selectedIndex` so we don't fire a changed
                        // event, otherwise the consumer may end up in an infinite loop in some edge cases like
                        // adding a tab within the `selectedIndexChange` event.
                        this._indexToSelect = this._selectedIndex = i;
                        break;
                    }
                }
            }
            this._changeDetectorRef.markForCheck();
        }));
    }
    /**
     * After the content is checked, this component knows what tabs have been defined
     * and what the selected index should be.
     * @return {?}
     */
    ngAfterContentChecked() {
        // Don't clamp the `indexToSelect` immediately in the setter because it can happen that
        // the amount of tabs changes before the actual change detection runs.
        /** @type {?} */
        let indexToSelect = this._indexToSelect = this._clampTabIndex(this._indexToSelect);
        // If the active tab is disabled select the next focusable tab
        // if all tabs are disabled, allow selection of disabled active tab.
        if (!this.disabled && this.tabs.toArray()[indexToSelect].disabled) {
            /** @type {?} */
            const nextFocusable = this.tabs.toArray()
                .map((/**
             * @param {?} tab
             * @param {?} index
             * @return {?}
             */
            (tab, index) => ({ tab: tab, index: index })))
                .find((/**
             * @param {?} item
             * @return {?}
             */
            item => !item.tab.disabled));
            indexToSelect = nextFocusable ? nextFocusable.index : indexToSelect;
        }
        // If the index to select was disabled previously leave the selection on the current
        // so that the selection does not jump from one to another tab.
        if (this._disabledTabsCache[this._indexToSelect]) {
            this._indexToSelect = this.selectedIndex;
        }
        // If there is a change in selected index, emit a change event. Should not trigger if
        // the selected index has not yet been initialized.
        if (this._selectedIndex !== indexToSelect) {
            /** @type {?} */
            const isFirstRun = this._selectedIndex == null;
            if (!isFirstRun) {
                this.selectedTabChange.emit(this._createChangeEvent(indexToSelect));
            }
            // Changing these values after change detection has run
            // since the checked content may contain references to them.
            Promise.resolve().then((/**
             * @return {?}
             */
            () => {
                this.tabs.forEach((/**
                 * @param {?} tab
                 * @param {?} index
                 * @return {?}
                 */
                (tab, index) => tab.isActive = index === indexToSelect));
                if (!isFirstRun) {
                    this.selectedIndexChange.emit(indexToSelect);
                }
            }));
        }
        if (this._selectedIndex !== indexToSelect) {
            this._selectedIndex = indexToSelect;
            this._changeDetectorRef.markForCheck();
        }
        // cache the previous disabled status of all tabs
        if (!this.disabled) {
            this.tabs.toArray().forEach((/**
             * @param {?} tab
             * @param {?} index
             * @return {?}
             */
            (tab, index) => this._disabledTabsCache[index] = tab.disabled));
        }
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this._tabsSubscription.unsubscribe();
        this._tabLabelSubscription.unsubscribe();
    }
    /**
     * Subscribes to changes in the tab labels. This is needed, because the \@Input for the label is
     * on the NxTab component, whereas the data binding is inside the NxTabGroup. In order for the
     * binding to be updated, we need to subscribe to changes in it and trigger change detection
     * manually.
     * @private
     * @return {?}
     */
    _subscribeToTabLabels() {
        if (this._tabLabelSubscription) {
            this._tabLabelSubscription.unsubscribe();
        }
        this._tabLabelSubscription = merge(...this.tabs.map((/**
         * @param {?} tab
         * @return {?}
         */
        tab => tab._stateChanges)))
            .subscribe((/**
         * @return {?}
         */
        () => this._changeDetectorRef.markForCheck()));
    }
    /**
     * Clamps the given index to the bounds of 0 and the tabs length.
     * @private
     * @param {?} index
     * @return {?}
     */
    _clampTabIndex(index) {
        // Note the `|| 0`, which ensures that values like NaN can't get through
        // and which would otherwise throw the component into an infinite loop
        // (since Math.max(NaN, 0) === NaN).
        return Math.min(this.tabs.length - 1, Math.max(index || 0, 0));
    }
    /**
     * \@docs-private
     * @param {?} index
     * @return {?}
     */
    focusChanged(index) {
        this.focusChange.emit(this._createChangeEvent(index));
    }
    /**
     * @private
     * @param {?} index
     * @return {?}
     */
    _createChangeEvent(index) {
        /** @type {?} */
        const event = new NxTabChangeEvent;
        event.index = index;
        if (this.tabs && this.tabs.length) {
            event.tab = this.tabs.toArray()[index];
        }
        return event;
    }
    /**
     * \@docs-private
     * @param {?} index
     * @return {?}
     */
    handleClick(index) {
        /** @type {?} */
        const clickedTab = this.tabs.toArray()[index];
        if (!this.disabled && !clickedTab.disabled) {
            this.selectedIndex = this.tabHeader.focusIndex = index;
        }
    }
    /**
     * \@docs-private
     * Returns the tabindex for a tab label
     * @param {?} tab
     * @param {?} idx
     * @return {?}
     */
    getTabIndex(tab, idx) {
        return (this.selectedIndex === idx && !tab.disabled && !this.disabled) ? 0 : -1;
    }
    /**
     * Returns a unique id for each tab label element
     * @param {?} i
     * @return {?}
     */
    _getTabLabelId(i) {
        return `nx-tab-label-${this._groupId}-${i}`;
    }
    /**
     * Returns a unique id for each tab content element
     * @param {?} i
     * @return {?}
     */
    _getTabContentId(i) {
        return `nx-tab-content-${this._groupId}-${i}`;
    }
    /**
     * \@docs-private
     * @param {?} event
     * @return {?}
     */
    onResize(event) {
        this._switchAppearance(event.target.innerWidth);
    }
    /**
     * @private
     * @param {?} viewPortWidth
     * @return {?}
     */
    _switchAppearance(viewPortWidth) {
        if (!this._mobileAccordion) {
            return;
        }
        // notify the outlets to detach the viewrefs for header and body before
        // we switch the appearance. this way we only instantiate the templates
        // once so that they do not get destroyed during the switch
        if (viewPortWidth <= MOBILE_BREAKPOINT && !this._showAccordion) {
            this._appearanceChange.next();
            this._showMobileVersion();
        }
        else if (viewPortWidth > MOBILE_BREAKPOINT && this._showAccordion) {
            this._appearanceChange.next();
            this._showDesktopVersion();
        }
    }
    /**
     * @private
     * @return {?}
     */
    _showMobileVersion() {
        this._showAccordion = true;
        this._changeDetectorRef.markForCheck();
    }
    /**
     * @private
     * @return {?}
     */
    _showDesktopVersion() {
        this._showAccordion = false;
        this._changeDetectorRef.markForCheck();
    }
    /**
     * Emulate the tab change event when an accordion panel is opened in
     * mobile viewports.
     * @param {?} index
     * @return {?}
     */
    _panelOpened(index) {
        this.selectedIndex = index;
    }
}
NxTabGroupComponent.decorators = [
    { type: Component, args: [{
                selector: 'nx-tab-group',
                template: "\n\n  <ng-container *ngIf=\"!_showAccordion\">\n  <nx-tab-header\n      #tabHeader\n      [selectedIndex]=\"selectedIndex\"\n      (selectFocusedIndex)=\"selectedIndex = $event\"\n      (indexFocused)=\"focusChanged($event)\"\n      [autoselect]=\"autoselect\">\n    <button\n      type=\"button\"\n      nxTabLabelWrapper\n      *ngFor=\"let tab of tabs; let i = index\"\n      role=\"tab\"\n      (click)=\"handleClick(i)\"\n      class=\"nx-tab-header__item\"\n      [id]=\"_getTabLabelId(i)\"\n      [attr.aria-controls]=\"_getTabContentId(i)\"\n      [attr.aria-selected]=\"selectedIndex == i\"\n      [attr.tabindex]=\"getTabIndex(tab, i)\"\n      [disabled]=\"tab.disabled\"\n      [class.nx-tab-header__item--disabled]=\"tab.disabled\"\n      [class.nx-tab-header__item--active]=\"selectedIndex == i\">\n      <div class=\"nx-tab-label__content\">\n        <nx-tab-header-outlet *ngIf=\"tab.templateLabel\" [content]=\"tab.headerViewRef\"></nx-tab-header-outlet>\n        <ng-container *ngIf=\"!tab.templateLabel\">{{tab.label}}</ng-container>\n      </div>\n    </button>\n  </nx-tab-header>\n\n  <div class=\"nx-tab-body__container\">\n    <nx-tab-body\n      *ngFor=\"let tab of tabs; let i = index\"\n      [id]=\"_getTabContentId(i)\"\n      role=\"tabpanel\"\n      [attr.tabindex]=\"(selectedIndex == i) ? 0 : -1\"\n      class=\"nx-tab__body\"\n      [attr.aria-labelledby]=\"_getTabContentId(i)\"\n      [class.nx-tab__body--active]=\"selectedIndex == i\"\n      [tab]=\"tab\"\n      [active]=\"selectedIndex == i\"\n    ></nx-tab-body>\n  </div>\n</ng-container>\n\n<nx-accordion *ngIf=\"_showAccordion\" [negative]=\"negative\">\n  <nx-expansion-panel *ngFor=\"let tab of tabs; let i = index\"\n                      [expanded]=\"selectedIndex === i\"\n                      (opened)=\"_panelOpened(i)\"\n                      [disabled]=\"tab.disabled\"\n  >\n    <nx-expansion-panel-header>\n      <nx-expansion-panel-title>\n        <nx-tab-header-outlet *ngIf=\"tab.templateLabel\" [content]=\"tab.headerViewRef\"></nx-tab-header-outlet>\n        <ng-container *ngIf=\"!tab.templateLabel\">{{tab.label}}</ng-container>\n      </nx-expansion-panel-title>\n    </nx-expansion-panel-header>\n    <!-- this is not lazy loading this is a trick because the portal gets added here -->\n    <!-- so we could rewrite the tab-body component that it takes care of \"lazy loading\" and the\n    accordion wouldn't know about it -->\n    <!-- active=true is a trick because we want to keep the content attached for better user experience along with expansion panel animation.  -->\n    <nx-tab-body [active]=\"true\" [tab]=\"tab\"></nx-tab-body>\n  </nx-expansion-panel>\n</nx-accordion>\n",
                changeDetection: ChangeDetectionStrategy.OnPush,
                host: {
                    '[class.is-negative]': 'negative',
                    '[class.is-disabled]': 'disabled'
                },
                providers: [{ provide: NxTabGroupBase, useExisting: NxTabGroupComponent }],
                styles: [":host{display:block}.nx-tab-header__item{font-size:18px;font-size:var(--tab-item-font-size,18px);line-height:24px;line-height:var(--tab-item-line-height,24px);font-weight:400;font-weight:var(--tab-item-font-weight,400);letter-spacing:.2px;letter-spacing:var(--tab-item-letter-spacing,.2px);text-decoration:none;border:#006192;background:0 0;color:#006192;color:var(--tab-item-color,#006192);border-color:var(--tab-item-border-color,#006192);border-bottom-width:2px;border-bottom-style:solid;padding:0 16px 6px;outline:0;margin:0}.nx-tab-header__item:hover:not(.nx-tab-header__item--disabled){cursor:pointer}.nx-tab-header__item::-moz-focus-inner{border:0}.nx-tab-header__item--active{border-width:4px;font-weight:700;transition:font-weight .3s;padding-bottom:4px}@media screen and (-ms-high-contrast:active){.nx-tab-header__item{background-color:buttonFace;border-color:buttonText;color:buttonText;-ms-high-contrast-adjust:none}.nx-tab-header__item--active{background-color:highlight;color:highlightText;border-color:highlight}}.nx-tab-header__item--disabled{border-color:#c2c2c2;border-color:var(--tab-item-disabled-border-color,#c2c2c2);color:#c2c2c2;color:var(--tab-item-disabled-color,#c2c2c2);cursor:not-allowed}.nx-tab-label__content{display:inline-flex;justify-content:center;align-items:center;white-space:nowrap}:host-context([data-whatinput=keyboard]) .nx-tab-header__item:focus{box-shadow:0 0 0 2px #fff,0 0 0 6px #009de6;box-shadow:var(--focus-box-shadow,0 0 0 2px #fff,0 0 0 6px #009de6);border-radius:4px}@media screen and (-ms-high-contrast:active){.nx-tab-header__item--disabled{border-color:GrayText;background-color:buttonFace;color:GrayText}:host-context([data-whatinput=keyboard]) .nx-tab-header__item:focus{box-shadow:0 0 0 2px background,0 0 0 6px windowText}}:host(.is-negative){color:#fff}:host(.is-negative) .nx-tab-header__item{color:#fff;border-bottom-color:#fff}:host(.is-negative) .nx-tab-header__item.nx-tab-header__item--disabled{border-color:rgba(255,255,255,.4);border-color:var(--tab-item-disabled-border-color,#c2c2c2);color:var(--tab-item-disabled-color,#c2c2c2);cursor:not-allowed;color:rgba(255,255,255,.4);color:var(--tab-item-disabled-negative-color,rgba(255,255,255,.4));border-color:var(--tab-item-disabled-negative-color,rgba(255,255,255,.4))}@media screen and (-ms-high-contrast:active){:host(.is-negative) .nx-tab-header__item.nx-tab-header__item--disabled{border-color:GrayText;background-color:buttonFace;color:GrayText}}:host(.is-disabled){cursor:not-allowed}:host(.is-disabled.is-negative) .nx-tab-header__item{border-color:rgba(255,255,255,.4);border-color:var(--tab-item-disabled-border-color,#c2c2c2);color:var(--tab-item-disabled-color,#c2c2c2);cursor:not-allowed;color:rgba(255,255,255,.4);color:var(--tab-item-disabled-negative-color,rgba(255,255,255,.4));border-color:var(--tab-item-disabled-negative-color,rgba(255,255,255,.4))}@media screen and (-ms-high-contrast:active){:host(.is-disabled.is-negative) .nx-tab-header__item{border-color:GrayText;background-color:buttonFace}:host(.is-negative){color:buttonText}:host(.is-negative) .nx-tab-header__item{color:buttonText;border-bottom-color:buttonText}:host(.is-negative) .nx-tab-header__item--active{background-color:highlight;color:highlightText;border-color:highlight;-ms-high-contrast-adjust:none}:host(.is-disabled.is-negative) .nx-tab-header__item{color:GrayText;border-bottom-color:GrayText}}"]
            }] }
];
/** @nocollapse */
NxTabGroupComponent.ctorParameters = () => [
    { type: ChangeDetectorRef }
];
NxTabGroupComponent.propDecorators = {
    tabs: [{ type: ContentChildren, args: [NxTabComponent,] }],
    tabBodyChildren: [{ type: ViewChildren, args: [NxTabBodyComponent,] }],
    tabHeader: [{ type: ViewChild, args: ['tabHeader', { static: false },] }],
    panels: [{ type: ViewChildren, args: [NxExpansionPanelComponent$1,] }],
    accordion: [{ type: ViewChild, args: [NxAccordionDirective$1, { static: false },] }],
    selectedIndex: [{ type: Input }],
    negative: [{ type: Input }],
    disabled: [{ type: Input }],
    autoselect: [{ type: Input }],
    mobileAccordion: [{ type: Input }],
    selectedIndexChange: [{ type: Output }],
    selectedTabChange: [{ type: Output }],
    focusChange: [{ type: Output }],
    onResize: [{ type: HostListener, args: ['window:resize', ['$event'],] }]
};
if (false) {
    /**
     * @type {?}
     * @private
     */
    NxTabGroupComponent.prototype._selectedIndex;
    /**
     * @type {?}
     * @private
     */
    NxTabGroupComponent.prototype._groupId;
    /**
     * @type {?}
     * @private
     */
    NxTabGroupComponent.prototype._negative;
    /**
     * @type {?}
     * @private
     */
    NxTabGroupComponent.prototype._disabled;
    /**
     * @type {?}
     * @private
     */
    NxTabGroupComponent.prototype._indexToSelect;
    /**
     * @type {?}
     * @private
     */
    NxTabGroupComponent.prototype._autoselect;
    /**
     * @type {?}
     * @private
     */
    NxTabGroupComponent.prototype._mobileAccordion;
    /** @type {?} */
    NxTabGroupComponent.prototype._showAccordion;
    /**
     * \@docs-private
     * @type {?}
     */
    NxTabGroupComponent.prototype.tabs;
    /**
     * \@docs-private
     * @type {?}
     */
    NxTabGroupComponent.prototype.tabBodyChildren;
    /**
     * \@docs-private
     * @type {?}
     */
    NxTabGroupComponent.prototype.tabHeader;
    /**
     * \@docs-private
     * @type {?}
     */
    NxTabGroupComponent.prototype.panels;
    /**
     * \@docs-private
     * @type {?}
     */
    NxTabGroupComponent.prototype.accordion;
    /**
     * An event emitted when the selected tab has changed.
     * @type {?}
     */
    NxTabGroupComponent.prototype.selectedIndexChange;
    /**
     * An event emitted when the selected tab has changed.
     * @type {?}
     */
    NxTabGroupComponent.prototype.selectedTabChange;
    /**
     * An event emitted when focus has changed within a tab group.
     *
     * **Note:** is not supported in mobile view.
     * @type {?}
     */
    NxTabGroupComponent.prototype.focusChange;
    /**
     * Subscription to tabs being added/removed.
     * @type {?}
     * @private
     */
    NxTabGroupComponent.prototype._tabsSubscription;
    /**
     * Subscription to changes in the tab labels.
     * @type {?}
     * @private
     */
    NxTabGroupComponent.prototype._tabLabelSubscription;
    /**
     * @type {?}
     * @private
     */
    NxTabGroupComponent.prototype._disabledTabsCache;
    /** @type {?} */
    NxTabGroupComponent.prototype._appearanceChange;
    /**
     * @type {?}
     * @private
     */
    NxTabGroupComponent.prototype._changeDetectorRef;
}

/**
 * @fileoverview added by tsickle
 * Generated from: tabs/tab-nav-bar.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class NxTabNavBarComponent {
    /**
     * @param {?} _changeDetectorRef
     */
    constructor(_changeDetectorRef) {
        this._changeDetectorRef = _changeDetectorRef;
        this._negative = false;
        this._disabled = false;
    }
    /**
     * Whether the tab nav bar has negative styling.
     * @param {?} value
     * @return {?}
     */
    set negative(value) {
        /** @type {?} */
        const newValue = coerceBooleanProperty(value);
        if (newValue !== this.negative) {
            this._negative = newValue;
            this._changeDetectorRef.markForCheck();
        }
    }
    /**
     * @return {?}
     */
    get negative() {
        return this._negative;
    }
    /**
     * Whether the tab nav bar has disabled styling.
     * @param {?} value
     * @return {?}
     */
    set disabled(value) {
        /** @type {?} */
        const newValue = coerceBooleanProperty(value);
        if (newValue !== this.disabled) {
            this._disabled = newValue;
            this._changeDetectorRef.markForCheck();
        }
    }
    /**
     * @return {?}
     */
    get disabled() {
        return this._disabled;
    }
}
NxTabNavBarComponent.decorators = [
    { type: Component, args: [{
                selector: 'nx-tab-nav-bar',
                template: "<ng-content></ng-content>",
                changeDetection: ChangeDetectionStrategy.OnPush,
                host: {
                    '[class.is-negative]': 'negative',
                    '[class.is-disabled]': 'disabled',
                    'role': 'navigation',
                },
                styles: [":host{display:flex;align-items:flex-end;justify-content:center}:host ::ng-deep a.nx-tab-link{font-size:18px;font-size:var(--tab-item-font-size,18px);line-height:24px;line-height:var(--tab-item-line-height,24px);font-weight:400;font-weight:var(--tab-item-font-weight,400);letter-spacing:.2px;letter-spacing:var(--tab-item-letter-spacing,.2px);text-decoration:none;border:#006192;background:0 0;color:#006192;color:var(--tab-item-color,#006192);border-color:var(--tab-item-border-color,#006192);border-bottom-width:2px;border-bottom-style:solid;padding:0 16px 6px;outline:0;margin:0}:host ::ng-deep a.nx-tab-link.is-active{border-width:4px;font-weight:700;transition:font-weight .3s;padding-bottom:4px}@media screen and (-ms-high-contrast:active){:host ::ng-deep a.nx-tab-link{background-color:buttonFace;border-color:buttonText;color:buttonText;-ms-high-contrast-adjust:none}:host ::ng-deep a.nx-tab-link.is-active{background-color:highlight;color:highlightText;border-color:highlight}}:host(.is-negative){color:#fff}:host(.is-negative) ::ng-deep a.nx-tab-link{color:#fff;border-bottom-color:#fff}:host(.is-negative) ::ng-deep a.nx-tab-link.is-disabled{color:rgba(255,255,255,.4);color:var(--tab-item-disabled-negative-color,rgba(255,255,255,.4));border-color:rgba(255,255,255,.4);border-color:var(--tab-item-disabled-negative-color,rgba(255,255,255,.4))}:host ::ng-deep a.nx-tab-link.is-disabled{border-color:#c2c2c2;border-color:var(--tab-item-disabled-border-color,#c2c2c2);color:#c2c2c2;color:var(--tab-item-disabled-color,#c2c2c2);cursor:not-allowed}@media screen and (-ms-high-contrast:active){:host(.is-negative) ::ng-deep a.nx-tab-link.is-active{background-color:highlight;color:highlightText;border-color:windowFrame}:host ::ng-deep a.nx-tab-link.is-disabled{border-color:GrayText;background-color:buttonFace;color:GrayText}}:host(.is-disabled){cursor:not-allowed}:host(.is-disabled.is-negative) ::ng-deep a.nx-tab-link{color:rgba(255,255,255,.4);color:var(--tab-item-disabled-negative-color,rgba(255,255,255,.4));border-color:rgba(255,255,255,.4);border-color:var(--tab-item-disabled-negative-color,rgba(255,255,255,.4))}:host-context([data-whatinput=keyboard]) ::ng-deep .nx-tab-link:not(.is-disabled):focus{box-shadow:0 0 0 2px #fff,0 0 0 6px #009de6;box-shadow:var(--focus-box-shadow,0 0 0 2px #fff,0 0 0 6px #009de6);border-radius:4px}@media screen and (-ms-high-contrast:active){:host-context([data-whatinput=keyboard]) ::ng-deep .nx-tab-link:not(.is-disabled):focus{box-shadow:0 0 0 2px background,0 0 0 6px windowText}:host(.is-negative){color:buttonText}:host(.is-negative) ::ng-deep a.nx-tab-link{color:buttonText;border-bottom-color:buttonText}:host(.is-negative) ::ng-deep a.nx-tab-link.is-active{background-color:highlight;color:highlightText;border-color:highlight}:host(.is-negative) ::ng-deep a.nx-tab-link.is-disabled{color:GrayText;border-bottom-color:GrayText}}"]
            }] }
];
/** @nocollapse */
NxTabNavBarComponent.ctorParameters = () => [
    { type: ChangeDetectorRef }
];
NxTabNavBarComponent.propDecorators = {
    negative: [{ type: Input }],
    disabled: [{ type: Input }]
};
if (false) {
    /**
     * @type {?}
     * @private
     */
    NxTabNavBarComponent.prototype._negative;
    /**
     * @type {?}
     * @private
     */
    NxTabNavBarComponent.prototype._disabled;
    /**
     * @type {?}
     * @private
     */
    NxTabNavBarComponent.prototype._changeDetectorRef;
}
class NxTabLinkDirective {
    /**
     * @param {?} _tabNavBar
     */
    constructor(_tabNavBar) {
        this._tabNavBar = _tabNavBar;
        this._active = false;
        this._disabled = false;
        if (!this._tabNavBar) {
            throw Error(`The nx-tab-link element has to be wrapped in a nx-tab-nav-bar to work.`);
        }
    }
    /**
     * Whether the tab link is active and has the active styling.
     * @return {?}
     */
    get active() {
        return this._active;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set active(value) {
        /** @type {?} */
        const newValue = coerceBooleanProperty(value);
        if (newValue !== this._active) {
            this._active = value;
        }
    }
    /**
     * Whether the tab link is disabled. Default: false.
     * @return {?}
     */
    get disabled() {
        return (this._tabNavBar && this._tabNavBar.disabled) ? this._tabNavBar.disabled : this._disabled;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set disabled(value) {
        /** @type {?} */
        const newValue = coerceBooleanProperty(value);
        if (newValue !== this._disabled) {
            this._disabled = value;
        }
    }
    /**
     * @return {?}
     */
    _getTabIndex() {
        return (this.disabled) ? '-1' : '0';
    }
}
NxTabLinkDirective.decorators = [
    { type: Directive, args: [{
                selector: '[nxTabLink]',
                host: {
                    '[class.nx-tab-link]': 'true',
                    '[class.is-active]': 'active',
                    '[class.is-disabled]': 'disabled',
                    '[attr.aria-current]': 'active',
                    '[attr.tabindex]': '_getTabIndex()',
                    '[attr.aria-disabled]': 'disabled.toString()',
                }
            },] }
];
/** @nocollapse */
NxTabLinkDirective.ctorParameters = () => [
    { type: NxTabNavBarComponent, decorators: [{ type: Optional }, { type: SkipSelf }] }
];
NxTabLinkDirective.propDecorators = {
    active: [{ type: Input }],
    disabled: [{ type: Input }]
};
if (false) {
    /**
     * @type {?}
     * @private
     */
    NxTabLinkDirective.prototype._active;
    /**
     * @type {?}
     * @private
     */
    NxTabLinkDirective.prototype._disabled;
    /**
     * @type {?}
     * @private
     */
    NxTabLinkDirective.prototype._tabNavBar;
}

/**
 * @fileoverview added by tsickle
 * Generated from: tabs/tabs.module.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class NxTabsModule {
}
NxTabsModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    CommonModule,
                    PortalModule,
                    NxAccordionModule$1
                ],
                exports: [
                    NxTabComponent,
                    NxTabGroupComponent,
                    NxTabLabelDirective,
                    NxTabLabelWrapperDirective,
                    NxTabHeaderComponent,
                    NxTabBodyComponent,
                    NxTabNavBarComponent,
                    NxTabLinkDirective,
                    NxTabContentDirective
                ],
                declarations: [
                    NxTabComponent,
                    NxTabGroupComponent,
                    NxTabLabelDirective,
                    NxTabLabelWrapperDirective,
                    NxTabHeaderComponent,
                    NxTabBodyComponent,
                    NxTabNavBarComponent,
                    NxTabLinkDirective,
                    NxTabContentDirective,
                    NxTabHeaderOutletComponent
                ],
                providers: [],
            },] }
];

/**
 * @fileoverview added by tsickle
 * Generated from: tabs/public-api.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * Generated from: core/breakpoints.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const BREAKPOINT_MOBILE = '(max-width: 703px)';
/** @type {?} */
const BREAKPOINT_TABLET = '(min-width: 704px) and (max-width: 992px)';
/** @type {?} */
const BREAKPOINT_DESKTOP = '(min-width: 993px)';

/**
 * @fileoverview added by tsickle
 * Generated from: core/mapped-styles.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class MappedStyles {
    /**
     * @param {?} mapping
     * @param {?=} baseClasses
     * @param {?=} _elementRef
     * @param {?=} _renderer
     */
    constructor(mapping, baseClasses = [], _elementRef, _renderer) {
        this.mapping = mapping;
        this.baseClasses = baseClasses;
        this._elementRef = _elementRef;
        this._renderer = _renderer;
        this.classNames = '';
    }
    /**
     * @return {?}
     */
    get classNames() {
        return this._classNames;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set classNames(value) {
        if (this._classNames === value) {
            return;
        }
        removeClasses(this._renderer, this._elementRef, this._classNamesSanitized);
        this._classNamesSanitized = mapClassNames(value, this.baseClasses, this.mapping);
        this._classNames = value;
        appendClasses(this._renderer, this._elementRef, this._classNamesSanitized);
    }
}
if (false) {
    /**
     * @type {?}
     * @private
     */
    MappedStyles.prototype._classNames;
    /**
     * @type {?}
     * @private
     */
    MappedStyles.prototype._classNamesSanitized;
    /**
     * @type {?}
     * @private
     */
    MappedStyles.prototype.mapping;
    /**
     * @type {?}
     * @private
     */
    MappedStyles.prototype.baseClasses;
    /**
     * @type {?}
     * @protected
     */
    MappedStyles.prototype._elementRef;
    /**
     * @type {?}
     * @protected
     */
    MappedStyles.prototype._renderer;
}

/**
 * @fileoverview added by tsickle
 * Generated from: core/public-api.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * Generated from: card/card.component.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class NxCardComponent {
    /**
     * @param {?} _changeDetectorRef
     * @param {?} tabindex
     */
    constructor(_changeDetectorRef, tabindex) {
        this._changeDetectorRef = _changeDetectorRef;
        this._disabled = false;
        /**
         * Event emitted when the selected value has changed.
         *
         * This output  property of the card is deprecated,
         * as its selectable properties are deprecated as well.
         * Please use the selectable card component instead.
         *
         * @deprecated
         * \@deletion-target 10.0.0
         */
        this.selectedChange = new EventEmitter();
        this._tabindex = tabindex;
    }
    /**
     * Whether this card is selectable or not.
     *
     * The selectable property of the card is deprecated.
     * Please use the selectable card component instead.
     *
     * @deprecated
     * \@deletion-target 10.0.0
     * @param {?} value
     * @return {?}
     */
    set selectable(value) {
        this._selectable = coerceBooleanProperty(value);
        this._changeDetectorRef.markForCheck();
    }
    /**
     * @return {?}
     */
    get selectable() {
        return this._selectable;
    }
    /**
     * Whether this card is selected or not.
     *
     * The selected property of the card is deprecated.
     * Please use the selectable card component instead.
     *
     * @deprecated
     * \@deletion-target 10.0.0
     * @param {?} value
     * @return {?}
     */
    set selected(value) {
        this._selected = coerceBooleanProperty(value);
        this._changeDetectorRef.markForCheck();
    }
    /**
     * @return {?}
     */
    get selected() {
        return this._selected;
    }
    /**
     * Whether a selectable card is disabled or not.
     *
     * The disabled property of the card will be deprecated,
     * as its selectable properties are deprecated as well.
     * Please use the selectable card component instead.
     *
     * @deprecated
     * \@deletion-target 10.0.0
     * @param {?} value
     * @return {?}
     */
    set disabled(value) {
        this._disabled = coerceBooleanProperty(value);
        this._changeDetectorRef.markForCheck();
    }
    /**
     * @return {?}
     */
    get disabled() {
        return this._disabled;
    }
    /**
     * @return {?}
     */
    _toggleSelected() {
        if (this.selectable && !this.disabled) {
            this.selected = !this.selected;
            this.selectedChange.emit(this.selected);
        }
    }
    /**
     * @return {?}
     */
    _getTabindex() {
        if (this.disabled) {
            return '-1';
        }
        if (this.selectable) {
            return this._tabindex || '0';
        }
        return this._tabindex || '';
    }
}
NxCardComponent.decorators = [
    { type: Component, args: [{
                template: '<ng-content></ng-content>',
                selector: 'nx-card',
                changeDetection: ChangeDetectionStrategy.OnPush,
                host: {
                    'class': 'nx-card',
                    '[class.is-selectable]': 'selectable',
                    '[class.is-selected]': 'selected',
                    '[class.is-disabled]': 'disabled',
                    '[attr.aria-disabled]': 'disabled',
                    '(click)': '_toggleSelected()',
                    '(keydown.enter)': '_toggleSelected()',
                    '[attr.tabindex]': '_getTabindex()'
                },
                styles: [":host{background:#fff;background:var(--card-background-color,#fff);border-color:var(--card-border-color,#d9d9d9);border-width:var(--card-border-width,1px);border-radius:4px;border-radius:var(--card-border-radius,4px);box-shadow:none;display:inline-block;margin-bottom:24px;padding:23px;transition:background-color .2s,box-shadow .2s;border:1px solid #d9d9d9}:host:focus,:host:hover{outline:0}:host.is-selectable{cursor:pointer}:host.is-selectable:hover{background:#f5f5f5;background:var(--card-background-hover-color,#f5f5f5)}:host.is-selected{box-shadow:0 8px 24px rgba(65,65,65,.35);background:#f5f5f5;background:var(--card-background-selected-color,#f5f5f5)}:host.is-disabled{cursor:not-allowed;opacity:.4}:host.is-disabled:hover{background:#fff;background:var(--card-background-color,#fff)}:host-context([data-whatinput=keyboard]):focus{box-shadow:0 0 0 2px #fff,0 0 0 6px #009de6;box-shadow:var(--focus-box-shadow,0 0 0 2px #fff,0 0 0 6px #009de6)}@media screen and (-ms-high-contrast:active){:host-context([data-whatinput=keyboard]):focus{box-shadow:0 0 0 2px background,0 0 0 6px windowText}:host.is-selectable{border-color:buttonText}:host.is-selected{border-width:3px;padding:21px;border-color:highlight}:host.is-disabled{opacity:1;border-color:GrayText;color:GrayText}}"]
            }] }
];
/** @nocollapse */
NxCardComponent.ctorParameters = () => [
    { type: ChangeDetectorRef },
    { type: String, decorators: [{ type: Attribute, args: ['tabindex',] }] }
];
NxCardComponent.propDecorators = {
    selectable: [{ type: Input }],
    selected: [{ type: Input }],
    disabled: [{ type: Input }],
    selectedChange: [{ type: Output }]
};
if (false) {
    /** @type {?} */
    NxCardComponent.prototype._tabindex;
    /**
     * @type {?}
     * @private
     */
    NxCardComponent.prototype._selectable;
    /**
     * @type {?}
     * @private
     */
    NxCardComponent.prototype._selected;
    /**
     * @type {?}
     * @private
     */
    NxCardComponent.prototype._disabled;
    /**
     * Event emitted when the selected value has changed.
     *
     * This output  property of the card is deprecated,
     * as its selectable properties are deprecated as well.
     * Please use the selectable card component instead.
     *
     * @deprecated
     * \@deletion-target 10.0.0
     * @type {?}
     */
    NxCardComponent.prototype.selectedChange;
    /**
     * @type {?}
     * @private
     */
    NxCardComponent.prototype._changeDetectorRef;
}

/**
 * @fileoverview added by tsickle
 * Generated from: card/card.module.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class NxCardModule {
}
NxCardModule.decorators = [
    { type: NgModule, args: [{
                declarations: [NxCardComponent],
                exports: [NxCardComponent],
                imports: [
                    CommonModule
                ]
            },] }
];

/**
 * @fileoverview added by tsickle
 * Generated from: card/selectable-card.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * \@docs-private
 * @abstract
 */
class SelectableCard {
}
if (false) {
    /** @type {?} */
    SelectableCard.prototype.id;
    /** @type {?} */
    SelectableCard.prototype.value;
    /** @type {?} */
    SelectableCard.prototype.checked;
    /** @type {?} */
    SelectableCard.prototype.name;
    /** @type {?} */
    SelectableCard.prototype.negative;
    /** @type {?} */
    SelectableCard.prototype.disabled;
    /** @type {?} */
    SelectableCard.prototype.checkedChange;
    /** @type {?} */
    SelectableCard.prototype.selectionChange;
}

/**
 * @fileoverview added by tsickle
 * Generated from: card/selectable-card-change-event.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class NxSelectableCardChangeEvent {
    /**
     * @param {?} checked
     * @param {?} value
     * @param {?} card
     */
    constructor(checked, value, card) {
        this.checked = checked;
        this.value = value;
        this.card = card;
    }
}
if (false) {
    /**
     * The checked value of the selectable card.
     * @type {?}
     */
    NxSelectableCardChangeEvent.prototype.checked;
    /**
     * The value of the selectable card.
     * @type {?}
     */
    NxSelectableCardChangeEvent.prototype.value;
    /**
     * The component instance of the selectable card which emitted the change event.
     * @type {?}
     */
    NxSelectableCardChangeEvent.prototype.card;
}

/**
 * @fileoverview added by tsickle
 * Generated from: card/selectable-card.component.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
let nextId$b = 0;
class NxSelectableCardComponent extends SelectableCard {
    /**
     * @param {?} _changeDetectorRef
     * @param {?} _errorStateMatcher
     * @param {?} ngControl
     * @param {?} _parentForm
     * @param {?} _parentFormGroup
     */
    constructor(_changeDetectorRef, _errorStateMatcher, ngControl, _parentForm, _parentFormGroup) {
        super();
        this._changeDetectorRef = _changeDetectorRef;
        this._errorStateMatcher = _errorStateMatcher;
        this.ngControl = ngControl;
        this._parentForm = _parentForm;
        this._parentFormGroup = _parentFormGroup;
        this._id = (nextId$b++).toString();
        this._checked = false;
        this._disabled = false;
        this._negative = false;
        this._tabindex = '0';
        /**
         * \@docs-private
         */
        this._errorListIds = '';
        /**
         * \@docs-private
         */
        this.errorState = false;
        /**
         * \@docs-private
         */
        this.stateChanges = new Subject();
        /**
         * An event is dispatched each time the selectable card value is changed
         */
        this.selectionChange = new EventEmitter();
        /**
         * An event is dispatched each time the selectable card value is changed
         */
        this.checkedChange = new EventEmitter();
        /**
         * \@docs-private
         */
        this.onChangeCallback = (/**
         * @param {?} _
         * @return {?}
         */
        (_) => { });
        this.onTouchedCallback = (/**
         * @param {?} _
         * @return {?}
         */
        (_) => { });
        if (this.ngControl) {
            // Note: we provide the value accessor through here, instead of
            // the `providers` to avoid running into a circular import.
            this.ngControl.valueAccessor = this;
        }
    }
    /**
     * Id of the selectable card.
     *
     * If not set, the selectable card gets an incremented value by default.
     * @param {?} value
     * @return {?}
     */
    set id(value) {
        if (value !== this._id) {
            this._id = value;
            this._changeDetectorRef.markForCheck();
        }
    }
    /**
     * @return {?}
     */
    get id() {
        return `nx-selectable-card-${this._id}`;
    }
    /**
     * Whether the selectable card  is checked.
     * @param {?} value
     * @return {?}
     */
    set checked(value) {
        /** @type {?} */
        const newValue = coerceBooleanProperty(value);
        if (newValue !== this._checked) {
            this._checked = newValue;
            this._changeDetectorRef.markForCheck();
        }
    }
    /**
     * @return {?}
     */
    get checked() {
        return this._checked;
    }
    /**
     * The value attribute of the native input element
     * @return {?}
     */
    get value() {
        return this._value;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set value(value) {
        if (value) {
            this._value = value;
        }
        this._changeDetectorRef.markForCheck();
    }
    /**
     * Whether the selectable card is disabled.
     * @param {?} value
     * @return {?}
     */
    set disabled(value) {
        /** @type {?} */
        const newValue = coerceBooleanProperty(value);
        if (newValue !== this._disabled) {
            this._disabled = newValue;
            this._changeDetectorRef.markForCheck();
        }
    }
    /**
     * @return {?}
     */
    get disabled() {
        return this._disabled || null;
    }
    /**
     * Whether the selectable card is negative.
     * @param {?} value
     * @return {?}
     */
    set negative(value) {
        /** @type {?} */
        const newValue = coerceBooleanProperty(value);
        if (newValue !== this._negative) {
            this._negative = newValue;
            this._changeDetectorRef.markForCheck();
        }
    }
    /**
     * @return {?}
     */
    get negative() {
        return this._negative || null;
    }
    /**
     * Whether the selectable card is required.
     * @return {?}
     */
    get required() {
        return this._required;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set required(value) {
        this._required = coerceBooleanProperty(value);
    }
    /**
     * Name of the selectable card.
     * @return {?}
     */
    get name() {
        return this._name;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set name(value) {
        this._name = value;
    }
    /**
     * The tabIndex of the element
     * @return {?}
     */
    get tabindex() {
        if (this.disabled) {
            return '-1';
        }
        return this._tabindex;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set tabindex(value) {
        this._tabindex = value;
    }
    /**
     * @return {?}
     */
    ngAfterContentInit() {
        this._errorList.changes.subscribe((/**
         * @param {?} value
         * @return {?}
         */
        (value) => {
            this._errorListIds = value.map((/**
             * @param {?} errorItem
             * @return {?}
             */
            (errorItem) => {
                return errorItem.id;
            })).join(' ');
            this._changeDetectorRef.markForCheck();
        }));
        this._errorListIds = this._errorList.map((/**
         * @param {?} errorItem
         * @return {?}
         */
        (errorItem) => {
            return errorItem.id;
        })).join(' ');
    }
    /**
     * @param {?} fn
     * @return {?}
     */
    registerOnChange(fn) {
        this.onChangeCallback = fn;
    }
    /**
     * @param {?} onTouched
     * @return {?}
     */
    registerOnTouched(onTouched) {
        this.onTouchedCallback = onTouched;
    }
    /**
     * @param {?} isDisabled
     * @return {?}
     */
    setDisabledState(isDisabled) {
        this.disabled = isDisabled;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    writeValue(value) {
        this.checked = !!value;
    }
    /**
     * @return {?}
     */
    ngDoCheck() {
        if (this.ngControl) {
            // We need to re-evaluate this on every change detection cycle, because there are some
            // error triggers that we can't subscribe to (e.g. parent form submissions). This means
            // that whatever logic is in here has to be super lean or we risk destroying the performance.
            this.updateErrorState();
        }
    }
    /**
     * \@docs-private
     * @return {?}
     */
    updateErrorState() {
        /** @type {?} */
        const oldState = this.errorState;
        /** @type {?} */
        const parent = this._parentFormGroup || this._parentForm;
        /** @type {?} */
        const control = this.ngControl ? (/** @type {?} */ (this.ngControl.control)) : null;
        /** @type {?} */
        const newState = this._errorStateMatcher.isErrorState(control, parent);
        if (newState !== oldState) {
            this.errorState = newState;
            this.stateChanges.next();
        }
    }
    /**
     * Toggles the checked state of the selectable card .
     * @return {?}
     */
    toggle() {
        if (!this.disabled) {
            this.checked = !this.checked;
        }
    }
    /**
     * \@docs-private
     * @param {?} event
     * @return {?}
     */
    _onInputClick(event) {
        // We have to stop propagation for click events on the visual hidden input element.
        // By default, when a user clicks on a label element, a generated click event will be
        // stop the propagation of the native click on the checkbox input so that a click is not triggered twice
        // Preventing bubbling for the second event will solve that issue.
        event.stopPropagation();
        if (!this.disabled) {
            this.toggle();
            this._emitChangeEvent();
        }
    }
    /**
     * \@docs-private
     * @param {?} event
     * @return {?}
     */
    _onInteractionEvent(event) {
        // We always have to stop propagation on the change event.
        // Otherwise the change event, from the input element, will bubble up and
        // emit its event object to the `change` output.
        event.stopPropagation();
    }
    /**
     * \@docs-private
     * @private
     * @return {?}
     */
    _emitChangeEvent() {
        /** @type {?} */
        const event = new NxSelectableCardChangeEvent(this.checked, this.value, this);
        this.onChangeCallback(this.checked);
        this.selectionChange.emit(event);
        this.checkedChange.emit(this.checked);
    }
}
NxSelectableCardComponent.decorators = [
    { type: Component, args: [{
                selector: 'nx-selectable-card',
                template: "<input #input\n       type=\"checkbox\"\n       [checked]=\"checked\"\n       [value]=\"value || null\"\n       [attr.disabled]=\"disabled\"\n       (change)=\"_onInteractionEvent($event)\"\n       (blur)=\"onTouchedCallback($event)\"\n       [attr.id]=\"id\"\n       [attr.name]=\"name\"\n       (click)=\"_onInputClick($event)\"\n       [required]=\"required\"\n       [attr.aria-required]=\"required\"\n       [attr.tabindex]=\"tabindex\"\n       [attr.aria-invalid]=\"errorState\"\n       [attr.aria-describedby]=\"_errorListIds || null\"\n>\n\n<label [attr.for]=\"id\" [class.is-disabled]=\"disabled\">\n  <ng-container *ngTemplateOutlet=\"selectableCardContent\"></ng-container>\n</label>\n\n<ng-content *ngIf=\"errorState\" select=\"nx-error\"></ng-content>\n\n<ng-template #selectableCardContent>\n  <nx-icon name=\"check-circle\" size=\"s\" class=\"checked-icon\"></nx-icon>\n  <div class=\"nx-selectable-card--headline\">\n    <ng-content select=\"nx-card-header\"></ng-content>\n  </div>\n  <div class=\"nx-selectable-card--content\">\n    <ng-content></ng-content>\n  </div>\n  <div class=\"nx-selectable-card--footer\">\n    <ng-content select=\"nx-card-footer\"></ng-content>\n  </div>\n</ng-template>\n",
                changeDetection: ChangeDetectionStrategy.OnPush,
                providers: [{ provide: SelectableCard, useExisting: forwardRef((/**
                         * @return {?}
                         */
                        () => NxSelectableCardComponent)) }],
                host: {
                    '[class.is-checked]': 'checked',
                    '[class.is-disabled]': 'disabled',
                    '[class.has-error]': 'errorState',
                    '[attr.aria-invalid]': 'errorState',
                    '[attr.role]': '"checkbox"',
                    '[attr.aria-checked]': 'checked'
                },
                styles: [":host{display:block}:host input{position:absolute;height:0;width:0;overflow:hidden;opacity:0}:host label{border:1px solid #999;border:var(--selectable-card-border-width,1px) solid var(--selectable-card-border-color,#999);display:block;position:relative;padding:16px;cursor:pointer;width:100%;margin-bottom:8px;border-radius:4px;border-radius:var(--selectable-card-border-radius,4px);background:#fff;background:var(--selectable-card-background-color,#fff)}:host:focus{outline:0}:host::-moz-focus-inner{border:0}:host input:checked+label{background:#f5f5f5;background:var(--selectable-card-background-selected-color,#f5f5f5);border-color:#414141;border-color:var(--selectable-card-border-selected-color,#414141)}:host input:checked+label ::ng-deep nx-icon.checked-icon{display:block}:host label:active,:host label:hover{background:#f5f5f5;background:var(--selectable-card-background-hover-color,#f5f5f5);border-color:#414141;border-color:var(--selectable-card-border-hover-color,#414141)}:host input:checked+label:hover{background:#ececec;background:var(--selectable-card-background-selected-hover-color,#ececec)}:host ::ng-deep nx-icon.checked-icon{position:absolute;right:8px;top:8px;display:none}:host(.is-disabled) label{border-color:#ececec;border-color:var(--selectable-card-border-disabled-color,#ececec);cursor:not-allowed}:host(.is-disabled) label:hover{background:#fff;background:var(--selectable-card-background-disabled-color,#fff)}:host(.is-disabled) input:checked+label{background:#f5f5f5;background:var(--selectable-card-background-disabled-selected-color,#f5f5f5);border-color:#c2c2c2;border-color:var(--selectable-card-border-disabled-selected-color,#c2c2c2)}:host(.is-disabled) input:checked+label ::ng-deep nx-icon.checked-icon{display:block;color:#c2c2c2;color:var(--selectable-card-icon-diabled-color,#c2c2c2)}:host(.has-error) input:checked+label,:host(.has-error) input:checked+label:hover,:host(.has-error) label,:host(.has-error) label:hover{border-color:#dc3149;border-color:var(--selectable-card-border-error-color,#dc3149)}:host-context([data-whatinput=keyboard]) :host:focus label,:host-context([data-whatinput=keyboard]) input:focus+label{box-shadow:0 0 0 2px #fff,0 0 0 6px #009de6;box-shadow:var(--focus-box-shadow,0 0 0 2px #fff,0 0 0 6px #009de6)}@media screen and (-ms-high-contrast:active){:host-context([data-whatinput=keyboard]) :host:focus label,:host-context([data-whatinput=keyboard]) input:focus+label{box-shadow:0 0 0 2px background,0 0 0 6px windowText}:host label{border-color:buttonText}:host input:checked+label{border-width:3px;padding:14px;border-color:highlight}:host(.is-disabled) input:checked+label,:host(.is-disabled) label{border-color:GrayText;color:GrayText}:host(.is-disabled) input:checked+label ::ng-deep nx-icon.checked-icon,:host(.is-disabled) label ::ng-deep nx-icon.checked-icon{color:GrayText}}"]
            }] }
];
/** @nocollapse */
NxSelectableCardComponent.ctorParameters = () => [
    { type: ChangeDetectorRef },
    { type: ErrorStateMatcher },
    { type: NgControl, decorators: [{ type: Self }, { type: Optional }] },
    { type: NgForm, decorators: [{ type: Optional }] },
    { type: FormGroupDirective, decorators: [{ type: Optional }] }
];
NxSelectableCardComponent.propDecorators = {
    _errorList: [{ type: ContentChildren, args: [NxErrorComponent,] }],
    selectionChange: [{ type: Output }],
    checkedChange: [{ type: Output }],
    id: [{ type: Input }],
    checked: [{ type: Input }],
    value: [{ type: Input }],
    disabled: [{ type: Input }],
    negative: [{ type: Input }],
    required: [{ type: Input }],
    name: [{ type: Input }],
    tabindex: [{ type: Input }]
};
if (false) {
    /**
     * @type {?}
     * @private
     */
    NxSelectableCardComponent.prototype._id;
    /**
     * @type {?}
     * @private
     */
    NxSelectableCardComponent.prototype._checked;
    /**
     * @type {?}
     * @private
     */
    NxSelectableCardComponent.prototype._disabled;
    /**
     * @type {?}
     * @private
     */
    NxSelectableCardComponent.prototype._value;
    /**
     * @type {?}
     * @private
     */
    NxSelectableCardComponent.prototype._name;
    /**
     * @type {?}
     * @private
     */
    NxSelectableCardComponent.prototype._negative;
    /**
     * @type {?}
     * @private
     */
    NxSelectableCardComponent.prototype._tabindex;
    /**
     * @type {?}
     * @private
     */
    NxSelectableCardComponent.prototype._required;
    /**
     * \@docs-private
     * @type {?}
     */
    NxSelectableCardComponent.prototype._errorListIds;
    /**
     * \@docs-private
     * @type {?}
     */
    NxSelectableCardComponent.prototype._errorList;
    /**
     * \@docs-private
     * @type {?}
     */
    NxSelectableCardComponent.prototype.errorState;
    /**
     * \@docs-private
     * @type {?}
     */
    NxSelectableCardComponent.prototype.stateChanges;
    /**
     * An event is dispatched each time the selectable card value is changed
     * @type {?}
     */
    NxSelectableCardComponent.prototype.selectionChange;
    /**
     * An event is dispatched each time the selectable card value is changed
     * @type {?}
     */
    NxSelectableCardComponent.prototype.checkedChange;
    /**
     * \@docs-private
     * @type {?}
     */
    NxSelectableCardComponent.prototype.onChangeCallback;
    /** @type {?} */
    NxSelectableCardComponent.prototype.onTouchedCallback;
    /**
     * @type {?}
     * @private
     */
    NxSelectableCardComponent.prototype._changeDetectorRef;
    /**
     * @type {?}
     * @private
     */
    NxSelectableCardComponent.prototype._errorStateMatcher;
    /** @type {?} */
    NxSelectableCardComponent.prototype.ngControl;
    /**
     * @type {?}
     * @private
     */
    NxSelectableCardComponent.prototype._parentForm;
    /**
     * @type {?}
     * @private
     */
    NxSelectableCardComponent.prototype._parentFormGroup;
}

/**
 * @fileoverview added by tsickle
 * Generated from: card/card-header.component.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class NxCardHeaderComponent {
}
NxCardHeaderComponent.decorators = [
    { type: Component, args: [{
                selector: 'nx-card-header',
                template: "<ng-content></ng-content>\n",
                changeDetection: ChangeDetectionStrategy.OnPush
            }] }
];

/**
 * @fileoverview added by tsickle
 * Generated from: card/card-footer.component.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class NxCardFooterComponent {
}
NxCardFooterComponent.decorators = [
    { type: Component, args: [{
                selector: 'nx-card-footer',
                template: "<ng-content></ng-content>\n",
                changeDetection: ChangeDetectionStrategy.OnPush
            }] }
];

/**
 * @fileoverview added by tsickle
 * Generated from: card/selectable-card.module.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class NxSelectableCardModule {
}
NxSelectableCardModule.decorators = [
    { type: NgModule, args: [{
                declarations: [
                    NxSelectableCardComponent,
                    NxCardHeaderComponent,
                    NxCardFooterComponent
                ],
                exports: [
                    NxSelectableCardComponent,
                    NxCardHeaderComponent,
                    NxCardFooterComponent
                ],
                imports: [
                    CommonModule,
                    NxIconModule,
                    NxErrorModule
                ]
            },] }
];

/**
 * @fileoverview added by tsickle
 * Generated from: card/public-api.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * Generated from: public-api.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * Generated from: allianz-ngx-ndbx.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

export { BREAKPOINT_DESKTOP, BREAKPOINT_MOBILE, BREAKPOINT_TABLET, DefaultPaginationTexts, MappedStyles, NX_AUTOCOMPLETE_VALUE_ACCESSOR, NX_MESSAGE_TOAST_DEFAULT_CONFIG, NX_PAGINATION_TEXTS, NdbxModule, NxAccordionDirective, NxAccordionModule, NxAutocompleteComponent, NxAutocompleteModule, NxAutocompleteOptionComponent, NxAutocompleteOptionSelected, NxAutocompleteSelectedEvent, NxAutocompleteTriggerDirective, NxButtonBase, NxButtonComponent, NxButtonModule, NxCardComponent, NxCardFooterComponent, NxCardHeaderComponent, NxCardModule, NxCheckboxChangeEvent, NxCheckboxComponent, NxCheckboxGroupComponent, NxCheckboxModule, NxCircleToggleComponent, NxCircleToggleGroupComponent, NxCircleToggleModule, NxCopytextComponent, NxCopytextModule, NxDropdownComponent, NxDropdownGroupComponent, NxDropdownItemChange, NxDropdownItemComponent, NxDropdownModule, NxDropdownSelectChange, NxDynamicTableComponent, NxDynamicTableModule, NxExpansionPanelComponent, NxFigureComponent, NxHeadlineComponent, NxHeadlineModule, NxIconButtonComponent, NxIconToggleButtonComponent, NxImageDirective, NxImageModule, NxLinkComponent, NxLinkModule, NxListComponent, NxListModule, NxMessageComponent, NxMessageModule, NxMessageToastComponent, NxMessageToastConfig, NxMessageToastData, NxMessageToastRef, NxMessageToastService, NxMobileToggleButtonComponent, NxModalActionsDirective, NxModalComponent, NxModalContentDirective, NxModalModule, NxModalService, NxNaturalLanguageFormComponent, NxNaturalLanguageFormModule, NxNumberStepperComponent, NxNumberStepperIntl, NxNumberStepperModule, NxNumberStepperPrefixDirective, NxNumberStepperSuffixDirective, NxOpenModalOnClickDirective, NxPageSearchComponent, NxPageSearchModule, NxPaginationComponent, NxPaginationModule, NxPaginationUtils, NxPopoverComponent, NxPopoverContentDirective, NxPopoverModule, NxPopoverTriggerDirective, NxRadioChange, NxRadioComponent, NxRadioGroupComponent, NxRadioModule, NxRadioToggleComponent, NxRadioToggleModule, NxRatingComponent, NxRatingModule, NxSelectableCardComponent, NxSelectableCardModule, NxSpinnerComponent, NxSpinnerModule, NxSwitcherComponent, NxSwitcherModule, NxTabBodyComponent, NxTabChangeEvent, NxTabComponent, NxTabContentDirective, NxTabGroupComponent, NxTabHeaderComponent, NxTabLabelDirective, NxTabLinkDirective, NxTabNavBarComponent, NxTabsModule, NxTaglistComponent, NxTaglistModule, NxVideoComponent, NxVideoModule, NxWordComponent, ToggleChangeEvent, getNxAutocompleteMissingPanelError, messageToastAnimations, ToggleButton as ɵa, NxListIconComponent as ɵb, NxRadioToggleButtonBaseComponent as ɵc, NxRadioToggleButtonComponent as ɵd, fadeIn as ɵe, fadeOut as ɵf, scaleUp as ɵg, scaleDown as ɵh, NxTagComponent as ɵi, NxDropdownControl as ɵj, NxDropdownClosedLabelDirective as ɵk, NxAutoResizeDirective as ɵl, nxAccordionAnimations as ɵm, NxExpansionPanelBodyDirective as ɵn, NxExpansionPanelHeaderComponent as ɵo, NxExpansionPanelDescriptionDirective as ɵp, NxExpansionPanelTitleDirective as ɵq, NxTabGroupBase as ɵr, NxTabLabelWrapperDirective as ɵs, NxTabHeaderOutletComponent as ɵt, SelectableCard as ɵu };
//# sourceMappingURL=allianz-ngx-ndbx.js.map
