{"version":3,"file":"allianz-ngx-ndbx-mask.js","sources":["ng://@allianz/ngx-ndbx/mask/mask.directive.ts","ng://@allianz/ngx-ndbx/mask/iban-mask.directive.ts","ng://@allianz/ngx-ndbx/mask/mask.module.ts"],"sourcesContent":["import { Directive, Input, ElementRef, forwardRef } from '@angular/core';\nimport {\n  ControlValueAccessor,\n  NG_VALUE_ACCESSOR,\n  NG_VALIDATORS,\n  Validator\n} from '@angular/forms';\nimport { coerceBooleanProperty } from '@angular/cdk/coercion';\nimport { NX_INPUT_VALUE_ACCESSOR } from '@allianz/ngx-ndbx/input';\nimport { BACKSPACE, DELETE } from '@angular/cdk/keycodes';\nimport { Subject } from 'rxjs';\n\ntype MASK_TYPE = '0' | 'A' | 'S';\n\nexport const NX_MASK_VALUE_ACCESSOR: any = {\n  provide: NG_VALUE_ACCESSOR,\n  useExisting: forwardRef(() => NxMaskDirective),\n  multi: true\n};\n\nexport const NX_MASK_VALIDATORS: any = {\n  provide: NG_VALIDATORS,\n  useExisting: forwardRef(() => NxMaskDirective),\n  multi: true\n};\n\n/** Options for input case sensitivity. */\nexport type MaskConversionTypes = 'lower' | 'upper';\n\n/** Interface for saving the cursor information. */\ninterface CursorInfo {\n  selectionStart?: number;\n  selectionEnd?: number;\n  position?: number;\n}\n\n@Directive({\n  selector: 'input[nxMask]',\n  host: {\n    '(input)': '_onInputChange($event)',\n    '(keydown)': '_onKeydown($event)',\n    '(paste)': '_onPaste($event)',\n    '(blur)': '_touch()'\n  },\n  exportAs: 'nxMaskDirective',\n  providers: [\n    NX_MASK_VALUE_ACCESSOR,\n    { provide: NX_INPUT_VALUE_ACCESSOR, useExisting: NxMaskDirective },\n    NX_MASK_VALIDATORS\n  ]\n})\nexport class NxMaskDirective implements ControlValueAccessor, Validator {\n\n  private _mask: string;\n  private _separators = ['/', '(', ')', '.', ':', '-', ' ', '+', ','];\n  private _dropSpecialCharacters: boolean = false;\n  private _validateMask: boolean = true;\n  private _convertTo?: MaskConversionTypes;\n\n  /**\n   * _cursor is a helper for saving a position or a selectionRange (selectionStart + selectionEnd)\n   * and then apply it later on (in _onInputChange()).\n   *\n   * _cursor.position is used for saving a position that is then applied without any changes.\n   * if the position is saved, selectionStart and selectionEnd will be ignored in _onInputChange().\n   * _cursor.selectionStart and selectionEnd is used for saving the current cursor position,\n   * and a new cursor position is then calculated with this data.\n   */\n  private _cursor: CursorInfo;\n\n  /** helper variable for saving the current value of the input element to compare it then with a new value. */\n  private _inputValue: string;\n\n  /** helper variable for saving the masked string of a pasted value and then applying it in _onInputChange(). */\n  private _pastedData: string;\n\n  /**\n   * Emits the unmasked value before the value changes.\n   */\n  readonly cvaModelChange = new Subject<string>();\n\n  private _onChangeCallback = (_: any) => { };\n  private _onTouchedCallback = () => { };\n  private _validatorOnChange = () => {};\n\n  private _callOnChangeCallback() {\n    if (!this.dropSpecialCharacters) {\n      this._onChangeCallback(this._elementRef.nativeElement.value);\n    } else {\n      this._onChangeCallback(this.getUnmaskedValue());\n    }\n  }\n\n  private _afterInputHook = (event: KeyboardEvent) => { };\n  private _beforePasteHook = (event: ClipboardEvent) => { };\n\n  /**\n   * Registers a function to be executed after the onInput handler.\n   * The registered hook receives a `KeyboardEvent` from the onInput event handler as a parameter.\n   *\n   * **Note:** If you register a `afterInputHook`, you may also register a `beforePasteHook`\n   * to perform similar changes for pasting.\n   */\n  registerAfterInputHook(afterInput: (event: KeyboardEvent) => void): void {\n    this._afterInputHook = afterInput;\n  }\n\n  /**\n   * Registers a function to be executed before the onPaste handler.\n   * The registered hook receives a `ClipboardEvent` from the onPaste event handler as a parameter.\n   */\n  registerBeforePasteHook(beforePaste: (event: ClipboardEvent) => void): void {\n    this._beforePasteHook = beforePaste;\n  }\n\n  /** Sets the mask. */\n  @Input('nxMask')\n  set mask(value: string) {\n    if (!value) {\n      value = '';\n    }\n    if (value !== this._mask) {\n      this._mask = value;\n      this.updateValue(this.getMaskedString(this._elementRef.nativeElement.value));\n      this._callOnChangeCallback();\n      this._validatorOnChange();\n    }\n  }\n  get mask(): string {\n    return this._mask;\n  }\n\n  /**\n   * Sets the mask (for programmatical use).\n   *\n   * No `_onChangeCallback()` will be called!\n   */\n  setMask(value: string) {\n    if (!value) {\n      value = '';\n    }\n    if (value !== this._mask) {\n      this._mask = value;\n      this.updateValue(this.getMaskedString(this._elementRef.nativeElement.value));\n      this._validatorOnChange();\n    }\n  }\n\n  /** Sets the case sensitivity of the mask. */\n  @Input('nxConvertTo')\n  set convertTo(value: MaskConversionTypes) {\n    this._convertTo = value;\n    this.updateValue(this.getMaskedString(this._elementRef.nativeElement.value));\n    this._callOnChangeCallback();\n  }\n  get convertTo() {\n    return this._convertTo;\n  }\n\n  /**\n   * Sets the keys that are recognized as separators.\n   * Default separators: / ( ) . : - + , and space.\n   */\n  @Input()\n  set separators(values: string[]) {\n    this._separators = values;\n    this.updateValue(this.getMaskedString(this._elementRef.nativeElement.value));\n    this._validatorOnChange();\n    this._callOnChangeCallback();\n  }\n  get separators(): string[] {\n    return this._separators;\n  }\n\n  /** Whether the separators should be dropped in the control value accessor. */\n  @Input()\n  set dropSpecialCharacters(value: boolean) {\n    const newValue = coerceBooleanProperty(value);\n    if (newValue !== this._dropSpecialCharacters) {\n      this._dropSpecialCharacters = newValue;\n      this.updateValue(this.getMaskedString(this._elementRef.nativeElement.value));\n      this._callOnChangeCallback();\n    }\n  }\n  get dropSpecialCharacters(): boolean {\n    return this._dropSpecialCharacters;\n  }\n\n  /** Whether the mask validation should be applied on the input. Default: true. */\n  @Input()\n  set validateMask(value: boolean) {\n    const newValue = coerceBooleanProperty(value);\n    if (newValue !== this._validateMask) {\n      this._validateMask = newValue;\n      this._validatorOnChange();\n    }\n  }\n  get validateMask(): boolean {\n    return this._validateMask;\n  }\n\n  constructor(\n    private _elementRef: ElementRef\n  ) {}\n\n  /** @docs-private */\n  get elementRefValue(): string {\n    return this._elementRef.nativeElement.value;\n  }\n\n  /** Returns the unmasked value. */\n  getUnmaskedValue(): string {\n    const unmaskedValue = this.separators.reduce(function(unmasked, separator) {\n      return unmasked.split(separator).join('');\n    }, this._elementRef.nativeElement.value);\n\n    return unmaskedValue;\n  }\n\n  /**\n   * this._cursor can be set to a new value in this function;\n   * in _onInputChange() it is then used to set the cursor position.\n   */\n  _onKeydown(event: KeyboardEvent) {\n    const keyCode = event.keyCode;\n\n    const input: HTMLInputElement = event.target as HTMLInputElement;\n    const currentValue = this._elementRef.nativeElement.value;\n\n    if (keyCode === BACKSPACE || keyCode === DELETE) {\n      // if backspace pressed, cursor has to move one character to start\n      const backspaceShift = keyCode === BACKSPACE ? 1 : 0;\n      const lastCharacter = currentValue.substring(input.selectionStart - backspaceShift, input.selectionEnd - backspaceShift + 1);\n      const selectionAtLastCharacter = (input.selectionStart === currentValue.length - 1 + backspaceShift);\n\n      if (input.selectionStart !== input.selectionEnd) {\n        let newPosition = input.selectionStart;\n        // jump behind separators, but do not shift after the next character (=> don't use _calculateCursorShift())\n        while (this.isSeparator(this.mask[newPosition])) {\n          newPosition++;\n        }\n        this._cursor = { position: newPosition };\n      } else if (selectionAtLastCharacter) {\n        // if last character is deleted: only delete last character, do not trigger input event again\n        // (here the separator would be added again)\n        this.updateValue(currentValue.substring(0, currentValue.length - 1));\n        this._callOnChangeCallback();\n        event.preventDefault();\n      } else if (this.isSeparator(lastCharacter)) {\n        // do not delete a separator, only set cursor position\n        input.setSelectionRange(input.selectionStart - backspaceShift, input.selectionEnd - backspaceShift);\n        event.preventDefault();\n      } else {\n        // for any other character: decrease cursor position by one (backspaceShift).\n        // the input is modified and will be validated in _onInputChange().\n        this._cursor = { position: input.selectionStart - backspaceShift };\n      }\n    } else {\n      this._cursor = { selectionStart: input.selectionStart, selectionEnd: input.selectionEnd };\n    }\n  }\n\n  /**\n   * Returns the cursor position after a letter is entered at `selectionStart` position in the mask.\n   * There are two cases to consider ('|' => cursor position where the character is entered, mask: 00:00:00):\n   * - before the separators there is space for entering the letter: '12:3|4:5' => '12:30:|45'\n   * - the letter has to be shifted and is entered after the separators: '12:34|:5' => '12:34:0|5'\n   */\n  private _calculateCursorShift(position: number): number {\n    let shift = 0;\n    // tracks if the entered letter was already placed in the current mask\n    // and therefor was considered in the cursor calculation.\n    let characterWasEntered = false;\n\n    if (!this.isSeparator(this.mask[position + shift])) {\n      shift++;\n      characterWasEntered = true;\n    }\n\n    while (this.isSeparator(this.mask[position + shift])) {\n      shift++;\n    }\n\n    if (!characterWasEntered) {\n      shift++;\n    }\n\n    return shift;\n  }\n\n  private _isStringAllowed(value: string, maskedValue: MASK_TYPE) {\n    if ((maskedValue === '0' && /^[0-9]{1}$/.test(value))\n          || (maskedValue === 'A' && /^[a-zA-Z0-9]{1}$/.test(value))\n          || (maskedValue === 'S' && /^[a-zA-Z]{1}$/.test(value))) {\n\n      return true;\n    }\n    return false;\n  }\n\n  /**\n   * Handles the onInput event.\n   * `_beforeInputHook()` is called before the actual execution.\n   *\n   */\n  _onInputChange(event: KeyboardEvent) {\n    // _inputValue is updated in updateValue(), so I need to pick it up here to compare it to a new value\n    const oldVal = this._inputValue;\n    const input: HTMLInputElement = event.target as HTMLInputElement;\n    const newVal = this.getMaskedString(input.value);\n\n    // if _pastedData was set in _onPaste(), use this value\n    if (this._pastedData) {\n      this.updateValue(this._pastedData);\n      input.setSelectionRange(this._cursor.position, this._cursor.position);\n      this._pastedData = null;\n      this._cursor = null;\n      this._callOnChangeCallback();\n      return;\n    }\n\n    // do nothing if mask is already filled up\n    if (oldVal.length === this._mask.length\n        && newVal.length === this._mask.length\n        && oldVal !== newVal\n        && (this._cursor\n              && this._cursor.selectionStart !== undefined\n              && this._cursor.selectionStart === this._cursor.selectionEnd)) {\n\n      this._elementRef.nativeElement.value = this.getMaskedString(oldVal);\n      input.setSelectionRange(this._cursor.selectionStart, this._cursor.selectionEnd);\n      this._cursor = null;\n      return;\n    }\n\n    this.updateValue(newVal);\n\n    // set new cursor position\n    if (this._cursor && this._cursor.position !== undefined) {\n      input.setSelectionRange(this._cursor.position, this._cursor.position);\n      this._cursor = null;\n    } else if (this._cursor && this._cursor.selectionStart !== undefined) {\n      // only one character can be entered (except pasting, this is calculated in _onPaste())\n      if (oldVal !== input.value) {\n        const newPosition = this._cursor.selectionStart + this._calculateCursorShift(this._cursor.selectionStart);\n        input.setSelectionRange(newPosition, newPosition);\n        this._cursor = null;\n      } else {\n        // we always have to set the cursor position here even if nothing changed\n        // because otherwise the cursor would jump to the end of the input.\n        // if the cursor is placed in front of a separator and the user types a non-allowed character,\n        // the cursor is supposed to jump over the separator.\n        let currentPosition = this._cursor.selectionStart;\n        while (this.isSeparator(this.mask[currentPosition])) {\n          currentPosition++;\n        }\n        input.setSelectionRange(currentPosition, currentPosition);\n        this._cursor = null;\n      }\n    }\n\n    this._afterInputHook(event);\n    this._callOnChangeCallback();\n  }\n\n  /**\n   * this._cursor and this._pastedData can be set to a new value in this function;\n   * _cursor is used to set the cursor position after checking the masked input in _onInputChange().\n   * _pastedData carries the valid part of the pasted value to _inInputChange();\n   *\n   *`_beforePasteHook()` is called before the actual execution.\n   */\n  _onPaste(event: ClipboardEvent) {\n    const input: HTMLInputElement = event.target as HTMLInputElement;\n    const pastedData = (event.clipboardData || (<any> window).clipboardData).getData('text');\n\n    // saving these three values as if something is changed in the _beforePasteHook()\n    // which causes the input value to be updated, this values will get lost.\n    const selectionStart = input.selectionStart;\n    const selectionEnd = input.selectionEnd;\n    const oldValue = input.value;\n\n    this._beforePasteHook(event);\n\n    const maskedString = this.getMaskedString(pastedData, selectionStart);\n\n    // if mask is already filled up (and no characters are selected with the cursor), do nothing\n    if (input.value.length === this._mask.length\n      && maskedString.length > 0\n      && selectionStart === selectionEnd) {\n\n      input.setSelectionRange(selectionStart, selectionEnd);\n      this._cursor = null;    // was set in _onKeydown(), but will not be used in this case; so reset it\n      event.preventDefault();\n      return;\n    }\n\n    // if length of newValue is >= mask: allow only to enter characters from a pasted value until mask is filled up\n    // example: 12:|34: (\"|\" cursor position, mask: 00:00:00) => when pasting '567', only '56' fits in until input is filled up => 12:56:|34\n    // get the pasted unmasked value from the pasted string (to cut all the invalid characters and separators)\n    const pastedUnmaskedValue = this.separators.reduce(\n      (unmasked, separator) => unmasked.split(separator).join(''), maskedString\n    );\n\n    let newValue: string = this.getMaskedString(\n      oldValue.substring(0, selectionStart)\n      + pastedUnmaskedValue\n      + oldValue.substring(selectionEnd, oldValue.length)\n    );\n\n    if (newValue.length >= this._mask.length) {\n      let newPosition = selectionStart;\n\n      let i = 1;\n      do {\n        newValue = this.getMaskedString(\n          oldValue.substring(0, selectionStart)\n          + pastedUnmaskedValue.substring(0, i)\n          + oldValue.substring(selectionEnd, oldValue.length)\n        );\n        newPosition += this._calculateCursorShift(newPosition);\n\n        i++;\n      } while (newValue.length < this._mask.length);\n\n      // save value for using it in _onInputChange()\n      this._pastedData = newValue;\n      this._cursor = {\n        position: newPosition\n      };\n      return;\n    }\n\n    // if pasting is fine: save the cursor position for using them in _onInputChange()\n    this._cursor = {\n      position: selectionStart + maskedString.length\n    };\n  }\n\n  private updateValue(value: string) {\n    // Write UpperCase\n    if (this._convertTo === 'upper') {\n      value = value.toUpperCase();\n    } else if (this._convertTo === 'lower') {\n      value = value.toLowerCase();\n    }\n    this._elementRef.nativeElement.value = value;\n\n    // _inputValue is needed for calculating the cursor shift in onInput()\n    this._inputValue = value;\n  }\n\n  /** @docs-private */\n  getMaskedString(inputValue: string, maskStartIndex: number = 0): string {\n    let formattedValue = '';\n    let maskIndex = maskStartIndex;\n    let inputIndex = 0;\n\n    // insert if next in mask is separator\n    while (this.isSeparator(this.mask[maskIndex])) {\n      formattedValue += this.mask[maskIndex];\n      maskIndex++;\n    }\n\n    while (inputIndex < inputValue.length) {\n      // test if letters are valid\n      if (this._isStringAllowed(inputValue[inputIndex], this.mask[maskIndex] as MASK_TYPE)) {\n        formattedValue += inputValue[inputIndex];\n        inputIndex++;\n        maskIndex++;\n      } else {\n        inputIndex++;\n      }\n\n      // insert if next in mask is separator\n      while (this.isSeparator(this.mask[maskIndex])) {\n        formattedValue += this.mask[maskIndex];\n        maskIndex++;\n      }\n    }\n\n    return formattedValue;\n  }\n\n  private isSeparator(value: string): boolean {\n    return (this._separators.indexOf(value) !== -1);\n  }\n\n  // control value accessor\n  writeValue(value: any): void {\n    if (!value) {\n      value = '';\n    }\n\n    this.cvaModelChange.next(value);\n    this.updateValue(this.getMaskedString(value));\n  }\n\n  registerOnChange(onChange: any): void {\n    this._onChangeCallback = onChange;\n  }\n\n  registerOnTouched(onTouched: any): void {\n    this._onTouchedCallback = onTouched;\n  }\n\n  /** @docs-private */\n  registerOnValidatorChange(fn: () => void): void {\n    this._validatorOnChange = fn;\n  }\n\n  _validateFn() {\n    const inputLength = this._elementRef.nativeElement.value.length;\n    const maskLength = this._mask.length;\n    if (inputLength !== maskLength) {\n      return { nxMaskLengthError: {'length': maskLength, 'actual': inputLength} };\n    }\n    return null;\n  }\n\n  /** @docs-private */\n  validate() {\n    return this.validateMask ? this._validateFn() : null;\n  }\n\n  _touch() {\n    this._onTouchedCallback();\n  }\n}\n","import { Directive, ElementRef, Inject, forwardRef, OnInit } from '@angular/core';\nimport * as IBAN from 'iban';\nimport { NG_VALIDATORS } from '@angular/forms';\nimport { Validator } from '@angular/forms';\n\nimport { NxMaskDirective } from './mask.directive';\n\nexport const NX_IBAN_MASK_VALIDATORS: any = {\n  provide: NG_VALIDATORS,\n  useExisting: forwardRef(() => NxIbanMaskDirective),\n  multi: true\n};\n\n/**\n * To use the `NxIbanMaskDirective`, you have to install the **peer dependency** `iban.js`.\n */\n@Directive({\n  selector: 'input[nxIbanMask]',\n  exportAs: 'nxIbanMaskDirective',\n  providers: [\n    NX_IBAN_MASK_VALIDATORS\n  ]\n})\nexport class NxIbanMaskDirective implements OnInit, Validator {\n\n  private _countryCode: string;\n\n  constructor(\n    private _elementRef: ElementRef,\n    @Inject(forwardRef(() => NxMaskDirective)) private maskDirective: NxMaskDirective\n  ) {\n    this.maskDirective.registerAfterInputHook(this._afterInputHook);\n    this.maskDirective.registerBeforePasteHook(this._beforePasteHook);\n\n    this.maskDirective.cvaModelChange.subscribe((value: string) => {\n      const enteredCountryCode = this.maskDirective.getMaskedString(value).substr(0, 2);\n      this._setCountryCode(enteredCountryCode);\n    });\n  }\n\n  private _afterInputHook = (event: KeyboardEvent) => {\n    const input = event.target as HTMLInputElement;\n    this._setCountryCode(input.value.substr(0, 2));\n  }\n\n  private _beforePasteHook = (event: ClipboardEvent) => {\n    // change the country code here if necessary\n    const input: HTMLInputElement = event.target as HTMLInputElement;\n    const pastedData = (event.clipboardData || (<any> window).clipboardData).getData('text');\n\n    const enteredCountryCode = (\n      this.maskDirective.elementRefValue.substr(0, input.selectionStart)\n      + this.maskDirective.getMaskedString(pastedData, input.selectionStart)\n    ).substr(0, 2);\n\n    this._setCountryCode(enteredCountryCode);\n  }\n\n  private _setCountryCode(code: string): void {\n    code = code.toUpperCase();\n    if (code.length === 2 && this._countryCode !== code) {\n      if (this._countryCodeExists(code)) {\n        this._countryCode = code;\n        this.maskDirective.setMask(this._getMask(this._countryCode));\n      } else {\n        this._countryCode = null;\n        this.maskDirective.setMask('SS');\n      }\n    }\n  }\n\n  ngOnInit(): void {\n    // set only first two letters as I don't know a country yet\n    this.maskDirective.mask = 'SS';\n    this.maskDirective.convertTo = 'upper';\n  }\n\n  private _getMask(countryCode: string) {\n    // the countrySpecs of a country contain: countryCode (\"DE\"), length (22), structure (\"F08F10\")\n    // and an example belonging to each country\n    const countrySpecs = IBAN['countries'][countryCode];\n\n    // 'SS' for country code + '00' for IBAN checksum\n    let mask = 'SS00';\n\n    // split up after every third character\n    const characterDefs = countrySpecs['structure'].match(/.{1,3}/g);\n\n    characterDefs.forEach(charDef => {\n      const character = charDef[0];\n      const count = Number(charDef.substring(1, 3));\n\n      switch (character) {\n        // [0-9]\n        case 'F': mask = mask + '0'.repeat(count); break;\n        // [0-9A-Za-z]\n        case 'A': mask = mask + 'A'.repeat(count); break;\n        // [A-Z]\n        // 'S' in nxMask does accept also [a-z].\n        // There is no option for only accepting capital letters at the moment.\n        case 'U': mask = mask + 'S'.repeat(count); break;\n      }\n    });\n\n    // insert whitespaces after every 4 characters\n    mask = mask.match(/.{1,4}/g).join(' ');\n\n    return mask;\n  }\n\n  private _countryCodeExists(countryCode: string): boolean {\n    return (!!IBAN['countries'][countryCode]);\n  }\n\n  private _validateFn() {\n    const enteredCountryCode = this._elementRef.nativeElement.value.substr(0, 2);\n    if (enteredCountryCode.length === 2 && !this._countryCodeExists(enteredCountryCode)) {\n      // immediately show error to user\n      this.maskDirective._touch();\n      return { nxIbanInvalidCountryError: 'no valid country code'};\n    }\n    if (!IBAN.isValid(this.maskDirective.getUnmaskedValue())) {\n      return { nxIbanParseError: 'no valid iban'};\n    }\n    return null;\n  }\n\n  /** @docs-private */\n  validate() {\n    return this.maskDirective.validateMask ? this._validateFn() : null;\n  }\n}\n","import { CommonModule } from '@angular/common';\nimport { NgModule } from '@angular/core';\n\nimport { NxFormfieldModule } from '@allianz/ngx-ndbx/formfield';\nimport { NxMaskDirective } from './mask.directive';\nimport { NxIbanMaskDirective } from './iban-mask.directive';\n\n@NgModule({\n  imports: [\n    CommonModule,\n    NxFormfieldModule\n  ],\n  declarations: [\n    NxMaskDirective,\n    NxIbanMaskDirective\n  ],\n  exports: [\n    NxFormfieldModule,\n    NxMaskDirective,\n    NxIbanMaskDirective\n  ]\n})\nexport class NxMaskModule { }\n"],"names":["IBAN['countries']","IBAN.isValid"],"mappings":"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"}