import { CommonModule } from '@angular/common';
import { EventEmitter, Component, ChangeDetectionStrategy, ChangeDetectorRef, Input, Output, NgZone, ViewChild, NgModule, InjectionToken, Injectable, Injector, Optional, SkipSelf, Inject, ɵɵdefineInjectable, ɵɵinject, INJECTOR } from '@angular/core';
import { NxIconModule } from '@allianz/ngx-ndbx/icon';
import { coerceBooleanProperty } from '@angular/cdk/coercion';
import { OverlayModule, OverlayConfig, Overlay } from '@angular/cdk/overlay';
import { BasePortalOutlet, CdkPortalOutlet, PortalModule, ComponentPortal, TemplatePortal, PortalInjector } from '@angular/cdk/portal';
import { trigger, state, style, transition, animate } from '@angular/animations';
import { Subject } from 'rxjs';
import { take } from 'rxjs/operators';
import { LiveAnnouncer } from '@angular/cdk/a11y';

/**
 * @fileoverview added by tsickle
 * Generated from: message/message.component.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const ICONS = {
    info: 'info-circle',
    error: 'exclamation-triangle',
    success: 'check-circle',
    warning: 'exclamation-circle'
};
class NxMessageComponent {
    /**
     * @param {?} _changeDetectorRef
     */
    constructor(_changeDetectorRef) {
        this._changeDetectorRef = _changeDetectorRef;
        this._context = 'regular';
        this._showIcon = false;
        this._closable = false;
        this._closeButtonLabel = 'Close dialog';
        /**
         * Event emitted when the close icon of the message has been clicked.
         */
        this.closeEvent = new EventEmitter();
    }
    /**
     * Sets the context of the message.
     * The message box will color accordingly. Default: 'regular'
     * @param {?} value
     * @return {?}
     */
    set context(value) {
        if (value !== this._context) {
            this._context = value;
            this._icon = this.getIconName();
            this._changeDetectorRef.markForCheck();
        }
    }
    /**
     * @return {?}
     */
    get context() {
        return this._context;
    }
    /**
     * Whether an icon that belongs to the context of the message should be displayed.
     *
     * **Important:** The `showIcon` attribute should always be set to `true` due to deprecation.
     *
     * @deprecated The `showIcon` attribute should be always true in future. Messages without an icon are deprecated.
     * \@deletion-target 9.0.0
     *
     * @param {?} value
     * @return {?}
     */
    set showIcon(value) {
        this._showIcon = coerceBooleanProperty(value);
        this._changeDetectorRef.markForCheck();
    }
    /**
     * @return {?}
     */
    get showIcon() {
        return this._showIcon;
    }
    /**
     * Whether a message should have a close icon in order to be dismissed.
     * @param {?} value
     * @return {?}
     */
    set closable(value) {
        /** @type {?} */
        const newValue = coerceBooleanProperty(value);
        if (newValue !== this._closable) {
            this._closable = newValue;
            this._changeDetectorRef.markForCheck();
        }
    }
    /**
     * @return {?}
     */
    get closable() {
        return this._closable;
    }
    /**
     * \@docs-private
     * @return {?}
     */
    get icon() {
        return this._icon;
    }
    /**
     * Sets the label of the close button of the message.
     * @param {?} value
     * @return {?}
     */
    set closeButtonLabel(value) {
        if (value !== this._closeButtonLabel) {
            this._closeButtonLabel = value;
            this._changeDetectorRef.markForCheck();
        }
    }
    /**
     * @return {?}
     */
    get closeButtonLabel() {
        return this._closeButtonLabel;
    }
    /**
     * \@docs-private
     * @return {?}
     */
    _emitCloseEvent() {
        this.closeEvent.emit();
    }
    /**
     * \@docs-private
     * @return {?}
     */
    getIconName() {
        if (this._context === 'info') {
            return ICONS.info;
        }
        else if (this._context === 'error') {
            return ICONS.error;
        }
        else if (this._context === 'success') {
            return ICONS.success;
        }
        else if (this._context === 'warning') {
            return ICONS.warning;
        }
        return '';
    }
}
NxMessageComponent.decorators = [
    { type: Component, args: [{
                selector: 'nx-message',
                template: "<nx-icon *ngIf=\"showIcon && context !== 'regular'\"\n         class=\"nx-message__icon\"\n         [name]=\"icon\"\n         size=\"s\">\n</nx-icon>\n<button\n  *ngIf=\"closable\"\n  (click)=\"_emitCloseEvent()\"\n  [attr.aria-label]=\"closeButtonLabel\"\n  tabindex=\"0\"\n  class=\"nx-message__close-icon\">\n    <nx-icon\n      name=\"close\"\n      size=\"s\"\n      aria-hidden=\"true\">\n    </nx-icon>\n</button>\n\n\n<div class=\"nx-message__content-wrapper\">\n  <div class=\"nx-message__content\">\n    <ng-content></ng-content>\n  </div>\n</div>\n",
                changeDetection: ChangeDetectionStrategy.OnPush,
                exportAs: 'nxMessage',
                host: {
                    '[class.context-info]': 'context === "info"',
                    '[class.context-error]': 'context === "error"',
                    '[class.context-success]': 'context === "success"',
                    '[class.context-warning]': 'context === "warning"',
                    '[class.nx-message--closable]': 'closable'
                },
                styles: [":host{font-size:16px;font-size:var(--message-font-size,16px);line-height:24px;line-height:var(--message-line-height,24px);font-weight:400;font-weight:var(--message-font-weight,400);letter-spacing:0;letter-spacing:var(--message-letter-spacing,0);color:#414141;color:var(--message-text-color,#414141);border-radius:4px;border-radius:var(--message-border-radius,4px);width:100%;display:flex;align-items:flex-start;text-align:left;position:relative;border:1px solid;padding:23px;margin:12px 0}.nx-message__content-wrapper{max-width:100%}:host,:host(.context-regular){border-color:#414141;border-color:var(--message-regular-border-color,#414141);background-color:#fff;background-color:var(--message-regular-background-color,#fff)}:host(.context-info){border-color:#496ebd;border-color:var(--message-info-border-color,#496ebd);background-color:#ecf0f8;background-color:var(--message-info-background-color,#ecf0f8)}:host(.context-info) .nx-message__icon{color:#496ebd;color:var(--message-info-icon-color,#496ebd)}:host(.context-error){border-color:#dc3149;border-color:var(--message-error-border-color,#dc3149);background-color:#fbeaec;background-color:var(--message-error-background-color,#fbeaec)}:host(.context-error) .nx-message__icon{color:#dc3149;color:var(--message-error-icon-color,#dc3149)}:host(.context-success){border-color:#1e8927;border-color:var(--message-success-border-color,#1e8927);background-color:#e8f3e9;background-color:var(--message-success-background-color,#e8f3e9)}:host(.context-success) .nx-message__icon{color:#1e8927;color:var(--message-success-icon-color,#1e8927)}:host(.context-warning){border-color:#efbe25;border-color:var(--message-warning-border-color,#efbe25);background-color:#fdf8e9;background-color:var(--message-warning-background-color,#fdf8e9)}:host(.context-warning) .nx-message__icon{color:#efbe25;color:var(--message-warning-icon-color,#efbe25)}.nx-message__icon{margin-right:16px}@media (max-width:703px){:host{padding:31px;display:block}:host(.context-error) .nx-message__icon~.nx-message__content-wrapper .nx-message__content,:host(.context-info) .nx-message__icon~.nx-message__content-wrapper .nx-message__content,:host(.context-success) .nx-message__icon~.nx-message__content-wrapper .nx-message__content,:host(.context-warning) .nx-message__icon~.nx-message__content-wrapper .nx-message__content{display:inline;margin-left:31px}.nx-message__icon{position:absolute}}:host(.nx-message--closable){padding-right:39px}@media (max-width:703px){:host(.nx-message--closable){padding-right:31px}}.nx-message__close-icon{position:absolute;top:16px;right:16px;cursor:pointer;background-color:transparent;border:none;outline:0;padding:0;display:flex;align-items:center}.nx-message__close-icon nx-icon{color:#414141;color:var(--message-close-icon-color,#414141);font-size:16px}:host-context([data-whatinput=keyboard]) .nx-message__close-icon:focus{box-shadow:0 0 0 2px #fff,0 0 0 6px #009de6;box-shadow:var(--focus-box-shadow,0 0 0 2px #fff,0 0 0 6px #009de6);border-radius:4px}@media screen and (-ms-high-contrast:active){:host(.context-error) .nx-message__icon,:host(.context-info) .nx-message__icon,:host(.context-success) .nx-message__icon,:host(.context-warning) .nx-message__icon{color:windowText}:host-context([data-whatinput=keyboard]) .nx-message__close-icon:focus{box-shadow:0 0 0 2px background,0 0 0 6px windowText}}"]
            }] }
];
/** @nocollapse */
NxMessageComponent.ctorParameters = () => [
    { type: ChangeDetectorRef }
];
NxMessageComponent.propDecorators = {
    context: [{ type: Input, args: ['nxContext',] }],
    showIcon: [{ type: Input }],
    closable: [{ type: Input }],
    closeButtonLabel: [{ type: Input }],
    closeEvent: [{ type: Output, args: ['close',] }]
};
if (false) {
    /**
     * @type {?}
     * @private
     */
    NxMessageComponent.prototype._context;
    /**
     * @type {?}
     * @private
     */
    NxMessageComponent.prototype._showIcon;
    /**
     * @type {?}
     * @private
     */
    NxMessageComponent.prototype._closable;
    /**
     * @type {?}
     * @private
     */
    NxMessageComponent.prototype._icon;
    /**
     * @type {?}
     * @private
     */
    NxMessageComponent.prototype._closeButtonLabel;
    /**
     * Event emitted when the close icon of the message has been clicked.
     * @type {?}
     */
    NxMessageComponent.prototype.closeEvent;
    /**
     * @type {?}
     * @private
     */
    NxMessageComponent.prototype._changeDetectorRef;
}

/**
 * @fileoverview added by tsickle
 * Generated from: message-toast/message-toast-animations.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Animations used by the Message Toast.
 * \@docs-private
 * @type {?}
 */
const messageToastAnimations = {
    toastState: trigger('state', [
        state('initial, void, hidden', style({ opacity: 0, transform: 'translateY(100%)' })),
        state('visible', style({ opacity: 1 })),
        transition('* => visible', animate('300ms cubic-bezier(0, 0, 0.2, 1)', style({ opacity: 1, transform: 'translateY(0)' }))),
        transition('* => hidden', animate('300ms cubic-bezier(0, 0, 0.2, 1)', style({ opacity: 0, transform: 'translateY(200%)' }))),
    ])
};

/**
 * @fileoverview added by tsickle
 * Generated from: message-toast/message-toast-config.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Configuration used when opening a message toast.
 */
class NxMessageToastConfig {
    constructor() {
        /**
         * The politeness level for the LiveAnnouncer announcement.
         *
         *  Default value: 'polite'.
         */
        this.politeness = 'polite';
        /**
         * Message to be announced by the LiveAnnouncer. When opening a toast message without a custom
         * component or template, the announcement message will default to the specified message.
         *
         * Default value: ''.
         */
        this.announcementMessage = '';
        /**
         * The length of time in milliseconds to wait before automatically dismissing the message toast.
         *
         * Default value: 3000.
         */
        this.duration = 3000;
        /**
         * Context of the message toast.
         *
         * Default value: 'info'.
         */
        this.context = 'info';
    }
}
if (false) {
    /**
     * The politeness level for the LiveAnnouncer announcement.
     *
     *  Default value: 'polite'.
     * @type {?}
     */
    NxMessageToastConfig.prototype.politeness;
    /**
     * Message to be announced by the LiveAnnouncer. When opening a toast message without a custom
     * component or template, the announcement message will default to the specified message.
     *
     * Default value: ''.
     * @type {?}
     */
    NxMessageToastConfig.prototype.announcementMessage;
    /**
     * The length of time in milliseconds to wait before automatically dismissing the message toast.
     *
     * Default value: 3000.
     * @type {?}
     */
    NxMessageToastConfig.prototype.duration;
    /**
     * Context of the message toast.
     *
     * Default value: 'info'.
     * @type {?}
     */
    NxMessageToastConfig.prototype.context;
}
/**
 * \@docs-private
 * Needed so that the user text data can be injected in the message toastcomponent
 */
class NxMessageToastData {
    /**
     * @param {?} data
     */
    constructor(data) {
        this.data = data;
    }
}
if (false) {
    /** @type {?} */
    NxMessageToastData.prototype.data;
}

/**
 * @fileoverview added by tsickle
 * Generated from: message-toast/message-toast.component.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const ICONS$1 = {
    info: 'info-circle',
    success: 'check-circle',
};
/**
 * Internal component that wraps user-provided message toastcontent.
 * \@docs-private
 */
class NxMessageToastComponent extends BasePortalOutlet {
    /**
     * @param {?} _ngZone
     * @param {?} _changeDetectorRef
     * @param {?} config
     * @param {?=} data
     */
    constructor(_ngZone, _changeDetectorRef, config, data) {
        super();
        this._ngZone = _ngZone;
        this._changeDetectorRef = _changeDetectorRef;
        this.config = config;
        this.data = data;
        /**
         * Whether the component has been destroyed.
         */
        this._destroyed = false;
        /**
         * Subject for notifying that the message toasthas exited from view.
         */
        this._onExit = new Subject();
        /**
         * Subject for notifying that the message toasthas finished entering the view.
         */
        this._onEnter = new Subject();
        /**
         * The state of the message toastanimations.
         */
        this._animationState = 'void';
        this._context = this.config.context;
        this._setAriaLabels();
    }
    /**
     * Attach a component portal as content to this message toastcontainer.
     * @template T
     * @param {?} portal
     * @return {?}
     */
    attachComponentPortal(portal) {
        this._assertNotAttached();
        return this._portalOutlet.attachComponentPortal(portal);
    }
    /**
     * Attach a template portal as content to this message toastcontainer.
     * @template C
     * @param {?} portal
     * @return {?}
     */
    attachTemplatePortal(portal) {
        this._assertNotAttached();
        return this._portalOutlet.attachTemplatePortal(portal);
    }
    /**
     * Handle end of animations, updating the state of the notification.
     * @param {?} event
     * @return {?}
     */
    onAnimationEnd(event) {
        const { fromState, toState } = event;
        if ((toState === 'void' && fromState !== 'void') || toState === 'hidden') {
            this._completeExit();
        }
        if (toState === 'visible') {
            // Note: we shouldn't use `this` inside the zone callback,
            // because it can cause a memory leak.
            /** @type {?} */
            const onEnter = this._onEnter;
            this._ngZone.run((/**
             * @return {?}
             */
            () => {
                onEnter.next();
                onEnter.complete();
            }));
        }
    }
    /**
     * Begin animation of message toastentrance into view.
     * @return {?}
     */
    enter() {
        if (!this._destroyed) {
            this._animationState = 'visible';
            this._changeDetectorRef.detectChanges();
        }
    }
    /**
     * Begin animation of the message toastexiting from view.
     * @return {?}
     */
    exit() {
        // Note: this one transitions to `hidden`, rather than `void`, in order to handle the case
        // where multiple notifications are opened in quick succession (e.g. two consecutive calls to
        // `NxMessageToastService.open`).
        this._animationState = 'hidden';
    }
    /**
     * Makes sure the exit callbacks have been invoked when the element is destroyed.
     * @return {?}
     */
    ngOnDestroy() {
        this._destroyed = true;
        this._completeExit();
    }
    /**
     * Waits for the zone to settle before removing the element. Helps prevent
     * errors where we end up removing an element which is in the middle of an animation.
     * @private
     * @return {?}
     */
    _completeExit() {
        this._ngZone.onMicrotaskEmpty.asObservable().pipe(take(1)).subscribe((/**
         * @return {?}
         */
        () => {
            this._onExit.next();
            this._onExit.complete();
        }));
    }
    /**
     * Asserts that no content is already attached to the container.
     * @private
     * @return {?}
     */
    _assertNotAttached() {
        if (this._portalOutlet.hasAttached()) {
            throw Error('Attempting to attach message toastcontent after content is already attached');
        }
    }
    /**
     * @return {?}
     */
    _getIconName() {
        return this._context === 'success' ? ICONS$1.success : ICONS$1.info;
    }
    /**
     * @return {?}
     */
    _setAriaLabels() {
        // Based on the ARIA spec, `alert` and `status` roles have an
        // implicit `assertive` and `polite` politeness respectively.
        if (this.config.politeness === 'assertive' && !this.config.announcementMessage) {
            this._role = 'alert';
        }
        else if (this.config.politeness === 'off') {
            this._role = null;
        }
        else {
            this._role = 'status';
        }
    }
}
NxMessageToastComponent.decorators = [
    { type: Component, args: [{
                selector: 'nx-message-toast',
                template: "<nx-icon class=\"nx-message__icon\" [name]=\"_getIconName()\" size=\"s\">\n</nx-icon>\n\n<div class=\"nx-message__content-wrapper\">\n    <!-- Used when opening from a template -->\n    <ng-template cdkPortalOutlet></ng-template>\n    <!-- Used when opening only with custom text-->\n    <ng-container *ngIf=\"data\">{{data.data}}</ng-container>\n</div>\n",
                host: {
                    '[attr.role]': '_role',
                    '[class.context-info]': '_context === "info"',
                    '[class.context-success]': '_context === "success"',
                    '[@state]': '_animationState',
                    '(@state.done)': 'onAnimationEnd($event)'
                },
                animations: [messageToastAnimations.toastState],
                styles: [":host{font-size:16px;font-size:var(--message-font-size,16px);line-height:24px;line-height:var(--message-line-height,24px);font-weight:400;font-weight:var(--message-font-weight,400);letter-spacing:0;letter-spacing:var(--message-letter-spacing,0);color:#414141;color:var(--message-text-color,#414141);border-radius:4px;border-radius:var(--message-border-radius,4px);width:100%;display:flex;align-items:flex-start;text-align:left;position:relative;border:1px solid;padding:23px 23px 23px 63px;margin:12px 0;box-shadow:0 2px 4px rgba(65,65,65,.5);box-shadow:var(--message-box-shadow,0 2px 4px rgba(65,65,65,.5));max-width:352px}@media (max-width:703px){:host{padding:23px 23px 23px 63px;display:block}}:host(.context-info){border-color:#496ebd;border-color:var(--message-info-border-color,#496ebd);background-color:#ecf0f8;background-color:var(--message-info-background-color,#ecf0f8)}:host(.context-info) .nx-message__icon{color:#496ebd;color:var(--message-info-icon-color,#496ebd)}:host(.context-success){border-color:#1e8927;border-color:var(--message-success-border-color,#1e8927);background-color:#e8f3e9;background-color:var(--message-success-background-color,#e8f3e9)}:host(.context-success) .nx-message__icon{color:#1e8927;color:var(--message-success-icon-color,#1e8927)}@media screen and (-ms-high-contrast:active){:host(.context-info) .nx-message__icon,:host(.context-success) .nx-message__icon{color:windowText}}.nx-message__icon{position:absolute;top:23px;left:23px}"]
            }] }
];
/** @nocollapse */
NxMessageToastComponent.ctorParameters = () => [
    { type: NgZone },
    { type: ChangeDetectorRef },
    { type: NxMessageToastConfig },
    { type: NxMessageToastData }
];
NxMessageToastComponent.propDecorators = {
    _portalOutlet: [{ type: ViewChild, args: [CdkPortalOutlet, { static: true },] }]
};
if (false) {
    /**
     * Whether the component has been destroyed.
     * @type {?}
     * @private
     */
    NxMessageToastComponent.prototype._destroyed;
    /**
     * The portal outlet inside of this container into which the message toastcontent will be loaded.
     * @type {?}
     */
    NxMessageToastComponent.prototype._portalOutlet;
    /**
     * Subject for notifying that the message toasthas exited from view.
     * @type {?}
     */
    NxMessageToastComponent.prototype._onExit;
    /**
     * Subject for notifying that the message toasthas finished entering the view.
     * @type {?}
     */
    NxMessageToastComponent.prototype._onEnter;
    /**
     * The state of the message toastanimations.
     * @type {?}
     */
    NxMessageToastComponent.prototype._animationState;
    /**
     * ARIA role for the message toastcontainer.
     * @type {?}
     */
    NxMessageToastComponent.prototype._role;
    /** @type {?} */
    NxMessageToastComponent.prototype._context;
    /**
     * @type {?}
     * @private
     */
    NxMessageToastComponent.prototype._ngZone;
    /**
     * @type {?}
     * @private
     */
    NxMessageToastComponent.prototype._changeDetectorRef;
    /**
     * The message toastconfiguration.
     * @type {?}
     */
    NxMessageToastComponent.prototype.config;
    /**
     * Injected data into the notifciation.
     * @type {?}
     */
    NxMessageToastComponent.prototype.data;
}

/**
 * @fileoverview added by tsickle
 * Generated from: message.module.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class NxMessageModule {
}
NxMessageModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    CommonModule,
                    NxIconModule,
                    OverlayModule,
                    PortalModule
                ],
                declarations: [
                    NxMessageComponent,
                    NxMessageToastComponent
                ],
                exports: [
                    NxMessageComponent
                ],
                entryComponents: [
                    NxMessageToastComponent
                ]
            },] }
];

/**
 * @fileoverview added by tsickle
 * Generated from: message-toast/message-toast-ref.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Maximum amount of milliseconds that can be passed into setTimeout.
 * @type {?}
 */
const MAX_TIMEOUT = Math.pow(2, 31) - 1;
class NxMessageToastRef {
    /**
     * @param {?} toastInstance
     * @param {?} _overlayRef
     */
    constructor(toastInstance, _overlayRef) {
        this._overlayRef = _overlayRef;
        /**
         * Subject for notifying the user that the message toasthas been dismissed.
         */
        this._afterDismissed = new Subject();
        /**
         * Subject for notifying the user that the message toasthas opened and appeared.
         */
        this._afterOpened = new Subject();
        this.toastInstance = toastInstance;
        toastInstance._onExit.subscribe((/**
         * @return {?}
         */
        () => this._finishDismiss()));
    }
    /**
     * Dismisses the message toast.
     * @return {?}
     */
    dismiss() {
        if (!this._afterDismissed.closed) {
            this.toastInstance.exit();
        }
        clearTimeout(this._durationTimeoutId);
    }
    /**
     * Dismisses the message toastafter some duration
     * @param {?} duration
     * @return {?}
     */
    _dismissAfter(duration) {
        // Note that we need to cap the duration to the maximum value for setTimeout, because
        // it'll revert to 1 if somebody passes in something greater (e.g. `Infinity`). See #17234.
        this._durationTimeoutId = setTimeout((/**
         * @return {?}
         */
        () => this.dismiss()), Math.min(duration, MAX_TIMEOUT));
    }
    /**
     * Marks the message toastas opened
     * @return {?}
     */
    _open() {
        if (!this._afterOpened.closed) {
            this._afterOpened.next();
            this._afterOpened.complete();
        }
    }
    /**
     * Cleans up the DOM after closing.
     * @private
     * @return {?}
     */
    _finishDismiss() {
        this._overlayRef.dispose();
        this._afterDismissed.next();
        this._afterDismissed.complete();
    }
    /**
     * Gets an observable that is notified when the message toastis finished closing.
     * @return {?}
     */
    afterDismissed() {
        return this._afterDismissed.asObservable();
    }
    /**
     * Gets an observable that is notified when the message toasthas opened and appeared.
     * @return {?}
     */
    afterOpened() {
        return this.toastInstance._onEnter;
    }
}
if (false) {
    /**
     * The instance of the component making up the content of the message toast.
     * \@docs-private
     * @type {?}
     */
    NxMessageToastRef.prototype.toastInstance;
    /**
     * Subject for notifying the user that the message toasthas been dismissed.
     * @type {?}
     * @private
     */
    NxMessageToastRef.prototype._afterDismissed;
    /**
     * Subject for notifying the user that the message toasthas opened and appeared.
     * @type {?}
     * @private
     */
    NxMessageToastRef.prototype._afterOpened;
    /**
     * Timeout ID for the duration setTimeout call. Used to clear the timeout if the message toastis
     * dismissed before the duration passes.
     * @type {?}
     * @private
     */
    NxMessageToastRef.prototype._durationTimeoutId;
    /**
     * @type {?}
     * @private
     */
    NxMessageToastRef.prototype._overlayRef;
}

/**
 * @fileoverview added by tsickle
 * Generated from: message-toast/message-toast.service.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Injection token that can be used to specify default message toast.
 * @type {?}
 */
const NX_MESSAGE_TOAST_DEFAULT_CONFIG = new InjectionToken('NX_MESSAGE_TOAST_DEFAULT_CONFIG');
/**
 * A service for dispatching and displaying toast messages.
 */
class NxMessageToastService {
    /**
     * @param {?} _overlay
     * @param {?} _injector
     * @param {?} _live
     * @param {?} _parentMessageToastService
     * @param {?} _defaultConfig
     */
    constructor(_overlay, _injector, _live, _parentMessageToastService, _defaultConfig) {
        this._overlay = _overlay;
        this._injector = _injector;
        this._live = _live;
        this._parentMessageToastService = _parentMessageToastService;
        this._defaultConfig = _defaultConfig;
        /**
         * Reference to the current message toast in the view *at this level* (in the Angular injector tree).
         * If there is a parent message toast service, all operations should delegate to that parent
         * via `_oldToastMessageRef`.
         */
        this._toastRefAtThisLevel = null;
    }
    /**
     * Reference to the currently opened message toastat *any* level.
     * @return {?}
     */
    get _oldToastMessageRef() {
        /** @type {?} */
        const parent = this._parentMessageToastService;
        return parent ? parent._oldToastMessageRef : this._toastRefAtThisLevel;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set _oldToastMessageRef(value) {
        if (this._parentMessageToastService) {
            this._parentMessageToastService._oldToastMessageRef = value;
        }
        else {
            this._toastRefAtThisLevel = value;
        }
    }
    /**
     * Creates and dispatches a message toastwith a custom text.
     *
     * @param {?} text Text to be used for the message toast.
     * @param {?=} config Extra configuration for the message toast.
     * @return {?}
     */
    open(text, config) {
        /** @type {?} */
        const currentConfig = Object.assign({}, new NxMessageToastConfig(), this._defaultConfig, config);
        /** @type {?} */
        const overlayRef = this._createOverlay(currentConfig);
        /** @type {?} */
        const injector = this._createInjector(currentConfig, new NxMessageToastData(text), this._injector);
        /** @type {?} */
        const componentPortal = new ComponentPortal(NxMessageToastComponent, undefined, injector);
        /** @type {?} */
        const componentRef = overlayRef.attach(componentPortal);
        /** @type {?} */
        const toastRef = new NxMessageToastRef(componentRef.instance, overlayRef);
        this._animateToast(toastRef, currentConfig);
        this._oldToastMessageRef = toastRef;
        return this._oldToastMessageRef;
    }
    /**
     * Creates and dispatches a message toastwith a custom template for the content.
     *
     * @param {?} template Template to be used for the message toast.
     * @param {?=} config Extra configuration for the message toast.
     * @return {?}
     */
    openFromTemplate(template, config) {
        /** @type {?} */
        const currentConfig = Object.assign({}, new NxMessageToastConfig(), this._defaultConfig, config);
        /** @type {?} */
        const overlayRef = this._createOverlay(currentConfig);
        /** @type {?} */
        const container = this._attachToastComponent(overlayRef, currentConfig);
        /** @type {?} */
        const toastRef = new NxMessageToastRef(container, overlayRef);
        /** @type {?} */
        const portal = new TemplatePortal(template, (/** @type {?} */ (null)), toastRef);
        container.attachTemplatePortal(portal);
        this._animateToast(toastRef, currentConfig);
        this._oldToastMessageRef = toastRef;
        return this._oldToastMessageRef;
    }
    // Attaches the message toastcontainer component to the overlay.
    /**
     * @private
     * @param {?} overlayRef
     * @param {?} config
     * @return {?}
     */
    _attachToastComponent(overlayRef, config) {
        /** @type {?} */
        const injector = this._createInjector(config, null, this._injector);
        /** @type {?} */
        const containerPortal = new ComponentPortal(NxMessageToastComponent, null, injector);
        /** @type {?} */
        const containerRef = overlayRef.attach(containerPortal);
        containerRef.instance.config = config;
        return containerRef.instance;
    }
    // Creates a new overlay and places it in the correct place.
    /**
     * @private
     * @param {?} config
     * @return {?}
     */
    _createOverlay(config) {
        /** @type {?} */
        const overlayConfig = new OverlayConfig();
        /** @type {?} */
        const positionStrategy = this._overlay.position().global();
        positionStrategy.bottom('0');
        positionStrategy.centerHorizontally();
        overlayConfig.positionStrategy = positionStrategy;
        return this._overlay.create(overlayConfig);
    }
    /**
     * Animates the old message toastout and the new one in.
     * @private
     * @param {?} toastRef
     * @param {?} config
     * @return {?}
     */
    _animateToast(toastRef, config) {
        // When the message toastis dismissed, clear the reference to it.
        toastRef.afterDismissed().subscribe((/**
         * @return {?}
         */
        () => {
            // Clear the message toastref if it hasn't already been replaced by a newer message toast.
            if (this._oldToastMessageRef === toastRef) {
                this._oldToastMessageRef = null;
            }
            if (config.announcementMessage) {
                this._live.clear();
            }
        }));
        if (this._oldToastMessageRef) {
            // If a message toastis opened, dismiss it and enter the
            // new message toastafter exit animation is complete.
            this._oldToastMessageRef.afterDismissed().subscribe((/**
             * @return {?}
             */
            () => {
                toastRef.toastInstance.enter();
            }));
            this._oldToastMessageRef.dismiss();
        }
        else {
            // If no message toastis in view, enter the message toast.
            toastRef.toastInstance.enter();
        }
        // If a message toastduration is provided, set up dismiss based on after the message toastis opened.
        if (config.duration && config.duration > 0) {
            toastRef.afterOpened().subscribe((/**
             * @return {?}
             */
            () => toastRef._dismissAfter((/** @type {?} */ (config.duration)))));
        }
        if (config.announcementMessage) {
            this._live.announce(config.announcementMessage, config.politeness);
        }
    }
    /**
     * @private
     * @param {?} config
     * @param {?} data
     * @param {?} injector
     * @return {?}
     */
    _createInjector(config, data, injector) {
        /** @type {?} */
        const tokens = new WeakMap();
        tokens.set(NxMessageToastConfig, config);
        tokens.set(NxMessageToastData, data);
        return new PortalInjector(injector, tokens);
    }
    /**
     * Dismisses the currently visible message toast.
     * @return {?}
     */
    dismiss() {
        if (this._oldToastMessageRef) {
            this._oldToastMessageRef.dismiss();
        }
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        if (this._toastRefAtThisLevel) {
            this._toastRefAtThisLevel.dismiss();
        }
    }
}
NxMessageToastService.decorators = [
    { type: Injectable, args: [{ providedIn: NxMessageModule },] }
];
/** @nocollapse */
NxMessageToastService.ctorParameters = () => [
    { type: Overlay },
    { type: Injector },
    { type: LiveAnnouncer },
    { type: NxMessageToastService, decorators: [{ type: Optional }, { type: SkipSelf }] },
    { type: NxMessageToastConfig, decorators: [{ type: Optional }, { type: Inject, args: [NX_MESSAGE_TOAST_DEFAULT_CONFIG,] }] }
];
/** @nocollapse */ NxMessageToastService.ngInjectableDef = ɵɵdefineInjectable({ factory: function NxMessageToastService_Factory() { return new NxMessageToastService(ɵɵinject(Overlay), ɵɵinject(INJECTOR), ɵɵinject(LiveAnnouncer), ɵɵinject(NxMessageToastService, 12), ɵɵinject(NX_MESSAGE_TOAST_DEFAULT_CONFIG, 8)); }, token: NxMessageToastService, providedIn: NxMessageModule });
if (false) {
    /**
     * Reference to the current message toast in the view *at this level* (in the Angular injector tree).
     * If there is a parent message toast service, all operations should delegate to that parent
     * via `_oldToastMessageRef`.
     * @type {?}
     * @private
     */
    NxMessageToastService.prototype._toastRefAtThisLevel;
    /**
     * @type {?}
     * @private
     */
    NxMessageToastService.prototype._overlay;
    /**
     * @type {?}
     * @private
     */
    NxMessageToastService.prototype._injector;
    /**
     * @type {?}
     * @private
     */
    NxMessageToastService.prototype._live;
    /**
     * @type {?}
     * @private
     */
    NxMessageToastService.prototype._parentMessageToastService;
    /**
     * @type {?}
     * @private
     */
    NxMessageToastService.prototype._defaultConfig;
}

/**
 * @fileoverview added by tsickle
 * Generated from: public-api.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * Generated from: allianz-ngx-ndbx-message.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

export { NX_MESSAGE_TOAST_DEFAULT_CONFIG, NxMessageComponent, NxMessageModule, NxMessageToastComponent, NxMessageToastConfig, NxMessageToastData, NxMessageToastRef, NxMessageToastService, messageToastAnimations };
//# sourceMappingURL=allianz-ngx-ndbx-message.js.map
