import { NxFormfieldControl, NxFormfieldComponent, NxFormfieldModule } from '@allianz/ngx-ndbx/formfield';
import { NxIconModule } from '@allianz/ngx-ndbx/icon';
import { ActiveDescendantKeyManager, A11yModule } from '@angular/cdk/a11y';
import { CdkConnectedOverlay, OverlayModule } from '@angular/cdk/overlay';
import { CommonModule } from '@angular/common';
import { Input, Component, ChangeDetectionStrategy, EventEmitter, Inject, Optional, ChangeDetectorRef, ElementRef, Output, ViewChild, Directive, TemplateRef, isDevMode, NgZone, Attribute, Self, ContentChildren, ContentChild, NgModule } from '@angular/core';
import { NxCheckboxModule } from '@allianz/ngx-ndbx/checkbox';
import { SelectionModel } from '@angular/cdk/collections';
import { DOWN_ARROW, UP_ARROW, LEFT_ARROW, RIGHT_ARROW, ENTER, SPACE, HOME, END, SHIFT, TAB } from '@angular/cdk/keycodes';
import { NgControl, NgForm, FormGroupDirective } from '@angular/forms';
import { Subject, defer, merge } from 'rxjs';
import { takeUntil, filter, map, take, switchMap, startWith, delay } from 'rxjs/operators';
import { ObserversModule } from '@angular/cdk/observers';

/**
 * @fileoverview added by tsickle
 * Generated from: dropdown-errors.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Returns an exception to be thrown when attempting to change a select's `multiple` option
 * after initialization.
 * \@docs-private
 * @return {?}
 */
function getNxDropdownDynamicMultipleError() {
    return Error('Cannot change `multiselect` mode of select after initialization.');
}
/**
 * Returns an exception to be thrown when attempting to assign a non-array value to a select
 * in `multiselect` mode. Note that `undefined` and `null` are still valid values to allow for
 * resetting the value.
 * \@docs-private
 * @return {?}
 */
function getNxDropdownNonArrayValueError() {
    return Error('Value must be an array in multiselect mode.');
}
/**
 * Returns an exception to be thrown when assigning a non-function value to the comparator
 * used to determine if a value corresponds to an option. Note that whether the function
 * actually takes two values and returns a boolean is not checked.
 * @return {?}
 */
function getNxDropdownNonFunctionValueError() {
    return Error('`compareWith` must be a function.');
}

/**
 * @fileoverview added by tsickle
 * Generated from: dropdown.control.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @abstract
 */
class NxDropdownControl extends NxFormfieldControl {
    constructor() {
        super(...arguments);
        /**
         * Whether the dropdown should allow multi selection and additional checkboxes are shown.
         *
         * Note: Please make sure the value you bind is an array. If not an error is thrown!
         */
        this.isMultiSelect = false;
    }
}
NxDropdownControl.propDecorators = {
    isMultiSelect: [{ type: Input, args: ['nxIsMultiselect',] }]
};
if (false) {
    /**
     * Whether the dropdown should allow multi selection and additional checkboxes are shown.
     *
     * Note: Please make sure the value you bind is an array. If not an error is thrown!
     * @type {?}
     */
    NxDropdownControl.prototype.isMultiSelect;
    /**
     * \@docs-private
     * @abstract
     * @param {?} value
     * @return {?}
     */
    NxDropdownControl.prototype.formatValue = function (value) { };
}

/**
 * @fileoverview added by tsickle
 * Generated from: group/dropdown-group.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class NxDropdownGroupComponent {
}
NxDropdownGroupComponent.decorators = [
    { type: Component, args: [{
                selector: 'nx-dropdown-group',
                template: "<div class=\"nx-dropdown-results__group\">\n  <div class=\"nx-dropdown-results__group-label\">{{label}}</div>\n  <ng-content></ng-content>\n</div>\n",
                changeDetection: ChangeDetectionStrategy.OnPush,
                styles: [":host{display:block}:host:first-child .nx-dropdown-results__group{background:rgba(236,236,236,.5);background:var(--dropdown-group-section-background-color,rgba(236,236,236,.5))}:host:first-child .nx-dropdown-results__group-label{padding-top:16px}.nx-dropdown-results__group-label{font-size:12px;font-size:var(--formfield-label-font-size,12px);line-height:16px;line-height:var(--formfield-label-line-height,16px);font-weight:var(--formfield-label-font-weight,600);letter-spacing:.5px;letter-spacing:var(--formfield-label-letter-spacing,.5px);font-style:italic;font-weight:700;padding:24px 32px 16px}"]
            }] }
];
NxDropdownGroupComponent.propDecorators = {
    label: [{ type: Input, args: ['nxLabel',] }]
};
if (false) {
    /**
     * Label displayed in the group.
     * @type {?}
     */
    NxDropdownGroupComponent.prototype.label;
}

/**
 * @fileoverview added by tsickle
 * Generated from: item/dropdown-item.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class NxDropdownItemChange {
    /**
     * @param {?} item
     * @param {?=} isUserInput
     */
    constructor(item, isUserInput = false) {
        this.item = item;
        this.isUserInput = isUserInput;
    }
}
if (false) {
    /**
     * Reference to the option that emitted the event.
     * @type {?}
     */
    NxDropdownItemChange.prototype.item;
    /**
     * Whether the change in the option's value was a result of a user action.
     * @type {?}
     */
    NxDropdownItemChange.prototype.isUserInput;
}
/**
 * the unique id counter
 * @type {?}
 */
let nextId = 0;
class NxDropdownItemComponent {
    /**
     * @param {?} _dropdown
     * @param {?} group
     * @param {?} _changeDetectorRef
     * @param {?} _elementRef
     */
    constructor(_dropdown, group, _changeDetectorRef, _elementRef) {
        this._dropdown = _dropdown;
        this.group = group;
        this._changeDetectorRef = _changeDetectorRef;
        this._elementRef = _elementRef;
        this._hidden = false;
        this._mostRecentViewValue = '';
        this._id = `nx-dropdown-item-${nextId++}`;
        this._selected = false;
        /**
         * Emits whenever the component is destroyed.
         */
        this._destroy = new Subject();
        /**
         * Event emitted when the option is selected or deselected.
         */
        // tslint:disable-next-line:no-output-on-prefix
        this.onSelectionChange = new EventEmitter();
        /**
         * Emits when the state of the option changes and any parents have to be notified.
         */
        this._stateChanges = new Subject();
        ((/** @type {?} */ (this._dropdown))).filterChanges.pipe(takeUntil(this._destroy)).subscribe((/**
         * @param {?} value
         * @return {?}
         */
        (value) => {
            this._showOrHideByFilter(value);
        }));
        // reset the hidden state when dropdown closes that on next open the user is seeing the full list again
        ((/** @type {?} */ (this._dropdown)))._closedStream.pipe(takeUntil(this._destroy)).subscribe((/**
         * @return {?}
         */
        () => {
            this._hidden = false;
        }));
    }
    /**
     * The unique ID of the option.
     * @return {?}
     */
    get id() { return this._id; }
    /**
     * Whether the item is selected.
     * @return {?}
     */
    get selected() {
        return this._selected;
    }
    /**
     * Whether the item is active.
     * @return {?}
     */
    get active() {
        return this._active;
    }
    /**
     * \@docs-private
     * Whether the parent dropdown is in multiselect mode.
     * @return {?}
     */
    get multiselect() {
        return this._dropdown && this._dropdown.isMultiSelect;
    }
    /**
     * @return {?}
     */
    ngAfterViewChecked() {
        // Since the parent dropdown component could be using the item's label to display the selected values
        // and it doesn't have a way of knowing if the item's label has changed
        // we have to check for changes in the DOM ourselves and dispatch an event. These checks are
        // relatively cheap, however we still limit them only to selected options in order to avoid
        // hitting the DOM too often.
        if (this._selected) {
            /** @type {?} */
            const viewValue = this.viewValue;
            if (viewValue !== this._mostRecentViewValue) {
                this._mostRecentViewValue = viewValue;
                this._stateChanges.next();
            }
        }
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this._stateChanges.complete();
        this._destroy.next();
        this._destroy.complete();
    }
    /**
     * @param {?} event
     * @return {?}
     */
    _onClick(event) {
        /* preventDefault to stop triggering the event twice when you click on the checkbox or the label inside the item */
        event.preventDefault();
        event.stopPropagation();
        this._selectViaInteraction();
    }
    /**
     * `Selects the option while indicating the selection came from the user. Used to
     * determine if the select's view -> model callback should be invoked.`
     * @return {?}
     */
    _selectViaInteraction() {
        this._selected = this.multiselect ? !this._selected : true;
        this._changeDetectorRef.markForCheck();
        this._emitSelectionChangeEvent(true);
    }
    /**
     * \@docs-private
     * @return {?}
     */
    show() {
        this._hidden = false;
        this._changeDetectorRef.markForCheck();
    }
    /**
     * \@docs-private
     * @return {?}
     */
    hide() {
        this._hidden = true;
        this._changeDetectorRef.markForCheck();
    }
    /**
     * @private
     * @param {?} search
     * @return {?}
     */
    _showOrHideByFilter(search) {
        /** @type {?} */
        const constraint = ((/** @type {?} */ (this._dropdown))).filterFn(search, this.viewValue);
        this._hidden = constraint ? false : true;
        this._changeDetectorRef.markForCheck();
    }
    /**
     * @return {?}
     */
    get _formattedValue() {
        return ((/** @type {?} */ (this._dropdown))).valueFormatter(this.value);
    }
    /**
     * \@docs-private
     * @return {?}
     */
    get viewValue() {
        return (this._elementRef.nativeElement.textContent || '').trim();
    }
    /**
     * \@docs-private
     * @return {?}
     */
    get elementRef() {
        return this._elementRef;
    }
    /**
     * @return {?}
     */
    select() {
        if (!this._selected) {
            this._selected = true;
            this._changeDetectorRef.markForCheck();
            this._emitSelectionChangeEvent();
        }
    }
    /**
     * \@docs-private
     * @return {?}
     */
    deselect() {
        if (this._selected) {
            this._selected = false;
            this._changeDetectorRef.markForCheck();
            this._emitSelectionChangeEvent();
        }
    }
    /**
     * \@docs-private
     * @return {?}
     */
    focus() {
        this._elementRef.nativeElement.focus();
    }
    /**
     * @private
     * @param {?=} isUserInput
     * @return {?}
     */
    _emitSelectionChangeEvent(isUserInput = false) {
        this.onSelectionChange.emit(new NxDropdownItemChange(this, isUserInput));
    }
    /**
     * \@docs-private
     * @return {?}
     */
    setActiveStyles() {
        this._active = true;
        this._changeDetectorRef.markForCheck();
    }
    /**
     * \@docs-private
     * @return {?}
     */
    setInactiveStyles() {
        this._active = false;
        this._changeDetectorRef.markForCheck();
    }
    /**
     * Returns the list item's text label. Implemented as a part of the ListKeyManagerOption.
     * \@docs-private
     * @return {?}
     */
    getLabel() {
        return this.viewValue;
    }
    /**
     * @param {?} element
     * @return {?}
     */
    _isContentEmpty(element) {
        return element.children.length === 0 && !element.textContent.trim();
    }
    /**
     * @return {?}
     */
    _onLabelChange() {
        // trigger change detection when the label content changes for the case that ng-content was empty before.
        // this is also important when the label comes in deferred, e.g. by a delayed observable,
        // then first the default label derived from the value is shown
        // and after the value from the async observable is ready we need to trigger change detection that the derived label
        // gets hidden again.
        // Notice(!): the event of (cdkObserveContent) is run outside of the ngZone
        // We run detectChanges directly here as markForCheck wasn't enough to always trigger change detection correctly
        this._changeDetectorRef.detectChanges();
    }
}
NxDropdownItemComponent.decorators = [
    { type: Component, args: [{
                selector: 'nx-dropdown-item',
                template: "<div #container class=\"nx-dropdown-results__option\"\n     [ngClass]=\"{'nx-dropdown-results__option--selected': selected}\">\n\n   <nx-checkbox *ngIf=\"multiselect\" [checked]=\"selected\">\n      <ng-container *ngTemplateOutlet=\"contentTemplate\"></ng-container>\n    </nx-checkbox>\n\n    <span *ngIf=\"!multiselect\" class=\"nx-dropdown-results__option-checkicon\">\n       <nx-icon name=\"check\" aria-hidden=\"true\"></nx-icon>\n    </span>\n\n    <ng-container *ngIf=\"!multiselect\">\n      <ng-container *ngTemplateOutlet=\"contentTemplate\"></ng-container>\n    </ng-container>\n</div>\n\n<ng-template #contentTemplate>\n  <div class=\"nx-dropdown-results__option-label\" >\n    <span #content (cdkObserveContent)=\"_onLabelChange()\">\n      <ng-content></ng-content>\n    </span>\n    <ng-container *ngIf=\"_isContentEmpty(content)\">\n      {{_formattedValue}}\n    </ng-container>\n  </div>\n</ng-template>\n",
                changeDetection: ChangeDetectionStrategy.OnPush,
                host: {
                    '[id]': 'id',
                    'role': 'option',
                    '[attr.aria-selected]': 'selected.toString()',
                    '[class.nx-hidden]': '_hidden',
                    '[class.nx-dropdown-item--active]': 'active',
                    '[class.nx-selected]': 'selected',
                    '[class.nx-multiselect]': 'multiselect',
                    '(click)': '_onClick($event)'
                },
                styles: [":host{display:block}:host(.nx-hidden){display:none}:host:first-child .nx-dropdown-results__option{padding-top:16px}:host:last-child .nx-dropdown-results__option{padding-bottom:16px}nx-checkbox{margin-bottom:0}.nx-dropdown-results__option{font-size:20px;font-size:var(--dropdown-item-font-size,20px);line-height:28px;line-height:var(--dropdown-item-line-height,28px);font-weight:400;font-weight:var(--dropdown-item-font-weight,400);letter-spacing:.2px;letter-spacing:var(--dropdown-item-letter-spacing,.2px);padding:8px 32px 8px 8px;cursor:pointer;position:relative;display:flex;max-width:100%;white-space:nowrap}.nx-dropdown-results__option-label{padding:0 12px;margin:0 -12px;color:#414141;color:var(--dropdown-item-text-color,#414141);white-space:pre-line}@media screen and (-ms-high-contrast:active){.nx-dropdown-results__option-label{-ms-high-contrast-adjust:none;color:buttonText;background-color:buttonFace;border-radius:4px}}:host(.nx-multiselect) .nx-dropdown-results__option{display:block;padding-left:32px}:host(.nx-selected):hover .nx-dropdown-results__option-checkicon,:host(.nx-selected):hover .nx-dropdown-results__option-label,:host:hover .nx-dropdown-results__option-label{color:#006192;color:var(--hover-primary,#006192)}@media screen and (-ms-high-contrast:active){:host(.nx-dropdown-item--active):not(.nx-multiselect) .nx-dropdown-results__option-label,:host:hover .nx-dropdown-results__option-label{color:highlightText;background-color:highlight}:host(.nx-dropdown-item--active):not(.nx-multiselect) .nx-dropdown-results__option-checkicon{-ms-high-contrast-adjust:none;color:highlightText;background:highlight;z-index:1}}:host(.nx-selected) .nx-dropdown-results__option-checkicon{opacity:1}:host(.nx-selected) .nx-dropdown-results__option-label{color:#414141;color:var(--dropdown-item-selected-color,#414141)}.nx-dropdown-results__option-checkicon{opacity:0;margin-right:8px;height:28px;height:var(--dropdown-item-line-height,28px);color:#414141;color:var(--dropdown-item-checkmark-color,#414141)}.nx-dropdown-results__option-checkicon nx-icon{line-height:28px;line-height:var(--dropdown-item-line-height,28px);font-size:16px}\n:host-context([data-whatinput=\"keyboard\"] .nx-dropdown__panel-body.is-stable).nx-dropdown-item--active .nx-dropdown-results__option .nx-dropdown-results__option-label {\n  border-radius: 4px;\n  box-shadow: 0 0 0 2px #ffffff, 0 0 0 6px #009DE6;\n  box-shadow: var(--focus-box-shadow, 0 0 0 2px #ffffff, 0 0 0 6px #009DE6); }\n  @media screen and (-ms-high-contrast: active) {\n    :host-context([data-whatinput=\"keyboard\"] .nx-dropdown__panel-body.is-stable).nx-dropdown-item--active .nx-dropdown-results__option .nx-dropdown-results__option-label {\n      box-shadow: 0 0 0 2px background, 0 0 0 6px windowText; } }\n\n\n:host-context([data-whatinput=\"keyboard\"] .nx-dropdown__panel-body.is-stable).nx-multiselect.nx-dropdown-item--active .nx-dropdown-results__option .nx-dropdown-results__option-label {\n  box-shadow: none; }\n  @media screen and (-ms-high-contrast: active) {\n    :host-context([data-whatinput=\"keyboard\"] .nx-dropdown__panel-body.is-stable).nx-multiselect.nx-dropdown-item--active .nx-dropdown-results__option .nx-dropdown-results__option-label {\n      box-shadow: none; } }\n\n:host-context([data-whatinput=\"keyboard\"] .nx-dropdown__panel-body.is-stable).nx-multiselect.nx-dropdown-item--active ::ng-deep .nx-checkbox__label {\n  border-radius: 4px;\n  box-shadow: 0 0 0 2px #ffffff, 0 0 0 6px #009DE6;\n  box-shadow: var(--focus-box-shadow, 0 0 0 2px #ffffff, 0 0 0 6px #009DE6); }\n  @media screen and (-ms-high-contrast: active) {\n    :host-context([data-whatinput=\"keyboard\"] .nx-dropdown__panel-body.is-stable).nx-multiselect.nx-dropdown-item--active ::ng-deep .nx-checkbox__label {\n      box-shadow: 0 0 0 2px background, 0 0 0 6px windowText; } }\n\n:host(.nx-selected.nx-dropdown-item--active) .nx-dropdown-results__option-label{padding-left:24px;margin-left:-24px}:host ::ng-deep .nx-checkbox__label{padding:0 4px;margin:0 -4px}"]
            }] }
];
/** @nocollapse */
NxDropdownItemComponent.ctorParameters = () => [
    { type: NxDropdownControl, decorators: [{ type: Inject, args: [NxDropdownControl,] }] },
    { type: NxDropdownGroupComponent, decorators: [{ type: Optional }] },
    { type: ChangeDetectorRef },
    { type: ElementRef }
];
NxDropdownItemComponent.propDecorators = {
    value: [{ type: Input, args: ['nxValue',] }],
    onSelectionChange: [{ type: Output }],
    containerElement: [{ type: ViewChild, args: ['container', { static: true },] }]
};
if (false) {
    /** @type {?} */
    NxDropdownItemComponent.prototype._hidden;
    /**
     * @type {?}
     * @private
     */
    NxDropdownItemComponent.prototype._mostRecentViewValue;
    /**
     * @type {?}
     * @private
     */
    NxDropdownItemComponent.prototype._id;
    /**
     * The value of the dropdown item.
     * You can't use undefined, null and '' (empty strings)
     * as they are sentinel values signalling empty data.
     * @type {?}
     */
    NxDropdownItemComponent.prototype.value;
    /**
     * @type {?}
     * @private
     */
    NxDropdownItemComponent.prototype._selected;
    /**
     * @type {?}
     * @private
     */
    NxDropdownItemComponent.prototype._active;
    /**
     * Emits whenever the component is destroyed.
     * @type {?}
     * @private
     */
    NxDropdownItemComponent.prototype._destroy;
    /**
     * Event emitted when the option is selected or deselected.
     * @type {?}
     */
    NxDropdownItemComponent.prototype.onSelectionChange;
    /**
     * Emits when the state of the option changes and any parents have to be notified.
     * @type {?}
     */
    NxDropdownItemComponent.prototype._stateChanges;
    /**
     * \@docs-private
     * The wrapping div in the template. Used by dropdown to use the container height for scrolling.
     * @type {?}
     */
    NxDropdownItemComponent.prototype.containerElement;
    /**
     * @type {?}
     * @private
     */
    NxDropdownItemComponent.prototype._dropdown;
    /**
     * \@docs-private
     * @type {?}
     */
    NxDropdownItemComponent.prototype.group;
    /**
     * @type {?}
     * @private
     */
    NxDropdownItemComponent.prototype._changeDetectorRef;
    /**
     * @type {?}
     * @private
     */
    NxDropdownItemComponent.prototype._elementRef;
}

/**
 * @fileoverview added by tsickle
 * Generated from: closed-label.directive.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
// This Directive solely purpose is to mark given ng-template and project it into the required destination.
class NxDropdownClosedLabelDirective {
    /**
     * @param {?} templateRef
     */
    constructor(templateRef) {
        this.templateRef = templateRef;
    }
}
NxDropdownClosedLabelDirective.decorators = [
    { type: Directive, args: [{
                selector: '[nxClosedLabel]'
            },] }
];
/** @nocollapse */
NxDropdownClosedLabelDirective.ctorParameters = () => [
    { type: TemplateRef }
];
if (false) {
    /** @type {?} */
    NxDropdownClosedLabelDirective.prototype.templateRef;
}

/**
 * @fileoverview added by tsickle
 * Generated from: dropdown.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Change event object that is emitted when the select value has changed.
 * @template T
 */
class NxDropdownSelectChange {
    /**
     * @param {?} source
     * @param {?} value
     */
    constructor(source, value) {
        this.source = source;
        this.value = value;
    }
}
if (false) {
    /**
     * Reference to the select that emitted the change event.
     * @type {?}
     */
    NxDropdownSelectChange.prototype.source;
    /**
     * Current value of the select that emitted the event.
     * @type {?}
     */
    NxDropdownSelectChange.prototype.value;
}
/**
 * @return {?}
 */
function getPositions() {
    return [{
            originX: 'start',
            originY: 'top',
            overlayX: 'start',
            overlayY: 'top'
        }, {
            originX: 'start',
            originY: 'center',
            overlayX: 'start',
            overlayY: 'center'
        }, {
            originX: 'start',
            originY: 'bottom',
            overlayX: 'start',
            overlayY: 'bottom'
        }];
}
class NxDropdownComponent extends NxDropdownControl {
    /**
     * @param {?} _changeDetectorRef
     * @param {?} _elementRef
     * @param {?} _ngZone
     * @param {?} tabIndex
     * @param {?} formFieldComponent
     * @param {?} ngControl
     * @param {?} _parentForm
     * @param {?} _parentFormGroup
     */
    constructor(_changeDetectorRef, _elementRef, _ngZone, tabIndex, formFieldComponent, ngControl, _parentForm, _parentFormGroup) {
        super();
        this._changeDetectorRef = _changeDetectorRef;
        this._elementRef = _elementRef;
        this._ngZone = _ngZone;
        this.formFieldComponent = formFieldComponent;
        this.ngControl = ngControl;
        this._parentForm = _parentForm;
        this._parentFormGroup = _parentFormGroup;
        // The dropdown currently doesn't support readonly of the NxFormfieldControl so we hardcode it here
        this.readonly = false;
        this._disabled = false;
        this._focused = false;
        /**
         * Whether or not the overlay panel is open.
         */
        this._panelOpen = false;
        /**
         * \@docs-private
         */
        this.errorState = false;
        /**
         * \@docs-private
         */
        this.isStable = false;
        /**
         * Name of this control that is used inside the formfield component
         * \@docs-private
         */
        this.controlType = 'nx-dropdown';
        /**
         * The minimal space between the viewport and the overlay
         */
        this._overlayViewportMargin = 16;
        /**
         * \@docs-private
         * Emits when internal state changes to inform formfield about it.
         */
        this.stateChanges = new Subject();
        /**
         * The IDs of child options to be passed to the aria-owns attribute.
         */
        this._optionIds = '';
        this._tabIndex = 0;
        /**
         * \@docs-private
         */
        this.currentFilter = '';
        /**
         * Label to describe the component.
         */
        this._ariaLabel = '';
        this._style = '';
        /**
         * Whether the dropdown should render in its negative style or not.
         */
        this._negative = false;
        /**
         * Whether the dropdown should be shown with an additional filter input.
         */
        this.showFilter = false;
        /**
         * Text displayed as placeholder for the filter.
         */
        this.filterPlaceholder = '';
        /**
         * Event emitted when the select panel has been toggled.
         */
        this.openedChange = new EventEmitter();
        /**
         * Event emitted when the select has been opened.
         */
        this._openedStream = this.openedChange.pipe(filter((/**
         * @param {?} o
         * @return {?}
         */
        o => o)), map((/**
         * @return {?}
         */
        () => { })));
        /**
         * Event emitted when the select has been closed.
         */
        this._closedStream = this.openedChange.pipe(filter((/**
         * @param {?} o
         * @return {?}
         */
        o => !o)), map((/**
         * @return {?}
         */
        () => { })));
        /**
         * Event emitted when the user types in the filter input.
         */
        this.filterChanges = new Subject();
        /**
         * Event that emits whenever the raw value of the select changes. This is here primarily
         * to facilitate the two-way binding for the `value` input.
         * \@docs-private
         */
        this.valueChange = new EventEmitter();
        /**
         * Event emitted when the selected value has been changed.
         */
        this.selectionChange = new EventEmitter();
        /**
         * \@docs-private
         */
        this.optionSelectionChanges = defer((/**
         * @return {?}
         */
        () => {
            if (this.options) {
                return merge(...this.options.map((/**
                 * @param {?} option
                 * @return {?}
                 */
                option => option.onSelectionChange)));
            }
            return this._ngZone.onStable
                .asObservable()
                .pipe(take(1), switchMap((/**
             * @return {?}
             */
            () => this.optionSelectionChanges)));
        }));
        /**
         * Emits whenever the component is destroyed.
         */
        this._destroy = new Subject();
        /**
         * Function that transforms the value into a string.
         * This function is used for displaying and filtering the content
         * ( Default: (value) => value ? value.toString() : null; ).
         */
        this.valueFormatter = (/**
         * @param {?} value
         * @return {?}
         */
        (value) => {
            return value == null ? '' : value.toString();
        });
        /**
         * Comparison function to specify which option is displayed. Defaults to object equality.
         */
        this._compareWith = (/**
         * @param {?} o1
         * @param {?} o2
         * @return {?}
         */
        (o1, o2) => o1 === o2);
        this._filterFn = (/**
         * @param {?} search
         * @param {?} itemValue
         * @return {?}
         */
        (search, itemValue) => {
            return itemValue.toLocaleLowerCase().indexOf(search.toLocaleLowerCase()) >= 0;
        });
        /**
         * `View -> model callback called when value changes`
         */
        this._onChange = (/**
         * @return {?}
         */
        () => { });
        /**
         * `View -> model callback called when select has been touched`
         */
        this._onTouched = (/**
         * @return {?}
         */
        () => { });
        if (this.ngControl) {
            // Note: we provide the value accessor through here, instead of
            // the `providers` to avoid running into a circular import.
            this.ngControl.valueAccessor = this;
        }
        this._positions = getPositions();
        this.tabIndex = parseInt(tabIndex, 10) || 0;
    }
    /**
     * @return {?}
     */
    get tabIndex() { return this.disabled ? -1 : this._tabIndex; }
    /**
     * @param {?} value
     * @return {?}
     */
    set tabIndex(value) {
        // If the specified tabIndex value is null or undefined, fall back to the default value.
        this._tabIndex = value != null ? value : 0;
    }
    /**
     * Selected value
     * @return {?}
     */
    get value() { return this._value; }
    /**
     * @param {?} newValue
     * @return {?}
     */
    set value(newValue) {
        if (newValue !== this._value) {
            this.writeValue(newValue);
            this._value = newValue;
            this._onChange(newValue);
        }
    }
    /**
     * Whether the dropdown is disabled.
     * @return {?}
     */
    get disabled() {
        return this._disabled;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set disabled(value) {
        this._disabled = value;
    }
    /**
     * If set to 'negative', the component is displayed with the negative set of styles.
     * @param {?} value
     * @return {?}
     */
    set styles(value) {
        if (this._style === value) {
            return;
        }
        this._style = value;
        this._negative = !!this._style.match(/negative/);
    }
    /**
     * \@docs-private
     * @return {?}
     */
    get closedDropdownLabel() {
        return this._closedDropdownLabel;
    }
    /**
     * \@docs-private
     * The currently selected option.
     * @return {?}
     */
    get selected() {
        return this.isMultiSelect ? this._selectionModel.selected : this._selectionModel.selected[0];
    }
    /**
     * \@docs-private
     * @return {?}
     */
    get panelOpen() {
        return this._panelOpen;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set panelOpen(value) {
        this._panelOpen = value;
    }
    /**
     * \@docs-private
     * @return {?}
     */
    get label() {
        return this.formFieldComponent ? this.formFieldComponent.label : '';
    }
    /**
     * Function to compare the option values with the selected values. The first argument
     * is a value from an option. The second is a value from the selection. A boolean
     * should be returned.
     * @return {?}
     */
    get compareWith() { return this._compareWith; }
    /**
     * @param {?} fn
     * @return {?}
     */
    set compareWith(fn) {
        if (typeof fn !== 'function') {
            throw getNxDropdownNonFunctionValueError();
        }
        this._compareWith = fn;
        if (this._selectionModel) {
            // A different comparator means the selection could change.
            this._initializeSelection();
        }
    }
    /**
     * Function to be used when the user types into the search filter. The first argument is the user input,
     * the second argument is the dropdown item value. The dropdown items will use this function to set their
     * visibility state.
     * A boolean should be returned.
     * @return {?}
     */
    get filterFn() { return this._filterFn; }
    /**
     * @param {?} fn
     * @return {?}
     */
    set filterFn(fn) {
        if (typeof fn !== 'function') {
            throw getNxDropdownNonFunctionValueError();
        }
        this._filterFn = fn;
    }
    /**
     * \@docs-private
     * Whether the select is focused.
     * @return {?}
     */
    get focused() {
        return this._focused || this.panelOpen;
    }
    /**
     * \@docs-private
     * @return {?}
     */
    get elementRef() {
        return this._elementRef;
    }
    /**
     * @return {?}
     */
    ngDoCheck() {
        if (this.ngControl) {
            this.updateErrorState();
        }
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this._selectionModel = new SelectionModel(this.isMultiSelect);
    }
    /**
     * @return {?}
     */
    ngAfterContentInit() {
        this._closedDropdownLabel =
            this._customClosedDropdownLabel && this._customClosedDropdownLabel.templateRef || this._defaultClosedDropdownLabel;
        this._initKeyManager();
        this._selectionModel.changed.pipe(takeUntil(this._destroy)).subscribe((/**
         * @param {?} event
         * @return {?}
         */
        event => {
            event.added.forEach((/**
             * @param {?} option
             * @return {?}
             */
            option => option.select()));
            event.removed.forEach((/**
             * @param {?} option
             * @return {?}
             */
            option => option.deselect()));
        }));
        this.options.changes.pipe(startWith(null), takeUntil(this._destroy)).subscribe((/**
         * @return {?}
         */
        () => {
            this._resetOptions();
            this._initializeSelection();
        }));
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this._destroy.next();
        this._destroy.complete();
    }
    /**
     * \@docs-private
     * @param {?} control
     * @param {?} form
     * @return {?}
     */
    isErrorState(control, form) {
        return !!(control && control.invalid && (control.touched || (form && form.submitted)));
    }
    /**
     * \@docs-private
     * @return {?}
     */
    updateErrorState() {
        /** @type {?} */
        const oldState = this.errorState;
        /** @type {?} */
        const parent = this._parentFormGroup || this._parentForm;
        /** @type {?} */
        const control = this.ngControl ? (/** @type {?} */ (this.ngControl.control)) : null;
        /** @type {?} */
        const newState = this.isErrorState(control, parent);
        if (newState !== oldState) {
            this.errorState = newState;
            this.stateChanges.next();
        }
    }
    /**
     * Sets up a key manager to listen to keyboard events on the overlay panel.
     * @private
     * @return {?}
     */
    _initKeyManager() {
        this._keyManager = new ActiveDescendantKeyManager(this.options)
            .withTypeAhead()
            .withWrap()
            .withVerticalOrientation()
            .withHorizontalOrientation('ltr')
            .skipPredicate((/**
         * @param {?} item
         * @return {?}
         */
        item => item._hidden));
        this._keyManager.tabOut.pipe(takeUntil(this._destroy)).subscribe((/**
         * @return {?}
         */
        () => {
            // Restore focus to the trigger before closing. Ensures that the focus
            // position won't be lost if the user got focus into the overlay.
            this.closePanel();
        }));
        this._keyManager.change.pipe(takeUntil(this._destroy)).subscribe((/**
         * @return {?}
         */
        () => {
            if (this._panelOpen && this.panel) {
                // Delay the auto scrolling until all items have settled otherwise the item containers might
                // not exist yet
                this._ngZone.onStable
                    .asObservable()
                    .pipe(take(1)).subscribe((/**
                 * @return {?}
                 */
                () => {
                    this._scrollActiveOptionIntoView();
                }));
            }
            else if (!this._panelOpen && !this.isMultiSelect && this._keyManager.activeItem) {
                this._keyManager.activeItem._selectViaInteraction();
            }
        }));
    }
    /**
     * @private
     * @return {?}
     */
    _resetOptions() {
        /** @type {?} */
        const changedOrDestroyed = merge(this.options.changes, this._destroy);
        this.optionSelectionChanges.pipe(takeUntil(changedOrDestroyed)).subscribe((/**
         * @param {?} event
         * @return {?}
         */
        event => {
            this._onSelect(event.item, event.isUserInput);
            if (event.isUserInput && !this.isMultiSelect && this._panelOpen) {
                this.closePanel();
            }
        }));
        // Listen to changes in the internal state of the options and react accordingly.
        // Handles cases like the labels of the selected options changing.
        merge(...this.options.map((/**
         * @param {?} option
         * @return {?}
         */
        option => option._stateChanges)))
            .pipe(takeUntil(changedOrDestroyed))
            .subscribe((/**
         * @return {?}
         */
        () => {
            // defer it for the next cycle to not run in changed after checked errors
            // the combination of dropdown-item notifying parent and when the parent
            // tries to fetch the triggerValue from the child throws these errors
            setTimeout((/**
             * @return {?}
             */
            () => {
                this._changeDetectorRef.markForCheck();
                this.stateChanges.next();
            }));
        }));
        this._setOptionIds();
    }
    /**
     * Records option IDs to pass to the aria-owns property.
     * @private
     * @return {?}
     */
    _setOptionIds() {
        this._optionIds = this.options.map((/**
         * @param {?} option
         * @return {?}
         */
        option => option.id)).join(' ');
    }
    /**
     * Invoked when an option is clicked.
     * @private
     * @param {?} option
     * @param {?} isUserInput
     * @return {?}
     */
    _onSelect(option, isUserInput) {
        /** @type {?} */
        const wasSelected = this._selectionModel.isSelected(option);
        if (option.value == null && !this.isMultiSelect) {
            option.deselect();
            this._selectionModel.clear();
            this._propagateChanges(option.value);
        }
        else {
            option.selected ? this._selectionModel.select(option) : this._selectionModel.deselect(option);
            if (isUserInput) {
                this._keyManager.setActiveItem(option);
            }
            if (this.isMultiSelect) {
                this._sortValues();
            }
        }
        if (wasSelected !== this._selectionModel.isSelected(option)) {
            this._propagateChanges();
        }
        this.stateChanges.next();
    }
    /**
     * @private
     * @return {?}
     */
    _initializeSelection() {
        // Defer setting the value in order to avoid the "Expression
        // has changed after it was checked" errors from Angular.
        Promise.resolve().then((/**
         * @return {?}
         */
        () => {
            this._setSelectionByValue(this.ngControl ? this.ngControl.value : this._value);
        }));
    }
    /**
     * Sets the selected option based on a value. If no option can be
     * found with the designated value, the select trigger is cleared.
     * @private
     * @param {?} value
     * @return {?}
     */
    _setSelectionByValue(value) {
        if (this.isMultiSelect && value) {
            if (!Array.isArray(value)) {
                throw getNxDropdownNonArrayValueError();
            }
            this._selectionModel.clear();
            value.forEach((/**
             * @param {?} currentValue
             * @return {?}
             */
            (currentValue) => this._selectValue(currentValue)));
            this._sortValues();
        }
        else {
            this._selectionModel.clear();
            /** @type {?} */
            const correspondingOption = this._selectValue(value);
            // Shift focus to the active item. Note that we shouldn't do this in multiple
            // mode, because we don't know what option the user interacted with last.
            if (correspondingOption) {
                this._keyManager.setActiveItem(correspondingOption);
            }
        }
        this._changeDetectorRef.markForCheck();
    }
    /**
     * Finds and selects and option based on its value.
     * @private
     * @param {?} value
     * @return {?} Option that has the corresponding value.
     */
    _selectValue(value) {
        /** @type {?} */
        const correspondingOption = this.options.find((/**
         * @param {?} option
         * @return {?}
         */
        (option) => {
            try {
                // Treat null as a special reset value.
                return option.value != null && this._compareWith(option.value, value);
            }
            catch (error) {
                if (isDevMode()) {
                    // Notify developers of errors in their comparator.
                    console.warn(error);
                }
                return false;
            }
        }));
        if (correspondingOption) {
            this._selectionModel.select(correspondingOption);
        }
        return correspondingOption;
    }
    /**
     * Emits change event to set the model value.
     * @private
     * @param {?=} fallbackValue
     * @return {?}
     */
    _propagateChanges(fallbackValue) {
        /** @type {?} */
        let valueToEmit = null;
        if (this.isMultiSelect) {
            valueToEmit = ((/** @type {?} */ (this.selected))).map((/**
             * @param {?} option
             * @return {?}
             */
            option => option.value));
        }
        else {
            valueToEmit = this.selected ? ((/** @type {?} */ (this.selected))).value : fallbackValue;
        }
        this._value = valueToEmit;
        this.valueChange.emit(valueToEmit);
        this._onChange(valueToEmit);
        this.selectionChange.emit(new NxDropdownSelectChange(this, valueToEmit));
        this._changeDetectorRef.markForCheck();
    }
    /**
     * Sorts the selected values in the selected based on their order in the panel.
     * @private
     * @return {?}
     */
    _sortValues() {
        if (this.isMultiSelect) {
            /** @type {?} */
            const options = this.options.toArray();
            this._selectionModel.sort((/**
             * @param {?} a
             * @param {?} b
             * @return {?}
             */
            (a, b) => options.indexOf(a) - options.indexOf(b)));
            this.stateChanges.next();
        }
    }
    /**
     * Adds a offset to the overlay position, so the formfield label and the dropdown panel header are vertically aligned.
     * @private
     * @return {?}
     */
    _updatePositionOffset() {
        /** @type {?} */
        let offset = 0;
        if (this.formFieldComponent !== null) {
            /** @type {?} */
            const formFieldRect = this.formFieldComponent.elementRef.nativeElement.getBoundingClientRect();
            /** @type {?} */
            const dropdownRect = this._elementRef.nativeElement.getBoundingClientRect();
            /** @type {?} */
            const panelHeader = this.overlayDir.overlayRef.overlayElement.querySelector('.nx-dropdown__panel-header');
            /** @type {?} */
            const panelHeaderPaddingTop = panelHeader ? parseInt(getComputedStyle(panelHeader).paddingTop, 10) : 0;
            offset = formFieldRect.top - dropdownRect.top - panelHeaderPaddingTop;
        }
        this._positions[0].offsetY = offset;
    }
    /**
     * Focuses the select element.
     * @return {?}
     */
    focus() {
        this._elementRef.nativeElement.focus();
    }
    /**
     * Opens the panel of the dropdown.
     * @return {?}
     */
    openPanel() {
        if (this.disabled || !this.options || !this.options.length || this._panelOpen) {
            return;
        }
        this._panelOpen = true;
        this._triggerRect = this.trigger.nativeElement.getBoundingClientRect();
        this._keyManager.withHorizontalOrientation(null);
        this._highlightCorrectOption();
        this._changeDetectorRef.markForCheck();
    }
    /**
     * Closes the panel of the dropdown.
     * @return {?}
     */
    closePanel() {
        if (this._panelOpen) {
            this._panelOpen = false;
            this.isStable = false;
            this._keyManager.withHorizontalOrientation('ltr');
            this._changeDetectorRef.markForCheck();
            this._onTouched();
            this.openedChange.emit(false);
            // defer the focus if the dropdown triggers actions that detach
            // a template/view from the DOM to prevent changed after checked errors
            setTimeout((/**
             * @return {?}
             */
            () => this.focus()));
        }
    }
    // calculate inital scrollTop when the dropdown opens
    // scrolls the selected item to the middle of the panel if possible
    /**
     * @private
     * @return {?}
     */
    _calculateScrollTop() {
        // reset the scrolltop to make calculation easier
        this.panelBody.nativeElement.scrollTop = 0;
        if (!this.empty) {
            /** @type {?} */
            const offset = this._getItemOffset(this._keyManager.activeItem);
            /** @type {?} */
            const panelHeight = this.panelBody.nativeElement.offsetHeight;
            /** @type {?} */
            const panelRect = this.panelBody.nativeElement.getBoundingClientRect();
            /** @type {?} */
            const middleOfPanel = panelRect.top + panelHeight / 2;
            if (offset > middleOfPanel) {
                // because we reset the scrollTop to 0 at the top we can simply take the middleOfPanel which is our
                // target position for the item and subtract it from the offset (which is now always relative to the viewport)
                this.panelBody.nativeElement.scrollTop = offset - middleOfPanel;
            }
        }
    }
    /**
     * Scrolls the active option into view.
     * @private
     * @return {?}
     */
    _scrollActiveOptionIntoView() {
        if (!this.panelOpen || !this._keyManager.activeItem) {
            return;
        }
        /** @type {?} */
        const activeItem = this._keyManager.activeItem.containerElement.nativeElement;
        /** @type {?} */
        const panel = this.panelBody.nativeElement;
        /** @type {?} */
        const panelOffset = panel.offsetTop;
        // how much the overlay is repositioned on the page
        /** @type {?} */
        const panelTopScrollPosition = panel.scrollTop;
        /** @type {?} */
        const panelHeight = panel.clientHeight;
        /** @type {?} */
        const itemTop = activeItem.offsetTop - panelOffset;
        /** @type {?} */
        const itemBottom = activeItem.offsetTop - panelOffset + activeItem.getBoundingClientRect().height;
        // item half or less visible on top
        if (itemTop < panelTopScrollPosition) {
            this.panelBody.nativeElement.scrollTop = itemTop;
            // item half or less visible on bottom
        }
        else if (itemBottom > (panelTopScrollPosition + panelHeight)) {
            this.panelBody.nativeElement.scrollTop = itemBottom - panelHeight;
        }
    }
    /**
     * \@docs-private
     * @private
     * @param {?} item
     * @return {?}
     */
    _getItemOffset(item) {
        /** @type {?} */
        const itemRect = item.containerElement.nativeElement.getBoundingClientRect();
        return itemRect.top + (itemRect.height / 2); // get position of the item's center
    }
    /**
     * \@docs-private
     * Formfield Implementation
     * @param {?} ids
     * @return {?}
     */
    setDescribedByIds(ids) {
        this.ariaDescribedby = ids.join(' ');
    }
    /**
     * \@docs-private
     * @param {?} value
     * @return {?}
     */
    setAriaLabel(value) {
        this._ariaLabel = value;
    }
    /**
     * @return {?}
     */
    _getAriaLabel() {
        return this._ariaLabel || (this.formFieldComponent ? this.formFieldComponent.label : null);
    }
    /**
     * @return {?}
     */
    get _isInOutlineField() {
        return this.formFieldComponent !== null
            && this.formFieldComponent.appearance === 'outline';
    }
    /**
     * \@docs-private
     * Whether the select has a value.
     * @return {?}
     */
    get empty() {
        return !this._selectionModel || this._selectionModel.isEmpty();
    }
    /**
     * \@docs-private
     * @return {?}
     */
    get hasValue() {
        return this._selectionModel.hasValue();
    }
    /**
     * \@docs-private
     * @return {?}
     */
    get shouldLabelFloat() {
        return this.focused || !this.empty;
    }
    /** End Formfield */
    /** ControlValueAccessor */
    /**
     * Sets the select's value. Part of the ControlValueAccessor interface
     * required to integrate with Angular's core forms API.
     *
     * @param {?} value New value to be written to the model.
     * @return {?}
     */
    writeValue(value) {
        if (this.options) {
            this._setSelectionByValue(value);
        }
    }
    /**
     * @param {?} fn
     * @return {?}
     */
    registerOnChange(fn) {
        this._onChange = fn;
    }
    /**
     * @param {?} fn
     * @return {?}
     */
    registerOnTouched(fn) {
        this._onTouched = fn;
    }
    /**
     * Disables the select. Part of the ControlValueAccessor interface required
     * to integrate with Angular's core forms API.
     *
     * @param {?} isDisabled Sets whether the component is disabled.
     * @return {?}
     */
    setDisabledState(isDisabled) {
        this.disabled = isDisabled;
        this._changeDetectorRef.markForCheck();
        this.stateChanges.next();
    }
    /**
     * End ControlValueAccessor
     * @param {?} event
     * @return {?}
     */
    _handleKeydown(event) {
        this.panelOpen ? this._handleOpenKeydown(event) : this._handleClosedKeydown(event);
    }
    /**
     * @private
     * @param {?} event
     * @return {?}
     */
    _handleClosedKeydown(event) {
        /** @type {?} */
        const keyCode = event.keyCode;
        /** @type {?} */
        const isArrowKey = keyCode === DOWN_ARROW || keyCode === UP_ARROW ||
            keyCode === LEFT_ARROW || keyCode === RIGHT_ARROW;
        /** @type {?} */
        const isOpenKey = keyCode === ENTER || keyCode === SPACE;
        // Open the select on ALT + arrow key to match the native <select>
        if (isOpenKey || ((this.isMultiSelect || event.altKey) && isArrowKey)) {
            event.preventDefault(); // prevents the page from scrolling down when pressing space
            this.openPanel();
        }
        else if (!this.isMultiSelect && !this.disabled) {
            this._keyManager.onKeydown(event);
        }
    }
    /**
     * @private
     * @param {?} event
     * @return {?}
     */
    _handleOpenKeydown(event) {
        /** @type {?} */
        const keyCode = event.keyCode;
        // if has filter all events other than the listed ones should be ignored or handled in _onFilter()
        if (!([DOWN_ARROW, UP_ARROW, HOME, END, ENTER, LEFT_ARROW, RIGHT_ARROW, SHIFT, SPACE, TAB].indexOf(keyCode) >= 0)
            && this.showFilter) {
            return;
        }
        /** @type {?} */
        const isArrowKey = keyCode === DOWN_ARROW || keyCode === UP_ARROW;
        /** @type {?} */
        const manager = this._keyManager;
        /** @type {?} */
        const allHidden = this.options.map((/**
         * @param {?} option
         * @return {?}
         */
        option => option._hidden)).every((/**
         * @param {?} option
         * @return {?}
         */
        option => Boolean(option)));
        if (keyCode === HOME || keyCode === END) {
            event.preventDefault();
            keyCode === HOME ? manager.setFirstItemActive() : manager.setLastItemActive();
        }
        else if (isArrowKey && event.altKey) {
            // Close the select on ALT + arrow key to match the native <select>
            event.preventDefault();
            this.closePanel();
        }
        else if (keyCode === ENTER && manager.activeItem && !allHidden) {
            event.preventDefault();
            manager.activeItem._selectViaInteraction();
        }
        else if (keyCode === ENTER && allHidden) {
            event.preventDefault();
            this.closePanel();
        }
        else if (!this.showFilter && keyCode === SPACE && manager.activeItem) {
            event.preventDefault();
            manager.activeItem._selectViaInteraction();
        }
        else if (keyCode === TAB) {
            this.closePanel();
        }
        else {
            /** @type {?} */
            const previouslyFocusedIndex = manager.activeItemIndex;
            manager.onKeydown(event);
            this._ngZone.onStable
                .asObservable()
                .pipe(take(1), delay(251) // we need to defer to get the new activeItemIndex. delay > debouncing of the typeAhead
            ).subscribe((/**
             * @return {?}
             */
            () => {
                this.isStable = true;
                this._changeDetectorRef.detectChanges();
            }));
            if (this.isMultiSelect && isArrowKey && event.shiftKey && manager.activeItem &&
                manager.activeItemIndex !== previouslyFocusedIndex) {
                manager.activeItem._selectViaInteraction();
            }
        }
    }
    /**
     * \@docs-private
     * @param {?} value
     * @return {?}
     */
    formatValue(value) {
        return this.valueFormatter(value);
    }
    /**
     * Called when the user types in the filter input
     * @param {?} event
     * @return {?}
     */
    _onFilter(event) {
        event.preventDefault();
        this.currentFilter = event.target.value;
        this.filterChanges.next(event.target.value);
        /** @type {?} */
        const allHidden = this.options.map((/**
         * @param {?} option
         * @return {?}
         */
        option => option._hidden)).every((/**
         * @param {?} option
         * @return {?}
         */
        option => Boolean(option)));
        if (allHidden) {
            this._keyManager.setActiveItem(null);
        }
        else {
            this._keyManager.setFirstItemActive();
        }
    }
    /**
     * \@docs-private
     * The value displayed in the trigger.
     * @return {?}
     */
    get triggerValue() {
        if (this.empty) {
            return '';
        }
        if (this.isMultiSelect) {
            /** @type {?} */
            const selectedOptions = this._selectionModel.selected.map((/**
             * @param {?} option
             * @return {?}
             */
            option => option.viewValue));
            return selectedOptions.join(', ');
        }
        return this._selectionModel.selected[0].viewValue;
    }
    /**
     * Highlights the selected item. If no option is selected, it will highlight
     * the first item instead.
     * @private
     * @return {?}
     */
    _highlightCorrectOption() {
        if (this._keyManager) {
            if (this.empty) {
                this._keyManager.setFirstItemActive();
            }
            else {
                this._keyManager.setActiveItem(this._selectionModel.selected[0]);
            }
        }
    }
    /**
     * Callback that is invoked when the overlay panel has been attached.
     * @return {?}
     */
    _onAttached() {
        this.overlayDir.positionChange.pipe(take(1)).subscribe((/**
         * @return {?}
         */
        () => {
            /** @type {?} */
            const overlayRef = this.overlayDir.overlayRef;
            /** @type {?} */
            const positionStrategy = (/** @type {?} */ (overlayRef.getConfig()
                .positionStrategy));
            this._updatePositionOffset();
            positionStrategy.withPositions(this._positions.slice());
            overlayRef.updatePosition();
            if (this._keyManager.activeItem) {
                this._calculateScrollTop();
            }
            this._changeDetectorRef.markForCheck();
            this.openedChange.emit(true);
            // If there is no item selected, the filter takes the focus.
            if (this.showFilter && !this._value) {
                this.filterInput.nativeElement.focus();
            }
            else {
                this.panelBody.nativeElement.focus();
            }
        }));
    }
    /**
     * @return {?}
     */
    _onFocus() {
        if (!this.disabled) {
            this._focused = true;
            this.stateChanges.next();
        }
    }
    /**
     * Calls the touched callback only if the panel is closed. Otherwise, the trigger will
     * "blur" to the panel when it opens, causing a false positive.
     * @return {?}
     */
    _onBlur() {
        this._focused = false;
        if (this.filterInput && this.showFilter) {
            this._clearFilter();
        }
        if (!this.disabled && !this.panelOpen) {
            this._onTouched();
            this._changeDetectorRef.markForCheck();
            this.stateChanges.next();
        }
    }
    /**
     * \@docs-private
     * @return {?}
     */
    get isFilterEmpty() {
        return this.currentFilter.length === 0;
    }
    /**
     * \@docs-private
     * @return {?}
     */
    _clearFilter() {
        this.filterInput.nativeElement.value = '';
        this.currentFilter = '';
        this.filterChanges.next('');
    }
    /**
     * \@docs-private determines the `aria-activedescendant` to be set on the host.
     * @return {?}
     */
    _getAriaActiveDescendant() {
        if (this.panelOpen && this._keyManager && this._keyManager.activeItem) {
            return this._keyManager.activeItem.id;
        }
        return null;
    }
}
NxDropdownComponent.decorators = [
    { type: Component, args: [{
                selector: 'nx-dropdown',
                template: "\n<!-- input and stuff-->\n<div cdkOverlayOrigin\n    #origin=\"cdkOverlayOrigin\"\n    class=\"nx-dropdown__container\"\n    #trigger>\n  <div class=\"nx-dropdown__rendered\">\n    <ng-container *ngTemplateOutlet=\"closedDropdownLabel\"></ng-container>\n  </div>\n  <div class=\"nx-dropdown__icon\">\n    <nx-icon class=\"nx-dropdown__chevron\" name=\"chevron-down\"></nx-icon>\n  </div>\n</div>\n\n<ng-template #defaultClosedDropdownLabel>\n  <span *ngIf=\"triggerValue\">{{ triggerValue }}</span>\n</ng-template>\n\n<!-- overlay -->\n<ng-template\n  cdkConnectedOverlay\n  cdkConnectedOverlayHasBackdrop\n  cdkConnectedOverlayBackdropClass=\"cdk-overlay-transparent-backdrop\"\n  [cdkConnectedOverlayOrigin]=\"origin\"\n  [cdkConnectedOverlayOpen]=\"panelOpen\"\n  [cdkConnectedOverlayPositions]=\"_positions\"\n  [cdkConnectedOverlayMinWidth]=\"_triggerRect?.width\"\n  [cdkConnectedOverlayFlexibleDimensions]=\"true\"\n  [cdkConnectedOverlayViewportMargin]=\"_overlayViewportMargin\"\n  [cdkConnectedOverlayPush]=\"true\"\n  (backdropClick)=\"closePanel()\"\n  (attach)=\"_onAttached()\"\n  (detach)=\"closePanel()\">\n\n  <div class=\"nx-dropdown__panel\"\n      [class.has-filter]=\"showFilter\"\n      [class.nx-dropdown__panel--in-outline-field]=\"_isInOutlineField\"\n      (keydown)=\"_handleKeydown($event)\"\n      #panel>\n    <div class=\"nx-dropdown__panel-header\" *ngIf=\"label\">\n      {{ label }}\n    </div>\n    <div class=\"nx-dropdown__filter\" *ngIf=\"showFilter\">\n      <input class=\"nx-dropdown__filter-input\"\n             [class.is-filled]=\"!isFilterEmpty\"\n             #filterInput\n             type=\"text\"\n             (input)=\"_onFilter($event)\"\n             [placeholder]=\"filterPlaceholder\"\n      >\n      <span class=\"nx-dropdown__filter-icon\" *ngIf=\"!isFilterEmpty\" (click)=\"_clearFilter()\">\n        <nx-icon name=\"close\"></nx-icon>\n      </span>\n    </div>\n\n    <div class=\"nx-dropdown__panel-body\"\n         tabindex=\"-1\"\n         role=\"listbox\"\n         #panelBody\n         [class.is-stable]=\"isStable\"\n         [attr.aria-activedescendant]=\"_getAriaActiveDescendant()\"\n         [attr.aria-multiselectable]=\"isMultiSelect\"\n    >\n        <ng-content></ng-content>\n      </div>\n  </div>\n</ng-template>\n",
                changeDetection: ChangeDetectionStrategy.OnPush,
                providers: [
                    { provide: NxDropdownControl, useExisting: NxDropdownComponent },
                    { provide: NxFormfieldControl, useExisting: NxDropdownComponent },
                ],
                host: {
                    'role': 'button',
                    '[class.nx-dropdown]': 'true',
                    '[class.is-filled]': 'hasValue',
                    '[class.has-focus]': 'focused',
                    '[class.nx-dropdown--negative]': '_negative',
                    '[class.nx-dropdown--disabled]': 'disabled',
                    '[attr.aria-describedby]': 'ariaDescribedby || null',
                    '[attr.aria-required]': 'required',
                    '[attr.aria-label]': '_getAriaLabel()',
                    'aria-haspopup': 'listbox',
                    '[attr.aria-expanded]': 'panelOpen',
                    '[attr.disabled]': 'disabled || null',
                    '[attr.tabindex]': 'tabIndex',
                    '(keydown)': '_handleKeydown($event)',
                    '(focus)': '_onFocus()',
                    '(blur)': '_onBlur()',
                    '(click)': 'openPanel()'
                },
                styles: [":host{display:block;width:100%}:host:focus{outline:0}:host(.nx-dropdown--negative):focus{font-weight:600}:host(.nx-dropdown--negative){color:#fff}.nx-dropdown__container{display:flex;justify-content:flex-end;align-items:center;height:100%;cursor:pointer}:host(.nx-dropdown--disabled) .nx-dropdown__container{cursor:not-allowed}.nx-dropdown__rendered{flex:1 1 auto;overflow:hidden;text-overflow:ellipsis;white-space:nowrap}.nx-dropdown__panel{box-shadow:0 2px 4px rgba(65,65,65,.5);border-radius:4px;min-width:100%}.nx-dropdown__panel ::ng-deep .nx-checkbox__label{font-size:20px;font-size:var(--dropdown-item-font-size,20px);line-height:28px;line-height:var(--dropdown-item-line-height,28px);font-weight:400;font-weight:var(--dropdown-item-font-weight,400);letter-spacing:.2px;letter-spacing:var(--dropdown-item-letter-spacing,.2px);display:flex;align-items:center}.nx-dropdown__panel:focus{outline:0}.nx-dropdown__panel--in-outline-field .nx-dropdown__panel-header{font-size:16px;font-size:var(--formfield-outline-label-font-size,16px);line-height:24px;line-height:var(--formfield-outline-label-line-height,24px);font-weight:600;font-weight:var(--formfield-outline-label-font-weight,600);letter-spacing:0;letter-spacing:var(--formfield-outline-label-letter-spacing,0)}.nx-dropdown__panel--in-outline-field .nx-dropdown__panel-body{max-height:calc(5 * (24px + 16px) + 16px);max-height:calc(5 * (var(--dropdown-item-outline-line-height,24px) + 16px) + 16px)}.nx-dropdown__panel--in-outline-field ::ng-deep .nx-dropdown-results__group-label{font-size:16px;font-size:var(--formfield-outline-label-font-size,16px);line-height:24px;line-height:var(--formfield-outline-label-line-height,24px);font-weight:var(--formfield-outline-label-font-weight,600);letter-spacing:0;letter-spacing:var(--formfield-outline-label-letter-spacing,0);font-style:normal;font-weight:700}.nx-dropdown__panel--in-outline-field ::ng-deep nx-dropdown-item .nx-dropdown-results__option,.nx-dropdown__panel--in-outline-field ::ng-deep nx-dropdown-item .nx-dropdown-results__option-label{font-size:16px;font-size:var(--dropdown-item-outline-font-size,16px);line-height:24px;line-height:var(--dropdown-item-outline-line-height,24px);font-weight:400;font-weight:var(--dropdown-item-outline-font-weight,400);letter-spacing:0;letter-spacing:var(--dropdown-item-outline-letter-spacing,0)}.nx-dropdown__panel--in-outline-field ::ng-deep nx-dropdown-item .nx-dropdown-results__option-checkicon{height:24px;height:var(--dropdown-item-outline-line-height,24px)}.nx-dropdown__panel--in-outline-field ::ng-deep .nx-dropdown__filter-input{font-size:16px;font-size:var(--formfield-outline-control-font-size,16px);line-height:24px;line-height:var(--formfield-outline-control-line-height,24px);font-weight:400;font-weight:var(--formfield-outline-control-font-weight,400);letter-spacing:0;letter-spacing:var(--formfield-outline-control-letter-spacing,0)}.nx-dropdown__panel--in-outline-field ::ng-deep .nx-dropdown__filter-input:empty{font-weight:300}.nx-dropdown__icon{font-size:24px;font-size:var(--dropdown-chevron-size,24px);line-height:0}.nx-dropdown__chevron{vertical-align:middle}.nx-dropdown__panel-header{font-size:12px;font-size:var(--formfield-label-font-size,12px);line-height:16px;line-height:var(--formfield-label-line-height,16px);font-weight:600;font-weight:var(--formfield-label-font-weight,600);letter-spacing:.5px;letter-spacing:var(--formfield-label-letter-spacing,.5px);color:#414141;color:var(--dropdown-panel-header-text-color,#414141);background-color:#ececec;background-color:var(--dropdown-panel-header-background-color,#ececec);padding:8px 32px;border-top-left-radius:4px;border-top-right-radius:4px;z-index:1}.nx-dropdown__panel-body{background-color:#fff;background-color:var(--dropdown-panel-background-color,#fff);max-height:calc(5 * (28px + 16px) + 16px);max-height:calc(5 * (var(--dropdown-item-line-height,28px) + 16px) + 16px);overflow-y:auto;outline:0}.nx-dropdown__filter{position:relative;padding:16px 32px 12px;background-color:#fff;background-color:var(--dropdown-panel-background-color,#fff)}.nx-dropdown__filter-input{font-size:20px;font-size:var(--formfield-control-font-size,20px);line-height:28px;line-height:var(--formfield-control-line-height,28px);font-weight:var(--formfield-control-font-weight,600);letter-spacing:.2px;letter-spacing:var(--formfield-control-letter-spacing,.2px);border:0;border-bottom:1px solid #767676;border-bottom:1px var(--dropdown-filter-input-border-color,#767676) solid;color:#414141;color:var(--dropdown-filter-input-text-color,#414141);width:100%;outline:0;background-color:transparent;padding:0 24px 3px 0;font-weight:300}.nx-dropdown__filter-input::-ms-clear{display:none}.nx-dropdown__panel.has-filter ::ng-deep nx-dropdown-item:first-of-type .nx-dropdown-results__option{padding-top:12px}.nx-dropdown__filter-icon{position:absolute;height:24px;right:32px;top:calc(16px + 1px);cursor:pointer}.nx-dropdown__filter-icon nx-icon{font-size:24px}.nx-dropdown__filter-input:focus{border-color:#007ab3;border-color:var(--dropdown-filter-input-active-border-color,#007ab3)}.nx-dropdown__filter-input.is-filled:focus{font-weight:600;color:#007ab3;color:var(--dropdown-filter-input-active-text-color,#007ab3);border-color:#007ab3;border-color:var(--dropdown-filter-input-active-border-color,#007ab3)}.nx-dropdown__filter-input.is-filled:focus+.nx-dropdown__filter-icon{color:#007ab3;color:var(--dropdown-filter-input-active-text-color,#007ab3)}@media screen and (-ms-high-contrast:active){.nx-dropdown__panel{box-shadow:0 0 0 1px windowText}.nx-dropdown__panel-header{border-bottom:1px solid windowText}.nx-dropdown__filter-input{border-bottom-color:buttonText}}"]
            }] }
];
/** @nocollapse */
NxDropdownComponent.ctorParameters = () => [
    { type: ChangeDetectorRef },
    { type: ElementRef },
    { type: NgZone },
    { type: String, decorators: [{ type: Attribute, args: ['tabindex',] }] },
    { type: NxFormfieldComponent, decorators: [{ type: Optional }] },
    { type: NgControl, decorators: [{ type: Self }, { type: Optional }] },
    { type: NgForm, decorators: [{ type: Optional }] },
    { type: FormGroupDirective, decorators: [{ type: Optional }] }
];
NxDropdownComponent.propDecorators = {
    tabIndex: [{ type: Input }],
    _ariaLabel: [{ type: Input, args: ['nxAriaLabel',] }],
    value: [{ type: Input, args: ['nxValue',] }],
    disabled: [{ type: Input, args: ['nxDisabled',] }],
    required: [{ type: Input, args: ['nxRequired',] }],
    styles: [{ type: Input, args: ['nxStyle',] }],
    showFilter: [{ type: Input, args: ['nxShowFilter',] }],
    filterPlaceholder: [{ type: Input, args: ['nxFilterPlaceholder',] }],
    openedChange: [{ type: Output }],
    _openedStream: [{ type: Output, args: ['opened',] }],
    _closedStream: [{ type: Output, args: ['closed',] }],
    filterChanges: [{ type: Output, args: ['filterInput',] }],
    valueChange: [{ type: Output, args: ['nxValueChange',] }],
    selectionChange: [{ type: Output }],
    panel: [{ type: ViewChild, args: ['panel', { static: false },] }],
    panelBody: [{ type: ViewChild, args: ['panelBody', { static: false },] }],
    trigger: [{ type: ViewChild, args: ['trigger', { static: true },] }],
    filterInput: [{ type: ViewChild, args: ['filterInput', { static: false },] }],
    overlayDir: [{ type: ViewChild, args: [CdkConnectedOverlay, { static: true },] }],
    options: [{ type: ContentChildren, args: [NxDropdownItemComponent, { descendants: true },] }],
    groups: [{ type: ContentChildren, args: [NxDropdownGroupComponent,] }],
    _customClosedDropdownLabel: [{ type: ContentChild, args: [NxDropdownClosedLabelDirective, { static: false },] }],
    _defaultClosedDropdownLabel: [{ type: ViewChild, args: ['defaultClosedDropdownLabel', { static: true },] }],
    valueFormatter: [{ type: Input, args: ['nxValueFormatter',] }],
    compareWith: [{ type: Input }],
    filterFn: [{ type: Input }]
};
if (false) {
    /** @type {?} */
    NxDropdownComponent.prototype.readonly;
    /**
     * @type {?}
     * @private
     */
    NxDropdownComponent.prototype._selectionModel;
    /**
     * @type {?}
     * @protected
     */
    NxDropdownComponent.prototype._disabled;
    /**
     * @type {?}
     * @private
     */
    NxDropdownComponent.prototype._focused;
    /**
     * Whether or not the overlay panel is open.
     * @type {?}
     * @private
     */
    NxDropdownComponent.prototype._panelOpen;
    /**
     * \@docs-private
     * @type {?}
     */
    NxDropdownComponent.prototype.errorState;
    /**
     * \@docs-private
     * @type {?}
     */
    NxDropdownComponent.prototype.isStable;
    /**
     * Name of this control that is used inside the formfield component
     * \@docs-private
     * @type {?}
     */
    NxDropdownComponent.prototype.controlType;
    /**
     * Holds the value from nxValue.
     * @type {?}
     * @private
     */
    NxDropdownComponent.prototype._value;
    /**
     * The minimal space between the viewport and the overlay
     * @type {?}
     */
    NxDropdownComponent.prototype._overlayViewportMargin;
    /**
     * The last measured value for the trigger's client bounding rect.
     * @type {?}
     */
    NxDropdownComponent.prototype._triggerRect;
    /**
     * Holds the panelWidth after panel was attached.
     * @type {?}
     */
    NxDropdownComponent.prototype._panelWidth;
    /**
     * \@docs-private
     * Emits when internal state changes to inform formfield about it.
     * @type {?}
     */
    NxDropdownComponent.prototype.stateChanges;
    /**
     * The IDs of child options to be passed to the aria-owns attribute.
     * @type {?}
     */
    NxDropdownComponent.prototype._optionIds;
    /**
     * \@docs-private
     * @type {?}
     */
    NxDropdownComponent.prototype.ariaDescribedby;
    /**
     * @type {?}
     * @private
     */
    NxDropdownComponent.prototype._tabIndex;
    /**
     * \@docs-private
     * @type {?}
     */
    NxDropdownComponent.prototype.currentFilter;
    /**
     * Label to describe the component.
     * @type {?}
     */
    NxDropdownComponent.prototype._ariaLabel;
    /**
     * Whether the component is required. This adds an aria-required label to the component.
     * @type {?}
     */
    NxDropdownComponent.prototype.required;
    /**
     * @type {?}
     * @private
     */
    NxDropdownComponent.prototype._style;
    /**
     * Whether the dropdown should render in its negative style or not.
     * @type {?}
     */
    NxDropdownComponent.prototype._negative;
    /**
     * Whether the dropdown should be shown with an additional filter input.
     * @type {?}
     */
    NxDropdownComponent.prototype.showFilter;
    /**
     * Text displayed as placeholder for the filter.
     * @type {?}
     */
    NxDropdownComponent.prototype.filterPlaceholder;
    /**
     * Event emitted when the select panel has been toggled.
     * @type {?}
     */
    NxDropdownComponent.prototype.openedChange;
    /**
     * Event emitted when the select has been opened.
     * @type {?}
     */
    NxDropdownComponent.prototype._openedStream;
    /**
     * Event emitted when the select has been closed.
     * @type {?}
     */
    NxDropdownComponent.prototype._closedStream;
    /**
     * Event emitted when the user types in the filter input.
     * @type {?}
     */
    NxDropdownComponent.prototype.filterChanges;
    /**
     * Event that emits whenever the raw value of the select changes. This is here primarily
     * to facilitate the two-way binding for the `value` input.
     * \@docs-private
     * @type {?}
     */
    NxDropdownComponent.prototype.valueChange;
    /**
     * Event emitted when the selected value has been changed.
     * @type {?}
     */
    NxDropdownComponent.prototype.selectionChange;
    /**
     * \@docs-private
     * @type {?}
     */
    NxDropdownComponent.prototype.optionSelectionChanges;
    /**
     * This position config ensures that the top "start" corner of the overlay
     * is aligned with with the top "start" of the origin by default (overlapping
     * the trigger completely). If the panel cannot fit below the trigger, it
     * will fall back to a position above the trigger.
     * @type {?}
     */
    NxDropdownComponent.prototype._positions;
    /**
     * \@docs-private
     * Panel containing the select options.
     * @type {?}
     */
    NxDropdownComponent.prototype.panel;
    /**
     * \@docs-private
     * @type {?}
     */
    NxDropdownComponent.prototype.panelBody;
    /**
     * \@docs-private
     * @type {?}
     */
    NxDropdownComponent.prototype.trigger;
    /**
     * \@docs-private
     * @type {?}
     */
    NxDropdownComponent.prototype.filterInput;
    /**
     * \@docs-private
     * Overlay pane containing the options.
     * @type {?}
     */
    NxDropdownComponent.prototype.overlayDir;
    /**
     * \@docs-private
     * @type {?}
     */
    NxDropdownComponent.prototype.options;
    /**
     * \@docs-private
     * @type {?}
     */
    NxDropdownComponent.prototype.groups;
    /** @type {?} */
    NxDropdownComponent.prototype._customClosedDropdownLabel;
    /**
     * @type {?}
     * @private
     */
    NxDropdownComponent.prototype._defaultClosedDropdownLabel;
    /**
     * @type {?}
     * @private
     */
    NxDropdownComponent.prototype._closedDropdownLabel;
    /**
     * Emits whenever the component is destroyed.
     * @type {?}
     * @private
     */
    NxDropdownComponent.prototype._destroy;
    /**
     * @type {?}
     * @private
     */
    NxDropdownComponent.prototype._keyManager;
    /**
     * Function that transforms the value into a string.
     * This function is used for displaying and filtering the content
     * ( Default: (value) => value ? value.toString() : null; ).
     * @type {?}
     */
    NxDropdownComponent.prototype.valueFormatter;
    /**
     * Comparison function to specify which option is displayed. Defaults to object equality.
     * @type {?}
     * @private
     */
    NxDropdownComponent.prototype._compareWith;
    /**
     * @type {?}
     * @private
     */
    NxDropdownComponent.prototype._filterFn;
    /**
     * `View -> model callback called when value changes`
     * @type {?}
     */
    NxDropdownComponent.prototype._onChange;
    /**
     * `View -> model callback called when select has been touched`
     * @type {?}
     */
    NxDropdownComponent.prototype._onTouched;
    /**
     * @type {?}
     * @private
     */
    NxDropdownComponent.prototype._changeDetectorRef;
    /**
     * @type {?}
     * @private
     */
    NxDropdownComponent.prototype._elementRef;
    /**
     * @type {?}
     * @private
     */
    NxDropdownComponent.prototype._ngZone;
    /**
     * @type {?}
     * @private
     */
    NxDropdownComponent.prototype.formFieldComponent;
    /**
     * \@docs-private
     * @type {?}
     */
    NxDropdownComponent.prototype.ngControl;
    /**
     * @type {?}
     * @private
     */
    NxDropdownComponent.prototype._parentForm;
    /**
     * @type {?}
     * @private
     */
    NxDropdownComponent.prototype._parentFormGroup;
}

/**
 * @fileoverview added by tsickle
 * Generated from: dropdown.module.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class NxDropdownModule {
}
NxDropdownModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    CommonModule,
                    NxFormfieldModule,
                    NxCheckboxModule,
                    OverlayModule,
                    A11yModule,
                    NxIconModule,
                    ObserversModule
                ],
                declarations: [
                    NxDropdownComponent,
                    NxDropdownItemComponent,
                    NxDropdownGroupComponent,
                    NxDropdownClosedLabelDirective
                ],
                exports: [
                    NxDropdownComponent,
                    NxDropdownItemComponent,
                    NxDropdownGroupComponent,
                    NxDropdownClosedLabelDirective
                ]
            },] }
];

/**
 * @fileoverview added by tsickle
 * Generated from: public-api.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * Generated from: allianz-ngx-ndbx-dropdown.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

export { NxDropdownComponent, NxDropdownGroupComponent, NxDropdownItemChange, NxDropdownItemComponent, NxDropdownModule, NxDropdownSelectChange, NxDropdownControl as a, NxDropdownClosedLabelDirective as b };
//# sourceMappingURL=allianz-ngx-ndbx-dropdown.js.map
