import { CommonModule } from '@angular/common';
import { InjectionToken, Directive, ElementRef, Optional, Self, Inject, Input, Component, ChangeDetectionStrategy, ChangeDetectorRef, NgModule } from '@angular/core';
import { NxFormfieldControl, NxFormfieldModule } from '@allianz/ngx-ndbx/formfield';
import { coerceBooleanProperty } from '@angular/cdk/coercion';
import { getSupportedInputTypes, Platform } from '@angular/cdk/platform';
import { NgControl, NgForm, FormGroupDirective } from '@angular/forms';
import { Subject } from 'rxjs';
import { AutofillMonitor } from '@angular/cdk/text-field';
import { ErrorStateMatcher } from '@allianz/ngx-ndbx/utils';
import { ENTER, SPACE } from '@angular/cdk/keycodes';
import { NxIconModule } from '@allianz/ngx-ndbx/icon';

/**
 * @fileoverview added by tsickle
 * Generated from: input.directive.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const NX_INPUT_VALUE_ACCESSOR = new InjectionToken('NX_INPUT_VALUE_ACCESSOR');
/** @type {?} */
const INVALID_TYPES = [
    'button',
    'checkbox',
    'file',
    'hidden',
    'image',
    'radio',
    'range',
    'reset',
    'submit'
];
const ɵ0 = /**
 * @param {?} t
 * @return {?}
 */
t => getSupportedInputTypes().has(t);
/** @type {?} */
const NEVER_EMPTY = [
    'date',
    'datetime',
    'datetime-local',
    'month',
    'time',
    'week'
].filter((ɵ0));
/** @type {?} */
let nextUniqueId = 0;
class NxInputDirective {
    /**
     * @param {?} _elementRef
     * @param {?} _platform
     * @param {?} ngControl
     * @param {?} _parentForm
     * @param {?} _parentFormGroup
     * @param {?} _errorStateMatcher
     * @param {?} inputValueAccessor
     * @param {?} _autofillMonitor
     */
    constructor(_elementRef, _platform, ngControl, _parentForm, _parentFormGroup, _errorStateMatcher, inputValueAccessor, _autofillMonitor) {
        this._elementRef = _elementRef;
        this._platform = _platform;
        this.ngControl = ngControl;
        this._parentForm = _parentForm;
        this._parentFormGroup = _parentFormGroup;
        this._errorStateMatcher = _errorStateMatcher;
        this._autofillMonitor = _autofillMonitor;
        this._type = 'text';
        this._uid = `nx-input-${nextUniqueId++}`;
        this._disabled = false;
        this._required = false;
        this._readonly = false;
        /**
         * \@docs-private
         */
        this.errorState = false;
        /**
         * Name of this control that is used inside the formfield component
         * \@docs-private
         */
        this.controlType = 'nx-input';
        /**
         * \@docs-private
         */
        this.autofilled = false;
        /**
         * \@docs-private
         */
        this.stateChanges = new Subject();
        /**
         * \@docs-private
         */
        this.focused = false;
        this.id = this.id;
        // This will enable other directives to plugin itself as the value accessor
        // by using the NX_INPUT_VALUE_ACCESSOR Token. Default is the given input field.
        // TODO eliminate injected dateValueAccessor once we have intra-package support in ng-packagr
        // See the datefield for details.
        this._inputValueAccessor = inputValueAccessor || this._elementRef.nativeElement;
        this._previousNativeValue = this.value;
        if (this._elementRef.nativeElement.nodeName.toLowerCase() === 'textarea') {
            this.controlType = 'textarea';
        }
    }
    /**
     * The id of the input.
     * @return {?}
     */
    get id() {
        return this._id;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set id(value) {
        this._id = value || this._uid;
    }
    /**
     * The input element's value.
     * @return {?}
     */
    get value() { return this._inputValueAccessor.value; }
    /**
     * @param {?} value
     * @return {?}
     */
    set value(value) {
        if (value !== this.value) {
            this._inputValueAccessor.value = value;
        }
    }
    /**
     * Whether the element is readonly.
     * @return {?}
     */
    get readonly() { return this._readonly; }
    /**
     * @param {?} value
     * @return {?}
     */
    set readonly(value) {
        this._readonly = coerceBooleanProperty(value);
        this.stateChanges.next();
    }
    /**
     * Whether the input is disabled.
     * @return {?}
     */
    get disabled() {
        if (this.ngControl && this.ngControl.disabled !== null) {
            return this.ngControl.disabled;
        }
        return this._disabled;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set disabled(value) {
        this._disabled = coerceBooleanProperty(value);
        // Browsers may not fire the blur event if the input is disabled too quickly.
        // Reset from here to ensure that the element doesn't become stuck.
        if (this.focused) {
            this.focused = false;
            this.stateChanges.next();
        }
    }
    /**
     * Whether the element is required.
     * @return {?}
     */
    get required() { return this._required; }
    /**
     * @param {?} value
     * @return {?}
     */
    set required(value) { this._required = coerceBooleanProperty(value); }
    /**
     * Sets the type of the input element (e.g. password, text etc).
     * @return {?}
     */
    get type() { return this._type; }
    /**
     * @param {?} value
     * @return {?}
     */
    set type(value) {
        this._type = value || 'text';
        this._validateType();
        // When using Angular inputs, developers are no longer able to set the properties on the native
        // input element. To ensure that bindings for `type` work, we need to sync the setter
        // with the native property. Textarea elements don't support the type property or attribute.
        if (!this._isTextarea() && getSupportedInputTypes().has(this._type)) {
            this._elementRef.nativeElement.type = this._type;
        }
    }
    /**
     * Sets the text for the input placeholder
     * @return {?}
     */
    get placeholder() {
        return this.empty ? this._placeholder : '';
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set placeholder(value) {
        this._placeholder = value;
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        if (this._platform.isBrowser) {
            this._autofillMonitor.monitor(this._elementRef.nativeElement).subscribe((/**
             * @param {?} event
             * @return {?}
             */
            event => {
                this.autofilled = event.isAutofilled;
                this.stateChanges.next();
            }));
        }
    }
    /**
     * \@docs-private
     * @return {?}
     */
    get elementRef() {
        return this._elementRef;
    }
    /**
     * @return {?}
     */
    _onInput() {
        // force to to run change detection so we know about changes in the native form input
    }
    /**
     * @param {?} isFocused
     * @return {?}
     */
    _focusChanged(isFocused) {
        if (isFocused !== this.focused && !this.readonly) {
            this.focused = isFocused;
            this.stateChanges.next();
        }
    }
    /**
     * @return {?}
     */
    ngOnChanges() {
        this.stateChanges.next();
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this.stateChanges.complete();
        if (this._platform.isBrowser) {
            this._autofillMonitor.stopMonitoring(this._elementRef.nativeElement);
        }
    }
    /**
     * @return {?}
     */
    ngDoCheck() {
        if (this.ngControl) {
            // We need to re-evaluate this on every change detection cycle, because there are some
            // error triggers that we can't subscribe to (e.g. parent form submissions). This means
            // that whatever logic is in here has to be super lean or we risk destroying the performance.
            this.updateErrorState();
        }
        // We need to dirty-check the native element's value, because there are some cases where
        // we won't be notified when it changes (e.g. the consumer isn't using forms or they're
        // updating the value using `emitEvent: false`).
        this._dirtyCheckNativeValue();
    }
    /**
     * \@docs-private
     * @return {?}
     */
    updateErrorState() {
        /** @type {?} */
        const oldState = this.errorState;
        /** @type {?} */
        const parent = this._parentFormGroup || this._parentForm;
        /** @type {?} */
        const control = this.ngControl ? (/** @type {?} */ (this.ngControl.control)) : null;
        /** @type {?} */
        const newState = this._errorStateMatcher.isErrorState(control, parent);
        if (newState !== oldState) {
            this.errorState = newState;
            this.stateChanges.next();
        }
    }
    /**
     * Set a list of ids that is currently describing this input
     * (if you have hints and errors for example).
     * @param {?} ids
     * @return {?}
     */
    setDescribedByIds(ids) {
        this._ariaDescribedby = ids.join(' ');
    }
    // allow to set a arial label value in case there
    // is not possibility to display a proper label
    /**
     * Method to set the aria label.
     * This is required if you use the input outside of a formfield
     * where you don't have a label connected.
     * @param {?} value
     * @return {?}
     */
    setAriaLabel(value) {
        this._ariaLabel = value;
    }
    /**
     * @protected
     * @return {?}
     */
    _isBadInput() {
        // The `validity` property won't be present on platform-server.
        /** @type {?} */
        const validity = ((/** @type {?} */ (this._elementRef.nativeElement))).validity;
        return validity && validity.badInput;
    }
    /**
     * \@docs-private
     * @return {?}
     */
    get empty() {
        return !this._isNeverEmpty() && !this._elementRef.nativeElement.value && !this._isBadInput() && !this.autofilled;
    }
    /**
     * @protected
     * @return {?}
     */
    _isNeverEmpty() {
        return NEVER_EMPTY.indexOf(this._type) > -1;
    }
    /**
     * @protected
     * @return {?}
     */
    _isTextarea() {
        /** @type {?} */
        const nativeElement = this._elementRef.nativeElement;
        return nativeElement.nodeName ? nativeElement.nodeName.toLowerCase() === 'textarea' : false;
    }
    /**
     * @protected
     * @return {?}
     */
    _validateType() {
        if (INVALID_TYPES.indexOf(this._type) > -1) {
            throw new Error(`Input of type '${this._type}' is not supported`);
        }
    }
    /**
     * \@docs-private
     * @return {?}
     */
    get shouldLabelFloat() {
        return this.focused || !this.empty || (this.placeholder && this.placeholder.length > 0);
    }
    /**
     * @protected
     * @return {?}
     */
    _dirtyCheckNativeValue() {
        /** @type {?} */
        const newValue = this.value;
        if (this._previousNativeValue !== newValue) {
            this._previousNativeValue = newValue;
            this.stateChanges.next();
        }
    }
}
NxInputDirective.decorators = [
    { type: Directive, args: [{
                selector: 'input[nxInput], textarea[nxInput], select[nxInput]',
                exportAs: 'nxInput',
                host: {
                    '[class.c-input]': 'true',
                    '[attr.id]': 'id',
                    '[class.is-filled]': 'empty === false',
                    '[class.is-disabled]': 'disabled',
                    '[class.has-error]': 'errorState',
                    '[class.is-focused]': 'focused',
                    '[attr.disabled]': 'disabled || null',
                    '[attr.readonly]': 'readonly || null',
                    '[attr.required]': 'required || null',
                    '[attr.aria-label]': '_ariaLabel || null',
                    '[attr.aria-describedby]': '_ariaDescribedby || null',
                    '[attr.aria-invalid]': 'errorState',
                    '[attr.aria-required]': 'required.toString()',
                    '[attr.placeholder]': 'placeholder || null',
                    '(blur)': '_focusChanged(false)',
                    '(focus)': '_focusChanged(true)',
                    '(input)': '_onInput()',
                },
                providers: [{ provide: NxFormfieldControl, useExisting: NxInputDirective }],
            },] }
];
/** @nocollapse */
NxInputDirective.ctorParameters = () => [
    { type: ElementRef },
    { type: Platform },
    { type: NgControl, decorators: [{ type: Optional }, { type: Self }] },
    { type: NgForm, decorators: [{ type: Optional }] },
    { type: FormGroupDirective, decorators: [{ type: Optional }] },
    { type: ErrorStateMatcher },
    { type: undefined, decorators: [{ type: Optional }, { type: Self }, { type: Inject, args: [NX_INPUT_VALUE_ACCESSOR,] }] },
    { type: AutofillMonitor }
];
NxInputDirective.propDecorators = {
    _ariaLabel: [{ type: Input, args: ['nxAriaLabel',] }],
    id: [{ type: Input }],
    value: [{ type: Input }],
    readonly: [{ type: Input }],
    disabled: [{ type: Input }],
    required: [{ type: Input }],
    type: [{ type: Input }],
    placeholder: [{ type: Input }]
};
if (false) {
    /**
     * @type {?}
     * @protected
     */
    NxInputDirective.prototype._type;
    /**
     * @type {?}
     * @protected
     */
    NxInputDirective.prototype._id;
    /**
     * @type {?}
     * @protected
     */
    NxInputDirective.prototype._uid;
    /**
     * @type {?}
     * @protected
     */
    NxInputDirective.prototype._previousNativeValue;
    /**
     * @type {?}
     * @protected
     */
    NxInputDirective.prototype._disabled;
    /**
     * @type {?}
     * @protected
     */
    NxInputDirective.prototype._required;
    /**
     * @type {?}
     * @private
     */
    NxInputDirective.prototype._readonly;
    /**
     * @type {?}
     * @private
     */
    NxInputDirective.prototype._inputValueAccessor;
    /** @type {?} */
    NxInputDirective.prototype._ariaDescribedby;
    /**
     * @type {?}
     * @private
     */
    NxInputDirective.prototype._placeholder;
    /** @type {?} */
    NxInputDirective.prototype._ariaLabel;
    /**
     * \@docs-private
     * @type {?}
     */
    NxInputDirective.prototype.errorState;
    /**
     * Name of this control that is used inside the formfield component
     * \@docs-private
     * @type {?}
     */
    NxInputDirective.prototype.controlType;
    /**
     * \@docs-private
     * @type {?}
     */
    NxInputDirective.prototype.autofilled;
    /**
     * \@docs-private
     * @type {?}
     */
    NxInputDirective.prototype.stateChanges;
    /**
     * \@docs-private
     * @type {?}
     */
    NxInputDirective.prototype.focused;
    /**
     * @type {?}
     * @protected
     */
    NxInputDirective.prototype._elementRef;
    /**
     * @type {?}
     * @protected
     */
    NxInputDirective.prototype._platform;
    /**
     * \@docs-private
     * @type {?}
     */
    NxInputDirective.prototype.ngControl;
    /**
     * @type {?}
     * @private
     */
    NxInputDirective.prototype._parentForm;
    /**
     * @type {?}
     * @private
     */
    NxInputDirective.prototype._parentFormGroup;
    /**
     * @type {?}
     * @private
     */
    NxInputDirective.prototype._errorStateMatcher;
    /**
     * @type {?}
     * @private
     */
    NxInputDirective.prototype._autofillMonitor;
}

/**
 * @fileoverview added by tsickle
 * Generated from: password-toggle.component.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const visibilityIcons = {
    show: 'password-show-o',
    hide: 'password-hide-o'
};
class NxPasswordToggleComponent {
    /**
     * @param {?} _changeDetectorRef
     */
    constructor(_changeDetectorRef) {
        this._changeDetectorRef = _changeDetectorRef;
        /**
         * \@docs-private
         */
        this._currentIcon = visibilityIcons['show'];
        /**
         * \@docs-private
         */
        this._pressed = false;
        this._ariaLabel = 'Show password';
    }
    /**
     * Sets the aria-label needed for accessibility.
     * Notice that this `aria-label` should describe the initial action according to the status of the visibility.
     * E.g if you have an `input[type=password]` at the beginning then the
     * password will be hidden and the correct aria-label would be 'Show password.'
     * @param {?} value
     * @return {?}
     */
    set ariaLabel(value) {
        if (value !== this._ariaLabel) {
            this._ariaLabel = value;
            this._changeDetectorRef.markForCheck();
        }
    }
    /**
     * @return {?}
     */
    get ariaLabel() {
        return this._ariaLabel;
    }
    /**
     * @return {?}
     */
    ngAfterViewInit() {
        if (!this.control) {
            console.warn('You need to pass an input as a control to the password toggle.');
        }
        else {
            // show the right icon according to the initial type of the input
            this._currentIcon = this.control.type === 'password' ? visibilityIcons['show'] : visibilityIcons['hide'];
        }
    }
    /**
     * Toggles the type of the input.
     * @return {?}
     */
    toggleInputType() {
        if (this.control) {
            this.control.type = this.control.type === 'password' ? 'text' : 'password';
            this._pressed = !this._pressed;
            this.toggleIcon();
            this._changeDetectorRef.markForCheck();
        }
    }
    /**
     * \@docs-private
     * @return {?}
     */
    toggleIcon() {
        this._currentIcon = this._currentIcon === visibilityIcons['show'] ? visibilityIcons['hide'] : visibilityIcons['show'];
    }
    /**
     * \@docs-private
     * @param {?} $event
     * @return {?}
     */
    _onKeydown($event) {
        if ($event && ($event.keyCode === ENTER || $event.keyCode === SPACE)) {
            this.toggleInputType();
        }
    }
    /**
     * \@docs-private
     * @return {?}
     */
    get tabindex() {
        if (this.control) {
            return this.control.disabled ? -1 : 0;
        }
        return null;
    }
}
NxPasswordToggleComponent.decorators = [
    { type: Component, args: [{
                selector: 'nx-password-toggle',
                template: `<nx-icon
      aria-hidden="true"
      [name]="_currentIcon">
    </nx-icon>`,
                host: {
                    '[attr.aria-label]': 'ariaLabel',
                    '[attr.tabindex]': 'tabindex',
                    '[attr.aria-pressed]': '_pressed',
                    'role': 'button',
                    '(click)': 'toggleInputType()',
                    '(keydown)': '_onKeydown($event)'
                },
                changeDetection: ChangeDetectionStrategy.OnPush,
                styles: [":host{position:relative;display:inline-block;height:24px;width:24px;cursor:pointer}:host:focus{outline:0}:host:hover{color:#006192;color:var(--hover-primary,#006192)}:host-context([data-whatinput=keyboard]):focus ::ng-deep nx-icon{box-shadow:0 0 0 2px #fff,0 0 0 6px #009de6;box-shadow:var(--focus-box-shadow,0 0 0 2px #fff,0 0 0 6px #009de6);border-radius:4px}@media screen and (-ms-high-contrast:active){:host{color:buttonText}:host-context([data-whatinput=keyboard]):focus ::ng-deep nx-icon{box-shadow:0 0 0 2px background,0 0 0 6px windowText}}:host-context(.is-disabled){pointer-events:none}"]
            }] }
];
/** @nocollapse */
NxPasswordToggleComponent.ctorParameters = () => [
    { type: ChangeDetectorRef }
];
NxPasswordToggleComponent.propDecorators = {
    control: [{ type: Input }],
    ariaLabel: [{ type: Input }]
};
if (false) {
    /**
     * Input element using the toggle functionality.
     * @type {?}
     */
    NxPasswordToggleComponent.prototype.control;
    /**
     * \@docs-private
     * @type {?}
     */
    NxPasswordToggleComponent.prototype._currentIcon;
    /**
     * \@docs-private
     * @type {?}
     */
    NxPasswordToggleComponent.prototype._pressed;
    /**
     * @type {?}
     * @private
     */
    NxPasswordToggleComponent.prototype._ariaLabel;
    /**
     * @type {?}
     * @private
     */
    NxPasswordToggleComponent.prototype._changeDetectorRef;
}

/**
 * @fileoverview added by tsickle
 * Generated from: input.module.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class NxInputModule {
}
NxInputModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    CommonModule,
                    NxFormfieldModule,
                    NxIconModule
                ],
                declarations: [
                    NxInputDirective,
                    NxPasswordToggleComponent
                ],
                exports: [
                    NxFormfieldModule,
                    NxInputDirective,
                    NxPasswordToggleComponent
                ]
            },] }
];

/**
 * @fileoverview added by tsickle
 * Generated from: public-api.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * Generated from: allianz-ngx-ndbx-input.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

export { NX_INPUT_VALUE_ACCESSOR, NxInputDirective, NxInputModule, NxPasswordToggleComponent };
//# sourceMappingURL=allianz-ngx-ndbx-input.js.map
