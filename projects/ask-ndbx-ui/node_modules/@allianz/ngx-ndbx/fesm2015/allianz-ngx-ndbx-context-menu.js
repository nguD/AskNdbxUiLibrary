import { OverlayConfig, Overlay, OverlayModule } from '@angular/cdk/overlay';
import { DOCUMENT, CommonModule } from '@angular/common';
import { Directive, TemplateRef, ComponentFactoryResolver, ApplicationRef, Injector, ViewContainerRef, Inject, EventEmitter, Component, ChangeDetectionStrategy, NgZone, ViewChild, ContentChild, Output, ElementRef, ChangeDetectorRef, Optional, Input, Self, NgModule } from '@angular/core';
import { TemplatePortal, DomPortalOutlet } from '@angular/cdk/portal';
import { Subject, Subscription, merge, fromEvent, of, asapScheduler } from 'rxjs';
import { FocusKeyManager } from '@angular/cdk/a11y';
import { END, hasModifierKey, HOME, RIGHT_ARROW, LEFT_ARROW, ESCAPE } from '@angular/cdk/keycodes';
import { startWith, switchMap, take, filter, takeUntil, map, delay } from 'rxjs/operators';
import { trigger, state, style, transition, group, query, animate } from '@angular/animations';
import { coerceBooleanProperty } from '@angular/cdk/coercion';
import { Directionality } from '@angular/cdk/bidi';
import { normalizePassiveListenerOptions } from '@angular/cdk/platform';
import { NxIconModule } from '@allianz/ngx-ndbx/icon';

/**
 * @fileoverview added by tsickle
 * Generated from: context-menu-content.directive.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Context menu content that will be rendered lazily once the menu is opened.
 */
class NxContextMenuContentDirective {
    /**
     * @param {?} _template
     * @param {?} _componentFactoryResolver
     * @param {?} _appRef
     * @param {?} _injector
     * @param {?} _viewContainerRef
     * @param {?} _document
     */
    constructor(_template, _componentFactoryResolver, _appRef, _injector, _viewContainerRef, _document) {
        this._template = _template;
        this._componentFactoryResolver = _componentFactoryResolver;
        this._appRef = _appRef;
        this._injector = _injector;
        this._viewContainerRef = _viewContainerRef;
        this._document = _document;
        /**
         * Emits when the menu content has been attached.
         */
        this._attached = new Subject();
    }
    /**
     * Attaches the content with a particular context.
     * \@docs-private
     * @param {?=} context
     * @return {?}
     */
    attach(context = {}) {
        if (!this._portal) {
            this._portal = new TemplatePortal(this._template, this._viewContainerRef);
        }
        this.detach();
        if (!this._outlet) {
            this._outlet = new DomPortalOutlet(this._document.createElement('div'), this._componentFactoryResolver, this._appRef, this._injector);
        }
        /** @type {?} */
        const element = this._template.elementRef.nativeElement;
        // Because we support opening the same menu from different triggers (which in turn have their
        // own `OverlayRef` panel), we have to re-insert the host element every time, otherwise we
        // risk it staying attached to a pane that's no longer in the DOM.
        if (element.parentNode) {
            element.parentNode.insertBefore(this._outlet.outletElement, element);
        }
        this._portal.attach(this._outlet, context);
        this._attached.next();
    }
    /**
     * Detaches the content.
     * \@docs-private
     * @return {?}
     */
    detach() {
        if (this._portal.isAttached) {
            this._portal.detach();
        }
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        if (this._outlet) {
            this._outlet.dispose();
        }
    }
}
NxContextMenuContentDirective.decorators = [
    { type: Directive, args: [{
                selector: 'ng-template[nxContextMenuContent]'
            },] }
];
/** @nocollapse */
NxContextMenuContentDirective.ctorParameters = () => [
    { type: TemplateRef },
    { type: ComponentFactoryResolver },
    { type: ApplicationRef },
    { type: Injector },
    { type: ViewContainerRef },
    { type: undefined, decorators: [{ type: Inject, args: [DOCUMENT,] }] }
];
if (false) {
    /**
     * @type {?}
     * @private
     */
    NxContextMenuContentDirective.prototype._portal;
    /**
     * @type {?}
     * @private
     */
    NxContextMenuContentDirective.prototype._outlet;
    /**
     * Emits when the menu content has been attached.
     * @type {?}
     */
    NxContextMenuContentDirective.prototype._attached;
    /**
     * @type {?}
     * @private
     */
    NxContextMenuContentDirective.prototype._template;
    /**
     * @type {?}
     * @private
     */
    NxContextMenuContentDirective.prototype._componentFactoryResolver;
    /**
     * @type {?}
     * @private
     */
    NxContextMenuContentDirective.prototype._appRef;
    /**
     * @type {?}
     * @private
     */
    NxContextMenuContentDirective.prototype._injector;
    /**
     * @type {?}
     * @private
     */
    NxContextMenuContentDirective.prototype._viewContainerRef;
    /**
     * @type {?}
     * @private
     */
    NxContextMenuContentDirective.prototype._document;
}

/**
 * @fileoverview added by tsickle
 * Generated from: context-menu-animations.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Animations used by the NxContextMenuComponent.
 * \@docs-private
 * @type {?}
 */
const nxContextMenuAnimations = {
    /**
     * This animation controls the context menu panel's entry and exit from the page.
     * When the context menu panel is added to the DOM, it scales in and fades in its border.
     * When the context menu panel is removed from the DOM, it simply fades out.
     */
    transformContextMenu: trigger('transformContextMenu', [
        state('void', style({
            opacity: 0,
            transform: 'scale(0.8)'
        })),
        transition('void => enter', group([
            query('.nx-context-menu__content', animate('100ms linear', style({
                opacity: 1
            }))),
            animate('120ms cubic-bezier(0, 0, 0.2, 1)', style({ transform: 'scale(1)' })),
        ])),
        transition('* => void', animate('100ms linear', style({ opacity: 0 })))
    ])
};

/**
 * @fileoverview added by tsickle
 * Generated from: context-menu.component.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class NxContextMenuComponent {
    /**
     * @param {?} _ngZone
     */
    constructor(_ngZone) {
        this._ngZone = _ngZone;
        /**
         * Menu items inside the current menu.
         */
        this._items = [];
        /**
         * Emits whenever the amount of menu items changes.
         */
        this._itemChanges = new Subject();
        /**
         * Subscription to tab events on the menu panel
         */
        this._tabSubscription = Subscription.EMPTY;
        /**
         * Config object to be passed into the menu's ngClass
         */
        this._classList = {};
        /**
         * Current state of the panel animation.
         */
        this._panelAnimationState = 'void';
        /**
         * Emits whenever an animation on the menu completes.
         */
        this._animationDone = new Subject();
        /**
         * Event emitted when the menu is closed.
         */
        this.closed = new EventEmitter();
    }
    /**
     * @return {?}
     */
    ngAfterContentInit() {
        this._keyManager = new FocusKeyManager(this._items)
            .withWrap()
            .withTypeAhead();
        this._tabSubscription = this._keyManager.tabOut.subscribe((/**
         * @return {?}
         */
        () => this.closed.emit('tab')));
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this._tabSubscription.unsubscribe();
        this.closed.complete();
    }
    /**
     * Stream that emits whenever the hovered menu item changes.
     * @return {?}
     */
    _hovered() {
        return this._itemChanges.pipe(startWith(this._items), switchMap((/**
         * @param {?} items
         * @return {?}
         */
        items => merge(...items.map((/**
         * @param {?} item
         * @return {?}
         */
        item => item._hovered))))));
    }
    /**
     * Handle a keyboard event from the menu, delegating to the appropriate action.
     * @param {?} event
     * @return {?}
     */
    _handleKeydown(event) {
        /** @type {?} */
        const keyCode = event.keyCode;
        /** @type {?} */
        const manager = this._keyManager;
        switch (keyCode) {
            case ESCAPE:
                if (!hasModifierKey(event)) {
                    event.preventDefault();
                    this.closed.emit('keydown');
                }
                break;
            case LEFT_ARROW:
                if (this.parentMenu && this.direction === 'ltr') {
                    this.closed.emit('keydown');
                }
                break;
            case RIGHT_ARROW:
                if (this.parentMenu && this.direction === 'rtl') {
                    this.closed.emit('keydown');
                }
                break;
            case HOME:
            case END:
                if (!hasModifierKey(event)) {
                    keyCode === HOME
                        ? manager.setFirstItemActive()
                        : manager.setLastItemActive();
                    event.preventDefault();
                }
                break;
            default:
                manager.onKeydown(event);
        }
    }
    /**
     * Focus the first item in the menu.
     * @return {?}
     */
    focusFirstItem() {
        // When the content is rendered lazily, it takes a bit before the items are inside the DOM.
        if (this.lazyContent) {
            this._ngZone.onStable
                .asObservable()
                .pipe(take(1))
                .subscribe((/**
             * @return {?}
             */
            () => this._keyManager.setFirstItemActive()));
        }
        else {
            this._keyManager.setFirstItemActive();
        }
    }
    /**
     * Resets the active item in the menu. This is used when the menu is opened, allowing
     * the user to start from the first option when pressing the down arrow.
     * @return {?}
     */
    resetActiveItem() {
        this._keyManager.setActiveItem(-1);
    }
    /**
     * Registers a menu item with the context menu.
     * \@docs-private
     * @param {?} item
     * @return {?}
     */
    addItem(item) {
        // We register the items through this method, rather than picking them up through
        // `ContentChildren`, because we need the items to be picked up by their closest
        // `nx-context-menu` ancestor. If we used `@ContentChildren(NxContextMenuItem, {descendants: true})`,
        // all descendant items will bleed into the top-level menu in the case where the consumer
        // has `nx-context-menu` instances nested inside each other.
        if (this._items.indexOf(item) === -1) {
            this._items.push(item);
            this._itemChanges.next(this._items);
        }
    }
    /**
     * Removes an item from the context menu.
     * \@docs-private
     * @param {?} item
     * @return {?}
     */
    removeItem(item) {
        /** @type {?} */
        const index = this._items.indexOf(item);
        if (this._items.indexOf(item) > -1) {
            this._items.splice(index, 1);
            this._itemChanges.next(this._items);
        }
    }
    /**
     * Starts the enter animation.
     * @return {?}
     */
    _startAnimation() {
        this._panelAnimationState = 'enter';
    }
    /**
     * Resets the panel animation to its initial state.
     * @return {?}
     */
    _resetAnimation() {
        this._panelAnimationState = 'void';
    }
    /**
     * Callback that is invoked when the panel animation completes.
     * @param {?} event
     * @return {?}
     */
    _onAnimationDone(event) {
        this._animationDone.next(event);
        this._isAnimating = false;
    }
    /**
     * @param {?} event
     * @return {?}
     */
    _onAnimationStart(event) {
        this._isAnimating = true;
        // Scroll the content element to the top as soon as the animation starts. This is necessary,
        // because we move focus to the first item while it's still being animated, which can throw
        // the browser off when it determines the scroll position. Alternatively we can move focus
        // when the animation is done, however moving focus asynchronously will interrupt screen
        // readers which are in the process of reading out the menu already. We take the `element`
        // from the `event` since we can't use a `ViewChild` to access the pane.
        if (event.toState === 'enter' && this._keyManager.activeItemIndex === 0) {
            event.element.scrollTop = 0;
        }
    }
}
NxContextMenuComponent.decorators = [
    { type: Component, args: [{
                selector: 'nx-context-menu',
                template: "<ng-template>\n  <div class=\"nx-context-menu\"\n    [ngClass]=\"_classList\"\n    (keydown)=\"_handleKeydown($event)\"\n    (click)=\"closed.emit('click')\"\n    [@transformContextMenu]=\"_panelAnimationState\"\n    (@transformContextMenu.start)=\"_onAnimationStart($event)\"\n    (@transformContextMenu.done)=\"_onAnimationDone($event)\"\n    tabindex=\"-1\"\n    role=\"menu\">\n    <div class=\"nx-context-menu__content\">\n      <ng-content></ng-content>\n    </div>\n  </div>\n</ng-template>\n",
                changeDetection: ChangeDetectionStrategy.OnPush,
                exportAs: 'nxContextMenu',
                animations: [
                    nxContextMenuAnimations.transformContextMenu
                ],
                styles: [".nx-context-menu{border-radius:4px;background:#fff;background:var(--context-menu-background-color,#fff);min-height:64px;box-shadow:0 2px 4px rgba(65,65,65,.5);outline:0}.nx-context-menu.ng-animating{pointer-events:none}.nx-context-menu__content:not(:empty){padding-top:16px;padding-bottom:16px;display:flex;flex-direction:column}@media screen and (-ms-high-contrast:active){.nx-context-menu{border:1px solid windowText}.nx-context-menu__content:not(:empty){background-color:buttonFace}}"]
            }] }
];
/** @nocollapse */
NxContextMenuComponent.ctorParameters = () => [
    { type: NgZone }
];
NxContextMenuComponent.propDecorators = {
    templateRef: [{ type: ViewChild, args: [TemplateRef, { static: false },] }],
    lazyContent: [{ type: ContentChild, args: [NxContextMenuContentDirective, { static: false },] }],
    closed: [{ type: Output }]
};
if (false) {
    /**
     * @type {?}
     * @private
     */
    NxContextMenuComponent.prototype._keyManager;
    /**
     * Menu items inside the current menu.
     * @type {?}
     * @private
     */
    NxContextMenuComponent.prototype._items;
    /**
     * Emits whenever the amount of menu items changes.
     * @type {?}
     * @private
     */
    NxContextMenuComponent.prototype._itemChanges;
    /**
     * Subscription to tab events on the menu panel
     * @type {?}
     * @private
     */
    NxContextMenuComponent.prototype._tabSubscription;
    /**
     * Config object to be passed into the menu's ngClass
     * @type {?}
     */
    NxContextMenuComponent.prototype._classList;
    /**
     * Current state of the panel animation.
     * @type {?}
     */
    NxContextMenuComponent.prototype._panelAnimationState;
    /**
     * Emits whenever an animation on the menu completes.
     * @type {?}
     */
    NxContextMenuComponent.prototype._animationDone;
    /**
     * Whether the menu is animating.
     * @type {?}
     */
    NxContextMenuComponent.prototype._isAnimating;
    /**
     * Parent menu of the current menu panel.
     * @type {?}
     */
    NxContextMenuComponent.prototype.parentMenu;
    /**
     * \@docs-private
     * Layout direction of the menu.
     * @type {?}
     */
    NxContextMenuComponent.prototype.direction;
    /**
     * \@docs-private
     * @type {?}
     */
    NxContextMenuComponent.prototype.templateRef;
    /**
     * Menu content that will be rendered lazily.
     * \@docs-private
     * @type {?}
     */
    NxContextMenuComponent.prototype.lazyContent;
    /**
     * Event emitted when the menu is closed.
     * @type {?}
     */
    NxContextMenuComponent.prototype.closed;
    /**
     * @type {?}
     * @private
     */
    NxContextMenuComponent.prototype._ngZone;
}

/**
 * @fileoverview added by tsickle
 * Generated from: context-menu-item.component.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * This directive is intended to be used inside an nx-context-menu tag.
 * It exists mostly to set the role attribute, disabled state and styling.
 */
class NxContextMenuItemComponent {
    /**
     * @param {?} _elementRef
     * @param {?} document
     * @param {?} _changeDetectorRef
     * @param {?} _parentMenu
     */
    constructor(_elementRef, document, _changeDetectorRef, _parentMenu) {
        this._elementRef = _elementRef;
        this._changeDetectorRef = _changeDetectorRef;
        this._parentMenu = _parentMenu;
        /**
         * Stream that emits when the context menu item is hovered.
         */
        this._hovered = new Subject();
        this._disabled = false;
        /**
         * Whether the context menu item is highlighted.
         */
        this._highlighted = false;
        /**
         * Whether the context menu item acts as a trigger for a sub-menu.
         */
        this._triggersSubmenu = false;
        if (_parentMenu && _parentMenu.addItem) {
            _parentMenu.addItem(this);
        }
        this._document = document;
    }
    /**
     * Whether the context menu item is disabled.
     * @param {?} value
     * @return {?}
     */
    set disabled(value) {
        this._disabled = coerceBooleanProperty(value);
        this._changeDetectorRef.markForCheck();
    }
    /**
     * @return {?}
     */
    get disabled() {
        return this._disabled;
    }
    /**
     * Focuses this context menu item.
     * @return {?}
     */
    focus() {
        this._getHostElement().focus();
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        if (this._parentMenu && this._parentMenu.removeItem) {
            this._parentMenu.removeItem(this);
        }
        this._hovered.complete();
    }
    /**
     * Used to set the `tabindex`.
     * @return {?}
     */
    _getTabIndex() {
        return this.disabled ? '-1' : '0';
    }
    /**
     * Returns the host DOM element.
     * @return {?}
     */
    _getHostElement() {
        return this._elementRef.nativeElement;
    }
    /**
     * Prevents the default element actions if it is disabled.
     * @param {?} event
     * @return {?}
     */
    _checkDisabled(event) {
        if (this.disabled) {
            event.preventDefault();
            event.stopPropagation();
        }
    }
    /**
     * Emits to the hover stream.
     * @return {?}
     */
    _handleMouseEnter() {
        this._hovered.next(this);
    }
    /**
     * Gets the label to be used when determining whether the option should be focused.
     * @return {?}
     */
    getLabel() {
        /** @type {?} */
        const element = this._elementRef.nativeElement;
        /** @type {?} */
        const textNodeType = this._document ? this._document.TEXT_NODE : 3;
        /** @type {?} */
        let output = '';
        if (element.childNodes) {
            /** @type {?} */
            const length = element.childNodes.length;
            // Go through all the top-level text nodes and extract their text.
            // We skip anything that's not a text node to prevent the text from
            // being thrown off by something like an icon.
            for (let i = 0; i < length; i++) {
                if (element.childNodes[i].nodeType === textNodeType) {
                    output += element.childNodes[i].textContent;
                }
            }
        }
        return output.trim();
    }
}
NxContextMenuItemComponent.decorators = [
    { type: Component, args: [{
                // tslint:disable-next-line:component-selector
                selector: '[nxContextMenuItem]',
                exportAs: 'nxContextMenuItem',
                host: {
                    class: 'nx-context-menu-item',
                    role: 'menuitem',
                    '[class.is-highlighted]': '_highlighted',
                    '[attr.tabindex]': '_getTabIndex()',
                    '[attr.aria-disabled]': 'disabled.toString()',
                    '[attr.disabled]': 'disabled || null',
                    '(mouseenter)': '_handleMouseEnter()',
                    '(click)': '_checkDisabled($event)'
                },
                changeDetection: ChangeDetectionStrategy.OnPush,
                template: `
    <ng-content></ng-content>
    <nx-icon *ngIf="_triggersSubmenu"
      class="nx-context-menu-item__expand"
      name="chevron-right-small">
    </nx-icon>
    `,
                styles: [":host{font-size:16px;font-size:var(--context-menu-font-size,16px);line-height:24px;line-height:var(--context-menu-line-height,24px);font-weight:400;font-weight:var(--context-menu-font-weight,400);letter-spacing:0;letter-spacing:var(--context-menu-letter-spacing,0);display:flex;align-items:center;cursor:pointer;text-align:left;width:100%;-webkit-appearance:none;-moz-appearance:none;appearance:none;border:none;outline:0;background:0 0;padding:4px 48px 4px 32px;color:#414141;color:var(--context-menu-item-text-color,#414141)}:host:not(:disabled).is-highlighted,:host:not(:disabled):active,:host:not(:disabled):hover{color:#006192;color:var(--context-menu-item-active-color,#006192)}@media screen and (-ms-high-contrast:active){:host{-ms-high-contrast-adjust:none;background-color:buttonFace;color:buttonText}:host:not(:disabled).is-highlighted,:host:not(:disabled):active,:host:not(:disabled):hover{background-color:highlight;color:highlightText}}:host:disabled{cursor:not-allowed;color:#c2c2c2;color:var(--context-menu-item-disabled-color,#c2c2c2)}:host::-moz-focus-inner{border:0}:host ::ng-deep>nx-icon{margin-right:8px;font-size:20px;font-size:var(--context-menu-item-icon-size,20px)}:host .nx-context-menu-item__expand{font-size:20px;font-size:var(--context-menu-item-expand-icon-size,20px);padding-left:8px;margin-left:auto;margin-right:-16px;width:1em}:host-context([data-whatinput=keyboard]):focus{border-radius:8px;outline:0;box-shadow:inset 0 0 0 4px #009de6,inset 0 0 0 6px #fff;box-shadow:var(--focus-inset-box-shadow,inset 0 0 0 4px #009de6,inset 0 0 0 6px #fff)}@media screen and (-ms-high-contrast:active){:host:disabled{color:GrayText}:host-context([data-whatinput=keyboard]):focus{box-shadow:inset 0 0 0 4px windowText,inset 0 0 0 6px background}}"]
            }] }
];
/** @nocollapse */
NxContextMenuItemComponent.ctorParameters = () => [
    { type: ElementRef },
    { type: undefined, decorators: [{ type: Inject, args: [DOCUMENT,] }] },
    { type: ChangeDetectorRef },
    { type: NxContextMenuComponent, decorators: [{ type: Inject, args: [NxContextMenuComponent,] }, { type: Optional }] }
];
NxContextMenuItemComponent.propDecorators = {
    disabled: [{ type: Input }]
};
if (false) {
    /**
     * @type {?}
     * @private
     */
    NxContextMenuItemComponent.prototype._document;
    /**
     * Stream that emits when the context menu item is hovered.
     * @type {?}
     */
    NxContextMenuItemComponent.prototype._hovered;
    /**
     * @type {?}
     * @private
     */
    NxContextMenuItemComponent.prototype._disabled;
    /**
     * Whether the context menu item is highlighted.
     * @type {?}
     */
    NxContextMenuItemComponent.prototype._highlighted;
    /**
     * Whether the context menu item acts as a trigger for a sub-menu.
     * @type {?}
     */
    NxContextMenuItemComponent.prototype._triggersSubmenu;
    /**
     * @type {?}
     * @private
     */
    NxContextMenuItemComponent.prototype._elementRef;
    /**
     * @type {?}
     * @private
     */
    NxContextMenuItemComponent.prototype._changeDetectorRef;
    /**
     * @type {?}
     * @private
     */
    NxContextMenuItemComponent.prototype._parentMenu;
}

/**
 * @fileoverview added by tsickle
 * Generated from: context-menu-errors.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Throws an exception for the case when menu trigger doesn't have a valid nx-context-menu instance
 * \@docs-private
 * @return {?}
 */
function throwNxContextMenuMissingError() {
    throw Error(`nxContextMenuTriggerFor: must pass in an nx-context-menu instance.
    Example:
      <nx-context-menu #contextMenu="nxContextMenu"></nx-context-menu>
      <button [nxContextMenuTriggerFor]="contextMenu"></button>`);
}

/**
 * @fileoverview added by tsickle
 * Generated from: context-menu-trigger.directive.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Default top padding of the menu panel.
 * @type {?}
 */
const MENU_PANEL_TOP_PADDING = 16;
/** @type {?} */
const MENU_PANEL_OFFSET = 8;
/**
 * Options for binding a passive event listener.
 * @type {?}
 */
const passiveEventListenerOptions = normalizePassiveListenerOptions({
    passive: true
});
/**
 * This directive is intended to be used in conjunction with an nx-context-menu tag.
 * It is responsible for toggling the display of the provided context menu instance.
 */
class NxContextMenuTriggerDirective {
    /**
     * @param {?} _overlay
     * @param {?} _element
     * @param {?} _viewContainerRef
     * @param {?} _parentMenu
     * @param {?} _contextMenuItemInstance
     * @param {?} _dir
     */
    constructor(_overlay, _element, _viewContainerRef, _parentMenu, _contextMenuItemInstance, _dir) {
        this._overlay = _overlay;
        this._element = _element;
        this._viewContainerRef = _viewContainerRef;
        this._parentMenu = _parentMenu;
        this._contextMenuItemInstance = _contextMenuItemInstance;
        this._dir = _dir;
        this._overlayRef = null;
        this._contextMenuOpen = false;
        this._closingActionsSubscription = Subscription.EMPTY;
        this._hoverSubscription = Subscription.EMPTY;
        this._contextMenuCloseSubscription = Subscription.EMPTY;
        /**
         * Event emitted when the associated context menu is opened.
         */
        this.contextMenuOpened = new EventEmitter();
        /**
         * Event emitted when the associated context menu is closed.
         */
        this.contextMenuClosed = new EventEmitter();
        if (_contextMenuItemInstance) {
            _contextMenuItemInstance._triggersSubmenu = this.triggersSubmenu();
        }
        this._scrollStrategy = this._overlay.scrollStrategies.reposition;
        this._documentClickObservable = fromEvent(document, 'click');
    }
    /**
     * References the context menu instance that the trigger is associated with.
     * @return {?}
     */
    get contextMenu() {
        return this._contextMenu;
    }
    /**
     * @param {?} contextMenu
     * @return {?}
     */
    set contextMenu(contextMenu) {
        if (contextMenu === this._contextMenu) {
            return;
        }
        this._contextMenu = contextMenu;
        this._contextMenuCloseSubscription.unsubscribe();
        if (contextMenu) {
            this._contextMenuCloseSubscription = contextMenu.closed
                .asObservable()
                .subscribe((/**
             * @param {?} reason
             * @return {?}
             */
            reason => {
                this._destroyMenu();
                // If a click closed the menu, we should close the entire chain of nested menus.
                if ((reason === 'click' || reason === 'tab') && this._parentMenu) {
                    this._parentMenu.closed.emit(reason);
                }
            }));
        }
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set scrollStrategy(value) {
        if (value === 'close') {
            this._scrollStrategy = this._overlay.scrollStrategies.close;
        }
        else {
            this._scrollStrategy = this._overlay.scrollStrategies.reposition;
        }
    }
    /**
     * Whether the context menu is open.
     * @return {?}
     */
    get contextMenuOpen() {
        return this._contextMenuOpen;
    }
    /**
     * The text direction of the containing app.
     * @private
     * @return {?}
     */
    get dir() {
        return this._dir && this._dir.value === 'rtl' ? 'rtl' : 'ltr';
    }
    /**
     * @return {?}
     */
    ngAfterContentInit() {
        this._checkContextMenu();
        this._handleHover();
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        if (this._overlayRef) {
            this._overlayRef.dispose();
            this._overlayRef = null;
        }
        this._contextMenuCloseSubscription.unsubscribe();
        this._closingActionsSubscription.unsubscribe();
        this._hoverSubscription.unsubscribe();
    }
    /**
     * Whether the context menu triggers a sub-menu or a top-level one.
     * @return {?}
     */
    triggersSubmenu() {
        return !!(this._contextMenuItemInstance && this._parentMenu);
    }
    /**
     * Toggles the context menu between the open and closed states.
     * @return {?}
     */
    toggleContextMenu() {
        return this.contextMenuOpen
            ? this.closeContextMenu()
            : this.openContextMenu();
    }
    /**
     * Opens the context menu.
     * @return {?}
     */
    openContextMenu() {
        if (this.contextMenuOpen) {
            return;
        }
        this._checkContextMenu();
        /** @type {?} */
        const overlayRef = this._createOverlay();
        /** @type {?} */
        const overlayConfig = overlayRef.getConfig();
        this._setPosition((/** @type {?} */ (overlayConfig.positionStrategy)));
        overlayRef.attach(this._getPortal());
        if (this.contextMenu.lazyContent) {
            this.contextMenu.lazyContent.attach(this.contextMenuData);
        }
        this._closingActionsSubscription = this._contextMenuClosingActions().subscribe((/**
         * @return {?}
         */
        () => this.closeContextMenu()));
        this._initContextMenu();
        if (this.contextMenu instanceof NxContextMenuComponent) {
            this.contextMenu._startAnimation();
        }
        this._waitForClose();
    }
    /**
     * Closes the context menu.
     * @return {?}
     */
    closeContextMenu() {
        this.contextMenu.closed.emit();
    }
    /**
     * Closes the context menu and does the necessary cleanup.
     * @private
     * @return {?}
     */
    _destroyMenu() {
        if (!this._overlayRef || !this.contextMenuOpen) {
            return;
        }
        /** @type {?} */
        const contextMenu = this.contextMenu;
        this._closingActionsSubscription.unsubscribe();
        this._overlayRef.detach();
        contextMenu._resetAnimation();
        if (contextMenu.lazyContent) {
            // Wait for the exit animation to finish before detaching the content.
            contextMenu._animationDone
                .pipe(filter((/**
             * @param {?} event
             * @return {?}
             */
            event => event.toState === 'void')), take(1), 
            // Interrupt if the content got re-attached.
            takeUntil(contextMenu.lazyContent._attached))
                .subscribe({
                next: (/**
                 * @return {?}
                 */
                () => contextMenu.lazyContent && contextMenu.lazyContent.detach()),
                // No matter whether the content got re-attached, reset the menu.
                complete: (/**
                 * @return {?}
                 */
                () => this._resetContextMenu())
            });
        }
        else {
            this._resetContextMenu();
        }
    }
    /**
     * This method sets the context menu state to open and focuses the first item if
     * the context menu was opened via the keyboard.
     * @private
     * @return {?}
     */
    _initContextMenu() {
        this.contextMenu.parentMenu = this.triggersSubmenu()
            ? this._parentMenu
            : undefined;
        this.contextMenu.direction = this.dir;
        this._setIsContextMenuOpen(true);
        this.contextMenu.focusFirstItem();
    }
    /**
     * Focuses the context menu trigger.
     * @return {?}
     */
    focus() {
        this._element.nativeElement.focus();
    }
    /**
     * This method resets the context menu when it's closed, most importantly restoring
     * focus to the context menu trigger if the context menu was opened via the keyboard.
     * @private
     * @return {?}
     */
    _resetContextMenu() {
        this._setIsContextMenuOpen(false);
        this.focus();
    }
    /**
     * Set state rather than toggle to support triggers sharing a menu.
     * @private
     * @param {?} isOpen
     * @return {?}
     */
    _setIsContextMenuOpen(isOpen) {
        this._contextMenuOpen = isOpen;
        this._contextMenuOpen
            ? this.contextMenuOpened.emit()
            : this.contextMenuClosed.emit();
        if (this.triggersSubmenu()) {
            this._contextMenuItemInstance._highlighted = isOpen;
        }
    }
    /**
     * This method checks that a valid instance of NxContextMenuComponent has been passed into
     * nxContextMenuTriggerFor. If not, an exception is thrown.
     * @private
     * @return {?}
     */
    _checkContextMenu() {
        if (!this.contextMenu) {
            throwNxContextMenuMissingError();
        }
    }
    /**
     * This method creates the overlay from the provided menu's template and saves its
     * OverlayRef so that it can be attached to the DOM when openContextMenu is called.
     * @private
     * @return {?}
     */
    _createOverlay() {
        if (!this._overlayRef) {
            /** @type {?} */
            const config = this._getOverlayConfig();
            this._overlayRef = this._overlay.create(config);
            // Consume the `keydownEvents` in order to prevent them from going to another overlay.
            this._overlayRef.keydownEvents().subscribe();
        }
        return this._overlayRef;
    }
    /**
     * This method builds the configuration object needed to create the overlay, the OverlayState.
     * @private
     * @return {?} OverlayConfig
     */
    _getOverlayConfig() {
        return new OverlayConfig({
            positionStrategy: this._overlay
                .position()
                .flexibleConnectedTo(this._element)
                .withLockedPosition()
                .withFlexibleDimensions(false)
                .withTransformOriginOn('.nx-context-menu'),
            scrollStrategy: this._scrollStrategy(),
            direction: this._dir
        });
    }
    /**
     * Sets the appropriate positions on a position strategy
     * so the overlay connects with the trigger correctly.
     * @private
     * @param {?} positionStrategy Strategy whose position to update.
     * @return {?}
     */
    _setPosition(positionStrategy) {
        /** @type {?} */
        let originX = 'start';
        /** @type {?} */
        let originFallbackX = 'end';
        /** @type {?} */
        const overlayY = 'top';
        /** @type {?} */
        const overlayFallbackY = 'bottom';
        /** @type {?} */
        let originY = overlayY;
        /** @type {?} */
        let originFallbackY = overlayFallbackY;
        /** @type {?} */
        let overlayX = originX;
        /** @type {?} */
        let overlayFallbackX = originFallbackX;
        /** @type {?} */
        let offsetY = 0;
        if (this.triggersSubmenu()) {
            // When the menu is a sub-menu, it should always align itself
            // to the edges of the trigger, instead of overlapping it.
            overlayFallbackX = originX = 'end';
            originFallbackX = overlayX = 'start';
            offsetY = -MENU_PANEL_TOP_PADDING;
        }
        else {
            offsetY = MENU_PANEL_OFFSET;
            originY = 'bottom';
            originFallbackY = 'top';
        }
        positionStrategy.withPositions((/** @type {?} */ ([
            { originX, originY, overlayX, overlayY, offsetY },
            {
                originX: originFallbackX,
                originY,
                overlayX: overlayFallbackX,
                overlayY,
                offsetY
            },
            {
                originX,
                originY: originFallbackY,
                overlayX,
                overlayY: overlayFallbackY,
                offsetY: -offsetY
            },
            {
                originX: originFallbackX,
                originY: originFallbackY,
                overlayX: overlayFallbackX,
                overlayY: overlayFallbackY,
                offsetY: -offsetY
            }
        ])));
    }
    /**
     * Returns a stream that emits whenever an action that should close the context menu occurs.
     * @private
     * @return {?}
     */
    _contextMenuClosingActions() {
        /** @type {?} */
        let backdrop;
        /** @type {?} */
        let detachments;
        if (this._overlayRef) {
            backdrop = this._overlayRef.backdropClick();
            detachments = this._overlayRef.detachments();
        }
        /** @type {?} */
        const parentClose = this._parentMenu
            ? this._parentMenu.closed
            : of();
        /** @type {?} */
        const hover = this._parentMenu
            ? this._parentMenu._hovered().pipe(filter((/**
             * @param {?} active
             * @return {?}
             */
            active => active !== this._contextMenuItemInstance)), filter((/**
             * @return {?}
             */
            () => this._contextMenuOpen)))
            : of();
        return merge(backdrop, parentClose, hover, detachments);
    }
    /**
     * Handles mouse presses on the trigger.
     * @param {?} event
     * @return {?}
     */
    _handleMousedown(event) {
        // Since right or middle button clicks won't trigger the `click` event,
        // we shouldn't consider the menu as opened by mouse in those cases.
        // this._openedBy = event.button === 0 ? 'mouse' : null;
        // Since clicking on the trigger won't close the menu if it opens a sub-menu,
        // we should prevent focus from moving onto it via click to avoid the
        // highlight from lingering on the menu item.
        if (this.triggersSubmenu()) {
            event.preventDefault();
        }
    }
    /**
     * Handles key presses on the trigger.
     * @param {?} event
     * @return {?}
     */
    _handleKeydown(event) {
        /** @type {?} */
        const keyCode = event.keyCode;
        if (this.triggersSubmenu() &&
            ((keyCode === RIGHT_ARROW && this.dir === 'ltr') ||
                (keyCode === LEFT_ARROW && this.dir === 'rtl'))) {
            this.openContextMenu();
        }
    }
    /**
     * Handles click events on the trigger.
     * @param {?} event
     * @return {?}
     */
    _handleClick(event) {
        if (this.triggersSubmenu()) {
            // Stop event propagation to avoid closing the parent menu.
            event.stopPropagation();
            this.openContextMenu();
        }
        else {
            this.toggleContextMenu();
        }
    }
    /* Subscribes to document clicks to close the context menu on clicks on the background. */
    /**
     * @private
     * @return {?}
     */
    _waitForClose() {
        return this._documentClickObservable
            .pipe(map((/**
         * @param {?} event
         * @return {?}
         */
        event => event.target)), filter((/**
         * @param {?} target
         * @return {?}
         */
        (target) => !this._element.nativeElement.contains(target))), takeUntil(this.contextMenu.closed))
            .subscribe((/**
         * @return {?}
         */
        () => {
            this.closeContextMenu();
        }));
    }
    /**
     * Handles the cases where the user hovers over the trigger.
     * @private
     * @return {?}
     */
    _handleHover() {
        // Subscribe to changes in the hovered item in order to toggle the panel.
        if (!this.triggersSubmenu()) {
            return;
        }
        this._hoverSubscription = this._parentMenu
            ._hovered()
            // Since we might have multiple competing triggers for the same menu (e.g. a sub-menu
            // with different data and triggers), we have to delay it by a tick to ensure that
            // it won't be closed immediately after it is opened.
            .pipe(filter((/**
         * @param {?} active
         * @return {?}
         */
        active => active === this._contextMenuItemInstance && !active.disabled)), delay(0, asapScheduler))
            .subscribe((/**
         * @return {?}
         */
        () => {
            // If the same menu is used between multiple triggers, it might still be animating
            // while the new trigger tries to re-open it. Wait for the animation to finish
            // before doing so. Also interrupt if the user moves to another item.
            if (this.contextMenu._isAnimating) {
                // We need the `delay(0)` here in order to avoid
                // 'changed after checked' errors in some cases.
                this.contextMenu._animationDone
                    .pipe(take(1), delay(0, asapScheduler), takeUntil(this._parentMenu._hovered()))
                    .subscribe((/**
                 * @return {?}
                 */
                () => this.openContextMenu()));
            }
            else {
                this.openContextMenu();
            }
        }));
    }
    /**
     * Gets the portal that should be attached to the overlay.
     * @private
     * @return {?}
     */
    _getPortal() {
        // Note that we can avoid this check by keeping the portal on the context menu panel.
        // While it would be cleaner, we'd have to introduce another required method on
        // `NxContextMenuPanelComponent`, making it harder to consume.
        if (!this._portal ||
            this._portal.templateRef !== this.contextMenu.templateRef) {
            this._portal = new TemplatePortal(this.contextMenu.templateRef, this._viewContainerRef);
        }
        return this._portal;
    }
}
NxContextMenuTriggerDirective.decorators = [
    { type: Directive, args: [{
                selector: `[nxContextMenuTriggerFor]`,
                host: {
                    'aria-haspopup': 'true',
                    '[attr.aria-expanded]': 'contextMenuOpen || null',
                    '(mousedown)': '_handleMousedown($event)',
                    '(keydown)': '_handleKeydown($event)',
                    '(click)': '_handleClick($event)'
                },
                exportAs: 'nxContextMenuTrigger'
            },] }
];
/** @nocollapse */
NxContextMenuTriggerDirective.ctorParameters = () => [
    { type: Overlay },
    { type: ElementRef },
    { type: ViewContainerRef },
    { type: NxContextMenuComponent, decorators: [{ type: Optional }] },
    { type: NxContextMenuItemComponent, decorators: [{ type: Optional }, { type: Self }] },
    { type: Directionality, decorators: [{ type: Optional }] }
];
NxContextMenuTriggerDirective.propDecorators = {
    contextMenu: [{ type: Input, args: ['nxContextMenuTriggerFor',] }],
    scrollStrategy: [{ type: Input }],
    contextMenuData: [{ type: Input, args: ['nxContextMenuTriggerData',] }],
    contextMenuOpened: [{ type: Output }],
    contextMenuClosed: [{ type: Output }]
};
if (false) {
    /**
     * @type {?}
     * @private
     */
    NxContextMenuTriggerDirective.prototype._portal;
    /**
     * @type {?}
     * @private
     */
    NxContextMenuTriggerDirective.prototype._overlayRef;
    /**
     * @type {?}
     * @private
     */
    NxContextMenuTriggerDirective.prototype._contextMenuOpen;
    /**
     * @type {?}
     * @private
     */
    NxContextMenuTriggerDirective.prototype._closingActionsSubscription;
    /**
     * @type {?}
     * @private
     */
    NxContextMenuTriggerDirective.prototype._hoverSubscription;
    /**
     * @type {?}
     * @private
     */
    NxContextMenuTriggerDirective.prototype._contextMenuCloseSubscription;
    /**
     * @type {?}
     * @private
     */
    NxContextMenuTriggerDirective.prototype._documentClickObservable;
    /**
     * @type {?}
     * @private
     */
    NxContextMenuTriggerDirective.prototype._scrollStrategy;
    /**
     * @type {?}
     * @private
     */
    NxContextMenuTriggerDirective.prototype._contextMenu;
    /**
     * Data to be passed along to any lazily-rendered content.
     * @type {?}
     */
    NxContextMenuTriggerDirective.prototype.contextMenuData;
    /**
     * Event emitted when the associated context menu is opened.
     * @type {?}
     */
    NxContextMenuTriggerDirective.prototype.contextMenuOpened;
    /**
     * Event emitted when the associated context menu is closed.
     * @type {?}
     */
    NxContextMenuTriggerDirective.prototype.contextMenuClosed;
    /**
     * @type {?}
     * @private
     */
    NxContextMenuTriggerDirective.prototype._overlay;
    /**
     * @type {?}
     * @private
     */
    NxContextMenuTriggerDirective.prototype._element;
    /**
     * @type {?}
     * @private
     */
    NxContextMenuTriggerDirective.prototype._viewContainerRef;
    /**
     * @type {?}
     * @private
     */
    NxContextMenuTriggerDirective.prototype._parentMenu;
    /**
     * @type {?}
     * @private
     */
    NxContextMenuTriggerDirective.prototype._contextMenuItemInstance;
    /**
     * @type {?}
     * @private
     */
    NxContextMenuTriggerDirective.prototype._dir;
}

/**
 * @fileoverview added by tsickle
 * Generated from: context-menu.module.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const EXPORTED_MODULES = [
    NxContextMenuComponent,
    NxContextMenuContentDirective,
    NxContextMenuItemComponent,
    NxContextMenuTriggerDirective
];
class NxContextMenuModule {
}
NxContextMenuModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    CommonModule,
                    OverlayModule,
                    NxIconModule
                ],
                exports: EXPORTED_MODULES,
                declarations: EXPORTED_MODULES
            },] }
];

/**
 * @fileoverview added by tsickle
 * Generated from: public-api.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * Generated from: allianz-ngx-ndbx-context-menu.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

export { MENU_PANEL_OFFSET, MENU_PANEL_TOP_PADDING, NxContextMenuComponent, NxContextMenuItemComponent, NxContextMenuModule, NxContextMenuTriggerDirective, nxContextMenuAnimations as ɵa, NxContextMenuContentDirective as ɵb };
//# sourceMappingURL=allianz-ngx-ndbx-context-menu.js.map
