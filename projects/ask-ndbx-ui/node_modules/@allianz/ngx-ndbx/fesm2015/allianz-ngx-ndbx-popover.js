import { Directive, TemplateRef, EventEmitter, Component, ChangeDetectionStrategy, ViewChild, ContentChild, Output, ElementRef, ViewContainerRef, NgZone, Optional, Inject, Input, NgModule } from '@angular/core';
import { coerceBooleanProperty } from '@angular/cdk/coercion';
import { OverlayConfig, Overlay, OverlayModule } from '@angular/cdk/overlay';
import { TemplatePortal } from '@angular/cdk/portal';
import { EventManager } from '@angular/platform-browser';
import { Subject, fromEvent } from 'rxjs';
import { takeUntil, map, filter } from 'rxjs/operators';
import { FocusTrapFactory, FocusMonitor } from '@angular/cdk/a11y';
import { ENTER, SPACE } from '@angular/cdk/keycodes';
import { DOCUMENT, CommonModule } from '@angular/common';
import { Platform } from '@angular/cdk/platform';
import { NxIconModule } from '@allianz/ngx-ndbx/icon';

/**
 * @fileoverview added by tsickle
 * Generated from: popover-content.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Popover content that will be rendered lazily
 * after the popover is opened for the first time.
 */
class NxPopoverContentDirective {
    /**
     * @param {?} _template
     */
    constructor(_template) {
        this._template = _template;
    }
}
NxPopoverContentDirective.decorators = [
    { type: Directive, args: [{
                selector: 'ng-template[nxPopoverContent]'
            },] }
];
/** @nocollapse */
NxPopoverContentDirective.ctorParameters = () => [
    { type: TemplateRef }
];
if (false) {
    /** @type {?} */
    NxPopoverContentDirective.prototype._template;
}

/**
 * @fileoverview added by tsickle
 * Generated from: popover.component.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class NxPopoverComponent {
    constructor() {
        /**
         * Event emitted when the popover is closed.
         */
        this.closed = new EventEmitter();
        /**
         * \@docs-private
         */
        this.closeButtonClick = new Subject();
        /**
         * \@docs-private
         */
        this.showCloseButton = false;
        /**
         * \@docs-private
         */
        this.arrowStyle = {};
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this.closed.complete();
    }
    // emit to notify the popover trigger directive that the close button was clicked
    /**
     * \@docs-private
     * @return {?}
     */
    emitCloseButtonClick() {
        this.closeButtonClick.next();
    }
    /**
     * \@docs-private
     * @param {?} $event
     * @return {?}
     */
    _onCloseKeyup($event) {
        if ($event && ($event.keyCode === ENTER || $event.keyCode === SPACE)) {
            this.emitCloseButtonClick();
        }
        $event.preventDefault();
    }
    /**
     * \@docs-private
     * @return {?}
     */
    emitClosedEvent() {
        this.closed.emit();
    }
    /**
     * \@docs-private
     * @return {?}
     */
    get classList() {
        if (this.direction) {
            return [`nx-popover--${this.direction}`];
        }
    }
    /**
     * Prevent the popover from closing when the user clicks on the popover content.
     * @param {?} event
     * @return {?}
     */
    _onClick(event) {
        event.stopPropagation();
    }
}
NxPopoverComponent.decorators = [
    { type: Component, args: [{
                selector: 'nx-popover',
                template: "<ng-template>\n  <div [ngClass]=\"classList\" role=\"tooltip\" aria-hidden=\"false\" (click)=\"_onClick($event)\">\n    <div class=\"nx-popover__content\" tabindex=\"0\">\n        <div class=\"nx-popover__arrow\" [ngStyle]=\"arrowStyle\">\n          </div>\n      <span\n          aria-label=\"close\"\n          tabindex=\"0\"\n          role=\"button\"\n          class=\"nx-popover__close-icon\"\n          (click)=\"emitCloseButtonClick()\"\n          (keyup)=\"_onCloseKeyup($event)\"\n          *ngIf=\"showCloseButton\">\n        <nx-icon aria-hidden=\"true\" name=\"close\"></nx-icon>\n        </span>\n\n      <span [id]=\"id\">\n        <ng-content></ng-content>\n        <ng-container [ngTemplateOutlet]=\"_lazyContent?._template\"></ng-container>\n      </span>\n    </div>\n  </div>\n</ng-template>\n",
                changeDetection: ChangeDetectionStrategy.OnPush,
                exportAs: 'nxPopover',
                styles: [".nx-popover__content{font-size:16px;font-size:var(--popover-content-font-size,16px);line-height:24px;line-height:var(--popover-content-line-height,24px);font-weight:400;font-weight:var(--popover-content-font-weight,400);letter-spacing:0;letter-spacing:var(--popover-content-letter-spacing,0);background-color:#fff;background-color:var(--popover-background-color,#fff);color:#414141;color:var(--popover-text-color,#414141);border:1px solid #d9d9d9;border:1px solid var(--popover-border-color,#d9d9d9);border-radius:4px;box-shadow:0 2px 4px rgba(65,65,65,.5);padding:23px;display:inline-block}.nx-popover__content:focus{outline:0}.nx-popover__content::-moz-focus-inner{border:0}.nx-popover__close-icon{display:flex;position:absolute;top:4px;right:4px;cursor:pointer;font-size:16px;font-size:var(--popover-close-icon-size,16px);color:#d9d9d9;color:var(--popover-close-icon-color,#d9d9d9);border-radius:2px}.nx-popover__close-icon:focus{outline:0}.nx-popover__close-icon::-moz-focus-inner{border:0}::ng-deep [data-whatinput=keyboard] .nx-popover__close-icon:focus,::ng-deep [data-whatinput=keyboard] .nx-popover__content:focus{box-shadow:0 0 0 2px #fff,0 0 0 6px #009de6;box-shadow:var(--focus-box-shadow,0 0 0 2px #fff,0 0 0 6px #009de6)}@media screen and (-ms-high-contrast:active){::ng-deep [data-whatinput=keyboard] .nx-popover__close-icon:focus,::ng-deep [data-whatinput=keyboard] .nx-popover__content:focus{box-shadow:0 0 0 2px background,0 0 0 6px windowText}}.nx-popover__arrow{width:12px;height:12px;background-color:inherit;position:absolute;transform:translate(-50%,0);border-top:1px solid #d9d9d9;border-top:1px solid var(--popover-border-color,#d9d9d9);border-left:1px solid #d9d9d9;border-left:1px solid var(--popover-border-color,#d9d9d9)}.nx-popover--top .nx-popover__arrow{transform:translate(-50%,0) rotate(225deg);bottom:-5px;box-shadow:2px 2px 1px 1px #fff,-2px -2px 4px rgba(65,65,65,.5);box-shadow:2px 2px 1px 1px var(--popover-background-color,#fff),-2px -2px 4px rgba(65,65,65,.5)}.nx-popover--right .nx-popover__arrow{transform:translate(0,-50%) rotate(-45deg);left:-5px}.nx-popover--bottom .nx-popover__arrow{transform:translate(-50%,0) rotate(45deg);top:-5px}.nx-popover--left .nx-popover__arrow{transform:translate(0,-50%) rotate(135deg);right:-5px}"]
            }] }
];
/** @nocollapse */
NxPopoverComponent.ctorParameters = () => [];
NxPopoverComponent.propDecorators = {
    templateRef: [{ type: ViewChild, args: [TemplateRef, { static: false },] }],
    _lazyContent: [{ type: ContentChild, args: [NxPopoverContentDirective, { static: false },] }],
    closed: [{ type: Output, args: ['nxClosed',] }]
};
if (false) {
    /**
     * \@docs-private
     * @type {?}
     */
    NxPopoverComponent.prototype.templateRef;
    /**
     * Content that will be rendered lazily.
     * @type {?}
     */
    NxPopoverComponent.prototype._lazyContent;
    /**
     * Event emitted when the popover is closed.
     * @type {?}
     */
    NxPopoverComponent.prototype.closed;
    /**
     * \@docs-private
     * @type {?}
     */
    NxPopoverComponent.prototype.closeButtonClick;
    /**
     * \@docs-private
     * @type {?}
     */
    NxPopoverComponent.prototype.id;
    /**
     * \@docs-private
     * @type {?}
     */
    NxPopoverComponent.prototype.direction;
    /**
     * \@docs-private
     * @type {?}
     */
    NxPopoverComponent.prototype.showCloseButton;
    /**
     * \@docs-private
     * @type {?}
     */
    NxPopoverComponent.prototype.arrowStyle;
}

/**
 * @fileoverview added by tsickle
 * Generated from: popover-trigger.directive.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
let nextId = 0;
/** @type {?} */
const fallbacks = [
    {
        originX: 'start',
        originY: 'bottom',
        overlayX: 'start',
        overlayY: 'top',
        offsetX: 0,
        offsetY: 16
    },
    {
        originX: 'end',
        originY: 'top',
        overlayX: 'end',
        overlayY: 'bottom',
        offsetX: 0,
        offsetY: -16
    },
    {
        originX: 'center',
        originY: 'bottom',
        overlayX: 'center',
        overlayY: 'top',
        offsetX: 0,
        offsetY: 16
    },
    {
        originX: 'end',
        originY: 'bottom',
        overlayX: 'end',
        overlayY: 'top',
        offsetX: 0,
        offsetY: 16
    },
    {
        originX: 'end',
        originY: 'center',
        overlayX: 'start',
        overlayY: 'center',
        offsetX: 16,
        offsetY: 0
    },
    {
        originX: 'start',
        originY: 'center',
        overlayX: 'end',
        overlayY: 'center',
        offsetX: -16,
        offsetY: 0
    },
    {
        originX: 'center',
        originY: 'top',
        overlayX: 'center',
        overlayY: 'bottom',
        offsetX: 0,
        offsetY: -16
    },
    {
        originX: 'start',
        originY: 'top',
        overlayX: 'start',
        overlayY: 'bottom',
        offsetX: 0,
        offsetY: -16
    }
];
class NxPopoverTriggerDirective {
    /**
     * @param {?} overlay
     * @param {?} elementRef
     * @param {?} viewContainerRef
     * @param {?} eventManager
     * @param {?} _focusTrapFactory
     * @param {?} _focusMonitor
     * @param {?} _ngZone
     * @param {?} _platform
     * @param {?} _document
     */
    constructor(overlay, elementRef, viewContainerRef, eventManager, _focusTrapFactory, _focusMonitor, _ngZone, _platform, _document) {
        this.overlay = overlay;
        this.elementRef = elementRef;
        this.viewContainerRef = viewContainerRef;
        this.eventManager = eventManager;
        this._focusTrapFactory = _focusTrapFactory;
        this._focusMonitor = _focusMonitor;
        this._ngZone = _ngZone;
        this._platform = _platform;
        this._document = _document;
        this._destroyed = new Subject();
        this._show = false;
        this._closeable = null;
        /**
         * Element that was focused before the Popover was opened. Save this to restore upon close.
         */
        this._elementFocusedBeforePopoverWasOpened = null;
        this._manualListeners = new Map();
        /**
         * \@docs-private
         */
        this.id = 'nx-popover-' + nextId++;
        /**
         * An event is emitted if the visibility status of the popover changes.
         */
        this.changeShow = new EventEmitter();
        this._closeOnClickOutside = true;
        /**
         * Sets the desired direction to open the popover. E.g., right, left, bottom, top
         */
        this.direction = 'right';
        /**
         * Whether the popover will be opened automatically.
         */
        this.popoverInitialVisible = false;
        /**
         * An event is emitted when the visibility of the popopver changes.
         */
        this.visibleChange = new EventEmitter();
        /**
         * Whether the popover opens in modal state.
         */
        this.modal = false;
        // If nxPopoverTrigger equals to 'hover' the popover opens on mouseenter and closes on mouseout.
        // If nxPopoverTrigger equals to 'click' the popover opens on click and closes on a click of the close icon or pressing ESC key.
        // If nxPopoverTrigger equals to 'manual' the popover opens only when programatically requested.
        /**
         * Sets the way to trigger the popover. Options are hover, click, manual
         */
        this.trigger = 'click';
        /**
         * Sets the scroll strategy. 'close' closes the popover on scroll while 'reposition' scrolls the popover with the origin.
         */
        this.scrollStrategy = 'close';
        this._documentClickObservable = fromEvent(document, 'click');
        /** @type {?} */
        const element = elementRef.nativeElement;
        if (!this._platform.IOS && !this._platform.ANDROID) {
            this._manualListeners
                .set('mouseenter', (/**
             * @return {?}
             */
            () => {
                if (this.trigger === 'hover') {
                    this.show = true;
                }
            }))
                .set('mouseleave', (/**
             * @return {?}
             */
            () => {
                if (this.trigger === 'hover') {
                    this.show = false;
                }
            }))
                .set('keydown', (/**
             * @param {?} event
             * @return {?}
             */
            (event) => {
                switch (event.keyCode) {
                    case SPACE:
                    case ENTER:
                        this.handleClick();
                        break;
                    default:
                        return;
                }
            }));
        }
        else {
            this._manualListeners.set('touchstart', (/**
             * @return {?}
             */
            () => {
                if (this.trigger === 'hover') {
                    this.show = true;
                }
            }));
        }
        this._manualListeners.forEach((/**
         * @param {?} listener
         * @param {?} event
         * @return {?}
         */
        (listener, event) => element.addEventListener(event, listener)));
        this._focusMonitor.monitor(element).pipe(takeUntil(this._destroyed)).subscribe((/**
         * @param {?} origin
         * @return {?}
         */
        origin => {
            if (origin === 'keyboard' && this.trigger === 'hover') {
                this._ngZone.run((/**
                 * @return {?}
                 */
                () => this.show = true));
            }
        }));
    }
    /**
     * Whether to show or hide the popover.
     * @param {?} value
     * @return {?}
     */
    set show(value) {
        value = coerceBooleanProperty(value);
        if (this._show !== value) {
            this._show = value;
            if (this._show) {
                this.openPopover();
            }
            else {
                this.closePopover();
            }
        }
    }
    /**
     * @return {?}
     */
    get show() {
        return this._show;
    }
    /**
     * Whether to show a close button. By default a close icon is only shown for trigger type click.
     * @param {?} value
     * @return {?}
     */
    set closeable(value) {
        this._closeable = coerceBooleanProperty(value);
        if (this.popover) {
            this.popover.showCloseButton = this.isCloseable();
        }
    }
    /**
     * @return {?}
     */
    get closeable() {
        return this._closeable;
    }
    /**
     * Whether the popover should be closed on click outside of the popover in the trigger modes 'manual' and 'click'.
     * @param {?} value
     * @return {?}
     */
    set closeOnClickOutside(value) {
        this._closeOnClickOutside = coerceBooleanProperty(value);
    }
    /**
     * @return {?}
     */
    get closeOnClickOutside() {
        return this._closeOnClickOutside;
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.popover.showCloseButton = this.isCloseable();
    }
    /**
     * @return {?}
     */
    ngAfterViewInit() {
        this.popover.id = this.id;
        this.eventManager.addGlobalEventListener('window', 'keyup.esc', (/**
         * @return {?}
         */
        () => {
            if (this.isOpen) {
                this.show = false;
            }
        }));
        this.popover.closeButtonClick.pipe(takeUntil(this._destroyed)).subscribe((/**
         * @return {?}
         */
        () => {
            this.show = false;
        }));
        if (this.popoverInitialVisible || this._show) {
            this.show = true;
        }
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this.show = false;
        // Clean up the event listeners set in the constructor
        this._manualListeners.forEach((/**
         * @param {?} listener
         * @param {?} event
         * @return {?}
         */
        (listener, event) => {
            this.elementRef.nativeElement.removeEventListener(event, listener);
        }));
        this._manualListeners.clear();
        this._destroyed.next();
        this._destroyed.complete();
    }
    /**
     * \@docs-private
     * @return {?}
     */
    get isOpen() {
        return this.overlayRef && this.createOverlay().hasAttached();
    }
    /**
     * \@docs-private
     * @return {?}
     */
    isCloseable() {
        return (this.trigger === 'click' && this._closeable === null) || this._closeable;
    }
    /**
     * Update the popover with the given position strategy.
     * @return {?}
     */
    updatePosition() {
        if (this._positionStrategy) {
            this._positionStrategy.apply();
        }
    }
    /**
     * \@docs-private
     * @return {?}
     */
    handleClick() {
        if (this.trigger === 'click') {
            this.show = !this.isOpen;
        }
        else if (this.trigger === 'hover') {
            this.show = true;
        }
    }
    /**
     * Open the popover instance.
     * @return {?}
     */
    open() {
        this.show = true;
    }
    /**
     * Close the popover instance.
     * @return {?}
     */
    close() {
        this.show = false;
    }
    /**
     * Toggle the popover instance.
     * @return {?}
     */
    toggle() {
        this.show = !this.show;
    }
    /**
     * @private
     * @return {?}
     */
    openPopover() {
        if (!this.createOverlay().hasAttached()) {
            this._embeddedViewRef = this.createOverlay().attach(this.portal);
            /** @type {?} */
            const element = (/** @type {?} */ (this._embeddedViewRef.rootNodes[0]));
            this._focusTrap = this._focusTrapFactory.create(element);
            this._elementFocusedBeforePopoverWasOpened = this.elementRef.nativeElement;
            this._autoFocusFirstTabbableElement(element);
            // attach a close click listener only if it makes sense (ignore it on hover e.g.)
            if (this.shouldReactOnClickOutside()) {
                this.waitForClose();
            }
        }
    }
    /**
     * Autofocus the first tabbable element inside of the popover, if there is not a tabbable element,
     * focus the popover instead.
     * @private
     * @param {?} element
     * @return {?}
     */
    _autoFocusFirstTabbableElement(element) {
        this._focusTrap.focusInitialElementWhenReady().then((/**
         * @param {?} hasMovedFocus
         * @return {?}
         */
        hasMovedFocus => {
            // If we didn't find any focusable elements inside the popover, focus the
            // container so the user can't tab into other elements behind it.
            if (!hasMovedFocus) {
                element.focus();
            }
        }));
    }
    /**
     * @private
     * @return {?}
     */
    shouldReactOnClickOutside() {
        return (!this.modal && this.closeOnClickOutside);
    }
    // detaches the overlay
    // we are listening to the detachments observable which will then emit the nxClosed event
    // on the popover component
    /**
     * @private
     * @return {?}
     */
    closePopover() {
        if (this.overlayRef) {
            this._returnFocusAfterPopover();
            this.overlayRef.detach();
            this._embeddedViewRef = null;
            this._focusTrap.destroy();
        }
    }
    /**
     * @private
     * @return {?}
     */
    createOverlay() {
        if (!this.overlayRef) {
            this.portal = new TemplatePortal(this.popover.templateRef, this.viewContainerRef);
            /** @type {?} */
            const overlayState = new OverlayConfig();
            overlayState.positionStrategy = this.getPosition();
            this._positionStrategy = overlayState.positionStrategy;
            if (this.scrollStrategy === 'reposition') {
                overlayState.scrollStrategy = this.overlay.scrollStrategies.reposition();
            }
            else {
                overlayState.scrollStrategy = this.overlay.scrollStrategies.close();
            }
            overlayState.scrollStrategy.enable();
            if (this.modal && this.trigger === 'click') {
                overlayState.hasBackdrop = true;
            }
            this.overlayRef = this.overlay.create(overlayState);
            this.subscribeToPositions((/** @type {?} */ (overlayState.positionStrategy)));
            this._subscribeToAttach();
            this._subscribeToDetach();
            if (this.modal) {
                this._subscribeToBackdropClick();
            }
        }
        return this.overlayRef;
    }
    /**
     * @private
     * @param {?} position
     * @return {?}
     */
    subscribeToPositions(position) {
        position.positionChanges.pipe(takeUntil(this._destroyed)).subscribe((/**
         * @param {?} change
         * @return {?}
         */
        change => {
            /** @type {?} */
            const pair = change.connectionPair;
            this.positionOverlay(pair);
            this.positionArrow(pair);
            // These position changes arrive too late,
            // We have to trigger the change detection manually
            // as it's detached from any render hierarchy
            // and only updated by the overlay when attached.
            if (this._embeddedViewRef && !this._embeddedViewRef.destroyed) {
                this._embeddedViewRef.detectChanges();
            }
        }));
    }
    // for modal popovers close the popover on backdrop clicks
    /**
     * @private
     * @return {?}
     */
    _subscribeToBackdropClick() {
        this.overlayRef.backdropClick().pipe(takeUntil(this._destroyed)).subscribe((/**
         * @param {?} event
         * @return {?}
         */
        (event) => {
            this.show = false;
        }));
    }
    // Emit the nxClosed and the show status change event on the popover component when the overlay detaches
    /**
     * @private
     * @return {?}
     */
    _subscribeToDetach() {
        this.overlayRef.detachments().pipe(takeUntil(this._destroyed)).subscribe((/**
         * @param {?} data
         * @return {?}
         */
        data => {
            // This is an exception: when the popover is closed by a scrolling event,
            // then only the detached method is called but the show state variable remains unchanged.
            if (this.show) {
                this.show = false;
            }
            this.changeShow.emit(this._show);
            this.popover.emitClosedEvent();
        }));
    }
    /**
     * @private
     * @return {?}
     */
    _subscribeToAttach() {
        this.overlayRef.attachments().pipe(takeUntil(this._destroyed)).subscribe((/**
         * @param {?} data
         * @return {?}
         */
        data => {
            this.changeShow.emit(this._show);
        }));
    }
    // subscribe to document clicks when trigger='click' to close the popover on clicks on the background
    /**
     * @private
     * @return {?}
     */
    waitForClose() {
        return this._documentClickObservable
            .pipe(map((/**
         * @param {?} event
         * @return {?}
         */
        event => event.target)), filter((/**
         * @param {?} target
         * @return {?}
         */
        target => !this.elementRef.nativeElement.contains(target))), takeUntil(this.popover.closed))
            .subscribe((/**
         * @return {?}
         */
        () => {
            this.show = false;
        }));
    }
    /**
     * @private
     * @param {?} pair
     * @return {?}
     */
    positionOverlay(pair) {
        if (pair.originX === 'end' && pair.overlayX === 'start') {
            this.popover.direction = 'right';
        }
        else if (pair.originY === 'bottom' && pair.overlayY === 'top') {
            this.popover.direction = 'bottom';
        }
        else if (pair.originX === 'start' && pair.overlayX === 'end') {
            this.popover.direction = 'left';
        }
        else if (pair.originY === 'top' && pair.overlayY === 'bottom') {
            this.popover.direction = 'top';
        }
    }
    /**
     * @private
     * @param {?} pair
     * @return {?}
     */
    positionArrow(pair) {
        /** @type {?} */
        const parentElementPositionX = this.elementRef.nativeElement.getBoundingClientRect().left;
        /** @type {?} */
        const parentElementWidth = this.elementRef.nativeElement.getBoundingClientRect().width / 2;
        /** @type {?} */
        const parentElementLeftOffset = this.overlayRef.overlayElement.parentElement.offsetLeft;
        /** @type {?} */
        const overlayElementLeftOffset = this.overlayRef.overlayElement.offsetLeft;
        // calculation for x position of the parent element. In this case, overlay left offset is the one thing to consider.
        /** @type {?} */
        const targetPosition = (parentElementPositionX + parentElementWidth) - (parentElementLeftOffset + overlayElementLeftOffset);
        if (pair.originX === pair.overlayX) {
            /** @type {?} */
            const direction = 'left';
            /** @type {?} */
            const arrowStyle = {};
            arrowStyle[direction] = targetPosition + 'px';
            this.popover.arrowStyle = arrowStyle;
        }
        if ((pair.originY === 'bottom' || pair.originY === 'top') && pair.overlayX === 'center') {
            this.popover.arrowStyle = { left: targetPosition + 'px' };
        }
        if ((pair.originX === 'end' || pair.originX === 'start') && pair.overlayY === 'center') {
            this.popover.arrowStyle = { top: '50%' };
        }
    }
    /**
     * @private
     * @return {?}
     */
    getPosition() {
        /** @type {?} */
        let positions;
        /** @type {?} */
        let offsetX = 0;
        /** @type {?} */
        let offsetY = 0;
        if (this.direction === 'top') {
            positions = [{
                    overlayX: 'center',
                    overlayY: 'bottom',
                    originX: 'center',
                    originY: 'top'
                }];
            offsetX = 0;
            offsetY = -20;
        }
        else if (this.direction === 'right') {
            positions = [{
                    overlayX: 'start',
                    overlayY: 'center',
                    originX: 'end',
                    originY: 'center'
                }];
            offsetX = 20;
            offsetY = 0;
        }
        else if (this.direction === 'bottom') {
            positions = [{
                    overlayX: 'center',
                    overlayY: 'top',
                    originX: 'center',
                    originY: 'bottom'
                }];
            offsetX = 0;
            offsetY = 20;
        }
        else if (this.direction === 'left') {
            positions = [{
                    overlayX: 'end',
                    overlayY: 'center',
                    originX: 'start',
                    originY: 'center'
                }];
            offsetX = -20;
            offsetY = 0;
        }
        return this.overlay.position().flexibleConnectedTo(this.elementRef)
            .withPositions([...positions, ...fallbacks])
            .withDefaultOffsetX(offsetX)
            .withDefaultOffsetY(offsetY);
    }
    /**
     * Returns the focus to the element focused before the Popover was open.
     * @private
     * @return {?}
     */
    _returnFocusAfterPopover() {
        /** @type {?} */
        const toFocus = this._elementFocusedBeforePopoverWasOpened;
        // We need the extra check, because IE can set the `activeElement` to null in some cases.
        if (toFocus && typeof toFocus.focus === 'function') {
            toFocus.focus();
        }
    }
}
NxPopoverTriggerDirective.decorators = [
    { type: Directive, args: [{
                selector: '[nxPopoverTriggerFor]',
                exportAs: 'nxPopoverTrigger',
                host: {
                    '(click)': 'handleClick()',
                    'aria-haspopup': 'true',
                    '[attr.aria-expanded]': 'isOpen',
                    '[attr.aria-describedby]': 'isOpen ? id : null'
                }
            },] }
];
/** @nocollapse */
NxPopoverTriggerDirective.ctorParameters = () => [
    { type: Overlay },
    { type: ElementRef },
    { type: ViewContainerRef },
    { type: EventManager },
    { type: FocusTrapFactory },
    { type: FocusMonitor },
    { type: NgZone },
    { type: Platform },
    { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [DOCUMENT,] }] }
];
NxPopoverTriggerDirective.propDecorators = {
    changeShow: [{ type: Output, args: ['nxPopoverShowChange',] }],
    show: [{ type: Input, args: ['nxPopoverShow',] }],
    closeable: [{ type: Input, args: ['nxPopoverCloseable',] }],
    closeOnClickOutside: [{ type: Input }],
    popover: [{ type: Input, args: ['nxPopoverTriggerFor',] }],
    direction: [{ type: Input, args: ['nxPopoverDirection',] }],
    popoverInitialVisible: [{ type: Input, args: ['nxPopoverInitialVisible',] }],
    visibleChange: [{ type: Input, args: ['nxPopoverVisibleChange',] }],
    modal: [{ type: Input, args: ['nxPopoverModal',] }],
    trigger: [{ type: Input, args: ['nxPopoverTrigger',] }],
    scrollStrategy: [{ type: Input, args: ['nxPopoverScrollStrategy',] }]
};
if (false) {
    /**
     * @type {?}
     * @private
     */
    NxPopoverTriggerDirective.prototype.overlayRef;
    /**
     * @type {?}
     * @private
     */
    NxPopoverTriggerDirective.prototype.portal;
    /**
     * @type {?}
     * @private
     */
    NxPopoverTriggerDirective.prototype._destroyed;
    /**
     * @type {?}
     * @private
     */
    NxPopoverTriggerDirective.prototype._show;
    /**
     * @type {?}
     * @private
     */
    NxPopoverTriggerDirective.prototype._closeable;
    /**
     * @type {?}
     * @private
     */
    NxPopoverTriggerDirective.prototype._positionStrategy;
    /**
     * @type {?}
     * @private
     */
    NxPopoverTriggerDirective.prototype._embeddedViewRef;
    /**
     * @type {?}
     * @private
     */
    NxPopoverTriggerDirective.prototype._documentClickObservable;
    /**
     * The class that traps and manages focus within the popover.
     * @type {?}
     * @private
     */
    NxPopoverTriggerDirective.prototype._focusTrap;
    /**
     * Element that was focused before the Popover was opened. Save this to restore upon close.
     * @type {?}
     * @private
     */
    NxPopoverTriggerDirective.prototype._elementFocusedBeforePopoverWasOpened;
    /**
     * @type {?}
     * @private
     */
    NxPopoverTriggerDirective.prototype._manualListeners;
    /**
     * \@docs-private
     * @type {?}
     */
    NxPopoverTriggerDirective.prototype.id;
    /**
     * An event is emitted if the visibility status of the popover changes.
     * @type {?}
     */
    NxPopoverTriggerDirective.prototype.changeShow;
    /**
     * @type {?}
     * @private
     */
    NxPopoverTriggerDirective.prototype._closeOnClickOutside;
    /**
     * Links the trigger with the popover to open.
     * @type {?}
     */
    NxPopoverTriggerDirective.prototype.popover;
    /**
     * Sets the desired direction to open the popover. E.g., right, left, bottom, top
     * @type {?}
     */
    NxPopoverTriggerDirective.prototype.direction;
    /**
     * Whether the popover will be opened automatically.
     * @type {?}
     */
    NxPopoverTriggerDirective.prototype.popoverInitialVisible;
    /**
     * An event is emitted when the visibility of the popopver changes.
     * @type {?}
     */
    NxPopoverTriggerDirective.prototype.visibleChange;
    /**
     * Whether the popover opens in modal state.
     * @type {?}
     */
    NxPopoverTriggerDirective.prototype.modal;
    /**
     * Sets the way to trigger the popover. Options are hover, click, manual
     * @type {?}
     */
    NxPopoverTriggerDirective.prototype.trigger;
    /**
     * Sets the scroll strategy. 'close' closes the popover on scroll while 'reposition' scrolls the popover with the origin.
     * @type {?}
     */
    NxPopoverTriggerDirective.prototype.scrollStrategy;
    /**
     * @type {?}
     * @private
     */
    NxPopoverTriggerDirective.prototype.overlay;
    /**
     * @type {?}
     * @private
     */
    NxPopoverTriggerDirective.prototype.elementRef;
    /**
     * @type {?}
     * @private
     */
    NxPopoverTriggerDirective.prototype.viewContainerRef;
    /**
     * @type {?}
     * @private
     */
    NxPopoverTriggerDirective.prototype.eventManager;
    /**
     * @type {?}
     * @private
     */
    NxPopoverTriggerDirective.prototype._focusTrapFactory;
    /**
     * @type {?}
     * @private
     */
    NxPopoverTriggerDirective.prototype._focusMonitor;
    /**
     * @type {?}
     * @private
     */
    NxPopoverTriggerDirective.prototype._ngZone;
    /**
     * @type {?}
     * @private
     */
    NxPopoverTriggerDirective.prototype._platform;
    /**
     * @type {?}
     * @private
     */
    NxPopoverTriggerDirective.prototype._document;
}

/**
 * @fileoverview added by tsickle
 * Generated from: popover.module.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class NxPopoverModule {
}
NxPopoverModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    CommonModule,
                    OverlayModule,
                    NxIconModule
                ],
                declarations: [
                    NxPopoverTriggerDirective,
                    NxPopoverComponent,
                    NxPopoverContentDirective
                ],
                exports: [
                    NxPopoverTriggerDirective,
                    NxPopoverComponent,
                    NxPopoverContentDirective
                ]
            },] }
];

/**
 * @fileoverview added by tsickle
 * Generated from: public-api.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * Generated from: allianz-ngx-ndbx-popover.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

export { NxPopoverComponent, NxPopoverContentDirective, NxPopoverModule, NxPopoverTriggerDirective };
//# sourceMappingURL=allianz-ngx-ndbx-popover.js.map
