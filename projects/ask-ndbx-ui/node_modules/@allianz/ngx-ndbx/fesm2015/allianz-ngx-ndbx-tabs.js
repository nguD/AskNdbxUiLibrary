import { Component, ViewChild, ViewContainerRef, Input, Directive, TemplateRef, ChangeDetectionStrategy, Inject, Optional, Host, ContentChild, ElementRef, EventEmitter, ChangeDetectorRef, Output, ContentChildren, ViewChildren, HostListener, SkipSelf, NgModule } from '@angular/core';
import { CdkPortal, PortalModule } from '@angular/cdk/portal';
import { CommonModule } from '@angular/common';
import { NxExpansionPanelComponent, NxAccordionDirective, NxAccordionModule } from '@allianz/ngx-ndbx/accordion';
import { Subject, Subscription, merge } from 'rxjs';
import { coerceBooleanProperty, coerceNumberProperty } from '@angular/cdk/coercion';
import { FocusKeyManager } from '@angular/cdk/a11y';
import { SPACE, ENTER, END, HOME } from '@angular/cdk/keycodes';

/**
 * @fileoverview added by tsickle
 * Generated from: tab-group-base.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * \@docs-private
 * @abstract
 */
class NxTabGroupBase {
}

/**
 * @fileoverview added by tsickle
 * Generated from: tab-header-outlet.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * \@docs-private
 */
class NxTabHeaderOutletComponent {
    /**
     * @param {?} _tabGroup
     */
    constructor(_tabGroup) {
        this._tabGroup = _tabGroup;
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this._appearanceSubscription = ((/** @type {?} */ (this._tabGroup)))._appearanceChange.subscribe((/**
         * @return {?}
         */
        () => {
            this.detach();
        }));
        this.attach();
    }
    /**
     * @return {?}
     */
    attach() {
        this._outlet.insert(this.content);
    }
    /**
     * @return {?}
     */
    detach() {
        /** @type {?} */
        const index = this._outlet.indexOf(this.content);
        if (index !== -1) {
            this._outlet.detach(index);
        }
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this._appearanceSubscription.unsubscribe();
    }
}
NxTabHeaderOutletComponent.decorators = [
    { type: Component, args: [{
                selector: 'nx-tab-header-outlet',
                template: '<ng-container #outlet></ng-container>'
            }] }
];
/** @nocollapse */
NxTabHeaderOutletComponent.ctorParameters = () => [
    { type: NxTabGroupBase }
];
NxTabHeaderOutletComponent.propDecorators = {
    _outlet: [{ type: ViewChild, args: ['outlet', { static: true, read: ViewContainerRef },] }],
    content: [{ type: Input }]
};
if (false) {
    /** @type {?} */
    NxTabHeaderOutletComponent.prototype._outlet;
    /** @type {?} */
    NxTabHeaderOutletComponent.prototype.content;
    /**
     * @type {?}
     * @private
     */
    NxTabHeaderOutletComponent.prototype._appearanceSubscription;
    /**
     * @type {?}
     * @private
     */
    NxTabHeaderOutletComponent.prototype._tabGroup;
}

/**
 * @fileoverview added by tsickle
 * Generated from: tab-label.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * \@docs-private
 */
class NxTabLabelDirective extends CdkPortal {
}
NxTabLabelDirective.decorators = [
    { type: Directive, args: [{ selector: '[nxTabLabel]' },] }
];

/**
 * @fileoverview added by tsickle
 * Generated from: tab-content.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Decorates the `ng-template` tags and reads out the template from it.
 */
class NxTabContentDirective {
    /**
     * @param {?} template
     */
    constructor(/** @docs-private */ template) {
        this.template = template;
    }
}
NxTabContentDirective.decorators = [
    { type: Directive, args: [{ selector: '[nxTabContent]' },] }
];
/** @nocollapse */
NxTabContentDirective.ctorParameters = () => [
    { type: TemplateRef }
];
if (false) {
    /**
     * \@docs-private
     * @type {?}
     */
    NxTabContentDirective.prototype.template;
}

/**
 * @fileoverview added by tsickle
 * Generated from: tab.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class NxTabComponent {
    /**
     * @param {?} _tabGroup
     */
    constructor(_tabGroup) {
        this._tabGroup = _tabGroup;
        this._disabled = false;
        /**
         * Emits whenever the internal state of the tab changes.
         */
        this._stateChanges = new Subject();
        /**
         * Whether the tab is currently active.
         */
        this.isActive = false;
        if (!this._tabGroup) {
            throw Error(`The nx-tab element has to be wrapped in a nx-tab-group to work.
      Please provide a nx-tab-group element and place your tabs inside it.`);
        }
    }
    /**
     * Content for the tab label given by `<ng-template nxTabLabel>`.
     * \@docs-private
     *
     * @return {?}
     */
    get templateLabel() { return this._templateLabel; }
    /**
     * @param {?} value
     * @return {?}
     */
    set templateLabel(value) {
        // Only update the templateLabel via query if there is actually
        // a nxTabLabel found. This works around an issue where a user may have
        // manually set `templateLabel` during creation mode, which would then get clobbered
        // by `undefined` when this query resolves.
        if (value) {
            this._templateLabel = value;
        }
    }
    /**
     * Sets the label of the tab shown in the tablist.
     * @return {?}
     */
    get label() {
        return this._label;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set label(value) {
        if (this._label !== value) {
            this._label = value;
        }
    }
    /**
     * Sets the tab to disabled.
     * @return {?}
     */
    get disabled() {
        return (this._tabGroup && ((/** @type {?} */ (this._tabGroup))).disabled) ?
            ((/** @type {?} */ (this._tabGroup))).disabled : this._disabled;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set disabled(value) {
        if (this._disabled !== value) {
            this._disabled = value;
        }
    }
    /**
     * \@docs-private
     * @return {?}
     */
    get headerViewRef() {
        return this._headerViewRef;
    }
    /**
     * \@docs-private
     * @return {?}
     */
    get contentViewRef() {
        // for lazy loading we only create the viewref when it is asked for
        if (!this._contentViewRef) {
            /** @type {?} */
            const contentTemplate = this._explicitContent || this._implicitContent;
            this._contentViewRef = contentTemplate.createEmbeddedView({});
        }
        return this._contentViewRef;
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        if (changes.hasOwnProperty('label') || changes.hasOwnProperty('disabled')) {
            this._stateChanges.next();
        }
    }
    /**
     * @return {?}
     */
    ngAfterContentInit() {
        if (this.templateLabel) {
            this._headerViewRef = this.templateLabel.createEmbeddedView({});
        }
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this._stateChanges.complete();
        this._contentViewRef.destroy();
        if (this._headerViewRef) {
            this._headerViewRef.destroy();
        }
    }
}
NxTabComponent.decorators = [
    { type: Component, args: [{
                selector: 'nx-tab',
                exportAs: 'nxTab',
                template: "<ng-template><ng-content></ng-content></ng-template>\n",
                changeDetection: ChangeDetectionStrategy.OnPush
            }] }
];
/** @nocollapse */
NxTabComponent.ctorParameters = () => [
    { type: NxTabGroupBase, decorators: [{ type: Inject, args: [NxTabGroupBase,] }, { type: Optional }, { type: Host }] }
];
NxTabComponent.propDecorators = {
    templateLabel: [{ type: ContentChild, args: [NxTabLabelDirective, { read: TemplateRef, static: true },] }],
    _implicitContent: [{ type: ViewChild, args: [TemplateRef, { static: true },] }],
    _explicitContent: [{ type: ContentChild, args: [NxTabContentDirective, { read: TemplateRef, static: true },] }],
    label: [{ type: Input }],
    disabled: [{ type: Input }]
};
if (false) {
    /**
     * @type {?}
     * @private
     */
    NxTabComponent.prototype._label;
    /**
     * @type {?}
     * @private
     */
    NxTabComponent.prototype._disabled;
    /**
     * Emits whenever the internal state of the tab changes.
     * @type {?}
     */
    NxTabComponent.prototype._stateChanges;
    /**
     * @type {?}
     * @private
     */
    NxTabComponent.prototype._templateLabel;
    /**
     * Template inside the NxTab view that contains an `<ng-content>`.
     * @type {?}
     */
    NxTabComponent.prototype._implicitContent;
    /**
     * Template provided in the tab content that will be used if present, used to enable lazy-loading
     * @type {?}
     */
    NxTabComponent.prototype._explicitContent;
    /**
     * @type {?}
     * @private
     */
    NxTabComponent.prototype._headerViewRef;
    /**
     * @type {?}
     * @private
     */
    NxTabComponent.prototype._contentViewRef;
    /**
     * Whether the tab is currently active.
     * @type {?}
     */
    NxTabComponent.prototype.isActive;
    /**
     * @type {?}
     * @private
     */
    NxTabComponent.prototype._tabGroup;
}

/**
 * @fileoverview added by tsickle
 * Generated from: tab-body.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * \@docs-private
 */
class NxTabBodyComponent {
    /**
     * @param {?} _tabGroup
     */
    constructor(_tabGroup) {
        this._tabGroup = _tabGroup;
        this._active = false;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set active(value) {
        this._active = coerceBooleanProperty(value);
        if (this._active) {
            this.attach();
        }
        else {
            this.detach();
        }
    }
    /**
     * @return {?}
     */
    get active() {
        return this._active;
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this._appearanceSubscription = ((/** @type {?} */ (this._tabGroup)))._appearanceChange.subscribe((/**
         * @return {?}
         */
        () => {
            this.detach();
        }));
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this._appearanceSubscription.unsubscribe();
    }
    /**
     * @return {?}
     */
    attach() {
        this._outlet.insert(this.tab.contentViewRef);
    }
    /**
     * @return {?}
     */
    detach() {
        /** @type {?} */
        const index = this._outlet.indexOf(this.tab.contentViewRef);
        if (index !== -1) {
            this._outlet.detach(index);
        }
    }
}
NxTabBodyComponent.decorators = [
    { type: Component, args: [{
                selector: 'nx-tab-body',
                template: "<ng-container #outlet></ng-container>",
                changeDetection: ChangeDetectionStrategy.OnPush,
                styles: [":host{display:block}"]
            }] }
];
/** @nocollapse */
NxTabBodyComponent.ctorParameters = () => [
    { type: NxTabGroupBase }
];
NxTabBodyComponent.propDecorators = {
    _outlet: [{ type: ViewChild, args: ['outlet', { static: true, read: ViewContainerRef },] }],
    tab: [{ type: Input }],
    active: [{ type: Input }]
};
if (false) {
    /**
     * @type {?}
     * @private
     */
    NxTabBodyComponent.prototype._appearanceSubscription;
    /** @type {?} */
    NxTabBodyComponent.prototype._outlet;
    /** @type {?} */
    NxTabBodyComponent.prototype.tab;
    /**
     * @type {?}
     * @private
     */
    NxTabBodyComponent.prototype._active;
    /**
     * @type {?}
     * @private
     */
    NxTabBodyComponent.prototype._tabGroup;
}

/**
 * @fileoverview added by tsickle
 * Generated from: tab-label-wrapper.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * \@docs-private
 */
class NxTabLabelWrapperDirective {
    /**
     * @param {?} elementRef
     */
    constructor(elementRef) {
        this.elementRef = elementRef;
        this._disabled = false;
    }
    /**
     * Whether the tab group is disabled. Default: false.
     * @return {?}
     */
    get disabled() {
        return this._disabled;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set disabled(value) {
        /** @type {?} */
        const newValue = coerceBooleanProperty(value);
        if (this.disabled !== newValue) {
            this._disabled = newValue;
        }
    }
    /**
     * @return {?}
     */
    focus() {
        this.elementRef.nativeElement.focus();
    }
}
NxTabLabelWrapperDirective.decorators = [
    { type: Directive, args: [{ selector: '[nxTabLabelWrapper]' },] }
];
/** @nocollapse */
NxTabLabelWrapperDirective.ctorParameters = () => [
    { type: ElementRef }
];
NxTabLabelWrapperDirective.propDecorators = {
    disabled: [{ type: Input }]
};
if (false) {
    /**
     * @type {?}
     * @private
     */
    NxTabLabelWrapperDirective.prototype._disabled;
    /** @type {?} */
    NxTabLabelWrapperDirective.prototype.elementRef;
}

/**
 * @fileoverview added by tsickle
 * Generated from: tab-header.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * \@docs-private
 */
class NxTabHeaderComponent {
    /**
     * @param {?} _changeDetectorRef
     */
    constructor(_changeDetectorRef) {
        this._changeDetectorRef = _changeDetectorRef;
        this._selectedIndex = 0;
        this._autoselect = true;
        this.selectFocusedIndex = new EventEmitter();
        this.indexFocused = new EventEmitter();
    }
    /**
     * @return {?}
     */
    get selectedIndex() {
        return this._selectedIndex;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set selectedIndex(value) {
        this._selectedIndex = value;
        if (this._keyManager) {
            this._keyManager.updateActiveItem(value);
        }
    }
    /**
     * @return {?}
     */
    get focusIndex() {
        return this._keyManager ? this._keyManager.activeItemIndex : 0;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set focusIndex(value) {
        if (!this._isValidIndex(value) || this.focusIndex === value || !this._keyManager) {
            return;
        }
        this._keyManager.setActiveItem(value);
    }
    /**
     * @return {?}
     */
    get autoselect() {
        return this._autoselect;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set autoselect(value) {
        this._autoselect = value;
    }
    /**
     * @return {?}
     */
    ngAfterContentInit() {
        this._keyManager = new FocusKeyManager(this.labels).withHorizontalOrientation('ltr').withWrap();
        this._keyManager.updateActiveItem(0);
        this._changeDetectorRef.markForCheck();
    }
    /**
     * @private
     * @param {?} idx
     * @return {?}
     */
    _isValidIndex(idx) {
        if (!this.labels) {
            return true;
        }
        /** @type {?} */
        const tab = this.labels.toArray()[idx] || null;
        return !!tab && !tab.disabled;
    }
    /**
     * Handles keyboard inputs on the labels
     * If autoselect is enabled the tab gets changed immediately
     * If autoselect is disabled only the focus changes but the user still has to select the item
     * by himself
     * @param {?} event
     * @return {?}
     */
    handleKeydown(event) {
        switch (event.keyCode) {
            case HOME:
                this._keyManager.setFirstItemActive();
                event.preventDefault();
                break;
            case END:
                this._keyManager.setLastItemActive();
                event.preventDefault();
                break;
            case ENTER:
            case SPACE:
                this.selectFocusedIndex.emit(this._keyManager.activeItemIndex);
                event.preventDefault();
                break;
            default:
                this._keyManager.onKeydown(event);
        }
        if (this.autoselect) {
            this.selectFocusedIndex.emit(this._keyManager.activeItemIndex);
        }
        else if (event.keyCode !== ENTER && event.keyCode !== SPACE) {
            this.indexFocused.emit(this._keyManager.activeItemIndex);
        }
    }
}
NxTabHeaderComponent.decorators = [
    { type: Component, args: [{
                selector: 'nx-tab-header',
                template: "<div class=\"nx-tab-header\" (keydown)=\"handleKeydown($event)\" role=\"tablist\">\n  <ng-content></ng-content>\n</div>",
                changeDetection: ChangeDetectionStrategy.OnPush,
                styles: [":host{display:block}.nx-tab-header{display:flex;align-items:flex-end;justify-content:center;padding:60px 0}"]
            }] }
];
/** @nocollapse */
NxTabHeaderComponent.ctorParameters = () => [
    { type: ChangeDetectorRef }
];
NxTabHeaderComponent.propDecorators = {
    selectedIndex: [{ type: Input }],
    autoselect: [{ type: Input }],
    selectFocusedIndex: [{ type: Output }],
    indexFocused: [{ type: Output }],
    labels: [{ type: ContentChildren, args: [NxTabLabelWrapperDirective,] }]
};
if (false) {
    /**
     * @type {?}
     * @private
     */
    NxTabHeaderComponent.prototype._keyManager;
    /**
     * @type {?}
     * @private
     */
    NxTabHeaderComponent.prototype._selectedIndex;
    /**
     * @type {?}
     * @private
     */
    NxTabHeaderComponent.prototype._autoselect;
    /** @type {?} */
    NxTabHeaderComponent.prototype.selectFocusedIndex;
    /** @type {?} */
    NxTabHeaderComponent.prototype.indexFocused;
    /** @type {?} */
    NxTabHeaderComponent.prototype.labels;
    /**
     * @type {?}
     * @private
     */
    NxTabHeaderComponent.prototype._changeDetectorRef;
}

/**
 * @fileoverview added by tsickle
 * Generated from: tab-group.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class NxTabChangeEvent {
}
if (false) {
    /**
     * The index of the selected or focused tab.
     * @type {?}
     */
    NxTabChangeEvent.prototype.index;
    /**
     * The component instance of the selected or focused tab.
     * @type {?}
     */
    NxTabChangeEvent.prototype.tab;
}
/** @type {?} */
let nextId = 0;
/** @type {?} */
const MOBILE_BREAKPOINT = 480;
class NxTabGroupComponent {
    /**
     * @param {?} _changeDetectorRef
     */
    constructor(_changeDetectorRef) {
        this._changeDetectorRef = _changeDetectorRef;
        this._selectedIndex = null;
        this._negative = false;
        this._disabled = false;
        this._indexToSelect = 0;
        this._autoselect = true;
        this._mobileAccordion = true;
        this._showAccordion = false;
        /**
         * An event emitted when the selected tab has changed.
         */
        this.selectedIndexChange = new EventEmitter();
        /**
         * An event emitted when the selected tab has changed.
         */
        this.selectedTabChange = new EventEmitter();
        /**
         * An event emitted when focus has changed within a tab group.
         *
         * **Note:** is not supported in mobile view.
         */
        this.focusChange = new EventEmitter();
        /**
         * Subscription to tabs being added/removed.
         */
        this._tabsSubscription = Subscription.EMPTY;
        /**
         * Subscription to changes in the tab labels.
         */
        this._tabLabelSubscription = Subscription.EMPTY;
        this._disabledTabsCache = [];
        this._appearanceChange = new Subject();
        this._groupId = nextId++;
    }
    /**
     * Sets the selected tab.
     * @return {?}
     */
    get selectedIndex() {
        return this._selectedIndex;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set selectedIndex(value) {
        this._indexToSelect = coerceNumberProperty(value, null);
    }
    /**
     * Whether the negative set of styling should be used.
     * @return {?}
     */
    get negative() {
        return this._negative;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set negative(value) {
        if (value !== this._negative) {
            this._negative = coerceBooleanProperty(value);
        }
    }
    /**
     * Whether the tab group is disabled. Default: false.
     * @return {?}
     */
    get disabled() {
        return this._disabled;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set disabled(value) {
        if (value !== this._disabled) {
            this._disabled = coerceBooleanProperty(value);
        }
    }
    /**
     * Whether the tab should be immediately selected on focus.
     * @return {?}
     */
    get autoselect() {
        return this._autoselect;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set autoselect(value) {
        this._autoselect = coerceBooleanProperty(value);
    }
    /**
     * Whether the tabs should to accordion on mobile viewports.
     * @return {?}
     */
    get mobileAccordion() {
        return this._mobileAccordion;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set mobileAccordion(value) {
        this._mobileAccordion = coerceBooleanProperty(value);
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this._switchAppearance(window.innerWidth);
    }
    /**
     * @return {?}
     */
    ngAfterContentInit() {
        this._subscribeToTabLabels();
        // Subscribe to changes in the amount of tabs, in order to be
        // able to re-render the content as new tabs are added or removed.
        this._tabsSubscription = this.tabs.changes.subscribe((/**
         * @return {?}
         */
        () => {
            /** @type {?} */
            const indexToSelect = this._clampTabIndex(this._indexToSelect);
            // Maintain the previously-selected tab if a new tab is added or removed and there is no
            // explicit change that selects a different tab.
            if (indexToSelect === this._selectedIndex) {
                /** @type {?} */
                const tabs = this.tabs.toArray();
                for (let i = 0; i < tabs.length; i++) {
                    if (tabs[i].isActive) {
                        // Assign both to the `_indexToSelect` and `_selectedIndex` so we don't fire a changed
                        // event, otherwise the consumer may end up in an infinite loop in some edge cases like
                        // adding a tab within the `selectedIndexChange` event.
                        this._indexToSelect = this._selectedIndex = i;
                        break;
                    }
                }
            }
            this._changeDetectorRef.markForCheck();
        }));
    }
    /**
     * After the content is checked, this component knows what tabs have been defined
     * and what the selected index should be.
     * @return {?}
     */
    ngAfterContentChecked() {
        // Don't clamp the `indexToSelect` immediately in the setter because it can happen that
        // the amount of tabs changes before the actual change detection runs.
        /** @type {?} */
        let indexToSelect = this._indexToSelect = this._clampTabIndex(this._indexToSelect);
        // If the active tab is disabled select the next focusable tab
        // if all tabs are disabled, allow selection of disabled active tab.
        if (!this.disabled && this.tabs.toArray()[indexToSelect].disabled) {
            /** @type {?} */
            const nextFocusable = this.tabs.toArray()
                .map((/**
             * @param {?} tab
             * @param {?} index
             * @return {?}
             */
            (tab, index) => ({ tab: tab, index: index })))
                .find((/**
             * @param {?} item
             * @return {?}
             */
            item => !item.tab.disabled));
            indexToSelect = nextFocusable ? nextFocusable.index : indexToSelect;
        }
        // If the index to select was disabled previously leave the selection on the current
        // so that the selection does not jump from one to another tab.
        if (this._disabledTabsCache[this._indexToSelect]) {
            this._indexToSelect = this.selectedIndex;
        }
        // If there is a change in selected index, emit a change event. Should not trigger if
        // the selected index has not yet been initialized.
        if (this._selectedIndex !== indexToSelect) {
            /** @type {?} */
            const isFirstRun = this._selectedIndex == null;
            if (!isFirstRun) {
                this.selectedTabChange.emit(this._createChangeEvent(indexToSelect));
            }
            // Changing these values after change detection has run
            // since the checked content may contain references to them.
            Promise.resolve().then((/**
             * @return {?}
             */
            () => {
                this.tabs.forEach((/**
                 * @param {?} tab
                 * @param {?} index
                 * @return {?}
                 */
                (tab, index) => tab.isActive = index === indexToSelect));
                if (!isFirstRun) {
                    this.selectedIndexChange.emit(indexToSelect);
                }
            }));
        }
        if (this._selectedIndex !== indexToSelect) {
            this._selectedIndex = indexToSelect;
            this._changeDetectorRef.markForCheck();
        }
        // cache the previous disabled status of all tabs
        if (!this.disabled) {
            this.tabs.toArray().forEach((/**
             * @param {?} tab
             * @param {?} index
             * @return {?}
             */
            (tab, index) => this._disabledTabsCache[index] = tab.disabled));
        }
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this._tabsSubscription.unsubscribe();
        this._tabLabelSubscription.unsubscribe();
    }
    /**
     * Subscribes to changes in the tab labels. This is needed, because the \@Input for the label is
     * on the NxTab component, whereas the data binding is inside the NxTabGroup. In order for the
     * binding to be updated, we need to subscribe to changes in it and trigger change detection
     * manually.
     * @private
     * @return {?}
     */
    _subscribeToTabLabels() {
        if (this._tabLabelSubscription) {
            this._tabLabelSubscription.unsubscribe();
        }
        this._tabLabelSubscription = merge(...this.tabs.map((/**
         * @param {?} tab
         * @return {?}
         */
        tab => tab._stateChanges)))
            .subscribe((/**
         * @return {?}
         */
        () => this._changeDetectorRef.markForCheck()));
    }
    /**
     * Clamps the given index to the bounds of 0 and the tabs length.
     * @private
     * @param {?} index
     * @return {?}
     */
    _clampTabIndex(index) {
        // Note the `|| 0`, which ensures that values like NaN can't get through
        // and which would otherwise throw the component into an infinite loop
        // (since Math.max(NaN, 0) === NaN).
        return Math.min(this.tabs.length - 1, Math.max(index || 0, 0));
    }
    /**
     * \@docs-private
     * @param {?} index
     * @return {?}
     */
    focusChanged(index) {
        this.focusChange.emit(this._createChangeEvent(index));
    }
    /**
     * @private
     * @param {?} index
     * @return {?}
     */
    _createChangeEvent(index) {
        /** @type {?} */
        const event = new NxTabChangeEvent;
        event.index = index;
        if (this.tabs && this.tabs.length) {
            event.tab = this.tabs.toArray()[index];
        }
        return event;
    }
    /**
     * \@docs-private
     * @param {?} index
     * @return {?}
     */
    handleClick(index) {
        /** @type {?} */
        const clickedTab = this.tabs.toArray()[index];
        if (!this.disabled && !clickedTab.disabled) {
            this.selectedIndex = this.tabHeader.focusIndex = index;
        }
    }
    /**
     * \@docs-private
     * Returns the tabindex for a tab label
     * @param {?} tab
     * @param {?} idx
     * @return {?}
     */
    getTabIndex(tab, idx) {
        return (this.selectedIndex === idx && !tab.disabled && !this.disabled) ? 0 : -1;
    }
    /**
     * Returns a unique id for each tab label element
     * @param {?} i
     * @return {?}
     */
    _getTabLabelId(i) {
        return `nx-tab-label-${this._groupId}-${i}`;
    }
    /**
     * Returns a unique id for each tab content element
     * @param {?} i
     * @return {?}
     */
    _getTabContentId(i) {
        return `nx-tab-content-${this._groupId}-${i}`;
    }
    /**
     * \@docs-private
     * @param {?} event
     * @return {?}
     */
    onResize(event) {
        this._switchAppearance(event.target.innerWidth);
    }
    /**
     * @private
     * @param {?} viewPortWidth
     * @return {?}
     */
    _switchAppearance(viewPortWidth) {
        if (!this._mobileAccordion) {
            return;
        }
        // notify the outlets to detach the viewrefs for header and body before
        // we switch the appearance. this way we only instantiate the templates
        // once so that they do not get destroyed during the switch
        if (viewPortWidth <= MOBILE_BREAKPOINT && !this._showAccordion) {
            this._appearanceChange.next();
            this._showMobileVersion();
        }
        else if (viewPortWidth > MOBILE_BREAKPOINT && this._showAccordion) {
            this._appearanceChange.next();
            this._showDesktopVersion();
        }
    }
    /**
     * @private
     * @return {?}
     */
    _showMobileVersion() {
        this._showAccordion = true;
        this._changeDetectorRef.markForCheck();
    }
    /**
     * @private
     * @return {?}
     */
    _showDesktopVersion() {
        this._showAccordion = false;
        this._changeDetectorRef.markForCheck();
    }
    /**
     * Emulate the tab change event when an accordion panel is opened in
     * mobile viewports.
     * @param {?} index
     * @return {?}
     */
    _panelOpened(index) {
        this.selectedIndex = index;
    }
}
NxTabGroupComponent.decorators = [
    { type: Component, args: [{
                selector: 'nx-tab-group',
                template: "\n\n  <ng-container *ngIf=\"!_showAccordion\">\n  <nx-tab-header\n      #tabHeader\n      [selectedIndex]=\"selectedIndex\"\n      (selectFocusedIndex)=\"selectedIndex = $event\"\n      (indexFocused)=\"focusChanged($event)\"\n      [autoselect]=\"autoselect\">\n    <button\n      type=\"button\"\n      nxTabLabelWrapper\n      *ngFor=\"let tab of tabs; let i = index\"\n      role=\"tab\"\n      (click)=\"handleClick(i)\"\n      class=\"nx-tab-header__item\"\n      [id]=\"_getTabLabelId(i)\"\n      [attr.aria-controls]=\"_getTabContentId(i)\"\n      [attr.aria-selected]=\"selectedIndex == i\"\n      [attr.tabindex]=\"getTabIndex(tab, i)\"\n      [disabled]=\"tab.disabled\"\n      [class.nx-tab-header__item--disabled]=\"tab.disabled\"\n      [class.nx-tab-header__item--active]=\"selectedIndex == i\">\n      <div class=\"nx-tab-label__content\">\n        <nx-tab-header-outlet *ngIf=\"tab.templateLabel\" [content]=\"tab.headerViewRef\"></nx-tab-header-outlet>\n        <ng-container *ngIf=\"!tab.templateLabel\">{{tab.label}}</ng-container>\n      </div>\n    </button>\n  </nx-tab-header>\n\n  <div class=\"nx-tab-body__container\">\n    <nx-tab-body\n      *ngFor=\"let tab of tabs; let i = index\"\n      [id]=\"_getTabContentId(i)\"\n      role=\"tabpanel\"\n      [attr.tabindex]=\"(selectedIndex == i) ? 0 : -1\"\n      class=\"nx-tab__body\"\n      [attr.aria-labelledby]=\"_getTabContentId(i)\"\n      [class.nx-tab__body--active]=\"selectedIndex == i\"\n      [tab]=\"tab\"\n      [active]=\"selectedIndex == i\"\n    ></nx-tab-body>\n  </div>\n</ng-container>\n\n<nx-accordion *ngIf=\"_showAccordion\" [negative]=\"negative\">\n  <nx-expansion-panel *ngFor=\"let tab of tabs; let i = index\"\n                      [expanded]=\"selectedIndex === i\"\n                      (opened)=\"_panelOpened(i)\"\n                      [disabled]=\"tab.disabled\"\n  >\n    <nx-expansion-panel-header>\n      <nx-expansion-panel-title>\n        <nx-tab-header-outlet *ngIf=\"tab.templateLabel\" [content]=\"tab.headerViewRef\"></nx-tab-header-outlet>\n        <ng-container *ngIf=\"!tab.templateLabel\">{{tab.label}}</ng-container>\n      </nx-expansion-panel-title>\n    </nx-expansion-panel-header>\n    <!-- this is not lazy loading this is a trick because the portal gets added here -->\n    <!-- so we could rewrite the tab-body component that it takes care of \"lazy loading\" and the\n    accordion wouldn't know about it -->\n    <!-- active=true is a trick because we want to keep the content attached for better user experience along with expansion panel animation.  -->\n    <nx-tab-body [active]=\"true\" [tab]=\"tab\"></nx-tab-body>\n  </nx-expansion-panel>\n</nx-accordion>\n",
                changeDetection: ChangeDetectionStrategy.OnPush,
                host: {
                    '[class.is-negative]': 'negative',
                    '[class.is-disabled]': 'disabled'
                },
                providers: [{ provide: NxTabGroupBase, useExisting: NxTabGroupComponent }],
                styles: [":host{display:block}.nx-tab-header__item{font-size:18px;font-size:var(--tab-item-font-size,18px);line-height:24px;line-height:var(--tab-item-line-height,24px);font-weight:400;font-weight:var(--tab-item-font-weight,400);letter-spacing:.2px;letter-spacing:var(--tab-item-letter-spacing,.2px);text-decoration:none;border:#006192;background:0 0;color:#006192;color:var(--tab-item-color,#006192);border-color:var(--tab-item-border-color,#006192);border-bottom-width:2px;border-bottom-style:solid;padding:0 16px 6px;outline:0;margin:0}.nx-tab-header__item:hover:not(.nx-tab-header__item--disabled){cursor:pointer}.nx-tab-header__item::-moz-focus-inner{border:0}.nx-tab-header__item--active{border-width:4px;font-weight:700;transition:font-weight .3s;padding-bottom:4px}@media screen and (-ms-high-contrast:active){.nx-tab-header__item{background-color:buttonFace;border-color:buttonText;color:buttonText;-ms-high-contrast-adjust:none}.nx-tab-header__item--active{background-color:highlight;color:highlightText;border-color:highlight}}.nx-tab-header__item--disabled{border-color:#c2c2c2;border-color:var(--tab-item-disabled-border-color,#c2c2c2);color:#c2c2c2;color:var(--tab-item-disabled-color,#c2c2c2);cursor:not-allowed}.nx-tab-label__content{display:inline-flex;justify-content:center;align-items:center;white-space:nowrap}:host-context([data-whatinput=keyboard]) .nx-tab-header__item:focus{box-shadow:0 0 0 2px #fff,0 0 0 6px #009de6;box-shadow:var(--focus-box-shadow,0 0 0 2px #fff,0 0 0 6px #009de6);border-radius:4px}@media screen and (-ms-high-contrast:active){.nx-tab-header__item--disabled{border-color:GrayText;background-color:buttonFace;color:GrayText}:host-context([data-whatinput=keyboard]) .nx-tab-header__item:focus{box-shadow:0 0 0 2px background,0 0 0 6px windowText}}:host(.is-negative){color:#fff}:host(.is-negative) .nx-tab-header__item{color:#fff;border-bottom-color:#fff}:host(.is-negative) .nx-tab-header__item.nx-tab-header__item--disabled{border-color:rgba(255,255,255,.4);border-color:var(--tab-item-disabled-border-color,#c2c2c2);color:var(--tab-item-disabled-color,#c2c2c2);cursor:not-allowed;color:rgba(255,255,255,.4);color:var(--tab-item-disabled-negative-color,rgba(255,255,255,.4));border-color:var(--tab-item-disabled-negative-color,rgba(255,255,255,.4))}@media screen and (-ms-high-contrast:active){:host(.is-negative) .nx-tab-header__item.nx-tab-header__item--disabled{border-color:GrayText;background-color:buttonFace;color:GrayText}}:host(.is-disabled){cursor:not-allowed}:host(.is-disabled.is-negative) .nx-tab-header__item{border-color:rgba(255,255,255,.4);border-color:var(--tab-item-disabled-border-color,#c2c2c2);color:var(--tab-item-disabled-color,#c2c2c2);cursor:not-allowed;color:rgba(255,255,255,.4);color:var(--tab-item-disabled-negative-color,rgba(255,255,255,.4));border-color:var(--tab-item-disabled-negative-color,rgba(255,255,255,.4))}@media screen and (-ms-high-contrast:active){:host(.is-disabled.is-negative) .nx-tab-header__item{border-color:GrayText;background-color:buttonFace}:host(.is-negative){color:buttonText}:host(.is-negative) .nx-tab-header__item{color:buttonText;border-bottom-color:buttonText}:host(.is-negative) .nx-tab-header__item--active{background-color:highlight;color:highlightText;border-color:highlight;-ms-high-contrast-adjust:none}:host(.is-disabled.is-negative) .nx-tab-header__item{color:GrayText;border-bottom-color:GrayText}}"]
            }] }
];
/** @nocollapse */
NxTabGroupComponent.ctorParameters = () => [
    { type: ChangeDetectorRef }
];
NxTabGroupComponent.propDecorators = {
    tabs: [{ type: ContentChildren, args: [NxTabComponent,] }],
    tabBodyChildren: [{ type: ViewChildren, args: [NxTabBodyComponent,] }],
    tabHeader: [{ type: ViewChild, args: ['tabHeader', { static: false },] }],
    panels: [{ type: ViewChildren, args: [NxExpansionPanelComponent,] }],
    accordion: [{ type: ViewChild, args: [NxAccordionDirective, { static: false },] }],
    selectedIndex: [{ type: Input }],
    negative: [{ type: Input }],
    disabled: [{ type: Input }],
    autoselect: [{ type: Input }],
    mobileAccordion: [{ type: Input }],
    selectedIndexChange: [{ type: Output }],
    selectedTabChange: [{ type: Output }],
    focusChange: [{ type: Output }],
    onResize: [{ type: HostListener, args: ['window:resize', ['$event'],] }]
};
if (false) {
    /**
     * @type {?}
     * @private
     */
    NxTabGroupComponent.prototype._selectedIndex;
    /**
     * @type {?}
     * @private
     */
    NxTabGroupComponent.prototype._groupId;
    /**
     * @type {?}
     * @private
     */
    NxTabGroupComponent.prototype._negative;
    /**
     * @type {?}
     * @private
     */
    NxTabGroupComponent.prototype._disabled;
    /**
     * @type {?}
     * @private
     */
    NxTabGroupComponent.prototype._indexToSelect;
    /**
     * @type {?}
     * @private
     */
    NxTabGroupComponent.prototype._autoselect;
    /**
     * @type {?}
     * @private
     */
    NxTabGroupComponent.prototype._mobileAccordion;
    /** @type {?} */
    NxTabGroupComponent.prototype._showAccordion;
    /**
     * \@docs-private
     * @type {?}
     */
    NxTabGroupComponent.prototype.tabs;
    /**
     * \@docs-private
     * @type {?}
     */
    NxTabGroupComponent.prototype.tabBodyChildren;
    /**
     * \@docs-private
     * @type {?}
     */
    NxTabGroupComponent.prototype.tabHeader;
    /**
     * \@docs-private
     * @type {?}
     */
    NxTabGroupComponent.prototype.panels;
    /**
     * \@docs-private
     * @type {?}
     */
    NxTabGroupComponent.prototype.accordion;
    /**
     * An event emitted when the selected tab has changed.
     * @type {?}
     */
    NxTabGroupComponent.prototype.selectedIndexChange;
    /**
     * An event emitted when the selected tab has changed.
     * @type {?}
     */
    NxTabGroupComponent.prototype.selectedTabChange;
    /**
     * An event emitted when focus has changed within a tab group.
     *
     * **Note:** is not supported in mobile view.
     * @type {?}
     */
    NxTabGroupComponent.prototype.focusChange;
    /**
     * Subscription to tabs being added/removed.
     * @type {?}
     * @private
     */
    NxTabGroupComponent.prototype._tabsSubscription;
    /**
     * Subscription to changes in the tab labels.
     * @type {?}
     * @private
     */
    NxTabGroupComponent.prototype._tabLabelSubscription;
    /**
     * @type {?}
     * @private
     */
    NxTabGroupComponent.prototype._disabledTabsCache;
    /** @type {?} */
    NxTabGroupComponent.prototype._appearanceChange;
    /**
     * @type {?}
     * @private
     */
    NxTabGroupComponent.prototype._changeDetectorRef;
}

/**
 * @fileoverview added by tsickle
 * Generated from: tab-nav-bar.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class NxTabNavBarComponent {
    /**
     * @param {?} _changeDetectorRef
     */
    constructor(_changeDetectorRef) {
        this._changeDetectorRef = _changeDetectorRef;
        this._negative = false;
        this._disabled = false;
    }
    /**
     * Whether the tab nav bar has negative styling.
     * @param {?} value
     * @return {?}
     */
    set negative(value) {
        /** @type {?} */
        const newValue = coerceBooleanProperty(value);
        if (newValue !== this.negative) {
            this._negative = newValue;
            this._changeDetectorRef.markForCheck();
        }
    }
    /**
     * @return {?}
     */
    get negative() {
        return this._negative;
    }
    /**
     * Whether the tab nav bar has disabled styling.
     * @param {?} value
     * @return {?}
     */
    set disabled(value) {
        /** @type {?} */
        const newValue = coerceBooleanProperty(value);
        if (newValue !== this.disabled) {
            this._disabled = newValue;
            this._changeDetectorRef.markForCheck();
        }
    }
    /**
     * @return {?}
     */
    get disabled() {
        return this._disabled;
    }
}
NxTabNavBarComponent.decorators = [
    { type: Component, args: [{
                selector: 'nx-tab-nav-bar',
                template: "<ng-content></ng-content>",
                changeDetection: ChangeDetectionStrategy.OnPush,
                host: {
                    '[class.is-negative]': 'negative',
                    '[class.is-disabled]': 'disabled',
                    'role': 'navigation',
                },
                styles: [":host{display:flex;align-items:flex-end;justify-content:center}:host ::ng-deep a.nx-tab-link{font-size:18px;font-size:var(--tab-item-font-size,18px);line-height:24px;line-height:var(--tab-item-line-height,24px);font-weight:400;font-weight:var(--tab-item-font-weight,400);letter-spacing:.2px;letter-spacing:var(--tab-item-letter-spacing,.2px);text-decoration:none;border:#006192;background:0 0;color:#006192;color:var(--tab-item-color,#006192);border-color:var(--tab-item-border-color,#006192);border-bottom-width:2px;border-bottom-style:solid;padding:0 16px 6px;outline:0;margin:0}:host ::ng-deep a.nx-tab-link.is-active{border-width:4px;font-weight:700;transition:font-weight .3s;padding-bottom:4px}@media screen and (-ms-high-contrast:active){:host ::ng-deep a.nx-tab-link{background-color:buttonFace;border-color:buttonText;color:buttonText;-ms-high-contrast-adjust:none}:host ::ng-deep a.nx-tab-link.is-active{background-color:highlight;color:highlightText;border-color:highlight}}:host(.is-negative){color:#fff}:host(.is-negative) ::ng-deep a.nx-tab-link{color:#fff;border-bottom-color:#fff}:host(.is-negative) ::ng-deep a.nx-tab-link.is-disabled{color:rgba(255,255,255,.4);color:var(--tab-item-disabled-negative-color,rgba(255,255,255,.4));border-color:rgba(255,255,255,.4);border-color:var(--tab-item-disabled-negative-color,rgba(255,255,255,.4))}:host ::ng-deep a.nx-tab-link.is-disabled{border-color:#c2c2c2;border-color:var(--tab-item-disabled-border-color,#c2c2c2);color:#c2c2c2;color:var(--tab-item-disabled-color,#c2c2c2);cursor:not-allowed}@media screen and (-ms-high-contrast:active){:host(.is-negative) ::ng-deep a.nx-tab-link.is-active{background-color:highlight;color:highlightText;border-color:windowFrame}:host ::ng-deep a.nx-tab-link.is-disabled{border-color:GrayText;background-color:buttonFace;color:GrayText}}:host(.is-disabled){cursor:not-allowed}:host(.is-disabled.is-negative) ::ng-deep a.nx-tab-link{color:rgba(255,255,255,.4);color:var(--tab-item-disabled-negative-color,rgba(255,255,255,.4));border-color:rgba(255,255,255,.4);border-color:var(--tab-item-disabled-negative-color,rgba(255,255,255,.4))}:host-context([data-whatinput=keyboard]) ::ng-deep .nx-tab-link:not(.is-disabled):focus{box-shadow:0 0 0 2px #fff,0 0 0 6px #009de6;box-shadow:var(--focus-box-shadow,0 0 0 2px #fff,0 0 0 6px #009de6);border-radius:4px}@media screen and (-ms-high-contrast:active){:host-context([data-whatinput=keyboard]) ::ng-deep .nx-tab-link:not(.is-disabled):focus{box-shadow:0 0 0 2px background,0 0 0 6px windowText}:host(.is-negative){color:buttonText}:host(.is-negative) ::ng-deep a.nx-tab-link{color:buttonText;border-bottom-color:buttonText}:host(.is-negative) ::ng-deep a.nx-tab-link.is-active{background-color:highlight;color:highlightText;border-color:highlight}:host(.is-negative) ::ng-deep a.nx-tab-link.is-disabled{color:GrayText;border-bottom-color:GrayText}}"]
            }] }
];
/** @nocollapse */
NxTabNavBarComponent.ctorParameters = () => [
    { type: ChangeDetectorRef }
];
NxTabNavBarComponent.propDecorators = {
    negative: [{ type: Input }],
    disabled: [{ type: Input }]
};
if (false) {
    /**
     * @type {?}
     * @private
     */
    NxTabNavBarComponent.prototype._negative;
    /**
     * @type {?}
     * @private
     */
    NxTabNavBarComponent.prototype._disabled;
    /**
     * @type {?}
     * @private
     */
    NxTabNavBarComponent.prototype._changeDetectorRef;
}
class NxTabLinkDirective {
    /**
     * @param {?} _tabNavBar
     */
    constructor(_tabNavBar) {
        this._tabNavBar = _tabNavBar;
        this._active = false;
        this._disabled = false;
        if (!this._tabNavBar) {
            throw Error(`The nx-tab-link element has to be wrapped in a nx-tab-nav-bar to work.`);
        }
    }
    /**
     * Whether the tab link is active and has the active styling.
     * @return {?}
     */
    get active() {
        return this._active;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set active(value) {
        /** @type {?} */
        const newValue = coerceBooleanProperty(value);
        if (newValue !== this._active) {
            this._active = value;
        }
    }
    /**
     * Whether the tab link is disabled. Default: false.
     * @return {?}
     */
    get disabled() {
        return (this._tabNavBar && this._tabNavBar.disabled) ? this._tabNavBar.disabled : this._disabled;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set disabled(value) {
        /** @type {?} */
        const newValue = coerceBooleanProperty(value);
        if (newValue !== this._disabled) {
            this._disabled = value;
        }
    }
    /**
     * @return {?}
     */
    _getTabIndex() {
        return (this.disabled) ? '-1' : '0';
    }
}
NxTabLinkDirective.decorators = [
    { type: Directive, args: [{
                selector: '[nxTabLink]',
                host: {
                    '[class.nx-tab-link]': 'true',
                    '[class.is-active]': 'active',
                    '[class.is-disabled]': 'disabled',
                    '[attr.aria-current]': 'active',
                    '[attr.tabindex]': '_getTabIndex()',
                    '[attr.aria-disabled]': 'disabled.toString()',
                }
            },] }
];
/** @nocollapse */
NxTabLinkDirective.ctorParameters = () => [
    { type: NxTabNavBarComponent, decorators: [{ type: Optional }, { type: SkipSelf }] }
];
NxTabLinkDirective.propDecorators = {
    active: [{ type: Input }],
    disabled: [{ type: Input }]
};
if (false) {
    /**
     * @type {?}
     * @private
     */
    NxTabLinkDirective.prototype._active;
    /**
     * @type {?}
     * @private
     */
    NxTabLinkDirective.prototype._disabled;
    /**
     * @type {?}
     * @private
     */
    NxTabLinkDirective.prototype._tabNavBar;
}

/**
 * @fileoverview added by tsickle
 * Generated from: tabs.module.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class NxTabsModule {
}
NxTabsModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    CommonModule,
                    PortalModule,
                    NxAccordionModule
                ],
                exports: [
                    NxTabComponent,
                    NxTabGroupComponent,
                    NxTabLabelDirective,
                    NxTabLabelWrapperDirective,
                    NxTabHeaderComponent,
                    NxTabBodyComponent,
                    NxTabNavBarComponent,
                    NxTabLinkDirective,
                    NxTabContentDirective
                ],
                declarations: [
                    NxTabComponent,
                    NxTabGroupComponent,
                    NxTabLabelDirective,
                    NxTabLabelWrapperDirective,
                    NxTabHeaderComponent,
                    NxTabBodyComponent,
                    NxTabNavBarComponent,
                    NxTabLinkDirective,
                    NxTabContentDirective,
                    NxTabHeaderOutletComponent
                ],
                providers: [],
            },] }
];

/**
 * @fileoverview added by tsickle
 * Generated from: public-api.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * Generated from: allianz-ngx-ndbx-tabs.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

export { NxTabBodyComponent, NxTabChangeEvent, NxTabComponent, NxTabContentDirective, NxTabGroupComponent, NxTabHeaderComponent, NxTabLabelDirective, NxTabLinkDirective, NxTabNavBarComponent, NxTabsModule, NxTabGroupBase as a, NxTabLabelWrapperDirective as b, NxTabHeaderOutletComponent as c };
//# sourceMappingURL=allianz-ngx-ndbx-tabs.js.map
