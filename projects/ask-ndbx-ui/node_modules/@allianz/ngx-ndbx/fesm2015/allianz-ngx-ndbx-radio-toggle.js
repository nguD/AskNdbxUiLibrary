import { Input, ViewChild, QueryList, Component, ChangeDetectionStrategy, Renderer2, ChangeDetectorRef, Optional, Self, ContentChildren, forwardRef, Inject, HostListener, NgModule } from '@angular/core';
import { CommonModule } from '@angular/common';
import { coerceBooleanProperty } from '@angular/cdk/coercion';
import { removeClasses, mapClassNames, ErrorStateMatcher } from '@allianz/ngx-ndbx/utils';
import { NgControl, NgForm, FormGroupDirective, FormsModule } from '@angular/forms';
import { Subject, merge } from 'rxjs';
import { takeUntil, startWith, filter } from 'rxjs/operators';
import { UniqueSelectionDispatcher } from '@angular/cdk/collections';
import { NxIconModule } from '@allianz/ngx-ndbx/icon';

/**
 * @fileoverview added by tsickle
 * Generated from: radio-toggle-button-base.component.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
let nextId = 0;
/**
 * \@docs-private
 */
class NxRadioToggleButtonBaseComponent {
    /**
     * @param {?} renderer
     */
    constructor(renderer) {
        this.renderer = renderer;
        /**
         * \@docs-private
         */
        this.toggleButtonId = 'nx-radio-toggle-button-' + nextId++;
    }
    /**
     * \@docs-private
     * @param {?} event
     * @return {?}
     */
    triggerInputClick(event) {
        event.stopPropagation();
        this.toggleInput.nativeElement.click();
    }
    /**
     * \@docs-private
     * @return {?}
     */
    setFirstButton() {
        this.renderer.addClass(this.labelContainer.nativeElement, 'nx-radio-toggle__label-container--first');
    }
    /**
     * \@docs-private
     * @return {?}
     */
    setLastButton() {
        this.renderer.addClass(this.labelContainer.nativeElement, 'nx-radio-toggle__label-container--last');
    }
    /**
     * \@docs-private
     * @return {?}
     */
    resetClasses() {
        removeClasses(this.renderer, this.labelContainer, 'nx-radio-toggle__label-container--first nx-radio-toggle__label-container--last');
    }
}
NxRadioToggleButtonBaseComponent.propDecorators = {
    value: [{ type: Input, args: ['nxValue',] }],
    labelContainer: [{ type: ViewChild, args: ['toggleButtonLabelContainer', { static: true },] }],
    toggleInput: [{ type: ViewChild, args: ['toggleInput', { static: true },] }]
};
if (false) {
    /**
     * \@docs-private
     * @type {?}
     */
    NxRadioToggleButtonBaseComponent.prototype.toggleButtonId;
    /**
     * \@docs-private
     * @type {?}
     */
    NxRadioToggleButtonBaseComponent.prototype.value;
    /**
     * \@docs-private
     * @type {?}
     */
    NxRadioToggleButtonBaseComponent.prototype.labelContainer;
    /**
     * \@docs-private
     * @type {?}
     */
    NxRadioToggleButtonBaseComponent.prototype.toggleInput;
    /**
     * \@docs-private
     * @type {?}
     * @protected
     */
    NxRadioToggleButtonBaseComponent.prototype.renderer;
}

/**
 * @fileoverview added by tsickle
 * Generated from: radio-toggle.component.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
let nextId$1 = 0;
/** @type {?} */
const MAPPING = {
    'negative': 'nx-radio-toggle--negative',
    'small': 'nx-radio-toggle--small',
};
class NxRadioToggleComponent {
    /**
     * @param {?} renderer
     * @param {?} _changeDetectorRef
     * @param {?} ngControl
     * @param {?} _errorStateMatcher
     * @param {?} _parentForm
     * @param {?} _parentFormGroup
     */
    constructor(renderer, _changeDetectorRef, ngControl, _errorStateMatcher, _parentForm, _parentFormGroup) {
        this.renderer = renderer;
        this._changeDetectorRef = _changeDetectorRef;
        this.ngControl = ngControl;
        this._errorStateMatcher = _errorStateMatcher;
        this._parentForm = _parentForm;
        this._parentFormGroup = _parentFormGroup;
        this._toggleId = (nextId$1++).toString();
        this._destroyed = new Subject();
        this._disabled = false;
        /**
         * \@docs-private
         */
        this.errorState = false;
        // emits to signal children to run change detection
        this._disableChange = new Subject();
        /**
         * \@docs-private
         */
        this.toggleButtons = new QueryList();
        this.onTouchedCallback = (/**
         * @return {?}
         */
        () => { });
        this.onChangeCallback = (/**
         * @param {?} option
         * @return {?}
         */
        (option) => { });
        if (this.ngControl) {
            // Note: we provide the value accessor through here, instead of
            // the `providers` to avoid running into a circular import.
            this.ngControl.valueAccessor = this;
        }
    }
    /**
     * Sets the component to the disabled state.
     * @param {?} value
     * @return {?}
     */
    set disabled(value) {
        /** @type {?} */
        const coerced = coerceBooleanProperty(value);
        if (this._disabled !== coerced) {
            this._disabled = coerced;
            this._disableChange.next();
        }
    }
    /**
     * @return {?}
     */
    get disabled() {
        return this._disabled;
    }
    /**
     * Sets the name used for accessibility.
     * @param {?} value
     * @return {?}
     */
    set name(value) {
        if (this._name !== value) {
            this._name = value;
            this._changeDetectorRef.markForCheck();
        }
    }
    /**
     * @return {?}
     */
    get name() {
        return this._name;
    }
    /**
     * @return {?}
     */
    ngAfterViewInit() {
        this.subscribeToToggleButtonsChange();
    }
    /**
     * @return {?}
     */
    ngAfterContentInit() {
        /** @type {?} */
        const changedOrDestroyed = merge(this.toggleButtons.changes, this._destroyed);
        merge(...this.toggleButtons.map((/**
         * @param {?} button
         * @return {?}
         */
        (button) => button.onChecked)))
            .pipe(takeUntil(changedOrDestroyed))
            .subscribe((/**
         * @param {?} change
         * @return {?}
         */
        (change) => {
            this._selection = change.value;
            this.onChangeCallback(this._selection);
        }));
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this._destroyed.next();
        this._destroyed.complete();
        this._disableChange.complete();
    }
    /**
     * @return {?}
     */
    ngDoCheck() {
        if (this.ngControl) {
            // We need to re-evaluate this on every change detection cycle, because there are some
            // error triggers that we can't subscribe to (e.g. parent form submissions). This means
            // that whatever logic is in here has to be super lean or we risk destroying the performance.
            this.updateErrorState();
        }
    }
    /**
     * \@docs-private
     * @return {?}
     */
    subscribeToToggleButtonsChange() {
        this.toggleButtons.changes
            .pipe(startWith(this.toggleButtons), filter((/**
         * @param {?} toggles
         * @return {?}
         */
        toggles => toggles.length > 0)), takeUntil(this._destroyed)).subscribe((/**
         * @param {?} toggles
         * @return {?}
         */
        (toggles) => {
            toggles.forEach((/**
             * @param {?} toggle
             * @return {?}
             */
            toggle => {
                toggle.resetClasses();
                if (toggle.value === this.selection) {
                    // We need to defer the selection for the edge case that the button with the value of this.selection
                    // didn't exist yet but was added afterwards to prevent changed after checked errors
                    setTimeout((/**
                     * @return {?}
                     */
                    () => toggle.select()));
                }
            }));
            toggles.first.setFirstButton();
            toggles.last.setLastButton();
        }));
    }
    /**
     * @param {?} onChangeCallback
     * @return {?}
     */
    registerOnChange(onChangeCallback) {
        this.onChangeCallback = onChangeCallback;
    }
    /**
     * @param {?} onTouchedCallback
     * @return {?}
     */
    registerOnTouched(onTouchedCallback) {
        this.onTouchedCallback = onTouchedCallback;
    }
    /**
     * Preselects the respective options.
     * @param {?} value
     * @return {?}
     */
    writeValue(value) {
        this._selection = value;
        /** @type {?} */
        const correspondingButton = this.toggleButtons.find((/**
         * @param {?} button
         * @return {?}
         */
        (button) => button.value === this._selection));
        if (correspondingButton) {
            ((/** @type {?} */ (correspondingButton))).select();
        }
    }
    /**
     * @param {?} isDisabled
     * @return {?}
     */
    setDisabledState(isDisabled) {
        this.disabled = isDisabled;
    }
    /**
     * \@docs-private
     * @return {?}
     */
    get id() {
        return `nx-radio-toggle-${this._toggleId}`;
    }
    /**
     * Sets the modifiers for the component.
     * @param {?} value
     * @return {?}
     */
    set style(value) {
        /** @type {?} */
        const modifierClasses = mapClassNames(value, [], MAPPING);
        modifierClasses.split(' ')
            .forEach((/**
         * @param {?} className
         * @return {?}
         */
        className => this.renderer.addClass(this.toggleContainer.nativeElement, className)));
    }
    /**
     * \@docs-private
     * @param {?} selection
     * @return {?}
     */
    set selection(selection) {
        this._selection = selection;
        this.onChangeCallback(selection);
    }
    /**
     * @return {?}
     */
    get selection() {
        return this._selection;
    }
    /**
     * \@docs-private
     * @param {?} value
     * @return {?}
     */
    change(value) {
        this.onChangeCallback(value);
        if (this.onTouchedCallback) {
            this.onTouchedCallback();
        }
    }
    /**
     * \@docs-private
     * @return {?}
     */
    updateErrorState() {
        /** @type {?} */
        const oldState = this.errorState;
        /** @type {?} */
        const parent = this._parentFormGroup || this._parentForm;
        /** @type {?} */
        const control = this.ngControl ? (/** @type {?} */ (this.ngControl.control)) : null;
        /** @type {?} */
        const newState = this._errorStateMatcher.isErrorState(control, parent);
        if (newState !== oldState) {
            this.errorState = newState;
        }
    }
}
NxRadioToggleComponent.decorators = [
    { type: Component, args: [{
                selector: 'nx-radio-toggle',
                template: "<div #toggleContainer class=\"nx-radio-toggle\" role=\"radiogroup\" [attr.aria-label]=\"name\">\n   <ng-content></ng-content>\n</div>\n",
                changeDetection: ChangeDetectionStrategy.OnPush,
                styles: [":host{display:block}.nx-radio-toggle{display:flex;height:100%}@media (max-width:703px){.nx-radio-toggle{flex-direction:column;text-align:center;width:100%;justify-content:center;align-items:center}}"]
            }] }
];
/** @nocollapse */
NxRadioToggleComponent.ctorParameters = () => [
    { type: Renderer2 },
    { type: ChangeDetectorRef },
    { type: NgControl, decorators: [{ type: Optional }, { type: Self }] },
    { type: ErrorStateMatcher },
    { type: NgForm, decorators: [{ type: Optional }] },
    { type: FormGroupDirective, decorators: [{ type: Optional }] }
];
NxRadioToggleComponent.propDecorators = {
    disabled: [{ type: Input, args: ['nxDisabled',] }],
    toggleContainer: [{ type: ViewChild, args: ['toggleContainer', { static: true },] }],
    name: [{ type: Input, args: ['nxName',] }],
    toggleButtons: [{ type: ContentChildren, args: [NxRadioToggleButtonBaseComponent,] }],
    writeValue: [{ type: Input, args: ['nxSelection',] }],
    style: [{ type: Input, args: ['nxStyle',] }]
};
if (false) {
    /**
     * @type {?}
     * @private
     */
    NxRadioToggleComponent.prototype._toggleId;
    /**
     * @type {?}
     * @private
     */
    NxRadioToggleComponent.prototype._selection;
    /**
     * @type {?}
     * @private
     */
    NxRadioToggleComponent.prototype._destroyed;
    /**
     * @type {?}
     * @private
     */
    NxRadioToggleComponent.prototype._disabled;
    /**
     * \@docs-private
     * @type {?}
     */
    NxRadioToggleComponent.prototype.errorState;
    /** @type {?} */
    NxRadioToggleComponent.prototype._disableChange;
    /**
     * @type {?}
     * @private
     */
    NxRadioToggleComponent.prototype.toggleContainer;
    /**
     * @type {?}
     * @private
     */
    NxRadioToggleComponent.prototype._name;
    /**
     * \@docs-private
     * @type {?}
     */
    NxRadioToggleComponent.prototype.toggleButtons;
    /**
     * @type {?}
     * @private
     */
    NxRadioToggleComponent.prototype.onTouchedCallback;
    /**
     * @type {?}
     * @private
     */
    NxRadioToggleComponent.prototype.onChangeCallback;
    /**
     * @type {?}
     * @private
     */
    NxRadioToggleComponent.prototype.renderer;
    /**
     * @type {?}
     * @private
     */
    NxRadioToggleComponent.prototype._changeDetectorRef;
    /**
     * \@docs-private
     * @type {?}
     */
    NxRadioToggleComponent.prototype.ngControl;
    /**
     * @type {?}
     * @private
     */
    NxRadioToggleComponent.prototype._errorStateMatcher;
    /**
     * @type {?}
     * @private
     */
    NxRadioToggleComponent.prototype._parentForm;
    /**
     * @type {?}
     * @private
     */
    NxRadioToggleComponent.prototype._parentFormGroup;
}

/**
 * @fileoverview added by tsickle
 * Generated from: radio-toggle-button.component.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * \@docs-private
 */
class NxRadioToggleButtonChange {
    /**
     * @param {?} source
     * @param {?} value
     */
    constructor(source, value) {
        this.source = source;
        this.value = value;
    }
}
if (false) {
    /** @type {?} */
    NxRadioToggleButtonChange.prototype.source;
    /** @type {?} */
    NxRadioToggleButtonChange.prototype.value;
}
class NxRadioToggleButtonComponent extends NxRadioToggleButtonBaseComponent {
    /**
     * @param {?} radioToggle
     * @param {?} renderer
     * @param {?} _changeDetectorRef
     * @param {?} _toggleDispatcher
     */
    constructor(radioToggle, 
    /** @docs-private */
    renderer, _changeDetectorRef, _toggleDispatcher) {
        super(renderer);
        this.radioToggle = radioToggle;
        this._changeDetectorRef = _changeDetectorRef;
        this._toggleDispatcher = _toggleDispatcher;
        /**
         * \@docs-private
         */
        // emits when the button is checked to notify the group
        this.onChecked = new Subject();
        this._destroyed = new Subject();
        this._disabled = false;
        this._selected = false;
        /**
         * Unregister function for _expansionDispatcher.
         */
        this._removeUniqueSelectionListener = (/**
         * @return {?}
         */
        () => { });
        this._removeUniqueSelectionListener = this._toggleDispatcher.listen((/**
         * @param {?} id
         * @param {?} radioToggleId
         * @return {?}
         */
        (id, radioToggleId) => {
            if (this.radioToggle && this.radioToggle.id === radioToggleId && this.id !== id) {
                this._selected = false;
                // need to let change detector know in case that the select() function was called on another button
                this._changeDetectorRef.markForCheck();
            }
        }));
        this.radioToggle._disableChange.pipe(takeUntil(this._destroyed)).subscribe((/**
         * @return {?}
         */
        () => {
            this._changeDetectorRef.markForCheck();
        }));
    }
    /**
     * \@docs-private
     * @param {?} value
     * @return {?}
     */
    set disabled(value) {
        this._disabled = coerceBooleanProperty(value);
        this._changeDetectorRef.markForCheck();
    }
    /**
     * @return {?}
     */
    get disabled() {
        return this._disabled || (this.radioToggle && this.radioToggle.disabled);
    }
    /**
     * Sets the checked state and notify siblings and the parent group about the change
     * @param {?} value
     * @return {?}
     */
    // Only use this if you want the onChecked event to be fired, this will inform the parent about the change!
    // To select a button without firing the event use the select() function
    set selected(value) {
        if (this._selected !== value) {
            this._selected = value;
            if (this._selected) {
                this._notifySiblings();
                this._emitCheckedEvent();
                if (this.radioToggle !== null) {
                    this.radioToggle.change(this.value);
                }
            }
            this._changeDetectorRef.markForCheck();
        }
    }
    /**
     * @return {?}
     */
    get selected() {
        return this._selected;
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this._removeUniqueSelectionListener();
        this._destroyed.next();
        this._destroyed.complete();
    }
    /**
     * \@docs-private
     * @return {?}
     */
    get toggleId() {
        return this.radioToggle.id;
    }
    /**
     * \@docs-private
     * @return {?}
     */
    get id() {
        return this.toggleButtonId;
    }
    /**
     * @private
     * @return {?}
     */
    _notifySiblings() {
        /** @type {?} */
        const toggleId = this.radioToggle ? this.radioToggle.id : this.id;
        this._toggleDispatcher.notify(this.id, toggleId);
    }
    /**
     * @private
     * @return {?}
     */
    _emitCheckedEvent() {
        this.onChecked.next(new NxRadioToggleButtonChange(this, this.value));
    }
    // Does NOT emit the onChecked event. Useful when you need to set initial
    // state. Used by the parent to set checked states on initialization and during
    // writeValue() changes.
    /**
     * \@docs-private
     * @return {?}
     */
    select() {
        if (!this._selected) {
            this._selected = true;
            this._notifySiblings();
        }
        this._changeDetectorRef.markForCheck();
    }
    /**
     * \@docs-private
     * @return {?}
     */
    onKeyupSpace() {
        this._selected = false;
        this._notifySiblings();
    }
    /**
     * \@docs-private
     * @return {?}
     */
    _controlInvalid() {
        return !!(this.radioToggle && this.radioToggle.errorState);
    }
}
NxRadioToggleButtonComponent.decorators = [
    { type: Component, args: [{
                selector: 'nx-radio-toggle-button',
                changeDetection: ChangeDetectionStrategy.OnPush,
                template: "<input [attr.id]=\"toggleButtonId\"\n    #toggleInput\n    [attr.name]=\"toggleId\"\n    [checked]=\"selected\"\n    class=\"nx-radio-toggle__input\"\n    type=\"radio\"\n    (click)=\"selected = true\"\n    [disabled]=\"disabled\">\n<div (click)=\"triggerInputClick($event)\" #toggleButtonLabelContainer class=\"nx-radio-toggle__label-container\">\n  <label [attr.for]=\"toggleButtonId\" class=\"nx-radio-toggle__label\">\n      <nx-icon class=\"nx-toggle-button__mobile-check\" name=\"check\" aria-hidden=\"true\"></nx-icon>\n      <ng-content></ng-content>\n  </label>\n</div>\n\n\n",
                providers: [
                    {
                        provide: NxRadioToggleButtonBaseComponent, useExisting: forwardRef((/**
                         * @return {?}
                         */
                        () => NxRadioToggleButtonComponent))
                    }
                ],
                host: {
                    '[class.has-error]': '_controlInvalid() || null',
                    '[attr.aria-invalid]': '_controlInvalid() || null'
                },
                styles: [":host{display:flex;position:relative;flex-direction:row}:host.has-error .nx-radio-toggle__input:checked+.nx-radio-toggle__label-container{border-color:#dc3149;border-color:var(--danger,#dc3149);background-color:#dc3149;background-color:var(--danger,#dc3149)}:host.has-error .nx-radio-toggle__label-container{border-color:#dc3149;border-color:var(--danger,#dc3149);color:#dc3149;color:var(--danger,#dc3149)}:host.has-error:hover .nx-radio-toggle__label-container{color:#fff}.nx-radio-toggle__input{opacity:0;position:absolute}.nx-radio-toggle__input:active+.nx-radio-toggle__label-container{background-color:#003781;background-color:var(--toggle-button-active-background-color,#003781);border-color:#003781;border-color:var(--toggle-button-active-border-color,#003781);color:#fff;color:var(--toggle-button-active-text-color,#fff)}.nx-radio-toggle__input:checked:disabled+.nx-radio-toggle__label-container{background-color:rgba(0,122,179,.4);background-color:var(--toggle-button-disabled-selected-background-color,rgba(0,122,179,.4));border-color:transparent;border-color:var(--toggle-button-disabled-selected-border-color,transparent);color:rgba(255,255,255,.4);color:var(--toggle-button-disabled-selected-text-color,rgba(255,255,255,.4))}.nx-radio-toggle__input:disabled+.nx-radio-toggle__label-container{background-color:#fff;background-color:var(--toggle-button-disabled-background-color,#fff);border-color:rgba(0,122,179,.4);border-color:var(--toggle-button-disabled-border-color,rgba(0,122,179,.4));color:rgba(0,97,146,.4);color:var(--toggle-button-disabled-text-color,rgba(0,97,146,.4));cursor:not-allowed}.nx-radio-toggle__input:disabled+.nx-radio-toggle__label-container .nx-radio-toggle__label{cursor:not-allowed}@media screen and (-ms-high-contrast:active){.nx-radio-toggle__input:disabled+.nx-radio-toggle__label-container{border-color:GrayText;color:GrayText}}.nx-radio-toggle__input:checked+.nx-radio-toggle__label-container{background-color:#007ab3;background-color:var(--toggle-button-selected-background-color,#007ab3);border-color:#007ab3;border-color:var(--toggle-button-selected-border-color,#007ab3);color:#fff;color:var(--toggle-button-selected-text-color,#fff);cursor:default}.nx-radio-toggle__input:checked+.nx-radio-toggle__label-container .nx-radio-toggle__label{cursor:default}.nx-toggle-button__mobile-check{display:none;font-size:24px;margin-right:8px;height:24px}:host-context(.nx-radio-toggle--small) .nx-radio-toggle__label-container{font-size:14px;font-size:var(--toggle-button-small-font-size,14px);line-height:16px;line-height:var(--toggle-button-small-line-height,16px);font-weight:600;font-weight:var(--toggle-button-small-font-weight,600);letter-spacing:1px;letter-spacing:var(--toggle-button-small-letter-spacing,1px);min-height:16px;padding:6px;text-transform:none}.nx-radio-toggle{-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;cursor:pointer}.nx-radio-toggle__label-container.nx-radio-toggle__label-container--first{border-radius:4px 0 0 4px;border-width:2px 0 2px 2px}@media (max-width:703px){:host{width:100%}.nx-radio-toggle__input:checked+.nx-radio-toggle__label-container .nx-toggle-button__mobile-check{display:inline-block}:host-context(.nx-radio-toggle--small) .nx-radio-toggle__label-container{font-size:16px;font-size:var(--toggle-button-large-font-size,16px);line-height:24px;line-height:var(--toggle-button-large-line-height,24px);font-weight:600;font-weight:var(--toggle-button-large-font-weight,600);letter-spacing:1px;letter-spacing:var(--toggle-button-large-letter-spacing,1px);padding:11px 31px}.nx-radio-toggle__label-container.nx-radio-toggle__label-container--first{border-width:2px 2px 1px;border-radius:4px 4px 0 0}}.nx-radio-toggle__label-container.nx-radio-toggle__label-container--last{border-top-right-radius:4px;border-bottom-right-radius:4px;border-width:2px}.nx-radio-toggle__label-container{font-size:16px;font-size:var(--toggle-button-large-font-size,16px);line-height:24px;line-height:var(--toggle-button-large-line-height,24px);font-weight:600;font-weight:var(--toggle-button-large-font-weight,600);letter-spacing:1px;letter-spacing:var(--toggle-button-large-letter-spacing,1px);padding:10px 30px;color:#006192;color:var(--toggle-button-unselected-text-color,#006192);background-color:transparent;background-color:var(--toggle-button-unselected-background-color,transparent);border-color:#007ab3;border-color:var(--toggle-button-unselected-border-color,#007ab3);border-style:solid;border-radius:0;border-width:2px 0 2px 2px;cursor:pointer;flex-grow:1;text-align:center;text-transform:uppercase;text-transform:var(--button-text-transform,uppercase);transition:background-color .2s,border-color .2s,color .2s;display:flex;align-items:center;height:100%;min-height:24px}@media (max-width:703px){.nx-radio-toggle__label-container.nx-radio-toggle__label-container--last{border-width:1px 2px 2px;border-radius:0 0 4px 4px}.nx-radio-toggle__label-container.nx-radio-toggle__label-container--last.nx-radio-toggle__label-container--first{border-radius:4px;border-width:2px}.nx-radio-toggle__label-container{border-width:1px 2px;justify-content:center;padding:11px 31px}}.nx-radio-toggle__label-container:hover{background-color:#006192;background-color:var(--toggle-button-hover-background-color,#006192);border-color:#006192;border-color:var(--toggle-button-hover-border-color,#006192);color:#fff;color:var(--toggle-button-hover-text-color,#fff)}@media screen and (-ms-high-contrast:active){.nx-radio-toggle__input:checked+.nx-radio-toggle__label-container{background-color:highlight;border-color:buttonText}.nx-radio-toggle__input:checked+.nx-radio-toggle__label-container .nx-radio-toggle__label{-ms-high-contrast-adjust:none;color:highlightText}.nx-radio-toggle__label-container{border-color:buttonText;background-color:buttonFace;color:buttonText}.nx-radio-toggle__label-container .nx-radio-toggle__label{-ms-high-contrast-adjust:none}}:host-context(.nx-radio-toggle--negative) .nx-radio-toggle__input:focus+.nx-radio-toggle__label-container{background-color:#d9d9d9;border-color:#d9d9d9;color:#007ab3}:host-context(.nx-radio-toggle--negative) .nx-radio-toggle__input:active+.nx-radio-toggle__label-container{background-color:#c2c2c2;border-color:#c2c2c2;color:#007ab3}:host-context(.nx-radio-toggle--negative) .nx-radio-toggle__input:disabled:checked+.nx-radio-toggle__label-container{background-color:rgba(255,255,255,.4);border-color:transparent;color:rgba(65,65,65,.4)}:host-context(.nx-radio-toggle--negative) .nx-radio-toggle__input:disabled+.nx-radio-toggle__label-container{background-color:transparent;border-color:rgba(255,255,255,.4);color:rgba(255,255,255,.4)}:host-context(.nx-radio-toggle--negative) .nx-radio-toggle__input:checked+.nx-radio-toggle__label-container{background-color:#fff;border-color:#fff;color:#006192}:host-context(.nx-radio-toggle--negative) .nx-radio-toggle__label-container{border-color:#fff;color:#fff}:host-context(.nx-radio-toggle--negative) .nx-radio-toggle__label-container:hover{background-color:#d9d9d9;border-color:#d9d9d9;color:#006192}.nx-radio-toggle__label{display:flex;align-items:center;cursor:pointer}:host-context([data-whatinput=keyboard]) .nx-radio-toggle__input:focus+.nx-radio-toggle__label-container{box-shadow:0 0 0 2px #fff,0 0 0 6px #009de6;box-shadow:var(--focus-box-shadow,0 0 0 2px #fff,0 0 0 6px #009de6);z-index:1}@media screen and (-ms-high-contrast:active){:host-context([data-whatinput=keyboard]) .nx-radio-toggle__input:focus+.nx-radio-toggle__label-container{box-shadow:0 0 0 2px background,0 0 0 6px windowText}}"]
            }] }
];
/** @nocollapse */
NxRadioToggleButtonComponent.ctorParameters = () => [
    { type: NxRadioToggleComponent, decorators: [{ type: Inject, args: [forwardRef((/**
                     * @return {?}
                     */
                    () => NxRadioToggleComponent)),] }] },
    { type: Renderer2 },
    { type: ChangeDetectorRef },
    { type: UniqueSelectionDispatcher }
];
NxRadioToggleButtonComponent.propDecorators = {
    disabled: [{ type: Input, args: ['nxDisabled',] }],
    selected: [{ type: Input, args: ['nxSelected',] }],
    onKeyupSpace: [{ type: HostListener, args: ['keyup.space',] }]
};
if (false) {
    /**
     * \@docs-private
     * @type {?}
     */
    NxRadioToggleButtonComponent.prototype.onChecked;
    /**
     * @type {?}
     * @private
     */
    NxRadioToggleButtonComponent.prototype._destroyed;
    /**
     * @type {?}
     * @private
     */
    NxRadioToggleButtonComponent.prototype._disabled;
    /**
     * @type {?}
     * @private
     */
    NxRadioToggleButtonComponent.prototype._selected;
    /**
     * Unregister function for _expansionDispatcher.
     * @type {?}
     * @private
     */
    NxRadioToggleButtonComponent.prototype._removeUniqueSelectionListener;
    /**
     * @type {?}
     * @private
     */
    NxRadioToggleButtonComponent.prototype.radioToggle;
    /**
     * @type {?}
     * @private
     */
    NxRadioToggleButtonComponent.prototype._changeDetectorRef;
    /**
     * @type {?}
     * @private
     */
    NxRadioToggleButtonComponent.prototype._toggleDispatcher;
}

/**
 * @fileoverview added by tsickle
 * Generated from: radio-toggle.module.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class NxRadioToggleModule {
}
NxRadioToggleModule.decorators = [
    { type: NgModule, args: [{
                declarations: [NxRadioToggleComponent, NxRadioToggleButtonComponent],
                exports: [NxRadioToggleComponent, NxRadioToggleButtonComponent],
                imports: [CommonModule, FormsModule, NxIconModule]
            },] }
];

/**
 * @fileoverview added by tsickle
 * Generated from: public-api.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * Generated from: allianz-ngx-ndbx-radio-toggle.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

export { NxRadioToggleComponent, NxRadioToggleModule, NxRadioToggleButtonBaseComponent as ɵa, NxRadioToggleButtonComponent as ɵb };
//# sourceMappingURL=allianz-ngx-ndbx-radio-toggle.js.map
