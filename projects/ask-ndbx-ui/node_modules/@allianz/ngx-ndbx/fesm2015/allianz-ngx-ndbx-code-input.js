import { CommonModule } from '@angular/common';
import { Injectable, Component, ChangeDetectionStrategy, ChangeDetectorRef, ElementRef, Self, Optional, Input, NgModule } from '@angular/core';
import { NgControl, NgForm, FormGroupDirective, FormsModule, ReactiveFormsModule } from '@angular/forms';
import { Subject } from 'rxjs';
import { ErrorStateMatcher } from '@allianz/ngx-ndbx/utils';
import { UP_ARROW, DOWN_ARROW, RIGHT_ARROW, LEFT_ARROW, BACKSPACE, SPACE } from '@angular/cdk/keycodes';
import { coerceBooleanProperty } from '@angular/cdk/coercion';

/**
 * @fileoverview added by tsickle
 * Generated from: code-input-intl.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class NxCodeInputIntl {
    constructor() {
        /**
         * Stream that emits whenever the labels here are changed. Use this to notify
         * components if the labels have changed after initialization.
         */
        this.changes = new Subject();
        /**
         * Label that should replace the 'Enter key' of the aria-label.
         */
        this.inputFieldAriaLabel = 'Enter Key';
        /**
         * Label that should replace the 'of' of the aria-label.
         */
        this.ofLabel = 'of';
    }
}
NxCodeInputIntl.decorators = [
    { type: Injectable }
];
if (false) {
    /**
     * Stream that emits whenever the labels here are changed. Use this to notify
     * components if the labels have changed after initialization.
     * @type {?}
     */
    NxCodeInputIntl.prototype.changes;
    /**
     * Label that should replace the 'Enter key' of the aria-label.
     * @type {?}
     */
    NxCodeInputIntl.prototype.inputFieldAriaLabel;
    /**
     * Label that should replace the 'of' of the aria-label.
     * @type {?}
     */
    NxCodeInputIntl.prototype.ofLabel;
}

/**
 * @fileoverview added by tsickle
 * Generated from: code-input.component.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const DEFAULT_INPUT_LENGTH = 6;
/** @type {?} */
const TAG_NAME_INPUT = 'INPUT';
/** @type {?} */
const AUTO_UPPERCASE = 'upper';
/** @type {?} */
const AUTO_LOWERCASE = 'lower';
/** @type {?} */
const INPUT_FIELD_GAP = 'nx-code-input--field-with-gap';
class NxCodeInputComponent {
    /**
     * @param {?} _changeDetectorRef
     * @param {?} _el
     * @param {?} _control
     * @param {?} _intl
     * @param {?} _errorStateMatcher
     * @param {?} _parentForm
     * @param {?} _parentFormGroup
     */
    constructor(_changeDetectorRef, _el, _control, _intl, _errorStateMatcher, _parentForm, _parentFormGroup) {
        this._changeDetectorRef = _changeDetectorRef;
        this._el = _el;
        this._control = _control;
        this._intl = _intl;
        this._errorStateMatcher = _errorStateMatcher;
        this._parentForm = _parentForm;
        this._parentFormGroup = _parentFormGroup;
        /**
         * Whether the current input of the component has an error.
         */
        this.errorState = false;
        this._codeLength = DEFAULT_INPUT_LENGTH;
        this._type = 'text';
        this._isUpDown = false;
        this._tabindex = 0;
        /**
         * The user input in array form
         */
        this._keyCode = new Array(DEFAULT_INPUT_LENGTH);
        this._focused = false;
        this._negative = false;
        this._disabled = false;
        /**
         * \@docs-private
         */
        this.propagateChange = (/**
         * @param {?} _
         * @return {?}
         */
        (_) => {
        });
        /**
         * \@docs-private
         */
        this.propagateTouch = (/**
         * @param {?} _
         * @return {?}
         */
        (_) => {
        });
        if (this._control) {
            // Note: we provide the value accessor through here, instead of
            // the `providers` to avoid running into a circular import.
            this._control.valueAccessor = this;
        }
    }
    /**
     * The length of the code input. Default: 6.
     * @param {?} value
     * @return {?}
     */
    set codeLength(value) {
        this._codeLength = value;
        this.setInputLength();
        this._changeDetectorRef.markForCheck();
    }
    /**
     * @return {?}
     */
    get codeLength() {
        return this._codeLength;
    }
    /**
     * The type of HTML input
     * @param {?} value
     * @return {?}
     */
    set type(value) {
        this._type = value;
        this._changeDetectorRef.markForCheck();
    }
    /**
     * @return {?}
     */
    get type() {
        return this._type;
    }
    /**
     * Sets the tabindex of the contained input elements.
     * @param {?} value
     * @return {?}
     */
    set tabindex(value) {
        this._tabindex = value;
        this._changeDetectorRef.markForCheck();
    }
    /**
     * @return {?}
     */
    get tabindex() {
        return this._tabindex;
    }
    /**
     * Whether the form should auto capitalize or lowercase (optional).
     * @param {?} value
     * @return {?}
     */
    set convertTo(value) {
        this._convertTo = value;
        this._changeDetectorRef.markForCheck();
    }
    /**
     * @return {?}
     */
    get convertTo() {
        return this._convertTo;
    }
    /**
     * Whether the code input uses the negative set of styling.
     * @param {?} value
     * @return {?}
     */
    set negative(value) {
        /** @type {?} */
        const newValue = coerceBooleanProperty(value);
        if (this._negative !== newValue) {
            this._negative = newValue;
            this._changeDetectorRef.markForCheck();
        }
    }
    /**
     * @return {?}
     */
    get negative() {
        return this._negative;
    }
    /**
     * Whether the code input is disabled.
     * @param {?} value
     * @return {?}
     */
    set disabled(value) {
        /** @type {?} */
        const newValue = coerceBooleanProperty(value);
        if (this._disabled !== newValue) {
            this._disabled = newValue;
            this._changeDetectorRef.markForCheck();
        }
    }
    /**
     * @return {?}
     */
    get disabled() {
        return this._disabled;
    }
    /**
     * @return {?}
     */
    ngDoCheck() {
        if (this._control) {
            // We need to re-evaluate this on every change detection cycle, because there are some
            // error triggers that we can't subscribe to (e.g. parent form submissions). This means
            // that whatever logic is in here has to be super lean or we risk destroying the performance.
            this.updateErrorState();
        }
    }
    /**
     * Sets the length of the input fields.
     * @return {?}
     */
    setInputLength() {
        if (this.codeLength) {
            this._keyCode = new Array(this.codeLength);
        }
        else {
            this._keyCode = new Array(DEFAULT_INPUT_LENGTH);
        }
    }
    /**
     * Converts to upper or lowercase when enabled.
     * @param {?} value
     * @return {?}
     */
    _convertLetterSize(value) {
        if (value === 'ÃŸ') {
            return value;
        }
        if (typeof value === 'string') {
            if (this.convertTo === AUTO_UPPERCASE) {
                return value.toUpperCase();
            }
            else if (this.convertTo === AUTO_LOWERCASE) {
                return value.toLowerCase();
            }
            return value;
        }
    }
    /**
     * Reacts to keydown event.
     * @param {?} event
     * @return {?}
     */
    _keydownAction(event) {
        /** @type {?} */
        const previousInputField = event.target.previousElementSibling;
        /** @type {?} */
        const nextInputField = event.target.nextElementSibling;
        switch (event.keyCode) {
            case SPACE:
                return false;
            case BACKSPACE:
                if (event.target.value === '') {
                    if (previousInputField && previousInputField.tagName === TAG_NAME_INPUT) {
                        this.selectInput(previousInputField);
                    }
                }
                break;
            case LEFT_ARROW:
                if (previousInputField && previousInputField.tagName === TAG_NAME_INPUT) {
                    event.preventDefault();
                    this.selectInput(previousInputField);
                }
                break;
            case RIGHT_ARROW:
                if (nextInputField && nextInputField.tagName === TAG_NAME_INPUT) {
                    this.selectInput(nextInputField);
                }
                event.preventDefault();
                break;
            case DOWN_ARROW:
                this._isUpDown = true;
                if (this._type === 'number' && (event.target.value === '' || event.target.value === '0')) {
                    event.preventDefault();
                }
                break;
            case UP_ARROW:
                this._isUpDown = true;
                if (this._type === 'number' && event.target.value === '9') {
                    event.preventDefault();
                }
                break;
            default:
                break;
        }
    }
    /**
     * Selects the value on click of an input field.
     * @param {?} event
     * @return {?}
     */
    _selectText(event) {
        this.selectInput(event.target);
    }
    /**
     * Automatically focuses and selects the next input on key input.
     * @param {?} event
     * @return {?}
     */
    _selectNextInput(event) {
        event.target.value = this._convertLetterSize(event.target.value.slice(0, 1));
        /** @type {?} */
        const currentIndex = this._getFocusedInputIndex(event);
        // save in model with uppercase if needed
        this._keyCode[currentIndex] = event.target.value;
        this.propagateChange(this._keyCode.join(''));
        // don't jump to next input if the user uses UP/DOWn arrow (native behaviour)
        /** @type {?} */
        const focusNextInput = !(this._isUpDown && this.type === 'number');
        if (event.target.value && focusNextInput) {
            /** @type {?} */
            const nextInputField = event.target.nextSibling;
            if (nextInputField !== null && nextInputField.tagName === TAG_NAME_INPUT) {
                nextInputField.focus();
                if (nextInputField.value !== '') {
                    this.selectInput(nextInputField);
                }
            }
        }
        this._isUpDown = false;
    }
    /**
     * Paste event to distribute content in input fields.
     * @param {?} event
     * @return {?}
     */
    _pasteClipboard(event) {
        /** @type {?} */
        let copiedText = (event.clipboardData || ((/** @type {?} */ (window))).clipboardData).getData('text');
        /** @type {?} */
        let copiedTextIndex = 0;
        /** @type {?} */
        const inputIndex = this._getFocusedInputIndex(event);
        copiedText = this.type === 'number' ? this._formatNumberInput(copiedText) : copiedText;
        for (let i = inputIndex; i < this.codeLength; i++) {
            this._keyCode[i] = this._convertLetterSize(copiedText[copiedTextIndex]);
            copiedTextIndex++;
        }
        this.propagateChange(this._keyCode.join(''));
        if (inputIndex + copiedText.length < this.codeLength) {
            this._el.nativeElement.children.item(inputIndex + copiedText.length).focus();
        }
        else {
            this._el.nativeElement.children.item(this.codeLength - 1).focus();
        }
        event.preventDefault();
    }
    /**
     * Returns the index of the code input, which is currently focused.
     * @private
     * @param {?} event
     * @return {?}
     */
    _getFocusedInputIndex(event) {
        /** @type {?} */
        let inputIndex;
        for (let i = 0; i < this._el.nativeElement.children.length; i++) {
            if (event.srcElement === this._el.nativeElement.children.item(i)) {
                inputIndex = i;
            }
        }
        return inputIndex;
    }
    /**
     * Removes all characters from the input except for numbers [0-9].
     * @private
     * @param {?} copiedText
     * @return {?}
     */
    _formatNumberInput(copiedText) {
        /** @type {?} */
        let formattedInput = '';
        for (let i = 0; i < copiedText.length; i++) {
            if (copiedText[i].match(/[0-9]{1}$/)) {
                formattedInput += copiedText[i];
            }
        }
        return formattedInput;
    }
    /**
     * Triggers when an input field is blurred.
     * @return {?}
     */
    _onBlur() {
        this._focused = false;
        setTimeout((/**
         * @return {?}
         */
        () => {
            if (!this._focused) {
                this.propagateTouch(this._keyCode.join(''));
            }
            this._changeDetectorRef.markForCheck();
        }));
    }
    /**
     * Sets _focused state and makes valid.
     * @return {?}
     */
    _setFocusState() {
        this._focused = true;
    }
    /**
     * Disables the code input. Part of the ControlValueAccessor interface required
     * to integrate with Angular's core forms API.
     *
     * @param {?} isDisabled Sets whether the component is disabled.
     * @return {?}
     */
    setDisabledState(isDisabled) {
        this.disabled = isDisabled;
        this._changeDetectorRef.markForCheck();
    }
    /**
     * Sets initial value, used by ControlValueAccessor.
     * @param {?} value
     * @return {?}
     */
    writeValue(value) {
        if (value) {
            /** @type {?} */
            const valueAsArray = value.split('').slice(0, this.codeLength);
            for (let i = 0; i < this.codeLength; i++) {
                this._keyCode[i] = valueAsArray[i];
            }
        }
        else {
            this.setInputLength();
        }
        this._changeDetectorRef.markForCheck();
    }
    /**
     * @param {?} index
     * @param {?} item
     * @return {?}
     */
    _trackByKeyCode(index, item) {
        return index;
    }
    /**
     * Adds a gap to input fields when appropriate.
     * @param {?} index
     * @return {?}
     */
    _inputGap(index) {
        switch (this.codeLength) {
            case 4:
            case 6:
            case 8:
                if (index === this.codeLength / 2) {
                    return INPUT_FIELD_GAP;
                }
                break;
            default:
                return;
        }
    }
    /**
     * @param {?} fn
     * @return {?}
     */
    registerOnChange(fn) {
        this.propagateChange = fn;
    }
    /**
     * @param {?} fn
     * @return {?}
     */
    registerOnTouched(fn) {
        this.propagateTouch = fn;
    }
    /**
     * \@docs-private
     * @return {?}
     */
    updateErrorState() {
        /** @type {?} */
        const oldState = this.errorState;
        /** @type {?} */
        const parent = this._parentFormGroup || this._parentForm;
        /** @type {?} */
        const control = this._control ? (/** @type {?} */ (this._control.control)) : null;
        /** @type {?} */
        const newState = this._errorStateMatcher.isErrorState(control, parent);
        if (newState !== oldState) {
            this.errorState = newState;
        }
    }
    /**
     * @param {?} keyIndex
     * @return {?}
     */
    getAriaLabel(keyIndex) {
        return `${this._intl.inputFieldAriaLabel} ${keyIndex + 1} ${this._intl.ofLabel} ${this._keyCode.length}`;
    }
    /**
     * \@docs-private
     * Workaround preventing the selection error because the `setSelectionRange` is not supported on input['type=number']
     *
     * @param {?} input
     * @return {?}
     */
    selectInput(input) {
        input.focus();
        try {
            input.setSelectionRange(0, input.value.length);
        }
        catch (err) {
            if (err instanceof DOMException && err.name === 'InvalidStateError') {
                // setSelectionRange does not apply
            }
            else {
                throw err;
            }
        }
    }
}
NxCodeInputComponent.decorators = [
    { type: Component, args: [{
                selector: 'nx-code-input',
                template: "<input\n        class=\"nx-code-input__field\"\n        maxlength=\"1\"\n        *ngFor=\"let key of _keyCode; index as i; trackBy: _trackByKeyCode;\"\n        [(ngModel)]=\"_keyCode[i]\"\n        [ngClass]=\"_inputGap(i)\"\n        [attr.aria-label]=\"getAriaLabel(i)\"\n        [attr.type]=\"type\"\n        (input)=\"_selectNextInput($event)\"\n        (paste)=\"_pasteClipboard($event)\"\n        (blur)=\"_onBlur()\"\n        (focus)=\"_setFocusState()\"\n        (click)=\"_selectText($event)\"\n        (keydown)=\"_keydownAction($event)\"\n        [attr.tabindex]=\"tabindex\"\n        [attr.disabled]=\"disabled ? '' : null\"\n />\n",
                host: {
                    '[class.nx-code-input]': 'true',
                    '[class.has-error]': 'errorState',
                    '[class.is-negative]': 'negative',
                    '[class.is-disabled]': 'disabled',
                    '[attr.tabindex]': '-1'
                },
                changeDetection: ChangeDetectionStrategy.OnPush,
                styles: [":host{display:block}:host .nx-code-input__field{font-size:26px;font-size:var(--code-input-font-size,26px);line-height:32px;line-height:var(--code-input-line-height,32px);font-weight:600;font-weight:var(--code-input-font-weight,600);letter-spacing:.3px;letter-spacing:var(--code-input-letter-spacing,.3px);color:#414141;color:var(--code-input-color,#414141);margin:0 4px;text-align:center;border:0;outline:0;caret-color:#007ab3;caret-color:var(--code-input-active-color,#007ab3);box-shadow:inset 0 -1px 0 0 #414141;box-shadow:inset 0 -1px 0 0 var(--code-input-color,#414141);width:32px;border-radius:0;padding:0;background:0 0;box-sizing:border-box}:host .nx-code-input__field:focus{margin-bottom:-1px;color:#007ab3;color:var(--code-input-active-color,#007ab3);box-shadow:inset 0 -2px 0 0 #007ab3;box-shadow:inset 0 -2px 0 0 var(--code-input-active-color,#007ab3)}:host .nx-code-input__field:first-child{margin-left:0}:host .nx-code-input__field:last-child{margin-right:0}:host .nx-code-input--field-with-gap{margin-left:20px}:host:focus{outline:0}:host.is-negative .nx-code-input__field{caret-color:#fff;box-shadow:inset 0 -1px 0 0 #fff;color:#fff}:host.is-negative .nx-code-input__field:focus{box-shadow:inset 0 -2px 0 0 #fff}:host.has-error:not(.is-negative) .nx-code-input__field{margin-bottom:-1px;font-weight:700;color:#dc3149;color:var(--code-input-error-color,#dc3149);box-shadow:inset 0 -1px 0 0 #dc3149;box-shadow:inset 0 -1px 0 0 var(--code-input-error-color,#dc3149)}:host.has-error:not(.is-negative) .nx-code-input__field:focus{box-shadow:inset 0 -2px 0 0 #dc3149;box-shadow:inset 0 -2px 0 0 var(--code-input-error-color,#dc3149)}:host.has-error.is-negative .nx-code-input__field{font-weight:700}:host.is-disabled{cursor:not-allowed}:host.is-disabled .nx-code-input__field{cursor:not-allowed;color:#c2c2c2;color:var(--code-input-disabled-color,#c2c2c2);box-shadow:inset 0 -1px 0 0 nx-theme-color(code-input-disabled-color);box-shadow:inset 0 -1px 0 0 var(--code-input-disabled-color,#c2c2c2)}:host.is-disabled.is-negative .nx-code-input__field{color:rgba(194,194,194,.4);box-shadow:inset 0 -1px 0 0 rgba(194,194,194,.4)}input[type=number]::-webkit-inner-spin-button,input[type=number]::-webkit-outer-spin-button{-webkit-appearance:none;margin:0}input[type=number]{-moz-appearance:textfield}@media screen and (-ms-high-contrast:active){.nx-code-input__field{box-shadow:inset 0 -1px 0 0 buttonText}.nx-code-input__field:focus{box-shadow:inset 0 -2px 0 0 buttonText}:host.is-disabled .nx-code-input__field{color:GrayText;box-shadow:inset 0 -1px 0 0 GrayText;opacity:1}}"]
            }] }
];
/** @nocollapse */
NxCodeInputComponent.ctorParameters = () => [
    { type: ChangeDetectorRef },
    { type: ElementRef },
    { type: NgControl, decorators: [{ type: Self }, { type: Optional }] },
    { type: NxCodeInputIntl },
    { type: ErrorStateMatcher },
    { type: NgForm, decorators: [{ type: Optional }] },
    { type: FormGroupDirective, decorators: [{ type: Optional }] }
];
NxCodeInputComponent.propDecorators = {
    codeLength: [{ type: Input, args: ['length',] }],
    type: [{ type: Input }],
    tabindex: [{ type: Input }],
    convertTo: [{ type: Input, args: ['nxConvertTo',] }],
    negative: [{ type: Input }],
    disabled: [{ type: Input }]
};
if (false) {
    /**
     * Whether the current input of the component has an error.
     * @type {?}
     */
    NxCodeInputComponent.prototype.errorState;
    /**
     * @type {?}
     * @private
     */
    NxCodeInputComponent.prototype._codeLength;
    /**
     * @type {?}
     * @private
     */
    NxCodeInputComponent.prototype._type;
    /**
     * @type {?}
     * @private
     */
    NxCodeInputComponent.prototype._isUpDown;
    /**
     * @type {?}
     * @private
     */
    NxCodeInputComponent.prototype._tabindex;
    /**
     * @type {?}
     * @private
     */
    NxCodeInputComponent.prototype._convertTo;
    /**
     * The user input in array form
     * @type {?}
     */
    NxCodeInputComponent.prototype._keyCode;
    /**
     * @type {?}
     * @private
     */
    NxCodeInputComponent.prototype._focused;
    /**
     * @type {?}
     * @private
     */
    NxCodeInputComponent.prototype._negative;
    /**
     * @type {?}
     * @private
     */
    NxCodeInputComponent.prototype._disabled;
    /**
     * \@docs-private
     * @type {?}
     */
    NxCodeInputComponent.prototype.propagateChange;
    /**
     * \@docs-private
     * @type {?}
     */
    NxCodeInputComponent.prototype.propagateTouch;
    /**
     * @type {?}
     * @private
     */
    NxCodeInputComponent.prototype._changeDetectorRef;
    /**
     * @type {?}
     * @private
     */
    NxCodeInputComponent.prototype._el;
    /** @type {?} */
    NxCodeInputComponent.prototype._control;
    /** @type {?} */
    NxCodeInputComponent.prototype._intl;
    /**
     * @type {?}
     * @private
     */
    NxCodeInputComponent.prototype._errorStateMatcher;
    /**
     * @type {?}
     * @private
     */
    NxCodeInputComponent.prototype._parentForm;
    /**
     * @type {?}
     * @private
     */
    NxCodeInputComponent.prototype._parentFormGroup;
}

/**
 * @fileoverview added by tsickle
 * Generated from: code-input.module.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class NxCodeInputModule {
}
NxCodeInputModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    CommonModule,
                    FormsModule,
                    ReactiveFormsModule
                ],
                declarations: [
                    NxCodeInputComponent,
                ],
                exports: [
                    NxCodeInputComponent,
                ],
                providers: [NxCodeInputIntl],
            },] }
];

/**
 * @fileoverview added by tsickle
 * Generated from: public-api.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * Generated from: allianz-ngx-ndbx-code-input.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

export { NxCodeInputComponent, NxCodeInputIntl, NxCodeInputModule };
//# sourceMappingURL=allianz-ngx-ndbx-code-input.js.map
