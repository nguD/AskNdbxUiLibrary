import { NxFormfieldComponent } from '@allianz/ngx-ndbx/formfield';
import { Directionality } from '@angular/cdk/bidi';
import { Overlay, ViewportRuler } from '@angular/cdk/overlay';
import { AfterViewInit, ChangeDetectorRef, ElementRef, NgZone, OnChanges, OnDestroy, ViewContainerRef } from '@angular/core';
import { ControlValueAccessor } from '@angular/forms';
import { Observable } from 'rxjs';
import { NxWordComponent } from '@allianz/ngx-ndbx/natural-language-form';
import { NxAutocompleteOptionComponent, NxAutocompleteOptionSelected } from './autocomplete-option.component';
import { NxAutocompleteComponent } from './autocomplete.component';
/**
 * Provider that allows the autocomplete to register as a ControlValueAccessor.
 * @docs-private
 */
export declare const NX_AUTOCOMPLETE_VALUE_ACCESSOR: any;
/**
 * Creates an error to be thrown when attempting to use an autocomplete trigger without a panel.
 */
export declare function getNxAutocompleteMissingPanelError(): Error;
export declare class NxAutocompleteTriggerDirective implements ControlValueAccessor, OnDestroy, OnChanges, AfterViewInit {
    private _element;
    private _overlay;
    private _viewContainerRef;
    private _zone;
    private _changeDetectorRef;
    private _dir;
    private _nxFormField;
    private _nxWordField;
    private _document;
    private _viewportRuler?;
    private _overlayRef;
    private _portal;
    private _componentDestroyed;
    /** Old value of the native input. Used to work around issues with the `input` event on IE. */
    private _previousValue;
    /** Strategy that is used to position the panel. */
    private _positionStrategy;
    /** Whether or not the label state is being overridden. */
    private _manuallyFloatingLabel;
    /** The subscription for closing actions (some are bound to document). */
    private _closingActionsSubscription;
    /** Subscription to viewport size changes. */
    private _viewportSubscription;
    /** Subscription to control value changes */
    private _controlValueChangesSubscription;
    /** Subscription to items observable */
    private _itemsSubscription;
    /** Stream of keyboard events that can close the panel. */
    private readonly _closeKeyEventStream;
    /** Value changes */
    private readonly _valueChanges;
    /** The autocomplete panel to be attached to this trigger. */
    autocomplete: NxAutocompleteComponent;
    /** The items callback. Called with input value, must return Observable of Array of strings */
    itemsCb: (val: string) => Observable<Array<string>>;
    private _itemsCb;
    /** Debounce in ms before items callback is triggered. Defaults to 400 */
    debounce: number;
    private _debounce;
    /** Whether autocomplete functionality is disabled. */
    autocompleteDisabled: boolean;
    private _autocompleteDisabled;
    /** Whether or not the autocomplete panel is open. */
    readonly panelOpen: boolean;
    private _overlayAttached;
    /** Stream of autocomplete option selections. */
    readonly optionSelections: Observable<NxAutocompleteOptionSelected>;
    /** The currently active option, coerced to NxAutocompleteOptionComponent type. */
    readonly activeOption: NxAutocompleteOptionComponent | null;
    /** Stream of clicks outside of the autocomplete panel. */
    private readonly _outsideClickStream;
    /** `View -> model callback called when value changes` */
    _onChange: (value: any) => void;
    /** `View -> model callback called when autocomplete has been touched` */
    _onTouched: () => void;
    private readonly _formField;
    constructor(_element: ElementRef, _overlay: Overlay, _viewContainerRef: ViewContainerRef, _zone: NgZone, _changeDetectorRef: ChangeDetectorRef, _dir: Directionality, _nxFormField: NxFormfieldComponent, _nxWordField: NxWordComponent, _document: any, _viewportRuler?: ViewportRuler);
    ngOnDestroy(): void;
    ngOnChanges(): void;
    ngAfterViewInit(): void;
    /**
     * Binds or rebinds the autocomplete items. Prerequisites:
     * - items callback has to be defined
     * - autocomplete panel has to be bound
     */
    private _bindAutocompleteItems;
    /** Opens the autocomplete suggestion panel. */
    openPanel(): void;
    /** Closes the autocomplete suggestion panel. */
    closePanel(): void;
    /**
     * A stream of actions that should close the autocomplete panel, including
     * when an option is selected, on blur, and when TAB is pressed.
     */
    readonly panelClosingActions: Observable<NxAutocompleteOptionSelected>;
    writeValue(value: any): void;
    registerOnChange(fn: (value: any) => {}): void;
    registerOnTouched(fn: () => {}): void;
    setDisabledState(isDisabled: boolean): void;
    _handleKeydown(event: KeyboardEvent): void;
    _handleInput(event: KeyboardEvent): void;
    _handleFocus(): void;
    /**
     * In "auto" mode, the label will animate down as soon as focus is lost.
     * This causes the value to jump when selecting an option with the mouse.
     * This method manually floats the label until the panel can be closed.
     * @param shouldAnimate Whether the label should be animated when it is floated.
     */
    private _floatLabel;
    /** If the label has been manually elevated, return it to its normal state. */
    private _resetLabel;
    /**
     * Given that we are not actually focusing active options, we must manually adjust scroll
     * to reveal options below the fold. First, we find the offset of the option from the top
     * of the panel. If that offset is below the fold, the new scrollTop will be the offset -
     * the panel height + the option height, so the active option will be just visible at the
     * bottom of the panel. If that offset is above the top of the visible panel, the new scrollTop
     * will become the offset. If that offset is visible within the panel already, the scrollTop is
     * not adjusted.
     */
    private _scrollToOption;
    /**
     * This method listens to a stream of panel closing actions and resets the
     * stream every time the option list changes.
     */
    private _subscribeToClosingActions;
    /** Destroys the autocomplete suggestion panel. */
    private _destroyPanel;
    private _setTriggerValue;
    /**
     * This method closes the panel, and if a value is specified, also sets the associated
     * control to that value. It will also mark the control as dirty if this interaction
     * stemmed from the user.
     */
    private _setValueAndClose;
    /**
     * Clear any previous selected option and emit a selection change event for this option
     */
    private _clearPreviousSelectedOption;
    private _attachOverlay;
    private _getOverlayConfig;
    private _getOverlayPosition;
    private _scrollStrategy;
    private _getConnectedElement;
    /** Returns the width of the input element, so the panel min-width can match it. */
    private _getHostWidth;
    /**
     * Resets the active item to -1 so arrow events will activate the
     * correct options, or to 0 if the consumer opted into it.
     */
    private _resetActiveItem;
    /** Determines whether the panel can be opened. */
    private _isFieldEnabled;
}
