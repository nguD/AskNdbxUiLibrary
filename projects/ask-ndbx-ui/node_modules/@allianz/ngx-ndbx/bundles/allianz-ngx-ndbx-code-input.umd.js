(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@angular/common'), require('@angular/core'), require('@angular/forms'), require('rxjs'), require('@allianz/ngx-ndbx/utils'), require('@angular/cdk/keycodes'), require('@angular/cdk/coercion')) :
    typeof define === 'function' && define.amd ? define('@allianz/ngx-ndbx/code-input', ['exports', '@angular/common', '@angular/core', '@angular/forms', 'rxjs', '@allianz/ngx-ndbx/utils', '@angular/cdk/keycodes', '@angular/cdk/coercion'], factory) :
    (global = global || self, factory((global.allianz = global.allianz || {}, global.allianz['ngx-ndbx'] = global.allianz['ngx-ndbx'] || {}, global.allianz['ngx-ndbx']['code-input'] = {}), global.ng.common, global.ng.core, global.ng.forms, global.rxjs, global.allianz['ngx-ndbx'].utils, global.ng.cdk.keycodes, global.ng.cdk.coercion));
}(this, (function (exports, common, core, forms, rxjs, utils, keycodes, coercion) { 'use strict';

    /**
     * @fileoverview added by tsickle
     * Generated from: code-input-intl.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var NxCodeInputIntl = /** @class */ (function () {
        function NxCodeInputIntl() {
            /**
             * Stream that emits whenever the labels here are changed. Use this to notify
             * components if the labels have changed after initialization.
             */
            this.changes = new rxjs.Subject();
            /**
             * Label that should replace the 'Enter key' of the aria-label.
             */
            this.inputFieldAriaLabel = 'Enter Key';
            /**
             * Label that should replace the 'of' of the aria-label.
             */
            this.ofLabel = 'of';
        }
        NxCodeInputIntl.decorators = [
            { type: core.Injectable }
        ];
        return NxCodeInputIntl;
    }());
    if (false) {
        /**
         * Stream that emits whenever the labels here are changed. Use this to notify
         * components if the labels have changed after initialization.
         * @type {?}
         */
        NxCodeInputIntl.prototype.changes;
        /**
         * Label that should replace the 'Enter key' of the aria-label.
         * @type {?}
         */
        NxCodeInputIntl.prototype.inputFieldAriaLabel;
        /**
         * Label that should replace the 'of' of the aria-label.
         * @type {?}
         */
        NxCodeInputIntl.prototype.ofLabel;
    }

    /**
     * @fileoverview added by tsickle
     * Generated from: code-input.component.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /** @type {?} */
    var DEFAULT_INPUT_LENGTH = 6;
    /** @type {?} */
    var TAG_NAME_INPUT = 'INPUT';
    /** @type {?} */
    var AUTO_UPPERCASE = 'upper';
    /** @type {?} */
    var AUTO_LOWERCASE = 'lower';
    /** @type {?} */
    var INPUT_FIELD_GAP = 'nx-code-input--field-with-gap';
    var NxCodeInputComponent = /** @class */ (function () {
        function NxCodeInputComponent(_changeDetectorRef, _el, _control, _intl, _errorStateMatcher, _parentForm, _parentFormGroup) {
            this._changeDetectorRef = _changeDetectorRef;
            this._el = _el;
            this._control = _control;
            this._intl = _intl;
            this._errorStateMatcher = _errorStateMatcher;
            this._parentForm = _parentForm;
            this._parentFormGroup = _parentFormGroup;
            /**
             * Whether the current input of the component has an error.
             */
            this.errorState = false;
            this._codeLength = DEFAULT_INPUT_LENGTH;
            this._type = 'text';
            this._isUpDown = false;
            this._tabindex = 0;
            /**
             * The user input in array form
             */
            this._keyCode = new Array(DEFAULT_INPUT_LENGTH);
            this._focused = false;
            this._negative = false;
            this._disabled = false;
            /**
             * \@docs-private
             */
            this.propagateChange = (/**
             * @param {?} _
             * @return {?}
             */
            function (_) {
            });
            /**
             * \@docs-private
             */
            this.propagateTouch = (/**
             * @param {?} _
             * @return {?}
             */
            function (_) {
            });
            if (this._control) {
                // Note: we provide the value accessor through here, instead of
                // the `providers` to avoid running into a circular import.
                this._control.valueAccessor = this;
            }
        }
        Object.defineProperty(NxCodeInputComponent.prototype, "codeLength", {
            get: /**
             * @return {?}
             */
            function () {
                return this._codeLength;
            },
            /** The length of the code input. Default: 6. */
            set: /**
             * The length of the code input. Default: 6.
             * @param {?} value
             * @return {?}
             */
            function (value) {
                this._codeLength = value;
                this.setInputLength();
                this._changeDetectorRef.markForCheck();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NxCodeInputComponent.prototype, "type", {
            get: /**
             * @return {?}
             */
            function () {
                return this._type;
            },
            /** The type of HTML input */
            set: /**
             * The type of HTML input
             * @param {?} value
             * @return {?}
             */
            function (value) {
                this._type = value;
                this._changeDetectorRef.markForCheck();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NxCodeInputComponent.prototype, "tabindex", {
            get: /**
             * @return {?}
             */
            function () {
                return this._tabindex;
            },
            /** Sets the tabindex of the contained input elements. */
            set: /**
             * Sets the tabindex of the contained input elements.
             * @param {?} value
             * @return {?}
             */
            function (value) {
                this._tabindex = value;
                this._changeDetectorRef.markForCheck();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NxCodeInputComponent.prototype, "convertTo", {
            get: /**
             * @return {?}
             */
            function () {
                return this._convertTo;
            },
            /** Whether the form should auto capitalize or lowercase (optional). */
            set: /**
             * Whether the form should auto capitalize or lowercase (optional).
             * @param {?} value
             * @return {?}
             */
            function (value) {
                this._convertTo = value;
                this._changeDetectorRef.markForCheck();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NxCodeInputComponent.prototype, "negative", {
            get: /**
             * @return {?}
             */
            function () {
                return this._negative;
            },
            /** Whether the code input uses the negative set of styling. */
            set: /**
             * Whether the code input uses the negative set of styling.
             * @param {?} value
             * @return {?}
             */
            function (value) {
                /** @type {?} */
                var newValue = coercion.coerceBooleanProperty(value);
                if (this._negative !== newValue) {
                    this._negative = newValue;
                    this._changeDetectorRef.markForCheck();
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NxCodeInputComponent.prototype, "disabled", {
            get: /**
             * @return {?}
             */
            function () {
                return this._disabled;
            },
            /** Whether the code input is disabled. */
            set: /**
             * Whether the code input is disabled.
             * @param {?} value
             * @return {?}
             */
            function (value) {
                /** @type {?} */
                var newValue = coercion.coerceBooleanProperty(value);
                if (this._disabled !== newValue) {
                    this._disabled = newValue;
                    this._changeDetectorRef.markForCheck();
                }
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        NxCodeInputComponent.prototype.ngDoCheck = /**
         * @return {?}
         */
        function () {
            if (this._control) {
                // We need to re-evaluate this on every change detection cycle, because there are some
                // error triggers that we can't subscribe to (e.g. parent form submissions). This means
                // that whatever logic is in here has to be super lean or we risk destroying the performance.
                this.updateErrorState();
            }
        };
        /** Sets the length of the input fields. */
        /**
         * Sets the length of the input fields.
         * @return {?}
         */
        NxCodeInputComponent.prototype.setInputLength = /**
         * Sets the length of the input fields.
         * @return {?}
         */
        function () {
            if (this.codeLength) {
                this._keyCode = new Array(this.codeLength);
            }
            else {
                this._keyCode = new Array(DEFAULT_INPUT_LENGTH);
            }
        };
        /** Converts to upper or lowercase when enabled. */
        /**
         * Converts to upper or lowercase when enabled.
         * @param {?} value
         * @return {?}
         */
        NxCodeInputComponent.prototype._convertLetterSize = /**
         * Converts to upper or lowercase when enabled.
         * @param {?} value
         * @return {?}
         */
        function (value) {
            if (value === 'ß') {
                return value;
            }
            if (typeof value === 'string') {
                if (this.convertTo === AUTO_UPPERCASE) {
                    return value.toUpperCase();
                }
                else if (this.convertTo === AUTO_LOWERCASE) {
                    return value.toLowerCase();
                }
                return value;
            }
        };
        /** Reacts to keydown event. */
        /**
         * Reacts to keydown event.
         * @param {?} event
         * @return {?}
         */
        NxCodeInputComponent.prototype._keydownAction = /**
         * Reacts to keydown event.
         * @param {?} event
         * @return {?}
         */
        function (event) {
            /** @type {?} */
            var previousInputField = event.target.previousElementSibling;
            /** @type {?} */
            var nextInputField = event.target.nextElementSibling;
            switch (event.keyCode) {
                case keycodes.SPACE:
                    return false;
                case keycodes.BACKSPACE:
                    if (event.target.value === '') {
                        if (previousInputField && previousInputField.tagName === TAG_NAME_INPUT) {
                            this.selectInput(previousInputField);
                        }
                    }
                    break;
                case keycodes.LEFT_ARROW:
                    if (previousInputField && previousInputField.tagName === TAG_NAME_INPUT) {
                        event.preventDefault();
                        this.selectInput(previousInputField);
                    }
                    break;
                case keycodes.RIGHT_ARROW:
                    if (nextInputField && nextInputField.tagName === TAG_NAME_INPUT) {
                        this.selectInput(nextInputField);
                    }
                    event.preventDefault();
                    break;
                case keycodes.DOWN_ARROW:
                    this._isUpDown = true;
                    if (this._type === 'number' && (event.target.value === '' || event.target.value === '0')) {
                        event.preventDefault();
                    }
                    break;
                case keycodes.UP_ARROW:
                    this._isUpDown = true;
                    if (this._type === 'number' && event.target.value === '9') {
                        event.preventDefault();
                    }
                    break;
                default:
                    break;
            }
        };
        /** Selects the value on click of an input field. */
        /**
         * Selects the value on click of an input field.
         * @param {?} event
         * @return {?}
         */
        NxCodeInputComponent.prototype._selectText = /**
         * Selects the value on click of an input field.
         * @param {?} event
         * @return {?}
         */
        function (event) {
            this.selectInput(event.target);
        };
        /** Automatically focuses and selects the next input on key input. */
        /**
         * Automatically focuses and selects the next input on key input.
         * @param {?} event
         * @return {?}
         */
        NxCodeInputComponent.prototype._selectNextInput = /**
         * Automatically focuses and selects the next input on key input.
         * @param {?} event
         * @return {?}
         */
        function (event) {
            event.target.value = this._convertLetterSize(event.target.value.slice(0, 1));
            /** @type {?} */
            var currentIndex = this._getFocusedInputIndex(event);
            // save in model with uppercase if needed
            this._keyCode[currentIndex] = event.target.value;
            this.propagateChange(this._keyCode.join(''));
            // don't jump to next input if the user uses UP/DOWn arrow (native behaviour)
            /** @type {?} */
            var focusNextInput = !(this._isUpDown && this.type === 'number');
            if (event.target.value && focusNextInput) {
                /** @type {?} */
                var nextInputField = event.target.nextSibling;
                if (nextInputField !== null && nextInputField.tagName === TAG_NAME_INPUT) {
                    nextInputField.focus();
                    if (nextInputField.value !== '') {
                        this.selectInput(nextInputField);
                    }
                }
            }
            this._isUpDown = false;
        };
        /** Paste event to distribute content in input fields. */
        /**
         * Paste event to distribute content in input fields.
         * @param {?} event
         * @return {?}
         */
        NxCodeInputComponent.prototype._pasteClipboard = /**
         * Paste event to distribute content in input fields.
         * @param {?} event
         * @return {?}
         */
        function (event) {
            /** @type {?} */
            var copiedText = (event.clipboardData || ((/** @type {?} */ (window))).clipboardData).getData('text');
            /** @type {?} */
            var copiedTextIndex = 0;
            /** @type {?} */
            var inputIndex = this._getFocusedInputIndex(event);
            copiedText = this.type === 'number' ? this._formatNumberInput(copiedText) : copiedText;
            for (var i = inputIndex; i < this.codeLength; i++) {
                this._keyCode[i] = this._convertLetterSize(copiedText[copiedTextIndex]);
                copiedTextIndex++;
            }
            this.propagateChange(this._keyCode.join(''));
            if (inputIndex + copiedText.length < this.codeLength) {
                this._el.nativeElement.children.item(inputIndex + copiedText.length).focus();
            }
            else {
                this._el.nativeElement.children.item(this.codeLength - 1).focus();
            }
            event.preventDefault();
        };
        /** Returns the index of the code input, which is currently focused. */
        /**
         * Returns the index of the code input, which is currently focused.
         * @private
         * @param {?} event
         * @return {?}
         */
        NxCodeInputComponent.prototype._getFocusedInputIndex = /**
         * Returns the index of the code input, which is currently focused.
         * @private
         * @param {?} event
         * @return {?}
         */
        function (event) {
            /** @type {?} */
            var inputIndex;
            for (var i = 0; i < this._el.nativeElement.children.length; i++) {
                if (event.srcElement === this._el.nativeElement.children.item(i)) {
                    inputIndex = i;
                }
            }
            return inputIndex;
        };
        /** Removes all characters from the input except for numbers [0-9]. */
        /**
         * Removes all characters from the input except for numbers [0-9].
         * @private
         * @param {?} copiedText
         * @return {?}
         */
        NxCodeInputComponent.prototype._formatNumberInput = /**
         * Removes all characters from the input except for numbers [0-9].
         * @private
         * @param {?} copiedText
         * @return {?}
         */
        function (copiedText) {
            /** @type {?} */
            var formattedInput = '';
            for (var i = 0; i < copiedText.length; i++) {
                if (copiedText[i].match(/[0-9]{1}$/)) {
                    formattedInput += copiedText[i];
                }
            }
            return formattedInput;
        };
        /** Triggers when an input field is blurred. */
        /**
         * Triggers when an input field is blurred.
         * @return {?}
         */
        NxCodeInputComponent.prototype._onBlur = /**
         * Triggers when an input field is blurred.
         * @return {?}
         */
        function () {
            var _this = this;
            this._focused = false;
            setTimeout((/**
             * @return {?}
             */
            function () {
                if (!_this._focused) {
                    _this.propagateTouch(_this._keyCode.join(''));
                }
                _this._changeDetectorRef.markForCheck();
            }));
        };
        /** Sets _focused state and makes valid. */
        /**
         * Sets _focused state and makes valid.
         * @return {?}
         */
        NxCodeInputComponent.prototype._setFocusState = /**
         * Sets _focused state and makes valid.
         * @return {?}
         */
        function () {
            this._focused = true;
        };
        /**
         * Disables the code input. Part of the ControlValueAccessor interface required
         * to integrate with Angular's core forms API.
         *
         * @param isDisabled Sets whether the component is disabled.
         */
        /**
         * Disables the code input. Part of the ControlValueAccessor interface required
         * to integrate with Angular's core forms API.
         *
         * @param {?} isDisabled Sets whether the component is disabled.
         * @return {?}
         */
        NxCodeInputComponent.prototype.setDisabledState = /**
         * Disables the code input. Part of the ControlValueAccessor interface required
         * to integrate with Angular's core forms API.
         *
         * @param {?} isDisabled Sets whether the component is disabled.
         * @return {?}
         */
        function (isDisabled) {
            this.disabled = isDisabled;
            this._changeDetectorRef.markForCheck();
        };
        /** Sets initial value, used by ControlValueAccessor. */
        /**
         * Sets initial value, used by ControlValueAccessor.
         * @param {?} value
         * @return {?}
         */
        NxCodeInputComponent.prototype.writeValue = /**
         * Sets initial value, used by ControlValueAccessor.
         * @param {?} value
         * @return {?}
         */
        function (value) {
            if (value) {
                /** @type {?} */
                var valueAsArray = value.split('').slice(0, this.codeLength);
                for (var i = 0; i < this.codeLength; i++) {
                    this._keyCode[i] = valueAsArray[i];
                }
            }
            else {
                this.setInputLength();
            }
            this._changeDetectorRef.markForCheck();
        };
        /**
         * @param {?} index
         * @param {?} item
         * @return {?}
         */
        NxCodeInputComponent.prototype._trackByKeyCode = /**
         * @param {?} index
         * @param {?} item
         * @return {?}
         */
        function (index, item) {
            return index;
        };
        /** Adds a gap to input fields when appropriate. */
        /**
         * Adds a gap to input fields when appropriate.
         * @param {?} index
         * @return {?}
         */
        NxCodeInputComponent.prototype._inputGap = /**
         * Adds a gap to input fields when appropriate.
         * @param {?} index
         * @return {?}
         */
        function (index) {
            switch (this.codeLength) {
                case 4:
                case 6:
                case 8:
                    if (index === this.codeLength / 2) {
                        return INPUT_FIELD_GAP;
                    }
                    break;
                default:
                    return;
            }
        };
        /**
         * @param {?} fn
         * @return {?}
         */
        NxCodeInputComponent.prototype.registerOnChange = /**
         * @param {?} fn
         * @return {?}
         */
        function (fn) {
            this.propagateChange = fn;
        };
        /**
         * @param {?} fn
         * @return {?}
         */
        NxCodeInputComponent.prototype.registerOnTouched = /**
         * @param {?} fn
         * @return {?}
         */
        function (fn) {
            this.propagateTouch = fn;
        };
        /** @docs-private */
        /**
         * \@docs-private
         * @return {?}
         */
        NxCodeInputComponent.prototype.updateErrorState = /**
         * \@docs-private
         * @return {?}
         */
        function () {
            /** @type {?} */
            var oldState = this.errorState;
            /** @type {?} */
            var parent = this._parentFormGroup || this._parentForm;
            /** @type {?} */
            var control = this._control ? (/** @type {?} */ (this._control.control)) : null;
            /** @type {?} */
            var newState = this._errorStateMatcher.isErrorState(control, parent);
            if (newState !== oldState) {
                this.errorState = newState;
            }
        };
        /**
         * @param {?} keyIndex
         * @return {?}
         */
        NxCodeInputComponent.prototype.getAriaLabel = /**
         * @param {?} keyIndex
         * @return {?}
         */
        function (keyIndex) {
            return this._intl.inputFieldAriaLabel + " " + (keyIndex + 1) + " " + this._intl.ofLabel + " " + this._keyCode.length;
        };
        /** @docs-private
         * Workaround preventing the selection error because the `setSelectionRange` is not supported on input['type=number']
         * */
        /**
         * \@docs-private
         * Workaround preventing the selection error because the `setSelectionRange` is not supported on input['type=number']
         *
         * @param {?} input
         * @return {?}
         */
        NxCodeInputComponent.prototype.selectInput = /**
         * \@docs-private
         * Workaround preventing the selection error because the `setSelectionRange` is not supported on input['type=number']
         *
         * @param {?} input
         * @return {?}
         */
        function (input) {
            input.focus();
            try {
                input.setSelectionRange(0, input.value.length);
            }
            catch (err) {
                if (err instanceof DOMException && err.name === 'InvalidStateError') {
                    // setSelectionRange does not apply
                }
                else {
                    throw err;
                }
            }
        };
        NxCodeInputComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'nx-code-input',
                        template: "<input\n        class=\"nx-code-input__field\"\n        maxlength=\"1\"\n        *ngFor=\"let key of _keyCode; index as i; trackBy: _trackByKeyCode;\"\n        [(ngModel)]=\"_keyCode[i]\"\n        [ngClass]=\"_inputGap(i)\"\n        [attr.aria-label]=\"getAriaLabel(i)\"\n        [attr.type]=\"type\"\n        (input)=\"_selectNextInput($event)\"\n        (paste)=\"_pasteClipboard($event)\"\n        (blur)=\"_onBlur()\"\n        (focus)=\"_setFocusState()\"\n        (click)=\"_selectText($event)\"\n        (keydown)=\"_keydownAction($event)\"\n        [attr.tabindex]=\"tabindex\"\n        [attr.disabled]=\"disabled ? '' : null\"\n />\n",
                        host: {
                            '[class.nx-code-input]': 'true',
                            '[class.has-error]': 'errorState',
                            '[class.is-negative]': 'negative',
                            '[class.is-disabled]': 'disabled',
                            '[attr.tabindex]': '-1'
                        },
                        changeDetection: core.ChangeDetectionStrategy.OnPush,
                        styles: [":host{display:block}:host .nx-code-input__field{font-size:26px;font-size:var(--code-input-font-size,26px);line-height:32px;line-height:var(--code-input-line-height,32px);font-weight:600;font-weight:var(--code-input-font-weight,600);letter-spacing:.3px;letter-spacing:var(--code-input-letter-spacing,.3px);color:#414141;color:var(--code-input-color,#414141);margin:0 4px;text-align:center;border:0;outline:0;caret-color:#007ab3;caret-color:var(--code-input-active-color,#007ab3);box-shadow:inset 0 -1px 0 0 #414141;box-shadow:inset 0 -1px 0 0 var(--code-input-color,#414141);width:32px;border-radius:0;padding:0;background:0 0;box-sizing:border-box}:host .nx-code-input__field:focus{margin-bottom:-1px;color:#007ab3;color:var(--code-input-active-color,#007ab3);box-shadow:inset 0 -2px 0 0 #007ab3;box-shadow:inset 0 -2px 0 0 var(--code-input-active-color,#007ab3)}:host .nx-code-input__field:first-child{margin-left:0}:host .nx-code-input__field:last-child{margin-right:0}:host .nx-code-input--field-with-gap{margin-left:20px}:host:focus{outline:0}:host.is-negative .nx-code-input__field{caret-color:#fff;box-shadow:inset 0 -1px 0 0 #fff;color:#fff}:host.is-negative .nx-code-input__field:focus{box-shadow:inset 0 -2px 0 0 #fff}:host.has-error:not(.is-negative) .nx-code-input__field{margin-bottom:-1px;font-weight:700;color:#dc3149;color:var(--code-input-error-color,#dc3149);box-shadow:inset 0 -1px 0 0 #dc3149;box-shadow:inset 0 -1px 0 0 var(--code-input-error-color,#dc3149)}:host.has-error:not(.is-negative) .nx-code-input__field:focus{box-shadow:inset 0 -2px 0 0 #dc3149;box-shadow:inset 0 -2px 0 0 var(--code-input-error-color,#dc3149)}:host.has-error.is-negative .nx-code-input__field{font-weight:700}:host.is-disabled{cursor:not-allowed}:host.is-disabled .nx-code-input__field{cursor:not-allowed;color:#c2c2c2;color:var(--code-input-disabled-color,#c2c2c2);box-shadow:inset 0 -1px 0 0 nx-theme-color(code-input-disabled-color);box-shadow:inset 0 -1px 0 0 var(--code-input-disabled-color,#c2c2c2)}:host.is-disabled.is-negative .nx-code-input__field{color:rgba(194,194,194,.4);box-shadow:inset 0 -1px 0 0 rgba(194,194,194,.4)}input[type=number]::-webkit-inner-spin-button,input[type=number]::-webkit-outer-spin-button{-webkit-appearance:none;margin:0}input[type=number]{-moz-appearance:textfield}@media screen and (-ms-high-contrast:active){.nx-code-input__field{box-shadow:inset 0 -1px 0 0 buttonText}.nx-code-input__field:focus{box-shadow:inset 0 -2px 0 0 buttonText}:host.is-disabled .nx-code-input__field{color:GrayText;box-shadow:inset 0 -1px 0 0 GrayText;opacity:1}}"]
                    }] }
        ];
        /** @nocollapse */
        NxCodeInputComponent.ctorParameters = function () { return [
            { type: core.ChangeDetectorRef },
            { type: core.ElementRef },
            { type: forms.NgControl, decorators: [{ type: core.Self }, { type: core.Optional }] },
            { type: NxCodeInputIntl },
            { type: utils.ErrorStateMatcher },
            { type: forms.NgForm, decorators: [{ type: core.Optional }] },
            { type: forms.FormGroupDirective, decorators: [{ type: core.Optional }] }
        ]; };
        NxCodeInputComponent.propDecorators = {
            codeLength: [{ type: core.Input, args: ['length',] }],
            type: [{ type: core.Input }],
            tabindex: [{ type: core.Input }],
            convertTo: [{ type: core.Input, args: ['nxConvertTo',] }],
            negative: [{ type: core.Input }],
            disabled: [{ type: core.Input }]
        };
        return NxCodeInputComponent;
    }());
    if (false) {
        /**
         * Whether the current input of the component has an error.
         * @type {?}
         */
        NxCodeInputComponent.prototype.errorState;
        /**
         * @type {?}
         * @private
         */
        NxCodeInputComponent.prototype._codeLength;
        /**
         * @type {?}
         * @private
         */
        NxCodeInputComponent.prototype._type;
        /**
         * @type {?}
         * @private
         */
        NxCodeInputComponent.prototype._isUpDown;
        /**
         * @type {?}
         * @private
         */
        NxCodeInputComponent.prototype._tabindex;
        /**
         * @type {?}
         * @private
         */
        NxCodeInputComponent.prototype._convertTo;
        /**
         * The user input in array form
         * @type {?}
         */
        NxCodeInputComponent.prototype._keyCode;
        /**
         * @type {?}
         * @private
         */
        NxCodeInputComponent.prototype._focused;
        /**
         * @type {?}
         * @private
         */
        NxCodeInputComponent.prototype._negative;
        /**
         * @type {?}
         * @private
         */
        NxCodeInputComponent.prototype._disabled;
        /**
         * \@docs-private
         * @type {?}
         */
        NxCodeInputComponent.prototype.propagateChange;
        /**
         * \@docs-private
         * @type {?}
         */
        NxCodeInputComponent.prototype.propagateTouch;
        /**
         * @type {?}
         * @private
         */
        NxCodeInputComponent.prototype._changeDetectorRef;
        /**
         * @type {?}
         * @private
         */
        NxCodeInputComponent.prototype._el;
        /** @type {?} */
        NxCodeInputComponent.prototype._control;
        /** @type {?} */
        NxCodeInputComponent.prototype._intl;
        /**
         * @type {?}
         * @private
         */
        NxCodeInputComponent.prototype._errorStateMatcher;
        /**
         * @type {?}
         * @private
         */
        NxCodeInputComponent.prototype._parentForm;
        /**
         * @type {?}
         * @private
         */
        NxCodeInputComponent.prototype._parentFormGroup;
    }

    /**
     * @fileoverview added by tsickle
     * Generated from: code-input.module.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var NxCodeInputModule = /** @class */ (function () {
        function NxCodeInputModule() {
        }
        NxCodeInputModule.decorators = [
            { type: core.NgModule, args: [{
                        imports: [
                            common.CommonModule,
                            forms.FormsModule,
                            forms.ReactiveFormsModule
                        ],
                        declarations: [
                            NxCodeInputComponent,
                        ],
                        exports: [
                            NxCodeInputComponent,
                        ],
                        providers: [NxCodeInputIntl],
                    },] }
        ];
        return NxCodeInputModule;
    }());

    exports.NxCodeInputComponent = NxCodeInputComponent;
    exports.NxCodeInputIntl = NxCodeInputIntl;
    exports.NxCodeInputModule = NxCodeInputModule;

    Object.defineProperty(exports, '__esModule', { value: true });

})));
//# sourceMappingURL=allianz-ngx-ndbx-code-input.umd.js.map
