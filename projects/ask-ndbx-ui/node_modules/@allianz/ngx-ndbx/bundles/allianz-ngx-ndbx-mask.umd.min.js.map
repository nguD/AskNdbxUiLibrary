{"version":3,"sources":["ng://@allianz/ngx-ndbx/mask/mask.directive.ts","ng://@allianz/ngx-ndbx/mask/iban-mask.directive.ts","ng://@allianz/ngx-ndbx/mask/mask.module.ts"],"names":["NX_MASK_VALUE_ACCESSOR","provide","NG_VALUE_ACCESSOR","useExisting","forwardRef","NxMaskDirective","multi","NX_MASK_VALIDATORS","NG_VALIDATORS","_elementRef","this","_separators","_dropSpecialCharacters","_validateMask","cvaModelChange","Subject","_onChangeCallback","_","_onTouchedCallback","_validatorOnChange","_afterInputHook","event","_beforePasteHook","prototype","_callOnChangeCallback","dropSpecialCharacters","getUnmaskedValue","nativeElement","value","registerAfterInputHook","afterInput","registerBeforePasteHook","beforePaste","Object","defineProperty","_mask","updateValue","getMaskedString","setMask","_convertTo","values","newValue","coerceBooleanProperty","separators","reduce","unmasked","separator","split","join","_onKeydown","keyCode","input","currentValue","BACKSPACE","DELETE","backspaceShift","lastCharacter","substring","selectionStart","selectionEnd","selectionAtLastCharacter","length","newPosition","isSeparator","mask","_cursor","position","preventDefault","setSelectionRange","_calculateCursorShift","shift","characterWasEntered","_isStringAllowed","maskedValue","test","_onInputChange","oldVal","_inputValue","newVal","_pastedData","undefined","currentPosition","_onPaste","pastedData","clipboardData","getData","oldValue","maskedString","pastedUnmaskedValue","i","toUpperCase","toLowerCase","inputValue","maskStartIndex","formattedValue","maskIndex","inputIndex","indexOf","writeValue","next","registerOnChange","onChange","registerOnTouched","onTouched","registerOnValidatorChange","fn","_validateFn","inputLength","maskLength","nxMaskLengthError","actual","validate","validateMask","_touch","Directive","args","selector","host","(input)","(keydown)","(paste)","(blur)","exportAs","providers","NX_INPUT_VALUE_ACCESSOR","ElementRef","Input","NX_IBAN_MASK_VALIDATORS","NxIbanMaskDirective","maskDirective","_this","_setCountryCode","substr","enteredCountryCode","elementRefValue","subscribe","code","_countryCode","_countryCodeExists","_getMask","ngOnInit","convertTo","countryCode","countrySpecs","IBAN['countries']","match","forEach","charDef","character","count","Number","repeat","IBAN.isValid","nxIbanParseError","nxIbanInvalidCountryError","decorators","type","Inject","NxMaskModule","NgModule","imports","CommonModule","NxFormfieldModule","declarations","exports"],"mappings":"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","sourcesContent":["import { Directive, Input, ElementRef, forwardRef } from '@angular/core';\nimport {\n  ControlValueAccessor,\n  NG_VALUE_ACCESSOR,\n  NG_VALIDATORS,\n  Validator\n} from '@angular/forms';\nimport { coerceBooleanProperty } from '@angular/cdk/coercion';\nimport { NX_INPUT_VALUE_ACCESSOR } from '@allianz/ngx-ndbx/input';\nimport { BACKSPACE, DELETE } from '@angular/cdk/keycodes';\nimport { Subject } from 'rxjs';\n\ntype MASK_TYPE = '0' | 'A' | 'S';\n\nexport const NX_MASK_VALUE_ACCESSOR: any = {\n  provide: NG_VALUE_ACCESSOR,\n  useExisting: forwardRef(() => NxMaskDirective),\n  multi: true\n};\n\nexport const NX_MASK_VALIDATORS: any = {\n  provide: NG_VALIDATORS,\n  useExisting: forwardRef(() => NxMaskDirective),\n  multi: true\n};\n\n/** Options for input case sensitivity. */\nexport type MaskConversionTypes = 'lower' | 'upper';\n\n/** Interface for saving the cursor information. */\ninterface CursorInfo {\n  selectionStart?: number;\n  selectionEnd?: number;\n  position?: number;\n}\n\n@Directive({\n  selector: 'input[nxMask]',\n  host: {\n    '(input)': '_onInputChange($event)',\n    '(keydown)': '_onKeydown($event)',\n    '(paste)': '_onPaste($event)',\n    '(blur)': '_touch()'\n  },\n  exportAs: 'nxMaskDirective',\n  providers: [\n    NX_MASK_VALUE_ACCESSOR,\n    { provide: NX_INPUT_VALUE_ACCESSOR, useExisting: NxMaskDirective },\n    NX_MASK_VALIDATORS\n  ]\n})\nexport class NxMaskDirective implements ControlValueAccessor, Validator {\n\n  private _mask: string;\n  private _separators = ['/', '(', ')', '.', ':', '-', ' ', '+', ','];\n  private _dropSpecialCharacters: boolean = false;\n  private _validateMask: boolean = true;\n  private _convertTo?: MaskConversionTypes;\n\n  /**\n   * _cursor is a helper for saving a position or a selectionRange (selectionStart + selectionEnd)\n   * and then apply it later on (in _onInputChange()).\n   *\n   * _cursor.position is used for saving a position that is then applied without any changes.\n   * if the position is saved, selectionStart and selectionEnd will be ignored in _onInputChange().\n   * _cursor.selectionStart and selectionEnd is used for saving the current cursor position,\n   * and a new cursor position is then calculated with this data.\n   */\n  private _cursor: CursorInfo;\n\n  /** helper variable for saving the current value of the input element to compare it then with a new value. */\n  private _inputValue: string;\n\n  /** helper variable for saving the masked string of a pasted value and then applying it in _onInputChange(). */\n  private _pastedData: string;\n\n  /**\n   * Emits the unmasked value before the value changes.\n   */\n  readonly cvaModelChange = new Subject<string>();\n\n  private _onChangeCallback = (_: any) => { };\n  private _onTouchedCallback = () => { };\n  private _validatorOnChange = () => {};\n\n  private _callOnChangeCallback() {\n    if (!this.dropSpecialCharacters) {\n      this._onChangeCallback(this._elementRef.nativeElement.value);\n    } else {\n      this._onChangeCallback(this.getUnmaskedValue());\n    }\n  }\n\n  private _afterInputHook = (event: KeyboardEvent) => { };\n  private _beforePasteHook = (event: ClipboardEvent) => { };\n\n  /**\n   * Registers a function to be executed after the onInput handler.\n   * The registered hook receives a `KeyboardEvent` from the onInput event handler as a parameter.\n   *\n   * **Note:** If you register a `afterInputHook`, you may also register a `beforePasteHook`\n   * to perform similar changes for pasting.\n   */\n  registerAfterInputHook(afterInput: (event: KeyboardEvent) => void): void {\n    this._afterInputHook = afterInput;\n  }\n\n  /**\n   * Registers a function to be executed before the onPaste handler.\n   * The registered hook receives a `ClipboardEvent` from the onPaste event handler as a parameter.\n   */\n  registerBeforePasteHook(beforePaste: (event: ClipboardEvent) => void): void {\n    this._beforePasteHook = beforePaste;\n  }\n\n  /** Sets the mask. */\n  @Input('nxMask')\n  set mask(value: string) {\n    if (!value) {\n      value = '';\n    }\n    if (value !== this._mask) {\n      this._mask = value;\n      this.updateValue(this.getMaskedString(this._elementRef.nativeElement.value));\n      this._callOnChangeCallback();\n      this._validatorOnChange();\n    }\n  }\n  get mask(): string {\n    return this._mask;\n  }\n\n  /**\n   * Sets the mask (for programmatical use).\n   *\n   * No `_onChangeCallback()` will be called!\n   */\n  setMask(value: string) {\n    if (!value) {\n      value = '';\n    }\n    if (value !== this._mask) {\n      this._mask = value;\n      this.updateValue(this.getMaskedString(this._elementRef.nativeElement.value));\n      this._validatorOnChange();\n    }\n  }\n\n  /** Sets the case sensitivity of the mask. */\n  @Input('nxConvertTo')\n  set convertTo(value: MaskConversionTypes) {\n    this._convertTo = value;\n    this.updateValue(this.getMaskedString(this._elementRef.nativeElement.value));\n    this._callOnChangeCallback();\n  }\n  get convertTo() {\n    return this._convertTo;\n  }\n\n  /**\n   * Sets the keys that are recognized as separators.\n   * Default separators: / ( ) . : - + , and space.\n   */\n  @Input()\n  set separators(values: string[]) {\n    this._separators = values;\n    this.updateValue(this.getMaskedString(this._elementRef.nativeElement.value));\n    this._validatorOnChange();\n    this._callOnChangeCallback();\n  }\n  get separators(): string[] {\n    return this._separators;\n  }\n\n  /** Whether the separators should be dropped in the control value accessor. */\n  @Input()\n  set dropSpecialCharacters(value: boolean) {\n    const newValue = coerceBooleanProperty(value);\n    if (newValue !== this._dropSpecialCharacters) {\n      this._dropSpecialCharacters = newValue;\n      this.updateValue(this.getMaskedString(this._elementRef.nativeElement.value));\n      this._callOnChangeCallback();\n    }\n  }\n  get dropSpecialCharacters(): boolean {\n    return this._dropSpecialCharacters;\n  }\n\n  /** Whether the mask validation should be applied on the input. Default: true. */\n  @Input()\n  set validateMask(value: boolean) {\n    const newValue = coerceBooleanProperty(value);\n    if (newValue !== this._validateMask) {\n      this._validateMask = newValue;\n      this._validatorOnChange();\n    }\n  }\n  get validateMask(): boolean {\n    return this._validateMask;\n  }\n\n  constructor(\n    private _elementRef: ElementRef\n  ) {}\n\n  /** @docs-private */\n  get elementRefValue(): string {\n    return this._elementRef.nativeElement.value;\n  }\n\n  /** Returns the unmasked value. */\n  getUnmaskedValue(): string {\n    const unmaskedValue = this.separators.reduce(function(unmasked, separator) {\n      return unmasked.split(separator).join('');\n    }, this._elementRef.nativeElement.value);\n\n    return unmaskedValue;\n  }\n\n  /**\n   * this._cursor can be set to a new value in this function;\n   * in _onInputChange() it is then used to set the cursor position.\n   */\n  _onKeydown(event: KeyboardEvent) {\n    const keyCode = event.keyCode;\n\n    const input: HTMLInputElement = event.target as HTMLInputElement;\n    const currentValue = this._elementRef.nativeElement.value;\n\n    if (keyCode === BACKSPACE || keyCode === DELETE) {\n      // if backspace pressed, cursor has to move one character to start\n      const backspaceShift = keyCode === BACKSPACE ? 1 : 0;\n      const lastCharacter = currentValue.substring(input.selectionStart - backspaceShift, input.selectionEnd - backspaceShift + 1);\n      const selectionAtLastCharacter = (input.selectionStart === currentValue.length - 1 + backspaceShift);\n\n      if (input.selectionStart !== input.selectionEnd) {\n        let newPosition = input.selectionStart;\n        // jump behind separators, but do not shift after the next character (=> don't use _calculateCursorShift())\n        while (this.isSeparator(this.mask[newPosition])) {\n          newPosition++;\n        }\n        this._cursor = { position: newPosition };\n      } else if (selectionAtLastCharacter) {\n        // if last character is deleted: only delete last character, do not trigger input event again\n        // (here the separator would be added again)\n        this.updateValue(currentValue.substring(0, currentValue.length - 1));\n        this._callOnChangeCallback();\n        event.preventDefault();\n      } else if (this.isSeparator(lastCharacter)) {\n        // do not delete a separator, only set cursor position\n        input.setSelectionRange(input.selectionStart - backspaceShift, input.selectionEnd - backspaceShift);\n        event.preventDefault();\n      } else {\n        // for any other character: decrease cursor position by one (backspaceShift).\n        // the input is modified and will be validated in _onInputChange().\n        this._cursor = { position: input.selectionStart - backspaceShift };\n      }\n    } else {\n      this._cursor = { selectionStart: input.selectionStart, selectionEnd: input.selectionEnd };\n    }\n  }\n\n  /**\n   * Returns the cursor position after a letter is entered at `selectionStart` position in the mask.\n   * There are two cases to consider ('|' => cursor position where the character is entered, mask: 00:00:00):\n   * - before the separators there is space for entering the letter: '12:3|4:5' => '12:30:|45'\n   * - the letter has to be shifted and is entered after the separators: '12:34|:5' => '12:34:0|5'\n   */\n  private _calculateCursorShift(position: number): number {\n    let shift = 0;\n    // tracks if the entered letter was already placed in the current mask\n    // and therefor was considered in the cursor calculation.\n    let characterWasEntered = false;\n\n    if (!this.isSeparator(this.mask[position + shift])) {\n      shift++;\n      characterWasEntered = true;\n    }\n\n    while (this.isSeparator(this.mask[position + shift])) {\n      shift++;\n    }\n\n    if (!characterWasEntered) {\n      shift++;\n    }\n\n    return shift;\n  }\n\n  private _isStringAllowed(value: string, maskedValue: MASK_TYPE) {\n    if ((maskedValue === '0' && /^[0-9]{1}$/.test(value))\n          || (maskedValue === 'A' && /^[a-zA-Z0-9]{1}$/.test(value))\n          || (maskedValue === 'S' && /^[a-zA-Z]{1}$/.test(value))) {\n\n      return true;\n    }\n    return false;\n  }\n\n  /**\n   * Handles the onInput event.\n   * `_beforeInputHook()` is called before the actual execution.\n   *\n   */\n  _onInputChange(event: KeyboardEvent) {\n    // _inputValue is updated in updateValue(), so I need to pick it up here to compare it to a new value\n    const oldVal = this._inputValue;\n    const input: HTMLInputElement = event.target as HTMLInputElement;\n    const newVal = this.getMaskedString(input.value);\n\n    // if _pastedData was set in _onPaste(), use this value\n    if (this._pastedData) {\n      this.updateValue(this._pastedData);\n      input.setSelectionRange(this._cursor.position, this._cursor.position);\n      this._pastedData = null;\n      this._cursor = null;\n      this._callOnChangeCallback();\n      return;\n    }\n\n    // do nothing if mask is already filled up\n    if (oldVal.length === this._mask.length\n        && newVal.length === this._mask.length\n        && oldVal !== newVal\n        && (this._cursor\n              && this._cursor.selectionStart !== undefined\n              && this._cursor.selectionStart === this._cursor.selectionEnd)) {\n\n      this._elementRef.nativeElement.value = this.getMaskedString(oldVal);\n      input.setSelectionRange(this._cursor.selectionStart, this._cursor.selectionEnd);\n      this._cursor = null;\n      return;\n    }\n\n    this.updateValue(newVal);\n\n    // set new cursor position\n    if (this._cursor && this._cursor.position !== undefined) {\n      input.setSelectionRange(this._cursor.position, this._cursor.position);\n      this._cursor = null;\n    } else if (this._cursor && this._cursor.selectionStart !== undefined) {\n      // only one character can be entered (except pasting, this is calculated in _onPaste())\n      if (oldVal !== input.value) {\n        const newPosition = this._cursor.selectionStart + this._calculateCursorShift(this._cursor.selectionStart);\n        input.setSelectionRange(newPosition, newPosition);\n        this._cursor = null;\n      } else {\n        // we always have to set the cursor position here even if nothing changed\n        // because otherwise the cursor would jump to the end of the input.\n        // if the cursor is placed in front of a separator and the user types a non-allowed character,\n        // the cursor is supposed to jump over the separator.\n        let currentPosition = this._cursor.selectionStart;\n        while (this.isSeparator(this.mask[currentPosition])) {\n          currentPosition++;\n        }\n        input.setSelectionRange(currentPosition, currentPosition);\n        this._cursor = null;\n      }\n    }\n\n    this._afterInputHook(event);\n    this._callOnChangeCallback();\n  }\n\n  /**\n   * this._cursor and this._pastedData can be set to a new value in this function;\n   * _cursor is used to set the cursor position after checking the masked input in _onInputChange().\n   * _pastedData carries the valid part of the pasted value to _inInputChange();\n   *\n   *`_beforePasteHook()` is called before the actual execution.\n   */\n  _onPaste(event: ClipboardEvent) {\n    const input: HTMLInputElement = event.target as HTMLInputElement;\n    const pastedData = (event.clipboardData || (<any> window).clipboardData).getData('text');\n\n    // saving these three values as if something is changed in the _beforePasteHook()\n    // which causes the input value to be updated, this values will get lost.\n    const selectionStart = input.selectionStart;\n    const selectionEnd = input.selectionEnd;\n    const oldValue = input.value;\n\n    this._beforePasteHook(event);\n\n    const maskedString = this.getMaskedString(pastedData, selectionStart);\n\n    // if mask is already filled up (and no characters are selected with the cursor), do nothing\n    if (input.value.length === this._mask.length\n      && maskedString.length > 0\n      && selectionStart === selectionEnd) {\n\n      input.setSelectionRange(selectionStart, selectionEnd);\n      this._cursor = null;    // was set in _onKeydown(), but will not be used in this case; so reset it\n      event.preventDefault();\n      return;\n    }\n\n    // if length of newValue is >= mask: allow only to enter characters from a pasted value until mask is filled up\n    // example: 12:|34: (\"|\" cursor position, mask: 00:00:00) => when pasting '567', only '56' fits in until input is filled up => 12:56:|34\n    // get the pasted unmasked value from the pasted string (to cut all the invalid characters and separators)\n    const pastedUnmaskedValue = this.separators.reduce(\n      (unmasked, separator) => unmasked.split(separator).join(''), maskedString\n    );\n\n    let newValue: string = this.getMaskedString(\n      oldValue.substring(0, selectionStart)\n      + pastedUnmaskedValue\n      + oldValue.substring(selectionEnd, oldValue.length)\n    );\n\n    if (newValue.length >= this._mask.length) {\n      let newPosition = selectionStart;\n\n      let i = 1;\n      do {\n        newValue = this.getMaskedString(\n          oldValue.substring(0, selectionStart)\n          + pastedUnmaskedValue.substring(0, i)\n          + oldValue.substring(selectionEnd, oldValue.length)\n        );\n        newPosition += this._calculateCursorShift(newPosition);\n\n        i++;\n      } while (newValue.length < this._mask.length);\n\n      // save value for using it in _onInputChange()\n      this._pastedData = newValue;\n      this._cursor = {\n        position: newPosition\n      };\n      return;\n    }\n\n    // if pasting is fine: save the cursor position for using them in _onInputChange()\n    this._cursor = {\n      position: selectionStart + maskedString.length\n    };\n  }\n\n  private updateValue(value: string) {\n    // Write UpperCase\n    if (this._convertTo === 'upper') {\n      value = value.toUpperCase();\n    } else if (this._convertTo === 'lower') {\n      value = value.toLowerCase();\n    }\n    this._elementRef.nativeElement.value = value;\n\n    // _inputValue is needed for calculating the cursor shift in onInput()\n    this._inputValue = value;\n  }\n\n  /** @docs-private */\n  getMaskedString(inputValue: string, maskStartIndex: number = 0): string {\n    let formattedValue = '';\n    let maskIndex = maskStartIndex;\n    let inputIndex = 0;\n\n    // insert if next in mask is separator\n    while (this.isSeparator(this.mask[maskIndex])) {\n      formattedValue += this.mask[maskIndex];\n      maskIndex++;\n    }\n\n    while (inputIndex < inputValue.length) {\n      // test if letters are valid\n      if (this._isStringAllowed(inputValue[inputIndex], this.mask[maskIndex] as MASK_TYPE)) {\n        formattedValue += inputValue[inputIndex];\n        inputIndex++;\n        maskIndex++;\n      } else {\n        inputIndex++;\n      }\n\n      // insert if next in mask is separator\n      while (this.isSeparator(this.mask[maskIndex])) {\n        formattedValue += this.mask[maskIndex];\n        maskIndex++;\n      }\n    }\n\n    return formattedValue;\n  }\n\n  private isSeparator(value: string): boolean {\n    return (this._separators.indexOf(value) !== -1);\n  }\n\n  // control value accessor\n  writeValue(value: any): void {\n    if (!value) {\n      value = '';\n    }\n\n    this.cvaModelChange.next(value);\n    this.updateValue(this.getMaskedString(value));\n  }\n\n  registerOnChange(onChange: any): void {\n    this._onChangeCallback = onChange;\n  }\n\n  registerOnTouched(onTouched: any): void {\n    this._onTouchedCallback = onTouched;\n  }\n\n  /** @docs-private */\n  registerOnValidatorChange(fn: () => void): void {\n    this._validatorOnChange = fn;\n  }\n\n  _validateFn() {\n    const inputLength = this._elementRef.nativeElement.value.length;\n    const maskLength = this._mask.length;\n    if (inputLength !== maskLength) {\n      return { nxMaskLengthError: {'length': maskLength, 'actual': inputLength} };\n    }\n    return null;\n  }\n\n  /** @docs-private */\n  validate() {\n    return this.validateMask ? this._validateFn() : null;\n  }\n\n  _touch() {\n    this._onTouchedCallback();\n  }\n}\n","import { Directive, ElementRef, Inject, forwardRef, OnInit } from '@angular/core';\nimport * as IBAN from 'iban';\nimport { NG_VALIDATORS } from '@angular/forms';\nimport { Validator } from '@angular/forms';\n\nimport { NxMaskDirective } from './mask.directive';\n\nexport const NX_IBAN_MASK_VALIDATORS: any = {\n  provide: NG_VALIDATORS,\n  useExisting: forwardRef(() => NxIbanMaskDirective),\n  multi: true\n};\n\n/**\n * To use the `NxIbanMaskDirective`, you have to install the **peer dependency** `iban.js`.\n */\n@Directive({\n  selector: 'input[nxIbanMask]',\n  exportAs: 'nxIbanMaskDirective',\n  providers: [\n    NX_IBAN_MASK_VALIDATORS\n  ]\n})\nexport class NxIbanMaskDirective implements OnInit, Validator {\n\n  private _countryCode: string;\n\n  constructor(\n    private _elementRef: ElementRef,\n    @Inject(forwardRef(() => NxMaskDirective)) private maskDirective: NxMaskDirective\n  ) {\n    this.maskDirective.registerAfterInputHook(this._afterInputHook);\n    this.maskDirective.registerBeforePasteHook(this._beforePasteHook);\n\n    this.maskDirective.cvaModelChange.subscribe((value: string) => {\n      const enteredCountryCode = this.maskDirective.getMaskedString(value).substr(0, 2);\n      this._setCountryCode(enteredCountryCode);\n    });\n  }\n\n  private _afterInputHook = (event: KeyboardEvent) => {\n    const input = event.target as HTMLInputElement;\n    this._setCountryCode(input.value.substr(0, 2));\n  }\n\n  private _beforePasteHook = (event: ClipboardEvent) => {\n    // change the country code here if necessary\n    const input: HTMLInputElement = event.target as HTMLInputElement;\n    const pastedData = (event.clipboardData || (<any> window).clipboardData).getData('text');\n\n    const enteredCountryCode = (\n      this.maskDirective.elementRefValue.substr(0, input.selectionStart)\n      + this.maskDirective.getMaskedString(pastedData, input.selectionStart)\n    ).substr(0, 2);\n\n    this._setCountryCode(enteredCountryCode);\n  }\n\n  private _setCountryCode(code: string): void {\n    code = code.toUpperCase();\n    if (code.length === 2 && this._countryCode !== code) {\n      if (this._countryCodeExists(code)) {\n        this._countryCode = code;\n        this.maskDirective.setMask(this._getMask(this._countryCode));\n      } else {\n        this._countryCode = null;\n        this.maskDirective.setMask('SS');\n      }\n    }\n  }\n\n  ngOnInit(): void {\n    // set only first two letters as I don't know a country yet\n    this.maskDirective.mask = 'SS';\n    this.maskDirective.convertTo = 'upper';\n  }\n\n  private _getMask(countryCode: string) {\n    // the countrySpecs of a country contain: countryCode (\"DE\"), length (22), structure (\"F08F10\")\n    // and an example belonging to each country\n    const countrySpecs = IBAN['countries'][countryCode];\n\n    // 'SS' for country code + '00' for IBAN checksum\n    let mask = 'SS00';\n\n    // split up after every third character\n    const characterDefs = countrySpecs['structure'].match(/.{1,3}/g);\n\n    characterDefs.forEach(charDef => {\n      const character = charDef[0];\n      const count = Number(charDef.substring(1, 3));\n\n      switch (character) {\n        // [0-9]\n        case 'F': mask = mask + '0'.repeat(count); break;\n        // [0-9A-Za-z]\n        case 'A': mask = mask + 'A'.repeat(count); break;\n        // [A-Z]\n        // 'S' in nxMask does accept also [a-z].\n        // There is no option for only accepting capital letters at the moment.\n        case 'U': mask = mask + 'S'.repeat(count); break;\n      }\n    });\n\n    // insert whitespaces after every 4 characters\n    mask = mask.match(/.{1,4}/g).join(' ');\n\n    return mask;\n  }\n\n  private _countryCodeExists(countryCode: string): boolean {\n    return (!!IBAN['countries'][countryCode]);\n  }\n\n  private _validateFn() {\n    const enteredCountryCode = this._elementRef.nativeElement.value.substr(0, 2);\n    if (enteredCountryCode.length === 2 && !this._countryCodeExists(enteredCountryCode)) {\n      // immediately show error to user\n      this.maskDirective._touch();\n      return { nxIbanInvalidCountryError: 'no valid country code'};\n    }\n    if (!IBAN.isValid(this.maskDirective.getUnmaskedValue())) {\n      return { nxIbanParseError: 'no valid iban'};\n    }\n    return null;\n  }\n\n  /** @docs-private */\n  validate() {\n    return this.maskDirective.validateMask ? this._validateFn() : null;\n  }\n}\n","import { CommonModule } from '@angular/common';\nimport { NgModule } from '@angular/core';\n\nimport { NxFormfieldModule } from '@allianz/ngx-ndbx/formfield';\nimport { NxMaskDirective } from './mask.directive';\nimport { NxIbanMaskDirective } from './iban-mask.directive';\n\n@NgModule({\n  imports: [\n    CommonModule,\n    NxFormfieldModule\n  ],\n  declarations: [\n    NxMaskDirective,\n    NxIbanMaskDirective\n  ],\n  exports: [\n    NxFormfieldModule,\n    NxMaskDirective,\n    NxIbanMaskDirective\n  ]\n})\nexport class NxMaskModule { }\n"]}