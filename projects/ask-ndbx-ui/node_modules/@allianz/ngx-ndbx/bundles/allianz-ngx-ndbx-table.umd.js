(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@angular/common'), require('@angular/core'), require('@allianz/ngx-ndbx/icon'), require('@angular/cdk/coercion'), require('@angular/cdk/keycodes'), require('@angular/animations'), require('rxjs'), require('rxjs/operators')) :
    typeof define === 'function' && define.amd ? define('@allianz/ngx-ndbx/table', ['exports', '@angular/common', '@angular/core', '@allianz/ngx-ndbx/icon', '@angular/cdk/coercion', '@angular/cdk/keycodes', '@angular/animations', 'rxjs', 'rxjs/operators'], factory) :
    (global = global || self, factory((global.allianz = global.allianz || {}, global.allianz['ngx-ndbx'] = global.allianz['ngx-ndbx'] || {}, global.allianz['ngx-ndbx'].table = {}), global.ng.common, global.ng.core, global.allianz['ngx-ndbx'].icon, global.ng.cdk.coercion, global.ng.cdk.keycodes, global.ng.animations, global.rxjs, global.rxjs.operators));
}(this, (function (exports, common, core, icon, coercion, keycodes, animations, rxjs, operators) { 'use strict';

    /**
     * @fileoverview added by tsickle
     * Generated from: table-cell.component.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * This is a table cell.
     */
    var NxTableCellComponent = /** @class */ (function () {
        function NxTableCellComponent() {
        }
        NxTableCellComponent.decorators = [
            { type: core.Component, args: [{
                        // tslint:disable-next-line:component-selector
                        selector: 'td[nxTableCell], td[nxCell]',
                        template: '<ng-content></ng-content>',
                        host: {
                            '[class.nx-table-cell]': 'true',
                        },
                        changeDetection: core.ChangeDetectionStrategy.OnPush
                    }] }
        ];
        return NxTableCellComponent;
    }());

    /**
     * @fileoverview added by tsickle
     * Generated from: header-cell.directive.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * This is a table header cell.
     */
    var NxHeaderCellDirective = /** @class */ (function () {
        function NxHeaderCellDirective() {
        }
        NxHeaderCellDirective.decorators = [
            { type: core.Directive, args: [{
                        selector: '[nxHeaderCell]',
                        host: {
                            '[class.nx-header-cell]': 'true'
                        }
                    },] }
        ];
        return NxHeaderCellDirective;
    }());

    /**
     * @fileoverview added by tsickle
     * Generated from: table.component.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * This is a table.
     * The table supports a `zebra` and a `condensed` mode.
     */
    var NxTableComponent = /** @class */ (function () {
        function NxTableComponent(_changeDetectorRef) {
            this._changeDetectorRef = _changeDetectorRef;
        }
        Object.defineProperty(NxTableComponent.prototype, "condensed", {
            get: /**
             * @return {?}
             */
            function () {
                return this._condensed;
            },
            /** Change the table mode to condensed  */
            set: /**
             * Change the table mode to condensed
             * @param {?} value
             * @return {?}
             */
            function (value) {
                /** @type {?} */
                var newValue = coercion.coerceBooleanProperty(value);
                if (value !== this._condensed) {
                    this._condensed = newValue;
                    this._changeDetectorRef.markForCheck();
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NxTableComponent.prototype, "zebra", {
            get: /**
             * @return {?}
             */
            function () {
                return this._zebra;
            },
            /** Change the table mode to zebra  */
            set: /**
             * Change the table mode to zebra
             * @param {?} value
             * @return {?}
             */
            function (value) {
                /** @type {?} */
                var newValue = coercion.coerceBooleanProperty(value);
                if (value !== this._zebra) {
                    this._zebra = newValue;
                    this._changeDetectorRef.markForCheck();
                }
            },
            enumerable: true,
            configurable: true
        });
        NxTableComponent.decorators = [
            { type: core.Component, args: [{
                        // tslint:disable-next-line:component-selector
                        selector: 'table[nxTable]',
                        template: '<ng-content></ng-content>',
                        host: {
                            'class': 'nx-table',
                            '[class.nx-table--condensed]': 'condensed',
                            '[class.nx-table--zebra]': 'zebra'
                        },
                        changeDetection: core.ChangeDetectionStrategy.OnPush,
                        styles: [":host{border-spacing:0;border-bottom:2px solid #414141;border-bottom:2px solid var(--table-border-bottom-color,#414141);width:100%}::ng-deep .nx-header-cell{font-size:16px;font-size:var(--table-header-cell-font-size,16px);line-height:24px;line-height:var(--table-header-cell-line-height,24px);font-weight:600;font-weight:var(--table-header-cell-font-weight,600);letter-spacing:0;letter-spacing:var(--table-header-cell-letter-spacing,0);color:#414141;color:var(--table-header-cell-color,#414141);background:0 0;background:var(--table-header-cell-background-color,transparent);border-top:1px solid #d9d9d9;border-top:1px solid var(--table-header-border-top-color,#d9d9d9);border-bottom:2px solid #414141;border-bottom:2px solid var(--table-header-border-bottom-color,#414141);text-align:left;white-space:nowrap;vertical-align:top;padding:16px 16px 14px}::ng-deep .nx-header-cell:first-child{padding-left:8px}::ng-deep .nx-header-cell:last-child{padding-right:8px}::ng-deep .nx-table-row{background:0 0;background:var(--table-row-background-color,transparent)}::ng-deep .nx-table-cell{font-size:16px;font-size:var(--table-cell-font-size,16px);line-height:24px;line-height:var(--table-cell-line-height,24px);font-weight:400;font-weight:var(--table-cell-font-weight,400);letter-spacing:0;letter-spacing:var(--table-cell-letter-spacing,0);color:#414141;color:var(--table-cell-color,#414141);border-top:1px solid #d9d9d9;border-top:1px solid var(--table-cell-border-top-color,#d9d9d9);padding:16px 16px 15px}::ng-deep .nx-table-cell:first-child{padding-left:8px}::ng-deep .nx-table-cell:last-child{padding-right:8px}:host(.nx-table--condensed) ::ng-deep .nx-table-cell{padding-bottom:7px;padding-top:8px}:host(.nx-table--zebra) ::ng-deep .nx-table-cell{border-top:1px solid #f5f5f5;border-top:1px solid var(--zebra-table-cell-border-top-color,#f5f5f5)}:host(.nx-table--zebra) ::ng-deep .nx-table-cell--expandable{border-top:0}:host(.nx-table--condensed) ::ng-deep .nx-table-cell--expandable{padding-bottom:0;padding-top:0}:host(.nx-table--condensed) ::ng-deep .nx-table-cell--expandable .nx-table-cell__wrapper{padding-bottom:7px;padding-top:8px}::ng-deep .nx-expandable-table-cell{font-size:16px;font-size:var(--table-cell-font-size,16px);line-height:24px;line-height:var(--table-cell-line-height,24px);font-weight:400;font-weight:var(--table-cell-font-weight,400);letter-spacing:0;letter-spacing:var(--table-cell-letter-spacing,0);color:#414141;color:var(--table-cell-color,#414141)}::ng-deep .nx-expandable-table-cell__content{overflow:hidden}::ng-deep .nx-expandable-table-cell__wrapper{padding:16px}::ng-deep .nx-expandable-table-cell:first-child .nx-cell__wrapper{padding-left:8px}::ng-deep .nx-expandable-table-cell:last-child .nx-cell__wrapper{padding-right:8px}:host(.nx-table--condensed) ::ng-deep .nx-expandable-table-cell .nx-expandable-table-cell__wrapper{padding-bottom:7px;padding-top:8px}:host(.nx-table--zebra) ::ng-deep .nx-expandable-table-row:nth-child(4n){background:#f5f5f5;background:var(--zebra-table-even-row-background-color,#f5f5f5)}:host(.nx-table--zebra) ::ng-deep .nx-expandable-table-row:nth-child(4n)+.nx-table-row:not(.is-selected){background:0 0;background:var(--zebra-table-odd-row-background-color,transparent)}:host(.nx-table--zebra) ::ng-deep .nx-expandable-table-row:nth-child(4n+2){background:0 0;background:var(--zebra-table-odd-row-background-color,transparent)}:host(.nx-table--zebra) ::ng-deep .nx-expandable-table-row:nth-child(4n+2)+.nx-table-row:not(.is-selected){background:#f5f5f5;background:var(--zebra-table-even-row-background-color,#f5f5f5)}:host(.nx-table--zebra) ::ng-deep .nx-table-row:nth-child(2n){background:#f5f5f5;background:var(--zebra-table-even-row-background-color,#f5f5f5)}:host(.nx-table--zebra) ::ng-deep .nx-table-row.nx-table-row--selectable:not(.is-selected):hover{background:#ececec;background:var(--zebra-table-row-hover-background-color,#ececec)}:host(.nx-table--zebra) ::ng-deep .nx-table-row.nx-table-row--selectable:not(.is-selected):active{background:#d9d9d9;background:var(--zebra-table-row-active-background-color,#d9d9d9)}:host(.nx-table--zebra) ::ng-deep .nx-table-row.nx-table-row--selectable.is-selected:hover{background:#cfe9ee;background:var(--selectable-table-row-selected-hover-background-color,#cfe9ee)}::ng-deep .nx-table-row:first-child .nx-table-cell{border-top:0}::ng-deep .nx-table-row.nx-table-row--selectable{cursor:pointer}::ng-deep .nx-table-row.nx-table-row--selectable::-moz-focus-inner{border:0}::ng-deep .nx-table-row.nx-table-row--selectable:focus{outline:0}::ng-deep .nx-table-row.nx-table-row--selectable:not(.is-selected):hover{background:#f5f5f5;background:var(--selectable-table-row-hover-background-color,#f5f5f5)}::ng-deep .nx-table-row.nx-table-row--selectable:not(.is-selected):active{background:#f5f5f5;background:var(--selectable-table-row-active-background-color,#f5f5f5)}::ng-deep .nx-table-row.nx-table-row--selectable.is-selected:hover{background:#cfe9ee;background:var(--selectable-table-row-selected-hover-background-color,#cfe9ee)}::ng-deep .nx-table-row.is-selected,:host(.nx-table--zebra) ::ng-deep .nx-table-row.is-selected{background:#f1f9fa;background:var(--zebra-table-row-selected-background-color,#f1f9fa)}::ng-deep .nx-table-row.is-selected+.nx-expandable-table-row,:host(.nx-table--zebra) ::ng-deep .nx-table-row.is-selected+.nx-expandable-table-row{background:#f1f9fa;background:var(--zebra-table-row-selected-background-color,#f1f9fa)}::ng-deep .nx-table-row.is-selected+.nx-expandable-table-row+.nx-table-row>.nx-table-cell,::ng-deep .nx-table-row.is-selected+.nx-table-row>.nx-table-cell,::ng-deep .nx-table-row.is-selected>.nx-table-cell,:host(.nx-table--zebra) ::ng-deep .nx-table-row.is-selected+.nx-expandable-table-row+.nx-table-row>.nx-table-cell,:host(.nx-table--zebra) ::ng-deep .nx-table-row.is-selected+.nx-table-row>.nx-table-cell,:host(.nx-table--zebra) ::ng-deep .nx-table-row.is-selected>.nx-table-cell{border-color:#003781;border-color:var(--selectable-table-row-selected-border-color,#003781)}::ng-deep .nx-exandable-table-cell nx-checkbox,::ng-deep .nx-header-cell nx-checkbox,::ng-deep .nx-table-cell nx-checkbox{margin:0}::ng-deep .nx-exandable-table-cell nx-checkbox .nx-checkbox__label,::ng-deep .nx-header-cell nx-checkbox .nx-checkbox__label,::ng-deep .nx-table-cell nx-checkbox .nx-checkbox__label{padding:0}::ng-deep .nx-exandable-table-cell nx-taglist,::ng-deep .nx-header-cell nx-taglist,::ng-deep .nx-table-cell nx-taglist{margin:0}::ng-deep .nx-exandable-table-cell nx-taglist .nx-taglist__list-item,::ng-deep .nx-header-cell nx-taglist .nx-taglist__list-item,::ng-deep .nx-table-cell nx-taglist .nx-taglist__list-item{margin-bottom:0}::ng-deep .nx-exandable-table-cell button[nxbutton],::ng-deep .nx-header-cell button[nxbutton],::ng-deep .nx-table-cell button[nxbutton]{margin:0}::ng-deep .nx-exandable-table-cell nx-formfield .nx-formfield__wrapper,::ng-deep .nx-header-cell nx-formfield .nx-formfield__wrapper,::ng-deep .nx-table-cell nx-formfield .nx-formfield__wrapper{padding:0}::ng-deep .nx-exandable-table-cell [nxlist],::ng-deep .nx-header-cell [nxlist],::ng-deep .nx-table-cell [nxlist]{margin:0}::ng-deep .nx-exandable-table-cell [nxlist] li:last-child,::ng-deep .nx-header-cell [nxlist] li:last-child,::ng-deep .nx-table-cell [nxlist] li:last-child{margin-bottom:0}::ng-deep .nx-exandable-table-cell nx-link a,::ng-deep .nx-header-cell nx-link a,::ng-deep .nx-table-cell nx-link a{display:inline-flex}"]
                    }] }
        ];
        /** @nocollapse */
        NxTableComponent.ctorParameters = function () { return [
            { type: core.ChangeDetectorRef }
        ]; };
        NxTableComponent.propDecorators = {
            condensed: [{ type: core.Input }],
            zebra: [{ type: core.Input }]
        };
        return NxTableComponent;
    }());
    if (false) {
        /**
         * @type {?}
         * @private
         */
        NxTableComponent.prototype._condensed;
        /**
         * @type {?}
         * @private
         */
        NxTableComponent.prototype._zebra;
        /**
         * @type {?}
         * @private
         */
        NxTableComponent.prototype._changeDetectorRef;
    }

    /**
     * @fileoverview added by tsickle
     * Generated from: table-row.component.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * This is a table row.
     */
    var NxTableRowComponent = /** @class */ (function () {
        function NxTableRowComponent(_changeDetectorRef, _elementRef) {
            this._changeDetectorRef = _changeDetectorRef;
            this._elementRef = _elementRef;
            this._selectable = false;
            this._selected = false;
            this.select = new core.EventEmitter();
        }
        Object.defineProperty(NxTableRowComponent.prototype, "selectable", {
            get: /**
             * @return {?}
             */
            function () {
                return this._selectable;
            },
            /** Whether this table row is selectable */
            set: /**
             * Whether this table row is selectable
             * @param {?} value
             * @return {?}
             */
            function (value) {
                this._selectable = coercion.coerceBooleanProperty(value);
                this._changeDetectorRef.markForCheck();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NxTableRowComponent.prototype, "selected", {
            get: /**
             * @return {?}
             */
            function () {
                return this._selected;
            },
            /** Whether this table row is selected */
            set: /**
             * Whether this table row is selected
             * @param {?} value
             * @return {?}
             */
            function (value) {
                this._selected = coercion.coerceBooleanProperty(value);
                this._changeDetectorRef.markForCheck();
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @param {?} $event
         * @return {?}
         */
        NxTableRowComponent.prototype._onSelect = /**
         * @param {?} $event
         * @return {?}
         */
        function ($event) {
            if (!this._selectable || this.isActionEvent($event)) {
                return;
            }
            if ($event.keyCode === keycodes.SPACE) {
                $event.preventDefault();
            }
            this.select.emit();
        };
        /**
         * Checks if the event would trigger an action.
         * Return `true` if a button, link, input or label are clicked.
         */
        /**
         * Checks if the event would trigger an action.
         * Return `true` if a button, link, input or label are clicked.
         * @private
         * @param {?} $event
         * @return {?}
         */
        NxTableRowComponent.prototype.isActionEvent = /**
         * Checks if the event would trigger an action.
         * Return `true` if a button, link, input or label are clicked.
         * @private
         * @param {?} $event
         * @return {?}
         */
        function ($event) {
            /** @type {?} */
            var parent = $event.target;
            while (parent && parent !== this._elementRef.nativeElement) {
                if (['A', 'INPUT', 'BUTTON'].indexOf(parent.tagName) >= 0) {
                    return true;
                }
                else if (parent.tagName === 'LABEL' && parent.getAttribute('for')) {
                    return true;
                }
                parent = parent.parentElement;
            }
            return false;
        };
        NxTableRowComponent.decorators = [
            { type: core.Component, args: [{
                        // tslint:disable-next-line:component-selector
                        selector: 'tr[nxTableRow]',
                        host: {
                            'class': 'nx-table-row',
                            '[class.is-selected]': 'selected',
                            '[class.nx-table-row--selectable]': 'selectable',
                            '[attr.aria-selected]': 'selected',
                            '(click)': '_onSelect($event)',
                            '(keydown.space)': '_onSelect($event)'
                        },
                        template: "<ng-content></ng-content>",
                        changeDetection: core.ChangeDetectionStrategy.OnPush
                    }] }
        ];
        /** @nocollapse */
        NxTableRowComponent.ctorParameters = function () { return [
            { type: core.ChangeDetectorRef },
            { type: core.ElementRef }
        ]; };
        NxTableRowComponent.propDecorators = {
            selectable: [{ type: core.Input }],
            selected: [{ type: core.Input }],
            select: [{ type: core.Output }]
        };
        return NxTableRowComponent;
    }());
    if (false) {
        /**
         * @type {?}
         * @private
         */
        NxTableRowComponent.prototype._selectable;
        /**
         * @type {?}
         * @private
         */
        NxTableRowComponent.prototype._selected;
        /** @type {?} */
        NxTableRowComponent.prototype.select;
        /**
         * @type {?}
         * @protected
         */
        NxTableRowComponent.prototype._changeDetectorRef;
        /**
         * @type {?}
         * @private
         */
        NxTableRowComponent.prototype._elementRef;
    }

    /**
     * @fileoverview added by tsickle
     * Generated from: expandable/expandable-table-row.component.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * This is an expandable table row.
     * It can collapse its height to hide the content.
     * Requires the table cells to have the `[nxExpandableTableCell]` component.
     */
    var NxExpandableTableRowComponent = /** @class */ (function () {
        function NxExpandableTableRowComponent(_changeDetectorRef) {
            this._changeDetectorRef = _changeDetectorRef;
            this.expanded = new rxjs.BehaviorSubject(false);
        }
        /**
         * Toggles the expansion of this row.
         */
        /**
         * Toggles the expansion of this row.
         * @return {?}
         */
        NxExpandableTableRowComponent.prototype.toggle = /**
         * Toggles the expansion of this row.
         * @return {?}
         */
        function () {
            if (this.expanded.value) {
                this.close();
            }
            else {
                this.expand();
            }
        };
        /**
         * Expands this row.
         */
        /**
         * Expands this row.
         * @return {?}
         */
        NxExpandableTableRowComponent.prototype.expand = /**
         * Expands this row.
         * @return {?}
         */
        function () {
            if (!this.expanded.value) {
                this.expanded.next(true);
                this._changeDetectorRef.markForCheck();
            }
        };
        /**
         * Closes this row.
         */
        /**
         * Closes this row.
         * @return {?}
         */
        NxExpandableTableRowComponent.prototype.close = /**
         * Closes this row.
         * @return {?}
         */
        function () {
            if (this.expanded.value) {
                this.expanded.next(false);
                this._changeDetectorRef.markForCheck();
            }
        };
        NxExpandableTableRowComponent.decorators = [
            { type: core.Component, args: [{
                        // tslint:disable-next-line:component-selector
                        selector: 'tr[nxExpandableTableRow]',
                        host: {
                            'class': 'nx-expandable-table-row'
                        },
                        template: "<ng-content></ng-content>",
                        changeDetection: core.ChangeDetectionStrategy.OnPush
                    }] }
        ];
        /** @nocollapse */
        NxExpandableTableRowComponent.ctorParameters = function () { return [
            { type: core.ChangeDetectorRef }
        ]; };
        return NxExpandableTableRowComponent;
    }());
    if (false) {
        /** @type {?} */
        NxExpandableTableRowComponent.prototype.expanded;
        /**
         * @type {?}
         * @private
         */
        NxExpandableTableRowComponent.prototype._changeDetectorRef;
    }

    /**
     * @fileoverview added by tsickle
     * Generated from: expandable/expandable-table-cell.component.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * This is an expandable table cell.
     * Only works in conjunction with the `[nxExpandableTableRow]` component.
     */
    var NxExpandableTableCellComponent = /** @class */ (function () {
        function NxExpandableTableCellComponent(_row, _changeDetectorRef) {
            var _this = this;
            this._changeDetectorRef = _changeDetectorRef;
            this._destroyed = new rxjs.Subject();
            this._open = false;
            _row.expanded.pipe(operators.takeUntil(this._destroyed))
                .subscribe((/**
             * @param {?} open
             * @return {?}
             */
            function (open) {
                _this._open = open;
                _this._changeDetectorRef.markForCheck();
            }));
        }
        /**
         * @return {?}
         */
        NxExpandableTableCellComponent.prototype.ngOnDestroy = /**
         * @return {?}
         */
        function () {
            this._destroyed.next();
            this._destroyed.complete();
        };
        NxExpandableTableCellComponent.decorators = [
            { type: core.Component, args: [{
                        // tslint:disable-next-line:component-selector
                        selector: 'td[nxExpandableTableCell]',
                        template: "<div [@openClose]=\"_open ? 'open' : 'closed'\" class=\"nx-expandable-table-cell__content\">\n  <div class=\"nx-expandable-table-cell__wrapper\">\n    <ng-content></ng-content>\n  </div>\n</div>\n",
                        host: {
                            'class': 'nx-expandable-table-cell'
                        },
                        animations: [
                            animations.trigger('openClose', [
                                animations.state('open', animations.style({
                                    height: '*',
                                    visibility: 'visible'
                                })),
                                animations.state('closed, void', animations.style({
                                    height: '0',
                                    visibility: 'hidden' // visibility and height to toggle instead of display: none to prevent cell width jumping
                                })),
                                animations.transition('closed <=> open, void => closed', [
                                    animations.animate('225ms cubic-bezier(0.4,0.0,0.2,1)')
                                ])
                            ])
                        ],
                        changeDetection: core.ChangeDetectionStrategy.OnPush
                    }] }
        ];
        /** @nocollapse */
        NxExpandableTableCellComponent.ctorParameters = function () { return [
            { type: NxExpandableTableRowComponent },
            { type: core.ChangeDetectorRef }
        ]; };
        return NxExpandableTableCellComponent;
    }());
    if (false) {
        /**
         * @type {?}
         * @private
         */
        NxExpandableTableCellComponent.prototype._destroyed;
        /** @type {?} */
        NxExpandableTableCellComponent.prototype._open;
        /**
         * @type {?}
         * @private
         */
        NxExpandableTableCellComponent.prototype._changeDetectorRef;
    }

    /**
     * @fileoverview added by tsickle
     * Generated from: expandable/toggle-button.component.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * @record
     */
    function NxExpandable() { }
    if (false) {
        /**
         * Indicates if this expandable instance is open or not.
         * @type {?}
         */
        NxExpandable.prototype.expanded;
        /**
         * Toggles the open state.
         * @type {?}
         */
        NxExpandable.prototype.toggle;
        /**
         * Expands this component.
         * @type {?}
         */
        NxExpandable.prototype.expand;
        /**
         * Closes this component.
         * @type {?}
         */
        NxExpandable.prototype.close;
    }
    /**
     * This toggle button can be clicked and toggles expandable elements.
     * e.g. it can toggle a expandable table row or anything else that implements the `NxExpandable` interface.
     */
    var NxToggleButtonComponent = /** @class */ (function () {
        function NxToggleButtonComponent(_changeDetectorRef) {
            this._changeDetectorRef = _changeDetectorRef;
            this._expanded = false;
            this._ariaLabel = '';
        }
        Object.defineProperty(NxToggleButtonComponent.prototype, "target", {
            /**
             * This is the expandable target that will be toggled when the user clicks the button.
             */
            set: /**
             * This is the expandable target that will be toggled when the user clicks the button.
             * @param {?} value
             * @return {?}
             */
            function (value) {
                var _this = this;
                this._target = value;
                if (this._subscription) {
                    this._subscription.unsubscribe();
                }
                if (this._target) {
                    this._subscription = this._target.expanded.subscribe((/**
                     * @param {?} expanded
                     * @return {?}
                     */
                    function (expanded) {
                        _this._expanded = expanded;
                        _this._changeDetectorRef.markForCheck();
                    }));
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NxToggleButtonComponent.prototype, "ariaLabel", {
            set: /**
             * @param {?} value
             * @return {?}
             */
            function (value) {
                this._ariaLabel = value;
                this._changeDetectorRef.markForCheck();
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        NxToggleButtonComponent.prototype._onClick = /**
         * @return {?}
         */
        function () {
            if (this._target) {
                this._target.toggle();
            }
        };
        /**
         * @return {?}
         */
        NxToggleButtonComponent.prototype.ngOnDestroy = /**
         * @return {?}
         */
        function () {
            if (this._subscription) {
                this._subscription.unsubscribe();
            }
        };
        NxToggleButtonComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'nx-toggle-button',
                        template: "<button (click)=\"_onClick()\"\n    class=\"nx-toggle-button\"\n    [attr.aria-label]=\"_ariaLabel\"\n    [attr.aria-expanded]=\"_expanded\"\n    [class.is-expanded]=\"_expanded\">\n  <nx-icon name=\"chevron-down\"\n      aria-hidden=\"true\"\n      size=\"s\"\n      class=\"nx-toggle-button__icon\"></nx-icon>\n</button>\n",
                        changeDetection: core.ChangeDetectionStrategy.OnPush,
                        styles: [":host{display:block}.nx-toggle-button{display:block;cursor:pointer;-webkit-appearance:none;-moz-appearance:none;appearance:none;border:none;outline:0;background:0 0;padding:0;line-height:24px;height:24px}.nx-toggle-button .nx-toggle-button__icon{transform:rotateZ(0);transition:transform .2s;color:#414141;color:var(--expandable-table-arrow-icon-color,#414141)}.nx-toggle-button.is-expanded .nx-toggle-button__icon{transform:rotateZ(-180deg)}.nx-toggle-button::-moz-focus-inner{border:0}:host-context([data-whatinput=keyboard]) .nx-toggle-button:focus{border-radius:4px;box-shadow:0 0 0 2px #fff,0 0 0 6px #009de6;box-shadow:var(--focus-box-shadow,0 0 0 2px #fff,0 0 0 6px #009de6)}@media screen and (-ms-high-contrast:active){:host-context([data-whatinput=keyboard]) .nx-toggle-button:focus{box-shadow:0 0 0 2px background,0 0 0 6px windowText}}"]
                    }] }
        ];
        /** @nocollapse */
        NxToggleButtonComponent.ctorParameters = function () { return [
            { type: core.ChangeDetectorRef }
        ]; };
        NxToggleButtonComponent.propDecorators = {
            target: [{ type: core.Input }],
            ariaLabel: [{ type: core.Input }]
        };
        return NxToggleButtonComponent;
    }());
    if (false) {
        /** @type {?} */
        NxToggleButtonComponent.prototype._expanded;
        /** @type {?} */
        NxToggleButtonComponent.prototype._target;
        /** @type {?} */
        NxToggleButtonComponent.prototype._ariaLabel;
        /**
         * @type {?}
         * @private
         */
        NxToggleButtonComponent.prototype._subscription;
        /**
         * @type {?}
         * @private
         */
        NxToggleButtonComponent.prototype._changeDetectorRef;
    }

    /**
     * @fileoverview added by tsickle
     * Generated from: expandable/expandable-table.directive.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * The nxExpandableTable adds row expansion functionality to the nxTable.
     * It provides the logic to expand/collapse all expandable rows simultanously.
     */
    var NxExpandableTableDirective = /** @class */ (function () {
        function NxExpandableTableDirective() {
            this.expanded = new rxjs.BehaviorSubject(false);
        }
        /**
         * @return {?}
         */
        NxExpandableTableDirective.prototype.ngAfterViewInit = /**
         * @return {?}
         */
        function () {
            var _this = this;
            this.rows.changes.pipe(operators.startWith(this.rows), operators.flatMap((/**
             * @param {?} rows
             * @return {?}
             */
            function (rows) {
                return rxjs.combineLatest(rows.map((/**
                 * @param {?} row
                 * @return {?}
                 */
                function (row) { return row.expanded; })));
            })), operators.map((/**
             * @param {?} values
             * @return {?}
             */
            function (values) {
                return values.reduce((/**
                 * @param {?} a
                 * @param {?} x
                 * @return {?}
                 */
                function (a, x) { return a && x; }), true);
            })), operators.distinctUntilChanged())
                .subscribe((/**
             * @param {?} rowsOpen
             * @return {?}
             */
            function (rowsOpen) {
                _this.expanded.next(rowsOpen);
            }));
        };
        /**
         * Toggles the expandable rows. If all rows are open it will close them, otherwise it will open them.
         */
        /**
         * Toggles the expandable rows. If all rows are open it will close them, otherwise it will open them.
         * @return {?}
         */
        NxExpandableTableDirective.prototype.toggle = /**
         * Toggles the expandable rows. If all rows are open it will close them, otherwise it will open them.
         * @return {?}
         */
        function () {
            if (this.expanded.value) {
                this.close();
            }
            else {
                this.expand();
            }
        };
        /**
         * Expands all expandable rows.
         */
        /**
         * Expands all expandable rows.
         * @return {?}
         */
        NxExpandableTableDirective.prototype.expand = /**
         * Expands all expandable rows.
         * @return {?}
         */
        function () {
            this.rows.forEach((/**
             * @param {?} row
             * @return {?}
             */
            function (row) { return row.expanded.next(true); }));
        };
        /**
         * Closes all expandable rows.
         */
        /**
         * Closes all expandable rows.
         * @return {?}
         */
        NxExpandableTableDirective.prototype.close = /**
         * Closes all expandable rows.
         * @return {?}
         */
        function () {
            this.rows.forEach((/**
             * @param {?} row
             * @return {?}
             */
            function (row) { return row.expanded.next(false); }));
        };
        NxExpandableTableDirective.decorators = [
            { type: core.Directive, args: [{
                        selector: 'table[nxExpandableTable]',
                        exportAs: 'nxExpandableTable'
                    },] }
        ];
        NxExpandableTableDirective.propDecorators = {
            rows: [{ type: core.ContentChildren, args: [NxExpandableTableRowComponent, { descendants: true },] }]
        };
        return NxExpandableTableDirective;
    }());
    if (false) {
        /** @type {?} */
        NxExpandableTableDirective.prototype.rows;
        /** @type {?} */
        NxExpandableTableDirective.prototype.expanded;
    }

    /**
     * @fileoverview added by tsickle
     * Generated from: sort-header/sort.directive.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var SortEvent = /** @class */ (function () {
        function SortEvent(active, direction) {
            this.active = active;
            this.direction = direction;
        }
        return SortEvent;
    }());
    if (false) {
        /**
         * The name of the column that is being sorted by.
         * @type {?}
         */
        SortEvent.prototype.active;
        /**
         * The sort direction.
         * @type {?}
         */
        SortEvent.prototype.direction;
    }
    var NxSortDirective = /** @class */ (function () {
        function NxSortDirective() {
            this._stateChanges = new rxjs.Subject();
            this._direction = 'asc';
            /**
             * \@docs-private
             * An event emitted when the active value has changed.
             */
            this.activeChange = new core.EventEmitter();
            /**
             * \@docs-private
             * An event emitted when the direction value has changed.
             */
            this.directionChange = new core.EventEmitter();
            /**
             * An event emitted when either the active sort or sort direction changes.
             */
            this.sortChange = new core.EventEmitter();
        }
        Object.defineProperty(NxSortDirective.prototype, "active", {
            get: /**
             * @return {?}
             */
            function () {
                return this._active;
            },
            /** Sets the key of the most recently sorted column. */
            set: /**
             * Sets the key of the most recently sorted column.
             * @param {?} value
             * @return {?}
             */
            function (value) {
                if (this._active !== value) {
                    this._active = value;
                    this.sortChange.emit(new SortEvent(this.active, this.direction));
                    this._stateChanges.next();
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NxSortDirective.prototype, "direction", {
            get: /**
             * @return {?}
             */
            function () {
                return this._direction;
            },
            /** Sets the direction of the currently active sorted column. Default: 'asc'. */
            set: /**
             * Sets the direction of the currently active sorted column. Default: 'asc'.
             * @param {?} value
             * @return {?}
             */
            function (value) {
                if (this._direction !== value) {
                    this._direction = value;
                    this.sortChange.emit(new SortEvent(this.active, this.direction));
                    this._stateChanges.next();
                }
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        NxSortDirective.prototype.ngOnDestroy = /**
         * @return {?}
         */
        function () {
            this._stateChanges.complete();
        };
        /**
         * Sets the active sort key and determines the new sort direction.
         * Afterwards the output event `sortChange` is called.
         *
         * If `sortable` is not the key of the active sort header, the initial direction to sort is 'asc'.
         * Otherwise the direction of the sorted column changes.
         */
        /**
         * Sets the active sort key and determines the new sort direction.
         * Afterwards the output event `sortChange` is called.
         *
         * If `sortable` is not the key of the active sort header, the initial direction to sort is 'asc'.
         * Otherwise the direction of the sorted column changes.
         * @param {?} sortable
         * @return {?}
         */
        NxSortDirective.prototype.sort = /**
         * Sets the active sort key and determines the new sort direction.
         * Afterwards the output event `sortChange` is called.
         *
         * If `sortable` is not the key of the active sort header, the initial direction to sort is 'asc'.
         * Otherwise the direction of the sorted column changes.
         * @param {?} sortable
         * @return {?}
         */
        function (sortable) {
            if (this._active !== sortable) {
                this._active = sortable;
                this.activeChange.emit(this.active);
                this._direction = 'asc';
                this.directionChange.emit(this.direction);
            }
            else if (this._direction === 'asc') {
                this._direction = 'desc';
                this.directionChange.emit(this.direction);
            }
            else {
                this._direction = 'asc';
                this.directionChange.emit(this.direction);
            }
            this.sortChange.emit(new SortEvent(this.active, this.direction));
            this._stateChanges.next();
        };
        NxSortDirective.decorators = [
            { type: core.Directive, args: [{
                        selector: 'table[nxSort]',
                        exportAs: 'NxSortDirective'
                    },] }
        ];
        NxSortDirective.propDecorators = {
            active: [{ type: core.Input }],
            direction: [{ type: core.Input }],
            activeChange: [{ type: core.Output }],
            directionChange: [{ type: core.Output }],
            sortChange: [{ type: core.Output }]
        };
        return NxSortDirective;
    }());
    if (false) {
        /** @type {?} */
        NxSortDirective.prototype._stateChanges;
        /**
         * @type {?}
         * @private
         */
        NxSortDirective.prototype._active;
        /**
         * @type {?}
         * @private
         */
        NxSortDirective.prototype._direction;
        /**
         * \@docs-private
         * An event emitted when the active value has changed.
         * @type {?}
         */
        NxSortDirective.prototype.activeChange;
        /**
         * \@docs-private
         * An event emitted when the direction value has changed.
         * @type {?}
         */
        NxSortDirective.prototype.directionChange;
        /**
         * An event emitted when either the active sort or sort direction changes.
         * @type {?}
         */
        NxSortDirective.prototype.sortChange;
    }

    /**
     * @fileoverview added by tsickle
     * Generated from: sort-header/sort-header-intl.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var NxSortHeaderIntl = /** @class */ (function () {
        function NxSortHeaderIntl() {
            /**
             * Stream that emits whenever the labels here are changed. Use this to notify
             * components if the labels have changed after initialization.
             */
            this.changes = new rxjs.Subject();
            /**
             * The aria label for a header that can be sorted ascending.
             */
            this.sortAscendingAriaLabel = 'sort ascending by';
            /**
             * The aria label for a header that can be sorted descending.
             */
            this.sortDescendingAriaLabel = 'sort descending by';
        }
        NxSortHeaderIntl.decorators = [
            { type: core.Injectable }
        ];
        return NxSortHeaderIntl;
    }());
    if (false) {
        /**
         * Stream that emits whenever the labels here are changed. Use this to notify
         * components if the labels have changed after initialization.
         * @type {?}
         */
        NxSortHeaderIntl.prototype.changes;
        /**
         * The aria label for a header that can be sorted ascending.
         * @type {?}
         */
        NxSortHeaderIntl.prototype.sortAscendingAriaLabel;
        /**
         * The aria label for a header that can be sorted descending.
         * @type {?}
         */
        NxSortHeaderIntl.prototype.sortDescendingAriaLabel;
    }

    /**
     * @fileoverview added by tsickle
     * Generated from: sort-header/sort-header.component.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var NxSortHeaderComponent = /** @class */ (function () {
        function NxSortHeaderComponent(_sort, _intl, _changeDetectorRef) {
            var _this = this;
            this._sort = _sort;
            this._intl = _intl;
            this._changeDetectorRef = _changeDetectorRef;
            this._intlSubscription = this._intl.changes.subscribe((/**
             * @return {?}
             */
            function () { return _this._changeDetectorRef.markForCheck(); }));
        }
        Object.defineProperty(NxSortHeaderComponent.prototype, "key", {
            get: /**
             * @return {?}
             */
            function () {
                return this._key;
            },
            /** Sets the key of this sort header. */
            set: /**
             * Sets the key of this sort header.
             * @param {?} value
             * @return {?}
             */
            function (value) {
                if (this._key !== value) {
                    this._key = value;
                }
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        NxSortHeaderComponent.prototype.ngOnInit = /**
         * @return {?}
         */
        function () {
            var _this = this;
            this._parentChangeSubscription = this._sort._stateChanges.subscribe((/**
             * @return {?}
             */
            function () {
                _this._changeDetectorRef.markForCheck();
            }));
        };
        /**
         * @return {?}
         */
        NxSortHeaderComponent.prototype.ngOnDestroy = /**
         * @return {?}
         */
        function () {
            if (this._parentChangeSubscription) {
                this._parentChangeSubscription.unsubscribe();
            }
            this._intlSubscription.unsubscribe();
        };
        /**
         * @return {?}
         */
        NxSortHeaderComponent.prototype._handleClick = /**
         * @return {?}
         */
        function () {
            this._sort.sort(this._key);
        };
        /**
         * @param {?} $event
         * @return {?}
         */
        NxSortHeaderComponent.prototype._onKeydown = /**
         * @param {?} $event
         * @return {?}
         */
        function ($event) {
            if ($event && ($event.keyCode === keycodes.ENTER || $event.keyCode === keycodes.SPACE)) {
                this._sort.sort(this._key);
                // prevent page from scrolling down
                if ($event.keyCode === keycodes.SPACE) {
                    $event.preventDefault();
                }
            }
        };
        /**
         * @return {?}
         */
        NxSortHeaderComponent.prototype._isSortedAscending = /**
         * @return {?}
         */
        function () {
            return (this._sort.active === this._key && this._sort.direction === 'asc');
        };
        /**
         * @return {?}
         */
        NxSortHeaderComponent.prototype._isSortedDescending = /**
         * @return {?}
         */
        function () {
            return (this._sort.active === this._key && this._sort.direction === 'desc');
        };
        /**
         * @return {?}
         */
        NxSortHeaderComponent.prototype._getAriaLabel = /**
         * @return {?}
         */
        function () {
            if (this._sort.active === this._key && this._sort.direction === 'asc') {
                return "" + this._intl.sortDescendingAriaLabel;
            }
            return "" + this._intl.sortAscendingAriaLabel;
        };
        NxSortHeaderComponent.decorators = [
            { type: core.Component, args: [{
                        // tslint:disable-next-line:component-selector
                        selector: 'th[nxSortHeaderCell]',
                        exportAs: 'nxSortHeaderComponent',
                        template: "<div class=\"nx-sort-header__focus-container\" role=\"button\" tabindex=\"0\">\n  <div class=\"nx-sort-header__icons-container\"\n      [attr.aria-label]=\"_getAriaLabel()\">\n    <nx-icon name=\"chevron-up-small\"\n        class=\"nx-sort-header__icon-up\"\n        [class.nx-sort-header__hidden-icon]=\"_isSortedDescending()\">\n    </nx-icon>\n    <nx-icon name=\"chevron-down-small\"\n        class=\"nx-sort-header__icon-down\"\n        [class.nx-sort-header__hidden-icon]=\"_isSortedAscending()\">\n    </nx-icon>\n  </div>\n\n  <ng-content></ng-content>\n</div>\n",
                        host: {
                            '(click)': '_handleClick()',
                            '(keydown)': '_onKeydown($event)'
                        },
                        changeDetection: core.ChangeDetectionStrategy.OnPush,
                        styles: [":host{cursor:pointer}.nx-sort-header__icons-container{display:inline-block;margin-right:8px;vertical-align:bottom;width:24px;position:relative;height:24px}.nx-sort-header__icons-container nx-icon{font-size:20px;position:absolute;font-weight:600;width:24px}.nx-sort-header__icons-container .nx-sort-header__icon-up{top:-3px}.nx-sort-header__icons-container .nx-sort-header__icon-down{top:5px}.nx-sort-header__icons-container .nx-sort-header__hidden-icon{visibility:hidden}.nx-sort-header__focus-container{display:flex}.nx-sort-header__focus-container:focus{outline:0}:host-context([data-whatinput=keyboard]) .nx-sort-header__focus-container:focus{box-shadow:0 0 0 2px #fff,0 0 0 6px #009de6;box-shadow:var(--focus-box-shadow,0 0 0 2px #fff,0 0 0 6px #009de6);border-radius:4px}@media screen and (-ms-high-contrast:active){:host-context([data-whatinput=keyboard]) .nx-sort-header__focus-container:focus{box-shadow:0 0 0 2px background,0 0 0 6px windowText}.nx-sort-header__focus-container{color:buttonText}}"]
                    }] }
        ];
        /** @nocollapse */
        NxSortHeaderComponent.ctorParameters = function () { return [
            { type: NxSortDirective, decorators: [{ type: core.Optional }] },
            { type: NxSortHeaderIntl },
            { type: core.ChangeDetectorRef }
        ]; };
        NxSortHeaderComponent.propDecorators = {
            key: [{ type: core.Input, args: ['nxSortHeaderCell',] }]
        };
        return NxSortHeaderComponent;
    }());
    if (false) {
        /**
         * @type {?}
         * @private
         */
        NxSortHeaderComponent.prototype._parentChangeSubscription;
        /**
         * @type {?}
         * @private
         */
        NxSortHeaderComponent.prototype._intlSubscription;
        /**
         * @type {?}
         * @private
         */
        NxSortHeaderComponent.prototype._key;
        /** @type {?} */
        NxSortHeaderComponent.prototype._sort;
        /** @type {?} */
        NxSortHeaderComponent.prototype._intl;
        /**
         * @type {?}
         * @private
         */
        NxSortHeaderComponent.prototype._changeDetectorRef;
    }

    /**
     * @fileoverview added by tsickle
     * Generated from: table.module.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /** @type {?} */
    var EXPORTED_DECLARED_ELEMENTS = [
        NxHeaderCellDirective,
        NxTableComponent,
        NxTableCellComponent,
        NxTableComponent,
        NxTableRowComponent,
        NxToggleButtonComponent,
        NxExpandableTableDirective,
        NxExpandableTableRowComponent,
        NxExpandableTableCellComponent,
        NxSortHeaderComponent,
        NxSortDirective
    ];
    var NxTableModule = /** @class */ (function () {
        function NxTableModule() {
        }
        NxTableModule.decorators = [
            { type: core.NgModule, args: [{
                        declarations: EXPORTED_DECLARED_ELEMENTS,
                        exports: EXPORTED_DECLARED_ELEMENTS,
                        imports: [
                            common.CommonModule,
                            icon.NxIconModule
                        ],
                        providers: [NxSortHeaderIntl],
                    },] }
        ];
        return NxTableModule;
    }());

    exports.NxExpandableTableCellComponent = NxExpandableTableCellComponent;
    exports.NxExpandableTableDirective = NxExpandableTableDirective;
    exports.NxExpandableTableRowComponent = NxExpandableTableRowComponent;
    exports.NxHeaderCellDirective = NxHeaderCellDirective;
    exports.NxSortDirective = NxSortDirective;
    exports.NxSortHeaderComponent = NxSortHeaderComponent;
    exports.NxSortHeaderIntl = NxSortHeaderIntl;
    exports.NxTableCellComponent = NxTableCellComponent;
    exports.NxTableComponent = NxTableComponent;
    exports.NxTableModule = NxTableModule;
    exports.NxTableRowComponent = NxTableRowComponent;
    exports.NxToggleButtonComponent = NxToggleButtonComponent;
    exports.SortEvent = SortEvent;

    Object.defineProperty(exports, '__esModule', { value: true });

})));
//# sourceMappingURL=allianz-ngx-ndbx-table.umd.js.map
