(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@allianz/ngx-ndbx/formfield'), require('@allianz/ngx-ndbx/icon'), require('@angular/cdk/a11y'), require('@angular/cdk/overlay'), require('@angular/common'), require('@angular/core'), require('@allianz/ngx-ndbx/checkbox'), require('@angular/cdk/collections'), require('@angular/cdk/keycodes'), require('@angular/forms'), require('rxjs'), require('rxjs/operators'), require('@angular/cdk/observers')) :
    typeof define === 'function' && define.amd ? define('@allianz/ngx-ndbx/dropdown', ['exports', '@allianz/ngx-ndbx/formfield', '@allianz/ngx-ndbx/icon', '@angular/cdk/a11y', '@angular/cdk/overlay', '@angular/common', '@angular/core', '@allianz/ngx-ndbx/checkbox', '@angular/cdk/collections', '@angular/cdk/keycodes', '@angular/forms', 'rxjs', 'rxjs/operators', '@angular/cdk/observers'], factory) :
    (global = global || self, factory((global.allianz = global.allianz || {}, global.allianz['ngx-ndbx'] = global.allianz['ngx-ndbx'] || {}, global.allianz['ngx-ndbx'].dropdown = {}), global.allianz['ngx-ndbx'].formfield, global.allianz['ngx-ndbx'].icon, global.ng.cdk.a11y, global.ng.cdk.overlay, global.ng.common, global.ng.core, global.allianz['ngx-ndbx'].checkbox, global.ng.cdk.collections, global.ng.cdk.keycodes, global.ng.forms, global.rxjs, global.rxjs.operators, global.ng.cdk.observers));
}(this, (function (exports, formfield, icon, a11y, overlay, common, core, checkbox, collections, keycodes, forms, rxjs, operators, observers) { 'use strict';

    /*! *****************************************************************************
    Copyright (c) Microsoft Corporation. All rights reserved.
    Licensed under the Apache License, Version 2.0 (the "License"); you may not use
    this file except in compliance with the License. You may obtain a copy of the
    License at http://www.apache.org/licenses/LICENSE-2.0

    THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
    WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
    MERCHANTABLITY OR NON-INFRINGEMENT.

    See the Apache Version 2.0 License for specific language governing permissions
    and limitations under the License.
    ***************************************************************************** */
    /* global Reflect, Promise */

    var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };

    function __extends(d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    }

    var __assign = function() {
        __assign = Object.assign || function __assign(t) {
            for (var s, i = 1, n = arguments.length; i < n; i++) {
                s = arguments[i];
                for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
            }
            return t;
        };
        return __assign.apply(this, arguments);
    };

    function __rest(s, e) {
        var t = {};
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
            t[p] = s[p];
        if (s != null && typeof Object.getOwnPropertySymbols === "function")
            for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
                if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                    t[p[i]] = s[p[i]];
            }
        return t;
    }

    function __decorate(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    }

    function __param(paramIndex, decorator) {
        return function (target, key) { decorator(target, key, paramIndex); }
    }

    function __metadata(metadataKey, metadataValue) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(metadataKey, metadataValue);
    }

    function __awaiter(thisArg, _arguments, P, generator) {
        return new (P || (P = Promise))(function (resolve, reject) {
            function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
            function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
            function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
            step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
    }

    function __generator(thisArg, body) {
        var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
        return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
        function verb(n) { return function (v) { return step([n, v]); }; }
        function step(op) {
            if (f) throw new TypeError("Generator is already executing.");
            while (_) try {
                if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
                if (y = 0, t) op = [op[0] & 2, t.value];
                switch (op[0]) {
                    case 0: case 1: t = op; break;
                    case 4: _.label++; return { value: op[1], done: false };
                    case 5: _.label++; y = op[1]; op = [0]; continue;
                    case 7: op = _.ops.pop(); _.trys.pop(); continue;
                    default:
                        if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                        if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                        if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                        if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                        if (t[2]) _.ops.pop();
                        _.trys.pop(); continue;
                }
                op = body.call(thisArg, _);
            } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
            if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
        }
    }

    function __exportStar(m, exports) {
        for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
    }

    function __values(o) {
        var m = typeof Symbol === "function" && o[Symbol.iterator], i = 0;
        if (m) return m.call(o);
        return {
            next: function () {
                if (o && i >= o.length) o = void 0;
                return { value: o && o[i++], done: !o };
            }
        };
    }

    function __read(o, n) {
        var m = typeof Symbol === "function" && o[Symbol.iterator];
        if (!m) return o;
        var i = m.call(o), r, ar = [], e;
        try {
            while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
        }
        catch (error) { e = { error: error }; }
        finally {
            try {
                if (r && !r.done && (m = i["return"])) m.call(i);
            }
            finally { if (e) throw e.error; }
        }
        return ar;
    }

    function __spread() {
        for (var ar = [], i = 0; i < arguments.length; i++)
            ar = ar.concat(__read(arguments[i]));
        return ar;
    }

    function __spreadArrays() {
        for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
        for (var r = Array(s), k = 0, i = 0; i < il; i++)
            for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
                r[k] = a[j];
        return r;
    };

    function __await(v) {
        return this instanceof __await ? (this.v = v, this) : new __await(v);
    }

    function __asyncGenerator(thisArg, _arguments, generator) {
        if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
        var g = generator.apply(thisArg, _arguments || []), i, q = [];
        return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i;
        function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }
        function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }
        function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }
        function fulfill(value) { resume("next", value); }
        function reject(value) { resume("throw", value); }
        function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }
    }

    function __asyncDelegator(o) {
        var i, p;
        return i = {}, verb("next"), verb("throw", function (e) { throw e; }), verb("return"), i[Symbol.iterator] = function () { return this; }, i;
        function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === "return" } : f ? f(v) : v; } : f; }
    }

    function __asyncValues(o) {
        if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
        var m = o[Symbol.asyncIterator], i;
        return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);
        function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }
        function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }
    }

    function __makeTemplateObject(cooked, raw) {
        if (Object.defineProperty) { Object.defineProperty(cooked, "raw", { value: raw }); } else { cooked.raw = raw; }
        return cooked;
    };

    function __importStar(mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
        result.default = mod;
        return result;
    }

    function __importDefault(mod) {
        return (mod && mod.__esModule) ? mod : { default: mod };
    }

    /**
     * @fileoverview added by tsickle
     * Generated from: dropdown-errors.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * Returns an exception to be thrown when attempting to change a select's `multiple` option
     * after initialization.
     * \@docs-private
     * @return {?}
     */
    function getNxDropdownDynamicMultipleError() {
        return Error('Cannot change `multiselect` mode of select after initialization.');
    }
    /**
     * Returns an exception to be thrown when attempting to assign a non-array value to a select
     * in `multiselect` mode. Note that `undefined` and `null` are still valid values to allow for
     * resetting the value.
     * \@docs-private
     * @return {?}
     */
    function getNxDropdownNonArrayValueError() {
        return Error('Value must be an array in multiselect mode.');
    }
    /**
     * Returns an exception to be thrown when assigning a non-function value to the comparator
     * used to determine if a value corresponds to an option. Note that whether the function
     * actually takes two values and returns a boolean is not checked.
     * @return {?}
     */
    function getNxDropdownNonFunctionValueError() {
        return Error('`compareWith` must be a function.');
    }

    /**
     * @fileoverview added by tsickle
     * Generated from: dropdown.control.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * @abstract
     */
    var NxDropdownControl = /** @class */ (function (_super) {
        __extends(NxDropdownControl, _super);
        function NxDropdownControl() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            /**
             * Whether the dropdown should allow multi selection and additional checkboxes are shown.
             *
             * Note: Please make sure the value you bind is an array. If not an error is thrown!
             */
            _this.isMultiSelect = false;
            return _this;
        }
        NxDropdownControl.propDecorators = {
            isMultiSelect: [{ type: core.Input, args: ['nxIsMultiselect',] }]
        };
        return NxDropdownControl;
    }(formfield.NxFormfieldControl));
    if (false) {
        /**
         * Whether the dropdown should allow multi selection and additional checkboxes are shown.
         *
         * Note: Please make sure the value you bind is an array. If not an error is thrown!
         * @type {?}
         */
        NxDropdownControl.prototype.isMultiSelect;
        /**
         * \@docs-private
         * @abstract
         * @param {?} value
         * @return {?}
         */
        NxDropdownControl.prototype.formatValue = function (value) { };
    }

    /**
     * @fileoverview added by tsickle
     * Generated from: group/dropdown-group.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var NxDropdownGroupComponent = /** @class */ (function () {
        function NxDropdownGroupComponent() {
        }
        NxDropdownGroupComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'nx-dropdown-group',
                        template: "<div class=\"nx-dropdown-results__group\">\n  <div class=\"nx-dropdown-results__group-label\">{{label}}</div>\n  <ng-content></ng-content>\n</div>\n",
                        changeDetection: core.ChangeDetectionStrategy.OnPush,
                        styles: [":host{display:block}:host:first-child .nx-dropdown-results__group{background:rgba(236,236,236,.5);background:var(--dropdown-group-section-background-color,rgba(236,236,236,.5))}:host:first-child .nx-dropdown-results__group-label{padding-top:16px}.nx-dropdown-results__group-label{font-size:12px;font-size:var(--formfield-label-font-size,12px);line-height:16px;line-height:var(--formfield-label-line-height,16px);font-weight:var(--formfield-label-font-weight,600);letter-spacing:.5px;letter-spacing:var(--formfield-label-letter-spacing,.5px);font-style:italic;font-weight:700;padding:24px 32px 16px}"]
                    }] }
        ];
        NxDropdownGroupComponent.propDecorators = {
            label: [{ type: core.Input, args: ['nxLabel',] }]
        };
        return NxDropdownGroupComponent;
    }());
    if (false) {
        /**
         * Label displayed in the group.
         * @type {?}
         */
        NxDropdownGroupComponent.prototype.label;
    }

    /**
     * @fileoverview added by tsickle
     * Generated from: item/dropdown-item.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var NxDropdownItemChange = /** @class */ (function () {
        function NxDropdownItemChange(item, isUserInput) {
            if (isUserInput === void 0) { isUserInput = false; }
            this.item = item;
            this.isUserInput = isUserInput;
        }
        return NxDropdownItemChange;
    }());
    if (false) {
        /**
         * Reference to the option that emitted the event.
         * @type {?}
         */
        NxDropdownItemChange.prototype.item;
        /**
         * Whether the change in the option's value was a result of a user action.
         * @type {?}
         */
        NxDropdownItemChange.prototype.isUserInput;
    }
    /**
     * the unique id counter
     * @type {?}
     */
    var nextId = 0;
    var NxDropdownItemComponent = /** @class */ (function () {
        function NxDropdownItemComponent(_dropdown, group, _changeDetectorRef, _elementRef) {
            var _this = this;
            this._dropdown = _dropdown;
            this.group = group;
            this._changeDetectorRef = _changeDetectorRef;
            this._elementRef = _elementRef;
            this._hidden = false;
            this._mostRecentViewValue = '';
            this._id = "nx-dropdown-item-" + nextId++;
            this._selected = false;
            /**
             * Emits whenever the component is destroyed.
             */
            this._destroy = new rxjs.Subject();
            /**
             * Event emitted when the option is selected or deselected.
             */
            // tslint:disable-next-line:no-output-on-prefix
            this.onSelectionChange = new core.EventEmitter();
            /**
             * Emits when the state of the option changes and any parents have to be notified.
             */
            this._stateChanges = new rxjs.Subject();
            ((/** @type {?} */ (this._dropdown))).filterChanges.pipe(operators.takeUntil(this._destroy)).subscribe((/**
             * @param {?} value
             * @return {?}
             */
            function (value) {
                _this._showOrHideByFilter(value);
            }));
            // reset the hidden state when dropdown closes that on next open the user is seeing the full list again
            ((/** @type {?} */ (this._dropdown)))._closedStream.pipe(operators.takeUntil(this._destroy)).subscribe((/**
             * @return {?}
             */
            function () {
                _this._hidden = false;
            }));
        }
        Object.defineProperty(NxDropdownItemComponent.prototype, "id", {
            /** The unique ID of the option. */
            get: /**
             * The unique ID of the option.
             * @return {?}
             */
            function () { return this._id; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NxDropdownItemComponent.prototype, "selected", {
            /** Whether the item is selected. */
            get: /**
             * Whether the item is selected.
             * @return {?}
             */
            function () {
                return this._selected;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NxDropdownItemComponent.prototype, "active", {
            /** Whether the item is active. */
            get: /**
             * Whether the item is active.
             * @return {?}
             */
            function () {
                return this._active;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NxDropdownItemComponent.prototype, "multiselect", {
            /**
             * @docs-private
             * Whether the parent dropdown is in multiselect mode.
             */
            get: /**
             * \@docs-private
             * Whether the parent dropdown is in multiselect mode.
             * @return {?}
             */
            function () {
                return this._dropdown && this._dropdown.isMultiSelect;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        NxDropdownItemComponent.prototype.ngAfterViewChecked = /**
         * @return {?}
         */
        function () {
            // Since the parent dropdown component could be using the item's label to display the selected values
            // and it doesn't have a way of knowing if the item's label has changed
            // we have to check for changes in the DOM ourselves and dispatch an event. These checks are
            // relatively cheap, however we still limit them only to selected options in order to avoid
            // hitting the DOM too often.
            if (this._selected) {
                /** @type {?} */
                var viewValue = this.viewValue;
                if (viewValue !== this._mostRecentViewValue) {
                    this._mostRecentViewValue = viewValue;
                    this._stateChanges.next();
                }
            }
        };
        /**
         * @return {?}
         */
        NxDropdownItemComponent.prototype.ngOnDestroy = /**
         * @return {?}
         */
        function () {
            this._stateChanges.complete();
            this._destroy.next();
            this._destroy.complete();
        };
        /**
         * @param {?} event
         * @return {?}
         */
        NxDropdownItemComponent.prototype._onClick = /**
         * @param {?} event
         * @return {?}
         */
        function (event) {
            /* preventDefault to stop triggering the event twice when you click on the checkbox or the label inside the item */
            event.preventDefault();
            event.stopPropagation();
            this._selectViaInteraction();
        };
        /**
        * `Selects the option while indicating the selection came from the user. Used to
        * determine if the select's view -> model callback should be invoked.`
        */
        /**
         * `Selects the option while indicating the selection came from the user. Used to
         * determine if the select's view -> model callback should be invoked.`
         * @return {?}
         */
        NxDropdownItemComponent.prototype._selectViaInteraction = /**
         * `Selects the option while indicating the selection came from the user. Used to
         * determine if the select's view -> model callback should be invoked.`
         * @return {?}
         */
        function () {
            this._selected = this.multiselect ? !this._selected : true;
            this._changeDetectorRef.markForCheck();
            this._emitSelectionChangeEvent(true);
        };
        /** @docs-private */
        /**
         * \@docs-private
         * @return {?}
         */
        NxDropdownItemComponent.prototype.show = /**
         * \@docs-private
         * @return {?}
         */
        function () {
            this._hidden = false;
            this._changeDetectorRef.markForCheck();
        };
        /** @docs-private */
        /**
         * \@docs-private
         * @return {?}
         */
        NxDropdownItemComponent.prototype.hide = /**
         * \@docs-private
         * @return {?}
         */
        function () {
            this._hidden = true;
            this._changeDetectorRef.markForCheck();
        };
        /**
         * @private
         * @param {?} search
         * @return {?}
         */
        NxDropdownItemComponent.prototype._showOrHideByFilter = /**
         * @private
         * @param {?} search
         * @return {?}
         */
        function (search) {
            /** @type {?} */
            var constraint = ((/** @type {?} */ (this._dropdown))).filterFn(search, this.viewValue);
            this._hidden = constraint ? false : true;
            this._changeDetectorRef.markForCheck();
        };
        Object.defineProperty(NxDropdownItemComponent.prototype, "_formattedValue", {
            get: /**
             * @return {?}
             */
            function () {
                return ((/** @type {?} */ (this._dropdown))).valueFormatter(this.value);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NxDropdownItemComponent.prototype, "viewValue", {
            /** @docs-private */
            get: /**
             * \@docs-private
             * @return {?}
             */
            function () {
                return (this._elementRef.nativeElement.textContent || '').trim();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NxDropdownItemComponent.prototype, "elementRef", {
            /** @docs-private */
            get: /**
             * \@docs-private
             * @return {?}
             */
            function () {
                return this._elementRef;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        NxDropdownItemComponent.prototype.select = /**
         * @return {?}
         */
        function () {
            if (!this._selected) {
                this._selected = true;
                this._changeDetectorRef.markForCheck();
                this._emitSelectionChangeEvent();
            }
        };
        /** @docs-private */
        /**
         * \@docs-private
         * @return {?}
         */
        NxDropdownItemComponent.prototype.deselect = /**
         * \@docs-private
         * @return {?}
         */
        function () {
            if (this._selected) {
                this._selected = false;
                this._changeDetectorRef.markForCheck();
                this._emitSelectionChangeEvent();
            }
        };
        /** @docs-private */
        /**
         * \@docs-private
         * @return {?}
         */
        NxDropdownItemComponent.prototype.focus = /**
         * \@docs-private
         * @return {?}
         */
        function () {
            this._elementRef.nativeElement.focus();
        };
        /**
         * @private
         * @param {?=} isUserInput
         * @return {?}
         */
        NxDropdownItemComponent.prototype._emitSelectionChangeEvent = /**
         * @private
         * @param {?=} isUserInput
         * @return {?}
         */
        function (isUserInput) {
            if (isUserInput === void 0) { isUserInput = false; }
            this.onSelectionChange.emit(new NxDropdownItemChange(this, isUserInput));
        };
        /** @docs-private */
        /**
         * \@docs-private
         * @return {?}
         */
        NxDropdownItemComponent.prototype.setActiveStyles = /**
         * \@docs-private
         * @return {?}
         */
        function () {
            this._active = true;
            this._changeDetectorRef.markForCheck();
        };
        /** @docs-private */
        /**
         * \@docs-private
         * @return {?}
         */
        NxDropdownItemComponent.prototype.setInactiveStyles = /**
         * \@docs-private
         * @return {?}
         */
        function () {
            this._active = false;
            this._changeDetectorRef.markForCheck();
        };
        /**
         * Returns the list item's text label. Implemented as a part of the ListKeyManagerOption.
         * @docs-private */
        /**
         * Returns the list item's text label. Implemented as a part of the ListKeyManagerOption.
         * \@docs-private
         * @return {?}
         */
        NxDropdownItemComponent.prototype.getLabel = /**
         * Returns the list item's text label. Implemented as a part of the ListKeyManagerOption.
         * \@docs-private
         * @return {?}
         */
        function () {
            return this.viewValue;
        };
        /**
         * @param {?} element
         * @return {?}
         */
        NxDropdownItemComponent.prototype._isContentEmpty = /**
         * @param {?} element
         * @return {?}
         */
        function (element) {
            return element.children.length === 0 && !element.textContent.trim();
        };
        /**
         * @return {?}
         */
        NxDropdownItemComponent.prototype._onLabelChange = /**
         * @return {?}
         */
        function () {
            // trigger change detection when the label content changes for the case that ng-content was empty before.
            // this is also important when the label comes in deferred, e.g. by a delayed observable,
            // then first the default label derived from the value is shown
            // and after the value from the async observable is ready we need to trigger change detection that the derived label
            // gets hidden again.
            // Notice(!): the event of (cdkObserveContent) is run outside of the ngZone
            // We run detectChanges directly here as markForCheck wasn't enough to always trigger change detection correctly
            this._changeDetectorRef.detectChanges();
        };
        NxDropdownItemComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'nx-dropdown-item',
                        template: "<div #container class=\"nx-dropdown-results__option\"\n     [ngClass]=\"{'nx-dropdown-results__option--selected': selected}\">\n\n   <nx-checkbox *ngIf=\"multiselect\" [checked]=\"selected\">\n      <ng-container *ngTemplateOutlet=\"contentTemplate\"></ng-container>\n    </nx-checkbox>\n\n    <span *ngIf=\"!multiselect\" class=\"nx-dropdown-results__option-checkicon\">\n       <nx-icon name=\"check\" aria-hidden=\"true\"></nx-icon>\n    </span>\n\n    <ng-container *ngIf=\"!multiselect\">\n      <ng-container *ngTemplateOutlet=\"contentTemplate\"></ng-container>\n    </ng-container>\n</div>\n\n<ng-template #contentTemplate>\n  <div class=\"nx-dropdown-results__option-label\" >\n    <span #content (cdkObserveContent)=\"_onLabelChange()\">\n      <ng-content></ng-content>\n    </span>\n    <ng-container *ngIf=\"_isContentEmpty(content)\">\n      {{_formattedValue}}\n    </ng-container>\n  </div>\n</ng-template>\n",
                        changeDetection: core.ChangeDetectionStrategy.OnPush,
                        host: {
                            '[id]': 'id',
                            'role': 'option',
                            '[attr.aria-selected]': 'selected.toString()',
                            '[class.nx-hidden]': '_hidden',
                            '[class.nx-dropdown-item--active]': 'active',
                            '[class.nx-selected]': 'selected',
                            '[class.nx-multiselect]': 'multiselect',
                            '(click)': '_onClick($event)'
                        },
                        styles: [":host{display:block}:host(.nx-hidden){display:none}:host:first-child .nx-dropdown-results__option{padding-top:16px}:host:last-child .nx-dropdown-results__option{padding-bottom:16px}nx-checkbox{margin-bottom:0}.nx-dropdown-results__option{font-size:20px;font-size:var(--dropdown-item-font-size,20px);line-height:28px;line-height:var(--dropdown-item-line-height,28px);font-weight:400;font-weight:var(--dropdown-item-font-weight,400);letter-spacing:.2px;letter-spacing:var(--dropdown-item-letter-spacing,.2px);padding:8px 32px 8px 8px;cursor:pointer;position:relative;display:flex;max-width:100%;white-space:nowrap}.nx-dropdown-results__option-label{padding:0 12px;margin:0 -12px;color:#414141;color:var(--dropdown-item-text-color,#414141);white-space:pre-line}@media screen and (-ms-high-contrast:active){.nx-dropdown-results__option-label{-ms-high-contrast-adjust:none;color:buttonText;background-color:buttonFace;border-radius:4px}}:host(.nx-multiselect) .nx-dropdown-results__option{display:block;padding-left:32px}:host(.nx-selected):hover .nx-dropdown-results__option-checkicon,:host(.nx-selected):hover .nx-dropdown-results__option-label,:host:hover .nx-dropdown-results__option-label{color:#006192;color:var(--hover-primary,#006192)}@media screen and (-ms-high-contrast:active){:host(.nx-dropdown-item--active):not(.nx-multiselect) .nx-dropdown-results__option-label,:host:hover .nx-dropdown-results__option-label{color:highlightText;background-color:highlight}:host(.nx-dropdown-item--active):not(.nx-multiselect) .nx-dropdown-results__option-checkicon{-ms-high-contrast-adjust:none;color:highlightText;background:highlight;z-index:1}}:host(.nx-selected) .nx-dropdown-results__option-checkicon{opacity:1}:host(.nx-selected) .nx-dropdown-results__option-label{color:#414141;color:var(--dropdown-item-selected-color,#414141)}.nx-dropdown-results__option-checkicon{opacity:0;margin-right:8px;height:28px;height:var(--dropdown-item-line-height,28px);color:#414141;color:var(--dropdown-item-checkmark-color,#414141)}.nx-dropdown-results__option-checkicon nx-icon{line-height:28px;line-height:var(--dropdown-item-line-height,28px);font-size:16px}\n:host-context([data-whatinput=\"keyboard\"] .nx-dropdown__panel-body.is-stable).nx-dropdown-item--active .nx-dropdown-results__option .nx-dropdown-results__option-label {\n  border-radius: 4px;\n  box-shadow: 0 0 0 2px #ffffff, 0 0 0 6px #009DE6;\n  box-shadow: var(--focus-box-shadow, 0 0 0 2px #ffffff, 0 0 0 6px #009DE6); }\n  @media screen and (-ms-high-contrast: active) {\n    :host-context([data-whatinput=\"keyboard\"] .nx-dropdown__panel-body.is-stable).nx-dropdown-item--active .nx-dropdown-results__option .nx-dropdown-results__option-label {\n      box-shadow: 0 0 0 2px background, 0 0 0 6px windowText; } }\n\n\n:host-context([data-whatinput=\"keyboard\"] .nx-dropdown__panel-body.is-stable).nx-multiselect.nx-dropdown-item--active .nx-dropdown-results__option .nx-dropdown-results__option-label {\n  box-shadow: none; }\n  @media screen and (-ms-high-contrast: active) {\n    :host-context([data-whatinput=\"keyboard\"] .nx-dropdown__panel-body.is-stable).nx-multiselect.nx-dropdown-item--active .nx-dropdown-results__option .nx-dropdown-results__option-label {\n      box-shadow: none; } }\n\n:host-context([data-whatinput=\"keyboard\"] .nx-dropdown__panel-body.is-stable).nx-multiselect.nx-dropdown-item--active ::ng-deep .nx-checkbox__label {\n  border-radius: 4px;\n  box-shadow: 0 0 0 2px #ffffff, 0 0 0 6px #009DE6;\n  box-shadow: var(--focus-box-shadow, 0 0 0 2px #ffffff, 0 0 0 6px #009DE6); }\n  @media screen and (-ms-high-contrast: active) {\n    :host-context([data-whatinput=\"keyboard\"] .nx-dropdown__panel-body.is-stable).nx-multiselect.nx-dropdown-item--active ::ng-deep .nx-checkbox__label {\n      box-shadow: 0 0 0 2px background, 0 0 0 6px windowText; } }\n\n:host(.nx-selected.nx-dropdown-item--active) .nx-dropdown-results__option-label{padding-left:24px;margin-left:-24px}:host ::ng-deep .nx-checkbox__label{padding:0 4px;margin:0 -4px}"]
                    }] }
        ];
        /** @nocollapse */
        NxDropdownItemComponent.ctorParameters = function () { return [
            { type: NxDropdownControl, decorators: [{ type: core.Inject, args: [NxDropdownControl,] }] },
            { type: NxDropdownGroupComponent, decorators: [{ type: core.Optional }] },
            { type: core.ChangeDetectorRef },
            { type: core.ElementRef }
        ]; };
        NxDropdownItemComponent.propDecorators = {
            value: [{ type: core.Input, args: ['nxValue',] }],
            onSelectionChange: [{ type: core.Output }],
            containerElement: [{ type: core.ViewChild, args: ['container', { static: true },] }]
        };
        return NxDropdownItemComponent;
    }());
    if (false) {
        /** @type {?} */
        NxDropdownItemComponent.prototype._hidden;
        /**
         * @type {?}
         * @private
         */
        NxDropdownItemComponent.prototype._mostRecentViewValue;
        /**
         * @type {?}
         * @private
         */
        NxDropdownItemComponent.prototype._id;
        /**
         * The value of the dropdown item.
         * You can't use undefined, null and '' (empty strings)
         * as they are sentinel values signalling empty data.
         * @type {?}
         */
        NxDropdownItemComponent.prototype.value;
        /**
         * @type {?}
         * @private
         */
        NxDropdownItemComponent.prototype._selected;
        /**
         * @type {?}
         * @private
         */
        NxDropdownItemComponent.prototype._active;
        /**
         * Emits whenever the component is destroyed.
         * @type {?}
         * @private
         */
        NxDropdownItemComponent.prototype._destroy;
        /**
         * Event emitted when the option is selected or deselected.
         * @type {?}
         */
        NxDropdownItemComponent.prototype.onSelectionChange;
        /**
         * Emits when the state of the option changes and any parents have to be notified.
         * @type {?}
         */
        NxDropdownItemComponent.prototype._stateChanges;
        /**
         * \@docs-private
         * The wrapping div in the template. Used by dropdown to use the container height for scrolling.
         * @type {?}
         */
        NxDropdownItemComponent.prototype.containerElement;
        /**
         * @type {?}
         * @private
         */
        NxDropdownItemComponent.prototype._dropdown;
        /**
         * \@docs-private
         * @type {?}
         */
        NxDropdownItemComponent.prototype.group;
        /**
         * @type {?}
         * @private
         */
        NxDropdownItemComponent.prototype._changeDetectorRef;
        /**
         * @type {?}
         * @private
         */
        NxDropdownItemComponent.prototype._elementRef;
    }

    /**
     * @fileoverview added by tsickle
     * Generated from: closed-label.directive.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    // This Directive solely purpose is to mark given ng-template and project it into the required destination.
    var NxDropdownClosedLabelDirective = /** @class */ (function () {
        function NxDropdownClosedLabelDirective(templateRef) {
            this.templateRef = templateRef;
        }
        NxDropdownClosedLabelDirective.decorators = [
            { type: core.Directive, args: [{
                        selector: '[nxClosedLabel]'
                    },] }
        ];
        /** @nocollapse */
        NxDropdownClosedLabelDirective.ctorParameters = function () { return [
            { type: core.TemplateRef }
        ]; };
        return NxDropdownClosedLabelDirective;
    }());
    if (false) {
        /** @type {?} */
        NxDropdownClosedLabelDirective.prototype.templateRef;
    }

    /**
     * @fileoverview added by tsickle
     * Generated from: dropdown.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * Change event object that is emitted when the select value has changed.
     * @template T
     */
    var   /**
     * Change event object that is emitted when the select value has changed.
     * @template T
     */
    NxDropdownSelectChange = /** @class */ (function () {
        function NxDropdownSelectChange(source, value) {
            this.source = source;
            this.value = value;
        }
        return NxDropdownSelectChange;
    }());
    if (false) {
        /**
         * Reference to the select that emitted the change event.
         * @type {?}
         */
        NxDropdownSelectChange.prototype.source;
        /**
         * Current value of the select that emitted the event.
         * @type {?}
         */
        NxDropdownSelectChange.prototype.value;
    }
    /**
     * @return {?}
     */
    function getPositions() {
        return [{
                originX: 'start',
                originY: 'top',
                overlayX: 'start',
                overlayY: 'top'
            }, {
                originX: 'start',
                originY: 'center',
                overlayX: 'start',
                overlayY: 'center'
            }, {
                originX: 'start',
                originY: 'bottom',
                overlayX: 'start',
                overlayY: 'bottom'
            }];
    }
    var NxDropdownComponent = /** @class */ (function (_super) {
        __extends(NxDropdownComponent, _super);
        function NxDropdownComponent(_changeDetectorRef, _elementRef, _ngZone, tabIndex, formFieldComponent, ngControl, _parentForm, _parentFormGroup) {
            var _this = _super.call(this) || this;
            _this._changeDetectorRef = _changeDetectorRef;
            _this._elementRef = _elementRef;
            _this._ngZone = _ngZone;
            _this.formFieldComponent = formFieldComponent;
            _this.ngControl = ngControl;
            _this._parentForm = _parentForm;
            _this._parentFormGroup = _parentFormGroup;
            // The dropdown currently doesn't support readonly of the NxFormfieldControl so we hardcode it here
            _this.readonly = false;
            _this._disabled = false;
            _this._focused = false;
            /**
             * Whether or not the overlay panel is open.
             */
            _this._panelOpen = false;
            /**
             * \@docs-private
             */
            _this.errorState = false;
            /**
             * \@docs-private
             */
            _this.isStable = false;
            /**
             * Name of this control that is used inside the formfield component
             * \@docs-private
             */
            _this.controlType = 'nx-dropdown';
            /**
             * The minimal space between the viewport and the overlay
             */
            _this._overlayViewportMargin = 16;
            /**
             * \@docs-private
             * Emits when internal state changes to inform formfield about it.
             */
            _this.stateChanges = new rxjs.Subject();
            /**
             * The IDs of child options to be passed to the aria-owns attribute.
             */
            _this._optionIds = '';
            _this._tabIndex = 0;
            /**
             * \@docs-private
             */
            _this.currentFilter = '';
            /**
             * Label to describe the component.
             */
            _this._ariaLabel = '';
            _this._style = '';
            /**
             * Whether the dropdown should render in its negative style or not.
             */
            _this._negative = false;
            /**
             * Whether the dropdown should be shown with an additional filter input.
             */
            _this.showFilter = false;
            /**
             * Text displayed as placeholder for the filter.
             */
            _this.filterPlaceholder = '';
            /**
             * Event emitted when the select panel has been toggled.
             */
            _this.openedChange = new core.EventEmitter();
            /**
             * Event emitted when the select has been opened.
             */
            _this._openedStream = _this.openedChange.pipe(operators.filter((/**
             * @param {?} o
             * @return {?}
             */
            function (o) { return o; })), operators.map((/**
             * @return {?}
             */
            function () { })));
            /**
             * Event emitted when the select has been closed.
             */
            _this._closedStream = _this.openedChange.pipe(operators.filter((/**
             * @param {?} o
             * @return {?}
             */
            function (o) { return !o; })), operators.map((/**
             * @return {?}
             */
            function () { })));
            /**
             * Event emitted when the user types in the filter input.
             */
            _this.filterChanges = new rxjs.Subject();
            /**
             * Event that emits whenever the raw value of the select changes. This is here primarily
             * to facilitate the two-way binding for the `value` input.
             * \@docs-private
             */
            _this.valueChange = new core.EventEmitter();
            /**
             * Event emitted when the selected value has been changed.
             */
            _this.selectionChange = new core.EventEmitter();
            /**
             * \@docs-private
             */
            _this.optionSelectionChanges = rxjs.defer((/**
             * @return {?}
             */
            function () {
                if (_this.options) {
                    return rxjs.merge.apply(void 0, __spread(_this.options.map((/**
                     * @param {?} option
                     * @return {?}
                     */
                    function (option) { return option.onSelectionChange; }))));
                }
                return _this._ngZone.onStable
                    .asObservable()
                    .pipe(operators.take(1), operators.switchMap((/**
                 * @return {?}
                 */
                function () { return _this.optionSelectionChanges; })));
            }));
            /**
             * Emits whenever the component is destroyed.
             */
            _this._destroy = new rxjs.Subject();
            /**
             * Function that transforms the value into a string.
             * This function is used for displaying and filtering the content
             * ( Default: (value) => value ? value.toString() : null; ).
             */
            _this.valueFormatter = (/**
             * @param {?} value
             * @return {?}
             */
            function (value) {
                return value == null ? '' : value.toString();
            });
            /**
             * Comparison function to specify which option is displayed. Defaults to object equality.
             */
            _this._compareWith = (/**
             * @param {?} o1
             * @param {?} o2
             * @return {?}
             */
            function (o1, o2) { return o1 === o2; });
            _this._filterFn = (/**
             * @param {?} search
             * @param {?} itemValue
             * @return {?}
             */
            function (search, itemValue) {
                return itemValue.toLocaleLowerCase().indexOf(search.toLocaleLowerCase()) >= 0;
            });
            /**
             * `View -> model callback called when value changes`
             */
            _this._onChange = (/**
             * @return {?}
             */
            function () { });
            /**
             * `View -> model callback called when select has been touched`
             */
            _this._onTouched = (/**
             * @return {?}
             */
            function () { });
            if (_this.ngControl) {
                // Note: we provide the value accessor through here, instead of
                // the `providers` to avoid running into a circular import.
                _this.ngControl.valueAccessor = _this;
            }
            _this._positions = getPositions();
            _this.tabIndex = parseInt(tabIndex, 10) || 0;
            return _this;
        }
        Object.defineProperty(NxDropdownComponent.prototype, "tabIndex", {
            get: /**
             * @return {?}
             */
            function () { return this.disabled ? -1 : this._tabIndex; },
            set: /**
             * @param {?} value
             * @return {?}
             */
            function (value) {
                // If the specified tabIndex value is null or undefined, fall back to the default value.
                this._tabIndex = value != null ? value : 0;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NxDropdownComponent.prototype, "value", {
            /** Selected value */
            get: /**
             * Selected value
             * @return {?}
             */
            function () { return this._value; },
            set: /**
             * @param {?} newValue
             * @return {?}
             */
            function (newValue) {
                if (newValue !== this._value) {
                    this.writeValue(newValue);
                    this._value = newValue;
                    this._onChange(newValue);
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NxDropdownComponent.prototype, "disabled", {
            /** Whether the dropdown is disabled. */
            get: /**
             * Whether the dropdown is disabled.
             * @return {?}
             */
            function () {
                return this._disabled;
            },
            set: /**
             * @param {?} value
             * @return {?}
             */
            function (value) {
                this._disabled = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NxDropdownComponent.prototype, "styles", {
            /** If set to 'negative', the component is displayed with the negative set of styles. */
            set: /**
             * If set to 'negative', the component is displayed with the negative set of styles.
             * @param {?} value
             * @return {?}
             */
            function (value) {
                if (this._style === value) {
                    return;
                }
                this._style = value;
                this._negative = !!this._style.match(/negative/);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NxDropdownComponent.prototype, "closedDropdownLabel", {
            /** @docs-private */
            get: /**
             * \@docs-private
             * @return {?}
             */
            function () {
                return this._closedDropdownLabel;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NxDropdownComponent.prototype, "selected", {
            /**
             * @docs-private
             * The currently selected option.
             */
            get: /**
             * \@docs-private
             * The currently selected option.
             * @return {?}
             */
            function () {
                return this.isMultiSelect ? this._selectionModel.selected : this._selectionModel.selected[0];
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NxDropdownComponent.prototype, "panelOpen", {
            /** @docs-private */
            get: /**
             * \@docs-private
             * @return {?}
             */
            function () {
                return this._panelOpen;
            },
            set: /**
             * @param {?} value
             * @return {?}
             */
            function (value) {
                this._panelOpen = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NxDropdownComponent.prototype, "label", {
            /** @docs-private */
            get: /**
             * \@docs-private
             * @return {?}
             */
            function () {
                return this.formFieldComponent ? this.formFieldComponent.label : '';
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NxDropdownComponent.prototype, "compareWith", {
            /**
             * Function to compare the option values with the selected values. The first argument
             * is a value from an option. The second is a value from the selection. A boolean
             * should be returned.
             */
            get: /**
             * Function to compare the option values with the selected values. The first argument
             * is a value from an option. The second is a value from the selection. A boolean
             * should be returned.
             * @return {?}
             */
            function () { return this._compareWith; },
            set: /**
             * @param {?} fn
             * @return {?}
             */
            function (fn) {
                if (typeof fn !== 'function') {
                    throw getNxDropdownNonFunctionValueError();
                }
                this._compareWith = fn;
                if (this._selectionModel) {
                    // A different comparator means the selection could change.
                    this._initializeSelection();
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NxDropdownComponent.prototype, "filterFn", {
            /**
             * Function to be used when the user types into the search filter. The first argument is the user input,
             * the second argument is the dropdown item value. The dropdown items will use this function to set their
             * visibility state.
             * A boolean should be returned.
             */
            get: /**
             * Function to be used when the user types into the search filter. The first argument is the user input,
             * the second argument is the dropdown item value. The dropdown items will use this function to set their
             * visibility state.
             * A boolean should be returned.
             * @return {?}
             */
            function () { return this._filterFn; },
            set: /**
             * @param {?} fn
             * @return {?}
             */
            function (fn) {
                if (typeof fn !== 'function') {
                    throw getNxDropdownNonFunctionValueError();
                }
                this._filterFn = fn;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NxDropdownComponent.prototype, "focused", {
            /**
             * @docs-private
             * Whether the select is focused.
             */
            get: /**
             * \@docs-private
             * Whether the select is focused.
             * @return {?}
             */
            function () {
                return this._focused || this.panelOpen;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NxDropdownComponent.prototype, "elementRef", {
            /** @docs-private */
            get: /**
             * \@docs-private
             * @return {?}
             */
            function () {
                return this._elementRef;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        NxDropdownComponent.prototype.ngDoCheck = /**
         * @return {?}
         */
        function () {
            if (this.ngControl) {
                this.updateErrorState();
            }
        };
        /**
         * @return {?}
         */
        NxDropdownComponent.prototype.ngOnInit = /**
         * @return {?}
         */
        function () {
            this._selectionModel = new collections.SelectionModel(this.isMultiSelect);
        };
        /**
         * @return {?}
         */
        NxDropdownComponent.prototype.ngAfterContentInit = /**
         * @return {?}
         */
        function () {
            var _this = this;
            this._closedDropdownLabel =
                this._customClosedDropdownLabel && this._customClosedDropdownLabel.templateRef || this._defaultClosedDropdownLabel;
            this._initKeyManager();
            this._selectionModel.changed.pipe(operators.takeUntil(this._destroy)).subscribe((/**
             * @param {?} event
             * @return {?}
             */
            function (event) {
                event.added.forEach((/**
                 * @param {?} option
                 * @return {?}
                 */
                function (option) { return option.select(); }));
                event.removed.forEach((/**
                 * @param {?} option
                 * @return {?}
                 */
                function (option) { return option.deselect(); }));
            }));
            this.options.changes.pipe(operators.startWith(null), operators.takeUntil(this._destroy)).subscribe((/**
             * @return {?}
             */
            function () {
                _this._resetOptions();
                _this._initializeSelection();
            }));
        };
        /**
         * @return {?}
         */
        NxDropdownComponent.prototype.ngOnDestroy = /**
         * @return {?}
         */
        function () {
            this._destroy.next();
            this._destroy.complete();
        };
        /** @docs-private */
        /**
         * \@docs-private
         * @param {?} control
         * @param {?} form
         * @return {?}
         */
        NxDropdownComponent.prototype.isErrorState = /**
         * \@docs-private
         * @param {?} control
         * @param {?} form
         * @return {?}
         */
        function (control, form) {
            return !!(control && control.invalid && (control.touched || (form && form.submitted)));
        };
        /** @docs-private */
        /**
         * \@docs-private
         * @return {?}
         */
        NxDropdownComponent.prototype.updateErrorState = /**
         * \@docs-private
         * @return {?}
         */
        function () {
            /** @type {?} */
            var oldState = this.errorState;
            /** @type {?} */
            var parent = this._parentFormGroup || this._parentForm;
            /** @type {?} */
            var control = this.ngControl ? (/** @type {?} */ (this.ngControl.control)) : null;
            /** @type {?} */
            var newState = this.isErrorState(control, parent);
            if (newState !== oldState) {
                this.errorState = newState;
                this.stateChanges.next();
            }
        };
        /** Sets up a key manager to listen to keyboard events on the overlay panel. */
        /**
         * Sets up a key manager to listen to keyboard events on the overlay panel.
         * @private
         * @return {?}
         */
        NxDropdownComponent.prototype._initKeyManager = /**
         * Sets up a key manager to listen to keyboard events on the overlay panel.
         * @private
         * @return {?}
         */
        function () {
            var _this = this;
            this._keyManager = new a11y.ActiveDescendantKeyManager(this.options)
                .withTypeAhead()
                .withWrap()
                .withVerticalOrientation()
                .withHorizontalOrientation('ltr')
                .skipPredicate((/**
             * @param {?} item
             * @return {?}
             */
            function (item) { return item._hidden; }));
            this._keyManager.tabOut.pipe(operators.takeUntil(this._destroy)).subscribe((/**
             * @return {?}
             */
            function () {
                // Restore focus to the trigger before closing. Ensures that the focus
                // position won't be lost if the user got focus into the overlay.
                _this.closePanel();
            }));
            this._keyManager.change.pipe(operators.takeUntil(this._destroy)).subscribe((/**
             * @return {?}
             */
            function () {
                if (_this._panelOpen && _this.panel) {
                    // Delay the auto scrolling until all items have settled otherwise the item containers might
                    // not exist yet
                    _this._ngZone.onStable
                        .asObservable()
                        .pipe(operators.take(1)).subscribe((/**
                     * @return {?}
                     */
                    function () {
                        _this._scrollActiveOptionIntoView();
                    }));
                }
                else if (!_this._panelOpen && !_this.isMultiSelect && _this._keyManager.activeItem) {
                    _this._keyManager.activeItem._selectViaInteraction();
                }
            }));
        };
        /**
         * @private
         * @return {?}
         */
        NxDropdownComponent.prototype._resetOptions = /**
         * @private
         * @return {?}
         */
        function () {
            var _this = this;
            /** @type {?} */
            var changedOrDestroyed = rxjs.merge(this.options.changes, this._destroy);
            this.optionSelectionChanges.pipe(operators.takeUntil(changedOrDestroyed)).subscribe((/**
             * @param {?} event
             * @return {?}
             */
            function (event) {
                _this._onSelect(event.item, event.isUserInput);
                if (event.isUserInput && !_this.isMultiSelect && _this._panelOpen) {
                    _this.closePanel();
                }
            }));
            // Listen to changes in the internal state of the options and react accordingly.
            // Handles cases like the labels of the selected options changing.
            rxjs.merge.apply(void 0, __spread(this.options.map((/**
             * @param {?} option
             * @return {?}
             */
            function (option) { return option._stateChanges; })))).pipe(operators.takeUntil(changedOrDestroyed))
                .subscribe((/**
             * @return {?}
             */
            function () {
                // defer it for the next cycle to not run in changed after checked errors
                // the combination of dropdown-item notifying parent and when the parent
                // tries to fetch the triggerValue from the child throws these errors
                setTimeout((/**
                 * @return {?}
                 */
                function () {
                    _this._changeDetectorRef.markForCheck();
                    _this.stateChanges.next();
                }));
            }));
            this._setOptionIds();
        };
        /** Records option IDs to pass to the aria-owns property. */
        /**
         * Records option IDs to pass to the aria-owns property.
         * @private
         * @return {?}
         */
        NxDropdownComponent.prototype._setOptionIds = /**
         * Records option IDs to pass to the aria-owns property.
         * @private
         * @return {?}
         */
        function () {
            this._optionIds = this.options.map((/**
             * @param {?} option
             * @return {?}
             */
            function (option) { return option.id; })).join(' ');
        };
        /** Invoked when an option is clicked. */
        /**
         * Invoked when an option is clicked.
         * @private
         * @param {?} option
         * @param {?} isUserInput
         * @return {?}
         */
        NxDropdownComponent.prototype._onSelect = /**
         * Invoked when an option is clicked.
         * @private
         * @param {?} option
         * @param {?} isUserInput
         * @return {?}
         */
        function (option, isUserInput) {
            /** @type {?} */
            var wasSelected = this._selectionModel.isSelected(option);
            if (option.value == null && !this.isMultiSelect) {
                option.deselect();
                this._selectionModel.clear();
                this._propagateChanges(option.value);
            }
            else {
                option.selected ? this._selectionModel.select(option) : this._selectionModel.deselect(option);
                if (isUserInput) {
                    this._keyManager.setActiveItem(option);
                }
                if (this.isMultiSelect) {
                    this._sortValues();
                }
            }
            if (wasSelected !== this._selectionModel.isSelected(option)) {
                this._propagateChanges();
            }
            this.stateChanges.next();
        };
        /**
         * @private
         * @return {?}
         */
        NxDropdownComponent.prototype._initializeSelection = /**
         * @private
         * @return {?}
         */
        function () {
            var _this = this;
            // Defer setting the value in order to avoid the "Expression
            // has changed after it was checked" errors from Angular.
            Promise.resolve().then((/**
             * @return {?}
             */
            function () {
                _this._setSelectionByValue(_this.ngControl ? _this.ngControl.value : _this._value);
            }));
        };
        /**
         * Sets the selected option based on a value. If no option can be
         * found with the designated value, the select trigger is cleared.
         */
        /**
         * Sets the selected option based on a value. If no option can be
         * found with the designated value, the select trigger is cleared.
         * @private
         * @param {?} value
         * @return {?}
         */
        NxDropdownComponent.prototype._setSelectionByValue = /**
         * Sets the selected option based on a value. If no option can be
         * found with the designated value, the select trigger is cleared.
         * @private
         * @param {?} value
         * @return {?}
         */
        function (value) {
            var _this = this;
            if (this.isMultiSelect && value) {
                if (!Array.isArray(value)) {
                    throw getNxDropdownNonArrayValueError();
                }
                this._selectionModel.clear();
                value.forEach((/**
                 * @param {?} currentValue
                 * @return {?}
                 */
                function (currentValue) { return _this._selectValue(currentValue); }));
                this._sortValues();
            }
            else {
                this._selectionModel.clear();
                /** @type {?} */
                var correspondingOption = this._selectValue(value);
                // Shift focus to the active item. Note that we shouldn't do this in multiple
                // mode, because we don't know what option the user interacted with last.
                if (correspondingOption) {
                    this._keyManager.setActiveItem(correspondingOption);
                }
            }
            this._changeDetectorRef.markForCheck();
        };
        /**
         * Finds and selects and option based on its value.
         * @returns Option that has the corresponding value.
         */
        /**
         * Finds and selects and option based on its value.
         * @private
         * @param {?} value
         * @return {?} Option that has the corresponding value.
         */
        NxDropdownComponent.prototype._selectValue = /**
         * Finds and selects and option based on its value.
         * @private
         * @param {?} value
         * @return {?} Option that has the corresponding value.
         */
        function (value) {
            var _this = this;
            /** @type {?} */
            var correspondingOption = this.options.find((/**
             * @param {?} option
             * @return {?}
             */
            function (option) {
                try {
                    // Treat null as a special reset value.
                    return option.value != null && _this._compareWith(option.value, value);
                }
                catch (error) {
                    if (core.isDevMode()) {
                        // Notify developers of errors in their comparator.
                        console.warn(error);
                    }
                    return false;
                }
            }));
            if (correspondingOption) {
                this._selectionModel.select(correspondingOption);
            }
            return correspondingOption;
        };
        /** Emits change event to set the model value. */
        /**
         * Emits change event to set the model value.
         * @private
         * @param {?=} fallbackValue
         * @return {?}
         */
        NxDropdownComponent.prototype._propagateChanges = /**
         * Emits change event to set the model value.
         * @private
         * @param {?=} fallbackValue
         * @return {?}
         */
        function (fallbackValue) {
            /** @type {?} */
            var valueToEmit = null;
            if (this.isMultiSelect) {
                valueToEmit = ((/** @type {?} */ (this.selected))).map((/**
                 * @param {?} option
                 * @return {?}
                 */
                function (option) { return option.value; }));
            }
            else {
                valueToEmit = this.selected ? ((/** @type {?} */ (this.selected))).value : fallbackValue;
            }
            this._value = valueToEmit;
            this.valueChange.emit(valueToEmit);
            this._onChange(valueToEmit);
            this.selectionChange.emit(new NxDropdownSelectChange(this, valueToEmit));
            this._changeDetectorRef.markForCheck();
        };
        /** Sorts the selected values in the selected based on their order in the panel. */
        /**
         * Sorts the selected values in the selected based on their order in the panel.
         * @private
         * @return {?}
         */
        NxDropdownComponent.prototype._sortValues = /**
         * Sorts the selected values in the selected based on their order in the panel.
         * @private
         * @return {?}
         */
        function () {
            if (this.isMultiSelect) {
                /** @type {?} */
                var options_1 = this.options.toArray();
                this._selectionModel.sort((/**
                 * @param {?} a
                 * @param {?} b
                 * @return {?}
                 */
                function (a, b) { return options_1.indexOf(a) - options_1.indexOf(b); }));
                this.stateChanges.next();
            }
        };
        /** Adds a offset to the overlay position, so the formfield label and the dropdown panel header are vertically aligned. */
        /**
         * Adds a offset to the overlay position, so the formfield label and the dropdown panel header are vertically aligned.
         * @private
         * @return {?}
         */
        NxDropdownComponent.prototype._updatePositionOffset = /**
         * Adds a offset to the overlay position, so the formfield label and the dropdown panel header are vertically aligned.
         * @private
         * @return {?}
         */
        function () {
            /** @type {?} */
            var offset = 0;
            if (this.formFieldComponent !== null) {
                /** @type {?} */
                var formFieldRect = this.formFieldComponent.elementRef.nativeElement.getBoundingClientRect();
                /** @type {?} */
                var dropdownRect = this._elementRef.nativeElement.getBoundingClientRect();
                /** @type {?} */
                var panelHeader = this.overlayDir.overlayRef.overlayElement.querySelector('.nx-dropdown__panel-header');
                /** @type {?} */
                var panelHeaderPaddingTop = panelHeader ? parseInt(getComputedStyle(panelHeader).paddingTop, 10) : 0;
                offset = formFieldRect.top - dropdownRect.top - panelHeaderPaddingTop;
            }
            this._positions[0].offsetY = offset;
        };
        /** Focuses the select element. */
        /**
         * Focuses the select element.
         * @return {?}
         */
        NxDropdownComponent.prototype.focus = /**
         * Focuses the select element.
         * @return {?}
         */
        function () {
            this._elementRef.nativeElement.focus();
        };
        /** Opens the panel of the dropdown. */
        /**
         * Opens the panel of the dropdown.
         * @return {?}
         */
        NxDropdownComponent.prototype.openPanel = /**
         * Opens the panel of the dropdown.
         * @return {?}
         */
        function () {
            if (this.disabled || !this.options || !this.options.length || this._panelOpen) {
                return;
            }
            this._panelOpen = true;
            this._triggerRect = this.trigger.nativeElement.getBoundingClientRect();
            this._keyManager.withHorizontalOrientation(null);
            this._highlightCorrectOption();
            this._changeDetectorRef.markForCheck();
        };
        /** Closes the panel of the dropdown. */
        /**
         * Closes the panel of the dropdown.
         * @return {?}
         */
        NxDropdownComponent.prototype.closePanel = /**
         * Closes the panel of the dropdown.
         * @return {?}
         */
        function () {
            var _this = this;
            if (this._panelOpen) {
                this._panelOpen = false;
                this.isStable = false;
                this._keyManager.withHorizontalOrientation('ltr');
                this._changeDetectorRef.markForCheck();
                this._onTouched();
                this.openedChange.emit(false);
                // defer the focus if the dropdown triggers actions that detach
                // a template/view from the DOM to prevent changed after checked errors
                setTimeout((/**
                 * @return {?}
                 */
                function () { return _this.focus(); }));
            }
        };
        // calculate inital scrollTop when the dropdown opens
        // scrolls the selected item to the middle of the panel if possible
        // calculate inital scrollTop when the dropdown opens
        // scrolls the selected item to the middle of the panel if possible
        /**
         * @private
         * @return {?}
         */
        NxDropdownComponent.prototype._calculateScrollTop = 
        // calculate inital scrollTop when the dropdown opens
        // scrolls the selected item to the middle of the panel if possible
        /**
         * @private
         * @return {?}
         */
        function () {
            // reset the scrolltop to make calculation easier
            this.panelBody.nativeElement.scrollTop = 0;
            if (!this.empty) {
                /** @type {?} */
                var offset = this._getItemOffset(this._keyManager.activeItem);
                /** @type {?} */
                var panelHeight = this.panelBody.nativeElement.offsetHeight;
                /** @type {?} */
                var panelRect = this.panelBody.nativeElement.getBoundingClientRect();
                /** @type {?} */
                var middleOfPanel = panelRect.top + panelHeight / 2;
                if (offset > middleOfPanel) {
                    // because we reset the scrollTop to 0 at the top we can simply take the middleOfPanel which is our
                    // target position for the item and subtract it from the offset (which is now always relative to the viewport)
                    this.panelBody.nativeElement.scrollTop = offset - middleOfPanel;
                }
            }
        };
        /** Scrolls the active option into view. */
        /**
         * Scrolls the active option into view.
         * @private
         * @return {?}
         */
        NxDropdownComponent.prototype._scrollActiveOptionIntoView = /**
         * Scrolls the active option into view.
         * @private
         * @return {?}
         */
        function () {
            if (!this.panelOpen || !this._keyManager.activeItem) {
                return;
            }
            /** @type {?} */
            var activeItem = this._keyManager.activeItem.containerElement.nativeElement;
            /** @type {?} */
            var panel = this.panelBody.nativeElement;
            /** @type {?} */
            var panelOffset = panel.offsetTop;
            // how much the overlay is repositioned on the page
            /** @type {?} */
            var panelTopScrollPosition = panel.scrollTop;
            /** @type {?} */
            var panelHeight = panel.clientHeight;
            /** @type {?} */
            var itemTop = activeItem.offsetTop - panelOffset;
            /** @type {?} */
            var itemBottom = activeItem.offsetTop - panelOffset + activeItem.getBoundingClientRect().height;
            // item half or less visible on top
            if (itemTop < panelTopScrollPosition) {
                this.panelBody.nativeElement.scrollTop = itemTop;
                // item half or less visible on bottom
            }
            else if (itemBottom > (panelTopScrollPosition + panelHeight)) {
                this.panelBody.nativeElement.scrollTop = itemBottom - panelHeight;
            }
        };
        /** @docs-private */
        /**
         * \@docs-private
         * @private
         * @param {?} item
         * @return {?}
         */
        NxDropdownComponent.prototype._getItemOffset = /**
         * \@docs-private
         * @private
         * @param {?} item
         * @return {?}
         */
        function (item) {
            /** @type {?} */
            var itemRect = item.containerElement.nativeElement.getBoundingClientRect();
            return itemRect.top + (itemRect.height / 2); // get position of the item's center
        };
        /**
         * @docs-private
         * Formfield Implementation
         */
        /**
         * \@docs-private
         * Formfield Implementation
         * @param {?} ids
         * @return {?}
         */
        NxDropdownComponent.prototype.setDescribedByIds = /**
         * \@docs-private
         * Formfield Implementation
         * @param {?} ids
         * @return {?}
         */
        function (ids) {
            this.ariaDescribedby = ids.join(' ');
        };
        /** @docs-private */
        /**
         * \@docs-private
         * @param {?} value
         * @return {?}
         */
        NxDropdownComponent.prototype.setAriaLabel = /**
         * \@docs-private
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this._ariaLabel = value;
        };
        /**
         * @return {?}
         */
        NxDropdownComponent.prototype._getAriaLabel = /**
         * @return {?}
         */
        function () {
            return this._ariaLabel || (this.formFieldComponent ? this.formFieldComponent.label : null);
        };
        Object.defineProperty(NxDropdownComponent.prototype, "_isInOutlineField", {
            get: /**
             * @return {?}
             */
            function () {
                return this.formFieldComponent !== null
                    && this.formFieldComponent.appearance === 'outline';
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NxDropdownComponent.prototype, "empty", {
            /**
             * @docs-private
             * Whether the select has a value.
             */
            get: /**
             * \@docs-private
             * Whether the select has a value.
             * @return {?}
             */
            function () {
                return !this._selectionModel || this._selectionModel.isEmpty();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NxDropdownComponent.prototype, "hasValue", {
            /** @docs-private */
            get: /**
             * \@docs-private
             * @return {?}
             */
            function () {
                return this._selectionModel.hasValue();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NxDropdownComponent.prototype, "shouldLabelFloat", {
            /** @docs-private */
            get: /**
             * \@docs-private
             * @return {?}
             */
            function () {
                return this.focused || !this.empty;
            },
            enumerable: true,
            configurable: true
        });
        /** End Formfield */
        /** ControlValueAccessor */
        /**
         * Sets the select's value. Part of the ControlValueAccessor interface
         * required to integrate with Angular's core forms API.
         *
         * @param value New value to be written to the model.
         */
        /** End Formfield */
        /** ControlValueAccessor */
        /**
         * Sets the select's value. Part of the ControlValueAccessor interface
         * required to integrate with Angular's core forms API.
         *
         * @param {?} value New value to be written to the model.
         * @return {?}
         */
        NxDropdownComponent.prototype.writeValue = /** End Formfield */
        /** ControlValueAccessor */
        /**
         * Sets the select's value. Part of the ControlValueAccessor interface
         * required to integrate with Angular's core forms API.
         *
         * @param {?} value New value to be written to the model.
         * @return {?}
         */
        function (value) {
            if (this.options) {
                this._setSelectionByValue(value);
            }
        };
        /**
         * @param {?} fn
         * @return {?}
         */
        NxDropdownComponent.prototype.registerOnChange = /**
         * @param {?} fn
         * @return {?}
         */
        function (fn) {
            this._onChange = fn;
        };
        /**
         * @param {?} fn
         * @return {?}
         */
        NxDropdownComponent.prototype.registerOnTouched = /**
         * @param {?} fn
         * @return {?}
         */
        function (fn) {
            this._onTouched = fn;
        };
        /**
         * Disables the select. Part of the ControlValueAccessor interface required
         * to integrate with Angular's core forms API.
         *
         * @param isDisabled Sets whether the component is disabled.
         */
        /**
         * Disables the select. Part of the ControlValueAccessor interface required
         * to integrate with Angular's core forms API.
         *
         * @param {?} isDisabled Sets whether the component is disabled.
         * @return {?}
         */
        NxDropdownComponent.prototype.setDisabledState = /**
         * Disables the select. Part of the ControlValueAccessor interface required
         * to integrate with Angular's core forms API.
         *
         * @param {?} isDisabled Sets whether the component is disabled.
         * @return {?}
         */
        function (isDisabled) {
            this.disabled = isDisabled;
            this._changeDetectorRef.markForCheck();
            this.stateChanges.next();
        };
        /** End ControlValueAccessor */
        /**
         * End ControlValueAccessor
         * @param {?} event
         * @return {?}
         */
        NxDropdownComponent.prototype._handleKeydown = /**
         * End ControlValueAccessor
         * @param {?} event
         * @return {?}
         */
        function (event) {
            this.panelOpen ? this._handleOpenKeydown(event) : this._handleClosedKeydown(event);
        };
        /**
         * @private
         * @param {?} event
         * @return {?}
         */
        NxDropdownComponent.prototype._handleClosedKeydown = /**
         * @private
         * @param {?} event
         * @return {?}
         */
        function (event) {
            /** @type {?} */
            var keyCode = event.keyCode;
            /** @type {?} */
            var isArrowKey = keyCode === keycodes.DOWN_ARROW || keyCode === keycodes.UP_ARROW ||
                keyCode === keycodes.LEFT_ARROW || keyCode === keycodes.RIGHT_ARROW;
            /** @type {?} */
            var isOpenKey = keyCode === keycodes.ENTER || keyCode === keycodes.SPACE;
            // Open the select on ALT + arrow key to match the native <select>
            if (isOpenKey || ((this.isMultiSelect || event.altKey) && isArrowKey)) {
                event.preventDefault(); // prevents the page from scrolling down when pressing space
                this.openPanel();
            }
            else if (!this.isMultiSelect && !this.disabled) {
                this._keyManager.onKeydown(event);
            }
        };
        /**
         * @private
         * @param {?} event
         * @return {?}
         */
        NxDropdownComponent.prototype._handleOpenKeydown = /**
         * @private
         * @param {?} event
         * @return {?}
         */
        function (event) {
            var _this = this;
            /** @type {?} */
            var keyCode = event.keyCode;
            // if has filter all events other than the listed ones should be ignored or handled in _onFilter()
            if (!([keycodes.DOWN_ARROW, keycodes.UP_ARROW, keycodes.HOME, keycodes.END, keycodes.ENTER, keycodes.LEFT_ARROW, keycodes.RIGHT_ARROW, keycodes.SHIFT, keycodes.SPACE, keycodes.TAB].indexOf(keyCode) >= 0)
                && this.showFilter) {
                return;
            }
            /** @type {?} */
            var isArrowKey = keyCode === keycodes.DOWN_ARROW || keyCode === keycodes.UP_ARROW;
            /** @type {?} */
            var manager = this._keyManager;
            /** @type {?} */
            var allHidden = this.options.map((/**
             * @param {?} option
             * @return {?}
             */
            function (option) { return option._hidden; })).every((/**
             * @param {?} option
             * @return {?}
             */
            function (option) { return Boolean(option); }));
            if (keyCode === keycodes.HOME || keyCode === keycodes.END) {
                event.preventDefault();
                keyCode === keycodes.HOME ? manager.setFirstItemActive() : manager.setLastItemActive();
            }
            else if (isArrowKey && event.altKey) {
                // Close the select on ALT + arrow key to match the native <select>
                event.preventDefault();
                this.closePanel();
            }
            else if (keyCode === keycodes.ENTER && manager.activeItem && !allHidden) {
                event.preventDefault();
                manager.activeItem._selectViaInteraction();
            }
            else if (keyCode === keycodes.ENTER && allHidden) {
                event.preventDefault();
                this.closePanel();
            }
            else if (!this.showFilter && keyCode === keycodes.SPACE && manager.activeItem) {
                event.preventDefault();
                manager.activeItem._selectViaInteraction();
            }
            else if (keyCode === keycodes.TAB) {
                this.closePanel();
            }
            else {
                /** @type {?} */
                var previouslyFocusedIndex = manager.activeItemIndex;
                manager.onKeydown(event);
                this._ngZone.onStable
                    .asObservable()
                    .pipe(operators.take(1), operators.delay(251) // we need to defer to get the new activeItemIndex. delay > debouncing of the typeAhead
                ).subscribe((/**
                 * @return {?}
                 */
                function () {
                    _this.isStable = true;
                    _this._changeDetectorRef.detectChanges();
                }));
                if (this.isMultiSelect && isArrowKey && event.shiftKey && manager.activeItem &&
                    manager.activeItemIndex !== previouslyFocusedIndex) {
                    manager.activeItem._selectViaInteraction();
                }
            }
        };
        /** @docs-private */
        /**
         * \@docs-private
         * @param {?} value
         * @return {?}
         */
        NxDropdownComponent.prototype.formatValue = /**
         * \@docs-private
         * @param {?} value
         * @return {?}
         */
        function (value) {
            return this.valueFormatter(value);
        };
        /** Called when the user types in the filter input */
        /**
         * Called when the user types in the filter input
         * @param {?} event
         * @return {?}
         */
        NxDropdownComponent.prototype._onFilter = /**
         * Called when the user types in the filter input
         * @param {?} event
         * @return {?}
         */
        function (event) {
            event.preventDefault();
            this.currentFilter = event.target.value;
            this.filterChanges.next(event.target.value);
            /** @type {?} */
            var allHidden = this.options.map((/**
             * @param {?} option
             * @return {?}
             */
            function (option) { return option._hidden; })).every((/**
             * @param {?} option
             * @return {?}
             */
            function (option) { return Boolean(option); }));
            if (allHidden) {
                this._keyManager.setActiveItem(null);
            }
            else {
                this._keyManager.setFirstItemActive();
            }
        };
        Object.defineProperty(NxDropdownComponent.prototype, "triggerValue", {
            /**
             * @docs-private
             * The value displayed in the trigger.
             */
            get: /**
             * \@docs-private
             * The value displayed in the trigger.
             * @return {?}
             */
            function () {
                if (this.empty) {
                    return '';
                }
                if (this.isMultiSelect) {
                    /** @type {?} */
                    var selectedOptions = this._selectionModel.selected.map((/**
                     * @param {?} option
                     * @return {?}
                     */
                    function (option) { return option.viewValue; }));
                    return selectedOptions.join(', ');
                }
                return this._selectionModel.selected[0].viewValue;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * Highlights the selected item. If no option is selected, it will highlight
         * the first item instead.
         */
        /**
         * Highlights the selected item. If no option is selected, it will highlight
         * the first item instead.
         * @private
         * @return {?}
         */
        NxDropdownComponent.prototype._highlightCorrectOption = /**
         * Highlights the selected item. If no option is selected, it will highlight
         * the first item instead.
         * @private
         * @return {?}
         */
        function () {
            if (this._keyManager) {
                if (this.empty) {
                    this._keyManager.setFirstItemActive();
                }
                else {
                    this._keyManager.setActiveItem(this._selectionModel.selected[0]);
                }
            }
        };
        /**
         * Callback that is invoked when the overlay panel has been attached.
         */
        /**
         * Callback that is invoked when the overlay panel has been attached.
         * @return {?}
         */
        NxDropdownComponent.prototype._onAttached = /**
         * Callback that is invoked when the overlay panel has been attached.
         * @return {?}
         */
        function () {
            var _this = this;
            this.overlayDir.positionChange.pipe(operators.take(1)).subscribe((/**
             * @return {?}
             */
            function () {
                /** @type {?} */
                var overlayRef = _this.overlayDir.overlayRef;
                /** @type {?} */
                var positionStrategy = (/** @type {?} */ (overlayRef.getConfig()
                    .positionStrategy));
                _this._updatePositionOffset();
                positionStrategy.withPositions(_this._positions.slice());
                overlayRef.updatePosition();
                if (_this._keyManager.activeItem) {
                    _this._calculateScrollTop();
                }
                _this._changeDetectorRef.markForCheck();
                _this.openedChange.emit(true);
                // If there is no item selected, the filter takes the focus.
                if (_this.showFilter && !_this._value) {
                    _this.filterInput.nativeElement.focus();
                }
                else {
                    _this.panelBody.nativeElement.focus();
                }
            }));
        };
        /**
         * @return {?}
         */
        NxDropdownComponent.prototype._onFocus = /**
         * @return {?}
         */
        function () {
            if (!this.disabled) {
                this._focused = true;
                this.stateChanges.next();
            }
        };
        /**
         * Calls the touched callback only if the panel is closed. Otherwise, the trigger will
         * "blur" to the panel when it opens, causing a false positive.
         */
        /**
         * Calls the touched callback only if the panel is closed. Otherwise, the trigger will
         * "blur" to the panel when it opens, causing a false positive.
         * @return {?}
         */
        NxDropdownComponent.prototype._onBlur = /**
         * Calls the touched callback only if the panel is closed. Otherwise, the trigger will
         * "blur" to the panel when it opens, causing a false positive.
         * @return {?}
         */
        function () {
            this._focused = false;
            if (this.filterInput && this.showFilter) {
                this._clearFilter();
            }
            if (!this.disabled && !this.panelOpen) {
                this._onTouched();
                this._changeDetectorRef.markForCheck();
                this.stateChanges.next();
            }
        };
        Object.defineProperty(NxDropdownComponent.prototype, "isFilterEmpty", {
            /** @docs-private */
            get: /**
             * \@docs-private
             * @return {?}
             */
            function () {
                return this.currentFilter.length === 0;
            },
            enumerable: true,
            configurable: true
        });
        /** @docs-private */
        /**
         * \@docs-private
         * @return {?}
         */
        NxDropdownComponent.prototype._clearFilter = /**
         * \@docs-private
         * @return {?}
         */
        function () {
            this.filterInput.nativeElement.value = '';
            this.currentFilter = '';
            this.filterChanges.next('');
        };
        /** @docs-private determines the `aria-activedescendant` to be set on the host. */
        /**
         * \@docs-private determines the `aria-activedescendant` to be set on the host.
         * @return {?}
         */
        NxDropdownComponent.prototype._getAriaActiveDescendant = /**
         * \@docs-private determines the `aria-activedescendant` to be set on the host.
         * @return {?}
         */
        function () {
            if (this.panelOpen && this._keyManager && this._keyManager.activeItem) {
                return this._keyManager.activeItem.id;
            }
            return null;
        };
        NxDropdownComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'nx-dropdown',
                        template: "\n<!-- input and stuff-->\n<div cdkOverlayOrigin\n    #origin=\"cdkOverlayOrigin\"\n    class=\"nx-dropdown__container\"\n    #trigger>\n  <div class=\"nx-dropdown__rendered\">\n    <ng-container *ngTemplateOutlet=\"closedDropdownLabel\"></ng-container>\n  </div>\n  <div class=\"nx-dropdown__icon\">\n    <nx-icon class=\"nx-dropdown__chevron\" name=\"chevron-down\"></nx-icon>\n  </div>\n</div>\n\n<ng-template #defaultClosedDropdownLabel>\n  <span *ngIf=\"triggerValue\">{{ triggerValue }}</span>\n</ng-template>\n\n<!-- overlay -->\n<ng-template\n  cdkConnectedOverlay\n  cdkConnectedOverlayHasBackdrop\n  cdkConnectedOverlayBackdropClass=\"cdk-overlay-transparent-backdrop\"\n  [cdkConnectedOverlayOrigin]=\"origin\"\n  [cdkConnectedOverlayOpen]=\"panelOpen\"\n  [cdkConnectedOverlayPositions]=\"_positions\"\n  [cdkConnectedOverlayMinWidth]=\"_triggerRect?.width\"\n  [cdkConnectedOverlayFlexibleDimensions]=\"true\"\n  [cdkConnectedOverlayViewportMargin]=\"_overlayViewportMargin\"\n  [cdkConnectedOverlayPush]=\"true\"\n  (backdropClick)=\"closePanel()\"\n  (attach)=\"_onAttached()\"\n  (detach)=\"closePanel()\">\n\n  <div class=\"nx-dropdown__panel\"\n      [class.has-filter]=\"showFilter\"\n      [class.nx-dropdown__panel--in-outline-field]=\"_isInOutlineField\"\n      (keydown)=\"_handleKeydown($event)\"\n      #panel>\n    <div class=\"nx-dropdown__panel-header\" *ngIf=\"label\">\n      {{ label }}\n    </div>\n    <div class=\"nx-dropdown__filter\" *ngIf=\"showFilter\">\n      <input class=\"nx-dropdown__filter-input\"\n             [class.is-filled]=\"!isFilterEmpty\"\n             #filterInput\n             type=\"text\"\n             (input)=\"_onFilter($event)\"\n             [placeholder]=\"filterPlaceholder\"\n      >\n      <span class=\"nx-dropdown__filter-icon\" *ngIf=\"!isFilterEmpty\" (click)=\"_clearFilter()\">\n        <nx-icon name=\"close\"></nx-icon>\n      </span>\n    </div>\n\n    <div class=\"nx-dropdown__panel-body\"\n         tabindex=\"-1\"\n         role=\"listbox\"\n         #panelBody\n         [class.is-stable]=\"isStable\"\n         [attr.aria-activedescendant]=\"_getAriaActiveDescendant()\"\n         [attr.aria-multiselectable]=\"isMultiSelect\"\n    >\n        <ng-content></ng-content>\n      </div>\n  </div>\n</ng-template>\n",
                        changeDetection: core.ChangeDetectionStrategy.OnPush,
                        providers: [
                            { provide: NxDropdownControl, useExisting: NxDropdownComponent },
                            { provide: formfield.NxFormfieldControl, useExisting: NxDropdownComponent },
                        ],
                        host: {
                            'role': 'button',
                            '[class.nx-dropdown]': 'true',
                            '[class.is-filled]': 'hasValue',
                            '[class.has-focus]': 'focused',
                            '[class.nx-dropdown--negative]': '_negative',
                            '[class.nx-dropdown--disabled]': 'disabled',
                            '[attr.aria-describedby]': 'ariaDescribedby || null',
                            '[attr.aria-required]': 'required',
                            '[attr.aria-label]': '_getAriaLabel()',
                            'aria-haspopup': 'listbox',
                            '[attr.aria-expanded]': 'panelOpen',
                            '[attr.disabled]': 'disabled || null',
                            '[attr.tabindex]': 'tabIndex',
                            '(keydown)': '_handleKeydown($event)',
                            '(focus)': '_onFocus()',
                            '(blur)': '_onBlur()',
                            '(click)': 'openPanel()'
                        },
                        styles: [":host{display:block;width:100%}:host:focus{outline:0}:host(.nx-dropdown--negative):focus{font-weight:600}:host(.nx-dropdown--negative){color:#fff}.nx-dropdown__container{display:flex;justify-content:flex-end;align-items:center;height:100%;cursor:pointer}:host(.nx-dropdown--disabled) .nx-dropdown__container{cursor:not-allowed}.nx-dropdown__rendered{flex:1 1 auto;overflow:hidden;text-overflow:ellipsis;white-space:nowrap}.nx-dropdown__panel{box-shadow:0 2px 4px rgba(65,65,65,.5);border-radius:4px;min-width:100%}.nx-dropdown__panel ::ng-deep .nx-checkbox__label{font-size:20px;font-size:var(--dropdown-item-font-size,20px);line-height:28px;line-height:var(--dropdown-item-line-height,28px);font-weight:400;font-weight:var(--dropdown-item-font-weight,400);letter-spacing:.2px;letter-spacing:var(--dropdown-item-letter-spacing,.2px);display:flex;align-items:center}.nx-dropdown__panel:focus{outline:0}.nx-dropdown__panel--in-outline-field .nx-dropdown__panel-header{font-size:16px;font-size:var(--formfield-outline-label-font-size,16px);line-height:24px;line-height:var(--formfield-outline-label-line-height,24px);font-weight:600;font-weight:var(--formfield-outline-label-font-weight,600);letter-spacing:0;letter-spacing:var(--formfield-outline-label-letter-spacing,0)}.nx-dropdown__panel--in-outline-field .nx-dropdown__panel-body{max-height:calc(5 * (24px + 16px) + 16px);max-height:calc(5 * (var(--dropdown-item-outline-line-height,24px) + 16px) + 16px)}.nx-dropdown__panel--in-outline-field ::ng-deep .nx-dropdown-results__group-label{font-size:16px;font-size:var(--formfield-outline-label-font-size,16px);line-height:24px;line-height:var(--formfield-outline-label-line-height,24px);font-weight:var(--formfield-outline-label-font-weight,600);letter-spacing:0;letter-spacing:var(--formfield-outline-label-letter-spacing,0);font-style:normal;font-weight:700}.nx-dropdown__panel--in-outline-field ::ng-deep nx-dropdown-item .nx-dropdown-results__option,.nx-dropdown__panel--in-outline-field ::ng-deep nx-dropdown-item .nx-dropdown-results__option-label{font-size:16px;font-size:var(--dropdown-item-outline-font-size,16px);line-height:24px;line-height:var(--dropdown-item-outline-line-height,24px);font-weight:400;font-weight:var(--dropdown-item-outline-font-weight,400);letter-spacing:0;letter-spacing:var(--dropdown-item-outline-letter-spacing,0)}.nx-dropdown__panel--in-outline-field ::ng-deep nx-dropdown-item .nx-dropdown-results__option-checkicon{height:24px;height:var(--dropdown-item-outline-line-height,24px)}.nx-dropdown__panel--in-outline-field ::ng-deep .nx-dropdown__filter-input{font-size:16px;font-size:var(--formfield-outline-control-font-size,16px);line-height:24px;line-height:var(--formfield-outline-control-line-height,24px);font-weight:400;font-weight:var(--formfield-outline-control-font-weight,400);letter-spacing:0;letter-spacing:var(--formfield-outline-control-letter-spacing,0)}.nx-dropdown__panel--in-outline-field ::ng-deep .nx-dropdown__filter-input:empty{font-weight:300}.nx-dropdown__icon{font-size:24px;font-size:var(--dropdown-chevron-size,24px);line-height:0}.nx-dropdown__chevron{vertical-align:middle}.nx-dropdown__panel-header{font-size:12px;font-size:var(--formfield-label-font-size,12px);line-height:16px;line-height:var(--formfield-label-line-height,16px);font-weight:600;font-weight:var(--formfield-label-font-weight,600);letter-spacing:.5px;letter-spacing:var(--formfield-label-letter-spacing,.5px);color:#414141;color:var(--dropdown-panel-header-text-color,#414141);background-color:#ececec;background-color:var(--dropdown-panel-header-background-color,#ececec);padding:8px 32px;border-top-left-radius:4px;border-top-right-radius:4px;z-index:1}.nx-dropdown__panel-body{background-color:#fff;background-color:var(--dropdown-panel-background-color,#fff);max-height:calc(5 * (28px + 16px) + 16px);max-height:calc(5 * (var(--dropdown-item-line-height,28px) + 16px) + 16px);overflow-y:auto;outline:0}.nx-dropdown__filter{position:relative;padding:16px 32px 12px;background-color:#fff;background-color:var(--dropdown-panel-background-color,#fff)}.nx-dropdown__filter-input{font-size:20px;font-size:var(--formfield-control-font-size,20px);line-height:28px;line-height:var(--formfield-control-line-height,28px);font-weight:var(--formfield-control-font-weight,600);letter-spacing:.2px;letter-spacing:var(--formfield-control-letter-spacing,.2px);border:0;border-bottom:1px solid #767676;border-bottom:1px var(--dropdown-filter-input-border-color,#767676) solid;color:#414141;color:var(--dropdown-filter-input-text-color,#414141);width:100%;outline:0;background-color:transparent;padding:0 24px 3px 0;font-weight:300}.nx-dropdown__filter-input::-ms-clear{display:none}.nx-dropdown__panel.has-filter ::ng-deep nx-dropdown-item:first-of-type .nx-dropdown-results__option{padding-top:12px}.nx-dropdown__filter-icon{position:absolute;height:24px;right:32px;top:calc(16px + 1px);cursor:pointer}.nx-dropdown__filter-icon nx-icon{font-size:24px}.nx-dropdown__filter-input:focus{border-color:#007ab3;border-color:var(--dropdown-filter-input-active-border-color,#007ab3)}.nx-dropdown__filter-input.is-filled:focus{font-weight:600;color:#007ab3;color:var(--dropdown-filter-input-active-text-color,#007ab3);border-color:#007ab3;border-color:var(--dropdown-filter-input-active-border-color,#007ab3)}.nx-dropdown__filter-input.is-filled:focus+.nx-dropdown__filter-icon{color:#007ab3;color:var(--dropdown-filter-input-active-text-color,#007ab3)}@media screen and (-ms-high-contrast:active){.nx-dropdown__panel{box-shadow:0 0 0 1px windowText}.nx-dropdown__panel-header{border-bottom:1px solid windowText}.nx-dropdown__filter-input{border-bottom-color:buttonText}}"]
                    }] }
        ];
        /** @nocollapse */
        NxDropdownComponent.ctorParameters = function () { return [
            { type: core.ChangeDetectorRef },
            { type: core.ElementRef },
            { type: core.NgZone },
            { type: String, decorators: [{ type: core.Attribute, args: ['tabindex',] }] },
            { type: formfield.NxFormfieldComponent, decorators: [{ type: core.Optional }] },
            { type: forms.NgControl, decorators: [{ type: core.Self }, { type: core.Optional }] },
            { type: forms.NgForm, decorators: [{ type: core.Optional }] },
            { type: forms.FormGroupDirective, decorators: [{ type: core.Optional }] }
        ]; };
        NxDropdownComponent.propDecorators = {
            tabIndex: [{ type: core.Input }],
            _ariaLabel: [{ type: core.Input, args: ['nxAriaLabel',] }],
            value: [{ type: core.Input, args: ['nxValue',] }],
            disabled: [{ type: core.Input, args: ['nxDisabled',] }],
            required: [{ type: core.Input, args: ['nxRequired',] }],
            styles: [{ type: core.Input, args: ['nxStyle',] }],
            showFilter: [{ type: core.Input, args: ['nxShowFilter',] }],
            filterPlaceholder: [{ type: core.Input, args: ['nxFilterPlaceholder',] }],
            openedChange: [{ type: core.Output }],
            _openedStream: [{ type: core.Output, args: ['opened',] }],
            _closedStream: [{ type: core.Output, args: ['closed',] }],
            filterChanges: [{ type: core.Output, args: ['filterInput',] }],
            valueChange: [{ type: core.Output, args: ['nxValueChange',] }],
            selectionChange: [{ type: core.Output }],
            panel: [{ type: core.ViewChild, args: ['panel', { static: false },] }],
            panelBody: [{ type: core.ViewChild, args: ['panelBody', { static: false },] }],
            trigger: [{ type: core.ViewChild, args: ['trigger', { static: true },] }],
            filterInput: [{ type: core.ViewChild, args: ['filterInput', { static: false },] }],
            overlayDir: [{ type: core.ViewChild, args: [overlay.CdkConnectedOverlay, { static: true },] }],
            options: [{ type: core.ContentChildren, args: [NxDropdownItemComponent, { descendants: true },] }],
            groups: [{ type: core.ContentChildren, args: [NxDropdownGroupComponent,] }],
            _customClosedDropdownLabel: [{ type: core.ContentChild, args: [NxDropdownClosedLabelDirective, { static: false },] }],
            _defaultClosedDropdownLabel: [{ type: core.ViewChild, args: ['defaultClosedDropdownLabel', { static: true },] }],
            valueFormatter: [{ type: core.Input, args: ['nxValueFormatter',] }],
            compareWith: [{ type: core.Input }],
            filterFn: [{ type: core.Input }]
        };
        return NxDropdownComponent;
    }(NxDropdownControl));
    if (false) {
        /** @type {?} */
        NxDropdownComponent.prototype.readonly;
        /**
         * @type {?}
         * @private
         */
        NxDropdownComponent.prototype._selectionModel;
        /**
         * @type {?}
         * @protected
         */
        NxDropdownComponent.prototype._disabled;
        /**
         * @type {?}
         * @private
         */
        NxDropdownComponent.prototype._focused;
        /**
         * Whether or not the overlay panel is open.
         * @type {?}
         * @private
         */
        NxDropdownComponent.prototype._panelOpen;
        /**
         * \@docs-private
         * @type {?}
         */
        NxDropdownComponent.prototype.errorState;
        /**
         * \@docs-private
         * @type {?}
         */
        NxDropdownComponent.prototype.isStable;
        /**
         * Name of this control that is used inside the formfield component
         * \@docs-private
         * @type {?}
         */
        NxDropdownComponent.prototype.controlType;
        /**
         * Holds the value from nxValue.
         * @type {?}
         * @private
         */
        NxDropdownComponent.prototype._value;
        /**
         * The minimal space between the viewport and the overlay
         * @type {?}
         */
        NxDropdownComponent.prototype._overlayViewportMargin;
        /**
         * The last measured value for the trigger's client bounding rect.
         * @type {?}
         */
        NxDropdownComponent.prototype._triggerRect;
        /**
         * Holds the panelWidth after panel was attached.
         * @type {?}
         */
        NxDropdownComponent.prototype._panelWidth;
        /**
         * \@docs-private
         * Emits when internal state changes to inform formfield about it.
         * @type {?}
         */
        NxDropdownComponent.prototype.stateChanges;
        /**
         * The IDs of child options to be passed to the aria-owns attribute.
         * @type {?}
         */
        NxDropdownComponent.prototype._optionIds;
        /**
         * \@docs-private
         * @type {?}
         */
        NxDropdownComponent.prototype.ariaDescribedby;
        /**
         * @type {?}
         * @private
         */
        NxDropdownComponent.prototype._tabIndex;
        /**
         * \@docs-private
         * @type {?}
         */
        NxDropdownComponent.prototype.currentFilter;
        /**
         * Label to describe the component.
         * @type {?}
         */
        NxDropdownComponent.prototype._ariaLabel;
        /**
         * Whether the component is required. This adds an aria-required label to the component.
         * @type {?}
         */
        NxDropdownComponent.prototype.required;
        /**
         * @type {?}
         * @private
         */
        NxDropdownComponent.prototype._style;
        /**
         * Whether the dropdown should render in its negative style or not.
         * @type {?}
         */
        NxDropdownComponent.prototype._negative;
        /**
         * Whether the dropdown should be shown with an additional filter input.
         * @type {?}
         */
        NxDropdownComponent.prototype.showFilter;
        /**
         * Text displayed as placeholder for the filter.
         * @type {?}
         */
        NxDropdownComponent.prototype.filterPlaceholder;
        /**
         * Event emitted when the select panel has been toggled.
         * @type {?}
         */
        NxDropdownComponent.prototype.openedChange;
        /**
         * Event emitted when the select has been opened.
         * @type {?}
         */
        NxDropdownComponent.prototype._openedStream;
        /**
         * Event emitted when the select has been closed.
         * @type {?}
         */
        NxDropdownComponent.prototype._closedStream;
        /**
         * Event emitted when the user types in the filter input.
         * @type {?}
         */
        NxDropdownComponent.prototype.filterChanges;
        /**
         * Event that emits whenever the raw value of the select changes. This is here primarily
         * to facilitate the two-way binding for the `value` input.
         * \@docs-private
         * @type {?}
         */
        NxDropdownComponent.prototype.valueChange;
        /**
         * Event emitted when the selected value has been changed.
         * @type {?}
         */
        NxDropdownComponent.prototype.selectionChange;
        /**
         * \@docs-private
         * @type {?}
         */
        NxDropdownComponent.prototype.optionSelectionChanges;
        /**
         * This position config ensures that the top "start" corner of the overlay
         * is aligned with with the top "start" of the origin by default (overlapping
         * the trigger completely). If the panel cannot fit below the trigger, it
         * will fall back to a position above the trigger.
         * @type {?}
         */
        NxDropdownComponent.prototype._positions;
        /**
         * \@docs-private
         * Panel containing the select options.
         * @type {?}
         */
        NxDropdownComponent.prototype.panel;
        /**
         * \@docs-private
         * @type {?}
         */
        NxDropdownComponent.prototype.panelBody;
        /**
         * \@docs-private
         * @type {?}
         */
        NxDropdownComponent.prototype.trigger;
        /**
         * \@docs-private
         * @type {?}
         */
        NxDropdownComponent.prototype.filterInput;
        /**
         * \@docs-private
         * Overlay pane containing the options.
         * @type {?}
         */
        NxDropdownComponent.prototype.overlayDir;
        /**
         * \@docs-private
         * @type {?}
         */
        NxDropdownComponent.prototype.options;
        /**
         * \@docs-private
         * @type {?}
         */
        NxDropdownComponent.prototype.groups;
        /** @type {?} */
        NxDropdownComponent.prototype._customClosedDropdownLabel;
        /**
         * @type {?}
         * @private
         */
        NxDropdownComponent.prototype._defaultClosedDropdownLabel;
        /**
         * @type {?}
         * @private
         */
        NxDropdownComponent.prototype._closedDropdownLabel;
        /**
         * Emits whenever the component is destroyed.
         * @type {?}
         * @private
         */
        NxDropdownComponent.prototype._destroy;
        /**
         * @type {?}
         * @private
         */
        NxDropdownComponent.prototype._keyManager;
        /**
         * Function that transforms the value into a string.
         * This function is used for displaying and filtering the content
         * ( Default: (value) => value ? value.toString() : null; ).
         * @type {?}
         */
        NxDropdownComponent.prototype.valueFormatter;
        /**
         * Comparison function to specify which option is displayed. Defaults to object equality.
         * @type {?}
         * @private
         */
        NxDropdownComponent.prototype._compareWith;
        /**
         * @type {?}
         * @private
         */
        NxDropdownComponent.prototype._filterFn;
        /**
         * `View -> model callback called when value changes`
         * @type {?}
         */
        NxDropdownComponent.prototype._onChange;
        /**
         * `View -> model callback called when select has been touched`
         * @type {?}
         */
        NxDropdownComponent.prototype._onTouched;
        /**
         * @type {?}
         * @private
         */
        NxDropdownComponent.prototype._changeDetectorRef;
        /**
         * @type {?}
         * @private
         */
        NxDropdownComponent.prototype._elementRef;
        /**
         * @type {?}
         * @private
         */
        NxDropdownComponent.prototype._ngZone;
        /**
         * @type {?}
         * @private
         */
        NxDropdownComponent.prototype.formFieldComponent;
        /**
         * \@docs-private
         * @type {?}
         */
        NxDropdownComponent.prototype.ngControl;
        /**
         * @type {?}
         * @private
         */
        NxDropdownComponent.prototype._parentForm;
        /**
         * @type {?}
         * @private
         */
        NxDropdownComponent.prototype._parentFormGroup;
    }

    /**
     * @fileoverview added by tsickle
     * Generated from: dropdown.module.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var NxDropdownModule = /** @class */ (function () {
        function NxDropdownModule() {
        }
        NxDropdownModule.decorators = [
            { type: core.NgModule, args: [{
                        imports: [
                            common.CommonModule,
                            formfield.NxFormfieldModule,
                            checkbox.NxCheckboxModule,
                            overlay.OverlayModule,
                            a11y.A11yModule,
                            icon.NxIconModule,
                            observers.ObserversModule
                        ],
                        declarations: [
                            NxDropdownComponent,
                            NxDropdownItemComponent,
                            NxDropdownGroupComponent,
                            NxDropdownClosedLabelDirective
                        ],
                        exports: [
                            NxDropdownComponent,
                            NxDropdownItemComponent,
                            NxDropdownGroupComponent,
                            NxDropdownClosedLabelDirective
                        ]
                    },] }
        ];
        return NxDropdownModule;
    }());

    exports.NxDropdownComponent = NxDropdownComponent;
    exports.NxDropdownGroupComponent = NxDropdownGroupComponent;
    exports.NxDropdownItemChange = NxDropdownItemChange;
    exports.NxDropdownItemComponent = NxDropdownItemComponent;
    exports.NxDropdownModule = NxDropdownModule;
    exports.NxDropdownSelectChange = NxDropdownSelectChange;
    exports.ɵa = NxDropdownControl;
    exports.ɵb = NxDropdownClosedLabelDirective;

    Object.defineProperty(exports, '__esModule', { value: true });

})));
//# sourceMappingURL=allianz-ngx-ndbx-dropdown.umd.js.map
