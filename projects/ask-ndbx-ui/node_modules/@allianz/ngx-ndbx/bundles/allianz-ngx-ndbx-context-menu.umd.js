(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@angular/cdk/overlay'), require('@angular/common'), require('@angular/core'), require('@angular/cdk/portal'), require('rxjs'), require('@angular/cdk/a11y'), require('@angular/cdk/keycodes'), require('rxjs/operators'), require('@angular/animations'), require('@angular/cdk/coercion'), require('@angular/cdk/bidi'), require('@angular/cdk/platform'), require('@allianz/ngx-ndbx/icon')) :
    typeof define === 'function' && define.amd ? define('@allianz/ngx-ndbx/context-menu', ['exports', '@angular/cdk/overlay', '@angular/common', '@angular/core', '@angular/cdk/portal', 'rxjs', '@angular/cdk/a11y', '@angular/cdk/keycodes', 'rxjs/operators', '@angular/animations', '@angular/cdk/coercion', '@angular/cdk/bidi', '@angular/cdk/platform', '@allianz/ngx-ndbx/icon'], factory) :
    (global = global || self, factory((global.allianz = global.allianz || {}, global.allianz['ngx-ndbx'] = global.allianz['ngx-ndbx'] || {}, global.allianz['ngx-ndbx']['context-menu'] = {}), global.ng.cdk.overlay, global.ng.common, global.ng.core, global.ng.cdk.portal, global.rxjs, global.ng.cdk.a11y, global.ng.cdk.keycodes, global.rxjs.operators, global.ng.animations, global.ng.cdk.coercion, global.ng.cdk.bidi, global.ng.cdk.platform, global.allianz['ngx-ndbx'].icon));
}(this, (function (exports, overlay, common, core, portal, rxjs, a11y, keycodes, operators, animations, coercion, bidi, platform, icon) { 'use strict';

    /*! *****************************************************************************
    Copyright (c) Microsoft Corporation. All rights reserved.
    Licensed under the Apache License, Version 2.0 (the "License"); you may not use
    this file except in compliance with the License. You may obtain a copy of the
    License at http://www.apache.org/licenses/LICENSE-2.0

    THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
    WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
    MERCHANTABLITY OR NON-INFRINGEMENT.

    See the Apache Version 2.0 License for specific language governing permissions
    and limitations under the License.
    ***************************************************************************** */
    /* global Reflect, Promise */

    var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };

    function __extends(d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    }

    var __assign = function() {
        __assign = Object.assign || function __assign(t) {
            for (var s, i = 1, n = arguments.length; i < n; i++) {
                s = arguments[i];
                for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
            }
            return t;
        };
        return __assign.apply(this, arguments);
    };

    function __rest(s, e) {
        var t = {};
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
            t[p] = s[p];
        if (s != null && typeof Object.getOwnPropertySymbols === "function")
            for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
                if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                    t[p[i]] = s[p[i]];
            }
        return t;
    }

    function __decorate(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    }

    function __param(paramIndex, decorator) {
        return function (target, key) { decorator(target, key, paramIndex); }
    }

    function __metadata(metadataKey, metadataValue) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(metadataKey, metadataValue);
    }

    function __awaiter(thisArg, _arguments, P, generator) {
        return new (P || (P = Promise))(function (resolve, reject) {
            function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
            function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
            function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
            step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
    }

    function __generator(thisArg, body) {
        var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
        return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
        function verb(n) { return function (v) { return step([n, v]); }; }
        function step(op) {
            if (f) throw new TypeError("Generator is already executing.");
            while (_) try {
                if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
                if (y = 0, t) op = [op[0] & 2, t.value];
                switch (op[0]) {
                    case 0: case 1: t = op; break;
                    case 4: _.label++; return { value: op[1], done: false };
                    case 5: _.label++; y = op[1]; op = [0]; continue;
                    case 7: op = _.ops.pop(); _.trys.pop(); continue;
                    default:
                        if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                        if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                        if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                        if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                        if (t[2]) _.ops.pop();
                        _.trys.pop(); continue;
                }
                op = body.call(thisArg, _);
            } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
            if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
        }
    }

    function __exportStar(m, exports) {
        for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
    }

    function __values(o) {
        var m = typeof Symbol === "function" && o[Symbol.iterator], i = 0;
        if (m) return m.call(o);
        return {
            next: function () {
                if (o && i >= o.length) o = void 0;
                return { value: o && o[i++], done: !o };
            }
        };
    }

    function __read(o, n) {
        var m = typeof Symbol === "function" && o[Symbol.iterator];
        if (!m) return o;
        var i = m.call(o), r, ar = [], e;
        try {
            while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
        }
        catch (error) { e = { error: error }; }
        finally {
            try {
                if (r && !r.done && (m = i["return"])) m.call(i);
            }
            finally { if (e) throw e.error; }
        }
        return ar;
    }

    function __spread() {
        for (var ar = [], i = 0; i < arguments.length; i++)
            ar = ar.concat(__read(arguments[i]));
        return ar;
    }

    function __spreadArrays() {
        for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
        for (var r = Array(s), k = 0, i = 0; i < il; i++)
            for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
                r[k] = a[j];
        return r;
    };

    function __await(v) {
        return this instanceof __await ? (this.v = v, this) : new __await(v);
    }

    function __asyncGenerator(thisArg, _arguments, generator) {
        if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
        var g = generator.apply(thisArg, _arguments || []), i, q = [];
        return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i;
        function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }
        function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }
        function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }
        function fulfill(value) { resume("next", value); }
        function reject(value) { resume("throw", value); }
        function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }
    }

    function __asyncDelegator(o) {
        var i, p;
        return i = {}, verb("next"), verb("throw", function (e) { throw e; }), verb("return"), i[Symbol.iterator] = function () { return this; }, i;
        function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === "return" } : f ? f(v) : v; } : f; }
    }

    function __asyncValues(o) {
        if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
        var m = o[Symbol.asyncIterator], i;
        return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);
        function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }
        function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }
    }

    function __makeTemplateObject(cooked, raw) {
        if (Object.defineProperty) { Object.defineProperty(cooked, "raw", { value: raw }); } else { cooked.raw = raw; }
        return cooked;
    };

    function __importStar(mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
        result.default = mod;
        return result;
    }

    function __importDefault(mod) {
        return (mod && mod.__esModule) ? mod : { default: mod };
    }

    /**
     * @fileoverview added by tsickle
     * Generated from: context-menu-content.directive.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * Context menu content that will be rendered lazily once the menu is opened.
     */
    var NxContextMenuContentDirective = /** @class */ (function () {
        function NxContextMenuContentDirective(_template, _componentFactoryResolver, _appRef, _injector, _viewContainerRef, _document) {
            this._template = _template;
            this._componentFactoryResolver = _componentFactoryResolver;
            this._appRef = _appRef;
            this._injector = _injector;
            this._viewContainerRef = _viewContainerRef;
            this._document = _document;
            /**
             * Emits when the menu content has been attached.
             */
            this._attached = new rxjs.Subject();
        }
        /**
         * Attaches the content with a particular context.
         * @docs-private
         */
        /**
         * Attaches the content with a particular context.
         * \@docs-private
         * @param {?=} context
         * @return {?}
         */
        NxContextMenuContentDirective.prototype.attach = /**
         * Attaches the content with a particular context.
         * \@docs-private
         * @param {?=} context
         * @return {?}
         */
        function (context) {
            if (context === void 0) { context = {}; }
            if (!this._portal) {
                this._portal = new portal.TemplatePortal(this._template, this._viewContainerRef);
            }
            this.detach();
            if (!this._outlet) {
                this._outlet = new portal.DomPortalOutlet(this._document.createElement('div'), this._componentFactoryResolver, this._appRef, this._injector);
            }
            /** @type {?} */
            var element = this._template.elementRef.nativeElement;
            // Because we support opening the same menu from different triggers (which in turn have their
            // own `OverlayRef` panel), we have to re-insert the host element every time, otherwise we
            // risk it staying attached to a pane that's no longer in the DOM.
            if (element.parentNode) {
                element.parentNode.insertBefore(this._outlet.outletElement, element);
            }
            this._portal.attach(this._outlet, context);
            this._attached.next();
        };
        /**
         * Detaches the content.
         * @docs-private
         */
        /**
         * Detaches the content.
         * \@docs-private
         * @return {?}
         */
        NxContextMenuContentDirective.prototype.detach = /**
         * Detaches the content.
         * \@docs-private
         * @return {?}
         */
        function () {
            if (this._portal.isAttached) {
                this._portal.detach();
            }
        };
        /**
         * @return {?}
         */
        NxContextMenuContentDirective.prototype.ngOnDestroy = /**
         * @return {?}
         */
        function () {
            if (this._outlet) {
                this._outlet.dispose();
            }
        };
        NxContextMenuContentDirective.decorators = [
            { type: core.Directive, args: [{
                        selector: 'ng-template[nxContextMenuContent]'
                    },] }
        ];
        /** @nocollapse */
        NxContextMenuContentDirective.ctorParameters = function () { return [
            { type: core.TemplateRef },
            { type: core.ComponentFactoryResolver },
            { type: core.ApplicationRef },
            { type: core.Injector },
            { type: core.ViewContainerRef },
            { type: undefined, decorators: [{ type: core.Inject, args: [common.DOCUMENT,] }] }
        ]; };
        return NxContextMenuContentDirective;
    }());
    if (false) {
        /**
         * @type {?}
         * @private
         */
        NxContextMenuContentDirective.prototype._portal;
        /**
         * @type {?}
         * @private
         */
        NxContextMenuContentDirective.prototype._outlet;
        /**
         * Emits when the menu content has been attached.
         * @type {?}
         */
        NxContextMenuContentDirective.prototype._attached;
        /**
         * @type {?}
         * @private
         */
        NxContextMenuContentDirective.prototype._template;
        /**
         * @type {?}
         * @private
         */
        NxContextMenuContentDirective.prototype._componentFactoryResolver;
        /**
         * @type {?}
         * @private
         */
        NxContextMenuContentDirective.prototype._appRef;
        /**
         * @type {?}
         * @private
         */
        NxContextMenuContentDirective.prototype._injector;
        /**
         * @type {?}
         * @private
         */
        NxContextMenuContentDirective.prototype._viewContainerRef;
        /**
         * @type {?}
         * @private
         */
        NxContextMenuContentDirective.prototype._document;
    }

    /**
     * @fileoverview added by tsickle
     * Generated from: context-menu-animations.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * Animations used by the NxContextMenuComponent.
     * \@docs-private
     * @type {?}
     */
    var nxContextMenuAnimations = {
        /**
         * This animation controls the context menu panel's entry and exit from the page.
         * When the context menu panel is added to the DOM, it scales in and fades in its border.
         * When the context menu panel is removed from the DOM, it simply fades out.
         */
        transformContextMenu: animations.trigger('transformContextMenu', [
            animations.state('void', animations.style({
                opacity: 0,
                transform: 'scale(0.8)'
            })),
            animations.transition('void => enter', animations.group([
                animations.query('.nx-context-menu__content', animations.animate('100ms linear', animations.style({
                    opacity: 1
                }))),
                animations.animate('120ms cubic-bezier(0, 0, 0.2, 1)', animations.style({ transform: 'scale(1)' })),
            ])),
            animations.transition('* => void', animations.animate('100ms linear', animations.style({ opacity: 0 })))
        ])
    };

    /**
     * @fileoverview added by tsickle
     * Generated from: context-menu.component.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var NxContextMenuComponent = /** @class */ (function () {
        function NxContextMenuComponent(_ngZone) {
            this._ngZone = _ngZone;
            /**
             * Menu items inside the current menu.
             */
            this._items = [];
            /**
             * Emits whenever the amount of menu items changes.
             */
            this._itemChanges = new rxjs.Subject();
            /**
             * Subscription to tab events on the menu panel
             */
            this._tabSubscription = rxjs.Subscription.EMPTY;
            /**
             * Config object to be passed into the menu's ngClass
             */
            this._classList = {};
            /**
             * Current state of the panel animation.
             */
            this._panelAnimationState = 'void';
            /**
             * Emits whenever an animation on the menu completes.
             */
            this._animationDone = new rxjs.Subject();
            /**
             * Event emitted when the menu is closed.
             */
            this.closed = new core.EventEmitter();
        }
        /**
         * @return {?}
         */
        NxContextMenuComponent.prototype.ngAfterContentInit = /**
         * @return {?}
         */
        function () {
            var _this = this;
            this._keyManager = new a11y.FocusKeyManager(this._items)
                .withWrap()
                .withTypeAhead();
            this._tabSubscription = this._keyManager.tabOut.subscribe((/**
             * @return {?}
             */
            function () {
                return _this.closed.emit('tab');
            }));
        };
        /**
         * @return {?}
         */
        NxContextMenuComponent.prototype.ngOnDestroy = /**
         * @return {?}
         */
        function () {
            this._tabSubscription.unsubscribe();
            this.closed.complete();
        };
        /** Stream that emits whenever the hovered menu item changes. */
        /**
         * Stream that emits whenever the hovered menu item changes.
         * @return {?}
         */
        NxContextMenuComponent.prototype._hovered = /**
         * Stream that emits whenever the hovered menu item changes.
         * @return {?}
         */
        function () {
            return this._itemChanges.pipe(operators.startWith(this._items), operators.switchMap((/**
             * @param {?} items
             * @return {?}
             */
            function (items) { return rxjs.merge.apply(void 0, __spread(items.map((/**
             * @param {?} item
             * @return {?}
             */
            function (item) { return item._hovered; })))); })));
        };
        /** Handle a keyboard event from the menu, delegating to the appropriate action. */
        /**
         * Handle a keyboard event from the menu, delegating to the appropriate action.
         * @param {?} event
         * @return {?}
         */
        NxContextMenuComponent.prototype._handleKeydown = /**
         * Handle a keyboard event from the menu, delegating to the appropriate action.
         * @param {?} event
         * @return {?}
         */
        function (event) {
            /** @type {?} */
            var keyCode = event.keyCode;
            /** @type {?} */
            var manager = this._keyManager;
            switch (keyCode) {
                case keycodes.ESCAPE:
                    if (!keycodes.hasModifierKey(event)) {
                        event.preventDefault();
                        this.closed.emit('keydown');
                    }
                    break;
                case keycodes.LEFT_ARROW:
                    if (this.parentMenu && this.direction === 'ltr') {
                        this.closed.emit('keydown');
                    }
                    break;
                case keycodes.RIGHT_ARROW:
                    if (this.parentMenu && this.direction === 'rtl') {
                        this.closed.emit('keydown');
                    }
                    break;
                case keycodes.HOME:
                case keycodes.END:
                    if (!keycodes.hasModifierKey(event)) {
                        keyCode === keycodes.HOME
                            ? manager.setFirstItemActive()
                            : manager.setLastItemActive();
                        event.preventDefault();
                    }
                    break;
                default:
                    manager.onKeydown(event);
            }
        };
        /**
         * Focus the first item in the menu.
         */
        /**
         * Focus the first item in the menu.
         * @return {?}
         */
        NxContextMenuComponent.prototype.focusFirstItem = /**
         * Focus the first item in the menu.
         * @return {?}
         */
        function () {
            var _this = this;
            // When the content is rendered lazily, it takes a bit before the items are inside the DOM.
            if (this.lazyContent) {
                this._ngZone.onStable
                    .asObservable()
                    .pipe(operators.take(1))
                    .subscribe((/**
                 * @return {?}
                 */
                function () {
                    return _this._keyManager.setFirstItemActive();
                }));
            }
            else {
                this._keyManager.setFirstItemActive();
            }
        };
        /**
         * Resets the active item in the menu. This is used when the menu is opened, allowing
         * the user to start from the first option when pressing the down arrow.
         */
        /**
         * Resets the active item in the menu. This is used when the menu is opened, allowing
         * the user to start from the first option when pressing the down arrow.
         * @return {?}
         */
        NxContextMenuComponent.prototype.resetActiveItem = /**
         * Resets the active item in the menu. This is used when the menu is opened, allowing
         * the user to start from the first option when pressing the down arrow.
         * @return {?}
         */
        function () {
            this._keyManager.setActiveItem(-1);
        };
        /**
         * Registers a menu item with the context menu.
         * @docs-private
         */
        /**
         * Registers a menu item with the context menu.
         * \@docs-private
         * @param {?} item
         * @return {?}
         */
        NxContextMenuComponent.prototype.addItem = /**
         * Registers a menu item with the context menu.
         * \@docs-private
         * @param {?} item
         * @return {?}
         */
        function (item) {
            // We register the items through this method, rather than picking them up through
            // `ContentChildren`, because we need the items to be picked up by their closest
            // `nx-context-menu` ancestor. If we used `@ContentChildren(NxContextMenuItem, {descendants: true})`,
            // all descendant items will bleed into the top-level menu in the case where the consumer
            // has `nx-context-menu` instances nested inside each other.
            if (this._items.indexOf(item) === -1) {
                this._items.push(item);
                this._itemChanges.next(this._items);
            }
        };
        /**
         * Removes an item from the context menu.
         * @docs-private
         */
        /**
         * Removes an item from the context menu.
         * \@docs-private
         * @param {?} item
         * @return {?}
         */
        NxContextMenuComponent.prototype.removeItem = /**
         * Removes an item from the context menu.
         * \@docs-private
         * @param {?} item
         * @return {?}
         */
        function (item) {
            /** @type {?} */
            var index = this._items.indexOf(item);
            if (this._items.indexOf(item) > -1) {
                this._items.splice(index, 1);
                this._itemChanges.next(this._items);
            }
        };
        /** Starts the enter animation. */
        /**
         * Starts the enter animation.
         * @return {?}
         */
        NxContextMenuComponent.prototype._startAnimation = /**
         * Starts the enter animation.
         * @return {?}
         */
        function () {
            this._panelAnimationState = 'enter';
        };
        /** Resets the panel animation to its initial state. */
        /**
         * Resets the panel animation to its initial state.
         * @return {?}
         */
        NxContextMenuComponent.prototype._resetAnimation = /**
         * Resets the panel animation to its initial state.
         * @return {?}
         */
        function () {
            this._panelAnimationState = 'void';
        };
        /** Callback that is invoked when the panel animation completes. */
        /**
         * Callback that is invoked when the panel animation completes.
         * @param {?} event
         * @return {?}
         */
        NxContextMenuComponent.prototype._onAnimationDone = /**
         * Callback that is invoked when the panel animation completes.
         * @param {?} event
         * @return {?}
         */
        function (event) {
            this._animationDone.next(event);
            this._isAnimating = false;
        };
        /**
         * @param {?} event
         * @return {?}
         */
        NxContextMenuComponent.prototype._onAnimationStart = /**
         * @param {?} event
         * @return {?}
         */
        function (event) {
            this._isAnimating = true;
            // Scroll the content element to the top as soon as the animation starts. This is necessary,
            // because we move focus to the first item while it's still being animated, which can throw
            // the browser off when it determines the scroll position. Alternatively we can move focus
            // when the animation is done, however moving focus asynchronously will interrupt screen
            // readers which are in the process of reading out the menu already. We take the `element`
            // from the `event` since we can't use a `ViewChild` to access the pane.
            if (event.toState === 'enter' && this._keyManager.activeItemIndex === 0) {
                event.element.scrollTop = 0;
            }
        };
        NxContextMenuComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'nx-context-menu',
                        template: "<ng-template>\n  <div class=\"nx-context-menu\"\n    [ngClass]=\"_classList\"\n    (keydown)=\"_handleKeydown($event)\"\n    (click)=\"closed.emit('click')\"\n    [@transformContextMenu]=\"_panelAnimationState\"\n    (@transformContextMenu.start)=\"_onAnimationStart($event)\"\n    (@transformContextMenu.done)=\"_onAnimationDone($event)\"\n    tabindex=\"-1\"\n    role=\"menu\">\n    <div class=\"nx-context-menu__content\">\n      <ng-content></ng-content>\n    </div>\n  </div>\n</ng-template>\n",
                        changeDetection: core.ChangeDetectionStrategy.OnPush,
                        exportAs: 'nxContextMenu',
                        animations: [
                            nxContextMenuAnimations.transformContextMenu
                        ],
                        styles: [".nx-context-menu{border-radius:4px;background:#fff;background:var(--context-menu-background-color,#fff);min-height:64px;box-shadow:0 2px 4px rgba(65,65,65,.5);outline:0}.nx-context-menu.ng-animating{pointer-events:none}.nx-context-menu__content:not(:empty){padding-top:16px;padding-bottom:16px;display:flex;flex-direction:column}@media screen and (-ms-high-contrast:active){.nx-context-menu{border:1px solid windowText}.nx-context-menu__content:not(:empty){background-color:buttonFace}}"]
                    }] }
        ];
        /** @nocollapse */
        NxContextMenuComponent.ctorParameters = function () { return [
            { type: core.NgZone }
        ]; };
        NxContextMenuComponent.propDecorators = {
            templateRef: [{ type: core.ViewChild, args: [core.TemplateRef, { static: false },] }],
            lazyContent: [{ type: core.ContentChild, args: [NxContextMenuContentDirective, { static: false },] }],
            closed: [{ type: core.Output }]
        };
        return NxContextMenuComponent;
    }());
    if (false) {
        /**
         * @type {?}
         * @private
         */
        NxContextMenuComponent.prototype._keyManager;
        /**
         * Menu items inside the current menu.
         * @type {?}
         * @private
         */
        NxContextMenuComponent.prototype._items;
        /**
         * Emits whenever the amount of menu items changes.
         * @type {?}
         * @private
         */
        NxContextMenuComponent.prototype._itemChanges;
        /**
         * Subscription to tab events on the menu panel
         * @type {?}
         * @private
         */
        NxContextMenuComponent.prototype._tabSubscription;
        /**
         * Config object to be passed into the menu's ngClass
         * @type {?}
         */
        NxContextMenuComponent.prototype._classList;
        /**
         * Current state of the panel animation.
         * @type {?}
         */
        NxContextMenuComponent.prototype._panelAnimationState;
        /**
         * Emits whenever an animation on the menu completes.
         * @type {?}
         */
        NxContextMenuComponent.prototype._animationDone;
        /**
         * Whether the menu is animating.
         * @type {?}
         */
        NxContextMenuComponent.prototype._isAnimating;
        /**
         * Parent menu of the current menu panel.
         * @type {?}
         */
        NxContextMenuComponent.prototype.parentMenu;
        /**
         * \@docs-private
         * Layout direction of the menu.
         * @type {?}
         */
        NxContextMenuComponent.prototype.direction;
        /**
         * \@docs-private
         * @type {?}
         */
        NxContextMenuComponent.prototype.templateRef;
        /**
         * Menu content that will be rendered lazily.
         * \@docs-private
         * @type {?}
         */
        NxContextMenuComponent.prototype.lazyContent;
        /**
         * Event emitted when the menu is closed.
         * @type {?}
         */
        NxContextMenuComponent.prototype.closed;
        /**
         * @type {?}
         * @private
         */
        NxContextMenuComponent.prototype._ngZone;
    }

    /**
     * @fileoverview added by tsickle
     * Generated from: context-menu-item.component.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * This directive is intended to be used inside an nx-context-menu tag.
     * It exists mostly to set the role attribute, disabled state and styling.
     */
    var NxContextMenuItemComponent = /** @class */ (function () {
        function NxContextMenuItemComponent(_elementRef, document, _changeDetectorRef, _parentMenu) {
            this._elementRef = _elementRef;
            this._changeDetectorRef = _changeDetectorRef;
            this._parentMenu = _parentMenu;
            /**
             * Stream that emits when the context menu item is hovered.
             */
            this._hovered = new rxjs.Subject();
            this._disabled = false;
            /**
             * Whether the context menu item is highlighted.
             */
            this._highlighted = false;
            /**
             * Whether the context menu item acts as a trigger for a sub-menu.
             */
            this._triggersSubmenu = false;
            if (_parentMenu && _parentMenu.addItem) {
                _parentMenu.addItem(this);
            }
            this._document = document;
        }
        Object.defineProperty(NxContextMenuItemComponent.prototype, "disabled", {
            get: /**
             * @return {?}
             */
            function () {
                return this._disabled;
            },
            /** Whether the context menu item is disabled. */
            set: /**
             * Whether the context menu item is disabled.
             * @param {?} value
             * @return {?}
             */
            function (value) {
                this._disabled = coercion.coerceBooleanProperty(value);
                this._changeDetectorRef.markForCheck();
            },
            enumerable: true,
            configurable: true
        });
        /** Focuses this context menu item. */
        /**
         * Focuses this context menu item.
         * @return {?}
         */
        NxContextMenuItemComponent.prototype.focus = /**
         * Focuses this context menu item.
         * @return {?}
         */
        function () {
            this._getHostElement().focus();
        };
        /**
         * @return {?}
         */
        NxContextMenuItemComponent.prototype.ngOnDestroy = /**
         * @return {?}
         */
        function () {
            if (this._parentMenu && this._parentMenu.removeItem) {
                this._parentMenu.removeItem(this);
            }
            this._hovered.complete();
        };
        /** Used to set the `tabindex`. */
        /**
         * Used to set the `tabindex`.
         * @return {?}
         */
        NxContextMenuItemComponent.prototype._getTabIndex = /**
         * Used to set the `tabindex`.
         * @return {?}
         */
        function () {
            return this.disabled ? '-1' : '0';
        };
        /** Returns the host DOM element. */
        /**
         * Returns the host DOM element.
         * @return {?}
         */
        NxContextMenuItemComponent.prototype._getHostElement = /**
         * Returns the host DOM element.
         * @return {?}
         */
        function () {
            return this._elementRef.nativeElement;
        };
        /** Prevents the default element actions if it is disabled. */
        /**
         * Prevents the default element actions if it is disabled.
         * @param {?} event
         * @return {?}
         */
        NxContextMenuItemComponent.prototype._checkDisabled = /**
         * Prevents the default element actions if it is disabled.
         * @param {?} event
         * @return {?}
         */
        function (event) {
            if (this.disabled) {
                event.preventDefault();
                event.stopPropagation();
            }
        };
        /** Emits to the hover stream. */
        /**
         * Emits to the hover stream.
         * @return {?}
         */
        NxContextMenuItemComponent.prototype._handleMouseEnter = /**
         * Emits to the hover stream.
         * @return {?}
         */
        function () {
            this._hovered.next(this);
        };
        /** Gets the label to be used when determining whether the option should be focused. */
        /**
         * Gets the label to be used when determining whether the option should be focused.
         * @return {?}
         */
        NxContextMenuItemComponent.prototype.getLabel = /**
         * Gets the label to be used when determining whether the option should be focused.
         * @return {?}
         */
        function () {
            /** @type {?} */
            var element = this._elementRef.nativeElement;
            /** @type {?} */
            var textNodeType = this._document ? this._document.TEXT_NODE : 3;
            /** @type {?} */
            var output = '';
            if (element.childNodes) {
                /** @type {?} */
                var length_1 = element.childNodes.length;
                // Go through all the top-level text nodes and extract their text.
                // We skip anything that's not a text node to prevent the text from
                // being thrown off by something like an icon.
                for (var i = 0; i < length_1; i++) {
                    if (element.childNodes[i].nodeType === textNodeType) {
                        output += element.childNodes[i].textContent;
                    }
                }
            }
            return output.trim();
        };
        NxContextMenuItemComponent.decorators = [
            { type: core.Component, args: [{
                        // tslint:disable-next-line:component-selector
                        selector: '[nxContextMenuItem]',
                        exportAs: 'nxContextMenuItem',
                        host: {
                            class: 'nx-context-menu-item',
                            role: 'menuitem',
                            '[class.is-highlighted]': '_highlighted',
                            '[attr.tabindex]': '_getTabIndex()',
                            '[attr.aria-disabled]': 'disabled.toString()',
                            '[attr.disabled]': 'disabled || null',
                            '(mouseenter)': '_handleMouseEnter()',
                            '(click)': '_checkDisabled($event)'
                        },
                        changeDetection: core.ChangeDetectionStrategy.OnPush,
                        template: "\n    <ng-content></ng-content>\n    <nx-icon *ngIf=\"_triggersSubmenu\"\n      class=\"nx-context-menu-item__expand\"\n      name=\"chevron-right-small\">\n    </nx-icon>\n    ",
                        styles: [":host{font-size:16px;font-size:var(--context-menu-font-size,16px);line-height:24px;line-height:var(--context-menu-line-height,24px);font-weight:400;font-weight:var(--context-menu-font-weight,400);letter-spacing:0;letter-spacing:var(--context-menu-letter-spacing,0);display:flex;align-items:center;cursor:pointer;text-align:left;width:100%;-webkit-appearance:none;-moz-appearance:none;appearance:none;border:none;outline:0;background:0 0;padding:4px 48px 4px 32px;color:#414141;color:var(--context-menu-item-text-color,#414141)}:host:not(:disabled).is-highlighted,:host:not(:disabled):active,:host:not(:disabled):hover{color:#006192;color:var(--context-menu-item-active-color,#006192)}@media screen and (-ms-high-contrast:active){:host{-ms-high-contrast-adjust:none;background-color:buttonFace;color:buttonText}:host:not(:disabled).is-highlighted,:host:not(:disabled):active,:host:not(:disabled):hover{background-color:highlight;color:highlightText}}:host:disabled{cursor:not-allowed;color:#c2c2c2;color:var(--context-menu-item-disabled-color,#c2c2c2)}:host::-moz-focus-inner{border:0}:host ::ng-deep>nx-icon{margin-right:8px;font-size:20px;font-size:var(--context-menu-item-icon-size,20px)}:host .nx-context-menu-item__expand{font-size:20px;font-size:var(--context-menu-item-expand-icon-size,20px);padding-left:8px;margin-left:auto;margin-right:-16px;width:1em}:host-context([data-whatinput=keyboard]):focus{border-radius:8px;outline:0;box-shadow:inset 0 0 0 4px #009de6,inset 0 0 0 6px #fff;box-shadow:var(--focus-inset-box-shadow,inset 0 0 0 4px #009de6,inset 0 0 0 6px #fff)}@media screen and (-ms-high-contrast:active){:host:disabled{color:GrayText}:host-context([data-whatinput=keyboard]):focus{box-shadow:inset 0 0 0 4px windowText,inset 0 0 0 6px background}}"]
                    }] }
        ];
        /** @nocollapse */
        NxContextMenuItemComponent.ctorParameters = function () { return [
            { type: core.ElementRef },
            { type: undefined, decorators: [{ type: core.Inject, args: [common.DOCUMENT,] }] },
            { type: core.ChangeDetectorRef },
            { type: NxContextMenuComponent, decorators: [{ type: core.Inject, args: [NxContextMenuComponent,] }, { type: core.Optional }] }
        ]; };
        NxContextMenuItemComponent.propDecorators = {
            disabled: [{ type: core.Input }]
        };
        return NxContextMenuItemComponent;
    }());
    if (false) {
        /**
         * @type {?}
         * @private
         */
        NxContextMenuItemComponent.prototype._document;
        /**
         * Stream that emits when the context menu item is hovered.
         * @type {?}
         */
        NxContextMenuItemComponent.prototype._hovered;
        /**
         * @type {?}
         * @private
         */
        NxContextMenuItemComponent.prototype._disabled;
        /**
         * Whether the context menu item is highlighted.
         * @type {?}
         */
        NxContextMenuItemComponent.prototype._highlighted;
        /**
         * Whether the context menu item acts as a trigger for a sub-menu.
         * @type {?}
         */
        NxContextMenuItemComponent.prototype._triggersSubmenu;
        /**
         * @type {?}
         * @private
         */
        NxContextMenuItemComponent.prototype._elementRef;
        /**
         * @type {?}
         * @private
         */
        NxContextMenuItemComponent.prototype._changeDetectorRef;
        /**
         * @type {?}
         * @private
         */
        NxContextMenuItemComponent.prototype._parentMenu;
    }

    /**
     * @fileoverview added by tsickle
     * Generated from: context-menu-errors.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * Throws an exception for the case when menu trigger doesn't have a valid nx-context-menu instance
     * \@docs-private
     * @return {?}
     */
    function throwNxContextMenuMissingError() {
        throw Error("nxContextMenuTriggerFor: must pass in an nx-context-menu instance.\n    Example:\n      <nx-context-menu #contextMenu=\"nxContextMenu\"></nx-context-menu>\n      <button [nxContextMenuTriggerFor]=\"contextMenu\"></button>");
    }

    /**
     * @fileoverview added by tsickle
     * Generated from: context-menu-trigger.directive.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * Default top padding of the menu panel.
     * @type {?}
     */
    var MENU_PANEL_TOP_PADDING = 16;
    /** @type {?} */
    var MENU_PANEL_OFFSET = 8;
    /**
     * Options for binding a passive event listener.
     * @type {?}
     */
    var passiveEventListenerOptions = platform.normalizePassiveListenerOptions({
        passive: true
    });
    /**
     * This directive is intended to be used in conjunction with an nx-context-menu tag.
     * It is responsible for toggling the display of the provided context menu instance.
     */
    var NxContextMenuTriggerDirective = /** @class */ (function () {
        function NxContextMenuTriggerDirective(_overlay, _element, _viewContainerRef, _parentMenu, _contextMenuItemInstance, _dir) {
            this._overlay = _overlay;
            this._element = _element;
            this._viewContainerRef = _viewContainerRef;
            this._parentMenu = _parentMenu;
            this._contextMenuItemInstance = _contextMenuItemInstance;
            this._dir = _dir;
            this._overlayRef = null;
            this._contextMenuOpen = false;
            this._closingActionsSubscription = rxjs.Subscription.EMPTY;
            this._hoverSubscription = rxjs.Subscription.EMPTY;
            this._contextMenuCloseSubscription = rxjs.Subscription.EMPTY;
            /**
             * Event emitted when the associated context menu is opened.
             */
            this.contextMenuOpened = new core.EventEmitter();
            /**
             * Event emitted when the associated context menu is closed.
             */
            this.contextMenuClosed = new core.EventEmitter();
            if (_contextMenuItemInstance) {
                _contextMenuItemInstance._triggersSubmenu = this.triggersSubmenu();
            }
            this._scrollStrategy = this._overlay.scrollStrategies.reposition;
            this._documentClickObservable = rxjs.fromEvent(document, 'click');
        }
        Object.defineProperty(NxContextMenuTriggerDirective.prototype, "contextMenu", {
            /** References the context menu instance that the trigger is associated with. */
            get: /**
             * References the context menu instance that the trigger is associated with.
             * @return {?}
             */
            function () {
                return this._contextMenu;
            },
            set: /**
             * @param {?} contextMenu
             * @return {?}
             */
            function (contextMenu) {
                var _this = this;
                if (contextMenu === this._contextMenu) {
                    return;
                }
                this._contextMenu = contextMenu;
                this._contextMenuCloseSubscription.unsubscribe();
                if (contextMenu) {
                    this._contextMenuCloseSubscription = contextMenu.closed
                        .asObservable()
                        .subscribe((/**
                     * @param {?} reason
                     * @return {?}
                     */
                    function (reason) {
                        _this._destroyMenu();
                        // If a click closed the menu, we should close the entire chain of nested menus.
                        if ((reason === 'click' || reason === 'tab') && _this._parentMenu) {
                            _this._parentMenu.closed.emit(reason);
                        }
                    }));
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NxContextMenuTriggerDirective.prototype, "scrollStrategy", {
            set: /**
             * @param {?} value
             * @return {?}
             */
            function (value) {
                if (value === 'close') {
                    this._scrollStrategy = this._overlay.scrollStrategies.close;
                }
                else {
                    this._scrollStrategy = this._overlay.scrollStrategies.reposition;
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NxContextMenuTriggerDirective.prototype, "contextMenuOpen", {
            /** Whether the context menu is open. */
            get: /**
             * Whether the context menu is open.
             * @return {?}
             */
            function () {
                return this._contextMenuOpen;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NxContextMenuTriggerDirective.prototype, "dir", {
            /** The text direction of the containing app. */
            get: /**
             * The text direction of the containing app.
             * @private
             * @return {?}
             */
            function () {
                return this._dir && this._dir.value === 'rtl' ? 'rtl' : 'ltr';
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        NxContextMenuTriggerDirective.prototype.ngAfterContentInit = /**
         * @return {?}
         */
        function () {
            this._checkContextMenu();
            this._handleHover();
        };
        /**
         * @return {?}
         */
        NxContextMenuTriggerDirective.prototype.ngOnDestroy = /**
         * @return {?}
         */
        function () {
            if (this._overlayRef) {
                this._overlayRef.dispose();
                this._overlayRef = null;
            }
            this._contextMenuCloseSubscription.unsubscribe();
            this._closingActionsSubscription.unsubscribe();
            this._hoverSubscription.unsubscribe();
        };
        /** Whether the context menu triggers a sub-menu or a top-level one. */
        /**
         * Whether the context menu triggers a sub-menu or a top-level one.
         * @return {?}
         */
        NxContextMenuTriggerDirective.prototype.triggersSubmenu = /**
         * Whether the context menu triggers a sub-menu or a top-level one.
         * @return {?}
         */
        function () {
            return !!(this._contextMenuItemInstance && this._parentMenu);
        };
        /** Toggles the context menu between the open and closed states. */
        /**
         * Toggles the context menu between the open and closed states.
         * @return {?}
         */
        NxContextMenuTriggerDirective.prototype.toggleContextMenu = /**
         * Toggles the context menu between the open and closed states.
         * @return {?}
         */
        function () {
            return this.contextMenuOpen
                ? this.closeContextMenu()
                : this.openContextMenu();
        };
        /** Opens the context menu. */
        /**
         * Opens the context menu.
         * @return {?}
         */
        NxContextMenuTriggerDirective.prototype.openContextMenu = /**
         * Opens the context menu.
         * @return {?}
         */
        function () {
            var _this = this;
            if (this.contextMenuOpen) {
                return;
            }
            this._checkContextMenu();
            /** @type {?} */
            var overlayRef = this._createOverlay();
            /** @type {?} */
            var overlayConfig = overlayRef.getConfig();
            this._setPosition((/** @type {?} */ (overlayConfig.positionStrategy)));
            overlayRef.attach(this._getPortal());
            if (this.contextMenu.lazyContent) {
                this.contextMenu.lazyContent.attach(this.contextMenuData);
            }
            this._closingActionsSubscription = this._contextMenuClosingActions().subscribe((/**
             * @return {?}
             */
            function () { return _this.closeContextMenu(); }));
            this._initContextMenu();
            if (this.contextMenu instanceof NxContextMenuComponent) {
                this.contextMenu._startAnimation();
            }
            this._waitForClose();
        };
        /** Closes the context menu. */
        /**
         * Closes the context menu.
         * @return {?}
         */
        NxContextMenuTriggerDirective.prototype.closeContextMenu = /**
         * Closes the context menu.
         * @return {?}
         */
        function () {
            this.contextMenu.closed.emit();
        };
        /** Closes the context menu and does the necessary cleanup. */
        /**
         * Closes the context menu and does the necessary cleanup.
         * @private
         * @return {?}
         */
        NxContextMenuTriggerDirective.prototype._destroyMenu = /**
         * Closes the context menu and does the necessary cleanup.
         * @private
         * @return {?}
         */
        function () {
            var _this = this;
            if (!this._overlayRef || !this.contextMenuOpen) {
                return;
            }
            /** @type {?} */
            var contextMenu = this.contextMenu;
            this._closingActionsSubscription.unsubscribe();
            this._overlayRef.detach();
            contextMenu._resetAnimation();
            if (contextMenu.lazyContent) {
                // Wait for the exit animation to finish before detaching the content.
                contextMenu._animationDone
                    .pipe(operators.filter((/**
                 * @param {?} event
                 * @return {?}
                 */
                function (event) { return event.toState === 'void'; })), operators.take(1), 
                // Interrupt if the content got re-attached.
                operators.takeUntil(contextMenu.lazyContent._attached))
                    .subscribe({
                    next: (/**
                     * @return {?}
                     */
                    function () {
                        return contextMenu.lazyContent && contextMenu.lazyContent.detach();
                    }),
                    // No matter whether the content got re-attached, reset the menu.
                    complete: (/**
                     * @return {?}
                     */
                    function () { return _this._resetContextMenu(); })
                });
            }
            else {
                this._resetContextMenu();
            }
        };
        /**
         * This method sets the context menu state to open and focuses the first item if
         * the context menu was opened via the keyboard.
         */
        /**
         * This method sets the context menu state to open and focuses the first item if
         * the context menu was opened via the keyboard.
         * @private
         * @return {?}
         */
        NxContextMenuTriggerDirective.prototype._initContextMenu = /**
         * This method sets the context menu state to open and focuses the first item if
         * the context menu was opened via the keyboard.
         * @private
         * @return {?}
         */
        function () {
            this.contextMenu.parentMenu = this.triggersSubmenu()
                ? this._parentMenu
                : undefined;
            this.contextMenu.direction = this.dir;
            this._setIsContextMenuOpen(true);
            this.contextMenu.focusFirstItem();
        };
        /**
         * Focuses the context menu trigger.
         */
        /**
         * Focuses the context menu trigger.
         * @return {?}
         */
        NxContextMenuTriggerDirective.prototype.focus = /**
         * Focuses the context menu trigger.
         * @return {?}
         */
        function () {
            this._element.nativeElement.focus();
        };
        /**
         * This method resets the context menu when it's closed, most importantly restoring
         * focus to the context menu trigger if the context menu was opened via the keyboard.
         */
        /**
         * This method resets the context menu when it's closed, most importantly restoring
         * focus to the context menu trigger if the context menu was opened via the keyboard.
         * @private
         * @return {?}
         */
        NxContextMenuTriggerDirective.prototype._resetContextMenu = /**
         * This method resets the context menu when it's closed, most importantly restoring
         * focus to the context menu trigger if the context menu was opened via the keyboard.
         * @private
         * @return {?}
         */
        function () {
            this._setIsContextMenuOpen(false);
            this.focus();
        };
        /** Set state rather than toggle to support triggers sharing a menu. */
        /**
         * Set state rather than toggle to support triggers sharing a menu.
         * @private
         * @param {?} isOpen
         * @return {?}
         */
        NxContextMenuTriggerDirective.prototype._setIsContextMenuOpen = /**
         * Set state rather than toggle to support triggers sharing a menu.
         * @private
         * @param {?} isOpen
         * @return {?}
         */
        function (isOpen) {
            this._contextMenuOpen = isOpen;
            this._contextMenuOpen
                ? this.contextMenuOpened.emit()
                : this.contextMenuClosed.emit();
            if (this.triggersSubmenu()) {
                this._contextMenuItemInstance._highlighted = isOpen;
            }
        };
        /**
         * This method checks that a valid instance of NxContextMenuComponent has been passed into
         * nxContextMenuTriggerFor. If not, an exception is thrown.
         */
        /**
         * This method checks that a valid instance of NxContextMenuComponent has been passed into
         * nxContextMenuTriggerFor. If not, an exception is thrown.
         * @private
         * @return {?}
         */
        NxContextMenuTriggerDirective.prototype._checkContextMenu = /**
         * This method checks that a valid instance of NxContextMenuComponent has been passed into
         * nxContextMenuTriggerFor. If not, an exception is thrown.
         * @private
         * @return {?}
         */
        function () {
            if (!this.contextMenu) {
                throwNxContextMenuMissingError();
            }
        };
        /**
         * This method creates the overlay from the provided menu's template and saves its
         * OverlayRef so that it can be attached to the DOM when openContextMenu is called.
         */
        /**
         * This method creates the overlay from the provided menu's template and saves its
         * OverlayRef so that it can be attached to the DOM when openContextMenu is called.
         * @private
         * @return {?}
         */
        NxContextMenuTriggerDirective.prototype._createOverlay = /**
         * This method creates the overlay from the provided menu's template and saves its
         * OverlayRef so that it can be attached to the DOM when openContextMenu is called.
         * @private
         * @return {?}
         */
        function () {
            if (!this._overlayRef) {
                /** @type {?} */
                var config = this._getOverlayConfig();
                this._overlayRef = this._overlay.create(config);
                // Consume the `keydownEvents` in order to prevent them from going to another overlay.
                this._overlayRef.keydownEvents().subscribe();
            }
            return this._overlayRef;
        };
        /**
         * This method builds the configuration object needed to create the overlay, the OverlayState.
         * @returns OverlayConfig
         */
        /**
         * This method builds the configuration object needed to create the overlay, the OverlayState.
         * @private
         * @return {?} OverlayConfig
         */
        NxContextMenuTriggerDirective.prototype._getOverlayConfig = /**
         * This method builds the configuration object needed to create the overlay, the OverlayState.
         * @private
         * @return {?} OverlayConfig
         */
        function () {
            return new overlay.OverlayConfig({
                positionStrategy: this._overlay
                    .position()
                    .flexibleConnectedTo(this._element)
                    .withLockedPosition()
                    .withFlexibleDimensions(false)
                    .withTransformOriginOn('.nx-context-menu'),
                scrollStrategy: this._scrollStrategy(),
                direction: this._dir
            });
        };
        /**
         * Sets the appropriate positions on a position strategy
         * so the overlay connects with the trigger correctly.
         * @param positionStrategy Strategy whose position to update.
         */
        /**
         * Sets the appropriate positions on a position strategy
         * so the overlay connects with the trigger correctly.
         * @private
         * @param {?} positionStrategy Strategy whose position to update.
         * @return {?}
         */
        NxContextMenuTriggerDirective.prototype._setPosition = /**
         * Sets the appropriate positions on a position strategy
         * so the overlay connects with the trigger correctly.
         * @private
         * @param {?} positionStrategy Strategy whose position to update.
         * @return {?}
         */
        function (positionStrategy) {
            /** @type {?} */
            var originX = 'start';
            /** @type {?} */
            var originFallbackX = 'end';
            /** @type {?} */
            var overlayY = 'top';
            /** @type {?} */
            var overlayFallbackY = 'bottom';
            /** @type {?} */
            var originY = overlayY;
            /** @type {?} */
            var originFallbackY = overlayFallbackY;
            /** @type {?} */
            var overlayX = originX;
            /** @type {?} */
            var overlayFallbackX = originFallbackX;
            /** @type {?} */
            var offsetY = 0;
            if (this.triggersSubmenu()) {
                // When the menu is a sub-menu, it should always align itself
                // to the edges of the trigger, instead of overlapping it.
                overlayFallbackX = originX = 'end';
                originFallbackX = overlayX = 'start';
                offsetY = -MENU_PANEL_TOP_PADDING;
            }
            else {
                offsetY = MENU_PANEL_OFFSET;
                originY = 'bottom';
                originFallbackY = 'top';
            }
            positionStrategy.withPositions((/** @type {?} */ ([
                { originX: originX, originY: originY, overlayX: overlayX, overlayY: overlayY, offsetY: offsetY },
                {
                    originX: originFallbackX,
                    originY: originY,
                    overlayX: overlayFallbackX,
                    overlayY: overlayY,
                    offsetY: offsetY
                },
                {
                    originX: originX,
                    originY: originFallbackY,
                    overlayX: overlayX,
                    overlayY: overlayFallbackY,
                    offsetY: -offsetY
                },
                {
                    originX: originFallbackX,
                    originY: originFallbackY,
                    overlayX: overlayFallbackX,
                    overlayY: overlayFallbackY,
                    offsetY: -offsetY
                }
            ])));
        };
        /**
         * Returns a stream that emits whenever an action that should close the context menu occurs. */
        /**
         * Returns a stream that emits whenever an action that should close the context menu occurs.
         * @private
         * @return {?}
         */
        NxContextMenuTriggerDirective.prototype._contextMenuClosingActions = /**
         * Returns a stream that emits whenever an action that should close the context menu occurs.
         * @private
         * @return {?}
         */
        function () {
            var _this = this;
            /** @type {?} */
            var backdrop;
            /** @type {?} */
            var detachments;
            if (this._overlayRef) {
                backdrop = this._overlayRef.backdropClick();
                detachments = this._overlayRef.detachments();
            }
            /** @type {?} */
            var parentClose = this._parentMenu
                ? this._parentMenu.closed
                : rxjs.of();
            /** @type {?} */
            var hover = this._parentMenu
                ? this._parentMenu._hovered().pipe(operators.filter((/**
                 * @param {?} active
                 * @return {?}
                 */
                function (active) { return active !== _this._contextMenuItemInstance; })), operators.filter((/**
                 * @return {?}
                 */
                function () { return _this._contextMenuOpen; })))
                : rxjs.of();
            return rxjs.merge(backdrop, parentClose, hover, detachments);
        };
        /** Handles mouse presses on the trigger. */
        /**
         * Handles mouse presses on the trigger.
         * @param {?} event
         * @return {?}
         */
        NxContextMenuTriggerDirective.prototype._handleMousedown = /**
         * Handles mouse presses on the trigger.
         * @param {?} event
         * @return {?}
         */
        function (event) {
            // Since right or middle button clicks won't trigger the `click` event,
            // we shouldn't consider the menu as opened by mouse in those cases.
            // this._openedBy = event.button === 0 ? 'mouse' : null;
            // Since clicking on the trigger won't close the menu if it opens a sub-menu,
            // we should prevent focus from moving onto it via click to avoid the
            // highlight from lingering on the menu item.
            if (this.triggersSubmenu()) {
                event.preventDefault();
            }
        };
        /** Handles key presses on the trigger. */
        /**
         * Handles key presses on the trigger.
         * @param {?} event
         * @return {?}
         */
        NxContextMenuTriggerDirective.prototype._handleKeydown = /**
         * Handles key presses on the trigger.
         * @param {?} event
         * @return {?}
         */
        function (event) {
            /** @type {?} */
            var keyCode = event.keyCode;
            if (this.triggersSubmenu() &&
                ((keyCode === keycodes.RIGHT_ARROW && this.dir === 'ltr') ||
                    (keyCode === keycodes.LEFT_ARROW && this.dir === 'rtl'))) {
                this.openContextMenu();
            }
        };
        /** Handles click events on the trigger. */
        /**
         * Handles click events on the trigger.
         * @param {?} event
         * @return {?}
         */
        NxContextMenuTriggerDirective.prototype._handleClick = /**
         * Handles click events on the trigger.
         * @param {?} event
         * @return {?}
         */
        function (event) {
            if (this.triggersSubmenu()) {
                // Stop event propagation to avoid closing the parent menu.
                event.stopPropagation();
                this.openContextMenu();
            }
            else {
                this.toggleContextMenu();
            }
        };
        /* Subscribes to document clicks to close the context menu on clicks on the background. */
        /* Subscribes to document clicks to close the context menu on clicks on the background. */
        /**
         * @private
         * @return {?}
         */
        NxContextMenuTriggerDirective.prototype._waitForClose = /* Subscribes to document clicks to close the context menu on clicks on the background. */
        /**
         * @private
         * @return {?}
         */
        function () {
            var _this = this;
            return this._documentClickObservable
                .pipe(operators.map((/**
             * @param {?} event
             * @return {?}
             */
            function (event) { return event.target; })), operators.filter((/**
             * @param {?} target
             * @return {?}
             */
            function (target) { return !_this._element.nativeElement.contains(target); })), operators.takeUntil(this.contextMenu.closed))
                .subscribe((/**
             * @return {?}
             */
            function () {
                _this.closeContextMenu();
            }));
        };
        /** Handles the cases where the user hovers over the trigger. */
        /**
         * Handles the cases where the user hovers over the trigger.
         * @private
         * @return {?}
         */
        NxContextMenuTriggerDirective.prototype._handleHover = /**
         * Handles the cases where the user hovers over the trigger.
         * @private
         * @return {?}
         */
        function () {
            var _this = this;
            // Subscribe to changes in the hovered item in order to toggle the panel.
            if (!this.triggersSubmenu()) {
                return;
            }
            this._hoverSubscription = this._parentMenu
                ._hovered()
                // Since we might have multiple competing triggers for the same menu (e.g. a sub-menu
                // with different data and triggers), we have to delay it by a tick to ensure that
                // it won't be closed immediately after it is opened.
                .pipe(operators.filter((/**
             * @param {?} active
             * @return {?}
             */
            function (active) { return active === _this._contextMenuItemInstance && !active.disabled; })), operators.delay(0, rxjs.asapScheduler))
                .subscribe((/**
             * @return {?}
             */
            function () {
                // If the same menu is used between multiple triggers, it might still be animating
                // while the new trigger tries to re-open it. Wait for the animation to finish
                // before doing so. Also interrupt if the user moves to another item.
                if (_this.contextMenu._isAnimating) {
                    // We need the `delay(0)` here in order to avoid
                    // 'changed after checked' errors in some cases.
                    _this.contextMenu._animationDone
                        .pipe(operators.take(1), operators.delay(0, rxjs.asapScheduler), operators.takeUntil(_this._parentMenu._hovered()))
                        .subscribe((/**
                     * @return {?}
                     */
                    function () { return _this.openContextMenu(); }));
                }
                else {
                    _this.openContextMenu();
                }
            }));
        };
        /** Gets the portal that should be attached to the overlay. */
        /**
         * Gets the portal that should be attached to the overlay.
         * @private
         * @return {?}
         */
        NxContextMenuTriggerDirective.prototype._getPortal = /**
         * Gets the portal that should be attached to the overlay.
         * @private
         * @return {?}
         */
        function () {
            // Note that we can avoid this check by keeping the portal on the context menu panel.
            // While it would be cleaner, we'd have to introduce another required method on
            // `NxContextMenuPanelComponent`, making it harder to consume.
            if (!this._portal ||
                this._portal.templateRef !== this.contextMenu.templateRef) {
                this._portal = new portal.TemplatePortal(this.contextMenu.templateRef, this._viewContainerRef);
            }
            return this._portal;
        };
        NxContextMenuTriggerDirective.decorators = [
            { type: core.Directive, args: [{
                        selector: "[nxContextMenuTriggerFor]",
                        host: {
                            'aria-haspopup': 'true',
                            '[attr.aria-expanded]': 'contextMenuOpen || null',
                            '(mousedown)': '_handleMousedown($event)',
                            '(keydown)': '_handleKeydown($event)',
                            '(click)': '_handleClick($event)'
                        },
                        exportAs: 'nxContextMenuTrigger'
                    },] }
        ];
        /** @nocollapse */
        NxContextMenuTriggerDirective.ctorParameters = function () { return [
            { type: overlay.Overlay },
            { type: core.ElementRef },
            { type: core.ViewContainerRef },
            { type: NxContextMenuComponent, decorators: [{ type: core.Optional }] },
            { type: NxContextMenuItemComponent, decorators: [{ type: core.Optional }, { type: core.Self }] },
            { type: bidi.Directionality, decorators: [{ type: core.Optional }] }
        ]; };
        NxContextMenuTriggerDirective.propDecorators = {
            contextMenu: [{ type: core.Input, args: ['nxContextMenuTriggerFor',] }],
            scrollStrategy: [{ type: core.Input }],
            contextMenuData: [{ type: core.Input, args: ['nxContextMenuTriggerData',] }],
            contextMenuOpened: [{ type: core.Output }],
            contextMenuClosed: [{ type: core.Output }]
        };
        return NxContextMenuTriggerDirective;
    }());
    if (false) {
        /**
         * @type {?}
         * @private
         */
        NxContextMenuTriggerDirective.prototype._portal;
        /**
         * @type {?}
         * @private
         */
        NxContextMenuTriggerDirective.prototype._overlayRef;
        /**
         * @type {?}
         * @private
         */
        NxContextMenuTriggerDirective.prototype._contextMenuOpen;
        /**
         * @type {?}
         * @private
         */
        NxContextMenuTriggerDirective.prototype._closingActionsSubscription;
        /**
         * @type {?}
         * @private
         */
        NxContextMenuTriggerDirective.prototype._hoverSubscription;
        /**
         * @type {?}
         * @private
         */
        NxContextMenuTriggerDirective.prototype._contextMenuCloseSubscription;
        /**
         * @type {?}
         * @private
         */
        NxContextMenuTriggerDirective.prototype._documentClickObservable;
        /**
         * @type {?}
         * @private
         */
        NxContextMenuTriggerDirective.prototype._scrollStrategy;
        /**
         * @type {?}
         * @private
         */
        NxContextMenuTriggerDirective.prototype._contextMenu;
        /**
         * Data to be passed along to any lazily-rendered content.
         * @type {?}
         */
        NxContextMenuTriggerDirective.prototype.contextMenuData;
        /**
         * Event emitted when the associated context menu is opened.
         * @type {?}
         */
        NxContextMenuTriggerDirective.prototype.contextMenuOpened;
        /**
         * Event emitted when the associated context menu is closed.
         * @type {?}
         */
        NxContextMenuTriggerDirective.prototype.contextMenuClosed;
        /**
         * @type {?}
         * @private
         */
        NxContextMenuTriggerDirective.prototype._overlay;
        /**
         * @type {?}
         * @private
         */
        NxContextMenuTriggerDirective.prototype._element;
        /**
         * @type {?}
         * @private
         */
        NxContextMenuTriggerDirective.prototype._viewContainerRef;
        /**
         * @type {?}
         * @private
         */
        NxContextMenuTriggerDirective.prototype._parentMenu;
        /**
         * @type {?}
         * @private
         */
        NxContextMenuTriggerDirective.prototype._contextMenuItemInstance;
        /**
         * @type {?}
         * @private
         */
        NxContextMenuTriggerDirective.prototype._dir;
    }

    /**
     * @fileoverview added by tsickle
     * Generated from: context-menu.module.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /** @type {?} */
    var EXPORTED_MODULES = [
        NxContextMenuComponent,
        NxContextMenuContentDirective,
        NxContextMenuItemComponent,
        NxContextMenuTriggerDirective
    ];
    var NxContextMenuModule = /** @class */ (function () {
        function NxContextMenuModule() {
        }
        NxContextMenuModule.decorators = [
            { type: core.NgModule, args: [{
                        imports: [
                            common.CommonModule,
                            overlay.OverlayModule,
                            icon.NxIconModule
                        ],
                        exports: EXPORTED_MODULES,
                        declarations: EXPORTED_MODULES
                    },] }
        ];
        return NxContextMenuModule;
    }());

    exports.MENU_PANEL_OFFSET = MENU_PANEL_OFFSET;
    exports.MENU_PANEL_TOP_PADDING = MENU_PANEL_TOP_PADDING;
    exports.NxContextMenuComponent = NxContextMenuComponent;
    exports.NxContextMenuItemComponent = NxContextMenuItemComponent;
    exports.NxContextMenuModule = NxContextMenuModule;
    exports.NxContextMenuTriggerDirective = NxContextMenuTriggerDirective;
    exports.ɵa = nxContextMenuAnimations;
    exports.ɵb = NxContextMenuContentDirective;

    Object.defineProperty(exports, '__esModule', { value: true });

})));
//# sourceMappingURL=allianz-ngx-ndbx-context-menu.umd.js.map
