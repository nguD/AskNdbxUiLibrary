(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@allianz/ngx-ndbx/icon'), require('@angular/core'), require('@angular/common'), require('@angular/forms'), require('@angular/cdk/coercion'), require('rxjs/operators'), require('rxjs'), require('@angular/cdk/collections')) :
    typeof define === 'function' && define.amd ? define('@allianz/ngx-ndbx/circle-toggle', ['exports', '@allianz/ngx-ndbx/icon', '@angular/core', '@angular/common', '@angular/forms', '@angular/cdk/coercion', 'rxjs/operators', 'rxjs', '@angular/cdk/collections'], factory) :
    (global = global || self, factory((global.allianz = global.allianz || {}, global.allianz['ngx-ndbx'] = global.allianz['ngx-ndbx'] || {}, global.allianz['ngx-ndbx']['circle-toggle'] = {}), global.allianz['ngx-ndbx'].icon, global.ng.core, global.ng.common, global.ng.forms, global.ng.cdk.coercion, global.rxjs.operators, global.rxjs, global.ng.cdk.collections));
}(this, (function (exports, icon, core, common, forms, coercion, operators, rxjs, collections) { 'use strict';

    /*! *****************************************************************************
    Copyright (c) Microsoft Corporation. All rights reserved.
    Licensed under the Apache License, Version 2.0 (the "License"); you may not use
    this file except in compliance with the License. You may obtain a copy of the
    License at http://www.apache.org/licenses/LICENSE-2.0

    THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
    WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
    MERCHANTABLITY OR NON-INFRINGEMENT.

    See the Apache Version 2.0 License for specific language governing permissions
    and limitations under the License.
    ***************************************************************************** */
    /* global Reflect, Promise */

    var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };

    function __extends(d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    }

    var __assign = function() {
        __assign = Object.assign || function __assign(t) {
            for (var s, i = 1, n = arguments.length; i < n; i++) {
                s = arguments[i];
                for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
            }
            return t;
        };
        return __assign.apply(this, arguments);
    };

    function __rest(s, e) {
        var t = {};
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
            t[p] = s[p];
        if (s != null && typeof Object.getOwnPropertySymbols === "function")
            for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
                if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                    t[p[i]] = s[p[i]];
            }
        return t;
    }

    function __decorate(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    }

    function __param(paramIndex, decorator) {
        return function (target, key) { decorator(target, key, paramIndex); }
    }

    function __metadata(metadataKey, metadataValue) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(metadataKey, metadataValue);
    }

    function __awaiter(thisArg, _arguments, P, generator) {
        return new (P || (P = Promise))(function (resolve, reject) {
            function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
            function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
            function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
            step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
    }

    function __generator(thisArg, body) {
        var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
        return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
        function verb(n) { return function (v) { return step([n, v]); }; }
        function step(op) {
            if (f) throw new TypeError("Generator is already executing.");
            while (_) try {
                if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
                if (y = 0, t) op = [op[0] & 2, t.value];
                switch (op[0]) {
                    case 0: case 1: t = op; break;
                    case 4: _.label++; return { value: op[1], done: false };
                    case 5: _.label++; y = op[1]; op = [0]; continue;
                    case 7: op = _.ops.pop(); _.trys.pop(); continue;
                    default:
                        if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                        if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                        if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                        if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                        if (t[2]) _.ops.pop();
                        _.trys.pop(); continue;
                }
                op = body.call(thisArg, _);
            } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
            if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
        }
    }

    function __exportStar(m, exports) {
        for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
    }

    function __values(o) {
        var m = typeof Symbol === "function" && o[Symbol.iterator], i = 0;
        if (m) return m.call(o);
        return {
            next: function () {
                if (o && i >= o.length) o = void 0;
                return { value: o && o[i++], done: !o };
            }
        };
    }

    function __read(o, n) {
        var m = typeof Symbol === "function" && o[Symbol.iterator];
        if (!m) return o;
        var i = m.call(o), r, ar = [], e;
        try {
            while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
        }
        catch (error) { e = { error: error }; }
        finally {
            try {
                if (r && !r.done && (m = i["return"])) m.call(i);
            }
            finally { if (e) throw e.error; }
        }
        return ar;
    }

    function __spread() {
        for (var ar = [], i = 0; i < arguments.length; i++)
            ar = ar.concat(__read(arguments[i]));
        return ar;
    }

    function __spreadArrays() {
        for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
        for (var r = Array(s), k = 0, i = 0; i < il; i++)
            for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
                r[k] = a[j];
        return r;
    };

    function __await(v) {
        return this instanceof __await ? (this.v = v, this) : new __await(v);
    }

    function __asyncGenerator(thisArg, _arguments, generator) {
        if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
        var g = generator.apply(thisArg, _arguments || []), i, q = [];
        return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i;
        function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }
        function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }
        function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }
        function fulfill(value) { resume("next", value); }
        function reject(value) { resume("throw", value); }
        function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }
    }

    function __asyncDelegator(o) {
        var i, p;
        return i = {}, verb("next"), verb("throw", function (e) { throw e; }), verb("return"), i[Symbol.iterator] = function () { return this; }, i;
        function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === "return" } : f ? f(v) : v; } : f; }
    }

    function __asyncValues(o) {
        if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
        var m = o[Symbol.asyncIterator], i;
        return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);
        function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }
        function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }
    }

    function __makeTemplateObject(cooked, raw) {
        if (Object.defineProperty) { Object.defineProperty(cooked, "raw", { value: raw }); } else { cooked.raw = raw; }
        return cooked;
    };

    function __importStar(mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
        result.default = mod;
        return result;
    }

    function __importDefault(mod) {
        return (mod && mod.__esModule) ? mod : { default: mod };
    }

    /**
     * @fileoverview added by tsickle
     * Generated from: circle-toggle/toggle-button.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * \@docs-private
     * @abstract
     */
    var   /**
     * \@docs-private
     * @abstract
     */
    ToggleButton = /** @class */ (function () {
        function ToggleButton() {
        }
        return ToggleButton;
    }());
    if (false) {
        /** @type {?} */
        ToggleButton.prototype.id;
        /** @type {?} */
        ToggleButton.prototype.value;
        /** @type {?} */
        ToggleButton.prototype.checked;
        /** @type {?} */
        ToggleButton.prototype.name;
        /** @type {?} */
        ToggleButton.prototype.negative;
        /** @type {?} */
        ToggleButton.prototype.disabled;
        /** @type {?} */
        ToggleButton.prototype.tabIndex;
        /** @type {?} */
        ToggleButton.prototype.checkedChange;
        /** @type {?} */
        ToggleButton.prototype.selectionChange;
        /** @type {?} */
        ToggleButton.prototype.toggleButton;
        /**
         * @abstract
         * @param {?} event
         * @return {?}
         */
        ToggleButton.prototype.toggle = function (event) { };
        /**
         * @abstract
         * @return {?}
         */
        ToggleButton.prototype.setGroupSelection = function () { };
    }

    /**
     * @fileoverview added by tsickle
     * Generated from: circle-toggle-group/circle-toggle-group.component.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /** @type {?} */
    var nextId = 0;
    var NxCircleToggleGroupComponent = /** @class */ (function () {
        function NxCircleToggleGroupComponent(_changeDetectorRef) {
            this._changeDetectorRef = _changeDetectorRef;
            this._id = "nx-circle-toggle-group-" + nextId++;
            this._destroyed = new rxjs.Subject();
            /**
             * An event emitted when the selection changes. Outputs the value of the currently selected button.
             */
            this.valueChange = new core.EventEmitter();
            this._name = "toggle-group-" + nextId++;
            this._negative = false;
            this._responsive = true;
            this.onChangeCallback = (/**
             * @param {?} value
             * @return {?}
             */
            function (value) { });
            this.onTouchedCallback = (/**
             * @return {?}
             */
            function () { });
        }
        Object.defineProperty(NxCircleToggleGroupComponent.prototype, "id", {
            get: /**
             * @return {?}
             */
            function () {
                return this._id;
            },
            /**
             * Id of the circle toggle group.
             *
             * If not set, the circle toggle group gets an incremented value by default.
             */
            set: /**
             * Id of the circle toggle group.
             *
             * If not set, the circle toggle group gets an incremented value by default.
             * @param {?} value
             * @return {?}
             */
            function (value) {
                this._id = value;
                this._changeDetectorRef.markForCheck();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NxCircleToggleGroupComponent.prototype, "name", {
            get: /**
             * @return {?}
             */
            function () {
                return this._name;
            },
            /** Name that is used for accessibility. */
            set: /**
             * Name that is used for accessibility.
             * @param {?} value
             * @return {?}
             */
            function (value) {
                this._name = value;
                this.updateToggleButtonsNames();
                this._changeDetectorRef.markForCheck();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NxCircleToggleGroupComponent.prototype, "disabled", {
            get: /**
             * @return {?}
             */
            function () {
                return this._disabled;
            },
            /** Whether the circle toggle group is disabled. */
            set: /**
             * Whether the circle toggle group is disabled.
             * @param {?} value
             * @return {?}
             */
            function (value) {
                /** @type {?} */
                var newValue = coercion.coerceBooleanProperty(value);
                if (this._disabled !== newValue) {
                    this._disabled = newValue;
                    this._changeDetectorRef.markForCheck();
                }
                if (this.buttons) {
                    this.buttons.forEach((/**
                     * @param {?} button
                     * @return {?}
                     */
                    function (button) { return button.disabled = value; }));
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NxCircleToggleGroupComponent.prototype, "negative", {
            get: /**
             * @return {?}
             */
            function () {
                return this._negative;
            },
            /** Whether the circle toggle group uses the negative styling. */
            set: /**
             * Whether the circle toggle group uses the negative styling.
             * @param {?} value
             * @return {?}
             */
            function (value) {
                /** @type {?} */
                var newValue = coercion.coerceBooleanProperty(value);
                if (this.negative !== newValue) {
                    this._negative = newValue;
                }
                if (this.buttons) {
                    this.buttons.forEach((/**
                     * @param {?} button
                     * @return {?}
                     */
                    function (button) { return button.negative = value; }));
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NxCircleToggleGroupComponent.prototype, "value", {
            get: /**
             * @return {?}
             */
            function () {
                return this._value;
            },
            /** The value of the selected circle toggle in the circle toggle group. */
            set: /**
             * The value of the selected circle toggle in the circle toggle group.
             * @param {?} value
             * @return {?}
             */
            function (value) {
                this.writeValue(value);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NxCircleToggleGroupComponent.prototype, "responsive", {
            get: /**
             * @return {?}
             */
            function () {
                return this._responsive;
            },
            /** Whether the circle toggle group has a responsive behavior. */
            set: /**
             * Whether the circle toggle group has a responsive behavior.
             * @param {?} value
             * @return {?}
             */
            function (value) {
                /** @type {?} */
                var newValue = coercion.coerceBooleanProperty(value);
                if (newValue !== this.responsive) {
                    this._responsive = newValue;
                    this._changeDetectorRef.markForCheck();
                }
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @param {?} value
         * @return {?}
         */
        NxCircleToggleGroupComponent.prototype.writeValue = /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            if (this.value !== value) {
                this._value = value;
                this.notifySelectedChild(value);
            }
        };
        /**
         * @return {?}
         */
        NxCircleToggleGroupComponent.prototype.ngOnDestroy = /**
         * @return {?}
         */
        function () {
            this._destroyed.next();
            this._destroyed.complete();
        };
        /**
         * @return {?}
         */
        NxCircleToggleGroupComponent.prototype.ngAfterViewInit = /**
         * @return {?}
         */
        function () {
            var _this = this;
            this.subscribeToSelectionChanges();
            // react if a content child is deleted, added etc.
            this.buttons.changes
                .pipe(operators.startWith(this.buttons), operators.filter((/**
             * @param {?} toggles
             * @return {?}
             */
            function (toggles) { return toggles.length > 0; })), operators.tap((/**
             * @param {?} toggles
             * @return {?}
             */
            function (toggles) {
                return Promise.resolve().then((/**
                 * @return {?}
                 */
                function () {
                    toggles.forEach((/**
                     * @param {?} toggle
                     * @return {?}
                     */
                    function (toggle) { return toggle.toggleButton.resetClasses(); }));
                    _this.buttons.first.toggleButton.setFirstButton();
                    _this.buttons.last.toggleButton.setLastButton();
                }));
            })), operators.takeUntil(this._destroyed))
                .subscribe((/**
             * @return {?}
             */
            function () { return _this.subscribeToSelectionChanges(); }));
        };
        /** @docs-private */
        /**
         * \@docs-private
         * @return {?}
         */
        NxCircleToggleGroupComponent.prototype.subscribeToSelectionChanges = /**
         * \@docs-private
         * @return {?}
         */
        function () {
            var _this = this;
            /** @type {?} */
            var changedOrDestroyed = rxjs.merge(this.buttons.changes, this._destroyed);
            rxjs.merge.apply(void 0, __spread(this.buttons.map((/**
             * @param {?} button
             * @return {?}
             */
            function (button) { return button.selectionChange; })))).pipe(operators.takeUntil(changedOrDestroyed))
                .subscribe((/**
             * @param {?} change
             * @return {?}
             */
            function (change) {
                _this.onChangeCallback(change.value);
                _this.valueChange.emit(change.value);
            }));
        };
        /**
         * @docs-private
         * inform the selected button if the group selection is set programattically at the beginning
         */
        /**
         * \@docs-private
         * inform the selected button if the group selection is set programattically at the beginning
         * @param {?} newValue
         * @return {?}
         */
        NxCircleToggleGroupComponent.prototype.notifySelectedChild = /**
         * \@docs-private
         * inform the selected button if the group selection is set programattically at the beginning
         * @param {?} newValue
         * @return {?}
         */
        function (newValue) {
            if (this.buttons) {
                /** @type {?} */
                var selected = this.buttons.find((/**
                 * @param {?} button
                 * @return {?}
                 */
                function (button) { return button.value === newValue; }));
                if (selected) {
                    selected.setGroupSelection();
                }
            }
        };
        /** @docs-private */
        /**
         * \@docs-private
         * @return {?}
         */
        NxCircleToggleGroupComponent.prototype.updateToggleButtonsNames = /**
         * \@docs-private
         * @return {?}
         */
        function () {
            var _this = this;
            if (this.buttons) {
                this.buttons.forEach((/**
                 * @param {?} button
                 * @return {?}
                 */
                function (button) { return button.name = _this.name; }));
            }
        };
        /**
         * @param {?} fn
         * @return {?}
         */
        NxCircleToggleGroupComponent.prototype.registerOnChange = /**
         * @param {?} fn
         * @return {?}
         */
        function (fn) {
            this.onChangeCallback = fn;
        };
        /**
         * @param {?} fn
         * @return {?}
         */
        NxCircleToggleGroupComponent.prototype.registerOnTouched = /**
         * @param {?} fn
         * @return {?}
         */
        function (fn) {
            this.onTouchedCallback = fn;
        };
        /**
         * @param {?} isDisabled
         * @return {?}
         */
        NxCircleToggleGroupComponent.prototype.setDisabledState = /**
         * @param {?} isDisabled
         * @return {?}
         */
        function (isDisabled) {
            this.disabled = isDisabled;
        };
        Object.defineProperty(NxCircleToggleGroupComponent.prototype, "selectedButton", {
            /** @docs-private */
            get: /**
             * \@docs-private
             * @return {?}
             */
            function () {
                return this.buttons ? this.buttons.find((/**
                 * @param {?} button
                 * @return {?}
                 */
                function (button) { return button.checked; })) : null;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NxCircleToggleGroupComponent.prototype, "buttons", {
            /** @docs-private */
            get: /**
             * \@docs-private
             * @return {?}
             */
            function () {
                return this._buttons;
            },
            enumerable: true,
            configurable: true
        });
        NxCircleToggleGroupComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'nx-circle-toggle-group',
                        template: "<ng-content></ng-content>",
                        changeDetection: core.ChangeDetectionStrategy.OnPush,
                        providers: [
                            {
                                provide: forms.NG_VALUE_ACCESSOR,
                                useExisting: core.forwardRef((/**
                                 * @return {?}
                                 */
                                function () { return NxCircleToggleGroupComponent; })),
                                multi: true
                            }
                        ],
                        host: {
                            '[class.is-responsive]': 'responsive',
                            '[class.is-disabled]': 'disabled',
                            '[attr.aria-disabled]': 'disabled',
                            '[attr.aria-labelledby]': 'name',
                            '[attr.name]': 'name',
                            '[attr.id]': 'id',
                            '[class.nx-circle-toggle-group]': 'true',
                            'role': 'radiogroup'
                        },
                        styles: [":host{display:flex;flex-wrap:wrap;flex-direction:column;justify-content:space-around}@media (min-width:320px){:host{flex-direction:row}}:host(.is-responsive){flex-direction:column}@media (min-width:704px){:host(.is-responsive){flex-direction:row}}"]
                    }] }
        ];
        /** @nocollapse */
        NxCircleToggleGroupComponent.ctorParameters = function () { return [
            { type: core.ChangeDetectorRef }
        ]; };
        NxCircleToggleGroupComponent.propDecorators = {
            _buttons: [{ type: core.ContentChildren, args: [ToggleButton,] }],
            valueChange: [{ type: core.Output }],
            name: [{ type: core.Input }],
            disabled: [{ type: core.Input }],
            negative: [{ type: core.Input }],
            value: [{ type: core.Input }],
            responsive: [{ type: core.Input }]
        };
        return NxCircleToggleGroupComponent;
    }());
    if (false) {
        /**
         * @type {?}
         * @private
         */
        NxCircleToggleGroupComponent.prototype._buttons;
        /**
         * @type {?}
         * @private
         */
        NxCircleToggleGroupComponent.prototype._id;
        /**
         * @type {?}
         * @private
         */
        NxCircleToggleGroupComponent.prototype._destroyed;
        /**
         * An event emitted when the selection changes. Outputs the value of the currently selected button.
         * @type {?}
         */
        NxCircleToggleGroupComponent.prototype.valueChange;
        /**
         * @type {?}
         * @private
         */
        NxCircleToggleGroupComponent.prototype._name;
        /**
         * @type {?}
         * @private
         */
        NxCircleToggleGroupComponent.prototype._disabled;
        /** @type {?} */
        NxCircleToggleGroupComponent.prototype._negative;
        /**
         * @type {?}
         * @private
         */
        NxCircleToggleGroupComponent.prototype._value;
        /**
         * @type {?}
         * @private
         */
        NxCircleToggleGroupComponent.prototype._responsive;
        /**
         * @type {?}
         * @private
         */
        NxCircleToggleGroupComponent.prototype.onChangeCallback;
        /**
         * @type {?}
         * @private
         */
        NxCircleToggleGroupComponent.prototype.onTouchedCallback;
        /**
         * @type {?}
         * @private
         */
        NxCircleToggleGroupComponent.prototype._changeDetectorRef;
    }

    /**
     * @fileoverview added by tsickle
     * Generated from: mobile-toggle-button/mobile-toggle-button.component.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * \@docs-private
     */
    var NxMobileToggleButtonComponent = /** @class */ (function () {
        function NxMobileToggleButtonComponent(_changeDetectorRef) {
            this._changeDetectorRef = _changeDetectorRef;
            this.checked = false;
            this.negative = false;
            this.disabled = false;
        }
        /** @docs-private */
        /**
         * \@docs-private
         * @return {?}
         */
        NxMobileToggleButtonComponent.prototype.setFirstButton = /**
         * \@docs-private
         * @return {?}
         */
        function () {
            this.isFirst = true;
            this._changeDetectorRef.markForCheck();
        };
        /** @docs-private */
        /**
         * \@docs-private
         * @return {?}
         */
        NxMobileToggleButtonComponent.prototype.setLastButton = /**
         * \@docs-private
         * @return {?}
         */
        function () {
            this.isLast = true;
            this._changeDetectorRef.markForCheck();
        };
        /** @docs-private */
        /**
         * \@docs-private
         * @return {?}
         */
        NxMobileToggleButtonComponent.prototype.resetClasses = /**
         * \@docs-private
         * @return {?}
         */
        function () {
            this.isFirst = false;
            this.isLast = false;
            this._changeDetectorRef.markForCheck();
        };
        NxMobileToggleButtonComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'nx-mobile-toggle-button',
                        template: "<nx-icon class=\"nx-toggle-button__mobile-check\" name=\"check\" aria-hidden=\"true\"></nx-icon>\n<!-- If there is no label defined, use the circleText instead -->\n<span class=\"nx-toggle-button__label-text\"><ng-template *ngIf=\"label; then labelContent else circleTextContent\"></ng-template></span>\n<span *ngIf=\"hint\" class=\"nx-toggle-button__label-hint\">({{hint}})</span>\n\n<ng-template #labelContent>{{label}}</ng-template>\n<ng-template #circleTextContent>{{circleText}}</ng-template>\n",
                        changeDetection: core.ChangeDetectionStrategy.OnPush,
                        host: {
                            '[class.is-disabled]': 'disabled',
                            '[class.is-negative]': 'negative',
                            '[class.is-first]': 'isFirst',
                            '[class.is-last]': 'isLast',
                            '[class.is-flipped]': 'checked'
                        },
                        styles: [":host{display:none;position:relative;transition:background-color .2s,border-color .2s,color .2s;flex-direction:row;border-width:1px 2px;border-color:#007ab3;border-color:var(--circle-toggle-border-color,#007ab3);border-style:solid;padding:11px 31px;width:100%;justify-content:center;align-items:center;cursor:pointer}:host:not(.is-flipped):not(.is-disabled):hover{background-color:#006192;background-color:var(--circle-toggle-hover-background-color,#006192);border-color:#006192;border-color:var(--circle-toggle-hover-border-color,#006192)}:host:not(.is-flipped):not(.is-disabled):hover .nx-toggle-button__label-hint,:host:not(.is-flipped):not(.is-disabled):hover .nx-toggle-button__label-text{color:#fff;color:var(--circle-toggle-hover-icon-color,#fff)}@media (max-width:703px){:host-context(.is-responsive){display:flex}}.nx-toggle-button__label-hint{color:#007ab3;color:var(--circle-toggle-icon-color,#007ab3);font-size:14px;font-size:var(--circle-toggle-hint-mobile-font-size,14px);line-height:20px;line-height:var(--circle-toggle-hint-mobile-line-height,20px);font-weight:300;font-weight:var(--circle-toggle-hint-mobile-font-weight,300);letter-spacing:.2px;letter-spacing:var(--circle-toggle-hint-mobile-letter-spacing,.2px)}.nx-toggle-button__label-text{color:#007ab3;color:var(--circle-toggle-icon-color,#007ab3);font-size:14px;font-size:var(--circle-toggle-label-mobile-font-size,14px);line-height:20px;line-height:var(--circle-toggle-label-mobile-line-height,20px);font-weight:var(--circle-toggle-label-mobile-font-weight,400);letter-spacing:.2px;letter-spacing:var(--circle-toggle-label-mobile-letter-spacing,.2px);padding-top:0;padding-right:4px;font-weight:600}.nx-toggle-button__mobile-check{font-size:24px;height:24px;display:inline-block;opacity:0;margin-right:8px;color:#fff;color:var(--circle-toggle-checkmark-color,#fff)}:host(.is-first){border-top-width:2px;border-radius:4px 4px 0 0}:host(.is-last){border-bottom-width:2px;border-radius:0 0 4px 4px}:host(.is-flipped){background-color:#007ab3;background-color:var(--circle-toggle-selected-background-color,#007ab3)}:host(.is-flipped) .nx-toggle-button__label-hint,:host(.is-flipped) .nx-toggle-button__label-text{color:#fff;color:var(--circle-toggle-selected-icon-color,#fff)}:host(.is-flipped) .nx-toggle-button__mobile-check{opacity:1}:host(.is-negative){border-color:#fff}:host(.is-negative) .nx-toggle-button__label-hint,:host(.is-negative) .nx-toggle-button__label-text,:host(.is-negative) .nx-toggle-button__mobile-check{color:#fff}:host(.is-negative):not(.is-flipped):not(.is-disabled):hover{background-color:#d9d9d9;border-color:#d9d9d9}:host(.is-negative):not(.is-flipped):not(.is-disabled):hover .nx-toggle-button__label-hint,:host(.is-negative):not(.is-flipped):not(.is-disabled):hover .nx-toggle-button__label-text{color:#006192}:host(.is-negative.is-flipped){background-color:#fff}:host(.is-negative.is-flipped) .nx-toggle-button__label-hint,:host(.is-negative.is-flipped) .nx-toggle-button__label-text,:host(.is-negative.is-flipped) .nx-toggle-button__mobile-check{color:#007ab3}:host(.is-disabled){opacity:.4;cursor:not-allowed}@media screen and (-ms-high-contrast:active){:host,:host(.is-negative){background-color:buttonFace;border-color:buttonText}:host .nx-toggle-button__label-hint,:host .nx-toggle-button__label-text,:host .nx-toggle-button__mobile-check,:host(.is-negative) .nx-toggle-button__label-hint,:host(.is-negative) .nx-toggle-button__label-text,:host(.is-negative) .nx-toggle-button__mobile-check{color:buttonText;-ms-high-contrast-adjust:none}:host(.is-flipped),:host(.is-negative.is-flipped){background-color:highlight}:host(.is-flipped) .nx-toggle-button__label-hint,:host(.is-flipped) .nx-toggle-button__label-text,:host(.is-flipped) .nx-toggle-button__mobile-check,:host(.is-negative.is-flipped) .nx-toggle-button__label-hint,:host(.is-negative.is-flipped) .nx-toggle-button__label-text,:host(.is-negative.is-flipped) .nx-toggle-button__mobile-check{color:highlightText}:host(.is-disabled){opacity:1;border-color:GrayText;color:GrayText}:host(.is-disabled).is-flipped .nx-toggle-button__mobile-check{color:GrayText}}"]
                    }] }
        ];
        /** @nocollapse */
        NxMobileToggleButtonComponent.ctorParameters = function () { return [
            { type: core.ChangeDetectorRef }
        ]; };
        NxMobileToggleButtonComponent.propDecorators = {
            checked: [{ type: core.Input }],
            negative: [{ type: core.Input }],
            disabled: [{ type: core.Input }],
            hint: [{ type: core.Input }],
            label: [{ type: core.Input }],
            circleText: [{ type: core.Input }]
        };
        return NxMobileToggleButtonComponent;
    }());
    if (false) {
        /** @type {?} */
        NxMobileToggleButtonComponent.prototype.checked;
        /** @type {?} */
        NxMobileToggleButtonComponent.prototype.negative;
        /** @type {?} */
        NxMobileToggleButtonComponent.prototype.disabled;
        /** @type {?} */
        NxMobileToggleButtonComponent.prototype.hint;
        /** @type {?} */
        NxMobileToggleButtonComponent.prototype.label;
        /** @type {?} */
        NxMobileToggleButtonComponent.prototype.circleText;
        /**
         * \@docs-private
         * @type {?}
         */
        NxMobileToggleButtonComponent.prototype.isFirst;
        /**
         * \@docs-private
         * @type {?}
         */
        NxMobileToggleButtonComponent.prototype.isLast;
        /**
         * @type {?}
         * @private
         */
        NxMobileToggleButtonComponent.prototype._changeDetectorRef;
    }

    /**
     * @fileoverview added by tsickle
     * Generated from: circle-toggle/circle-toggle.component.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var ToggleChangeEvent = /** @class */ (function () {
        function ToggleChangeEvent(button, value) {
            this.button = button;
            this.value = value;
        }
        return ToggleChangeEvent;
    }());
    if (false) {
        /**
         * A toggle button
         * @type {?}
         */
        ToggleChangeEvent.prototype.button;
        /**
         * The value of the toggle button that is sent with the event.
         * @type {?}
         */
        ToggleChangeEvent.prototype.value;
    }
    /** @type {?} */
    var nextId$1 = 0;
    var NxCircleToggleComponent = /** @class */ (function (_super) {
        __extends(NxCircleToggleComponent, _super);
        function NxCircleToggleComponent(/** @docs-private */ toggleGroup, _checkedDispatcher, _changeDetectorRef) {
            var _this = _super.call(this) || this;
            _this.toggleGroup = toggleGroup;
            _this._checkedDispatcher = _checkedDispatcher;
            _this._changeDetectorRef = _changeDetectorRef;
            _this._id = "toggle-button-" + nextId$1++;
            /**
             * \@docs-private
             */
            _this.inGroup = false;
            _this._name = null;
            /**
             * An event that is emitted when the checked state fo the circle toggle changes.
             */
            _this.checkedChange = new core.EventEmitter();
            /**
             * An event that is emitted when the checked state of the circle toggle changes.
             * The event object contains the circle toggle itself and its value (see ToggleChangeEvent).
             */
            _this.selectionChange = new core.EventEmitter();
            _this._checked = false;
            _this._value = null;
            _this._iconName = null;
            _this._svg = null;
            _this._svgChecked = null;
            _this._circleText = null;
            _this._label = null;
            _this._hint = null;
            _this._hover = false;
            /**
             * touched is set to true on touch devices.
             */
            _this._touched = false;
            _this._removeUniqueSelectionListener = (/**
             * @return {?}
             */
            function () { });
            _this.onChangeCallback = (/**
             * @param {?} checked
             * @return {?}
             */
            function (checked) { });
            _this.onTouchedCallback = (/**
             * @return {?}
             */
            function () { });
            if (_this.toggleGroup) {
                _this.name = _this.toggleGroup.name;
            }
            return _this;
        }
        Object.defineProperty(NxCircleToggleComponent.prototype, "id", {
            get: /**
             * @return {?}
             */
            function () {
                return this._id;
            },
            /**
             * Id of the circle toggle.
             *
             * If not set, the circle toggle gets an incremented value by default.
             */
            set: /**
             * Id of the circle toggle.
             *
             * If not set, the circle toggle gets an incremented value by default.
             * @param {?} value
             * @return {?}
             */
            function (value) {
                this._id = value;
                this._changeDetectorRef.markForCheck();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NxCircleToggleComponent.prototype, "name", {
            get: /**
             * @return {?}
             */
            function () {
                return this._name;
            },
            /** Name that is used for accessibility. */
            set: /**
             * Name that is used for accessibility.
             * @param {?} value
             * @return {?}
             */
            function (value) {
                this._name = value;
                this._changeDetectorRef.markForCheck();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NxCircleToggleComponent.prototype, "checked", {
            get: /**
             * @return {?}
             */
            function () {
                return this._checked;
            },
            /** Whether the circle toggle is checked. */
            set: /**
             * Whether the circle toggle is checked.
             * @param {?} value
             * @return {?}
             */
            function (value) {
                /** @type {?} */
                var newValue = coercion.coerceBooleanProperty(value);
                if (this.checked !== newValue) {
                    this._checked = newValue;
                    this._changeDetectorRef.markForCheck();
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NxCircleToggleComponent.prototype, "value", {
            get: /**
             * @return {?}
             */
            function () {
                return this._value;
            },
            /** The value that is used in the model. */
            set: /**
             * The value that is used in the model.
             * @param {?} newValue
             * @return {?}
             */
            function (newValue) {
                this._value = newValue;
                this._changeDetectorRef.markForCheck();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NxCircleToggleComponent.prototype, "iconName", {
            get: /**
             * @return {?}
             */
            function () {
                return this._iconName;
            },
            /** Id of the icon that should be displayed. */
            set: /**
             * Id of the icon that should be displayed.
             * @param {?} name
             * @return {?}
             */
            function (name) {
                this._iconName = name;
                this._changeDetectorRef.markForCheck();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NxCircleToggleComponent.prototype, "svg", {
            get: /**
             * @return {?}
             */
            function () {
                return this._svg;
            },
            /** SVG that is displayed if the circle toggle is unchecked. */
            set: /**
             * SVG that is displayed if the circle toggle is unchecked.
             * @param {?} src
             * @return {?}
             */
            function (src) {
                this._svg = src;
                this._changeDetectorRef.markForCheck();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NxCircleToggleComponent.prototype, "svgChecked", {
            get: /**
             * @return {?}
             */
            function () {
                return this._svgChecked;
            },
            /** SVG that is displayed if the circle toggle is checked. */
            set: /**
             * SVG that is displayed if the circle toggle is checked.
             * @param {?} src
             * @return {?}
             */
            function (src) {
                this._svgChecked = src;
                this._changeDetectorRef.markForCheck();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NxCircleToggleComponent.prototype, "circleText", {
            get: /**
             * @return {?}
             */
            function () {
                return this._circleText;
            },
            /** A text that is displayed inside the circle toggle. */
            set: /**
             * A text that is displayed inside the circle toggle.
             * @param {?} value
             * @return {?}
             */
            function (value) {
                if (value !== this._circleText) {
                    this._circleText = value;
                    this._changeDetectorRef.markForCheck();
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NxCircleToggleComponent.prototype, "label", {
            get: /**
             * @return {?}
             */
            function () {
                return this._label;
            },
            /** Label displayed below the circle. */
            set: /**
             * Label displayed below the circle.
             * @param {?} value
             * @return {?}
             */
            function (value) {
                this._label = value;
                this._changeDetectorRef.markForCheck();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NxCircleToggleComponent.prototype, "hint", {
            get: /**
             * @return {?}
             */
            function () {
                return this._hint;
            },
            /** Additional hint displayed below the label. */
            set: /**
             * Additional hint displayed below the label.
             * @param {?} value
             * @return {?}
             */
            function (value) {
                this._hint = value;
                this._changeDetectorRef.markForCheck();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NxCircleToggleComponent.prototype, "negative", {
            get: /**
             * @return {?}
             */
            function () {
                return this._negative;
            },
            /** Whether the circle toggle uses the negative set of styling. */
            set: /**
             * Whether the circle toggle uses the negative set of styling.
             * @param {?} value
             * @return {?}
             */
            function (value) {
                /** @type {?} */
                var newValue = coercion.coerceBooleanProperty(value);
                if (this.negative !== newValue) {
                    this._negative = newValue;
                    this._changeDetectorRef.markForCheck();
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NxCircleToggleComponent.prototype, "responsive", {
            get: /**
             * @return {?}
             */
            function () {
                return this._responsive;
            },
            /** Whether the circle toggle has a responsive behavior. */
            set: /**
             * Whether the circle toggle has a responsive behavior.
             * @param {?} value
             * @return {?}
             */
            function (value) {
                /** @type {?} */
                var newValue = coercion.coerceBooleanProperty(value);
                if (this.responsive !== newValue) {
                    this._responsive = newValue;
                    this._changeDetectorRef.markForCheck();
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NxCircleToggleComponent.prototype, "disabled", {
            get: /**
             * @return {?}
             */
            function () {
                return this._disabled;
            },
            /** Whether the circle toggle is disabled. */
            set: /**
             * Whether the circle toggle is disabled.
             * @param {?} value
             * @return {?}
             */
            function (value) {
                /** @type {?} */
                var newValue = coercion.coerceBooleanProperty(value);
                if (this.disabled !== newValue) {
                    this._disabled = newValue;
                    this._changeDetectorRef.markForCheck();
                }
            },
            enumerable: true,
            configurable: true
        });
        /** @docs-private */
        /**
         * \@docs-private
         * @return {?}
         */
        NxCircleToggleComponent.prototype.onMouseEnter = /**
         * \@docs-private
         * @return {?}
         */
        function () {
            if (!this._touched) {
                this._hover = true;
            }
        };
        /** @docs-private */
        /**
         * \@docs-private
         * @return {?}
         */
        NxCircleToggleComponent.prototype.onMouseLeave = /**
         * \@docs-private
         * @return {?}
         */
        function () {
            if (!this._touched) {
                this._hover = false;
            }
        };
        /** @docs-private */
        /**
         * \@docs-private
         * @return {?}
         */
        NxCircleToggleComponent.prototype.onTouchStart = /**
         * \@docs-private
         * @return {?}
         */
        function () {
            this._touched = true;
        };
        /**
         * @return {?}
         */
        NxCircleToggleComponent.prototype.ngOnInit = /**
         * @return {?}
         */
        function () {
            if (this.toggleGroup) {
                this.attachListenerForGroup();
            }
        };
        /**
         * @return {?}
         */
        NxCircleToggleComponent.prototype.ngAfterViewInit = /**
         * @return {?}
         */
        function () {
            var _this = this;
            if (this.toggleGroup) {
                Promise.resolve().then((/**
                 * @return {?}
                 */
                function () {
                    _this.inGroup = true;
                    _this.negative = _this.toggleGroup.negative;
                    _this.disabled = _this.toggleGroup.disabled;
                    _this.responsive = _this.toggleGroup.responsive;
                    _this.id = _this.toggleGroup.id + ("-button-" + nextId$1++);
                }));
            }
        };
        /**
         * @return {?}
         */
        NxCircleToggleComponent.prototype.ngOnDestroy = /**
         * @return {?}
         */
        function () {
            // function returned by the listener
            this._removeUniqueSelectionListener();
        };
        /** @docs-private */
        /**
         * \@docs-private
         * @return {?}
         */
        NxCircleToggleComponent.prototype.attachListenerForGroup = /**
         * \@docs-private
         * @return {?}
         */
        function () {
            var _this = this;
            this._removeUniqueSelectionListener =
                this._checkedDispatcher.listen((/**
                 * @param {?} groupId
                 * @param {?} buttonId
                 * @return {?}
                 */
                function (groupId, buttonId) {
                    if (_this.id !== buttonId && groupId === _this.toggleGroup.id) {
                        _this.checked = false;
                    }
                }));
        };
        /**
         * @param {?} newValue
         * @return {?}
         */
        NxCircleToggleComponent.prototype.writeValue = /**
         * @param {?} newValue
         * @return {?}
         */
        function (newValue) {
            this.checked = newValue;
        };
        /**
         * @param {?} fn
         * @return {?}
         */
        NxCircleToggleComponent.prototype.registerOnChange = /**
         * @param {?} fn
         * @return {?}
         */
        function (fn) {
            this.onChangeCallback = fn;
        };
        /**
         * @param {?} fn
         * @return {?}
         */
        NxCircleToggleComponent.prototype.registerOnTouched = /**
         * @param {?} fn
         * @return {?}
         */
        function (fn) {
            this.onTouchedCallback = fn;
        };
        /**
         * @param {?} isDisabled
         * @return {?}
         */
        NxCircleToggleComponent.prototype.setDisabledState = /**
         * @param {?} isDisabled
         * @return {?}
         */
        function (isDisabled) {
            this.disabled = isDisabled;
        };
        /** @docs-private */
        /**
         * \@docs-private
         * @param {?} event
         * @return {?}
         */
        NxCircleToggleComponent.prototype.toggle = /**
         * \@docs-private
         * @param {?} event
         * @return {?}
         */
        function (event) {
            event.preventDefault();
            event.stopPropagation();
            if ((this.toggleGroup && this.checked) || this.disabled) {
                return;
            }
            else {
                this.checked = !this.checked;
                this.onChangeCallback(this.checked);
                this.checkedChange.emit(this.checked);
                this.selectionChange.emit(new ToggleChangeEvent(this, this.value));
                if (this.toggleGroup) {
                    this._checkedDispatcher.notify(this.toggleGroup.id, this.id);
                }
            }
        };
        /**
         * @docs-private
         *
         * method called by the group if the internal value of the group is changed programatically,
         * does not trigger change emission
         */
        /**
         * \@docs-private
         *
         * method called by the group if the internal value of the group is changed programatically,
         * does not trigger change emission
         * @return {?}
         */
        NxCircleToggleComponent.prototype.setGroupSelection = /**
         * \@docs-private
         *
         * method called by the group if the internal value of the group is changed programatically,
         * does not trigger change emission
         * @return {?}
         */
        function () {
            // propagate changes only if the value in the group is different than the button checked value
            if (!this.checked) {
                this.checked = !this.checked;
                this.onChangeCallback(this.checked);
                this._checkedDispatcher.notify(this.toggleGroup.id, this.id);
            }
        };
        Object.defineProperty(NxCircleToggleComponent.prototype, "svgButton", {
            /** @docs-private */
            get: /**
             * \@docs-private
             * @return {?}
             */
            function () {
                return !!this.svg && !!this.svgChecked;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NxCircleToggleComponent.prototype, "svgUrl", {
            /** @docs-private */
            get: /**
             * \@docs-private
             * @return {?}
             */
            function () {
                /** @type {?} */
                var useFilledSvg = this.checked || (!this.disabled && this._hover);
                if (this.negative) {
                    useFilledSvg = !useFilledSvg;
                }
                return useFilledSvg ? this.svgChecked : this.svg;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NxCircleToggleComponent.prototype, "type", {
            /** @docs-private */
            get: /**
             * \@docs-private
             * @return {?}
             */
            function () {
                return this.toggleGroup ? 'radio' : 'checkbox';
            },
            enumerable: true,
            configurable: true
        });
        /** @docs-private */
        /**
         * \@docs-private
         * @param {?} event
         * @return {?}
         */
        NxCircleToggleComponent.prototype.handleEnterKey = /**
         * \@docs-private
         * @param {?} event
         * @return {?}
         */
        function (event) {
            if (!this.toggleGroup) {
                this.toggle(event);
            }
        };
        NxCircleToggleComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'nx-circle-toggle',
                        template: "<input [id]=\"id + '-input'\"\n       class=\"nx-circle-toggle__input\"\n       [attr.aria-labelledby]=\"id + '-label'\"\n       [type]=\"type\"\n       [attr.name]=\"name\"\n       [checked]=\"checked\"\n       [disabled]= \"disabled\"\n       [attr.aria-checked]=\"checked\"\n       (keydown.enter)=\"handleEnterKey($event)\"\n       (click)=\"toggle($event)\">\n<label class=\"nx-circle-toggle__label\"\n  [for]=\"id + '-input'\"\n  [id]=\"id + '-label'\">\n    <nx-icon-toggle-button\n      [label]=\"label\"\n      [hint]=\"hint\"\n      [checked]=\"checked\"\n      [icon]=\"iconName\"\n      [negative]=\"negative\"\n      [svg]=\"svgUrl\"\n      [disabled]=\"disabled\"\n      [inGroup]=\"inGroup\"\n      [touched]=\"_touched\"\n      [circleText]=\"circleText\">\n    </nx-icon-toggle-button>\n    <!-- The mobile toggle button is needed for the responsive mobile version of the component.\n    The display swtich is handled in the css. -->\n    <nx-mobile-toggle-button\n      [label]=\"label\"\n      [hint]=\"hint\"\n      [checked]=\"checked\"\n      [negative]=\"negative\"\n      [disabled]=\"disabled\"\n      [circleText]=\"circleText\">\n    </nx-mobile-toggle-button>\n</label>",
                        changeDetection: core.ChangeDetectionStrategy.OnPush,
                        providers: [
                            {
                                provide: ToggleButton,
                                useExisting: core.forwardRef((/**
                                 * @return {?}
                                 */
                                function () { return NxCircleToggleComponent; }))
                            },
                            {
                                provide: forms.NG_VALUE_ACCESSOR,
                                useExisting: core.forwardRef((/**
                                 * @return {?}
                                 */
                                function () { return NxCircleToggleComponent; })),
                                multi: true
                            }
                        ],
                        host: {
                            '[class.nx-toggle-circle]': 'true',
                            '[class.in-group]': 'inGroup',
                            '[class.is-disabled]': 'disabled',
                            '[class.is-responsive]': 'responsive'
                        },
                        styles: [":host{display:inline-block;vertical-align:top;position:relative}:host:not(.is-responsive){opacity:.9999}:host .nx-circle-toggle__input{opacity:0;position:absolute}:host:not(.in-group){margin-right:64px}@media (max-width:703px){:host:not(.in-group){margin-right:48px}}:host-context([data-whatinput=keyboard]) .nx-circle-toggle__input:focus+.nx-circle-toggle__label ::ng-deep .nx-toggle-circle__check-focus,:host-context([data-whatinput=keyboard]) .nx-circle-toggle__input:focus+.nx-circle-toggle__label ::ng-deep .nx-toggle-circle__icon-wrapper{box-shadow:0 0 0 2px #fff,0 0 0 6px #009de6;box-shadow:var(--focus-box-shadow,0 0 0 2px #fff,0 0 0 6px #009de6)}@media screen and (-ms-high-contrast:active){:host-context([data-whatinput=keyboard]) .nx-circle-toggle__input:focus+.nx-circle-toggle__label ::ng-deep .nx-toggle-circle__check-focus,:host-context([data-whatinput=keyboard]) .nx-circle-toggle__input:focus+.nx-circle-toggle__label ::ng-deep .nx-toggle-circle__icon-wrapper{box-shadow:0 0 0 2px background,0 0 0 6px windowText}}:host-context([data-whatinput=keyboard]) .nx-circle-toggle__input:focus+.nx-circle-toggle__label ::ng-deep nx-mobile-toggle-button{box-shadow:0 0 0 2px #fff,0 0 0 6px #009de6;box-shadow:var(--focus-box-shadow,0 0 0 2px #fff,0 0 0 6px #009de6);z-index:1}@media screen and (-ms-high-contrast:active){:host-context([data-whatinput=keyboard]) .nx-circle-toggle__input:focus+.nx-circle-toggle__label ::ng-deep nx-mobile-toggle-button{box-shadow:0 0 0 2px background,0 0 0 6px windowText}}"]
                    }] }
        ];
        /** @nocollapse */
        NxCircleToggleComponent.ctorParameters = function () { return [
            { type: NxCircleToggleGroupComponent, decorators: [{ type: core.Optional }] },
            { type: collections.UniqueSelectionDispatcher },
            { type: core.ChangeDetectorRef }
        ]; };
        NxCircleToggleComponent.propDecorators = {
            name: [{ type: core.Input }],
            checkedChange: [{ type: core.Output }],
            selectionChange: [{ type: core.Output }],
            checked: [{ type: core.Input }],
            value: [{ type: core.Input }],
            iconName: [{ type: core.Input, args: ['icon',] }],
            svg: [{ type: core.Input }],
            svgChecked: [{ type: core.Input }],
            circleText: [{ type: core.Input }],
            label: [{ type: core.Input }],
            hint: [{ type: core.Input }],
            negative: [{ type: core.Input }],
            responsive: [{ type: core.Input }],
            disabled: [{ type: core.Input }],
            toggleButton: [{ type: core.ViewChild, args: [NxMobileToggleButtonComponent, { static: true },] }],
            onMouseEnter: [{ type: core.HostListener, args: ['mouseenter',] }],
            onMouseLeave: [{ type: core.HostListener, args: ['mouseleave',] }],
            onTouchStart: [{ type: core.HostListener, args: ['touchstart',] }]
        };
        return NxCircleToggleComponent;
    }(ToggleButton));
    if (false) {
        /**
         * @type {?}
         * @private
         */
        NxCircleToggleComponent.prototype._id;
        /**
         * \@docs-private
         * @type {?}
         */
        NxCircleToggleComponent.prototype.inGroup;
        /**
         * @type {?}
         * @private
         */
        NxCircleToggleComponent.prototype._name;
        /**
         * An event that is emitted when the checked state fo the circle toggle changes.
         * @type {?}
         */
        NxCircleToggleComponent.prototype.checkedChange;
        /**
         * An event that is emitted when the checked state of the circle toggle changes.
         * The event object contains the circle toggle itself and its value (see ToggleChangeEvent).
         * @type {?}
         */
        NxCircleToggleComponent.prototype.selectionChange;
        /** @type {?} */
        NxCircleToggleComponent.prototype._checked;
        /**
         * @type {?}
         * @private
         */
        NxCircleToggleComponent.prototype._value;
        /**
         * @type {?}
         * @private
         */
        NxCircleToggleComponent.prototype._iconName;
        /**
         * @type {?}
         * @private
         */
        NxCircleToggleComponent.prototype._svg;
        /**
         * @type {?}
         * @private
         */
        NxCircleToggleComponent.prototype._svgChecked;
        /**
         * @type {?}
         * @private
         */
        NxCircleToggleComponent.prototype._circleText;
        /**
         * @type {?}
         * @private
         */
        NxCircleToggleComponent.prototype._label;
        /**
         * @type {?}
         * @private
         */
        NxCircleToggleComponent.prototype._hint;
        /**
         * @type {?}
         * @private
         */
        NxCircleToggleComponent.prototype._negative;
        /**
         * @type {?}
         * @private
         */
        NxCircleToggleComponent.prototype._responsive;
        /**
         * @type {?}
         * @private
         */
        NxCircleToggleComponent.prototype._disabled;
        /**
         * \@docs-private
         * @type {?}
         */
        NxCircleToggleComponent.prototype.toggleButton;
        /**
         * @type {?}
         * @private
         */
        NxCircleToggleComponent.prototype._hover;
        /**
         * touched is set to true on touch devices.
         * @type {?}
         */
        NxCircleToggleComponent.prototype._touched;
        /** @type {?} */
        NxCircleToggleComponent.prototype._removeUniqueSelectionListener;
        /**
         * @type {?}
         * @private
         */
        NxCircleToggleComponent.prototype.onChangeCallback;
        /**
         * @type {?}
         * @private
         */
        NxCircleToggleComponent.prototype.onTouchedCallback;
        /**
         * \@docs-private
         * @type {?}
         */
        NxCircleToggleComponent.prototype.toggleGroup;
        /**
         * @type {?}
         * @private
         */
        NxCircleToggleComponent.prototype._checkedDispatcher;
        /**
         * @type {?}
         * @private
         */
        NxCircleToggleComponent.prototype._changeDetectorRef;
    }

    /**
     * @fileoverview added by tsickle
     * Generated from: icon-toggle-button/icon-toggle-button.component.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * \@docs-private
     */
    var NxIconToggleButtonComponent = /** @class */ (function () {
        function NxIconToggleButtonComponent() {
            this.inGroup = true;
        }
        NxIconToggleButtonComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'nx-icon-toggle-button',
                        template: "<div class=\"nx-toggle-circle__icon-wrapper\">\n  <ng-container *ngIf=\"!inGroup\">\n    <span class=\"nx-toggle-circle__check-icon\">\n      <nx-icon name=\"check\"></nx-icon>\n    </span>\n    <div class=\"nx-toggle-circle__check-focus\"></div>\n  </ng-container>\n  <span class=\"nx-toggle-circle__icon\">\n    <nx-icon size=\"m\" *ngIf=\"icon\" [name]=\"icon\"></nx-icon>\n    <img *ngIf=\"svgUrl\" class=\"nx-toggle-circle__icon-image\" [src]=\"svgUrl\" />\n    <span *ngIf=\"circleText\" class=\"nx-toggle-circle__content-text\">{{circleText}}</span>\n  </span>\n</div>\n<span [class.is-label-bold]=\"hint\" class=\"nx-toggle-circle__label-text\">{{label}}</span>\n<span *ngIf=\"hint\" class=\"nx-toggle-circle__label-hint\">{{hint}}</span>\n",
                        changeDetection: core.ChangeDetectionStrategy.OnPush,
                        host: {
                            '[class.nx-circle-button]': 'true',
                            '[class.is-flipped]': 'checked',
                            '[class.has-checkmark]': '!inGroup',
                            '[class.is-disabled]': 'disabled',
                            '[class.is-negative]': 'negative',
                            '[class.is-touched]': 'touched'
                        },
                        styles: ["@media (max-width:703px){:host-context(.is-responsive){display:none}}:host{display:flex;flex-direction:column;padding:0;align-items:center;cursor:pointer;position:relative}:host .nx-toggle-circle__label-text{font-size:16px;font-size:var(--circle-toggle-label-font-size,16px);line-height:24px;line-height:var(--circle-toggle-label-line-height,24px);font-weight:400;font-weight:var(--circle-toggle-label-font-weight,400);letter-spacing:0;letter-spacing:var(--circle-toggle-label-letter-spacing,0);color:#414141;color:var(--circle-toggle-label-color,#414141);position:relative;display:inline-block;padding-top:12px;max-width:16rem;z-index:1}@media (max-width:703px){:host .nx-toggle-circle__label-text{font-size:14px;font-size:var(--circle-toggle-label-mobile-font-size,14px);line-height:20px;line-height:var(--circle-toggle-label-mobile-line-height,20px);font-weight:400;font-weight:var(--circle-toggle-label-mobile-font-weight,400);letter-spacing:.2px;letter-spacing:var(--circle-toggle-label-mobile-letter-spacing,.2px)}}:host .is-label-bold{font-weight:700}:host .nx-toggle-circle__icon-wrapper{height:80px;width:80px;border-radius:50%;border-color:var(--circle-toggle-border-color,#007ab3);display:flex;align-items:center;justify-content:center;transition:background-color .2s,border-color .2s,box-shadow .2s;border:2px solid #007ab3}@media (max-width:703px){:host .is-label-bold{font-weight:400}:host .nx-toggle-circle__icon-wrapper{height:64px;width:64px}:host .nx-toggle-circle__icon-wrapper .nx-toggle-circle__icon nx-icon{font-size:40px}}:host .nx-toggle-circle__check-icon{background-color:#3da556;background-color:var(--circle-toggle-checkmark-background-color,#3da556);color:#fff;color:var(--circle-toggle-checkmark-color,#fff);border-color:var(--circle-toggle-checkmark-border-color,#fff);border-radius:50%;font-size:24px;width:32px;height:32px;position:absolute;top:-8px;right:calc(50% - 48px);transition:opacity .3s;z-index:1;opacity:0;display:flex;justify-content:center;align-items:center;border:2px solid #fff}:host .nx-toggle-circle__check-focus{border-radius:50%;width:28px;height:28px;position:absolute;top:-6px;right:calc(50% - 48px + 2px);z-index:-1;opacity:0;transition:box-shadow .2s}:host .nx-toggle-circle__content-text{font-size:24px;font-size:var(--circle-toggle-content-text-font-size,24px);line-height:32px;line-height:var(--circle-toggle-content-text-line-height,32px);font-weight:400;font-weight:var(--circle-toggle-content-text-font-weight,400);letter-spacing:.2px;letter-spacing:var(--circle-toggle-content-text-letter-spacing,.2px);color:#006192;color:var(--circle-toggle-content-text-color,#006192)}@media (max-width:703px){:host .nx-toggle-circle__content-text{font-size:20px;font-size:var(--circle-toggle-content-text-mobile-font-size,20px);line-height:28px;line-height:var(--circle-toggle-content-text-mobile-line-height,28px);font-weight:400;font-weight:var(--circle-toggle-content-text-mobile-font-weight,400);letter-spacing:.2px;letter-spacing:var(--circle-toggle-content-text-mobile-letter-spacing,.2px)}:host .nx-toggle-circle__label-hint .nx-toggle-circle__icon-wrapper{width:64px;height:64px}:host .nx-toggle-circle__label-hint .nx-toggle-circle__icon nx-icon{font-size:32px}:host .nx-toggle-circle__label-hint .nx-toggle-circle__check-icon{right:calc(50% - 40px)}:host .nx-toggle-circle__label-hint .nx-toggle-circle__icon-image{width:64px;height:64px}}:host .nx-toggle-circle__label-hint{font-size:16px;font-size:var(--circle-toggle-hint-font-size,16px);line-height:24px;line-height:var(--circle-toggle-hint-line-height,24px);font-weight:400;font-weight:var(--circle-toggle-hint-font-weight,400);letter-spacing:0;letter-spacing:var(--circle-toggle-hint-letter-spacing,0);color:#414141;color:var(--circle-toggle-hint-color,#414141);display:inline-block;transition:color .2s;z-index:1}@media (max-width:703px){:host .nx-toggle-circle__label-hint{font-size:14px;font-size:var(--circle-toggle-hint-mobile-font-size,14px);line-height:20px;line-height:var(--circle-toggle-hint-mobile-line-height,20px);font-weight:300;font-weight:var(--circle-toggle-hint-mobile-font-weight,300);letter-spacing:.2px;letter-spacing:var(--circle-toggle-hint-mobile-letter-spacing,.2px)}}:host .nx-toggle-circle__icon{display:flex;justify-content:center;align-content:center}:host .nx-toggle-circle__icon nx-icon{color:#007ab3;color:var(--circle-toggle-icon-color,#007ab3)}:host .nx-toggle-circle__icon-image{pointer-events:none;position:relative;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}:host(.is-flipped) .nx-toggle-circle__icon-wrapper{background-color:#007ab3;background-color:var(--circle-toggle-selected-background-color,#007ab3);border-color:#007ab3;border-color:var(--circle-toggle-selected-border-color,#007ab3)}:host(.is-flipped) .nx-toggle-circle__icon nx-icon{color:#fff;color:var(--circle-toggle-selected-icon-color,#fff)}:host(.is-flipped) .nx-toggle-circle__content-text{color:#fff;color:var(--circle-toggle-selected-content-text-color,#fff)}:host(.is-flipped) .nx-toggle-circle__check-focus,:host(.is-flipped) .nx-toggle-circle__check-icon{opacity:1}:host:not(.is-disabled):not(.is-negative):not(.is-touched):hover .nx-toggle-circle__icon-wrapper{border-color:#006192;border-color:var(--circle-toggle-hover-border-color,#006192);background-color:#006192;background-color:var(--circle-toggle-hover-background-color,#006192)}:host:not(.is-disabled):not(.is-negative):not(.is-touched):hover:not(.is-flipped) .nx-toggle-circle__icon-wrapper{border-color:#007ab3;border-color:var(--circle-toggle-selected-border-color,#007ab3);background-color:#007ab3;background-color:var(--circle-toggle-selected-background-color,#007ab3)}:host:not(.is-disabled):not(.is-negative):not(.is-touched):hover .nx-toggle-circle__content-text{color:#fff;color:var(--circle-toggle-hover-icon-color,#fff)}:host:not(.is-disabled):not(.is-negative):not(.is-touched):hover .nx-toggle-circle__icon nx-icon{color:#fff;color:var(--circle-toggle-hover-icon-color,#fff)}:host:hover.is-flipped:not(.has-checkmark){cursor:auto}:host(.is-disabled){opacity:.4;cursor:not-allowed}:host(.is-negative) .nx-toggle-circle__icon-wrapper{border-color:#fff;background-color:transparent}:host(.is-negative) .nx-toggle-circle__content-text,:host(.is-negative) .nx-toggle-circle__icon nx-icon,:host(.is-negative) .nx-toggle-circle__label-hint,:host(.is-negative) .nx-toggle-circle__label-text{color:#fff}:host(.is-negative):not(.is-disabled):not(.is-touched):hover .nx-toggle-circle__icon-wrapper,:host(.is-negative.is-flipped) .nx-toggle-circle__icon-wrapper{border-color:#fff;background-color:#fff}:host(.is-negative):not(.is-disabled):not(.is-touched):hover .nx-toggle-circle__icon nx-icon,:host(.is-negative.is-flipped) .nx-toggle-circle__icon nx-icon{color:#007ab3}:host(.is-negative):not(.is-disabled):not(.is-touched):hover .nx-toggle-circle__content-text,:host(.is-negative.is-flipped) .nx-toggle-circle__content-text{color:#006192}@media screen and (-ms-high-contrast:active){.nx-toggle-circle__icon-wrapper{border-color:buttonText;background-color:buttonFace}.nx-toggle-circle__content-text{-ms-high-contrast-adjust:none}.nx-toggle-circle__label-hint,.nx-toggle-circle__label-text{color:buttonText}:host(.is-negative):not(.is-flipped):not(.is-disabled):not(.is-touched) .nx-toggle-circle__content-text,:host(.is-negative):not(.is-flipped):not(.is-disabled):not(.is-touched) .nx-toggle-circle__icon nx-icon,:host:not(.is-flipped) .nx-toggle-circle__content-text,:host:not(.is-flipped) .nx-toggle-circle__icon nx-icon{color:buttonText}:host(.is-flipped) .nx-toggle-circle__icon-wrapper,:host(.is-negative.is-flipped) .nx-toggle-circle__icon-wrapper{background:highlight;border-color:highlight;color:highlightText}:host(.is-flipped) .nx-toggle-circle__content-text,:host(.is-flipped) .nx-toggle-circle__icon nx-icon,:host(.is-negative.is-flipped) .nx-toggle-circle__content-text,:host(.is-negative.is-flipped) .nx-toggle-circle__icon nx-icon{color:highlightText}:host(.is-flipped) .nx-toggle-circle__check-icon,:host(.is-negative.is-flipped) .nx-toggle-circle__check-icon{border-color:windowText;color:windowText}:host.is-negative:not(.is-disabled):not(.is-touched):hover.is-flipped .nx-toggle-circle__content-text,:host.is-negative:not(.is-disabled):not(.is-touched):hover.is-flipped .nx-toggle-circle__icon nx-icon,:host:not(.is-disabled):not(.is-touched):hover.is-flipped .nx-toggle-circle__content-text,:host:not(.is-disabled):not(.is-touched):hover.is-flipped .nx-toggle-circle__icon nx-icon{color:highlightText}:host.is-negative:not(.is-disabled):not(.is-touched):hover:not(.is-flipped) .nx-toggle-circle__content-text,:host.is-negative:not(.is-disabled):not(.is-touched):hover:not(.is-flipped) .nx-toggle-circle__icon nx-icon,:host:not(.is-disabled):not(.is-touched):hover:not(.is-flipped) .nx-toggle-circle__content-text,:host:not(.is-disabled):not(.is-touched):hover:not(.is-flipped) .nx-toggle-circle__icon nx-icon{color:buttonText}:host(.is-disabled),:host(.is-disabled.is-flipped),:host(.is-disabled.is-flipped):hover{opacity:1}:host(.is-disabled) .nx-toggle-circle__icon-wrapper,:host(.is-disabled.is-flipped) .nx-toggle-circle__icon-wrapper,:host(.is-disabled.is-flipped):hover .nx-toggle-circle__icon-wrapper{border-color:GrayText;background:buttonFace;color:GrayText}:host(.is-disabled) .nx-toggle-circle__icon-wrapper .nx-toggle-circle__content-text,:host(.is-disabled) .nx-toggle-circle__icon-wrapper .nx-toggle-circle__icon nx-icon,:host(.is-disabled.is-flipped) .nx-toggle-circle__icon-wrapper .nx-toggle-circle__content-text,:host(.is-disabled.is-flipped) .nx-toggle-circle__icon-wrapper .nx-toggle-circle__icon nx-icon,:host(.is-disabled.is-flipped):hover .nx-toggle-circle__icon-wrapper .nx-toggle-circle__content-text,:host(.is-disabled.is-flipped):hover .nx-toggle-circle__icon-wrapper .nx-toggle-circle__icon nx-icon{color:GrayText}:host(.is-disabled) .nx-toggle-circle__check-icon,:host(.is-disabled.is-flipped) .nx-toggle-circle__check-icon,:host(.is-disabled.is-flipped):hover .nx-toggle-circle__check-icon{border-color:GrayText;color:GrayText}:host(.is-disabled) .nx-toggle-circle__label-hint,:host(.is-disabled) .nx-toggle-circle__label-text,:host(.is-disabled.is-flipped) .nx-toggle-circle__label-hint,:host(.is-disabled.is-flipped) .nx-toggle-circle__label-text,:host(.is-disabled.is-flipped):hover .nx-toggle-circle__label-hint,:host(.is-disabled.is-flipped):hover .nx-toggle-circle__label-text{color:GrayText}}"]
                    }] }
        ];
        NxIconToggleButtonComponent.propDecorators = {
            inGroup: [{ type: core.Input }],
            hint: [{ type: core.Input }],
            label: [{ type: core.Input }],
            checked: [{ type: core.Input }],
            icon: [{ type: core.Input }],
            svgUrl: [{ type: core.Input, args: ['svg',] }],
            disabled: [{ type: core.Input }],
            negative: [{ type: core.Input }],
            touched: [{ type: core.Input }],
            circleText: [{ type: core.Input }]
        };
        return NxIconToggleButtonComponent;
    }());
    if (false) {
        /** @type {?} */
        NxIconToggleButtonComponent.prototype.inGroup;
        /** @type {?} */
        NxIconToggleButtonComponent.prototype.hint;
        /** @type {?} */
        NxIconToggleButtonComponent.prototype.label;
        /** @type {?} */
        NxIconToggleButtonComponent.prototype.checked;
        /** @type {?} */
        NxIconToggleButtonComponent.prototype.icon;
        /** @type {?} */
        NxIconToggleButtonComponent.prototype.svgUrl;
        /** @type {?} */
        NxIconToggleButtonComponent.prototype.disabled;
        /** @type {?} */
        NxIconToggleButtonComponent.prototype.negative;
        /** @type {?} */
        NxIconToggleButtonComponent.prototype.touched;
        /** @type {?} */
        NxIconToggleButtonComponent.prototype.circleText;
    }

    /**
     * @fileoverview added by tsickle
     * Generated from: circle-toggle.module.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var NxCircleToggleModule = /** @class */ (function () {
        function NxCircleToggleModule() {
        }
        NxCircleToggleModule.decorators = [
            { type: core.NgModule, args: [{
                        declarations: [
                            NxCircleToggleGroupComponent,
                            NxCircleToggleComponent,
                            NxIconToggleButtonComponent,
                            NxMobileToggleButtonComponent
                        ],
                        exports: [
                            NxCircleToggleGroupComponent,
                            NxIconToggleButtonComponent,
                            NxCircleToggleComponent,
                            NxMobileToggleButtonComponent
                        ],
                        imports: [
                            common.CommonModule,
                            icon.NxIconModule
                        ]
                    },] }
        ];
        return NxCircleToggleModule;
    }());

    exports.NxCircleToggleComponent = NxCircleToggleComponent;
    exports.NxCircleToggleGroupComponent = NxCircleToggleGroupComponent;
    exports.NxCircleToggleModule = NxCircleToggleModule;
    exports.NxIconToggleButtonComponent = NxIconToggleButtonComponent;
    exports.NxMobileToggleButtonComponent = NxMobileToggleButtonComponent;
    exports.ToggleChangeEvent = ToggleChangeEvent;
    exports.a = ToggleButton;

    Object.defineProperty(exports, '__esModule', { value: true });

})));
//# sourceMappingURL=allianz-ngx-ndbx-circle-toggle.umd.js.map
