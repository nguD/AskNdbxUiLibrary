{"version":3,"sources":["../../../node_modules/tslib/tslib.es6.js","ng://@allianz/ngx-ndbx/context-menu/context-menu-content.directive.ts","ng://@allianz/ngx-ndbx/context-menu/context-menu-animations.ts","ng://@allianz/ngx-ndbx/context-menu/context-menu.component.ts","ng://@allianz/ngx-ndbx/context-menu/context-menu-item.component.ts","ng://@allianz/ngx-ndbx/context-menu/context-menu-trigger.directive.ts","ng://@allianz/ngx-ndbx/context-menu/context-menu-errors.ts","ng://@allianz/ngx-ndbx/context-menu/context-menu.module.ts"],"names":["__read","o","n","m","Symbol","iterator","r","e","i","call","ar","next","done","push","value","error","NxContextMenuContentDirective","_template","_componentFactoryResolver","_appRef","_injector","_viewContainerRef","_document","this","_attached","Subject","prototype","attach","context","_portal","TemplatePortal","detach","_outlet","DomPortalOutlet","createElement","element","elementRef","nativeElement","parentNode","insertBefore","outletElement","isAttached","ngOnDestroy","dispose","Directive","args","selector","TemplateRef","ComponentFactoryResolver","ApplicationRef","Injector","ViewContainerRef","Inject","DOCUMENT","nxContextMenuAnimations","transformContextMenu","trigger","state","style","opacity","transform","transition","group","query","animate","NxContextMenuComponent","_ngZone","_items","_itemChanges","_tabSubscription","Subscription","EMPTY","_classList","_panelAnimationState","_animationDone","closed","EventEmitter","ngAfterContentInit","_this","_keyManager","FocusKeyManager","withWrap","withTypeAhead","tabOut","subscribe","emit","unsubscribe","complete","_hovered","pipe","startWith","switchMap","items","merge","apply","arguments","length","concat","__spread","map","item","_handleKeydown","event","keyCode","manager","ESCAPE","hasModifierKey","preventDefault","LEFT_ARROW","parentMenu","direction","RIGHT_ARROW","HOME","END","setFirstItemActive","setLastItemActive","onKeydown","focusFirstItem","lazyContent","onStable","asObservable","take","resetActiveItem","setActiveItem","addItem","indexOf","removeItem","index","splice","_startAnimation","_resetAnimation","_onAnimationDone","_isAnimating","_onAnimationStart","toState","activeItemIndex","scrollTop","Component","template","changeDetection","ChangeDetectionStrategy","OnPush","exportAs","animations","NgZone","ViewChild","static","ContentChild","Output","NxContextMenuItemComponent","_elementRef","document","_changeDetectorRef","_parentMenu","_disabled","_highlighted","_triggersSubmenu","Object","defineProperty","coerceBooleanProperty","markForCheck","focus","_getHostElement","_getTabIndex","disabled","_checkDisabled","stopPropagation","_handleMouseEnter","getLabel","textNodeType","TEXT_NODE","output","childNodes","length_1","nodeType","textContent","trim","host","class","role","[class.is-highlighted]","[attr.tabindex]","[attr.aria-disabled]","[attr.disabled]","(mouseenter)","(click)","ElementRef","ChangeDetectorRef","decorators","type","Optional","Input","normalizePassiveListenerOptions","passive","NxContextMenuTriggerDirective","_overlay","_element","_contextMenuItemInstance","_dir","_overlayRef","_contextMenuOpen","_closingActionsSubscription","_hoverSubscription","_contextMenuCloseSubscription","contextMenuOpened","contextMenuClosed","triggersSubmenu","_scrollStrategy","scrollStrategies","reposition","_documentClickObservable","fromEvent","_contextMenu","contextMenu","reason","_destroyMenu","close","_checkContextMenu","_handleHover","toggleContextMenu","contextMenuOpen","closeContextMenu","openContextMenu","overlayRef","_createOverlay","overlayConfig","getConfig","_setPosition","_getPortal","contextMenuData","_contextMenuClosingActions","_initContextMenu","_waitForClose","filter","takeUntil","_resetContextMenu","undefined","dir","_setIsContextMenuOpen","isOpen","Error","throwNxContextMenuMissingError","config","_getOverlayConfig","create","keydownEvents","OverlayConfig","positionStrategy","position","flexibleConnectedTo","withLockedPosition","withFlexibleDimensions","withTransformOriginOn","scrollStrategy","originX","originFallbackX","originY","originFallbackY","overlayX","overlayFallbackX","offsetY","withPositions","overlayY","backdrop","detachments","backdropClick","parentClose","observableOf","hover","active","_handleMousedown","_handleClick","target","contains","delay","asapScheduler","templateRef","aria-haspopup","[attr.aria-expanded]","(mousedown)","(keydown)","Overlay","Self","Directionality","EXPORTED_MODULES","NxContextMenuModule","NgModule","imports","CommonModule","OverlayModule","NxIconModule","exports","declarations"],"mappings":"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","sourcesContent":["/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation. All rights reserved.\r\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\r\nthis file except in compliance with the License. You may obtain a copy of the\r\nLicense at http://www.apache.org/licenses/LICENSE-2.0\r\n\r\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\r\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\r\nMERCHANTABLITY OR NON-INFRINGEMENT.\r\n\r\nSee the Apache Version 2.0 License for specific language governing permissions\r\nand limitations under the License.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nexport function __extends(d, b) {\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nexport var __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    }\r\n    return __assign.apply(this, arguments);\r\n}\r\n\r\nexport function __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n}\r\n\r\nexport function __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nexport function __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nexport function __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nexport function __awaiter(thisArg, _arguments, P, generator) {\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nexport function __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nexport function __exportStar(m, exports) {\r\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\r\n}\r\n\r\nexport function __values(o) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator], i = 0;\r\n    if (m) return m.call(o);\r\n    return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n}\r\n\r\nexport function __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\nexport function __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\nexport function __spreadArrays() {\r\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\r\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\r\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\r\n            r[k] = a[j];\r\n    return r;\r\n};\r\n\r\nexport function __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nexport function __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nexport function __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === \"return\" } : f ? f(v) : v; } : f; }\r\n}\r\n\r\nexport function __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\nexport function __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nexport function __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\r\n    result.default = mod;\r\n    return result;\r\n}\r\n\r\nexport function __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n","import {\n  Directive,\n  TemplateRef,\n  ComponentFactoryResolver,\n  ApplicationRef,\n  Injector,\n  ViewContainerRef,\n  Inject,\n  OnDestroy\n} from '@angular/core';\nimport { TemplatePortal, DomPortalOutlet } from '@angular/cdk/portal';\nimport { DOCUMENT } from '@angular/common';\nimport { Subject } from 'rxjs';\n\n/**\n * Context menu content that will be rendered lazily once the menu is opened.\n */\n@Directive({\n  selector: 'ng-template[nxContextMenuContent]'\n})\nexport class NxContextMenuContentDirective implements OnDestroy {\n  private _portal: TemplatePortal<any>;\n  private _outlet: DomPortalOutlet;\n\n  /** Emits when the menu content has been attached. */\n  _attached = new Subject<void>();\n\n  constructor(\n    private _template: TemplateRef<any>,\n    private _componentFactoryResolver: ComponentFactoryResolver,\n    private _appRef: ApplicationRef,\n    private _injector: Injector,\n    private _viewContainerRef: ViewContainerRef,\n    @Inject(DOCUMENT) private _document: any\n  ) {}\n\n  /**\n   * Attaches the content with a particular context.\n   * @docs-private\n   */\n  attach(context: any = {}) {\n    if (!this._portal) {\n      this._portal = new TemplatePortal(this._template, this._viewContainerRef);\n    }\n\n    this.detach();\n\n    if (!this._outlet) {\n      this._outlet = new DomPortalOutlet(\n        this._document.createElement('div'),\n        this._componentFactoryResolver,\n        this._appRef,\n        this._injector\n      );\n    }\n\n    const element: HTMLElement = this._template.elementRef.nativeElement;\n\n    // Because we support opening the same menu from different triggers (which in turn have their\n    // own `OverlayRef` panel), we have to re-insert the host element every time, otherwise we\n    // risk it staying attached to a pane that's no longer in the DOM.\n    if (element.parentNode) {\n      element.parentNode.insertBefore(this._outlet.outletElement, element);\n    }\n    this._portal.attach(this._outlet, context);\n    this._attached.next();\n  }\n\n  /**\n   * Detaches the content.\n   * @docs-private\n   */\n  detach() {\n    if (this._portal.isAttached) {\n      this._portal.detach();\n    }\n  }\n\n  ngOnDestroy() {\n    if (this._outlet) {\n      this._outlet.dispose();\n    }\n  }\n}\n","import {\n  trigger,\n  state,\n  style,\n  animate,\n  transition,\n  query,\n  group,\n  AnimationTriggerMetadata,\n} from '@angular/animations';\n\n/**\n * Animations used by the NxContextMenuComponent.\n * @docs-private\n */\nexport const nxContextMenuAnimations: {\n  readonly transformContextMenu: AnimationTriggerMetadata;\n} = {\n  /**\n   * This animation controls the context menu panel's entry and exit from the page.\n   * When the context menu panel is added to the DOM, it scales in and fades in its border.\n   * When the context menu panel is removed from the DOM, it simply fades out.\n   */\n  transformContextMenu: trigger('transformContextMenu', [\n    state('void', style({\n      opacity: 0,\n      transform: 'scale(0.8)'\n    })),\n    transition('void => enter', group([\n      query('.nx-context-menu__content', animate('100ms linear', style({\n        opacity: 1\n      }))),\n      animate('120ms cubic-bezier(0, 0, 0.2, 1)', style({ transform: 'scale(1)' })),\n    ])),\n    transition('* => void', animate('100ms linear', style({ opacity: 0 })))\n  ])\n};\n","import { FocusKeyManager } from '@angular/cdk/a11y';\nimport { Direction } from '@angular/cdk/bidi';\nimport {\n  ESCAPE,\n  LEFT_ARROW,\n  RIGHT_ARROW,\n  HOME,\n  END,\n  hasModifierKey\n} from '@angular/cdk/keycodes';\nimport {\n  AfterContentInit,\n  ChangeDetectionStrategy,\n  Component,\n  ContentChild,\n  EventEmitter,\n  NgZone,\n  OnDestroy,\n  Output,\n  TemplateRef,\n  ViewChild,\n} from '@angular/core';\nimport { merge, Observable, Subject, Subscription } from 'rxjs';\nimport { startWith, switchMap, take } from 'rxjs/operators';\nimport { nxContextMenuAnimations } from './context-menu-animations';\nimport { NxContextMenuContentDirective } from './context-menu-content.directive';\nimport { NxContextMenuItemComponent } from './context-menu-item.component';\nimport { AnimationEvent } from '@angular/animations';\n\n@Component({\n  selector: 'nx-context-menu',\n  templateUrl: './context-menu.component.html',\n  styleUrls: ['./context-menu.scss'],\n  changeDetection: ChangeDetectionStrategy.OnPush,\n  exportAs: 'nxContextMenu',\n  animations: [\n    nxContextMenuAnimations.transformContextMenu\n  ]\n})\nexport class NxContextMenuComponent\n  implements AfterContentInit, OnDestroy {\n  private _keyManager: FocusKeyManager<NxContextMenuItemComponent>;\n\n  /** Menu items inside the current menu. */\n  private _items: NxContextMenuItemComponent[] = [];\n\n  /** Emits whenever the amount of menu items changes. */\n  private _itemChanges = new Subject<NxContextMenuItemComponent[]>();\n\n  /** Subscription to tab events on the menu panel */\n  private _tabSubscription = Subscription.EMPTY;\n\n  /** Config object to be passed into the menu's ngClass */\n  _classList: { [key: string]: boolean } = {};\n\n  /** Current state of the panel animation. */\n  _panelAnimationState: 'void' | 'enter' = 'void';\n\n  /** Emits whenever an animation on the menu completes. */\n  _animationDone = new Subject<AnimationEvent>();\n\n  /** Whether the menu is animating. */\n  _isAnimating: boolean;\n\n  /** Parent menu of the current menu panel. */\n  parentMenu: NxContextMenuComponent | undefined;\n\n  /**\n   * @docs-private\n   * Layout direction of the menu.\n   */\n  direction: Direction;\n\n  /** @docs-private */\n  @ViewChild(TemplateRef, { static: false })\n  templateRef: TemplateRef<any>;\n\n  /**\n   * Menu content that will be rendered lazily.\n   * @docs-private\n   */\n  @ContentChild(NxContextMenuContentDirective, { static: false })\n  lazyContent: NxContextMenuContentDirective;\n\n  /** Event emitted when the menu is closed. */\n  @Output() readonly closed: EventEmitter<void | 'click' | 'keydown' | 'tab'> = new EventEmitter<void | 'click' | 'keydown' | 'tab'>();\n\n  constructor(private _ngZone: NgZone) {}\n\n  ngAfterContentInit() {\n    this._keyManager = new FocusKeyManager<NxContextMenuItemComponent>(\n        this._items\n      )\n      .withWrap()\n      .withTypeAhead();\n    this._tabSubscription = this._keyManager.tabOut.subscribe(() =>\n      this.closed.emit('tab')\n    );\n  }\n\n  ngOnDestroy() {\n    this._tabSubscription.unsubscribe();\n    this.closed.complete();\n  }\n\n  /** Stream that emits whenever the hovered menu item changes. */\n  _hovered(): Observable<NxContextMenuItemComponent> {\n    return this._itemChanges.pipe(\n      startWith(this._items),\n      switchMap(items => merge(...items.map(item => item._hovered)))\n    );\n  }\n\n  /** Handle a keyboard event from the menu, delegating to the appropriate action. */\n  _handleKeydown(event: KeyboardEvent) {\n    const keyCode = event.keyCode;\n    const manager = this._keyManager;\n\n    switch (keyCode) {\n      case ESCAPE:\n        if (!hasModifierKey(event)) {\n          event.preventDefault();\n          this.closed.emit('keydown');\n        }\n        break;\n      case LEFT_ARROW:\n        if (this.parentMenu && this.direction === 'ltr') {\n          this.closed.emit('keydown');\n        }\n        break;\n      case RIGHT_ARROW:\n        if (this.parentMenu && this.direction === 'rtl') {\n          this.closed.emit('keydown');\n        }\n        break;\n      case HOME:\n      case END:\n        if (!hasModifierKey(event)) {\n          keyCode === HOME\n            ? manager.setFirstItemActive()\n            : manager.setLastItemActive();\n          event.preventDefault();\n        }\n        break;\n      default:\n        manager.onKeydown(event);\n    }\n  }\n\n  /**\n   * Focus the first item in the menu.\n   */\n  focusFirstItem(): void {\n    // When the content is rendered lazily, it takes a bit before the items are inside the DOM.\n    if (this.lazyContent) {\n      this._ngZone.onStable\n        .asObservable()\n        .pipe(take(1))\n        .subscribe(() =>\n          this._keyManager.setFirstItemActive()\n        );\n    } else {\n      this._keyManager.setFirstItemActive();\n    }\n  }\n\n  /**\n   * Resets the active item in the menu. This is used when the menu is opened, allowing\n   * the user to start from the first option when pressing the down arrow.\n   */\n  resetActiveItem() {\n    this._keyManager.setActiveItem(-1);\n  }\n\n  /**\n   * Registers a menu item with the context menu.\n   * @docs-private\n   */\n  addItem(item: NxContextMenuItemComponent) {\n    // We register the items through this method, rather than picking them up through\n    // `ContentChildren`, because we need the items to be picked up by their closest\n    // `nx-context-menu` ancestor. If we used `@ContentChildren(NxContextMenuItem, {descendants: true})`,\n    // all descendant items will bleed into the top-level menu in the case where the consumer\n    // has `nx-context-menu` instances nested inside each other.\n    if (this._items.indexOf(item) === -1) {\n      this._items.push(item);\n      this._itemChanges.next(this._items);\n    }\n  }\n\n  /**\n   * Removes an item from the context menu.\n   * @docs-private\n   */\n  removeItem(item: NxContextMenuItemComponent) {\n    const index = this._items.indexOf(item);\n\n    if (this._items.indexOf(item) > -1) {\n      this._items.splice(index, 1);\n      this._itemChanges.next(this._items);\n    }\n  }\n\n  /** Starts the enter animation. */\n  _startAnimation() {\n    this._panelAnimationState = 'enter';\n  }\n\n  /** Resets the panel animation to its initial state. */\n  _resetAnimation() {\n    this._panelAnimationState = 'void';\n  }\n\n  /** Callback that is invoked when the panel animation completes. */\n  _onAnimationDone(event: AnimationEvent) {\n    this._animationDone.next(event);\n    this._isAnimating = false;\n  }\n\n  _onAnimationStart(event: AnimationEvent) {\n    this._isAnimating = true;\n\n    // Scroll the content element to the top as soon as the animation starts. This is necessary,\n    // because we move focus to the first item while it's still being animated, which can throw\n    // the browser off when it determines the scroll position. Alternatively we can move focus\n    // when the animation is done, however moving focus asynchronously will interrupt screen\n    // readers which are in the process of reading out the menu already. We take the `element`\n    // from the `event` since we can't use a `ViewChild` to access the pane.\n    if (event.toState === 'enter' && this._keyManager.activeItemIndex === 0) {\n      event.element.scrollTop = 0;\n    }\n  }\n}\n","import {\n  ChangeDetectionStrategy,\n  Component,\n  ElementRef,\n  Inject,\n  Optional,\n  Input,\n  OnDestroy,\n  ChangeDetectorRef\n} from '@angular/core';\nimport { Subject } from 'rxjs';\nimport { DOCUMENT } from '@angular/common';\nimport { NxContextMenuComponent } from './context-menu.component';\nimport { coerceBooleanProperty } from '@angular/cdk/coercion';\n\n/**\n * This directive is intended to be used inside an nx-context-menu tag.\n * It exists mostly to set the role attribute, disabled state and styling.\n */\n@Component({\n  // tslint:disable-next-line:component-selector\n  selector: '[nxContextMenuItem]',\n  exportAs: 'nxContextMenuItem',\n  host: {\n    class: 'nx-context-menu-item',\n    role: 'menuitem',\n    '[class.is-highlighted]': '_highlighted',\n    '[attr.tabindex]': '_getTabIndex()',\n    '[attr.aria-disabled]': 'disabled.toString()',\n    '[attr.disabled]': 'disabled || null',\n    '(mouseenter)': '_handleMouseEnter()',\n    '(click)': '_checkDisabled($event)'\n  },\n  changeDetection: ChangeDetectionStrategy.OnPush,\n  template: `\n    <ng-content></ng-content>\n    <nx-icon *ngIf=\"_triggersSubmenu\"\n      class=\"nx-context-menu-item__expand\"\n      name=\"chevron-right-small\">\n    </nx-icon>\n    `,\n  styleUrls: ['./context-menu-item.component.scss']\n})\nexport class NxContextMenuItemComponent implements OnDestroy {\n  private _document: Document;\n\n  /** Stream that emits when the context menu item is hovered. */\n  readonly _hovered: Subject<NxContextMenuItemComponent> = new Subject<NxContextMenuItemComponent>();\n\n  /** Whether the context menu item is disabled. */\n  @Input()\n  set disabled(value: boolean) {\n    this._disabled = coerceBooleanProperty(value);\n    this._changeDetectorRef.markForCheck();\n  }\n  get disabled(): boolean {\n    return this._disabled;\n  }\n  private _disabled: boolean = false;\n\n  /** Whether the context menu item is highlighted. */\n  _highlighted: boolean = false;\n\n  /** Whether the context menu item acts as a trigger for a sub-menu. */\n  _triggersSubmenu: boolean = false;\n\n  constructor(\n    private _elementRef: ElementRef<HTMLElement>,\n    @Inject(DOCUMENT) document: any,\n    private _changeDetectorRef: ChangeDetectorRef,\n    @Inject(NxContextMenuComponent)\n    @Optional() private _parentMenu: NxContextMenuComponent\n  ) {\n\n    if (_parentMenu && _parentMenu.addItem) {\n      _parentMenu.addItem(this);\n    }\n\n    this._document = document;\n  }\n\n  /** Focuses this context menu item. */\n  focus(): void {\n    this._getHostElement().focus();\n  }\n\n  ngOnDestroy() {\n    if (this._parentMenu && this._parentMenu.removeItem) {\n      this._parentMenu.removeItem(this);\n    }\n\n    this._hovered.complete();\n  }\n\n  /** Used to set the `tabindex`. */\n  _getTabIndex(): string {\n    return this.disabled ? '-1' : '0';\n  }\n\n  /** Returns the host DOM element. */\n  _getHostElement(): HTMLElement {\n    return this._elementRef.nativeElement;\n  }\n\n  /** Prevents the default element actions if it is disabled. */\n  _checkDisabled(event: Event): void {\n    if (this.disabled) {\n      event.preventDefault();\n      event.stopPropagation();\n    }\n  }\n\n  /** Emits to the hover stream. */\n  _handleMouseEnter() {\n    this._hovered.next(this);\n  }\n\n  /** Gets the label to be used when determining whether the option should be focused. */\n  getLabel(): string {\n    const element: HTMLElement = this._elementRef.nativeElement;\n    const textNodeType = this._document ? this._document.TEXT_NODE : 3;\n    let output = '';\n\n    if (element.childNodes) {\n      const length = element.childNodes.length;\n\n      // Go through all the top-level text nodes and extract their text.\n      // We skip anything that's not a text node to prevent the text from\n      // being thrown off by something like an icon.\n      for (let i = 0; i < length; i++) {\n        if (element.childNodes[i].nodeType === textNodeType) {\n          output += element.childNodes[i].textContent;\n        }\n      }\n    }\n\n    return output.trim();\n  }\n}\n","import { Direction, Directionality } from '@angular/cdk/bidi';\nimport { LEFT_ARROW, RIGHT_ARROW } from '@angular/cdk/keycodes';\nimport {\n  FlexibleConnectedPositionStrategy,\n  Overlay,\n  OverlayConfig,\n  OverlayRef,\n  ScrollStrategy,\n  ConnectedPosition\n} from '@angular/cdk/overlay';\nimport { TemplatePortal } from '@angular/cdk/portal';\nimport {\n  AfterContentInit,\n  Directive,\n  ElementRef,\n  EventEmitter,\n  Input,\n  OnDestroy,\n  Optional,\n  Output,\n  Self,\n  ViewContainerRef\n} from '@angular/core';\nimport { normalizePassiveListenerOptions } from '@angular/cdk/platform';\nimport { asapScheduler, merge, of as observableOf, Subscription, fromEvent, Observable } from 'rxjs';\nimport { delay, filter, take, takeUntil, map } from 'rxjs/operators';\nimport { NxContextMenuComponent } from './context-menu.component';\nimport { throwNxContextMenuMissingError } from './context-menu-errors';\nimport { NxContextMenuItemComponent } from './context-menu-item.component';\n\n/** Default top padding of the menu panel. */\nexport const MENU_PANEL_TOP_PADDING = 16;\n\nexport const MENU_PANEL_OFFSET = 8;\n\nexport type NxContextMenuScrollStrategy = 'close' | 'reposition';\n\n/** Options for binding a passive event listener. */\nconst passiveEventListenerOptions = normalizePassiveListenerOptions({\n  passive: true\n});\n\n/**\n * This directive is intended to be used in conjunction with an nx-context-menu tag.\n * It is responsible for toggling the display of the provided context menu instance.\n */\n@Directive({\n  selector: `[nxContextMenuTriggerFor]`,\n  host: {\n    'aria-haspopup': 'true',\n    '[attr.aria-expanded]': 'contextMenuOpen || null',\n    '(mousedown)': '_handleMousedown($event)',\n    '(keydown)': '_handleKeydown($event)',\n    '(click)': '_handleClick($event)'\n  },\n  exportAs: 'nxContextMenuTrigger'\n})\nexport class NxContextMenuTriggerDirective\n  implements AfterContentInit, OnDestroy {\n  private _portal: TemplatePortal;\n  private _overlayRef: OverlayRef | null = null;\n  private _contextMenuOpen: boolean = false;\n  private _closingActionsSubscription = Subscription.EMPTY;\n  private _hoverSubscription = Subscription.EMPTY;\n  private _contextMenuCloseSubscription = Subscription.EMPTY;\n  private _documentClickObservable: Observable<MouseEvent>;\n  private _scrollStrategy: () => ScrollStrategy;\n\n  /** References the context menu instance that the trigger is associated with. */\n  @Input('nxContextMenuTriggerFor')\n  get contextMenu() {\n    return this._contextMenu;\n  }\n  set contextMenu(contextMenu: NxContextMenuComponent) {\n    if (contextMenu === this._contextMenu) {\n      return;\n    }\n\n    this._contextMenu = contextMenu;\n    this._contextMenuCloseSubscription.unsubscribe();\n\n    if (contextMenu) {\n      this._contextMenuCloseSubscription = contextMenu.closed\n        .asObservable()\n        .subscribe(reason => {\n          this._destroyMenu();\n\n          // If a click closed the menu, we should close the entire chain of nested menus.\n          if ((reason === 'click' || reason === 'tab') && this._parentMenu) {\n            this._parentMenu.closed.emit(reason);\n          }\n        });\n    }\n  }\n  private _contextMenu: NxContextMenuComponent;\n\n  @Input()\n  set scrollStrategy(value: NxContextMenuScrollStrategy) {\n    if (value === 'close') {\n      this._scrollStrategy = this._overlay.scrollStrategies.close;\n    } else {\n      this._scrollStrategy = this._overlay.scrollStrategies.reposition;\n    }\n  }\n\n  /** Whether the context menu is open. */\n  get contextMenuOpen(): boolean {\n    return this._contextMenuOpen;\n  }\n\n  /** The text direction of the containing app. */\n  private get dir(): Direction {\n    return this._dir && this._dir.value === 'rtl' ? 'rtl' : 'ltr';\n  }\n\n  /** Data to be passed along to any lazily-rendered content. */\n  @Input('nxContextMenuTriggerData') contextMenuData: any;\n\n  /** Event emitted when the associated context menu is opened. */\n  @Output() readonly contextMenuOpened: EventEmitter<void> = new EventEmitter<void>();\n\n  /** Event emitted when the associated context menu is closed. */\n  @Output() readonly contextMenuClosed: EventEmitter<void> = new EventEmitter<void>();\n\n  constructor(\n      private _overlay: Overlay,\n      private _element: ElementRef<HTMLElement>,\n      private _viewContainerRef: ViewContainerRef,\n      @Optional() private _parentMenu: NxContextMenuComponent,\n      @Optional()\n      @Self()\n      private _contextMenuItemInstance: NxContextMenuItemComponent,\n      @Optional() private _dir: Directionality) {\n\n    if (_contextMenuItemInstance) {\n      _contextMenuItemInstance._triggersSubmenu = this.triggersSubmenu();\n    }\n\n    this._scrollStrategy = this._overlay.scrollStrategies.reposition;\n    this._documentClickObservable = fromEvent<MouseEvent>(document, 'click');\n  }\n\n  ngAfterContentInit() {\n    this._checkContextMenu();\n    this._handleHover();\n  }\n\n  ngOnDestroy() {\n    if (this._overlayRef) {\n      this._overlayRef.dispose();\n      this._overlayRef = null;\n    }\n\n    this._contextMenuCloseSubscription.unsubscribe();\n    this._closingActionsSubscription.unsubscribe();\n    this._hoverSubscription.unsubscribe();\n  }\n\n  /** Whether the context menu triggers a sub-menu or a top-level one. */\n  triggersSubmenu(): boolean {\n    return !!(this._contextMenuItemInstance && this._parentMenu);\n  }\n\n  /** Toggles the context menu between the open and closed states. */\n  toggleContextMenu(): void {\n    return this.contextMenuOpen\n      ? this.closeContextMenu()\n      : this.openContextMenu();\n  }\n\n  /** Opens the context menu. */\n  openContextMenu(): void {\n    if (this.contextMenuOpen) {\n      return;\n    }\n\n    this._checkContextMenu();\n\n    const overlayRef = this._createOverlay();\n    const overlayConfig = overlayRef.getConfig();\n\n    this._setPosition(\n      overlayConfig.positionStrategy as FlexibleConnectedPositionStrategy\n    );\n    overlayRef.attach(this._getPortal());\n\n    if (this.contextMenu.lazyContent) {\n      this.contextMenu.lazyContent.attach(this.contextMenuData);\n    }\n\n    this._closingActionsSubscription = this._contextMenuClosingActions().subscribe(\n      () => this.closeContextMenu()\n    );\n    this._initContextMenu();\n\n    if (this.contextMenu instanceof NxContextMenuComponent) {\n      this.contextMenu._startAnimation();\n    }\n\n    this._waitForClose();\n  }\n\n  /** Closes the context menu. */\n  closeContextMenu(): void {\n    this.contextMenu.closed.emit();\n  }\n\n  /** Closes the context menu and does the necessary cleanup. */\n  private _destroyMenu() {\n    if (!this._overlayRef || !this.contextMenuOpen) {\n      return;\n    }\n\n    const contextMenu = this.contextMenu;\n\n    this._closingActionsSubscription.unsubscribe();\n    this._overlayRef.detach();\n\n    contextMenu._resetAnimation();\n\n    if (contextMenu.lazyContent) {\n      // Wait for the exit animation to finish before detaching the content.\n      contextMenu._animationDone\n        .pipe(\n          filter(event => event.toState === 'void'),\n          take(1),\n          // Interrupt if the content got re-attached.\n          takeUntil(contextMenu.lazyContent._attached)\n        )\n        .subscribe({\n          next: () =>\n            contextMenu.lazyContent && contextMenu.lazyContent.detach(),\n          // No matter whether the content got re-attached, reset the menu.\n          complete: () => this._resetContextMenu()\n        });\n    } else {\n      this._resetContextMenu();\n    }\n  }\n\n  /**\n   * This method sets the context menu state to open and focuses the first item if\n   * the context menu was opened via the keyboard.\n   */\n  private _initContextMenu(): void {\n    this.contextMenu.parentMenu = this.triggersSubmenu()\n      ? this._parentMenu\n      : undefined;\n    this.contextMenu.direction = this.dir;\n    this._setIsContextMenuOpen(true);\n    this.contextMenu.focusFirstItem();\n  }\n\n  /**\n   * Focuses the context menu trigger.\n   */\n  focus() {\n    this._element.nativeElement.focus();\n  }\n\n  /**\n   * This method resets the context menu when it's closed, most importantly restoring\n   * focus to the context menu trigger if the context menu was opened via the keyboard.\n   */\n  private _resetContextMenu(): void {\n    this._setIsContextMenuOpen(false);\n    this.focus();\n  }\n\n  /** Set state rather than toggle to support triggers sharing a menu. */\n  private _setIsContextMenuOpen(isOpen: boolean): void {\n    this._contextMenuOpen = isOpen;\n    this._contextMenuOpen\n      ? this.contextMenuOpened.emit()\n      : this.contextMenuClosed.emit();\n\n    if (this.triggersSubmenu()) {\n      this._contextMenuItemInstance._highlighted = isOpen;\n    }\n  }\n\n  /**\n   * This method checks that a valid instance of NxContextMenuComponent has been passed into\n   * nxContextMenuTriggerFor. If not, an exception is thrown.\n   */\n  private _checkContextMenu() {\n    if (!this.contextMenu) {\n      throwNxContextMenuMissingError();\n    }\n  }\n\n  /**\n   * This method creates the overlay from the provided menu's template and saves its\n   * OverlayRef so that it can be attached to the DOM when openContextMenu is called.\n   */\n  private _createOverlay(): OverlayRef {\n    if (!this._overlayRef) {\n      const config = this._getOverlayConfig();\n      this._overlayRef = this._overlay.create(config);\n\n      // Consume the `keydownEvents` in order to prevent them from going to another overlay.\n      this._overlayRef.keydownEvents().subscribe();\n    }\n\n    return this._overlayRef;\n  }\n\n  /**\n   * This method builds the configuration object needed to create the overlay, the OverlayState.\n   * @returns OverlayConfig\n   */\n  private _getOverlayConfig(): OverlayConfig {\n    return new OverlayConfig({\n      positionStrategy: this._overlay\n        .position()\n        .flexibleConnectedTo(this._element)\n        .withLockedPosition()\n        .withFlexibleDimensions(false)\n        .withTransformOriginOn('.nx-context-menu'),\n      scrollStrategy: this._scrollStrategy(),\n      direction: this._dir\n    });\n  }\n\n  /**\n   * Sets the appropriate positions on a position strategy\n   * so the overlay connects with the trigger correctly.\n   * @param positionStrategy Strategy whose position to update.\n   */\n  private _setPosition(positionStrategy: FlexibleConnectedPositionStrategy) {\n    let originX = 'start';\n    let originFallbackX = 'end';\n    const overlayY = 'top';\n    const overlayFallbackY = 'bottom';\n    let originY = overlayY;\n    let originFallbackY = overlayFallbackY;\n    let overlayX = originX;\n    let overlayFallbackX = originFallbackX;\n    let offsetY = 0;\n\n    if (this.triggersSubmenu()) {\n      // When the menu is a sub-menu, it should always align itself\n      // to the edges of the trigger, instead of overlapping it.\n      overlayFallbackX = originX = 'end';\n      originFallbackX = overlayX = 'start';\n      offsetY = -MENU_PANEL_TOP_PADDING;\n    } else {\n      offsetY = MENU_PANEL_OFFSET;\n      originY = 'bottom';\n      originFallbackY = 'top';\n    }\n\n    positionStrategy.withPositions([\n      { originX, originY, overlayX, overlayY, offsetY },\n      {\n        originX: originFallbackX,\n        originY,\n        overlayX: overlayFallbackX,\n        overlayY,\n        offsetY\n      },\n      {\n        originX,\n        originY: originFallbackY,\n        overlayX,\n        overlayY: overlayFallbackY,\n        offsetY: -offsetY\n      },\n      {\n        originX: originFallbackX,\n        originY: originFallbackY,\n        overlayX: overlayFallbackX,\n        overlayY: overlayFallbackY,\n        offsetY: -offsetY\n      }\n    ] as ConnectedPosition[]);\n  }\n\n  /**\n   * Returns a stream that emits whenever an action that should close the context menu occurs. */\n  private _contextMenuClosingActions() {\n    let backdrop;\n    let detachments;\n\n    if (this._overlayRef) {\n      backdrop = this._overlayRef.backdropClick();\n      detachments = this._overlayRef.detachments();\n    }\n\n    const parentClose = this._parentMenu\n      ? this._parentMenu.closed\n      : observableOf();\n\n    const hover = this._parentMenu\n      ? this._parentMenu._hovered().pipe(\n          filter(active => active !== this._contextMenuItemInstance),\n          filter(() => this._contextMenuOpen)\n        )\n      : observableOf();\n\n    return merge(backdrop, parentClose, hover, detachments);\n  }\n\n  /** Handles mouse presses on the trigger. */\n  _handleMousedown(event: MouseEvent): void {\n    // Since right or middle button clicks won't trigger the `click` event,\n    // we shouldn't consider the menu as opened by mouse in those cases.\n    // this._openedBy = event.button === 0 ? 'mouse' : null;\n\n    // Since clicking on the trigger won't close the menu if it opens a sub-menu,\n    // we should prevent focus from moving onto it via click to avoid the\n    // highlight from lingering on the menu item.\n    if (this.triggersSubmenu()) {\n      event.preventDefault();\n    }\n  }\n\n  /** Handles key presses on the trigger. */\n  _handleKeydown(event: KeyboardEvent): void {\n    const keyCode = event.keyCode;\n\n    if (\n      this.triggersSubmenu() &&\n      ((keyCode === RIGHT_ARROW && this.dir === 'ltr') ||\n        (keyCode === LEFT_ARROW && this.dir === 'rtl'))\n    ) {\n      this.openContextMenu();\n    }\n  }\n\n  /** Handles click events on the trigger. */\n  _handleClick(event: MouseEvent): void {\n    if (this.triggersSubmenu()) {\n      // Stop event propagation to avoid closing the parent menu.\n      event.stopPropagation();\n      this.openContextMenu();\n    } else {\n      this.toggleContextMenu();\n    }\n  }\n\n  /* Subscribes to document clicks to close the context menu on clicks on the background. */\n  private _waitForClose() {\n    return this._documentClickObservable\n      .pipe(\n        map(event => event.target),\n        filter((target: Node) => !this._element.nativeElement.contains(target)),\n        takeUntil(this.contextMenu.closed))\n      .subscribe(() => {\n        this.closeContextMenu();\n      });\n  }\n\n  /** Handles the cases where the user hovers over the trigger. */\n  private _handleHover() {\n    // Subscribe to changes in the hovered item in order to toggle the panel.\n    if (!this.triggersSubmenu()) {\n      return;\n    }\n\n    this._hoverSubscription = this._parentMenu\n      ._hovered()\n      // Since we might have multiple competing triggers for the same menu (e.g. a sub-menu\n      // with different data and triggers), we have to delay it by a tick to ensure that\n      // it won't be closed immediately after it is opened.\n      .pipe(\n        filter(active => active === this._contextMenuItemInstance && !active.disabled),\n        delay(0, asapScheduler)\n      )\n      .subscribe(() => {\n        // If the same menu is used between multiple triggers, it might still be animating\n        // while the new trigger tries to re-open it. Wait for the animation to finish\n        // before doing so. Also interrupt if the user moves to another item.\n        if (this.contextMenu._isAnimating) {\n          // We need the `delay(0)` here in order to avoid\n          // 'changed after checked' errors in some cases.\n          this.contextMenu._animationDone\n            .pipe(\n              take(1),\n              delay(0, asapScheduler),\n              takeUntil(this._parentMenu._hovered())\n            )\n            .subscribe(() => this.openContextMenu());\n        } else {\n          this.openContextMenu();\n        }\n      });\n  }\n\n  /** Gets the portal that should be attached to the overlay. */\n  private _getPortal(): TemplatePortal {\n    // Note that we can avoid this check by keeping the portal on the context menu panel.\n    // While it would be cleaner, we'd have to introduce another required method on\n    // `NxContextMenuPanelComponent`, making it harder to consume.\n    if (!this._portal ||\n        this._portal.templateRef !== this.contextMenu.templateRef) {\n      this._portal = new TemplatePortal(\n        this.contextMenu.templateRef,\n        this._viewContainerRef\n      );\n    }\n\n    return this._portal;\n  }\n}\n","/**\n * Throws an exception for the case when menu trigger doesn't have a valid nx-context-menu instance\n * @docs-private\n */\nexport function throwNxContextMenuMissingError() {\n  throw Error(`nxContextMenuTriggerFor: must pass in an nx-context-menu instance.\n    Example:\n      <nx-context-menu #contextMenu=\"nxContextMenu\"></nx-context-menu>\n      <button [nxContextMenuTriggerFor]=\"contextMenu\"></button>`);\n}\n","import { OverlayModule } from '@angular/cdk/overlay';\nimport { CommonModule } from '@angular/common';\nimport { NgModule } from '@angular/core';\nimport { NxContextMenuContentDirective } from './context-menu-content.directive';\nimport { NxContextMenuComponent } from './context-menu.component';\nimport { NxContextMenuItemComponent } from './context-menu-item.component';\nimport {\n  NxContextMenuTriggerDirective\n} from './context-menu-trigger.directive';\nimport { NxIconModule } from '@allianz/ngx-ndbx/icon';\n\nconst EXPORTED_MODULES = [\n  NxContextMenuComponent,\n  NxContextMenuContentDirective,\n  NxContextMenuItemComponent,\n  NxContextMenuTriggerDirective\n];\n\n@NgModule({\n  imports: [\n    CommonModule,\n    OverlayModule,\n    NxIconModule\n  ],\n  exports: EXPORTED_MODULES,\n  declarations: EXPORTED_MODULES\n})\nexport class NxContextMenuModule { }\n"]}