(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@angular/common'), require('@angular/core'), require('@allianz/ngx-ndbx/formfield'), require('@angular/cdk/coercion'), require('@angular/cdk/platform'), require('@angular/forms'), require('rxjs'), require('@angular/cdk/text-field'), require('@allianz/ngx-ndbx/utils'), require('@angular/cdk/keycodes'), require('@allianz/ngx-ndbx/icon')) :
    typeof define === 'function' && define.amd ? define('@allianz/ngx-ndbx/input', ['exports', '@angular/common', '@angular/core', '@allianz/ngx-ndbx/formfield', '@angular/cdk/coercion', '@angular/cdk/platform', '@angular/forms', 'rxjs', '@angular/cdk/text-field', '@allianz/ngx-ndbx/utils', '@angular/cdk/keycodes', '@allianz/ngx-ndbx/icon'], factory) :
    (global = global || self, factory((global.allianz = global.allianz || {}, global.allianz['ngx-ndbx'] = global.allianz['ngx-ndbx'] || {}, global.allianz['ngx-ndbx'].input = {}), global.ng.common, global.ng.core, global.allianz['ngx-ndbx'].formfield, global.ng.cdk.coercion, global.ng.cdk.platform, global.ng.forms, global.rxjs, global.ng.cdk['text-field'], global.allianz['ngx-ndbx'].utils, global.ng.cdk.keycodes, global.allianz['ngx-ndbx'].icon));
}(this, (function (exports, common, core, formfield, coercion, platform, forms, rxjs, textField, utils, keycodes, icon) { 'use strict';

    /**
     * @fileoverview added by tsickle
     * Generated from: input.directive.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /** @type {?} */
    var NX_INPUT_VALUE_ACCESSOR = new core.InjectionToken('NX_INPUT_VALUE_ACCESSOR');
    /** @type {?} */
    var INVALID_TYPES = [
        'button',
        'checkbox',
        'file',
        'hidden',
        'image',
        'radio',
        'range',
        'reset',
        'submit'
    ];
    var ɵ0 = /**
     * @param {?} t
     * @return {?}
     */
    function (t) { return platform.getSupportedInputTypes().has(t); };
    /** @type {?} */
    var NEVER_EMPTY = [
        'date',
        'datetime',
        'datetime-local',
        'month',
        'time',
        'week'
    ].filter((ɵ0));
    /** @type {?} */
    var nextUniqueId = 0;
    var NxInputDirective = /** @class */ (function () {
        function NxInputDirective(_elementRef, _platform, ngControl, _parentForm, _parentFormGroup, _errorStateMatcher, inputValueAccessor, _autofillMonitor) {
            this._elementRef = _elementRef;
            this._platform = _platform;
            this.ngControl = ngControl;
            this._parentForm = _parentForm;
            this._parentFormGroup = _parentFormGroup;
            this._errorStateMatcher = _errorStateMatcher;
            this._autofillMonitor = _autofillMonitor;
            this._type = 'text';
            this._uid = "nx-input-" + nextUniqueId++;
            this._disabled = false;
            this._required = false;
            this._readonly = false;
            /**
             * \@docs-private
             */
            this.errorState = false;
            /**
             * Name of this control that is used inside the formfield component
             * \@docs-private
             */
            this.controlType = 'nx-input';
            /**
             * \@docs-private
             */
            this.autofilled = false;
            /**
             * \@docs-private
             */
            this.stateChanges = new rxjs.Subject();
            /**
             * \@docs-private
             */
            this.focused = false;
            this.id = this.id;
            // This will enable other directives to plugin itself as the value accessor
            // by using the NX_INPUT_VALUE_ACCESSOR Token. Default is the given input field.
            // TODO eliminate injected dateValueAccessor once we have intra-package support in ng-packagr
            // See the datefield for details.
            this._inputValueAccessor = inputValueAccessor || this._elementRef.nativeElement;
            this._previousNativeValue = this.value;
            if (this._elementRef.nativeElement.nodeName.toLowerCase() === 'textarea') {
                this.controlType = 'textarea';
            }
        }
        Object.defineProperty(NxInputDirective.prototype, "id", {
            /** The id of the input. */
            get: /**
             * The id of the input.
             * @return {?}
             */
            function () {
                return this._id;
            },
            set: /**
             * @param {?} value
             * @return {?}
             */
            function (value) {
                this._id = value || this._uid;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NxInputDirective.prototype, "value", {
            /** The input element's value. */
            get: /**
             * The input element's value.
             * @return {?}
             */
            function () { return this._inputValueAccessor.value; },
            set: /**
             * @param {?} value
             * @return {?}
             */
            function (value) {
                if (value !== this.value) {
                    this._inputValueAccessor.value = value;
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NxInputDirective.prototype, "readonly", {
            /** Whether the element is readonly. */
            get: /**
             * Whether the element is readonly.
             * @return {?}
             */
            function () { return this._readonly; },
            set: /**
             * @param {?} value
             * @return {?}
             */
            function (value) {
                this._readonly = coercion.coerceBooleanProperty(value);
                this.stateChanges.next();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NxInputDirective.prototype, "disabled", {
            /** Whether the input is disabled. */
            get: /**
             * Whether the input is disabled.
             * @return {?}
             */
            function () {
                if (this.ngControl && this.ngControl.disabled !== null) {
                    return this.ngControl.disabled;
                }
                return this._disabled;
            },
            set: /**
             * @param {?} value
             * @return {?}
             */
            function (value) {
                this._disabled = coercion.coerceBooleanProperty(value);
                // Browsers may not fire the blur event if the input is disabled too quickly.
                // Reset from here to ensure that the element doesn't become stuck.
                if (this.focused) {
                    this.focused = false;
                    this.stateChanges.next();
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NxInputDirective.prototype, "required", {
            /** Whether the element is required. */
            get: /**
             * Whether the element is required.
             * @return {?}
             */
            function () { return this._required; },
            set: /**
             * @param {?} value
             * @return {?}
             */
            function (value) { this._required = coercion.coerceBooleanProperty(value); },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NxInputDirective.prototype, "type", {
            /** Sets the type of the input element (e.g. password, text etc). */
            get: /**
             * Sets the type of the input element (e.g. password, text etc).
             * @return {?}
             */
            function () { return this._type; },
            set: /**
             * @param {?} value
             * @return {?}
             */
            function (value) {
                this._type = value || 'text';
                this._validateType();
                // When using Angular inputs, developers are no longer able to set the properties on the native
                // input element. To ensure that bindings for `type` work, we need to sync the setter
                // with the native property. Textarea elements don't support the type property or attribute.
                if (!this._isTextarea() && platform.getSupportedInputTypes().has(this._type)) {
                    this._elementRef.nativeElement.type = this._type;
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NxInputDirective.prototype, "placeholder", {
            /**
             * Sets the text for the input placeholder
             */
            get: /**
             * Sets the text for the input placeholder
             * @return {?}
             */
            function () {
                return this.empty ? this._placeholder : '';
            },
            set: /**
             * @param {?} value
             * @return {?}
             */
            function (value) {
                this._placeholder = value;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        NxInputDirective.prototype.ngOnInit = /**
         * @return {?}
         */
        function () {
            var _this = this;
            if (this._platform.isBrowser) {
                this._autofillMonitor.monitor(this._elementRef.nativeElement).subscribe((/**
                 * @param {?} event
                 * @return {?}
                 */
                function (event) {
                    _this.autofilled = event.isAutofilled;
                    _this.stateChanges.next();
                }));
            }
        };
        Object.defineProperty(NxInputDirective.prototype, "elementRef", {
            /** @docs-private */
            get: /**
             * \@docs-private
             * @return {?}
             */
            function () {
                return this._elementRef;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        NxInputDirective.prototype._onInput = /**
         * @return {?}
         */
        function () {
            // force to to run change detection so we know about changes in the native form input
        };
        /**
         * @param {?} isFocused
         * @return {?}
         */
        NxInputDirective.prototype._focusChanged = /**
         * @param {?} isFocused
         * @return {?}
         */
        function (isFocused) {
            if (isFocused !== this.focused && !this.readonly) {
                this.focused = isFocused;
                this.stateChanges.next();
            }
        };
        /**
         * @return {?}
         */
        NxInputDirective.prototype.ngOnChanges = /**
         * @return {?}
         */
        function () {
            this.stateChanges.next();
        };
        /**
         * @return {?}
         */
        NxInputDirective.prototype.ngOnDestroy = /**
         * @return {?}
         */
        function () {
            this.stateChanges.complete();
            if (this._platform.isBrowser) {
                this._autofillMonitor.stopMonitoring(this._elementRef.nativeElement);
            }
        };
        /**
         * @return {?}
         */
        NxInputDirective.prototype.ngDoCheck = /**
         * @return {?}
         */
        function () {
            if (this.ngControl) {
                // We need to re-evaluate this on every change detection cycle, because there are some
                // error triggers that we can't subscribe to (e.g. parent form submissions). This means
                // that whatever logic is in here has to be super lean or we risk destroying the performance.
                this.updateErrorState();
            }
            // We need to dirty-check the native element's value, because there are some cases where
            // we won't be notified when it changes (e.g. the consumer isn't using forms or they're
            // updating the value using `emitEvent: false`).
            this._dirtyCheckNativeValue();
        };
        /** @docs-private */
        /**
         * \@docs-private
         * @return {?}
         */
        NxInputDirective.prototype.updateErrorState = /**
         * \@docs-private
         * @return {?}
         */
        function () {
            /** @type {?} */
            var oldState = this.errorState;
            /** @type {?} */
            var parent = this._parentFormGroup || this._parentForm;
            /** @type {?} */
            var control = this.ngControl ? (/** @type {?} */ (this.ngControl.control)) : null;
            /** @type {?} */
            var newState = this._errorStateMatcher.isErrorState(control, parent);
            if (newState !== oldState) {
                this.errorState = newState;
                this.stateChanges.next();
            }
        };
        /**
         * Set a list of ids that is currently describing this input
         * (if you have hints and errors for example).
         */
        /**
         * Set a list of ids that is currently describing this input
         * (if you have hints and errors for example).
         * @param {?} ids
         * @return {?}
         */
        NxInputDirective.prototype.setDescribedByIds = /**
         * Set a list of ids that is currently describing this input
         * (if you have hints and errors for example).
         * @param {?} ids
         * @return {?}
         */
        function (ids) {
            this._ariaDescribedby = ids.join(' ');
        };
        // allow to set a arial label value in case there
        // is not possibility to display a proper label
        /**
         * Method to set the aria label.
         * This is required if you use the input outside of a formfield
         * where you don't have a label connected.
         */
        // allow to set a arial label value in case there
        // is not possibility to display a proper label
        /**
         * Method to set the aria label.
         * This is required if you use the input outside of a formfield
         * where you don't have a label connected.
         * @param {?} value
         * @return {?}
         */
        NxInputDirective.prototype.setAriaLabel = 
        // allow to set a arial label value in case there
        // is not possibility to display a proper label
        /**
         * Method to set the aria label.
         * This is required if you use the input outside of a formfield
         * where you don't have a label connected.
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this._ariaLabel = value;
        };
        /**
         * @protected
         * @return {?}
         */
        NxInputDirective.prototype._isBadInput = /**
         * @protected
         * @return {?}
         */
        function () {
            // The `validity` property won't be present on platform-server.
            /** @type {?} */
            var validity = ((/** @type {?} */ (this._elementRef.nativeElement))).validity;
            return validity && validity.badInput;
        };
        Object.defineProperty(NxInputDirective.prototype, "empty", {
            /** @docs-private */
            get: /**
             * \@docs-private
             * @return {?}
             */
            function () {
                return !this._isNeverEmpty() && !this._elementRef.nativeElement.value && !this._isBadInput() && !this.autofilled;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @protected
         * @return {?}
         */
        NxInputDirective.prototype._isNeverEmpty = /**
         * @protected
         * @return {?}
         */
        function () {
            return NEVER_EMPTY.indexOf(this._type) > -1;
        };
        /**
         * @protected
         * @return {?}
         */
        NxInputDirective.prototype._isTextarea = /**
         * @protected
         * @return {?}
         */
        function () {
            /** @type {?} */
            var nativeElement = this._elementRef.nativeElement;
            return nativeElement.nodeName ? nativeElement.nodeName.toLowerCase() === 'textarea' : false;
        };
        /**
         * @protected
         * @return {?}
         */
        NxInputDirective.prototype._validateType = /**
         * @protected
         * @return {?}
         */
        function () {
            if (INVALID_TYPES.indexOf(this._type) > -1) {
                throw new Error("Input of type '" + this._type + "' is not supported");
            }
        };
        Object.defineProperty(NxInputDirective.prototype, "shouldLabelFloat", {
            /** @docs-private */
            get: /**
             * \@docs-private
             * @return {?}
             */
            function () {
                return this.focused || !this.empty || (this.placeholder && this.placeholder.length > 0);
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @protected
         * @return {?}
         */
        NxInputDirective.prototype._dirtyCheckNativeValue = /**
         * @protected
         * @return {?}
         */
        function () {
            /** @type {?} */
            var newValue = this.value;
            if (this._previousNativeValue !== newValue) {
                this._previousNativeValue = newValue;
                this.stateChanges.next();
            }
        };
        NxInputDirective.decorators = [
            { type: core.Directive, args: [{
                        selector: 'input[nxInput], textarea[nxInput], select[nxInput]',
                        exportAs: 'nxInput',
                        host: {
                            '[class.c-input]': 'true',
                            '[attr.id]': 'id',
                            '[class.is-filled]': 'empty === false',
                            '[class.is-disabled]': 'disabled',
                            '[class.has-error]': 'errorState',
                            '[class.is-focused]': 'focused',
                            '[attr.disabled]': 'disabled || null',
                            '[attr.readonly]': 'readonly || null',
                            '[attr.required]': 'required || null',
                            '[attr.aria-label]': '_ariaLabel || null',
                            '[attr.aria-describedby]': '_ariaDescribedby || null',
                            '[attr.aria-invalid]': 'errorState',
                            '[attr.aria-required]': 'required.toString()',
                            '[attr.placeholder]': 'placeholder || null',
                            '(blur)': '_focusChanged(false)',
                            '(focus)': '_focusChanged(true)',
                            '(input)': '_onInput()',
                        },
                        providers: [{ provide: formfield.NxFormfieldControl, useExisting: NxInputDirective }],
                    },] }
        ];
        /** @nocollapse */
        NxInputDirective.ctorParameters = function () { return [
            { type: core.ElementRef },
            { type: platform.Platform },
            { type: forms.NgControl, decorators: [{ type: core.Optional }, { type: core.Self }] },
            { type: forms.NgForm, decorators: [{ type: core.Optional }] },
            { type: forms.FormGroupDirective, decorators: [{ type: core.Optional }] },
            { type: utils.ErrorStateMatcher },
            { type: undefined, decorators: [{ type: core.Optional }, { type: core.Self }, { type: core.Inject, args: [NX_INPUT_VALUE_ACCESSOR,] }] },
            { type: textField.AutofillMonitor }
        ]; };
        NxInputDirective.propDecorators = {
            _ariaLabel: [{ type: core.Input, args: ['nxAriaLabel',] }],
            id: [{ type: core.Input }],
            value: [{ type: core.Input }],
            readonly: [{ type: core.Input }],
            disabled: [{ type: core.Input }],
            required: [{ type: core.Input }],
            type: [{ type: core.Input }],
            placeholder: [{ type: core.Input }]
        };
        return NxInputDirective;
    }());
    if (false) {
        /**
         * @type {?}
         * @protected
         */
        NxInputDirective.prototype._type;
        /**
         * @type {?}
         * @protected
         */
        NxInputDirective.prototype._id;
        /**
         * @type {?}
         * @protected
         */
        NxInputDirective.prototype._uid;
        /**
         * @type {?}
         * @protected
         */
        NxInputDirective.prototype._previousNativeValue;
        /**
         * @type {?}
         * @protected
         */
        NxInputDirective.prototype._disabled;
        /**
         * @type {?}
         * @protected
         */
        NxInputDirective.prototype._required;
        /**
         * @type {?}
         * @private
         */
        NxInputDirective.prototype._readonly;
        /**
         * @type {?}
         * @private
         */
        NxInputDirective.prototype._inputValueAccessor;
        /** @type {?} */
        NxInputDirective.prototype._ariaDescribedby;
        /**
         * @type {?}
         * @private
         */
        NxInputDirective.prototype._placeholder;
        /** @type {?} */
        NxInputDirective.prototype._ariaLabel;
        /**
         * \@docs-private
         * @type {?}
         */
        NxInputDirective.prototype.errorState;
        /**
         * Name of this control that is used inside the formfield component
         * \@docs-private
         * @type {?}
         */
        NxInputDirective.prototype.controlType;
        /**
         * \@docs-private
         * @type {?}
         */
        NxInputDirective.prototype.autofilled;
        /**
         * \@docs-private
         * @type {?}
         */
        NxInputDirective.prototype.stateChanges;
        /**
         * \@docs-private
         * @type {?}
         */
        NxInputDirective.prototype.focused;
        /**
         * @type {?}
         * @protected
         */
        NxInputDirective.prototype._elementRef;
        /**
         * @type {?}
         * @protected
         */
        NxInputDirective.prototype._platform;
        /**
         * \@docs-private
         * @type {?}
         */
        NxInputDirective.prototype.ngControl;
        /**
         * @type {?}
         * @private
         */
        NxInputDirective.prototype._parentForm;
        /**
         * @type {?}
         * @private
         */
        NxInputDirective.prototype._parentFormGroup;
        /**
         * @type {?}
         * @private
         */
        NxInputDirective.prototype._errorStateMatcher;
        /**
         * @type {?}
         * @private
         */
        NxInputDirective.prototype._autofillMonitor;
    }

    /**
     * @fileoverview added by tsickle
     * Generated from: password-toggle.component.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /** @type {?} */
    var visibilityIcons = {
        show: 'password-show-o',
        hide: 'password-hide-o'
    };
    var NxPasswordToggleComponent = /** @class */ (function () {
        function NxPasswordToggleComponent(_changeDetectorRef) {
            this._changeDetectorRef = _changeDetectorRef;
            /**
             * \@docs-private
             */
            this._currentIcon = visibilityIcons['show'];
            /**
             * \@docs-private
             */
            this._pressed = false;
            this._ariaLabel = 'Show password';
        }
        Object.defineProperty(NxPasswordToggleComponent.prototype, "ariaLabel", {
            get: /**
             * @return {?}
             */
            function () {
                return this._ariaLabel;
            },
            /** Sets the aria-label needed for accessibility.
             * Notice that this `aria-label` should describe the initial action according to the status of the visibility.
             * E.g if you have an `input[type=password]` at the beginning then the
             * password will be hidden and the correct aria-label would be 'Show password.'
             */
            set: /**
             * Sets the aria-label needed for accessibility.
             * Notice that this `aria-label` should describe the initial action according to the status of the visibility.
             * E.g if you have an `input[type=password]` at the beginning then the
             * password will be hidden and the correct aria-label would be 'Show password.'
             * @param {?} value
             * @return {?}
             */
            function (value) {
                if (value !== this._ariaLabel) {
                    this._ariaLabel = value;
                    this._changeDetectorRef.markForCheck();
                }
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        NxPasswordToggleComponent.prototype.ngAfterViewInit = /**
         * @return {?}
         */
        function () {
            if (!this.control) {
                console.warn('You need to pass an input as a control to the password toggle.');
            }
            else {
                // show the right icon according to the initial type of the input
                this._currentIcon = this.control.type === 'password' ? visibilityIcons['show'] : visibilityIcons['hide'];
            }
        };
        /** Toggles the type of the input. */
        /**
         * Toggles the type of the input.
         * @return {?}
         */
        NxPasswordToggleComponent.prototype.toggleInputType = /**
         * Toggles the type of the input.
         * @return {?}
         */
        function () {
            if (this.control) {
                this.control.type = this.control.type === 'password' ? 'text' : 'password';
                this._pressed = !this._pressed;
                this.toggleIcon();
                this._changeDetectorRef.markForCheck();
            }
        };
        /**@docs-private */
        /**
         * \@docs-private
         * @return {?}
         */
        NxPasswordToggleComponent.prototype.toggleIcon = /**
         * \@docs-private
         * @return {?}
         */
        function () {
            this._currentIcon = this._currentIcon === visibilityIcons['show'] ? visibilityIcons['hide'] : visibilityIcons['show'];
        };
        /**@docs-private */
        /**
         * \@docs-private
         * @param {?} $event
         * @return {?}
         */
        NxPasswordToggleComponent.prototype._onKeydown = /**
         * \@docs-private
         * @param {?} $event
         * @return {?}
         */
        function ($event) {
            if ($event && ($event.keyCode === keycodes.ENTER || $event.keyCode === keycodes.SPACE)) {
                this.toggleInputType();
            }
        };
        Object.defineProperty(NxPasswordToggleComponent.prototype, "tabindex", {
            /**@docs-private */
            get: /**
             * \@docs-private
             * @return {?}
             */
            function () {
                if (this.control) {
                    return this.control.disabled ? -1 : 0;
                }
                return null;
            },
            enumerable: true,
            configurable: true
        });
        NxPasswordToggleComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'nx-password-toggle',
                        template: "<nx-icon\n      aria-hidden=\"true\"\n      [name]=\"_currentIcon\">\n    </nx-icon>",
                        host: {
                            '[attr.aria-label]': 'ariaLabel',
                            '[attr.tabindex]': 'tabindex',
                            '[attr.aria-pressed]': '_pressed',
                            'role': 'button',
                            '(click)': 'toggleInputType()',
                            '(keydown)': '_onKeydown($event)'
                        },
                        changeDetection: core.ChangeDetectionStrategy.OnPush,
                        styles: [":host{position:relative;display:inline-block;height:24px;width:24px;cursor:pointer}:host:focus{outline:0}:host:hover{color:#006192;color:var(--hover-primary,#006192)}:host-context([data-whatinput=keyboard]):focus ::ng-deep nx-icon{box-shadow:0 0 0 2px #fff,0 0 0 6px #009de6;box-shadow:var(--focus-box-shadow,0 0 0 2px #fff,0 0 0 6px #009de6);border-radius:4px}@media screen and (-ms-high-contrast:active){:host{color:buttonText}:host-context([data-whatinput=keyboard]):focus ::ng-deep nx-icon{box-shadow:0 0 0 2px background,0 0 0 6px windowText}}:host-context(.is-disabled){pointer-events:none}"]
                    }] }
        ];
        /** @nocollapse */
        NxPasswordToggleComponent.ctorParameters = function () { return [
            { type: core.ChangeDetectorRef }
        ]; };
        NxPasswordToggleComponent.propDecorators = {
            control: [{ type: core.Input }],
            ariaLabel: [{ type: core.Input }]
        };
        return NxPasswordToggleComponent;
    }());
    if (false) {
        /**
         * Input element using the toggle functionality.
         * @type {?}
         */
        NxPasswordToggleComponent.prototype.control;
        /**
         * \@docs-private
         * @type {?}
         */
        NxPasswordToggleComponent.prototype._currentIcon;
        /**
         * \@docs-private
         * @type {?}
         */
        NxPasswordToggleComponent.prototype._pressed;
        /**
         * @type {?}
         * @private
         */
        NxPasswordToggleComponent.prototype._ariaLabel;
        /**
         * @type {?}
         * @private
         */
        NxPasswordToggleComponent.prototype._changeDetectorRef;
    }

    /**
     * @fileoverview added by tsickle
     * Generated from: input.module.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var NxInputModule = /** @class */ (function () {
        function NxInputModule() {
        }
        NxInputModule.decorators = [
            { type: core.NgModule, args: [{
                        imports: [
                            common.CommonModule,
                            formfield.NxFormfieldModule,
                            icon.NxIconModule
                        ],
                        declarations: [
                            NxInputDirective,
                            NxPasswordToggleComponent
                        ],
                        exports: [
                            formfield.NxFormfieldModule,
                            NxInputDirective,
                            NxPasswordToggleComponent
                        ]
                    },] }
        ];
        return NxInputModule;
    }());

    exports.NX_INPUT_VALUE_ACCESSOR = NX_INPUT_VALUE_ACCESSOR;
    exports.NxInputDirective = NxInputDirective;
    exports.NxInputModule = NxInputModule;
    exports.NxPasswordToggleComponent = NxPasswordToggleComponent;

    Object.defineProperty(exports, '__esModule', { value: true });

})));
//# sourceMappingURL=allianz-ngx-ndbx-input.umd.js.map
