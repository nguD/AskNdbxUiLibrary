(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@angular/common'), require('@angular/core'), require('@allianz/ngx-ndbx/icon'), require('@angular/cdk/coercion'), require('@angular/cdk/overlay'), require('@angular/cdk/portal'), require('@angular/animations'), require('rxjs'), require('rxjs/operators'), require('@angular/cdk/a11y')) :
    typeof define === 'function' && define.amd ? define('@allianz/ngx-ndbx/message', ['exports', '@angular/common', '@angular/core', '@allianz/ngx-ndbx/icon', '@angular/cdk/coercion', '@angular/cdk/overlay', '@angular/cdk/portal', '@angular/animations', 'rxjs', 'rxjs/operators', '@angular/cdk/a11y'], factory) :
    (global = global || self, factory((global.allianz = global.allianz || {}, global.allianz['ngx-ndbx'] = global.allianz['ngx-ndbx'] || {}, global.allianz['ngx-ndbx'].message = {}), global.ng.common, global.ng.core, global.allianz['ngx-ndbx'].icon, global.ng.cdk.coercion, global.ng.cdk.overlay, global.ng.cdk.portal, global.ng.animations, global.rxjs, global.rxjs.operators, global.ng.cdk.a11y));
}(this, (function (exports, common, core, icon, coercion, overlay, portal, animations, rxjs, operators, a11y) { 'use strict';

    /*! *****************************************************************************
    Copyright (c) Microsoft Corporation. All rights reserved.
    Licensed under the Apache License, Version 2.0 (the "License"); you may not use
    this file except in compliance with the License. You may obtain a copy of the
    License at http://www.apache.org/licenses/LICENSE-2.0

    THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
    WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
    MERCHANTABLITY OR NON-INFRINGEMENT.

    See the Apache Version 2.0 License for specific language governing permissions
    and limitations under the License.
    ***************************************************************************** */
    /* global Reflect, Promise */

    var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };

    function __extends(d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    }

    var __assign = function() {
        __assign = Object.assign || function __assign(t) {
            for (var s, i = 1, n = arguments.length; i < n; i++) {
                s = arguments[i];
                for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
            }
            return t;
        };
        return __assign.apply(this, arguments);
    };

    function __rest(s, e) {
        var t = {};
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
            t[p] = s[p];
        if (s != null && typeof Object.getOwnPropertySymbols === "function")
            for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
                if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                    t[p[i]] = s[p[i]];
            }
        return t;
    }

    function __decorate(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    }

    function __param(paramIndex, decorator) {
        return function (target, key) { decorator(target, key, paramIndex); }
    }

    function __metadata(metadataKey, metadataValue) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(metadataKey, metadataValue);
    }

    function __awaiter(thisArg, _arguments, P, generator) {
        return new (P || (P = Promise))(function (resolve, reject) {
            function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
            function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
            function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
            step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
    }

    function __generator(thisArg, body) {
        var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
        return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
        function verb(n) { return function (v) { return step([n, v]); }; }
        function step(op) {
            if (f) throw new TypeError("Generator is already executing.");
            while (_) try {
                if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
                if (y = 0, t) op = [op[0] & 2, t.value];
                switch (op[0]) {
                    case 0: case 1: t = op; break;
                    case 4: _.label++; return { value: op[1], done: false };
                    case 5: _.label++; y = op[1]; op = [0]; continue;
                    case 7: op = _.ops.pop(); _.trys.pop(); continue;
                    default:
                        if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                        if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                        if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                        if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                        if (t[2]) _.ops.pop();
                        _.trys.pop(); continue;
                }
                op = body.call(thisArg, _);
            } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
            if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
        }
    }

    function __exportStar(m, exports) {
        for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
    }

    function __values(o) {
        var m = typeof Symbol === "function" && o[Symbol.iterator], i = 0;
        if (m) return m.call(o);
        return {
            next: function () {
                if (o && i >= o.length) o = void 0;
                return { value: o && o[i++], done: !o };
            }
        };
    }

    function __read(o, n) {
        var m = typeof Symbol === "function" && o[Symbol.iterator];
        if (!m) return o;
        var i = m.call(o), r, ar = [], e;
        try {
            while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
        }
        catch (error) { e = { error: error }; }
        finally {
            try {
                if (r && !r.done && (m = i["return"])) m.call(i);
            }
            finally { if (e) throw e.error; }
        }
        return ar;
    }

    function __spread() {
        for (var ar = [], i = 0; i < arguments.length; i++)
            ar = ar.concat(__read(arguments[i]));
        return ar;
    }

    function __spreadArrays() {
        for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
        for (var r = Array(s), k = 0, i = 0; i < il; i++)
            for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
                r[k] = a[j];
        return r;
    };

    function __await(v) {
        return this instanceof __await ? (this.v = v, this) : new __await(v);
    }

    function __asyncGenerator(thisArg, _arguments, generator) {
        if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
        var g = generator.apply(thisArg, _arguments || []), i, q = [];
        return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i;
        function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }
        function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }
        function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }
        function fulfill(value) { resume("next", value); }
        function reject(value) { resume("throw", value); }
        function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }
    }

    function __asyncDelegator(o) {
        var i, p;
        return i = {}, verb("next"), verb("throw", function (e) { throw e; }), verb("return"), i[Symbol.iterator] = function () { return this; }, i;
        function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === "return" } : f ? f(v) : v; } : f; }
    }

    function __asyncValues(o) {
        if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
        var m = o[Symbol.asyncIterator], i;
        return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);
        function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }
        function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }
    }

    function __makeTemplateObject(cooked, raw) {
        if (Object.defineProperty) { Object.defineProperty(cooked, "raw", { value: raw }); } else { cooked.raw = raw; }
        return cooked;
    };

    function __importStar(mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
        result.default = mod;
        return result;
    }

    function __importDefault(mod) {
        return (mod && mod.__esModule) ? mod : { default: mod };
    }

    /**
     * @fileoverview added by tsickle
     * Generated from: message/message.component.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /** @type {?} */
    var ICONS = {
        info: 'info-circle',
        error: 'exclamation-triangle',
        success: 'check-circle',
        warning: 'exclamation-circle'
    };
    var NxMessageComponent = /** @class */ (function () {
        function NxMessageComponent(_changeDetectorRef) {
            this._changeDetectorRef = _changeDetectorRef;
            this._context = 'regular';
            this._showIcon = false;
            this._closable = false;
            this._closeButtonLabel = 'Close dialog';
            /**
             * Event emitted when the close icon of the message has been clicked.
             */
            this.closeEvent = new core.EventEmitter();
        }
        Object.defineProperty(NxMessageComponent.prototype, "context", {
            get: /**
             * @return {?}
             */
            function () {
                return this._context;
            },
            /**
             * Sets the context of the message.
             * The message box will color accordingly. Default: 'regular' */
            set: /**
             * Sets the context of the message.
             * The message box will color accordingly. Default: 'regular'
             * @param {?} value
             * @return {?}
             */
            function (value) {
                if (value !== this._context) {
                    this._context = value;
                    this._icon = this.getIconName();
                    this._changeDetectorRef.markForCheck();
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NxMessageComponent.prototype, "showIcon", {
            get: /**
             * @return {?}
             */
            function () {
                return this._showIcon;
            },
            /**
             * Whether an icon that belongs to the context of the message should be displayed.
             *
             * **Important:** The `showIcon` attribute should always be set to `true` due to deprecation.
             *
             * @deprecated The `showIcon` attribute should be always true in future. Messages without an icon are deprecated.
             * @deletion-target 9.0.0
             * */
            set: /**
             * Whether an icon that belongs to the context of the message should be displayed.
             *
             * **Important:** The `showIcon` attribute should always be set to `true` due to deprecation.
             *
             * @deprecated The `showIcon` attribute should be always true in future. Messages without an icon are deprecated.
             * \@deletion-target 9.0.0
             *
             * @param {?} value
             * @return {?}
             */
            function (value) {
                this._showIcon = coercion.coerceBooleanProperty(value);
                this._changeDetectorRef.markForCheck();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NxMessageComponent.prototype, "closable", {
            get: /**
             * @return {?}
             */
            function () {
                return this._closable;
            },
            /** Whether a message should have a close icon in order to be dismissed. */
            set: /**
             * Whether a message should have a close icon in order to be dismissed.
             * @param {?} value
             * @return {?}
             */
            function (value) {
                /** @type {?} */
                var newValue = coercion.coerceBooleanProperty(value);
                if (newValue !== this._closable) {
                    this._closable = newValue;
                    this._changeDetectorRef.markForCheck();
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NxMessageComponent.prototype, "icon", {
            /** @docs-private */
            get: /**
             * \@docs-private
             * @return {?}
             */
            function () {
                return this._icon;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NxMessageComponent.prototype, "closeButtonLabel", {
            get: /**
             * @return {?}
             */
            function () {
                return this._closeButtonLabel;
            },
            /** Sets the label of the close button of the message. */
            set: /**
             * Sets the label of the close button of the message.
             * @param {?} value
             * @return {?}
             */
            function (value) {
                if (value !== this._closeButtonLabel) {
                    this._closeButtonLabel = value;
                    this._changeDetectorRef.markForCheck();
                }
            },
            enumerable: true,
            configurable: true
        });
        /** @docs-private */
        /**
         * \@docs-private
         * @return {?}
         */
        NxMessageComponent.prototype._emitCloseEvent = /**
         * \@docs-private
         * @return {?}
         */
        function () {
            this.closeEvent.emit();
        };
        /** @docs-private */
        /**
         * \@docs-private
         * @return {?}
         */
        NxMessageComponent.prototype.getIconName = /**
         * \@docs-private
         * @return {?}
         */
        function () {
            if (this._context === 'info') {
                return ICONS.info;
            }
            else if (this._context === 'error') {
                return ICONS.error;
            }
            else if (this._context === 'success') {
                return ICONS.success;
            }
            else if (this._context === 'warning') {
                return ICONS.warning;
            }
            return '';
        };
        NxMessageComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'nx-message',
                        template: "<nx-icon *ngIf=\"showIcon && context !== 'regular'\"\n         class=\"nx-message__icon\"\n         [name]=\"icon\"\n         size=\"s\">\n</nx-icon>\n<button\n  *ngIf=\"closable\"\n  (click)=\"_emitCloseEvent()\"\n  [attr.aria-label]=\"closeButtonLabel\"\n  tabindex=\"0\"\n  class=\"nx-message__close-icon\">\n    <nx-icon\n      name=\"close\"\n      size=\"s\"\n      aria-hidden=\"true\">\n    </nx-icon>\n</button>\n\n\n<div class=\"nx-message__content-wrapper\">\n  <div class=\"nx-message__content\">\n    <ng-content></ng-content>\n  </div>\n</div>\n",
                        changeDetection: core.ChangeDetectionStrategy.OnPush,
                        exportAs: 'nxMessage',
                        host: {
                            '[class.context-info]': 'context === "info"',
                            '[class.context-error]': 'context === "error"',
                            '[class.context-success]': 'context === "success"',
                            '[class.context-warning]': 'context === "warning"',
                            '[class.nx-message--closable]': 'closable'
                        },
                        styles: [":host{font-size:16px;font-size:var(--message-font-size,16px);line-height:24px;line-height:var(--message-line-height,24px);font-weight:400;font-weight:var(--message-font-weight,400);letter-spacing:0;letter-spacing:var(--message-letter-spacing,0);color:#414141;color:var(--message-text-color,#414141);border-radius:4px;border-radius:var(--message-border-radius,4px);width:100%;display:flex;align-items:flex-start;text-align:left;position:relative;border:1px solid;padding:23px;margin:12px 0}.nx-message__content-wrapper{max-width:100%}:host,:host(.context-regular){border-color:#414141;border-color:var(--message-regular-border-color,#414141);background-color:#fff;background-color:var(--message-regular-background-color,#fff)}:host(.context-info){border-color:#496ebd;border-color:var(--message-info-border-color,#496ebd);background-color:#ecf0f8;background-color:var(--message-info-background-color,#ecf0f8)}:host(.context-info) .nx-message__icon{color:#496ebd;color:var(--message-info-icon-color,#496ebd)}:host(.context-error){border-color:#dc3149;border-color:var(--message-error-border-color,#dc3149);background-color:#fbeaec;background-color:var(--message-error-background-color,#fbeaec)}:host(.context-error) .nx-message__icon{color:#dc3149;color:var(--message-error-icon-color,#dc3149)}:host(.context-success){border-color:#1e8927;border-color:var(--message-success-border-color,#1e8927);background-color:#e8f3e9;background-color:var(--message-success-background-color,#e8f3e9)}:host(.context-success) .nx-message__icon{color:#1e8927;color:var(--message-success-icon-color,#1e8927)}:host(.context-warning){border-color:#efbe25;border-color:var(--message-warning-border-color,#efbe25);background-color:#fdf8e9;background-color:var(--message-warning-background-color,#fdf8e9)}:host(.context-warning) .nx-message__icon{color:#efbe25;color:var(--message-warning-icon-color,#efbe25)}.nx-message__icon{margin-right:16px}@media (max-width:703px){:host{padding:31px;display:block}:host(.context-error) .nx-message__icon~.nx-message__content-wrapper .nx-message__content,:host(.context-info) .nx-message__icon~.nx-message__content-wrapper .nx-message__content,:host(.context-success) .nx-message__icon~.nx-message__content-wrapper .nx-message__content,:host(.context-warning) .nx-message__icon~.nx-message__content-wrapper .nx-message__content{display:inline;margin-left:31px}.nx-message__icon{position:absolute}}:host(.nx-message--closable){padding-right:39px}@media (max-width:703px){:host(.nx-message--closable){padding-right:31px}}.nx-message__close-icon{position:absolute;top:16px;right:16px;cursor:pointer;background-color:transparent;border:none;outline:0;padding:0;display:flex;align-items:center}.nx-message__close-icon nx-icon{color:#414141;color:var(--message-close-icon-color,#414141);font-size:16px}:host-context([data-whatinput=keyboard]) .nx-message__close-icon:focus{box-shadow:0 0 0 2px #fff,0 0 0 6px #009de6;box-shadow:var(--focus-box-shadow,0 0 0 2px #fff,0 0 0 6px #009de6);border-radius:4px}@media screen and (-ms-high-contrast:active){:host(.context-error) .nx-message__icon,:host(.context-info) .nx-message__icon,:host(.context-success) .nx-message__icon,:host(.context-warning) .nx-message__icon{color:windowText}:host-context([data-whatinput=keyboard]) .nx-message__close-icon:focus{box-shadow:0 0 0 2px background,0 0 0 6px windowText}}"]
                    }] }
        ];
        /** @nocollapse */
        NxMessageComponent.ctorParameters = function () { return [
            { type: core.ChangeDetectorRef }
        ]; };
        NxMessageComponent.propDecorators = {
            context: [{ type: core.Input, args: ['nxContext',] }],
            showIcon: [{ type: core.Input }],
            closable: [{ type: core.Input }],
            closeButtonLabel: [{ type: core.Input }],
            closeEvent: [{ type: core.Output, args: ['close',] }]
        };
        return NxMessageComponent;
    }());
    if (false) {
        /**
         * @type {?}
         * @private
         */
        NxMessageComponent.prototype._context;
        /**
         * @type {?}
         * @private
         */
        NxMessageComponent.prototype._showIcon;
        /**
         * @type {?}
         * @private
         */
        NxMessageComponent.prototype._closable;
        /**
         * @type {?}
         * @private
         */
        NxMessageComponent.prototype._icon;
        /**
         * @type {?}
         * @private
         */
        NxMessageComponent.prototype._closeButtonLabel;
        /**
         * Event emitted when the close icon of the message has been clicked.
         * @type {?}
         */
        NxMessageComponent.prototype.closeEvent;
        /**
         * @type {?}
         * @private
         */
        NxMessageComponent.prototype._changeDetectorRef;
    }

    /**
     * @fileoverview added by tsickle
     * Generated from: message-toast/message-toast-animations.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * Animations used by the Message Toast.
     * \@docs-private
     * @type {?}
     */
    var messageToastAnimations = {
        toastState: animations.trigger('state', [
            animations.state('initial, void, hidden', animations.style({ opacity: 0, transform: 'translateY(100%)' })),
            animations.state('visible', animations.style({ opacity: 1 })),
            animations.transition('* => visible', animations.animate('300ms cubic-bezier(0, 0, 0.2, 1)', animations.style({ opacity: 1, transform: 'translateY(0)' }))),
            animations.transition('* => hidden', animations.animate('300ms cubic-bezier(0, 0, 0.2, 1)', animations.style({ opacity: 0, transform: 'translateY(200%)' }))),
        ])
    };

    /**
     * @fileoverview added by tsickle
     * Generated from: message-toast/message-toast-config.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * Configuration used when opening a message toast.
     */
    var   /**
     * Configuration used when opening a message toast.
     */
    NxMessageToastConfig = /** @class */ (function () {
        function NxMessageToastConfig() {
            /**
             * The politeness level for the LiveAnnouncer announcement.
             *
             *  Default value: 'polite'.
             */
            this.politeness = 'polite';
            /**
             * Message to be announced by the LiveAnnouncer. When opening a toast message without a custom
             * component or template, the announcement message will default to the specified message.
             *
             * Default value: ''.
             */
            this.announcementMessage = '';
            /**
             * The length of time in milliseconds to wait before automatically dismissing the message toast.
             *
             * Default value: 3000.
             */
            this.duration = 3000;
            /**
             * Context of the message toast.
             *
             * Default value: 'info'.
             */
            this.context = 'info';
        }
        return NxMessageToastConfig;
    }());
    if (false) {
        /**
         * The politeness level for the LiveAnnouncer announcement.
         *
         *  Default value: 'polite'.
         * @type {?}
         */
        NxMessageToastConfig.prototype.politeness;
        /**
         * Message to be announced by the LiveAnnouncer. When opening a toast message without a custom
         * component or template, the announcement message will default to the specified message.
         *
         * Default value: ''.
         * @type {?}
         */
        NxMessageToastConfig.prototype.announcementMessage;
        /**
         * The length of time in milliseconds to wait before automatically dismissing the message toast.
         *
         * Default value: 3000.
         * @type {?}
         */
        NxMessageToastConfig.prototype.duration;
        /**
         * Context of the message toast.
         *
         * Default value: 'info'.
         * @type {?}
         */
        NxMessageToastConfig.prototype.context;
    }
    /**
     * \@docs-private
     * Needed so that the user text data can be injected in the message toastcomponent
     */
    var   /**
     * \@docs-private
     * Needed so that the user text data can be injected in the message toastcomponent
     */
    NxMessageToastData = /** @class */ (function () {
        function NxMessageToastData(data) {
            this.data = data;
        }
        return NxMessageToastData;
    }());
    if (false) {
        /** @type {?} */
        NxMessageToastData.prototype.data;
    }

    /**
     * @fileoverview added by tsickle
     * Generated from: message-toast/message-toast.component.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /** @type {?} */
    var ICONS$1 = {
        info: 'info-circle',
        success: 'check-circle',
    };
    /**
     * Internal component that wraps user-provided message toastcontent.
     * \@docs-private
     */
    var NxMessageToastComponent = /** @class */ (function (_super) {
        __extends(NxMessageToastComponent, _super);
        function NxMessageToastComponent(_ngZone, _changeDetectorRef, config, data) {
            var _this = _super.call(this) || this;
            _this._ngZone = _ngZone;
            _this._changeDetectorRef = _changeDetectorRef;
            _this.config = config;
            _this.data = data;
            /**
             * Whether the component has been destroyed.
             */
            _this._destroyed = false;
            /**
             * Subject for notifying that the message toasthas exited from view.
             */
            _this._onExit = new rxjs.Subject();
            /**
             * Subject for notifying that the message toasthas finished entering the view.
             */
            _this._onEnter = new rxjs.Subject();
            /**
             * The state of the message toastanimations.
             */
            _this._animationState = 'void';
            _this._context = _this.config.context;
            _this._setAriaLabels();
            return _this;
        }
        /** Attach a component portal as content to this message toastcontainer. */
        /**
         * Attach a component portal as content to this message toastcontainer.
         * @template T
         * @param {?} portal
         * @return {?}
         */
        NxMessageToastComponent.prototype.attachComponentPortal = /**
         * Attach a component portal as content to this message toastcontainer.
         * @template T
         * @param {?} portal
         * @return {?}
         */
        function (portal) {
            this._assertNotAttached();
            return this._portalOutlet.attachComponentPortal(portal);
        };
        /** Attach a template portal as content to this message toastcontainer. */
        /**
         * Attach a template portal as content to this message toastcontainer.
         * @template C
         * @param {?} portal
         * @return {?}
         */
        NxMessageToastComponent.prototype.attachTemplatePortal = /**
         * Attach a template portal as content to this message toastcontainer.
         * @template C
         * @param {?} portal
         * @return {?}
         */
        function (portal) {
            this._assertNotAttached();
            return this._portalOutlet.attachTemplatePortal(portal);
        };
        /** Handle end of animations, updating the state of the notification. */
        /**
         * Handle end of animations, updating the state of the notification.
         * @param {?} event
         * @return {?}
         */
        NxMessageToastComponent.prototype.onAnimationEnd = /**
         * Handle end of animations, updating the state of the notification.
         * @param {?} event
         * @return {?}
         */
        function (event) {
            var fromState = event.fromState, toState = event.toState;
            if ((toState === 'void' && fromState !== 'void') || toState === 'hidden') {
                this._completeExit();
            }
            if (toState === 'visible') {
                // Note: we shouldn't use `this` inside the zone callback,
                // because it can cause a memory leak.
                /** @type {?} */
                var onEnter_1 = this._onEnter;
                this._ngZone.run((/**
                 * @return {?}
                 */
                function () {
                    onEnter_1.next();
                    onEnter_1.complete();
                }));
            }
        };
        /** Begin animation of message toastentrance into view. */
        /**
         * Begin animation of message toastentrance into view.
         * @return {?}
         */
        NxMessageToastComponent.prototype.enter = /**
         * Begin animation of message toastentrance into view.
         * @return {?}
         */
        function () {
            if (!this._destroyed) {
                this._animationState = 'visible';
                this._changeDetectorRef.detectChanges();
            }
        };
        /** Begin animation of the message toastexiting from view. */
        /**
         * Begin animation of the message toastexiting from view.
         * @return {?}
         */
        NxMessageToastComponent.prototype.exit = /**
         * Begin animation of the message toastexiting from view.
         * @return {?}
         */
        function () {
            // Note: this one transitions to `hidden`, rather than `void`, in order to handle the case
            // where multiple notifications are opened in quick succession (e.g. two consecutive calls to
            // `NxMessageToastService.open`).
            this._animationState = 'hidden';
        };
        /** Makes sure the exit callbacks have been invoked when the element is destroyed. */
        /**
         * Makes sure the exit callbacks have been invoked when the element is destroyed.
         * @return {?}
         */
        NxMessageToastComponent.prototype.ngOnDestroy = /**
         * Makes sure the exit callbacks have been invoked when the element is destroyed.
         * @return {?}
         */
        function () {
            this._destroyed = true;
            this._completeExit();
        };
        /**
         * Waits for the zone to settle before removing the element. Helps prevent
         * errors where we end up removing an element which is in the middle of an animation.
         */
        /**
         * Waits for the zone to settle before removing the element. Helps prevent
         * errors where we end up removing an element which is in the middle of an animation.
         * @private
         * @return {?}
         */
        NxMessageToastComponent.prototype._completeExit = /**
         * Waits for the zone to settle before removing the element. Helps prevent
         * errors where we end up removing an element which is in the middle of an animation.
         * @private
         * @return {?}
         */
        function () {
            var _this = this;
            this._ngZone.onMicrotaskEmpty.asObservable().pipe(operators.take(1)).subscribe((/**
             * @return {?}
             */
            function () {
                _this._onExit.next();
                _this._onExit.complete();
            }));
        };
        /** Asserts that no content is already attached to the container. */
        /**
         * Asserts that no content is already attached to the container.
         * @private
         * @return {?}
         */
        NxMessageToastComponent.prototype._assertNotAttached = /**
         * Asserts that no content is already attached to the container.
         * @private
         * @return {?}
         */
        function () {
            if (this._portalOutlet.hasAttached()) {
                throw Error('Attempting to attach message toastcontent after content is already attached');
            }
        };
        /**
         * @return {?}
         */
        NxMessageToastComponent.prototype._getIconName = /**
         * @return {?}
         */
        function () {
            return this._context === 'success' ? ICONS$1.success : ICONS$1.info;
        };
        /**
         * @return {?}
         */
        NxMessageToastComponent.prototype._setAriaLabels = /**
         * @return {?}
         */
        function () {
            // Based on the ARIA spec, `alert` and `status` roles have an
            // implicit `assertive` and `polite` politeness respectively.
            if (this.config.politeness === 'assertive' && !this.config.announcementMessage) {
                this._role = 'alert';
            }
            else if (this.config.politeness === 'off') {
                this._role = null;
            }
            else {
                this._role = 'status';
            }
        };
        NxMessageToastComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'nx-message-toast',
                        template: "<nx-icon class=\"nx-message__icon\" [name]=\"_getIconName()\" size=\"s\">\n</nx-icon>\n\n<div class=\"nx-message__content-wrapper\">\n    <!-- Used when opening from a template -->\n    <ng-template cdkPortalOutlet></ng-template>\n    <!-- Used when opening only with custom text-->\n    <ng-container *ngIf=\"data\">{{data.data}}</ng-container>\n</div>\n",
                        host: {
                            '[attr.role]': '_role',
                            '[class.context-info]': '_context === "info"',
                            '[class.context-success]': '_context === "success"',
                            '[@state]': '_animationState',
                            '(@state.done)': 'onAnimationEnd($event)'
                        },
                        animations: [messageToastAnimations.toastState],
                        styles: [":host{font-size:16px;font-size:var(--message-font-size,16px);line-height:24px;line-height:var(--message-line-height,24px);font-weight:400;font-weight:var(--message-font-weight,400);letter-spacing:0;letter-spacing:var(--message-letter-spacing,0);color:#414141;color:var(--message-text-color,#414141);border-radius:4px;border-radius:var(--message-border-radius,4px);width:100%;display:flex;align-items:flex-start;text-align:left;position:relative;border:1px solid;padding:23px 23px 23px 63px;margin:12px 0;box-shadow:0 2px 4px rgba(65,65,65,.5);box-shadow:var(--message-box-shadow,0 2px 4px rgba(65,65,65,.5));max-width:352px}@media (max-width:703px){:host{padding:23px 23px 23px 63px;display:block}}:host(.context-info){border-color:#496ebd;border-color:var(--message-info-border-color,#496ebd);background-color:#ecf0f8;background-color:var(--message-info-background-color,#ecf0f8)}:host(.context-info) .nx-message__icon{color:#496ebd;color:var(--message-info-icon-color,#496ebd)}:host(.context-success){border-color:#1e8927;border-color:var(--message-success-border-color,#1e8927);background-color:#e8f3e9;background-color:var(--message-success-background-color,#e8f3e9)}:host(.context-success) .nx-message__icon{color:#1e8927;color:var(--message-success-icon-color,#1e8927)}@media screen and (-ms-high-contrast:active){:host(.context-info) .nx-message__icon,:host(.context-success) .nx-message__icon{color:windowText}}.nx-message__icon{position:absolute;top:23px;left:23px}"]
                    }] }
        ];
        /** @nocollapse */
        NxMessageToastComponent.ctorParameters = function () { return [
            { type: core.NgZone },
            { type: core.ChangeDetectorRef },
            { type: NxMessageToastConfig },
            { type: NxMessageToastData }
        ]; };
        NxMessageToastComponent.propDecorators = {
            _portalOutlet: [{ type: core.ViewChild, args: [portal.CdkPortalOutlet, { static: true },] }]
        };
        return NxMessageToastComponent;
    }(portal.BasePortalOutlet));
    if (false) {
        /**
         * Whether the component has been destroyed.
         * @type {?}
         * @private
         */
        NxMessageToastComponent.prototype._destroyed;
        /**
         * The portal outlet inside of this container into which the message toastcontent will be loaded.
         * @type {?}
         */
        NxMessageToastComponent.prototype._portalOutlet;
        /**
         * Subject for notifying that the message toasthas exited from view.
         * @type {?}
         */
        NxMessageToastComponent.prototype._onExit;
        /**
         * Subject for notifying that the message toasthas finished entering the view.
         * @type {?}
         */
        NxMessageToastComponent.prototype._onEnter;
        /**
         * The state of the message toastanimations.
         * @type {?}
         */
        NxMessageToastComponent.prototype._animationState;
        /**
         * ARIA role for the message toastcontainer.
         * @type {?}
         */
        NxMessageToastComponent.prototype._role;
        /** @type {?} */
        NxMessageToastComponent.prototype._context;
        /**
         * @type {?}
         * @private
         */
        NxMessageToastComponent.prototype._ngZone;
        /**
         * @type {?}
         * @private
         */
        NxMessageToastComponent.prototype._changeDetectorRef;
        /**
         * The message toastconfiguration.
         * @type {?}
         */
        NxMessageToastComponent.prototype.config;
        /**
         * Injected data into the notifciation.
         * @type {?}
         */
        NxMessageToastComponent.prototype.data;
    }

    /**
     * @fileoverview added by tsickle
     * Generated from: message.module.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var NxMessageModule = /** @class */ (function () {
        function NxMessageModule() {
        }
        NxMessageModule.decorators = [
            { type: core.NgModule, args: [{
                        imports: [
                            common.CommonModule,
                            icon.NxIconModule,
                            overlay.OverlayModule,
                            portal.PortalModule
                        ],
                        declarations: [
                            NxMessageComponent,
                            NxMessageToastComponent
                        ],
                        exports: [
                            NxMessageComponent
                        ],
                        entryComponents: [
                            NxMessageToastComponent
                        ]
                    },] }
        ];
        return NxMessageModule;
    }());

    /**
     * @fileoverview added by tsickle
     * Generated from: message-toast/message-toast-ref.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * Maximum amount of milliseconds that can be passed into setTimeout.
     * @type {?}
     */
    var MAX_TIMEOUT = Math.pow(2, 31) - 1;
    var NxMessageToastRef = /** @class */ (function () {
        function NxMessageToastRef(toastInstance, _overlayRef) {
            var _this = this;
            this._overlayRef = _overlayRef;
            /**
             * Subject for notifying the user that the message toasthas been dismissed.
             */
            this._afterDismissed = new rxjs.Subject();
            /**
             * Subject for notifying the user that the message toasthas opened and appeared.
             */
            this._afterOpened = new rxjs.Subject();
            this.toastInstance = toastInstance;
            toastInstance._onExit.subscribe((/**
             * @return {?}
             */
            function () { return _this._finishDismiss(); }));
        }
        /** Dismisses the message toast. */
        /**
         * Dismisses the message toast.
         * @return {?}
         */
        NxMessageToastRef.prototype.dismiss = /**
         * Dismisses the message toast.
         * @return {?}
         */
        function () {
            if (!this._afterDismissed.closed) {
                this.toastInstance.exit();
            }
            clearTimeout(this._durationTimeoutId);
        };
        /** Dismisses the message toastafter some duration */
        /**
         * Dismisses the message toastafter some duration
         * @param {?} duration
         * @return {?}
         */
        NxMessageToastRef.prototype._dismissAfter = /**
         * Dismisses the message toastafter some duration
         * @param {?} duration
         * @return {?}
         */
        function (duration) {
            var _this = this;
            // Note that we need to cap the duration to the maximum value for setTimeout, because
            // it'll revert to 1 if somebody passes in something greater (e.g. `Infinity`). See #17234.
            this._durationTimeoutId = setTimeout((/**
             * @return {?}
             */
            function () { return _this.dismiss(); }), Math.min(duration, MAX_TIMEOUT));
        };
        /** Marks the message toastas opened */
        /**
         * Marks the message toastas opened
         * @return {?}
         */
        NxMessageToastRef.prototype._open = /**
         * Marks the message toastas opened
         * @return {?}
         */
        function () {
            if (!this._afterOpened.closed) {
                this._afterOpened.next();
                this._afterOpened.complete();
            }
        };
        /** Cleans up the DOM after closing. */
        /**
         * Cleans up the DOM after closing.
         * @private
         * @return {?}
         */
        NxMessageToastRef.prototype._finishDismiss = /**
         * Cleans up the DOM after closing.
         * @private
         * @return {?}
         */
        function () {
            this._overlayRef.dispose();
            this._afterDismissed.next();
            this._afterDismissed.complete();
        };
        /** Gets an observable that is notified when the message toastis finished closing. */
        /**
         * Gets an observable that is notified when the message toastis finished closing.
         * @return {?}
         */
        NxMessageToastRef.prototype.afterDismissed = /**
         * Gets an observable that is notified when the message toastis finished closing.
         * @return {?}
         */
        function () {
            return this._afterDismissed.asObservable();
        };
        /** Gets an observable that is notified when the message toasthas opened and appeared. */
        /**
         * Gets an observable that is notified when the message toasthas opened and appeared.
         * @return {?}
         */
        NxMessageToastRef.prototype.afterOpened = /**
         * Gets an observable that is notified when the message toasthas opened and appeared.
         * @return {?}
         */
        function () {
            return this.toastInstance._onEnter;
        };
        return NxMessageToastRef;
    }());
    if (false) {
        /**
         * The instance of the component making up the content of the message toast.
         * \@docs-private
         * @type {?}
         */
        NxMessageToastRef.prototype.toastInstance;
        /**
         * Subject for notifying the user that the message toasthas been dismissed.
         * @type {?}
         * @private
         */
        NxMessageToastRef.prototype._afterDismissed;
        /**
         * Subject for notifying the user that the message toasthas opened and appeared.
         * @type {?}
         * @private
         */
        NxMessageToastRef.prototype._afterOpened;
        /**
         * Timeout ID for the duration setTimeout call. Used to clear the timeout if the message toastis
         * dismissed before the duration passes.
         * @type {?}
         * @private
         */
        NxMessageToastRef.prototype._durationTimeoutId;
        /**
         * @type {?}
         * @private
         */
        NxMessageToastRef.prototype._overlayRef;
    }

    /**
     * @fileoverview added by tsickle
     * Generated from: message-toast/message-toast.service.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * Injection token that can be used to specify default message toast.
     * @type {?}
     */
    var NX_MESSAGE_TOAST_DEFAULT_CONFIG = new core.InjectionToken('NX_MESSAGE_TOAST_DEFAULT_CONFIG');
    /**
     * A service for dispatching and displaying toast messages.
     */
    var NxMessageToastService = /** @class */ (function () {
        function NxMessageToastService(_overlay, _injector, _live, _parentMessageToastService, _defaultConfig) {
            this._overlay = _overlay;
            this._injector = _injector;
            this._live = _live;
            this._parentMessageToastService = _parentMessageToastService;
            this._defaultConfig = _defaultConfig;
            /**
             * Reference to the current message toast in the view *at this level* (in the Angular injector tree).
             * If there is a parent message toast service, all operations should delegate to that parent
             * via `_oldToastMessageRef`.
             */
            this._toastRefAtThisLevel = null;
        }
        Object.defineProperty(NxMessageToastService.prototype, "_oldToastMessageRef", {
            /** Reference to the currently opened message toastat *any* level. */
            get: /**
             * Reference to the currently opened message toastat *any* level.
             * @return {?}
             */
            function () {
                /** @type {?} */
                var parent = this._parentMessageToastService;
                return parent ? parent._oldToastMessageRef : this._toastRefAtThisLevel;
            },
            set: /**
             * @param {?} value
             * @return {?}
             */
            function (value) {
                if (this._parentMessageToastService) {
                    this._parentMessageToastService._oldToastMessageRef = value;
                }
                else {
                    this._toastRefAtThisLevel = value;
                }
            },
            enumerable: true,
            configurable: true
        });
        /** Creates and dispatches a message toastwith a custom text.
         *
         * @param text Text to be used for the message toast.
         * @param config Extra configuration for the message toast.
        */
        /**
         * Creates and dispatches a message toastwith a custom text.
         *
         * @param {?} text Text to be used for the message toast.
         * @param {?=} config Extra configuration for the message toast.
         * @return {?}
         */
        NxMessageToastService.prototype.open = /**
         * Creates and dispatches a message toastwith a custom text.
         *
         * @param {?} text Text to be used for the message toast.
         * @param {?=} config Extra configuration for the message toast.
         * @return {?}
         */
        function (text, config) {
            /** @type {?} */
            var currentConfig = __assign({}, new NxMessageToastConfig(), this._defaultConfig, config);
            /** @type {?} */
            var overlayRef = this._createOverlay(currentConfig);
            /** @type {?} */
            var injector = this._createInjector(currentConfig, new NxMessageToastData(text), this._injector);
            /** @type {?} */
            var componentPortal = new portal.ComponentPortal(NxMessageToastComponent, undefined, injector);
            /** @type {?} */
            var componentRef = overlayRef.attach(componentPortal);
            /** @type {?} */
            var toastRef = new NxMessageToastRef(componentRef.instance, overlayRef);
            this._animateToast(toastRef, currentConfig);
            this._oldToastMessageRef = toastRef;
            return this._oldToastMessageRef;
        };
        /** Creates and dispatches a message toastwith a custom template for the content.
         *
         * @param template Template to be used for the message toast.
         * @param config Extra configuration for the message toast.
        */
        /**
         * Creates and dispatches a message toastwith a custom template for the content.
         *
         * @param {?} template Template to be used for the message toast.
         * @param {?=} config Extra configuration for the message toast.
         * @return {?}
         */
        NxMessageToastService.prototype.openFromTemplate = /**
         * Creates and dispatches a message toastwith a custom template for the content.
         *
         * @param {?} template Template to be used for the message toast.
         * @param {?=} config Extra configuration for the message toast.
         * @return {?}
         */
        function (template, config) {
            /** @type {?} */
            var currentConfig = __assign({}, new NxMessageToastConfig(), this._defaultConfig, config);
            /** @type {?} */
            var overlayRef = this._createOverlay(currentConfig);
            /** @type {?} */
            var container = this._attachToastComponent(overlayRef, currentConfig);
            /** @type {?} */
            var toastRef = new NxMessageToastRef(container, overlayRef);
            /** @type {?} */
            var portal$1 = new portal.TemplatePortal(template, (/** @type {?} */ (null)), toastRef);
            container.attachTemplatePortal(portal$1);
            this._animateToast(toastRef, currentConfig);
            this._oldToastMessageRef = toastRef;
            return this._oldToastMessageRef;
        };
        // Attaches the message toastcontainer component to the overlay.
        // Attaches the message toastcontainer component to the overlay.
        /**
         * @private
         * @param {?} overlayRef
         * @param {?} config
         * @return {?}
         */
        NxMessageToastService.prototype._attachToastComponent = 
        // Attaches the message toastcontainer component to the overlay.
        /**
         * @private
         * @param {?} overlayRef
         * @param {?} config
         * @return {?}
         */
        function (overlayRef, config) {
            /** @type {?} */
            var injector = this._createInjector(config, null, this._injector);
            /** @type {?} */
            var containerPortal = new portal.ComponentPortal(NxMessageToastComponent, null, injector);
            /** @type {?} */
            var containerRef = overlayRef.attach(containerPortal);
            containerRef.instance.config = config;
            return containerRef.instance;
        };
        // Creates a new overlay and places it in the correct place.
        // Creates a new overlay and places it in the correct place.
        /**
         * @private
         * @param {?} config
         * @return {?}
         */
        NxMessageToastService.prototype._createOverlay = 
        // Creates a new overlay and places it in the correct place.
        /**
         * @private
         * @param {?} config
         * @return {?}
         */
        function (config) {
            /** @type {?} */
            var overlayConfig = new overlay.OverlayConfig();
            /** @type {?} */
            var positionStrategy = this._overlay.position().global();
            positionStrategy.bottom('0');
            positionStrategy.centerHorizontally();
            overlayConfig.positionStrategy = positionStrategy;
            return this._overlay.create(overlayConfig);
        };
        /** Animates the old message toastout and the new one in. */
        /**
         * Animates the old message toastout and the new one in.
         * @private
         * @param {?} toastRef
         * @param {?} config
         * @return {?}
         */
        NxMessageToastService.prototype._animateToast = /**
         * Animates the old message toastout and the new one in.
         * @private
         * @param {?} toastRef
         * @param {?} config
         * @return {?}
         */
        function (toastRef, config) {
            var _this = this;
            // When the message toastis dismissed, clear the reference to it.
            toastRef.afterDismissed().subscribe((/**
             * @return {?}
             */
            function () {
                // Clear the message toastref if it hasn't already been replaced by a newer message toast.
                if (_this._oldToastMessageRef === toastRef) {
                    _this._oldToastMessageRef = null;
                }
                if (config.announcementMessage) {
                    _this._live.clear();
                }
            }));
            if (this._oldToastMessageRef) {
                // If a message toastis opened, dismiss it and enter the
                // new message toastafter exit animation is complete.
                this._oldToastMessageRef.afterDismissed().subscribe((/**
                 * @return {?}
                 */
                function () {
                    toastRef.toastInstance.enter();
                }));
                this._oldToastMessageRef.dismiss();
            }
            else {
                // If no message toastis in view, enter the message toast.
                toastRef.toastInstance.enter();
            }
            // If a message toastduration is provided, set up dismiss based on after the message toastis opened.
            if (config.duration && config.duration > 0) {
                toastRef.afterOpened().subscribe((/**
                 * @return {?}
                 */
                function () { return toastRef._dismissAfter((/** @type {?} */ (config.duration))); }));
            }
            if (config.announcementMessage) {
                this._live.announce(config.announcementMessage, config.politeness);
            }
        };
        /**
         * @private
         * @param {?} config
         * @param {?} data
         * @param {?} injector
         * @return {?}
         */
        NxMessageToastService.prototype._createInjector = /**
         * @private
         * @param {?} config
         * @param {?} data
         * @param {?} injector
         * @return {?}
         */
        function (config, data, injector) {
            /** @type {?} */
            var tokens = new WeakMap();
            tokens.set(NxMessageToastConfig, config);
            tokens.set(NxMessageToastData, data);
            return new portal.PortalInjector(injector, tokens);
        };
        /**
         * Dismisses the currently visible message toast.
         */
        /**
         * Dismisses the currently visible message toast.
         * @return {?}
         */
        NxMessageToastService.prototype.dismiss = /**
         * Dismisses the currently visible message toast.
         * @return {?}
         */
        function () {
            if (this._oldToastMessageRef) {
                this._oldToastMessageRef.dismiss();
            }
        };
        /**
         * @return {?}
         */
        NxMessageToastService.prototype.ngOnDestroy = /**
         * @return {?}
         */
        function () {
            if (this._toastRefAtThisLevel) {
                this._toastRefAtThisLevel.dismiss();
            }
        };
        NxMessageToastService.decorators = [
            { type: core.Injectable, args: [{ providedIn: NxMessageModule },] }
        ];
        /** @nocollapse */
        NxMessageToastService.ctorParameters = function () { return [
            { type: overlay.Overlay },
            { type: core.Injector },
            { type: a11y.LiveAnnouncer },
            { type: NxMessageToastService, decorators: [{ type: core.Optional }, { type: core.SkipSelf }] },
            { type: NxMessageToastConfig, decorators: [{ type: core.Optional }, { type: core.Inject, args: [NX_MESSAGE_TOAST_DEFAULT_CONFIG,] }] }
        ]; };
        /** @nocollapse */ NxMessageToastService.ngInjectableDef = core.defineInjectable({ factory: function NxMessageToastService_Factory() { return new NxMessageToastService(core.inject(overlay.Overlay), core.inject(core.INJECTOR), core.inject(a11y.LiveAnnouncer), core.inject(NxMessageToastService, 12), core.inject(NX_MESSAGE_TOAST_DEFAULT_CONFIG, 8)); }, token: NxMessageToastService, providedIn: NxMessageModule });
        return NxMessageToastService;
    }());
    if (false) {
        /**
         * Reference to the current message toast in the view *at this level* (in the Angular injector tree).
         * If there is a parent message toast service, all operations should delegate to that parent
         * via `_oldToastMessageRef`.
         * @type {?}
         * @private
         */
        NxMessageToastService.prototype._toastRefAtThisLevel;
        /**
         * @type {?}
         * @private
         */
        NxMessageToastService.prototype._overlay;
        /**
         * @type {?}
         * @private
         */
        NxMessageToastService.prototype._injector;
        /**
         * @type {?}
         * @private
         */
        NxMessageToastService.prototype._live;
        /**
         * @type {?}
         * @private
         */
        NxMessageToastService.prototype._parentMessageToastService;
        /**
         * @type {?}
         * @private
         */
        NxMessageToastService.prototype._defaultConfig;
    }

    exports.NX_MESSAGE_TOAST_DEFAULT_CONFIG = NX_MESSAGE_TOAST_DEFAULT_CONFIG;
    exports.NxMessageComponent = NxMessageComponent;
    exports.NxMessageModule = NxMessageModule;
    exports.NxMessageToastComponent = NxMessageToastComponent;
    exports.NxMessageToastConfig = NxMessageToastConfig;
    exports.NxMessageToastData = NxMessageToastData;
    exports.NxMessageToastRef = NxMessageToastRef;
    exports.NxMessageToastService = NxMessageToastService;
    exports.messageToastAnimations = messageToastAnimations;

    Object.defineProperty(exports, '__esModule', { value: true });

})));
//# sourceMappingURL=allianz-ngx-ndbx-message.umd.js.map
