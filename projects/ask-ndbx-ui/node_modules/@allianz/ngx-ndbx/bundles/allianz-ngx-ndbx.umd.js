(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@angular/core'), require('@angular/common'), require('@angular/cdk/coercion'), require('@angular/forms'), require('rxjs'), require('@allianz/ngx-ndbx/base'), require('@allianz/ngx-ndbx/utils'), require('@allianz/ngx-ndbx/icon'), require('@angular/cdk/observers'), require('@allianz/ngx-ndbx/core'), require('rxjs/operators'), require('@angular/cdk/collections'), require('@angular/platform-browser'), require('@angular/animations'), require('@angular/cdk/a11y'), require('@angular/cdk/overlay'), require('@angular/cdk/portal'), require('@angular/cdk/keycodes'), require('@angular/cdk/platform'), require('@allianz/ngx-ndbx/formfield'), require('@allianz/ngx-ndbx/checkbox'), require('@angular/cdk/bidi'), require('@allianz/ngx-ndbx/natural-language-form'), require('@allianz/ngx-ndbx/popover'), require('@allianz/ngx-ndbx/input'), require('@allianz/ngx-ndbx/dropdown'), require('@allianz/ngx-ndbx/grid'), require('@allianz/ngx-ndbx/autocomplete'), require('@allianz/ngx-ndbx/button'), require('decimal.js'), require('@angular/cdk/table'), require('@angular/cdk/scrolling'), require('@angular/cdk/accordion'), require('@allianz/ngx-ndbx/accordion')) :
    typeof define === 'function' && define.amd ? define('@allianz/ngx-ndbx', ['exports', '@angular/core', '@angular/common', '@angular/cdk/coercion', '@angular/forms', 'rxjs', '@allianz/ngx-ndbx/base', '@allianz/ngx-ndbx/utils', '@allianz/ngx-ndbx/icon', '@angular/cdk/observers', '@allianz/ngx-ndbx/core', 'rxjs/operators', '@angular/cdk/collections', '@angular/platform-browser', '@angular/animations', '@angular/cdk/a11y', '@angular/cdk/overlay', '@angular/cdk/portal', '@angular/cdk/keycodes', '@angular/cdk/platform', '@allianz/ngx-ndbx/formfield', '@allianz/ngx-ndbx/checkbox', '@angular/cdk/bidi', '@allianz/ngx-ndbx/natural-language-form', '@allianz/ngx-ndbx/popover', '@allianz/ngx-ndbx/input', '@allianz/ngx-ndbx/dropdown', '@allianz/ngx-ndbx/grid', '@allianz/ngx-ndbx/autocomplete', '@allianz/ngx-ndbx/button', 'decimal.js', '@angular/cdk/table', '@angular/cdk/scrolling', '@angular/cdk/accordion', '@allianz/ngx-ndbx/accordion'], factory) :
    (global = global || self, factory((global.allianz = global.allianz || {}, global.allianz['ngx-ndbx'] = {}), global.ng.core, global.ng.common, global.ng.cdk.coercion, global.ng.forms, global.rxjs, global.allianz['ngx-ndbx'].base, global.allianz['ngx-ndbx'].utils, global.allianz['ngx-ndbx'].icon, global.ng.cdk.observers, global.allianz['ngx-ndbx'].core, global.rxjs.operators, global.ng.cdk.collections, global.ng.platformBrowser, global.ng.animations, global.ng.cdk.a11y, global.ng.cdk.overlay, global.ng.cdk.portal, global.ng.cdk.keycodes, global.ng.cdk.platform, global.allianz['ngx-ndbx'].formfield, global.allianz['ngx-ndbx'].checkbox, global.ng.cdk.bidi, global.allianz['ngx-ndbx']['natural-language-form'], global.allianz['ngx-ndbx'].popover, global.allianz['ngx-ndbx'].input, global.allianz['ngx-ndbx'].dropdown, global.allianz['ngx-ndbx'].grid, global.allianz['ngx-ndbx'].autocomplete, global.allianz['ngx-ndbx'].button, global.decimal_js, global.ng.cdk.table, global.ng.cdk.scrolling, global.ng.cdk.accordion, global.allianz['ngx-ndbx'].accordion));
}(this, (function (exports, core, common, coercion, forms, rxjs, base, utils, icon, observers, core$1, operators, collections, platformBrowser, animations, a11y, overlay, portal, keycodes, platform, formfield, checkbox, bidi, naturalLanguageForm, popover, input, dropdown, grid, autocomplete, button, decimal_js, table, scrolling, accordion, accordion$1) { 'use strict';

    /*! *****************************************************************************
    Copyright (c) Microsoft Corporation. All rights reserved.
    Licensed under the Apache License, Version 2.0 (the "License"); you may not use
    this file except in compliance with the License. You may obtain a copy of the
    License at http://www.apache.org/licenses/LICENSE-2.0

    THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
    WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
    MERCHANTABLITY OR NON-INFRINGEMENT.

    See the Apache Version 2.0 License for specific language governing permissions
    and limitations under the License.
    ***************************************************************************** */
    /* global Reflect, Promise */

    var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };

    function __extends(d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    }

    var __assign = function() {
        __assign = Object.assign || function __assign(t) {
            for (var s, i = 1, n = arguments.length; i < n; i++) {
                s = arguments[i];
                for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
            }
            return t;
        };
        return __assign.apply(this, arguments);
    };

    function __rest(s, e) {
        var t = {};
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
            t[p] = s[p];
        if (s != null && typeof Object.getOwnPropertySymbols === "function")
            for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
                if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                    t[p[i]] = s[p[i]];
            }
        return t;
    }

    function __decorate(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    }

    function __param(paramIndex, decorator) {
        return function (target, key) { decorator(target, key, paramIndex); }
    }

    function __metadata(metadataKey, metadataValue) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(metadataKey, metadataValue);
    }

    function __awaiter(thisArg, _arguments, P, generator) {
        return new (P || (P = Promise))(function (resolve, reject) {
            function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
            function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
            function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
            step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
    }

    function __generator(thisArg, body) {
        var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
        return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
        function verb(n) { return function (v) { return step([n, v]); }; }
        function step(op) {
            if (f) throw new TypeError("Generator is already executing.");
            while (_) try {
                if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
                if (y = 0, t) op = [op[0] & 2, t.value];
                switch (op[0]) {
                    case 0: case 1: t = op; break;
                    case 4: _.label++; return { value: op[1], done: false };
                    case 5: _.label++; y = op[1]; op = [0]; continue;
                    case 7: op = _.ops.pop(); _.trys.pop(); continue;
                    default:
                        if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                        if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                        if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                        if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                        if (t[2]) _.ops.pop();
                        _.trys.pop(); continue;
                }
                op = body.call(thisArg, _);
            } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
            if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
        }
    }

    function __exportStar(m, exports) {
        for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
    }

    function __values(o) {
        var m = typeof Symbol === "function" && o[Symbol.iterator], i = 0;
        if (m) return m.call(o);
        return {
            next: function () {
                if (o && i >= o.length) o = void 0;
                return { value: o && o[i++], done: !o };
            }
        };
    }

    function __read(o, n) {
        var m = typeof Symbol === "function" && o[Symbol.iterator];
        if (!m) return o;
        var i = m.call(o), r, ar = [], e;
        try {
            while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
        }
        catch (error) { e = { error: error }; }
        finally {
            try {
                if (r && !r.done && (m = i["return"])) m.call(i);
            }
            finally { if (e) throw e.error; }
        }
        return ar;
    }

    function __spread() {
        for (var ar = [], i = 0; i < arguments.length; i++)
            ar = ar.concat(__read(arguments[i]));
        return ar;
    }

    function __spreadArrays() {
        for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
        for (var r = Array(s), k = 0, i = 0; i < il; i++)
            for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
                r[k] = a[j];
        return r;
    };

    function __await(v) {
        return this instanceof __await ? (this.v = v, this) : new __await(v);
    }

    function __asyncGenerator(thisArg, _arguments, generator) {
        if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
        var g = generator.apply(thisArg, _arguments || []), i, q = [];
        return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i;
        function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }
        function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }
        function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }
        function fulfill(value) { resume("next", value); }
        function reject(value) { resume("throw", value); }
        function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }
    }

    function __asyncDelegator(o) {
        var i, p;
        return i = {}, verb("next"), verb("throw", function (e) { throw e; }), verb("return"), i[Symbol.iterator] = function () { return this; }, i;
        function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === "return" } : f ? f(v) : v; } : f; }
    }

    function __asyncValues(o) {
        if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
        var m = o[Symbol.asyncIterator], i;
        return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);
        function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }
        function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }
    }

    function __makeTemplateObject(cooked, raw) {
        if (Object.defineProperty) { Object.defineProperty(cooked, "raw", { value: raw }); } else { cooked.raw = raw; }
        return cooked;
    };

    function __importStar(mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
        result.default = mod;
        return result;
    }

    function __importDefault(mod) {
        return (mod && mod.__esModule) ? mod : { default: mod };
    }

    /**
     * @fileoverview added by tsickle
     * Generated from: ndbx.module.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var NdbxModule = /** @class */ (function () {
        function NdbxModule() {
        }
        /**
         * @return {?}
         */
        NdbxModule.forRoot = /**
         * @return {?}
         */
        function () {
            return {
                ngModule: NdbxModule
            };
        };
        NdbxModule.decorators = [
            { type: core.NgModule, args: [{},] }
        ];
        return NdbxModule;
    }());

    /**
     * @fileoverview added by tsickle
     * Generated from: button/button-base.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /** @type {?} */
    var DEFAULT_SIZE = 'medium';
    /** @type {?} */
    var DEFAULT_TYPE = 'primary';
    /**
     * \@docs-private
     */
    var NxButtonBase = /** @class */ (function () {
        function NxButtonBase(_changeDetectorRef, _elementRef) {
            this._changeDetectorRef = _changeDetectorRef;
            this._elementRef = _elementRef;
            /**
             * \@docs-private
             */
            this.type = DEFAULT_TYPE;
            /**
             * \@docs-private
             */
            this.size = DEFAULT_SIZE;
            this.negative = false;
            this.block = false;
        }
        Object.defineProperty(NxButtonBase.prototype, "isPrimary", {
            /** @docs-private */
            get: /**
             * \@docs-private
             * @return {?}
             */
            function () { return this.type === 'primary'; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NxButtonBase.prototype, "isSecondary", {
            /** @docs-private */
            get: /**
             * \@docs-private
             * @return {?}
             */
            function () { return this.type === 'secondary'; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NxButtonBase.prototype, "isTertiary", {
            /** @docs-private */
            get: /**
             * \@docs-private
             * @return {?}
             */
            function () { return this.type === 'tertiary'; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NxButtonBase.prototype, "isCta", {
            /** @docs-private */
            get: /**
             * \@docs-private
             * @return {?}
             */
            function () { return this.type === 'cta'; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NxButtonBase.prototype, "isEmphasis", {
            /** @docs-private */
            get: /**
             * \@docs-private
             * @return {?}
             */
            function () { return this.type === 'emphasis'; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NxButtonBase.prototype, "isLarge", {
            /** @docs-private */
            get: /**
             * \@docs-private
             * @return {?}
             */
            function () { return this.size === 'large'; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NxButtonBase.prototype, "isMedium", {
            /** @docs-private */
            get: /**
             * \@docs-private
             * @return {?}
             */
            function () { return this.size === 'medium'; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NxButtonBase.prototype, "isSmallMedium", {
            /** @docs-private */
            get: /**
             * \@docs-private
             * @return {?}
             */
            function () { return this.size === 'small-medium'; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NxButtonBase.prototype, "isSmall", {
            /** @docs-private */
            get: /**
             * \@docs-private
             * @return {?}
             */
            function () { return this.size === 'small'; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NxButtonBase.prototype, "isBlock", {
            /** @docs-private */
            get: /**
             * \@docs-private
             * @return {?}
             */
            function () { return this.block; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NxButtonBase.prototype, "isNegative", {
            /** @docs-private */
            get: /**
             * \@docs-private
             * @return {?}
             */
            function () { return this.negative; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NxButtonBase.prototype, "classNames", {
            get: /**
             * @return {?}
             */
            function () {
                return this._classNames;
            },
            set: /**
             * @param {?} value
             * @return {?}
             */
            function (value) {
                if (this._classNames === value) {
                    return;
                }
                this._classNames = value;
                var _a = __read(this._classNames.match(/primary|secondary|tertiary|cta|emphasis/) || [DEFAULT_TYPE], 1), _b = _a[0], type = _b === void 0 ? null : _b;
                this.type = (/** @type {?} */ (type));
                var _c = __read(this._classNames.match(/small-medium|small|medium|large/) || [DEFAULT_SIZE], 1), _d = _c[0], size = _d === void 0 ? null : _d;
                this.size = (/** @type {?} */ (size));
                this.negative = /negative/.test(this._classNames);
                this.block = /block/.test(this._classNames);
                this._changeDetectorRef.markForCheck();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NxButtonBase.prototype, "elementRef", {
            /**
             * @docs-private
             * getter used for the modal component as a quickfix
             * since button got changed from directive to component the reference used by the ngOpenModelOnClick directive
             * for nxButtons is a reference to component instance instead of an element reference. As a workaround we need a
             * way to reach the elementRef of the component until the modal gets refactored.
             */
            get: /**
             * \@docs-private
             * getter used for the modal component as a quickfix
             * since button got changed from directive to component the reference used by the ngOpenModelOnClick directive
             * for nxButtons is a reference to component instance instead of an element reference. As a workaround we need a
             * way to reach the elementRef of the component until the modal gets refactored.
             * @return {?}
             */
            function () {
                return this._elementRef;
            },
            enumerable: true,
            configurable: true
        });
        NxButtonBase.propDecorators = {
            isPrimary: [{ type: core.HostBinding, args: ['class.nx-button--primary',] }],
            isSecondary: [{ type: core.HostBinding, args: ['class.nx-button--secondary',] }],
            isTertiary: [{ type: core.HostBinding, args: ['class.nx-button--tertiary',] }],
            isCta: [{ type: core.HostBinding, args: ['class.nx-button--cta',] }],
            isEmphasis: [{ type: core.HostBinding, args: ['class.nx-button--emphasis',] }],
            isLarge: [{ type: core.HostBinding, args: ['class.nx-button--large',] }],
            isMedium: [{ type: core.HostBinding, args: ['class.nx-button--medium',] }],
            isSmallMedium: [{ type: core.HostBinding, args: ['class.nx-button--small-medium',] }],
            isSmall: [{ type: core.HostBinding, args: ['class.nx-button--small',] }],
            isBlock: [{ type: core.HostBinding, args: ['class.nx-button--block',] }],
            isNegative: [{ type: core.HostBinding, args: ['class.nx-button--negative',] }]
        };
        return NxButtonBase;
    }());
    if (false) {
        /**
         * @type {?}
         * @private
         */
        NxButtonBase.prototype._classNames;
        /**
         * \@docs-private
         * @type {?}
         */
        NxButtonBase.prototype.type;
        /**
         * \@docs-private
         * @type {?}
         */
        NxButtonBase.prototype.size;
        /** @type {?} */
        NxButtonBase.prototype.negative;
        /** @type {?} */
        NxButtonBase.prototype.block;
        /**
         * @type {?}
         * @private
         */
        NxButtonBase.prototype._changeDetectorRef;
        /**
         * @type {?}
         * @private
         */
        NxButtonBase.prototype._elementRef;
    }

    /**
     * @fileoverview added by tsickle
     * Generated from: button/button.component.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var NxButtonComponent = /** @class */ (function (_super) {
        __extends(NxButtonComponent, _super);
        function NxButtonComponent(changeDetectorRef, elementRef) {
            return _super.call(this, changeDetectorRef, elementRef) || this;
        }
        NxButtonComponent.decorators = [
            { type: core.Component, args: [{
                        template: "<span class=\"nx-button__content-wrapper\">\n  <ng-content></ng-content>\n</span>\n",
                        // tslint:disable-next-line:component-selector
                        selector: 'button[nxButton]',
                        changeDetection: core.ChangeDetectionStrategy.OnPush,
                        inputs: ['classNames:nxButton'],
                        styles: [":host{font-size:16px;font-size:var(--button-medium-font-size,16px);line-height:24px;line-height:var(--button-medium-line-height,24px);font-weight:600;font-weight:var(--button-medium-font-weight,600);letter-spacing:1px;letter-spacing:var(--button-medium-letter-spacing,1px);min-height:48px;min-height:var(--button-medium-height,48px);text-transform:uppercase;text-transform:var(--button-text-transform,uppercase);border-width:var(--button-border-width,2px);border-radius:4px;border-radius:var(--button-border-radius,4px);cursor:pointer;margin:0 0 24px;padding:10px 30px;padding:calc(12px - var(--button-border-width,2px)) calc(32px - var(--button-border-width,2px));transition:background-color .2s,border-color .2s,color .2s,box-shadow .2s;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;width:auto;-webkit-hyphens:none;-ms-hyphens:none;hyphens:none;vertical-align:middle;border:2px solid transparent}:host:disabled{cursor:not-allowed}:host:focus{outline:0}:host::-moz-focus-inner{border:0}:host-context([data-whatinput=keyboard]).nx-button--negative:focus,:host-context([data-whatinput=keyboard]):focus{box-shadow:0 0 0 2px #fff,0 0 0 6px #009de6;box-shadow:var(--focus-box-shadow,0 0 0 2px #fff,0 0 0 6px #009de6)}:host(.nx-button--primary){color:#fff;color:var(--button-primary-text-color,#fff);background-color:#007ab3;background-color:var(--button-primary-background-color,#007ab3);border-color:transparent;border-color:var(--button-primary-border-color,transparent)}:host(.nx-button--primary):hover:not(:disabled):not(:active){background-color:#006192;background-color:var(--button-primary-hover-background-color,#006192);color:#fff;color:var(--button-primary-hover-text-color,#fff);border-color:transparent;border-color:var(--button-primary-hover-border-color,transparent)}:host(.nx-button--primary):active{background-color:#003781;background-color:var(--button-primary-active-background-color,#003781);color:#fff;color:var(--button-primary-active-text-color,#fff);border-color:transparent;border-color:var(--button-primary-active-border-color,transparent)}:host(.nx-button--primary):disabled{background-color:rgba(0,122,179,.4);background-color:var(--button-primary-disabled-background-color,rgba(0,122,179,.4));color:rgba(255,255,255,.4);color:var(--button-primary-disabled-text-color,rgba(255,255,255,.4));border-color:transparent;border-color:var(--button-primary-disabled-border-color,transparent)}:host(.nx-button--primary.nx-button--negative){background-color:#fff;border-color:#fff;color:#006192}:host(.nx-button--primary.nx-button--negative):hover:not(:disabled):not(:active){background-color:#d9d9d9;border-color:#d9d9d9;color:#006192}:host(.nx-button--primary.nx-button--negative):active{background-color:#c2c2c2;border-color:#c2c2c2;color:#006192}:host(.nx-button--primary.nx-button--negative):disabled{background-color:rgba(255,255,255,.4);border-color:transparent;color:rgba(65,65,65,.3)}:host(.nx-button--secondary){color:#006192;color:var(--button-secondary-text-color,#006192);background-color:transparent;background-color:var(--button-secondary-background-color,transparent);border-color:#007ab3;border-color:var(--button-secondary-border-color,#007ab3)}:host(.nx-button--secondary):hover:not(:disabled):not(:active){background-color:#006192;background-color:var(--button-secondary-hover-background-color,#006192);color:#fff;color:var(--button-secondary-hover-text-color,#fff);border-color:transparent;border-color:var(--button-secondary-hover-border-color,transparent)}:host(.nx-button--secondary):active{background-color:#003781;background-color:var(--button-secondary-active-background-color,#003781);color:#fff;color:var(--button-secondary-active-text-color,#fff);border-color:transparent;border-color:var(--button-secondary-active-border-color,transparent)}:host(.nx-button--secondary):disabled{background-color:transparent;background-color:var(--button-secondary-disabled-background-color,transparent);color:rgba(0,97,146,.4);color:var(--button-secondary-disabled-text-color,rgba(0,97,146,.4));border-color:rgba(0,122,179,.4);border-color:var(--button-secondary-disabled-border-color,rgba(0,122,179,.4))}:host(.nx-button--secondary.nx-button--negative){color:#fff;border-color:#fff}:host(.nx-button--secondary.nx-button--negative):hover:not(:disabled):not(:active){background-color:#d9d9d9;border-color:#d9d9d9;color:#006192;color:var(--button-secondary-text-color,#006192)}:host(.nx-button--secondary.nx-button--negative):active{background-color:#c2c2c2;border-color:#c2c2c2;color:#006192;color:var(--button-secondary-text-color,#006192)}:host(.nx-button--secondary.nx-button--negative):disabled{background-color:transparent;border-color:rgba(255,255,255,.4);color:rgba(255,255,255,.4)}:host(.nx-button--tertiary){color:#006192;color:var(--button-tertiary-text-color,#006192);background-color:transparent;background-color:var(--button-tertiary-background-color,transparent);border-color:transparent;border-color:var(--button-tertiary-border-color,transparent)}:host(.nx-button--tertiary):hover:not(:disabled):not(:active){background-color:#ececec;background-color:var(--button-tertiary-hover-background-color,#ececec);color:#006192;color:var(--button-tertiary-hover-text-color,#006192);border-color:transparent;border-color:var(--button-tertiary-hover-border-color,transparent)}:host(.nx-button--tertiary):active{background-color:#d9d9d9;background-color:var(--button-tertiary-active-background-color,#d9d9d9);color:#006192;color:var(--button-tertiary-active-text-color,#006192);border-color:transparent;border-color:var(--button-tertiary-active-border-color,transparent)}:host(.nx-button--tertiary):disabled{background-color:transparent;background-color:var(--button-tertiary-disabled-background-color,transparent);color:rgba(0,97,146,.4);color:var(--button-tertiary-disabled-text-color,rgba(0,97,146,.4));border-color:transparent;border-color:var(--button-tertiary-disabled-border-color,transparent)}:host(.nx-button--tertiary.nx-button--negative){color:#fff}:host(.nx-button--tertiary.nx-button--negative):hover{background-color:#d9d9d9;color:#006192;color:var(--button-secondary-text-color,#006192)}:host(.nx-button--tertiary.nx-button--negative):active{background-color:#c2c2c2;color:#006192;color:var(--button-secondary-text-color,#006192)}:host(.nx-button--tertiary.nx-button--negative):disabled{background-color:transparent;color:rgba(255,255,255,.4)}:host(.nx-button--large){font-size:20px;font-size:var(--button-large-font-size,20px);line-height:24px;line-height:var(--button-large-line-height,24px);font-weight:600;font-weight:var(--button-large-font-weight,600);letter-spacing:1px;letter-spacing:var(--button-large-letter-spacing,1px);min-height:72px;min-height:var(--button-large-height,72px);padding:22px 46px;padding:calc(24px - var(--button-border-width,2px)) calc(48px - var(--button-border-width,2px))}@media (max-width:703px){:host{display:block;width:100%}:host(.nx-button--large){padding:22px 30px;padding:calc(24px - var(--button-border-width,2px)) calc(32px - var(--button-border-width,2px))}}:host(.nx-button--small-medium){display:inline-block;font-size:16px;font-size:var(--button-small-medium-font-size,16px);line-height:24px;line-height:var(--button-small-medium-line-height,24px);font-weight:600;font-weight:var(--button-small-medium-font-weight,600);letter-spacing:1px;letter-spacing:var(--button-small-medium-letter-spacing,1px);padding:6px 22px;padding:calc(8px - var(--button-border-width,2px)) calc(24px - var(--button-border-width,2px));text-transform:none;width:auto;min-height:40px;min-height:var(--button-small-medium-height,40px)}:host(.nx-button--small){font-size:14px;font-size:var(--button-small-font-size,14px);line-height:16px;line-height:var(--button-small-line-height,16px);font-weight:600;font-weight:var(--button-small-font-weight,600);letter-spacing:1px;letter-spacing:var(--button-small-letter-spacing,1px);min-height:32px;min-height:var(--button-small-height,32px);display:inline-block;padding:6px 14px;padding:calc(8px - var(--button-border-width,2px)) calc(16px - var(--button-border-width,2px));text-transform:none;width:auto}:host(.nx-button--cta){color:#fff;color:var(--button-cta-text-color,#fff);background-color:#3da556;background-color:var(--button-cta-background-color,#3da556);border-color:transparent;border-color:var(--button-cta-border-color,transparent)}:host(.nx-button--cta):hover:not(:disabled):not(:active){background-color:#348357;background-color:var(--button-cta-hover-background-color,#348357);color:#fff;color:var(--button-cta-hover-text-color,#fff);border-color:transparent;border-color:var(--button-cta-hover-border-color,transparent)}:host(.nx-button--cta):active{background-color:#276442;background-color:var(--button-cta-active-background-color,#276442);color:#fff;color:var(--button-cta-active-text-color,#fff);border-color:transparent;border-color:var(--button-cta-active-border-color,transparent)}:host(.nx-button--cta):disabled{background-color:rgba(61,165,86,.4);background-color:var(--button-cta-disabled-background-color,rgba(61,165,86,.4));color:rgba(255,255,255,.4);color:var(--button-cta-disabled-text-color,rgba(255,255,255,.4));border-color:transparent;border-color:var(--button-cta-disabled-border-color,transparent)}:host(.nx-button--emphasis){color:#fff;color:var(--button-emphasis-text-color,#fff);background-color:#f86200;background-color:var(--button-emphasis-background-color,#f86200);border-color:transparent;border-color:var(--button-emphasis-border-color,transparent)}:host(.nx-button--emphasis):hover:not(:disabled):not(:active){background-color:#e15200;background-color:var(--button-emphasis-hover-background-color,#e15200);color:#fff;color:var(--button-emphasis-hover-text-color,#fff);border-color:transparent;border-color:var(--button-emphasis-hover-border-color,transparent)}:host(.nx-button--emphasis):active{background-color:#c15500;background-color:var(--button-emphasis-active-background-color,#c15500);color:#fff;color:var(--button-emphasis-active-text-color,#fff);border-color:transparent;border-color:var(--button-emphasis-active-border-color,transparent)}:host(.nx-button--emphasis):disabled{background-color:rgba(248,98,0,.4);background-color:var(--button-emphasis-disabled-background-color,rgba(248,98,0,.4));color:rgba(255,255,255,.4);color:var(--button-emphasis-disabled-text-color,rgba(255,255,255,.4));border-color:transparent;border-color:var(--button-emphasis-disabled-border-color,transparent)}@media (min-width:704px){:host(.nx-button--block){display:block;width:100%}}:host .nx-button__content-wrapper{display:inline-flex;align-items:center;justify-content:center;vertical-align:bottom}:host([nxiconbutton]),:host([nxsidebartoggle]){padding:0;flex:0 0 auto}:host([nxiconbutton]).nx-button--small,:host([nxsidebartoggle]).nx-button--small{width:32px;width:var(--button-small-height,32px);font-size:16px;font-size:var(--icon-button-small-icon-size,16px)}:host([nxiconbutton]).nx-button--small-medium,:host([nxsidebartoggle]).nx-button--small-medium{width:40px;width:var(--button-small-medium-height,40px);font-size:24px;font-size:var(--icon-button-small-medium-icon-size,24px)}:host([nxiconbutton]).nx-button--medium,:host([nxsidebartoggle]).nx-button--medium{width:48px;width:var(--button-medium-height,48px);font-size:24px;font-size:var(--icon-button-medium-icon-size,24px)}:host([nxiconbutton]).nx-button--large,:host([nxsidebartoggle]).nx-button--large{width:72px;width:var(--button-large-height,72px);font-size:24px;font-size:var(--icon-button-large-icon-size,24px)}:host([nxbutton]).nx-button--small ::ng-deep nx-icon{font-size:16px;font-size:var(--button-small-icon-size,16px)}:host([nxbutton]).nx-button--small-medium ::ng-deep nx-icon{font-size:20px;font-size:var(--button-small-medium-icon-size,20px)}:host([nxbutton]).nx-button--medium ::ng-deep nx-icon{font-size:24px;font-size:var(--button-medium-icon-size,24px)}:host([nxbutton]).nx-button--large ::ng-deep nx-icon{font-size:24px;font-size:var(--button-large-icon-size,24px)}@media screen and (-ms-high-contrast:active){:host-context([data-whatinput=keyboard]).nx-button--negative:focus,:host-context([data-whatinput=keyboard]):focus{box-shadow:0 0 0 2px background,0 0 0 6px windowText}:host{background-color:buttonFace}:host .nx-button__content-wrapper{-ms-high-contrast-adjust:none}:host:disabled{color:GrayText;border-color:GrayText}}"]
                    }] }
        ];
        /** @nocollapse */
        NxButtonComponent.ctorParameters = function () { return [
            { type: core.ChangeDetectorRef },
            { type: core.ElementRef }
        ]; };
        return NxButtonComponent;
    }(NxButtonBase));

    /**
     * @fileoverview added by tsickle
     * Generated from: button/icon-button.component.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var NxIconButtonComponent = /** @class */ (function (_super) {
        __extends(NxIconButtonComponent, _super);
        function NxIconButtonComponent(changeDetectorRef, elementRef) {
            return _super.call(this, changeDetectorRef, elementRef) || this;
        }
        NxIconButtonComponent.decorators = [
            { type: core.Component, args: [{
                        // tslint:disable-next-line:component-selector
                        selector: 'button[nxIconButton]',
                        template: "<span class=\"nx-button__content-wrapper\">\n  <ng-content></ng-content>\n</span>\n",
                        changeDetection: core.ChangeDetectionStrategy.OnPush,
                        inputs: ['classNames:nxIconButton'],
                        styles: [":host{font-size:16px;font-size:var(--button-medium-font-size,16px);line-height:24px;line-height:var(--button-medium-line-height,24px);font-weight:600;font-weight:var(--button-medium-font-weight,600);letter-spacing:1px;letter-spacing:var(--button-medium-letter-spacing,1px);min-height:48px;min-height:var(--button-medium-height,48px);text-transform:uppercase;text-transform:var(--button-text-transform,uppercase);border-width:var(--button-border-width,2px);border-radius:4px;border-radius:var(--button-border-radius,4px);cursor:pointer;margin:0 0 24px;padding:10px 30px;padding:calc(12px - var(--button-border-width,2px)) calc(32px - var(--button-border-width,2px));transition:background-color .2s,border-color .2s,color .2s,box-shadow .2s;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;width:auto;-webkit-hyphens:none;-ms-hyphens:none;hyphens:none;vertical-align:middle;border:2px solid transparent}:host:disabled{cursor:not-allowed}:host:focus{outline:0}:host::-moz-focus-inner{border:0}:host-context([data-whatinput=keyboard]).nx-button--negative:focus,:host-context([data-whatinput=keyboard]):focus{box-shadow:0 0 0 2px #fff,0 0 0 6px #009de6;box-shadow:var(--focus-box-shadow,0 0 0 2px #fff,0 0 0 6px #009de6)}:host(.nx-button--primary){color:#fff;color:var(--button-primary-text-color,#fff);background-color:#007ab3;background-color:var(--button-primary-background-color,#007ab3);border-color:transparent;border-color:var(--button-primary-border-color,transparent)}:host(.nx-button--primary):hover:not(:disabled):not(:active){background-color:#006192;background-color:var(--button-primary-hover-background-color,#006192);color:#fff;color:var(--button-primary-hover-text-color,#fff);border-color:transparent;border-color:var(--button-primary-hover-border-color,transparent)}:host(.nx-button--primary):active{background-color:#003781;background-color:var(--button-primary-active-background-color,#003781);color:#fff;color:var(--button-primary-active-text-color,#fff);border-color:transparent;border-color:var(--button-primary-active-border-color,transparent)}:host(.nx-button--primary):disabled{background-color:rgba(0,122,179,.4);background-color:var(--button-primary-disabled-background-color,rgba(0,122,179,.4));color:rgba(255,255,255,.4);color:var(--button-primary-disabled-text-color,rgba(255,255,255,.4));border-color:transparent;border-color:var(--button-primary-disabled-border-color,transparent)}:host(.nx-button--primary.nx-button--negative){background-color:#fff;border-color:#fff;color:#006192}:host(.nx-button--primary.nx-button--negative):hover:not(:disabled):not(:active){background-color:#d9d9d9;border-color:#d9d9d9;color:#006192}:host(.nx-button--primary.nx-button--negative):active{background-color:#c2c2c2;border-color:#c2c2c2;color:#006192}:host(.nx-button--primary.nx-button--negative):disabled{background-color:rgba(255,255,255,.4);border-color:transparent;color:rgba(65,65,65,.3)}:host(.nx-button--secondary){color:#006192;color:var(--button-secondary-text-color,#006192);background-color:transparent;background-color:var(--button-secondary-background-color,transparent);border-color:#007ab3;border-color:var(--button-secondary-border-color,#007ab3)}:host(.nx-button--secondary):hover:not(:disabled):not(:active){background-color:#006192;background-color:var(--button-secondary-hover-background-color,#006192);color:#fff;color:var(--button-secondary-hover-text-color,#fff);border-color:transparent;border-color:var(--button-secondary-hover-border-color,transparent)}:host(.nx-button--secondary):active{background-color:#003781;background-color:var(--button-secondary-active-background-color,#003781);color:#fff;color:var(--button-secondary-active-text-color,#fff);border-color:transparent;border-color:var(--button-secondary-active-border-color,transparent)}:host(.nx-button--secondary):disabled{background-color:transparent;background-color:var(--button-secondary-disabled-background-color,transparent);color:rgba(0,97,146,.4);color:var(--button-secondary-disabled-text-color,rgba(0,97,146,.4));border-color:rgba(0,122,179,.4);border-color:var(--button-secondary-disabled-border-color,rgba(0,122,179,.4))}:host(.nx-button--secondary.nx-button--negative){color:#fff;border-color:#fff}:host(.nx-button--secondary.nx-button--negative):hover:not(:disabled):not(:active){background-color:#d9d9d9;border-color:#d9d9d9;color:#006192;color:var(--button-secondary-text-color,#006192)}:host(.nx-button--secondary.nx-button--negative):active{background-color:#c2c2c2;border-color:#c2c2c2;color:#006192;color:var(--button-secondary-text-color,#006192)}:host(.nx-button--secondary.nx-button--negative):disabled{background-color:transparent;border-color:rgba(255,255,255,.4);color:rgba(255,255,255,.4)}:host(.nx-button--tertiary){color:#006192;color:var(--button-tertiary-text-color,#006192);background-color:transparent;background-color:var(--button-tertiary-background-color,transparent);border-color:transparent;border-color:var(--button-tertiary-border-color,transparent)}:host(.nx-button--tertiary):hover:not(:disabled):not(:active){background-color:#ececec;background-color:var(--button-tertiary-hover-background-color,#ececec);color:#006192;color:var(--button-tertiary-hover-text-color,#006192);border-color:transparent;border-color:var(--button-tertiary-hover-border-color,transparent)}:host(.nx-button--tertiary):active{background-color:#d9d9d9;background-color:var(--button-tertiary-active-background-color,#d9d9d9);color:#006192;color:var(--button-tertiary-active-text-color,#006192);border-color:transparent;border-color:var(--button-tertiary-active-border-color,transparent)}:host(.nx-button--tertiary):disabled{background-color:transparent;background-color:var(--button-tertiary-disabled-background-color,transparent);color:rgba(0,97,146,.4);color:var(--button-tertiary-disabled-text-color,rgba(0,97,146,.4));border-color:transparent;border-color:var(--button-tertiary-disabled-border-color,transparent)}:host(.nx-button--tertiary.nx-button--negative){color:#fff}:host(.nx-button--tertiary.nx-button--negative):hover{background-color:#d9d9d9;color:#006192;color:var(--button-secondary-text-color,#006192)}:host(.nx-button--tertiary.nx-button--negative):active{background-color:#c2c2c2;color:#006192;color:var(--button-secondary-text-color,#006192)}:host(.nx-button--tertiary.nx-button--negative):disabled{background-color:transparent;color:rgba(255,255,255,.4)}:host(.nx-button--large){font-size:20px;font-size:var(--button-large-font-size,20px);line-height:24px;line-height:var(--button-large-line-height,24px);font-weight:600;font-weight:var(--button-large-font-weight,600);letter-spacing:1px;letter-spacing:var(--button-large-letter-spacing,1px);min-height:72px;min-height:var(--button-large-height,72px);padding:22px 46px;padding:calc(24px - var(--button-border-width,2px)) calc(48px - var(--button-border-width,2px))}@media (max-width:703px){:host{display:block;width:100%}:host(.nx-button--large){padding:22px 30px;padding:calc(24px - var(--button-border-width,2px)) calc(32px - var(--button-border-width,2px))}}:host(.nx-button--small-medium){display:inline-block;font-size:16px;font-size:var(--button-small-medium-font-size,16px);line-height:24px;line-height:var(--button-small-medium-line-height,24px);font-weight:600;font-weight:var(--button-small-medium-font-weight,600);letter-spacing:1px;letter-spacing:var(--button-small-medium-letter-spacing,1px);padding:6px 22px;padding:calc(8px - var(--button-border-width,2px)) calc(24px - var(--button-border-width,2px));text-transform:none;width:auto;min-height:40px;min-height:var(--button-small-medium-height,40px)}:host(.nx-button--small){font-size:14px;font-size:var(--button-small-font-size,14px);line-height:16px;line-height:var(--button-small-line-height,16px);font-weight:600;font-weight:var(--button-small-font-weight,600);letter-spacing:1px;letter-spacing:var(--button-small-letter-spacing,1px);min-height:32px;min-height:var(--button-small-height,32px);display:inline-block;padding:6px 14px;padding:calc(8px - var(--button-border-width,2px)) calc(16px - var(--button-border-width,2px));text-transform:none;width:auto}:host(.nx-button--cta){color:#fff;color:var(--button-cta-text-color,#fff);background-color:#3da556;background-color:var(--button-cta-background-color,#3da556);border-color:transparent;border-color:var(--button-cta-border-color,transparent)}:host(.nx-button--cta):hover:not(:disabled):not(:active){background-color:#348357;background-color:var(--button-cta-hover-background-color,#348357);color:#fff;color:var(--button-cta-hover-text-color,#fff);border-color:transparent;border-color:var(--button-cta-hover-border-color,transparent)}:host(.nx-button--cta):active{background-color:#276442;background-color:var(--button-cta-active-background-color,#276442);color:#fff;color:var(--button-cta-active-text-color,#fff);border-color:transparent;border-color:var(--button-cta-active-border-color,transparent)}:host(.nx-button--cta):disabled{background-color:rgba(61,165,86,.4);background-color:var(--button-cta-disabled-background-color,rgba(61,165,86,.4));color:rgba(255,255,255,.4);color:var(--button-cta-disabled-text-color,rgba(255,255,255,.4));border-color:transparent;border-color:var(--button-cta-disabled-border-color,transparent)}:host(.nx-button--emphasis){color:#fff;color:var(--button-emphasis-text-color,#fff);background-color:#f86200;background-color:var(--button-emphasis-background-color,#f86200);border-color:transparent;border-color:var(--button-emphasis-border-color,transparent)}:host(.nx-button--emphasis):hover:not(:disabled):not(:active){background-color:#e15200;background-color:var(--button-emphasis-hover-background-color,#e15200);color:#fff;color:var(--button-emphasis-hover-text-color,#fff);border-color:transparent;border-color:var(--button-emphasis-hover-border-color,transparent)}:host(.nx-button--emphasis):active{background-color:#c15500;background-color:var(--button-emphasis-active-background-color,#c15500);color:#fff;color:var(--button-emphasis-active-text-color,#fff);border-color:transparent;border-color:var(--button-emphasis-active-border-color,transparent)}:host(.nx-button--emphasis):disabled{background-color:rgba(248,98,0,.4);background-color:var(--button-emphasis-disabled-background-color,rgba(248,98,0,.4));color:rgba(255,255,255,.4);color:var(--button-emphasis-disabled-text-color,rgba(255,255,255,.4));border-color:transparent;border-color:var(--button-emphasis-disabled-border-color,transparent)}@media (min-width:704px){:host(.nx-button--block){display:block;width:100%}}:host .nx-button__content-wrapper{display:inline-flex;align-items:center;justify-content:center;vertical-align:bottom}:host([nxiconbutton]),:host([nxsidebartoggle]){padding:0;flex:0 0 auto}:host([nxiconbutton]).nx-button--small,:host([nxsidebartoggle]).nx-button--small{width:32px;width:var(--button-small-height,32px);font-size:16px;font-size:var(--icon-button-small-icon-size,16px)}:host([nxiconbutton]).nx-button--small-medium,:host([nxsidebartoggle]).nx-button--small-medium{width:40px;width:var(--button-small-medium-height,40px);font-size:24px;font-size:var(--icon-button-small-medium-icon-size,24px)}:host([nxiconbutton]).nx-button--medium,:host([nxsidebartoggle]).nx-button--medium{width:48px;width:var(--button-medium-height,48px);font-size:24px;font-size:var(--icon-button-medium-icon-size,24px)}:host([nxiconbutton]).nx-button--large,:host([nxsidebartoggle]).nx-button--large{width:72px;width:var(--button-large-height,72px);font-size:24px;font-size:var(--icon-button-large-icon-size,24px)}:host([nxbutton]).nx-button--small ::ng-deep nx-icon{font-size:16px;font-size:var(--button-small-icon-size,16px)}:host([nxbutton]).nx-button--small-medium ::ng-deep nx-icon{font-size:20px;font-size:var(--button-small-medium-icon-size,20px)}:host([nxbutton]).nx-button--medium ::ng-deep nx-icon{font-size:24px;font-size:var(--button-medium-icon-size,24px)}:host([nxbutton]).nx-button--large ::ng-deep nx-icon{font-size:24px;font-size:var(--button-large-icon-size,24px)}@media screen and (-ms-high-contrast:active){:host-context([data-whatinput=keyboard]).nx-button--negative:focus,:host-context([data-whatinput=keyboard]):focus{box-shadow:0 0 0 2px background,0 0 0 6px windowText}:host{background-color:buttonFace}:host .nx-button__content-wrapper{-ms-high-contrast-adjust:none}:host:disabled{color:GrayText;border-color:GrayText}}"]
                    }] }
        ];
        /** @nocollapse */
        NxIconButtonComponent.ctorParameters = function () { return [
            { type: core.ChangeDetectorRef },
            { type: core.ElementRef }
        ]; };
        return NxIconButtonComponent;
    }(NxButtonBase));

    /**
     * @fileoverview added by tsickle
     * Generated from: button/button.module.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var NxButtonModule = /** @class */ (function () {
        function NxButtonModule() {
        }
        NxButtonModule.decorators = [
            { type: core.NgModule, args: [{
                        declarations: [NxButtonComponent, NxIconButtonComponent],
                        exports: [NxButtonComponent, NxIconButtonComponent]
                    },] }
        ];
        return NxButtonModule;
    }());

    /**
     * @fileoverview added by tsickle
     * Generated from: button/public-api.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * Generated from: button/index.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * Generated from: checkbox/checkbox.component.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /** @type {?} */
    var nextId = 0;
    var NxCheckboxChangeEvent = /** @class */ (function () {
        function NxCheckboxChangeEvent(checked, value, checkbox) {
            this.checked = checked;
            this.value = value;
            this.checkbox = checkbox;
        }
        return NxCheckboxChangeEvent;
    }());
    if (false) {
        /**
         * The checked value of the checkbox.
         * @type {?}
         */
        NxCheckboxChangeEvent.prototype.checked;
        /**
         * The value of the checkbox.
         * @type {?}
         */
        NxCheckboxChangeEvent.prototype.value;
        /**
         * The component instance of the checkbox which emitted the change event.
         * @type {?}
         */
        NxCheckboxChangeEvent.prototype.checkbox;
    }
    var NxCheckboxGroupComponent = /** @class */ (function () {
        function NxCheckboxGroupComponent(_changeDetectorRef, ngControl) {
            this._changeDetectorRef = _changeDetectorRef;
            this.ngControl = ngControl;
            this._stateChanges = new rxjs.Subject();
            this.selectionChange = new core.EventEmitter();
            this._id = "nx-checkbox-group-" + nextId++;
            this._disabled = false;
            this._negative = false;
            this._onChange = (/**
             * @return {?}
             */
            function () { });
            this._onTouched = (/**
             * @return {?}
             */
            function () { });
            if (this.ngControl) {
                // Note: we provide the value accessor through here, instead of
                // the `providers` to avoid running into a circular import.
                this.ngControl.valueAccessor = this;
            }
        }
        Object.defineProperty(NxCheckboxGroupComponent.prototype, "id", {
            get: /**
             * @return {?}
             */
            function () {
                return this._id;
            },
            /** Sets the Id of the checkbox group. */
            set: /**
             * Sets the Id of the checkbox group.
             * @param {?} value
             * @return {?}
             */
            function (value) {
                if (this._id !== value) {
                    this._id = value;
                    this._changeDetectorRef.markForCheck();
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NxCheckboxGroupComponent.prototype, "name", {
            get: /**
             * @return {?}
             */
            function () {
                return this._name;
            },
            /** Sets the name of the checkboxes inside the nx-checkbox-group. */
            set: /**
             * Sets the name of the checkboxes inside the nx-checkbox-group.
             * @param {?} value
             * @return {?}
             */
            function (value) {
                this._name = value;
                this._changeDetectorRef.markForCheck();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NxCheckboxGroupComponent.prototype, "disabled", {
            get: /**
             * @return {?}
             */
            function () {
                return this._disabled;
            },
            /** Disables all checkboxes inside the nx-checkbox-group. */
            set: /**
             * Disables all checkboxes inside the nx-checkbox-group.
             * @param {?} value
             * @return {?}
             */
            function (value) {
                this._disabled = coercion.coerceBooleanProperty(value);
                if (this._label) {
                    this._label.disabled = this._disabled;
                }
                this._stateChanges.next();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NxCheckboxGroupComponent.prototype, "negative", {
            get: /**
             * @return {?}
             */
            function () {
                return this._negative;
            },
            /** Set the negative styles for all the checkboxes inside the nx-checkbox-group */
            set: /**
             * Set the negative styles for all the checkboxes inside the nx-checkbox-group
             * @param {?} value
             * @return {?}
             */
            function (value) {
                this._negative = coercion.coerceBooleanProperty(value);
                this._changeDetectorRef.markForCheck();
                this._stateChanges.next();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NxCheckboxGroupComponent.prototype, "labelSize", {
            get: /**
             * @return {?}
             */
            function () {
                return this._labelSize;
            },
            /** Sets the label size of the checkboxes inside the group */
            set: /**
             * Sets the label size of the checkboxes inside the group
             * @param {?} value
             * @return {?}
             */
            function (value) {
                this._labelSize = value;
                this._stateChanges.next();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NxCheckboxGroupComponent.prototype, "required", {
            /** Whether the nx-checkbox-group are required. */
            get: /**
             * Whether the nx-checkbox-group are required.
             * @return {?}
             */
            function () {
                return this._required;
            },
            set: /**
             * @param {?} value
             * @return {?}
             */
            function (value) {
                this._required = coercion.coerceBooleanProperty(value);
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        NxCheckboxGroupComponent.prototype.ngAfterContentInit = /**
         * @return {?}
         */
        function () {
            var _this = this;
            if (this.ngControl) {
                if (!!this._value) {
                    this._updateSelectedCheckboxFromValue();
                }
                this._value = this._checkboxes
                    .filter((/**
                 * @param {?} checkbox
                 * @return {?}
                 */
                function (checkbox) { return checkbox.checked; }))
                    .map((/**
                 * @param {?} cb
                 * @return {?}
                 */
                function (cb) { return cb.value; }));
            }
            this._updateSelectedCheckboxFromValue();
            this._checkboxes.changes.subscribe((/**
             * @return {?}
             */
            function () {
                _this._value = _this._checkboxes.filter((/**
                 * @param {?} checkbox
                 * @return {?}
                 */
                function (checkbox) { return checkbox.checked; })).map((/**
                 * @param {?} cb
                 * @return {?}
                 */
                function (cb) { return cb.value; }));
                if (_this.ngControl) {
                    _this.ngControl.control.setValue(_this._value);
                }
                _this._updateSelectedCheckboxFromValue();
            }));
        };
        /**
         * @return {?}
         */
        NxCheckboxGroupComponent.prototype.ngOnDestroy = /**
         * @return {?}
         */
        function () {
            this._stateChanges.complete();
        };
        /**
         * @param {?} value
         * @return {?}
         */
        NxCheckboxGroupComponent.prototype.writeValue = /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            if (this._value !== value) {
                this._value = value;
                this._updateSelectedCheckboxFromValue();
            }
        };
        /**
         * @param {?} fn
         * @return {?}
         */
        NxCheckboxGroupComponent.prototype.registerOnChange = /**
         * @param {?} fn
         * @return {?}
         */
        function (fn) {
            this._onChange = fn;
        };
        /**
         * @param {?} fn
         * @return {?}
         */
        NxCheckboxGroupComponent.prototype.registerOnTouched = /**
         * @param {?} fn
         * @return {?}
         */
        function (fn) {
            this._onTouched = fn;
        };
        /**
         * @param {?} isDisabled
         * @return {?}
         */
        NxCheckboxGroupComponent.prototype.setDisabledState = /**
         * @param {?} isDisabled
         * @return {?}
         */
        function (isDisabled) {
            this.disabled = isDisabled;
        };
        /**
         * @private
         * @return {?}
         */
        NxCheckboxGroupComponent.prototype._updateSelectedCheckboxFromValue = /**
         * @private
         * @return {?}
         */
        function () {
            var _this = this;
            if (this._checkboxes && this._checkboxes.length && !!this._value && this._value.length) {
                this._checkboxes.map((/**
                 * @param {?} checkbox
                 * @return {?}
                 */
                function (checkbox) {
                    checkbox.checked = _this._value.indexOf(checkbox.value) !== -1;
                }));
            }
        };
        /** @docs-private */
        /**
         * \@docs-private
         * @param {?} value
         * @return {?}
         */
        NxCheckboxGroupComponent.prototype.change = /**
         * \@docs-private
         * @param {?} value
         * @return {?}
         */
        function (value) {
            value = this._checkboxes.filter((/**
             * @param {?} checkbox
             * @return {?}
             */
            function (checkbox) { return checkbox.checked; })).map((/**
             * @param {?} cb
             * @return {?}
             */
            function (cb) { return cb.value; }));
            this._onChange(value);
            if (this._onTouched) {
                this._onTouched();
            }
            this.selectionChange.emit(new NxCheckboxChangeEvent(value.checked, value.value, value));
        };
        NxCheckboxGroupComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'nx-checkbox-group',
                        template: "<div>\n  <div class=\"nx-checkbox-group__label\">\n    <ng-content select=\"nx-label\"></ng-content>\n  </div>\n  <div class=\"nx-checkbox-group__errors\">\n    <ng-content select=\"nx-error\"></ng-content>\n  </div>\n  <div class=\"nx-checkbox-group__controls\">\n    <ng-content></ng-content>\n  </div>\n</div>\n",
                        changeDetection: core.ChangeDetectionStrategy.OnPush,
                        host: {
                            '[class.nx-checkbox-group]': 'true',
                            '[class.nx-checkbox-group--negative]': 'negative',
                            '[attr.id]': 'id',
                            '[attr.required]': 'required',
                            '[attr.disabled]': 'disabled || null',
                            '[attr.aria-labelledby]': 'this._label?.id  || null',
                            '[attr.role]': '"group"',
                        },
                        styles: [":host ::ng-deep nx-error{margin-bottom:8px}:host ::ng-deep nx-label{margin-bottom:16px;display:block}:host.nx-checkbox-group--negative ::ng-deep nx-error,:host.nx-checkbox-group--negative ::ng-deep nx-icon.nx-error__icon,:host.nx-checkbox-group--negative ::ng-deep nx-label{color:#fff}"]
                    }] }
        ];
        /** @nocollapse */
        NxCheckboxGroupComponent.ctorParameters = function () { return [
            { type: core.ChangeDetectorRef },
            { type: forms.NgControl, decorators: [{ type: core.Optional }, { type: core.Self }] }
        ]; };
        NxCheckboxGroupComponent.propDecorators = {
            _checkboxes: [{ type: core.ContentChildren, args: [core.forwardRef((/**
                         * @return {?}
                         */
                        function () { return NxCheckboxComponent; })), { descendants: true },] }],
            _label: [{ type: core.ContentChild, args: [core.forwardRef((/**
                         * @return {?}
                         */
                        function () { return base.NxLabelComponent; })), { static: false },] }],
            selectionChange: [{ type: core.Output }],
            id: [{ type: core.Input }],
            name: [{ type: core.Input }],
            disabled: [{ type: core.Input }],
            negative: [{ type: core.Input }],
            labelSize: [{ type: core.Input }],
            required: [{ type: core.Input }]
        };
        return NxCheckboxGroupComponent;
    }());
    if (false) {
        /** @type {?} */
        NxCheckboxGroupComponent.prototype._checkboxes;
        /** @type {?} */
        NxCheckboxGroupComponent.prototype._label;
        /** @type {?} */
        NxCheckboxGroupComponent.prototype._stateChanges;
        /** @type {?} */
        NxCheckboxGroupComponent.prototype.selectionChange;
        /**
         * @type {?}
         * @private
         */
        NxCheckboxGroupComponent.prototype._id;
        /**
         * @type {?}
         * @private
         */
        NxCheckboxGroupComponent.prototype._name;
        /**
         * @type {?}
         * @private
         */
        NxCheckboxGroupComponent.prototype._disabled;
        /**
         * @type {?}
         * @private
         */
        NxCheckboxGroupComponent.prototype._negative;
        /**
         * @type {?}
         * @private
         */
        NxCheckboxGroupComponent.prototype._labelSize;
        /**
         * @type {?}
         * @private
         */
        NxCheckboxGroupComponent.prototype._required;
        /**
         * @type {?}
         * @private
         */
        NxCheckboxGroupComponent.prototype._value;
        /**
         * @type {?}
         * @private
         */
        NxCheckboxGroupComponent.prototype._onChange;
        /**
         * @type {?}
         * @private
         */
        NxCheckboxGroupComponent.prototype._onTouched;
        /**
         * @type {?}
         * @private
         */
        NxCheckboxGroupComponent.prototype._changeDetectorRef;
        /** @type {?} */
        NxCheckboxGroupComponent.prototype.ngControl;
    }
    var NxCheckboxComponent = /** @class */ (function () {
        function NxCheckboxComponent(_changeDetectorRef, _errorStateMatcher, checkboxGroup, ngControl, _parentForm, _parentFormGroup) {
            this._changeDetectorRef = _changeDetectorRef;
            this._errorStateMatcher = _errorStateMatcher;
            this.checkboxGroup = checkboxGroup;
            this.ngControl = ngControl;
            this._parentForm = _parentForm;
            this._parentFormGroup = _parentFormGroup;
            this._id = (nextId++).toString();
            this._disabled = false;
            this._negative = false;
            this._labelSize = 'small';
            this._checked = false;
            this._name = null;
            this._indeterminate = false;
            /**
             * An event emitted when the indeterminate value has changed
             */
            this.indeterminateChange = new core.EventEmitter(false);
            /**
             * An event emitted when the checked value has changed.
             *
             * Emits the boolean checked value of the changed checkbox.
             */
            this.checkedChange = new core.EventEmitter(false);
            /**
             * An event emitted when the checked value has changed.
             *
             * Emits a NxCheckboxChangeEvent.
             */
            this.checkboxChange = new core.EventEmitter();
            this.onChangeCallback = (/**
             * @param {?} _
             * @return {?}
             */
            function (_) { });
            this.onTouchedCallback = (/**
             * @return {?}
             */
            function () { });
            if (this.ngControl) {
                // Note: we provide the value accessor through here, instead of
                // the `providers` to avoid running into a circular import.
                this.ngControl.valueAccessor = this;
            }
        }
        Object.defineProperty(NxCheckboxComponent.prototype, "id", {
            get: /**
             * @return {?}
             */
            function () {
                return "nx-checkbox-" + this._id;
            },
            /**
             * Id of the checkbox.
             *
             * If not set, the checkbox gets an incremented value by default.
             */
            set: /**
             * Id of the checkbox.
             *
             * If not set, the checkbox gets an incremented value by default.
             * @param {?} value
             * @return {?}
             */
            function (value) {
                if (value !== this._id) {
                    this._id = value;
                    this._changeDetectorRef.markForCheck();
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NxCheckboxComponent.prototype, "name", {
            get: /**
             * @return {?}
             */
            function () {
                return (this.checkboxGroup && this.checkboxGroup.name) ? this.checkboxGroup.name : this._name;
            },
            /** Name of the checkbox. */
            set: /**
             * Name of the checkbox.
             * @param {?} name
             * @return {?}
             */
            function (name) {
                this._name = name;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NxCheckboxComponent.prototype, "disabled", {
            get: /**
             * @return {?}
             */
            function () {
                return (this.checkboxGroup && this.checkboxGroup.disabled) ? this.checkboxGroup.disabled : this._disabled;
            },
            /** Whether the checkbox is disabled. */
            set: /**
             * Whether the checkbox is disabled.
             * @param {?} value
             * @return {?}
             */
            function (value) {
                /** @type {?} */
                var newValue = coercion.coerceBooleanProperty(value);
                if (newValue !== this._disabled) {
                    this._disabled = newValue;
                    this._changeDetectorRef.markForCheck();
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NxCheckboxComponent.prototype, "labelSize", {
            get: /**
             * @return {?}
             */
            function () {
                return (this.checkboxGroup && this.checkboxGroup.labelSize) ? this.checkboxGroup.labelSize : this._labelSize;
            },
            /**
             * Sets the label size of the checkbox. Default value: small
             */
            set: /**
             * Sets the label size of the checkbox. Default value: small
             * @param {?} value
             * @return {?}
             */
            function (value) {
                this._labelSize = value;
                this._changeDetectorRef.markForCheck();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NxCheckboxComponent.prototype, "negative", {
            get: /**
             * @return {?}
             */
            function () {
                return (this.checkboxGroup && this.checkboxGroup.negative) ? this.checkboxGroup.negative : this._negative;
            },
            /**
             * Whether the checkbox has negative styling.
             */
            set: /**
             * Whether the checkbox has negative styling.
             * @param {?} value
             * @return {?}
             */
            function (value) {
                /** @type {?} */
                var newValue = coercion.coerceBooleanProperty(value);
                if (newValue !== this._negative) {
                    this._negative = newValue;
                    this._changeDetectorRef.markForCheck();
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NxCheckboxComponent.prototype, "checked", {
            get: /**
             * @return {?}
             */
            function () {
                return this._checked;
            },
            /** Whether the checkbox is checked. */
            set: /**
             * Whether the checkbox is checked.
             * @param {?} value
             * @return {?}
             */
            function (value) {
                /** @type {?} */
                var newValue = coercion.coerceBooleanProperty(value);
                if (newValue !== this._checked) {
                    if (this._indeterminate) {
                        this._setIndeterminate(false);
                    }
                    this._setChecked(newValue);
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NxCheckboxComponent.prototype, "indeterminate", {
            get: /**
             * @return {?}
             */
            function () {
                return this._indeterminate;
            },
            /** Whether the checkbox is indeterminated. */
            set: /**
             * Whether the checkbox is indeterminated.
             * @param {?} value
             * @return {?}
             */
            function (value) {
                /** @type {?} */
                var newValue = coercion.coerceBooleanProperty(value);
                if (this._indeterminate !== newValue) {
                    if (this._checked) {
                        this._setChecked(false);
                    }
                    this._setIndeterminate(newValue);
                }
                this._changeDetectorRef.markForCheck();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NxCheckboxComponent.prototype, "required", {
            /** Whether the checkbox is required. */
            get: /**
             * Whether the checkbox is required.
             * @return {?}
             */
            function () {
                return this._required;
            },
            set: /**
             * @param {?} value
             * @return {?}
             */
            function (value) {
                this._required = coercion.coerceBooleanProperty(value);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NxCheckboxComponent.prototype, "value", {
            /** Sets the value of the checkbox. Default value is the checked status. */
            get: /**
             * Sets the value of the checkbox. Default value is the checked status.
             * @return {?}
             */
            function () {
                return this._value ? this._value : this.checked.toString();
            },
            set: /**
             * @param {?} value
             * @return {?}
             */
            function (value) {
                this._value = value;
                this._changeDetectorRef.markForCheck();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NxCheckboxComponent.prototype, "labelHasContent", {
            /** @docs-private */
            get: /**
             * \@docs-private
             * @return {?}
             */
            function () {
                return !!this._checkboxLabelWrapper.nativeElement.innerHTML.trim();
            },
            enumerable: true,
            configurable: true
        });
        /** @docs-private
         * Callback for when the content of the label has changed.
         */
        /**
         * \@docs-private
         * Callback for when the content of the label has changed.
         * @return {?}
         */
        NxCheckboxComponent.prototype.labelContentChanged = /**
         * \@docs-private
         * Callback for when the content of the label has changed.
         * @return {?}
         */
        function () {
            this._changeDetectorRef.detectChanges();
        };
        /** @docs-private */
        /**
         * \@docs-private
         * @return {?}
         */
        NxCheckboxComponent.prototype._controlInvalid = /**
         * \@docs-private
         * @return {?}
         */
        function () {
            /** @type {?} */
            var parent = this._parentFormGroup || this._parentForm;
            /** @type {?} */
            var control = null;
            if (this.checkboxGroup && this.checkboxGroup.ngControl) {
                control = this.checkboxGroup.ngControl;
            }
            else {
                control = this.ngControl ? (/** @type {?} */ (this.ngControl.control)) : null;
            }
            return this._errorStateMatcher.isErrorState(control, parent);
        };
        /**
         * @return {?}
         */
        NxCheckboxComponent.prototype.ngOnInit = /**
         * @return {?}
         */
        function () {
            var _this = this;
            if (this.checkboxGroup) {
                this.name = this.checkboxGroup.name;
                // when relevant properties of the parent like name and disabled change
                // we need to let change detection know that the template needs an update
                this._parentChangeSubscription = this.checkboxGroup._stateChanges.subscribe((/**
                 * @return {?}
                 */
                function () {
                    _this._changeDetectorRef.markForCheck();
                }));
            }
        };
        /**
         * @return {?}
         */
        NxCheckboxComponent.prototype.ngOnDestroy = /**
         * @return {?}
         */
        function () {
            if (this._parentChangeSubscription) {
                this._parentChangeSubscription.unsubscribe();
            }
        };
        /**
         * @private
         * @param {?} value
         * @return {?}
         */
        NxCheckboxComponent.prototype._setIndeterminate = /**
         * @private
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this._indeterminate = value;
            this.indeterminateChange.emit(this._indeterminate);
            this._changeDetectorRef.markForCheck();
        };
        /**
         * @private
         * @param {?} value
         * @return {?}
         */
        NxCheckboxComponent.prototype._setChecked = /**
         * @private
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this._checked = value;
            this._changeDetectorRef.markForCheck();
        };
        /** Toggles the checked state of the checkbox. */
        /**
         * Toggles the checked state of the checkbox.
         * @return {?}
         */
        NxCheckboxComponent.prototype.toggle = /**
         * Toggles the checked state of the checkbox.
         * @return {?}
         */
        function () {
            this.checked = !this.checked;
            this.onChangeCallback(this.checked);
            if (this.checkboxGroup !== null) {
                this.checkboxGroup.change(this);
            }
        };
        /**
         * @param {?} value
         * @return {?}
         */
        NxCheckboxComponent.prototype.writeValue = /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            if (value === null) {
                value = false;
            }
            if (value !== this.checked) {
                this.checked = value;
            }
        };
        /**
         * @param {?} onChange
         * @return {?}
         */
        NxCheckboxComponent.prototype.registerOnChange = /**
         * @param {?} onChange
         * @return {?}
         */
        function (onChange) {
            this.onChangeCallback = onChange;
        };
        /**
         * @param {?} onTouched
         * @return {?}
         */
        NxCheckboxComponent.prototype.registerOnTouched = /**
         * @param {?} onTouched
         * @return {?}
         */
        function (onTouched) {
            this.onTouchedCallback = onTouched;
        };
        /**
         * @param {?} isDisabled
         * @return {?}
         */
        NxCheckboxComponent.prototype.setDisabledState = /**
         * @param {?} isDisabled
         * @return {?}
         */
        function (isDisabled) {
            this.disabled = isDisabled;
        };
        /** @docs-private */
        /**
         * \@docs-private
         * @return {?}
         */
        NxCheckboxComponent.prototype.touch = /**
         * \@docs-private
         * @return {?}
         */
        function () {
            this.onTouchedCallback();
        };
        /** @docs-private */
        /**
         * \@docs-private
         * @param {?} event
         * @return {?}
         */
        NxCheckboxComponent.prototype._onInputClick = /**
         * \@docs-private
         * @param {?} event
         * @return {?}
         */
        function (event) {
            // stop the propagation of the native click on the checkbox input so that a click is not triggered twice
            event.stopPropagation();
            if (!this.disabled) {
                this.toggle();
                this.checkedChange.emit(this._checked);
                this.checkboxChange.emit(this._createChangeEvent(this._checked));
            }
        };
        /**@docs-private */
        /**
         * \@docs-private
         * @private
         * @param {?} checkedValue
         * @return {?}
         */
        NxCheckboxComponent.prototype._createChangeEvent = /**
         * \@docs-private
         * @private
         * @param {?} checkedValue
         * @return {?}
         */
        function (checkedValue) {
            /** @type {?} */
            var event = new NxCheckboxChangeEvent(checkedValue, this.value, this);
            event.checked = checkedValue;
            event.value = this.value;
            event.checkbox = this;
            return event;
        };
        NxCheckboxComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'nx-checkbox',
                        template: "<input\n  type=\"checkbox\"\n  [id]=\"id\"\n  [name]=\"name\"\n  [checked]=\"checked\"\n  [indeterminate]=\"indeterminate\" [disabled]=\"disabled\"\n  (blur)=\"touch()\"\n  [attr.aria-labelledby]=\"id + '-label'\"\n  (click)=\"_onInputClick($event)\"\n  class=\"nx-checkbox__input\"\n  [value]=\"value\"\n>\n\n<label [id]=\"id + '-label'\" [attr.for]=\"id\" class=\"nx-checkbox__label\" [class.has-label]=\"labelHasContent\">\n    <span class=\"nx-checkbox__control\">\n        <nx-icon *ngIf=\"checked\" name=\"check\" aria-hidden=\"true\"></nx-icon>\n        <div *ngIf=\"indeterminate\" class=\"nx-checkbox__indeterminate-indicator\"></div>\n    </span>\n    <div class=\"nx-checkbox__label-text\" #checkboxLabelWrapper (cdkObserveContent)=\"labelContentChanged()\">\n        <ng-content></ng-content>\n    </div>\n</label>\n",
                        changeDetection: core.ChangeDetectionStrategy.OnPush,
                        host: {
                            '[class.nx-checkbox]': 'true',
                            '[class.disabled]': 'disabled',
                            '[class.nx-checkbox--label-large]': 'labelSize === "large"',
                            '[class.nx-checkbox--label-small]': 'labelSize === "small"',
                            '[class.nx-checkbox--negative]': 'negative',
                            '[class.has-error]': '_controlInvalid() || null',
                            '[attr.required]': 'required',
                            '[attr.aria-invalid]': '_controlInvalid() || null',
                        },
                        styles: [":host{display:block;position:relative;margin-bottom:16px}:host.has-error .nx-checkbox__input:checked+.nx-checkbox__label .nx-checkbox__control{background-color:#dc3149;background-color:var(--danger,#dc3149);border-color:#dc3149;border-color:var(--danger,#dc3149)}:host.has-error .nx-checkbox__control{border-color:#dc3149;border-color:var(--danger,#dc3149)}:host.has-error .nx-checkbox__indeterminate-indicator{background-color:#dc3149;background-color:var(--danger,#dc3149)}.nx-checkbox__input{opacity:0;position:absolute}.nx-checkbox__label{font-size:16px;font-size:var(--checkbox-small-label-font-size,16px);line-height:24px;line-height:var(--checkbox-small-label-line-height,24px);font-weight:400;font-weight:var(--checkbox-small-label-font-weight,400);letter-spacing:0;letter-spacing:var(--checkbox-small-label-letter-spacing,0);color:#414141;color:var(--checkbox-label-color,#414141);cursor:pointer;display:flex}:host(.nx-checkbox--label-large) .nx-checkbox__label{font-size:20px;font-size:var(--checkbox-large-label-font-size,20px);line-height:28px;line-height:var(--checkbox-large-label-line-height,28px);font-weight:400;font-weight:var(--checkbox-large-label-font-weight,400);letter-spacing:.2px;letter-spacing:var(--checkbox-large-label-letter-spacing,.2px)}:host(.nx-checkbox--label-large) .has-label .nx-checkbox__label-text{margin-top:0;margin-top:var(--checkbox-large-label-text-margin-top,0)}:host(.nx-checkbox--label-large) .has-label .nx-checkbox__control{margin-top:2px;margin-top:var(--checkbox-large-label-control-margin-top,2px)}:host(.nx-checkbox--label-large) .nx-checkbox__label-text{margin-left:12px;margin-left:var(--checkbox-large-label-text-margin-left,12px)}:host(.nx-checkbox--label-small) .has-label .nx-checkbox__label-text{margin-top:0;margin-top:var(--checkbox-small-label-text-margin-top,0)}:host(.nx-checkbox--label-small) .has-label .nx-checkbox__control{margin-top:0;margin-top:var(--checkbox-small-label-control-margin-top,0)}.nx-checkbox__label-text{padding:0;margin-left:12px;margin-left:var(--checkbox-small-label-text-margin-left,12px)}.nx-checkbox__label-text:empty{display:none}.nx-checkbox__control{background-color:transparent;background-color:var(--checkbox-background-color,transparent);border-width:var(--checkbox-border-width,2px);border-color:var(--checkbox-border-color,#767676);border-radius:4px;border-radius:var(--checkbox-border-radius,4px);color:#fff;color:var(--checkbox-icon-color,#fff);font-size:20px;font-size:var(--checkbox-icon-size,20px);height:24px;height:var(--checkbox-control-size,24px);width:24px;width:var(--checkbox-control-size,24px);min-width:24px;min-width:var(--checkbox-control-size,24px);display:flex;justify-content:center;align-items:center;z-index:0;cursor:pointer;border:2px solid #767676}.nx-checkbox__indeterminate-indicator{color:#007ab3;color:var(--checkbox-indeterminate-color,#007ab3);box-sizing:content-box;height:0;width:8px;border:1px solid;border-radius:2px}.nx-checkbox__input:checked+.nx-checkbox__label .nx-checkbox__control{background-color:#007ab3;background-color:var(--checkbox-selected-background-color,#007ab3);border-color:#007ab3;border-color:var(--checkbox-selected-border-color,#007ab3)}.nx-checkbox__input:disabled+.nx-checkbox__label .nx-checkbox__control{background-color:#ececec;background-color:var(--checkbox-disabled-background-color,#ececec);border-color:#c2c2c2;border-color:var(--checkbox-disabled-border-color,#c2c2c2);color:#fff;color:var(--checkbox-disabled-icon-color,#fff);cursor:not-allowed}.nx-checkbox__input:checked:disabled+.nx-checkbox__label .nx-checkbox__control{background-color:#c2c2c2;background-color:var(--checkbox-disabled-selected-background-color,#c2c2c2)}.nx-checkbox__input:disabled+.nx-checkbox__label{cursor:not-allowed;color:#c2c2c2;color:var(--checkbox-label-disabled-color,#c2c2c2)}.nx-checkbox__input:disabled+.nx-checkbox__label .nx-checkbox__indeterminate-indicator{color:#c2c2c2;color:var(--checkbox-disabled-border-color,#c2c2c2)}:host(.nx-checkbox--negative) .nx-checkbox__control{border-color:#fff;background-color:transparent}:host(.nx-checkbox--negative) .nx-checkbox__label{color:#fff}:host(.nx-checkbox--negative) .nx-checkbox__input:checked+.nx-checkbox__label .nx-checkbox__control{color:#000;background-color:#fff;border-color:#fff}:host(.nx-checkbox--negative) .nx-checkbox__input:checked:disabled+.nx-checkbox__label .nx-checkbox__control{color:rgba(255,255,255,.4);border-color:transparent;background-color:rgba(194,194,194,.4)}:host(.nx-checkbox--negative) .nx-checkbox__input:disabled+.nx-checkbox__label{color:rgba(255,255,255,.4)}:host(.nx-checkbox--negative) .nx-checkbox__input:disabled+.nx-checkbox__label .nx-checkbox__control{background-color:rgba(153,153,153,.4);border-color:rgba(217,217,217,.4)}:host(.nx-checkbox--negative) .nx-checkbox__input:disabled+.nx-checkbox__label .nx-checkbox__indeterminate-indicator{background-color:rgba(217,217,217,.4)}:host:not(.nx-checkbox--negative):not(.has-error):hover .nx-checkbox__input:not([disabled]):checked+.nx-checkbox__label .nx-checkbox__control{background-color:#006192;background-color:var(--checkbox-hover-background-color,#006192)}:host:not(.nx-checkbox--negative):not(.has-error):hover .nx-checkbox__input:not([disabled]):checked+.nx-checkbox__label .nx-checkbox__indeterminate-indicator{background-color:#006192;background-color:var(--checkbox-hover-background-color,#006192)}:host:not(.nx-checkbox--negative):not(.has-error):hover .nx-checkbox__input:not([disabled])+.nx-checkbox__label .nx-checkbox__control{border-color:#006192;border-color:var(--checkbox-hover-border-color,#006192)}:host:not(.nx-checkbox--negative):active .nx-checkbox__input:not([disabled]):checked+.nx-checkbox__label .nx-checkbox__control{background-color:#003781;background-color:var(--checkbox-active-background-color,#003781)}:host:not(.nx-checkbox--negative):active .nx-checkbox__input:not([disabled]):checked+.nx-checkbox__label .nx-checkbox__indeterminate-indicator{background-color:#003781;background-color:var(--checkbox-active-background-color,#003781)}:host:not(.nx-checkbox--negative):active .nx-checkbox__input:not([disabled])+.nx-checkbox__label .nx-checkbox__control{border-color:#003781;border-color:var(--checkbox-active-border-color,#003781)}:host-context([data-whatinput=keyboard]) .nx-checkbox__input:focus+.nx-checkbox__label .nx-checkbox__control{box-shadow:0 0 0 2px #fff,0 0 0 6px #009de6;box-shadow:var(--focus-box-shadow,0 0 0 2px #fff,0 0 0 6px #009de6)}@media screen and (-ms-high-contrast:active){:host-context([data-whatinput=keyboard]) .nx-checkbox__input:focus+.nx-checkbox__label .nx-checkbox__control{box-shadow:0 0 0 2px background,0 0 0 6px windowText}.nx-checkbox__input+.nx-checkbox__label .nx-checkbox__control{border-color:buttonText;background-color:buttonFace}.nx-checkbox__input+.nx-checkbox__label .nx-checkbox__label-text{color:buttonText}.nx-checkbox__input:checked+.nx-checkbox__label .nx-checkbox__control{background-color:highlight;border-color:highlight}.nx-checkbox__input:checked+.nx-checkbox__label .nx-checkbox__control nx-icon{color:highlightText}.nx-checkbox__input:indeterminate+.nx-checkbox__label .nx-checkbox__indeterminate-indicator{color:buttonText}.nx-checkbox__input:disabled+.nx-checkbox__label .nx-checkbox__control nx-icon,.nx-checkbox__input:disabled+.nx-checkbox__label .nx-checkbox__label-text{color:GrayText}.nx-checkbox__input:disabled:indeterminate+.nx-checkbox__label .nx-checkbox__indeterminate-indicator{color:GrayText}.nx-checkbox__input:disabled+.nx-checkbox__label .nx-checkbox__control{border-color:GrayText}.nx-checkbox__input:disabled:checked+.nx-checkbox__label .nx-checkbox__control{background-color:buttonFace}.nx-checkbox__input:disabled:checked+.nx-checkbox__label .nx-checkbox__control nx-icon{color:GrayText}}"]
                    }] }
        ];
        /** @nocollapse */
        NxCheckboxComponent.ctorParameters = function () { return [
            { type: core.ChangeDetectorRef },
            { type: utils.ErrorStateMatcher },
            { type: NxCheckboxGroupComponent, decorators: [{ type: core.Optional }] },
            { type: forms.NgControl, decorators: [{ type: core.Self }, { type: core.Optional }] },
            { type: forms.NgForm, decorators: [{ type: core.Optional }] },
            { type: forms.FormGroupDirective, decorators: [{ type: core.Optional }] }
        ]; };
        NxCheckboxComponent.propDecorators = {
            _checkboxLabelWrapper: [{ type: core.ViewChild, args: ['checkboxLabelWrapper', { static: true },] }],
            id: [{ type: core.Input }],
            name: [{ type: core.Input }],
            disabled: [{ type: core.Input }],
            labelSize: [{ type: core.Input }],
            negative: [{ type: core.Input }],
            checked: [{ type: core.Input }],
            indeterminate: [{ type: core.Input }],
            required: [{ type: core.Input }],
            value: [{ type: core.Input }],
            indeterminateChange: [{ type: core.Output }],
            checkedChange: [{ type: core.Output }],
            checkboxChange: [{ type: core.Output }]
        };
        return NxCheckboxComponent;
    }());
    if (false) {
        /**
         * @type {?}
         * @private
         */
        NxCheckboxComponent.prototype._parentChangeSubscription;
        /**
         * @type {?}
         * @private
         */
        NxCheckboxComponent.prototype._id;
        /**
         * @type {?}
         * @private
         */
        NxCheckboxComponent.prototype._disabled;
        /**
         * @type {?}
         * @private
         */
        NxCheckboxComponent.prototype._negative;
        /**
         * @type {?}
         * @private
         */
        NxCheckboxComponent.prototype._labelSize;
        /**
         * @type {?}
         * @private
         */
        NxCheckboxComponent.prototype._checked;
        /**
         * @type {?}
         * @private
         */
        NxCheckboxComponent.prototype._name;
        /**
         * \@docs-private
         * @type {?}
         */
        NxCheckboxComponent.prototype._checkboxLabelWrapper;
        /**
         * @type {?}
         * @private
         */
        NxCheckboxComponent.prototype._indeterminate;
        /**
         * @type {?}
         * @private
         */
        NxCheckboxComponent.prototype._required;
        /**
         * @type {?}
         * @private
         */
        NxCheckboxComponent.prototype._value;
        /**
         * An event emitted when the indeterminate value has changed
         * @type {?}
         */
        NxCheckboxComponent.prototype.indeterminateChange;
        /**
         * An event emitted when the checked value has changed.
         *
         * Emits the boolean checked value of the changed checkbox.
         * @type {?}
         */
        NxCheckboxComponent.prototype.checkedChange;
        /**
         * An event emitted when the checked value has changed.
         *
         * Emits a NxCheckboxChangeEvent.
         * @type {?}
         */
        NxCheckboxComponent.prototype.checkboxChange;
        /**
         * @type {?}
         * @private
         */
        NxCheckboxComponent.prototype.onChangeCallback;
        /**
         * @type {?}
         * @private
         */
        NxCheckboxComponent.prototype.onTouchedCallback;
        /**
         * @type {?}
         * @private
         */
        NxCheckboxComponent.prototype._changeDetectorRef;
        /**
         * @type {?}
         * @private
         */
        NxCheckboxComponent.prototype._errorStateMatcher;
        /** @type {?} */
        NxCheckboxComponent.prototype.checkboxGroup;
        /** @type {?} */
        NxCheckboxComponent.prototype.ngControl;
        /**
         * @type {?}
         * @private
         */
        NxCheckboxComponent.prototype._parentForm;
        /**
         * @type {?}
         * @private
         */
        NxCheckboxComponent.prototype._parentFormGroup;
    }

    /**
     * @fileoverview added by tsickle
     * Generated from: checkbox/checkbox.module.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var NxCheckboxModule = /** @class */ (function () {
        function NxCheckboxModule() {
        }
        NxCheckboxModule.decorators = [
            { type: core.NgModule, args: [{
                        declarations: [
                            NxCheckboxComponent,
                            NxCheckboxGroupComponent
                        ],
                        exports: [
                            NxCheckboxComponent,
                            NxCheckboxGroupComponent,
                            base.NxLabelModule,
                            base.NxErrorModule
                        ],
                        imports: [
                            common.CommonModule,
                            icon.NxIconModule,
                            observers.ObserversModule
                        ]
                    },] }
        ];
        return NxCheckboxModule;
    }());

    /**
     * @fileoverview added by tsickle
     * Generated from: checkbox/public-api.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * Generated from: radio-button/radio-button.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * The change event object emitted by the radio group and radio button.
     */
    var   /**
     * The change event object emitted by the radio group and radio button.
     */
    NxRadioChange = /** @class */ (function () {
        /** The NxRadioComponent that emits the change event. NxRadioChange object can be instantiated with source radio component and a value. */
        function NxRadioChange(source, value) {
            this.source = source;
            this.value = value;
        }
        return NxRadioChange;
    }());
    if (false) {
        /** @type {?} */
        NxRadioChange.prototype.source;
        /** @type {?} */
        NxRadioChange.prototype.value;
    }
    /** @type {?} */
    var nextId$1 = 0;
    var NxRadioGroupComponent = /** @class */ (function () {
        function NxRadioGroupComponent(_changeDetectorRef, ngControl, _parentForm, _parentFormGroup) {
            this._changeDetectorRef = _changeDetectorRef;
            this.ngControl = ngControl;
            this._parentForm = _parentForm;
            this._parentFormGroup = _parentFormGroup;
            // emits when the internal state changes on properties which are relevant
            // for the radio buttons so that they can mark themself for check
            this._stateChanges = new rxjs.Subject();
            this._id = "nx-radio-group-" + nextId$1++;
            this._disabled = false;
            this._negative = false;
            this._required = false;
            /**
             * An event is dispatched on each group value change.
             */
            this.groupValueChange = new core.EventEmitter();
            this._name = "nx-radio-group-" + nextId$1++;
            this._value = null;
            // The currently selected radio button; should match _value
            this._selected = null;
            this._onChange = (/**
             * @return {?}
             */
            function () { });
            this._onTouched = (/**
             * @return {?}
             */
            function () { });
            if (this.ngControl) {
                // Note: we provide the value accessor through here, instead of
                // the `providers` to avoid running into a circular import.
                this.ngControl.valueAccessor = this;
            }
        }
        Object.defineProperty(NxRadioGroupComponent.prototype, "id", {
            get: /**
             * @return {?}
             */
            function () {
                return this._id;
            },
            /** Sets the Id of the radio group. */
            set: /**
             * Sets the Id of the radio group.
             * @param {?} value
             * @return {?}
             */
            function (value) {
                if (this._id !== value) {
                    this._id = value;
                    this._changeDetectorRef.markForCheck();
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NxRadioGroupComponent.prototype, "disabled", {
            get: /**
             * @return {?}
             */
            function () {
                return this._disabled;
            },
            /** Whether every radio button in this group should be disabled. */
            set: /**
             * Whether every radio button in this group should be disabled.
             * @param {?} value
             * @return {?}
             */
            function (value) {
                this._disabled = coercion.coerceBooleanProperty(value);
                // inform childs about the change where CD should be triggered
                this._stateChanges.next();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NxRadioGroupComponent.prototype, "negative", {
            get: /**
             * @return {?}
             */
            function () {
                return this._negative;
            },
            /** Whether the radio group should have negative styling. */
            set: /**
             * Whether the radio group should have negative styling.
             * @param {?} value
             * @return {?}
             */
            function (value) {
                this._negative = coercion.coerceBooleanProperty(value);
                this._changeDetectorRef.markForCheck();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NxRadioGroupComponent.prototype, "required", {
            get: /**
             * @return {?}
             */
            function () {
                return this._required;
            },
            /** Sets if at least an option should be selected. */
            set: /**
             * Sets if at least an option should be selected.
             * @param {?} value
             * @return {?}
             */
            function (value) {
                this._required = coercion.coerceBooleanProperty(value);
                this._stateChanges.next();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NxRadioGroupComponent.prototype, "name", {
            get: /**
             * @return {?}
             */
            function () {
                return this._name;
            },
            // this is also the name attribute, which is mandatory in conjunction with ngModel, hence no nx prefix
            /** Sets the name of this radio group, which is mandatory in conjunction with ngModel (Default: null). */
            set: 
            // this is also the name attribute, which is mandatory in conjunction with ngModel, hence no nx prefix
            /**
             * Sets the name of this radio group, which is mandatory in conjunction with ngModel (Default: null).
             * @param {?} value
             * @return {?}
             */
            function (value) {
                this._name = value;
                this._stateChanges.next();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NxRadioGroupComponent.prototype, "value", {
            get: /**
             * @return {?}
             */
            function () { return this._value; },
            /** Sets the value of the selected radion button in this group (Default: null). */
            set: /**
             * Sets the value of the selected radion button in this group (Default: null).
             * @param {?} newValue
             * @return {?}
             */
            function (newValue) {
                if (this._value !== newValue) {
                    // Set this before proceeding to ensure no circular loop occurs with selection.
                    this._value = newValue;
                    this._updateSelectedRadioFromValue();
                    this._checkSelectedRadioButton();
                }
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        NxRadioGroupComponent.prototype.ngAfterContentInit = /**
         * @return {?}
         */
        function () {
            this._updateSelectedRadioFromValue();
            this._checkSelectedRadioButton();
        };
        /**
         * @return {?}
         */
        NxRadioGroupComponent.prototype.ngOnDestroy = /**
         * @return {?}
         */
        function () {
            this._stateChanges.complete();
        };
        /**
         * @param {?} value
         * @return {?}
         */
        NxRadioGroupComponent.prototype.writeValue = /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this.value = value;
        };
        /**
         * @param {?} fn
         * @return {?}
         */
        NxRadioGroupComponent.prototype.registerOnChange = /**
         * @param {?} fn
         * @return {?}
         */
        function (fn) {
            this._onChange = fn;
        };
        /**
         * @param {?} fn
         * @return {?}
         */
        NxRadioGroupComponent.prototype.registerOnTouched = /**
         * @param {?} fn
         * @return {?}
         */
        function (fn) {
            this._onTouched = fn;
        };
        /** @docs-private this is meant to be called by the radio buttons in this group */
        /**
         * \@docs-private this is meant to be called by the radio buttons in this group
         * @param {?} value
         * @return {?}
         */
        NxRadioGroupComponent.prototype.change = /**
         * \@docs-private this is meant to be called by the radio buttons in this group
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this.value = value;
            this._onChange(value);
            this.groupValueChange.emit(new NxRadioChange(this._selected, this._value));
        };
        /** @docs-private this is meant to be called by the radio buttons in this group. */
        /**
         * \@docs-private this is meant to be called by the radio buttons in this group.
         * @return {?}
         */
        NxRadioGroupComponent.prototype.touch = /**
         * \@docs-private this is meant to be called by the radio buttons in this group.
         * @return {?}
         */
        function () {
            if (this._onTouched) {
                this._onTouched();
            }
        };
        /**
         * @param {?} isDisabled
         * @return {?}
         */
        NxRadioGroupComponent.prototype.setDisabledState = /**
         * @param {?} isDisabled
         * @return {?}
         */
        function (isDisabled) {
            this.disabled = isDisabled;
        };
        /**
         * @private
         * @return {?}
         */
        NxRadioGroupComponent.prototype._updateSelectedRadioFromValue = /**
         * @private
         * @return {?}
         */
        function () {
            var _this = this;
            // If the value already matches the selected radio, do nothing.
            /** @type {?} */
            var isAlreadySelected = this._selected != null && this._selected.value === this._value;
            if (this._radios != null && !isAlreadySelected) {
                this._selected = null;
                this._radios.forEach((/**
                 * @param {?} radio
                 * @return {?}
                 */
                function (radio) {
                    radio.checked = _this.value === radio.value;
                    if (radio.checked) {
                        _this._selected = radio;
                    }
                }));
            }
        };
        /**
         * @private
         * @return {?}
         */
        NxRadioGroupComponent.prototype._checkSelectedRadioButton = /**
         * @private
         * @return {?}
         */
        function () {
            if (this._selected && !this._selected.checked) {
                this._selected.checked = true;
            }
        };
        NxRadioGroupComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'nx-radio-group',
                        template: "<div>\n  <div class=\"nx-radio-group__label\">\n    <ng-content select=\"nx-label\"></ng-content>\n  </div>\n  <div class=\"nx-radio-group__errors\">\n    <ng-content select=\"nx-error\"></ng-content>\n  </div>\n  <div class=\"nx-radio-group__controls\">\n    <ng-content></ng-content>\n  </div>\n</div>\n",
                        changeDetection: core.ChangeDetectionStrategy.OnPush,
                        host: {
                            'role': 'radiogroup',
                            '[attr.id]': 'id',
                            '[attr.required]': 'required',
                            '[class.nx-radio-group--negative]': 'negative',
                            '[attr.aria-labelledby]': 'this._label?.id  || null'
                        },
                        styles: [":host ::ng-deep nx-error{margin-bottom:8px}:host ::ng-deep nx-label{margin-bottom:16px;display:block}"]
                    }] }
        ];
        /** @nocollapse */
        NxRadioGroupComponent.ctorParameters = function () { return [
            { type: core.ChangeDetectorRef },
            { type: forms.NgControl, decorators: [{ type: core.Optional }, { type: core.Self }] },
            { type: forms.NgForm, decorators: [{ type: core.Optional }] },
            { type: forms.FormGroupDirective, decorators: [{ type: core.Optional }] }
        ]; };
        NxRadioGroupComponent.propDecorators = {
            _label: [{ type: core.ContentChild, args: [core.forwardRef((/**
                         * @return {?}
                         */
                        function () { return base.NxLabelComponent; })), { static: false },] }],
            id: [{ type: core.Input, args: ['id',] }],
            disabled: [{ type: core.Input, args: ['nxDisabled',] }],
            negative: [{ type: core.Input }],
            required: [{ type: core.Input }],
            groupValueChange: [{ type: core.Output, args: ['nxGroupValueChange',] }],
            _radios: [{ type: core.ContentChildren, args: [core.forwardRef((/**
                         * @return {?}
                         */
                        function () { return NxRadioComponent; })), { descendants: true },] }],
            name: [{ type: core.Input }],
            value: [{ type: core.Input, args: ['nxValue',] }]
        };
        return NxRadioGroupComponent;
    }());
    if (false) {
        /** @type {?} */
        NxRadioGroupComponent.prototype._label;
        /** @type {?} */
        NxRadioGroupComponent.prototype._stateChanges;
        /**
         * @type {?}
         * @private
         */
        NxRadioGroupComponent.prototype._id;
        /**
         * @type {?}
         * @private
         */
        NxRadioGroupComponent.prototype._disabled;
        /**
         * @type {?}
         * @private
         */
        NxRadioGroupComponent.prototype._negative;
        /**
         * @type {?}
         * @private
         */
        NxRadioGroupComponent.prototype._required;
        /**
         * An event is dispatched on each group value change.
         * @type {?}
         */
        NxRadioGroupComponent.prototype.groupValueChange;
        /**
         * @type {?}
         * @private
         */
        NxRadioGroupComponent.prototype._name;
        /**
         * @type {?}
         * @private
         */
        NxRadioGroupComponent.prototype._value;
        /**
         * @type {?}
         * @private
         */
        NxRadioGroupComponent.prototype._selected;
        /** @type {?} */
        NxRadioGroupComponent.prototype._radios;
        /**
         * @type {?}
         * @private
         */
        NxRadioGroupComponent.prototype._onChange;
        /**
         * @type {?}
         * @private
         */
        NxRadioGroupComponent.prototype._onTouched;
        /**
         * @type {?}
         * @private
         */
        NxRadioGroupComponent.prototype._changeDetectorRef;
        /** @type {?} */
        NxRadioGroupComponent.prototype.ngControl;
        /** @type {?} */
        NxRadioGroupComponent.prototype._parentForm;
        /** @type {?} */
        NxRadioGroupComponent.prototype._parentFormGroup;
    }
    var NxRadioComponent = /** @class */ (function () {
        function NxRadioComponent(radioGroup, _changeDetectorRef) {
            this.radioGroup = radioGroup;
            this._changeDetectorRef = _changeDetectorRef;
            this._id = "nx-radio-" + nextId$1++;
            this._name = null;
            this._labelSize = 'big';
            this._negative = false;
            /**
             * An event is dispatched on each value change.
             */
            this.valueChange = new core.EventEmitter();
            this._value = null;
            this._checked = false;
            this._disabled = false;
            this._required = false;
            this.onChangeCallback = (/**
             * @param {?} _
             * @return {?}
             */
            function (_) { });
            this.onTouchedCallback = (/**
             * @return {?}
             */
            function () { });
        }
        Object.defineProperty(NxRadioComponent.prototype, "id", {
            get: /**
             * @return {?}
             */
            function () {
                return this._id;
            },
            /** Sets the id of the radio component. */
            set: /**
             * Sets the id of the radio component.
             * @param {?} value
             * @return {?}
             */
            function (value) {
                if (this._id !== value) {
                    this._id = value;
                    this._changeDetectorRef.markForCheck();
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NxRadioComponent.prototype, "inputId", {
            /** @docs-private */
            get: /**
             * \@docs-private
             * @return {?}
             */
            function () {
                return this.id + "-input";
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NxRadioComponent.prototype, "labelId", {
            /** @docs-private */
            get: /**
             * \@docs-private
             * @return {?}
             */
            function () {
                return this.id + "-label";
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NxRadioComponent.prototype, "name", {
            get: /**
             * @return {?}
             */
            function () {
                return (this.radioGroup && this.radioGroup.name) ? this.radioGroup.name : this._name;
            },
            // this is also the name attribute, which is mandatory in conjunction with ngModel, hence no nx prefix
            /** Sets the name of this radio component, which is mandatory in conjunction with ngModel (Default: null). */
            set: 
            // this is also the name attribute, which is mandatory in conjunction with ngModel, hence no nx prefix
            /**
             * Sets the name of this radio component, which is mandatory in conjunction with ngModel (Default: null).
             * @param {?} value
             * @return {?}
             */
            function (value) {
                if (this._name !== value) {
                    this._name = value;
                    this._changeDetectorRef.markForCheck();
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NxRadioComponent.prototype, "labelSize", {
            get: /**
             * @return {?}
             */
            function () {
                return this._labelSize;
            },
            /** Sets the label size of the radio button.
             * The default value is `big`.
            */
            set: /**
             * Sets the label size of the radio button.
             * The default value is `big`.
             * @param {?} value
             * @return {?}
             */
            function (value) {
                if (this._labelSize !== value) {
                    this._labelSize = value;
                    this._changeDetectorRef.markForCheck();
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NxRadioComponent.prototype, "negative", {
            get: /**
             * @return {?}
             */
            function () {
                return this.radioGroup ? this.radioGroup.negative : this._negative;
            },
            /**
             * Whether the negative set of styles should be used.
             *
             * If the radio button is placed in a radio group, the negative value
             * is overwritten by the group's negative value.
             */
            set: /**
             * Whether the negative set of styles should be used.
             *
             * If the radio button is placed in a radio group, the negative value
             * is overwritten by the group's negative value.
             * @param {?} value
             * @return {?}
             */
            function (value) {
                /** @type {?} */
                var newValue = coercion.coerceBooleanProperty(value);
                if (this._negative !== newValue) {
                    this._negative = newValue;
                    this._changeDetectorRef.markForCheck();
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NxRadioComponent.prototype, "value", {
            get: /**
             * @return {?}
             */
            function () {
                return this._value;
            },
            /** Sets the value of the form control element (Default: null). */
            set: /**
             * Sets the value of the form control element (Default: null).
             * @param {?} value
             * @return {?}
             */
            function (value) {
                if (value !== this._value) {
                    this._value = value;
                    this.onChangeCallback(value);
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NxRadioComponent.prototype, "labelHasContent", {
            /** @docs-private */
            get: /**
             * \@docs-private
             * @return {?}
             */
            function () {
                return !!this._radioLabelWrapper.nativeElement.innerHTML.trim();
            },
            enumerable: true,
            configurable: true
        });
        /** @docs-private
         * Callback for when the content of the label has changed.
         */
        /**
         * \@docs-private
         * Callback for when the content of the label has changed.
         * @return {?}
         */
        NxRadioComponent.prototype.labelContentChanged = /**
         * \@docs-private
         * Callback for when the content of the label has changed.
         * @return {?}
         */
        function () {
            this._changeDetectorRef.detectChanges();
        };
        Object.defineProperty(NxRadioComponent.prototype, "checked", {
            /** @docs-private */
            get: /**
             * \@docs-private
             * @return {?}
             */
            function () {
                return this._checked;
            },
            /** Whether the radio component is selected. */
            set: /**
             * Whether the radio component is selected.
             * @param {?} value
             * @return {?}
             */
            function (value) {
                if (this._checked !== value) {
                    this._checked = value;
                    this._changeDetectorRef.markForCheck();
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NxRadioComponent.prototype, "disabled", {
            /** @docs-private */
            get: /**
             * \@docs-private
             * @return {?}
             */
            function () {
                return this._disabled || (this.radioGroup && this.radioGroup.disabled);
            },
            /** Whether the radio button should be disabled or not. */
            set: /**
             * Whether the radio button should be disabled or not.
             * @param {?} value
             * @return {?}
             */
            function (value) {
                this._disabled = coercion.coerceBooleanProperty(value);
                this._changeDetectorRef.markForCheck();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NxRadioComponent.prototype, "required", {
            /** @docs-private */
            get: /**
             * \@docs-private
             * @return {?}
             */
            function () {
                return this._required || (this.radioGroup && this.radioGroup.required);
            },
            /** Sets if at least a radio button should be selected. */
            set: /**
             * Sets if at least a radio button should be selected.
             * @param {?} value
             * @return {?}
             */
            function (value) {
                this._required = value;
                // needed when the outer component is set to onPush because it is a native property
                // on the host element
                this._changeDetectorRef.markForCheck();
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        NxRadioComponent.prototype.ngOnInit = /**
         * @return {?}
         */
        function () {
            var _this = this;
            if (this.radioGroup) {
                this.name = this.radioGroup.name;
                // when relevant properties of the parent like name and disabled change
                // we need to let change detection know that the template needs an update
                this._parentChangeSubscription = this.radioGroup._stateChanges.subscribe((/**
                 * @return {?}
                 */
                function () {
                    _this._changeDetectorRef.markForCheck();
                }));
                if (this.radioGroup.value === this._value) {
                    this._checked = true;
                }
            }
        };
        /**
         * @return {?}
         */
        NxRadioComponent.prototype.ngOnDestroy = /**
         * @return {?}
         */
        function () {
            if (this._parentChangeSubscription) {
                this._parentChangeSubscription.unsubscribe();
            }
        };
        /**
         * @param {?} value
         * @return {?}
         */
        NxRadioComponent.prototype.writeValue = /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            if (value === this._value) {
                this._checked = true;
                this._changeDetectorRef.markForCheck();
            }
        };
        /**
         * @param {?} onChange
         * @return {?}
         */
        NxRadioComponent.prototype.registerOnChange = /**
         * @param {?} onChange
         * @return {?}
         */
        function (onChange) {
            this.onChangeCallback = onChange;
        };
        /**
         * @param {?} onTouched
         * @return {?}
         */
        NxRadioComponent.prototype.registerOnTouched = /**
         * @param {?} onTouched
         * @return {?}
         */
        function (onTouched) {
            this.onTouchedCallback = onTouched;
        };
        /** @docs-private */
        /**
         * \@docs-private
         * @return {?}
         */
        NxRadioComponent.prototype.touch = /**
         * \@docs-private
         * @return {?}
         */
        function () {
            this.onTouchedCallback();
            if (this.radioGroup) {
                this.radioGroup.touch();
            }
        };
        /**
         * @param {?} event
         * @return {?}
         */
        NxRadioComponent.prototype._onInputChange = /**
         * @param {?} event
         * @return {?}
         */
        function (event) {
            event.stopPropagation();
            this._checked = true;
            this.valueChange.emit(new NxRadioChange(this, this._value));
            this.onChangeCallback(this.value);
            if (this.radioGroup && this.value !== this.radioGroup.value) {
                this.radioGroup.change(this.value);
            }
        };
        /**
         * @param {?} event
         * @return {?}
         */
        NxRadioComponent.prototype._onInputClick = /**
         * @param {?} event
         * @return {?}
         */
        function (event) {
            // make sure click event propagation on the visually hidden input
            // are stopped to prevent multiple events bubbling up.
            event.stopPropagation();
        };
        /** @docs-private */
        /**
         * \@docs-private
         * @return {?}
         */
        NxRadioComponent.prototype._controlInvalid = /**
         * \@docs-private
         * @return {?}
         */
        function () {
            /** @type {?} */
            var form = this.radioGroup && (this.radioGroup._parentFormGroup || this.radioGroup._parentForm);
            return !!(this.radioGroup && this.radioGroup.ngControl && this.radioGroup.ngControl.invalid
                && (this.radioGroup.ngControl.touched || (form && form.submitted)));
        };
        NxRadioComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'nx-radio',
                        template: "<input\n  type=\"radio\"\n  [id]=\"inputId\"\n  [attr.name]=\"name\"\n  [disabled]=\"disabled\"\n  (blur)=\"touch()\"\n  (change)=\"_onInputChange($event)\"\n  (click)=\"_onInputClick($event)\"\n  [checked]=\"checked\"\n  [attr.aria-labelledby]=\"labelId\"\n  class=\"nx-radio__input\">\n<label [id]=\"labelId\" [attr.for]=\"inputId\" class=\"nx-radio__label\" [class.has-label]=\"labelHasContent\">\n    <div class=\"nx-radio__circle\">\n      <div *ngIf=\"checked\" class=\"nx-radio__dot\"></div>\n    </div>\n    <span class=\"nx-radio__label--text\" #radioLabelWrapper (cdkObserveContent)=\"labelContentChanged()\">\n      <ng-content></ng-content>\n    </span>\n</label>\n",
                        changeDetection: core.ChangeDetectionStrategy.OnPush,
                        providers: [
                            {
                                provide: forms.NG_VALUE_ACCESSOR,
                                useExisting: core.forwardRef((/**
                                 * @return {?}
                                 */
                                function () { return NxRadioComponent; })),
                                multi: true
                            }
                        ],
                        host: {
                            '[attr.required]': 'required',
                            '[class.nx-radio-button--small-label]': 'labelSize === "small"',
                            '[class.nx-radio-button--big-label]': 'labelSize === "big"',
                            '[class.nx-radio--negative]': 'negative',
                            '[class.has-error]': '_controlInvalid() || null',
                            '[attr.aria-invalid]': '_controlInvalid() || null',
                        },
                        styles: [":host{display:block;position:relative}.nx-radio__input{opacity:0;position:absolute}:host(.nx-radio-button--small-label) .nx-radio__label{font-size:16px;font-size:var(--radio-button-small-label-font-size,16px);line-height:24px;line-height:var(--radio-button-small-label-line-height,24px);font-weight:400;font-weight:var(--radio-button-small-label-font-weight,400);letter-spacing:0;letter-spacing:var(--radio-button-small-label-letter-spacing,0)}:host(.nx-radio-button--small-label) .nx-radio__label.has-label .nx-radio__circle{margin-top:0;margin-top:var(--radio-button-small-circle-margin-top,0)}:host(.nx-radio-button--small-label) .nx-radio__label--text:not(:empty){margin-left:12px;margin-left:var(--radio-button-small-label-margin-left,12px);margin-top:0;margin-top:var(--radio-button-small-label-margin-top,0)}:host(.nx-radio-button--big-label) .nx-radio__label{font-size:20px;font-size:var(--radio-button-large-label-font-size,20px);line-height:28px;line-height:var(--radio-button-large-label-line-height,28px);font-weight:400;font-weight:var(--radio-button-large-label-font-weight,400);letter-spacing:.2px;letter-spacing:var(--radio-button-large-label-letter-spacing,.2px)}:host(.nx-radio-button--big-label) .nx-radio__label.has-label .nx-radio__circle{margin-top:2px;margin-top:var(--radio-button-large-circle-margin-top,2px)}:host(.nx-radio-button--big-label) .nx-radio__label--text:not(:empty){margin-left:12px;margin-left:var(--radio-button-large-label-margin-left,12px);margin-top:0;margin-top:var(--radio-button-large-label-margin-top,0)}:host.nx-radio--negative .nx-radio__label--text{color:#fff}:host.nx-radio--negative .nx-radio__circle{border-color:#fff}:host.nx-radio--negative .nx-radio__input:checked+.nx-radio__label .nx-radio__circle{border-color:#fff;background-color:transparent}:host.nx-radio--negative .nx-radio__input:checked+.nx-radio__label .nx-radio__dot{background:#fff}:host.nx-radio--negative .nx-radio__input:disabled+.nx-radio__label{opacity:.4}.nx-radio__label{color:#414141;color:var(--radio-button-label-color,#414141);cursor:pointer;display:flex;position:relative}.nx-radio__circle{border-color:var(--radio-button-circle-color,#767676);border-radius:50%;width:24px;min-width:24px;height:24px;position:relative;display:flex;justify-content:center;align-items:center;border:2px solid #767676}.nx-radio__dot{width:8px;width:var(--radio-button-dot-size,8px);height:8px;height:var(--radio-button-dot-size,8px);background-color:transparent;background-color:var(--radio-button-dot-background-color,transparent);border-radius:50%;transition:background-color .2s}.nx-radio__input:checked+.nx-radio__label .nx-radio__circle{border-color:#007ab3;border-color:var(--radio-button-selected-circle-color,#007ab3);background-color:transparent;background-color:var(--radio-button-selected-background-color,transparent)}.nx-radio__input:checked+.nx-radio__label .nx-radio__dot{background-color:#007ab3;background-color:var(--radio-button-selected-dot-color,#007ab3)}.nx-radio__input:disabled+.nx-radio__label{cursor:not-allowed;color:#c2c2c2;color:var(--radio-button-disabled-text-color,#c2c2c2)}.nx-radio__input:disabled+.nx-radio__label .nx-radio__circle{border-color:#c2c2c2;border-color:var(--radio-button-disabled-border-color,#c2c2c2)}.nx-radio__input:checked:disabled+.nx-radio__label .nx-radio__circle{background-color:transparent;background-color:var(--radio-button-disabled-selected-background-color,transparent)}.nx-radio__input:checked:disabled+.nx-radio__label .nx-radio__dot{background-color:#c2c2c2;background-color:var(--radio-button-disabled-selected-dot-color,#c2c2c2)}:host.has-error .nx-radio__input+.nx-radio__label .nx-radio__circle{border-color:#dc3149;border-color:var(--danger,#dc3149)}:host.has-error .nx-radio__input+.nx-radio__label .nx-radio__dot{background-color:#dc3149;background-color:var(--danger,#dc3149)}:host-context([data-whatinput=keyboard]) .nx-radio__input:focus+.nx-radio__label .nx-radio__circle{box-shadow:0 0 0 2px #fff,0 0 0 6px #009de6;box-shadow:var(--focus-box-shadow,0 0 0 2px #fff,0 0 0 6px #009de6)}:host:not(.nx-radio--negative):not(.has-error) .nx-radio__input:not(:disabled)+.nx-radio__label:hover .nx-radio__circle{border-color:#006192;border-color:var(--radio-button-hover-circle-color,#006192)}:host:not(.nx-radio--negative):not(.has-error) .nx-radio__input:not(:disabled):checked+.nx-radio__label:hover .nx-radio__dot{background-color:#006192;background-color:var(--radio-button-hover-dot-color,#006192)}:host:not(.nx-radio--negative):not(.has-error) .nx-radio__input:not(:disabled)+.nx-radio__label:active .nx-radio__circle{border-color:#006192;border-color:var(--radio-button-hover-circle-color,#006192)}:host:not(.nx-radio--negative):not(.has-error) .nx-radio__input:not(:disabled):checked+.nx-radio__label:active .nx-radio__dot{background-color:#006192;background-color:var(--radio-button-hover-dot-color,#006192)}@media screen and (-ms-high-contrast:active){:host-context([data-whatinput=keyboard]) .nx-radio__input:focus+.nx-radio__label .nx-radio__circle{box-shadow:0 0 0 2px background,0 0 0 6px windowText}.nx-radio__label{color:buttonText}.nx-radio__circle{border-color:buttonText;background-color:buttonFace}.nx-radio__input:checked+.nx-radio__label .nx-radio__circle{border-color:highlight}.nx-radio__input:checked+.nx-radio__label .nx-radio__dot{background-color:highlight}.nx-radio__input:disabled+.nx-radio__label{color:GrayText}.nx-radio__input:disabled+.nx-radio__label .nx-radio__circle{border-color:GrayText}.nx-radio__input:checked:disabled+.nx-radio__label .nx-radio__dot{background-color:GrayText}}"]
                    }] }
        ];
        /** @nocollapse */
        NxRadioComponent.ctorParameters = function () { return [
            { type: NxRadioGroupComponent, decorators: [{ type: core.Optional }] },
            { type: core.ChangeDetectorRef }
        ]; };
        NxRadioComponent.propDecorators = {
            _radioLabelWrapper: [{ type: core.ViewChild, args: ['radioLabelWrapper', { static: true },] }],
            id: [{ type: core.Input, args: ['id',] }],
            name: [{ type: core.Input, args: ['name',] }],
            labelSize: [{ type: core.Input }],
            negative: [{ type: core.Input }],
            valueChange: [{ type: core.Output, args: ['nxValueChange',] }],
            value: [{ type: core.Input, args: ['nxValue',] }],
            checked: [{ type: core.Input, args: ['nxChecked',] }],
            disabled: [{ type: core.Input, args: ['nxDisabled',] }],
            required: [{ type: core.Input }]
        };
        return NxRadioComponent;
    }());
    if (false) {
        /**
         * \@docs-private
         * @type {?}
         */
        NxRadioComponent.prototype._radioLabelWrapper;
        /**
         * @type {?}
         * @private
         */
        NxRadioComponent.prototype._parentChangeSubscription;
        /**
         * @type {?}
         * @private
         */
        NxRadioComponent.prototype._id;
        /**
         * @type {?}
         * @private
         */
        NxRadioComponent.prototype._name;
        /**
         * @type {?}
         * @private
         */
        NxRadioComponent.prototype._labelSize;
        /**
         * @type {?}
         * @private
         */
        NxRadioComponent.prototype._negative;
        /**
         * An event is dispatched on each value change.
         * @type {?}
         */
        NxRadioComponent.prototype.valueChange;
        /**
         * @type {?}
         * @private
         */
        NxRadioComponent.prototype._value;
        /**
         * @type {?}
         * @private
         */
        NxRadioComponent.prototype._checked;
        /**
         * @type {?}
         * @private
         */
        NxRadioComponent.prototype._disabled;
        /**
         * @type {?}
         * @private
         */
        NxRadioComponent.prototype._required;
        /**
         * @type {?}
         * @private
         */
        NxRadioComponent.prototype.onChangeCallback;
        /**
         * @type {?}
         * @private
         */
        NxRadioComponent.prototype.onTouchedCallback;
        /** @type {?} */
        NxRadioComponent.prototype.radioGroup;
        /**
         * @type {?}
         * @private
         */
        NxRadioComponent.prototype._changeDetectorRef;
    }

    /**
     * @fileoverview added by tsickle
     * Generated from: radio-button/radio-button.module.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var NxRadioModule = /** @class */ (function () {
        function NxRadioModule() {
        }
        NxRadioModule.decorators = [
            { type: core.NgModule, args: [{
                        declarations: [
                            NxRadioComponent,
                            NxRadioGroupComponent
                        ],
                        exports: [
                            NxRadioComponent,
                            NxRadioGroupComponent,
                            base.NxErrorModule,
                            base.NxLabelModule
                        ],
                        imports: [
                            common.CommonModule,
                            icon.NxIconModule,
                            observers.ObserversModule
                        ]
                    },] }
        ];
        return NxRadioModule;
    }());

    /**
     * @fileoverview added by tsickle
     * Generated from: radio-button/public-api.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * Generated from: copytext/copytext.component.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /** @type {?} */
    var DEFAULT_TYPE$1 = 'normal';
    var NxCopytextComponent = /** @class */ (function () {
        function NxCopytextComponent() {
            /**
             * \@docs-private
             */
            this.type = DEFAULT_TYPE$1;
            /**
             * \@docs-private
             */
            this.negative = false;
        }
        Object.defineProperty(NxCopytextComponent.prototype, "classNames", {
            get: /**
             * @return {?}
             */
            function () {
                return this._classNames;
            },
            /**
             * Sets the type and whether the negative set of styling should be used.
             *
             * You can combine the values of type NxCopytextType and 'negative'.
             *
             * Default type: 'normal'
             */
            set: /**
             * Sets the type and whether the negative set of styling should be used.
             *
             * You can combine the values of type NxCopytextType and 'negative'.
             *
             * Default type: 'normal'
             * @param {?} value
             * @return {?}
             */
            function (value) {
                if (this._classNames === value) {
                    return;
                }
                this._classNames = value;
                var _a = __read(this._classNames.match(/small|medium|normal|large/) || [DEFAULT_TYPE$1], 1), _b = _a[0], type = _b === void 0 ? null : _b;
                this.type = (/** @type {?} */ (type));
                this.negative = !!this._classNames.match(/negative/);
            },
            enumerable: true,
            configurable: true
        });
        NxCopytextComponent.decorators = [
            { type: core.Component, args: [{
                        // tslint:disable-next-line:component-selector
                        selector: 'p[nxCopytext]',
                        template: "<ng-content></ng-content>",
                        changeDetection: core.ChangeDetectionStrategy.OnPush,
                        host: {
                            '[class.nx-copy]': 'true',
                            '[class.nx-copy--small]': 'type === "small"',
                            '[class.nx-copy--medium]': 'type === "medium"',
                            '[class.nx-copy--normal]': 'type === "normal"',
                            '[class.nx-copy--large]': 'type === "large"',
                            '[class.nx-copy--negative]': 'negative',
                        },
                        styles: [":host{margin:0 0 32px;font-size:16px;font-size:var(--paragraph-03-font-size,16px);line-height:24px;line-height:var(--paragraph-03-line-height,24px);font-weight:400;font-weight:var(--paragraph-03-font-weight,400);letter-spacing:0;letter-spacing:var(--paragraph-03-letter-spacing,0)}:host.nx-copy.nx-copy{font-weight:400}:host(.nx-copy--negative){color:#fff}:host(.nx-copy--small){font-size:12px;font-size:var(--paragraph-05-font-size,12px);line-height:16px;line-height:var(--paragraph-05-line-height,16px);font-weight:600;font-weight:var(--paragraph-05-font-weight,600);letter-spacing:.5px;letter-spacing:var(--paragraph-05-letter-spacing,.5px)}:host(.nx-copy--medium){font-size:14px;font-size:var(--paragraph-04-font-size,14px);line-height:20px;line-height:var(--paragraph-04-line-height,20px);font-weight:600;font-weight:var(--paragraph-04-font-weight,600);letter-spacing:.2px;letter-spacing:var(--paragraph-04-letter-spacing,.2px)}:host(.nx-copy--large){font-size:18px;font-size:var(--paragraph-02-font-size,18px);line-height:24px;line-height:var(--paragraph-02-line-height,24px);font-weight:400;font-weight:var(--paragraph-02-font-weight,400);letter-spacing:.2px;letter-spacing:var(--paragraph-02-letter-spacing,.2px)}"]
                    }] }
        ];
        NxCopytextComponent.propDecorators = {
            classNames: [{ type: core.Input, args: ['nxCopytext',] }]
        };
        return NxCopytextComponent;
    }());
    if (false) {
        /**
         * @type {?}
         * @private
         */
        NxCopytextComponent.prototype._classNames;
        /**
         * \@docs-private
         * @type {?}
         */
        NxCopytextComponent.prototype.type;
        /**
         * \@docs-private
         * @type {?}
         */
        NxCopytextComponent.prototype.negative;
    }

    /**
     * @fileoverview added by tsickle
     * Generated from: copytext/copytext.module.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var NxCopytextModule = /** @class */ (function () {
        function NxCopytextModule() {
        }
        NxCopytextModule.decorators = [
            { type: core.NgModule, args: [{
                        declarations: [NxCopytextComponent],
                        exports: [NxCopytextComponent]
                    },] }
        ];
        return NxCopytextModule;
    }());

    /**
     * @fileoverview added by tsickle
     * Generated from: copytext/public-api.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * Generated from: headline/headline.component.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /** @type {?} */
    var DEFAULT_TYPE$2 = 'section';
    var NxHeadlineComponent = /** @class */ (function () {
        function NxHeadlineComponent() {
            /**
             * \@docs-private
             */
            this.type = DEFAULT_TYPE$2;
            /**
             * \@docs-private
             */
            this.negative = false;
        }
        Object.defineProperty(NxHeadlineComponent.prototype, "classNames", {
            get: /**
             * @return {?}
             */
            function () {
                return this._classNames;
            },
            /** Changes the type of the headline which affects the visual appearance.
             * You can combine a HeadlineType and 'negative'. */
            set: /**
             * Changes the type of the headline which affects the visual appearance.
             * You can combine a HeadlineType and 'negative'.
             * @param {?} value
             * @return {?}
             */
            function (value) {
                if (this._classNames === value) {
                    return;
                }
                this._classNames = value;
                /** @type {?} */
                var typeRegex = /page-bold-caps|page|section|subsection-large|subsection-medium|subsection-small|subsection-xsmall/;
                var _a = __read(this._classNames.match(typeRegex) || [DEFAULT_TYPE$2], 1), _b = _a[0], type = _b === void 0 ? null : _b;
                this.type = (/** @type {?} */ (type));
                this.negative = !!this._classNames.match(/negative/);
            },
            enumerable: true,
            configurable: true
        });
        NxHeadlineComponent.decorators = [
            { type: core.Component, args: [{
                        // tslint:disable-next-line:component-selector
                        selector: '[nxHeadline]',
                        template: "<ng-content></ng-content>",
                        host: {
                            '[class.nx-heading--page]': 'type === "page"',
                            '[class.nx-heading--page-bold-caps]': 'type === "page-bold-caps"',
                            '[class.nx-heading--section]': 'type === "section"',
                            '[class.nx-heading--subsection-large]': 'type === "subsection-large"',
                            '[class.nx-heading--subsection-medium]': 'type === "subsection-medium"',
                            '[class.nx-heading--subsection-small]': 'type === "subsection-small"',
                            '[class.nx-heading--subsection-xsmall]': 'type === "subsection-xsmall"',
                            '[class.nx-heading--negative]': 'negative',
                        },
                        styles: [":host{margin:0}:host ::ng-deep .nx-link,:host ::ng-deep nx-link a,:host a{color:#006192;color:var(--link-color,#006192);font-size:inherit;font-weight:600;line-height:inherit;letter-spacing:inherit;text-decoration:none}:host(.nx-heading--page){font-size:54px;font-size:var(--heading-01-font-size,54px);line-height:60px;line-height:var(--heading-01-line-height,60px);font-weight:300;font-weight:var(--heading-01-font-weight,300);letter-spacing:.3px;letter-spacing:var(--heading-01-letter-spacing,.3px);margin-bottom:40px}@media (max-width:703px){:host(.nx-heading--page){font-size:40px;font-size:var(--heading-01-mobile-font-size,40px);line-height:48px;line-height:var(--heading-01-mobile-line-height,48px);font-weight:300;font-weight:var(--heading-01-mobile-font-weight,300);letter-spacing:.3px;letter-spacing:var(--heading-01-mobile-letter-spacing,.3px)}}:host(.nx-heading--section){font-size:40px;font-size:var(--heading-02-font-size,40px);line-height:48px;line-height:var(--heading-02-line-height,48px);font-weight:300;font-weight:var(--heading-02-font-weight,300);letter-spacing:.3px;letter-spacing:var(--heading-02-letter-spacing,.3px);margin-bottom:48px}@media (max-width:703px){:host(.nx-heading--section){font-size:35px;font-size:var(--heading-02-mobile-font-size,35px);line-height:40px;line-height:var(--heading-02-mobile-line-height,40px);font-weight:300;font-weight:var(--heading-02-mobile-font-weight,300);letter-spacing:.3px;letter-spacing:var(--heading-02-mobile-letter-spacing,.3px)}}:host(.nx-heading--subsection-large){font-size:30px;font-size:var(--heading-03-font-size,30px);line-height:36px;line-height:var(--heading-03-line-height,36px);font-weight:300;font-weight:var(--heading-03-font-weight,300);letter-spacing:.3px;letter-spacing:var(--heading-03-letter-spacing,.3px);margin-bottom:32px}@media (max-width:703px){:host(.nx-heading--subsection-large){font-size:26px;font-size:var(--heading-03-mobile-font-size,26px);line-height:32px;line-height:var(--heading-03-mobile-line-height,32px);font-weight:300;font-weight:var(--heading-03-mobile-font-weight,300);letter-spacing:.3px;letter-spacing:var(--heading-03-mobile-letter-spacing,.3px)}}:host(.nx-heading--subsection-medium){font-size:26px;font-size:var(--heading-04-font-size,26px);line-height:32px;line-height:var(--heading-04-line-height,32px);font-weight:300;font-weight:var(--heading-04-font-weight,300);letter-spacing:.3px;letter-spacing:var(--heading-04-letter-spacing,.3px);margin-bottom:40px}@media (max-width:703px){:host(.nx-heading--subsection-medium){font-size:24px;font-size:var(--heading-04-mobile-font-size,24px);line-height:32px;line-height:var(--heading-04-mobile-line-height,32px);font-weight:600;font-weight:var(--heading-04-mobile-font-weight,600);letter-spacing:.2px;letter-spacing:var(--heading-04-mobile-letter-spacing,.2px)}}:host(.nx-heading--subsection-small){font-size:24px;font-size:var(--heading-05-font-size,24px);line-height:32px;line-height:var(--heading-05-line-height,32px);font-weight:600;font-weight:var(--heading-05-font-weight,600);letter-spacing:.2px;letter-spacing:var(--heading-05-letter-spacing,.2px);margin-bottom:32px}@media (max-width:703px){:host(.nx-heading--subsection-small){font-size:20px;font-size:var(--heading-05-mobile-font-size,20px);line-height:28px;line-height:var(--heading-05-mobile-line-height,28px);font-weight:300;font-weight:var(--heading-05-mobile-font-weight,300);letter-spacing:.2px;letter-spacing:var(--heading-05-mobile-letter-spacing,.2px)}}:host(.nx-heading--subsection-xsmall){font-size:20px;font-size:var(--heading-06-font-size,20px);line-height:28px;line-height:var(--heading-06-line-height,28px);font-weight:300;font-weight:var(--heading-06-font-weight,300);letter-spacing:.2px;letter-spacing:var(--heading-06-letter-spacing,.2px);margin-bottom:24px}@media (max-width:703px){:host(.nx-heading--subsection-xsmall){font-size:18px;font-size:var(--heading-06-mobile-font-size,18px);line-height:28px;line-height:var(--heading-06-mobile-line-height,28px);font-weight:300;font-weight:var(--heading-06-mobile-font-weight,300);letter-spacing:.2px;letter-spacing:var(--heading-06-mobile-letter-spacing,.2px)}}:host(.nx-heading--negative){color:#fff}:host(.nx-heading--negative) ::ng-deep a{color:#fff}:host(.nx-heading--page-bold-caps){font-size:54px;font-size:var(--heading-01-font-size,54px);line-height:60px;line-height:var(--heading-01-line-height,60px);font-weight:var(--heading-01-font-weight,300);letter-spacing:.3px;letter-spacing:var(--heading-01-letter-spacing,.3px);font-weight:700;text-transform:uppercase;margin-bottom:8px}@media (max-width:703px){:host(.nx-heading--page-bold-caps){font-size:40px;font-size:var(--heading-01-mobile-font-size,40px);line-height:48px;line-height:var(--heading-01-mobile-line-height,48px);font-weight:var(--heading-01-mobile-font-weight,300);letter-spacing:.3px;letter-spacing:var(--heading-01-mobile-letter-spacing,.3px);font-weight:700;text-transform:uppercase}}"]
                    }] }
        ];
        NxHeadlineComponent.propDecorators = {
            classNames: [{ type: core.Input, args: ['nxHeadline',] }]
        };
        return NxHeadlineComponent;
    }());
    if (false) {
        /**
         * @type {?}
         * @private
         */
        NxHeadlineComponent.prototype._classNames;
        /**
         * \@docs-private
         * @type {?}
         */
        NxHeadlineComponent.prototype.type;
        /**
         * \@docs-private
         * @type {?}
         */
        NxHeadlineComponent.prototype.negative;
    }

    /**
     * @fileoverview added by tsickle
     * Generated from: headline/headline.module.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var NxHeadlineModule = /** @class */ (function () {
        function NxHeadlineModule() {
        }
        NxHeadlineModule.decorators = [
            { type: core.NgModule, args: [{
                        declarations: [NxHeadlineComponent],
                        exports: [NxHeadlineComponent]
                    },] }
        ];
        return NxHeadlineModule;
    }());

    /**
     * @fileoverview added by tsickle
     * Generated from: headline/public-api.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * Generated from: link/link.component.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /** @type {?} */
    var MAPPING = {
        'black': 'nx-link--black',
        'negative': 'nx-link--negative',
        'text': 'nx-link--text',
        'block': 'nx-link--block',
        'icon-right': 'nx-link--icon-right'
    };
    /** @type {?} */
    var DEFAULT_CLASSES = ['nx-link'];
    var NxLinkComponent = /** @class */ (function (_super) {
        __extends(NxLinkComponent, _super);
        function NxLinkComponent(_elementRef, _renderer, _changeDetectorRef) {
            var _this = _super.call(this, MAPPING, DEFAULT_CLASSES, _elementRef, _renderer) || this;
            _this._renderer = _renderer;
            _this._changeDetectorRef = _changeDetectorRef;
            _this._size = 'small';
            return _this;
        }
        Object.defineProperty(NxLinkComponent.prototype, "size", {
            get: /**
             * @return {?}
             */
            function () {
                return this._size;
            },
            /** Sets the size of the link. Default: 'small'. */
            set: /**
             * Sets the size of the link. Default: 'small'.
             * @param {?} value
             * @return {?}
             */
            function (value) {
                if (this._size !== value) {
                    this._size = value;
                    this._changeDetectorRef.markForCheck();
                }
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        NxLinkComponent.prototype.ngAfterContentInit = /**
         * @return {?}
         */
        function () {
            // Add a specific link class that the css gets more specific than the nx-icon css
            /** @type {?} */
            var icons = this.elementRef.nativeElement.querySelectorAll('nx-icon');
            for (var i = 0; i < icons.length; i++) {
                this._renderer.addClass(icons[i], 'nx-link__icon');
            }
        };
        Object.defineProperty(NxLinkComponent.prototype, "elementRef", {
            /**
             * @docs-private
             * getter used for the modal component as a quickfix
             * since button got changed from directive to component the reference used by the ngOpenModelOnClick directive
             * for nxButtons is a reference to component instance instead of an element reference. As a workaround we need a
             * way to reach the elementRef of the component until the modal gets refactored.
             */
            get: /**
             * \@docs-private
             * getter used for the modal component as a quickfix
             * since button got changed from directive to component the reference used by the ngOpenModelOnClick directive
             * for nxButtons is a reference to component instance instead of an element reference. As a workaround we need a
             * way to reach the elementRef of the component until the modal gets refactored.
             * @return {?}
             */
            function () {
                return this._elementRef;
            },
            enumerable: true,
            configurable: true
        });
        NxLinkComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'nx-link',
                        changeDetection: core.ChangeDetectionStrategy.OnPush,
                        template: '<ng-content></ng-content>',
                        inputs: ['classNames: nxStyle'],
                        host: {
                            '[class.nx-link--small]': 'this.size === "small"',
                            '[class.nx-link--large]': 'this.size === "large"'
                        },
                        styles: [":host{color:#006192;color:var(--link-color,#006192);display:inline-block;cursor:pointer;position:relative;text-decoration:none;transition:color .2s,box-shadow .2s;-webkit-hyphens:none;-ms-hyphens:none;hyphens:none}:host:hover{color:#008ed6;color:var(--link-hover-color,#008ed6)}:host::ng-deep a:active{color:#003781;color:var(--link-active-color,#003781)}:host::ng-deep a{display:flex;align-items:center}:host.nx-link--small{font-size:16px;font-size:var(--link-small-font-size,16px);line-height:24px;line-height:var(--link-small-line-height,24px);font-weight:600;font-weight:var(--link-small-font-weight,600);letter-spacing:1px;letter-spacing:var(--link-small-letter-spacing,1px)}:host.nx-link--large{font-size:30px;font-size:var(--link-large-font-size,30px);line-height:36px;line-height:var(--link-large-line-height,36px);font-weight:600;font-weight:var(--link-large-font-weight,600);letter-spacing:.3px;letter-spacing:var(--link-large-letter-spacing,.3px)}:host-context([data-whatinput=keyboard])::ng-deep a:focus{border-radius:4px;outline:0;box-shadow:0 0 0 2px #fff,0 0 0 6px #009de6;box-shadow:var(--focus-box-shadow,0 0 0 2px #fff,0 0 0 6px #009de6)}:host(.nx-link--negative){color:#fff}:host(.nx-link--negative):hover{color:#c2c2c2}:host(.nx-link--negative)::ng-deep a:active{color:#999}:host(.nx-link--negative)::ng-deep a[aria-disabled],:host(.nx-link--negative)::ng-deep a[disabled]{color:rgba(255,255,255,.4)}:host(.nx-link--black){color:#414141;color:var(--link-black-color,#414141)}:host(.nx-link--black):hover{color:#999;color:var(--link-black-hover-color,#999)}:host(.nx-link--black)::ng-deep a:active{color:#5b5b5b;color:var(--link-black-active-color,#5b5b5b)}:host(.nx-link--black)::ng-deep a[aria-disabled],:host(.nx-link--black)::ng-deep a[disabled]{color:#c2c2c2;color:var(--link-black-disabled-color,#c2c2c2)}:host.nx-link--text{font-weight:700;text-transform:none;letter-spacing:normal;border-radius:4px;font-size:inherit;line-height:inherit}:host.nx-link--text ::ng-deep a{display:inline-flex}:host::ng-deep .c-icon,:host::ng-deep nx-icon.nx-link__icon{margin:0 8px 0 0}:host::ng-deep .c-icon::before,:host::ng-deep nx-icon.nx-link__icon::before{line-height:inherit;font-size:inherit}:host.nx-link--small ::ng-deep .c-icon,:host.nx-link--small ::ng-deep nx-icon.nx-link__icon{font-size:24px;font-size:var(--link-small-icon-size,24px)}:host.nx-link--large ::ng-deep .c-icon,:host.nx-link--large ::ng-deep nx-icon.nx-link__icon{font-size:32px;font-size:var(--link-large-icon-size,32px)}:host(.nx-link--icon-right)::ng-deep .c-icon,:host(.nx-link--icon-right)::ng-deep nx-icon.nx-link__icon{order:2;margin:0 0 0 8px}:host::ng-deep a[aria-disabled],:host::ng-deep a[disabled]{cursor:not-allowed;color:rgba(0,97,146,.4);color:var(--link-disabled-color,rgba(0,97,146,.4))}:host::ng-deep a[aria-disabled]:focus,:host::ng-deep a[disabled]:focus{outline:0;box-shadow:none}@media screen and (-ms-high-contrast:active){:host-context([data-whatinput=keyboard])::ng-deep a:focus{box-shadow:0 0 0 2px background,0 0 0 6px windowText}:host::ng-deep a[aria-disabled],:host::ng-deep a[disabled]{color:GrayText}}"]
                    }] }
        ];
        /** @nocollapse */
        NxLinkComponent.ctorParameters = function () { return [
            { type: core.ElementRef },
            { type: core.Renderer2 },
            { type: core.ChangeDetectorRef }
        ]; };
        NxLinkComponent.propDecorators = {
            icon: [{ type: core.ContentChild, args: [icon.NxIconComponent, { static: false },] }],
            size: [{ type: core.Input }]
        };
        return NxLinkComponent;
    }(core$1.MappedStyles));
    if (false) {
        /**
         * @type {?}
         * @private
         */
        NxLinkComponent.prototype._size;
        /**
         * \@docs-private
         * @type {?}
         */
        NxLinkComponent.prototype.icon;
        /**
         * Sets the style of the link, thereby altering the visual appearance.
         *
         * You can use any combination of 'black', 'icon-right', 'negative', 'text' and 'block' (deprecated).
         * @type {?}
         */
        NxLinkComponent.prototype.classNames;
        /**
         * @type {?}
         * @protected
         */
        NxLinkComponent.prototype._renderer;
        /**
         * @type {?}
         * @private
         */
        NxLinkComponent.prototype._changeDetectorRef;
    }

    /**
     * @fileoverview added by tsickle
     * Generated from: link/link.module.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var NxLinkModule = /** @class */ (function () {
        function NxLinkModule() {
        }
        NxLinkModule.decorators = [
            { type: core.NgModule, args: [{
                        declarations: [NxLinkComponent],
                        exports: [NxLinkComponent]
                    },] }
        ];
        return NxLinkModule;
    }());

    /**
     * @fileoverview added by tsickle
     * Generated from: link/public-api.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * Generated from: circle-toggle/circle-toggle/toggle-button.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * \@docs-private
     * @abstract
     */
    var   /**
     * \@docs-private
     * @abstract
     */
    ToggleButton = /** @class */ (function () {
        function ToggleButton() {
        }
        return ToggleButton;
    }());
    if (false) {
        /** @type {?} */
        ToggleButton.prototype.id;
        /** @type {?} */
        ToggleButton.prototype.value;
        /** @type {?} */
        ToggleButton.prototype.checked;
        /** @type {?} */
        ToggleButton.prototype.name;
        /** @type {?} */
        ToggleButton.prototype.negative;
        /** @type {?} */
        ToggleButton.prototype.disabled;
        /** @type {?} */
        ToggleButton.prototype.tabIndex;
        /** @type {?} */
        ToggleButton.prototype.checkedChange;
        /** @type {?} */
        ToggleButton.prototype.selectionChange;
        /** @type {?} */
        ToggleButton.prototype.toggleButton;
        /**
         * @abstract
         * @param {?} event
         * @return {?}
         */
        ToggleButton.prototype.toggle = function (event) { };
        /**
         * @abstract
         * @return {?}
         */
        ToggleButton.prototype.setGroupSelection = function () { };
    }

    /**
     * @fileoverview added by tsickle
     * Generated from: circle-toggle/circle-toggle-group/circle-toggle-group.component.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /** @type {?} */
    var nextId$2 = 0;
    var NxCircleToggleGroupComponent = /** @class */ (function () {
        function NxCircleToggleGroupComponent(_changeDetectorRef) {
            this._changeDetectorRef = _changeDetectorRef;
            this._id = "nx-circle-toggle-group-" + nextId$2++;
            this._destroyed = new rxjs.Subject();
            /**
             * An event emitted when the selection changes. Outputs the value of the currently selected button.
             */
            this.valueChange = new core.EventEmitter();
            this._name = "toggle-group-" + nextId$2++;
            this._negative = false;
            this._responsive = true;
            this.onChangeCallback = (/**
             * @param {?} value
             * @return {?}
             */
            function (value) { });
            this.onTouchedCallback = (/**
             * @return {?}
             */
            function () { });
        }
        Object.defineProperty(NxCircleToggleGroupComponent.prototype, "id", {
            get: /**
             * @return {?}
             */
            function () {
                return this._id;
            },
            /**
             * Id of the circle toggle group.
             *
             * If not set, the circle toggle group gets an incremented value by default.
             */
            set: /**
             * Id of the circle toggle group.
             *
             * If not set, the circle toggle group gets an incremented value by default.
             * @param {?} value
             * @return {?}
             */
            function (value) {
                this._id = value;
                this._changeDetectorRef.markForCheck();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NxCircleToggleGroupComponent.prototype, "name", {
            get: /**
             * @return {?}
             */
            function () {
                return this._name;
            },
            /** Name that is used for accessibility. */
            set: /**
             * Name that is used for accessibility.
             * @param {?} value
             * @return {?}
             */
            function (value) {
                this._name = value;
                this.updateToggleButtonsNames();
                this._changeDetectorRef.markForCheck();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NxCircleToggleGroupComponent.prototype, "disabled", {
            get: /**
             * @return {?}
             */
            function () {
                return this._disabled;
            },
            /** Whether the circle toggle group is disabled. */
            set: /**
             * Whether the circle toggle group is disabled.
             * @param {?} value
             * @return {?}
             */
            function (value) {
                /** @type {?} */
                var newValue = coercion.coerceBooleanProperty(value);
                if (this._disabled !== newValue) {
                    this._disabled = newValue;
                    this._changeDetectorRef.markForCheck();
                }
                if (this.buttons) {
                    this.buttons.forEach((/**
                     * @param {?} button
                     * @return {?}
                     */
                    function (button) { return button.disabled = value; }));
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NxCircleToggleGroupComponent.prototype, "negative", {
            get: /**
             * @return {?}
             */
            function () {
                return this._negative;
            },
            /** Whether the circle toggle group uses the negative styling. */
            set: /**
             * Whether the circle toggle group uses the negative styling.
             * @param {?} value
             * @return {?}
             */
            function (value) {
                /** @type {?} */
                var newValue = coercion.coerceBooleanProperty(value);
                if (this.negative !== newValue) {
                    this._negative = newValue;
                }
                if (this.buttons) {
                    this.buttons.forEach((/**
                     * @param {?} button
                     * @return {?}
                     */
                    function (button) { return button.negative = value; }));
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NxCircleToggleGroupComponent.prototype, "value", {
            get: /**
             * @return {?}
             */
            function () {
                return this._value;
            },
            /** The value of the selected circle toggle in the circle toggle group. */
            set: /**
             * The value of the selected circle toggle in the circle toggle group.
             * @param {?} value
             * @return {?}
             */
            function (value) {
                this.writeValue(value);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NxCircleToggleGroupComponent.prototype, "responsive", {
            get: /**
             * @return {?}
             */
            function () {
                return this._responsive;
            },
            /** Whether the circle toggle group has a responsive behavior. */
            set: /**
             * Whether the circle toggle group has a responsive behavior.
             * @param {?} value
             * @return {?}
             */
            function (value) {
                /** @type {?} */
                var newValue = coercion.coerceBooleanProperty(value);
                if (newValue !== this.responsive) {
                    this._responsive = newValue;
                    this._changeDetectorRef.markForCheck();
                }
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @param {?} value
         * @return {?}
         */
        NxCircleToggleGroupComponent.prototype.writeValue = /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            if (this.value !== value) {
                this._value = value;
                this.notifySelectedChild(value);
            }
        };
        /**
         * @return {?}
         */
        NxCircleToggleGroupComponent.prototype.ngOnDestroy = /**
         * @return {?}
         */
        function () {
            this._destroyed.next();
            this._destroyed.complete();
        };
        /**
         * @return {?}
         */
        NxCircleToggleGroupComponent.prototype.ngAfterViewInit = /**
         * @return {?}
         */
        function () {
            var _this = this;
            this.subscribeToSelectionChanges();
            // react if a content child is deleted, added etc.
            this.buttons.changes
                .pipe(operators.startWith(this.buttons), operators.filter((/**
             * @param {?} toggles
             * @return {?}
             */
            function (toggles) { return toggles.length > 0; })), operators.tap((/**
             * @param {?} toggles
             * @return {?}
             */
            function (toggles) {
                return Promise.resolve().then((/**
                 * @return {?}
                 */
                function () {
                    toggles.forEach((/**
                     * @param {?} toggle
                     * @return {?}
                     */
                    function (toggle) { return toggle.toggleButton.resetClasses(); }));
                    _this.buttons.first.toggleButton.setFirstButton();
                    _this.buttons.last.toggleButton.setLastButton();
                }));
            })), operators.takeUntil(this._destroyed))
                .subscribe((/**
             * @return {?}
             */
            function () { return _this.subscribeToSelectionChanges(); }));
        };
        /** @docs-private */
        /**
         * \@docs-private
         * @return {?}
         */
        NxCircleToggleGroupComponent.prototype.subscribeToSelectionChanges = /**
         * \@docs-private
         * @return {?}
         */
        function () {
            var _this = this;
            /** @type {?} */
            var changedOrDestroyed = rxjs.merge(this.buttons.changes, this._destroyed);
            rxjs.merge.apply(void 0, __spread(this.buttons.map((/**
             * @param {?} button
             * @return {?}
             */
            function (button) { return button.selectionChange; })))).pipe(operators.takeUntil(changedOrDestroyed))
                .subscribe((/**
             * @param {?} change
             * @return {?}
             */
            function (change) {
                _this.onChangeCallback(change.value);
                _this.valueChange.emit(change.value);
            }));
        };
        /**
         * @docs-private
         * inform the selected button if the group selection is set programattically at the beginning
         */
        /**
         * \@docs-private
         * inform the selected button if the group selection is set programattically at the beginning
         * @param {?} newValue
         * @return {?}
         */
        NxCircleToggleGroupComponent.prototype.notifySelectedChild = /**
         * \@docs-private
         * inform the selected button if the group selection is set programattically at the beginning
         * @param {?} newValue
         * @return {?}
         */
        function (newValue) {
            if (this.buttons) {
                /** @type {?} */
                var selected = this.buttons.find((/**
                 * @param {?} button
                 * @return {?}
                 */
                function (button) { return button.value === newValue; }));
                if (selected) {
                    selected.setGroupSelection();
                }
            }
        };
        /** @docs-private */
        /**
         * \@docs-private
         * @return {?}
         */
        NxCircleToggleGroupComponent.prototype.updateToggleButtonsNames = /**
         * \@docs-private
         * @return {?}
         */
        function () {
            var _this = this;
            if (this.buttons) {
                this.buttons.forEach((/**
                 * @param {?} button
                 * @return {?}
                 */
                function (button) { return button.name = _this.name; }));
            }
        };
        /**
         * @param {?} fn
         * @return {?}
         */
        NxCircleToggleGroupComponent.prototype.registerOnChange = /**
         * @param {?} fn
         * @return {?}
         */
        function (fn) {
            this.onChangeCallback = fn;
        };
        /**
         * @param {?} fn
         * @return {?}
         */
        NxCircleToggleGroupComponent.prototype.registerOnTouched = /**
         * @param {?} fn
         * @return {?}
         */
        function (fn) {
            this.onTouchedCallback = fn;
        };
        /**
         * @param {?} isDisabled
         * @return {?}
         */
        NxCircleToggleGroupComponent.prototype.setDisabledState = /**
         * @param {?} isDisabled
         * @return {?}
         */
        function (isDisabled) {
            this.disabled = isDisabled;
        };
        Object.defineProperty(NxCircleToggleGroupComponent.prototype, "selectedButton", {
            /** @docs-private */
            get: /**
             * \@docs-private
             * @return {?}
             */
            function () {
                return this.buttons ? this.buttons.find((/**
                 * @param {?} button
                 * @return {?}
                 */
                function (button) { return button.checked; })) : null;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NxCircleToggleGroupComponent.prototype, "buttons", {
            /** @docs-private */
            get: /**
             * \@docs-private
             * @return {?}
             */
            function () {
                return this._buttons;
            },
            enumerable: true,
            configurable: true
        });
        NxCircleToggleGroupComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'nx-circle-toggle-group',
                        template: "<ng-content></ng-content>",
                        changeDetection: core.ChangeDetectionStrategy.OnPush,
                        providers: [
                            {
                                provide: forms.NG_VALUE_ACCESSOR,
                                useExisting: core.forwardRef((/**
                                 * @return {?}
                                 */
                                function () { return NxCircleToggleGroupComponent; })),
                                multi: true
                            }
                        ],
                        host: {
                            '[class.is-responsive]': 'responsive',
                            '[class.is-disabled]': 'disabled',
                            '[attr.aria-disabled]': 'disabled',
                            '[attr.aria-labelledby]': 'name',
                            '[attr.name]': 'name',
                            '[attr.id]': 'id',
                            '[class.nx-circle-toggle-group]': 'true',
                            'role': 'radiogroup'
                        },
                        styles: [":host{display:flex;flex-wrap:wrap;flex-direction:column;justify-content:space-around}@media (min-width:320px){:host{flex-direction:row}}:host(.is-responsive){flex-direction:column}@media (min-width:704px){:host(.is-responsive){flex-direction:row}}"]
                    }] }
        ];
        /** @nocollapse */
        NxCircleToggleGroupComponent.ctorParameters = function () { return [
            { type: core.ChangeDetectorRef }
        ]; };
        NxCircleToggleGroupComponent.propDecorators = {
            _buttons: [{ type: core.ContentChildren, args: [ToggleButton,] }],
            valueChange: [{ type: core.Output }],
            name: [{ type: core.Input }],
            disabled: [{ type: core.Input }],
            negative: [{ type: core.Input }],
            value: [{ type: core.Input }],
            responsive: [{ type: core.Input }]
        };
        return NxCircleToggleGroupComponent;
    }());
    if (false) {
        /**
         * @type {?}
         * @private
         */
        NxCircleToggleGroupComponent.prototype._buttons;
        /**
         * @type {?}
         * @private
         */
        NxCircleToggleGroupComponent.prototype._id;
        /**
         * @type {?}
         * @private
         */
        NxCircleToggleGroupComponent.prototype._destroyed;
        /**
         * An event emitted when the selection changes. Outputs the value of the currently selected button.
         * @type {?}
         */
        NxCircleToggleGroupComponent.prototype.valueChange;
        /**
         * @type {?}
         * @private
         */
        NxCircleToggleGroupComponent.prototype._name;
        /**
         * @type {?}
         * @private
         */
        NxCircleToggleGroupComponent.prototype._disabled;
        /** @type {?} */
        NxCircleToggleGroupComponent.prototype._negative;
        /**
         * @type {?}
         * @private
         */
        NxCircleToggleGroupComponent.prototype._value;
        /**
         * @type {?}
         * @private
         */
        NxCircleToggleGroupComponent.prototype._responsive;
        /**
         * @type {?}
         * @private
         */
        NxCircleToggleGroupComponent.prototype.onChangeCallback;
        /**
         * @type {?}
         * @private
         */
        NxCircleToggleGroupComponent.prototype.onTouchedCallback;
        /**
         * @type {?}
         * @private
         */
        NxCircleToggleGroupComponent.prototype._changeDetectorRef;
    }

    /**
     * @fileoverview added by tsickle
     * Generated from: circle-toggle/mobile-toggle-button/mobile-toggle-button.component.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * \@docs-private
     */
    var NxMobileToggleButtonComponent = /** @class */ (function () {
        function NxMobileToggleButtonComponent(_changeDetectorRef) {
            this._changeDetectorRef = _changeDetectorRef;
            this.checked = false;
            this.negative = false;
            this.disabled = false;
        }
        /** @docs-private */
        /**
         * \@docs-private
         * @return {?}
         */
        NxMobileToggleButtonComponent.prototype.setFirstButton = /**
         * \@docs-private
         * @return {?}
         */
        function () {
            this.isFirst = true;
            this._changeDetectorRef.markForCheck();
        };
        /** @docs-private */
        /**
         * \@docs-private
         * @return {?}
         */
        NxMobileToggleButtonComponent.prototype.setLastButton = /**
         * \@docs-private
         * @return {?}
         */
        function () {
            this.isLast = true;
            this._changeDetectorRef.markForCheck();
        };
        /** @docs-private */
        /**
         * \@docs-private
         * @return {?}
         */
        NxMobileToggleButtonComponent.prototype.resetClasses = /**
         * \@docs-private
         * @return {?}
         */
        function () {
            this.isFirst = false;
            this.isLast = false;
            this._changeDetectorRef.markForCheck();
        };
        NxMobileToggleButtonComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'nx-mobile-toggle-button',
                        template: "<nx-icon class=\"nx-toggle-button__mobile-check\" name=\"check\" aria-hidden=\"true\"></nx-icon>\n<!-- If there is no label defined, use the circleText instead -->\n<span class=\"nx-toggle-button__label-text\"><ng-template *ngIf=\"label; then labelContent else circleTextContent\"></ng-template></span>\n<span *ngIf=\"hint\" class=\"nx-toggle-button__label-hint\">({{hint}})</span>\n\n<ng-template #labelContent>{{label}}</ng-template>\n<ng-template #circleTextContent>{{circleText}}</ng-template>\n",
                        changeDetection: core.ChangeDetectionStrategy.OnPush,
                        host: {
                            '[class.is-disabled]': 'disabled',
                            '[class.is-negative]': 'negative',
                            '[class.is-first]': 'isFirst',
                            '[class.is-last]': 'isLast',
                            '[class.is-flipped]': 'checked'
                        },
                        styles: [":host{display:none;position:relative;transition:background-color .2s,border-color .2s,color .2s;flex-direction:row;border-width:1px 2px;border-color:#007ab3;border-color:var(--circle-toggle-border-color,#007ab3);border-style:solid;padding:11px 31px;width:100%;justify-content:center;align-items:center;cursor:pointer}:host:not(.is-flipped):not(.is-disabled):hover{background-color:#006192;background-color:var(--circle-toggle-hover-background-color,#006192);border-color:#006192;border-color:var(--circle-toggle-hover-border-color,#006192)}:host:not(.is-flipped):not(.is-disabled):hover .nx-toggle-button__label-hint,:host:not(.is-flipped):not(.is-disabled):hover .nx-toggle-button__label-text{color:#fff;color:var(--circle-toggle-hover-icon-color,#fff)}@media (max-width:703px){:host-context(.is-responsive){display:flex}}.nx-toggle-button__label-hint{color:#007ab3;color:var(--circle-toggle-icon-color,#007ab3);font-size:14px;font-size:var(--circle-toggle-hint-mobile-font-size,14px);line-height:20px;line-height:var(--circle-toggle-hint-mobile-line-height,20px);font-weight:300;font-weight:var(--circle-toggle-hint-mobile-font-weight,300);letter-spacing:.2px;letter-spacing:var(--circle-toggle-hint-mobile-letter-spacing,.2px)}.nx-toggle-button__label-text{color:#007ab3;color:var(--circle-toggle-icon-color,#007ab3);font-size:14px;font-size:var(--circle-toggle-label-mobile-font-size,14px);line-height:20px;line-height:var(--circle-toggle-label-mobile-line-height,20px);font-weight:var(--circle-toggle-label-mobile-font-weight,400);letter-spacing:.2px;letter-spacing:var(--circle-toggle-label-mobile-letter-spacing,.2px);padding-top:0;padding-right:4px;font-weight:600}.nx-toggle-button__mobile-check{font-size:24px;height:24px;display:inline-block;opacity:0;margin-right:8px;color:#fff;color:var(--circle-toggle-checkmark-color,#fff)}:host(.is-first){border-top-width:2px;border-radius:4px 4px 0 0}:host(.is-last){border-bottom-width:2px;border-radius:0 0 4px 4px}:host(.is-flipped){background-color:#007ab3;background-color:var(--circle-toggle-selected-background-color,#007ab3)}:host(.is-flipped) .nx-toggle-button__label-hint,:host(.is-flipped) .nx-toggle-button__label-text{color:#fff;color:var(--circle-toggle-selected-icon-color,#fff)}:host(.is-flipped) .nx-toggle-button__mobile-check{opacity:1}:host(.is-negative){border-color:#fff}:host(.is-negative) .nx-toggle-button__label-hint,:host(.is-negative) .nx-toggle-button__label-text,:host(.is-negative) .nx-toggle-button__mobile-check{color:#fff}:host(.is-negative):not(.is-flipped):not(.is-disabled):hover{background-color:#d9d9d9;border-color:#d9d9d9}:host(.is-negative):not(.is-flipped):not(.is-disabled):hover .nx-toggle-button__label-hint,:host(.is-negative):not(.is-flipped):not(.is-disabled):hover .nx-toggle-button__label-text{color:#006192}:host(.is-negative.is-flipped){background-color:#fff}:host(.is-negative.is-flipped) .nx-toggle-button__label-hint,:host(.is-negative.is-flipped) .nx-toggle-button__label-text,:host(.is-negative.is-flipped) .nx-toggle-button__mobile-check{color:#007ab3}:host(.is-disabled){opacity:.4;cursor:not-allowed}@media screen and (-ms-high-contrast:active){:host,:host(.is-negative){background-color:buttonFace;border-color:buttonText}:host .nx-toggle-button__label-hint,:host .nx-toggle-button__label-text,:host .nx-toggle-button__mobile-check,:host(.is-negative) .nx-toggle-button__label-hint,:host(.is-negative) .nx-toggle-button__label-text,:host(.is-negative) .nx-toggle-button__mobile-check{color:buttonText;-ms-high-contrast-adjust:none}:host(.is-flipped),:host(.is-negative.is-flipped){background-color:highlight}:host(.is-flipped) .nx-toggle-button__label-hint,:host(.is-flipped) .nx-toggle-button__label-text,:host(.is-flipped) .nx-toggle-button__mobile-check,:host(.is-negative.is-flipped) .nx-toggle-button__label-hint,:host(.is-negative.is-flipped) .nx-toggle-button__label-text,:host(.is-negative.is-flipped) .nx-toggle-button__mobile-check{color:highlightText}:host(.is-disabled){opacity:1;border-color:GrayText;color:GrayText}:host(.is-disabled).is-flipped .nx-toggle-button__mobile-check{color:GrayText}}"]
                    }] }
        ];
        /** @nocollapse */
        NxMobileToggleButtonComponent.ctorParameters = function () { return [
            { type: core.ChangeDetectorRef }
        ]; };
        NxMobileToggleButtonComponent.propDecorators = {
            checked: [{ type: core.Input }],
            negative: [{ type: core.Input }],
            disabled: [{ type: core.Input }],
            hint: [{ type: core.Input }],
            label: [{ type: core.Input }],
            circleText: [{ type: core.Input }]
        };
        return NxMobileToggleButtonComponent;
    }());
    if (false) {
        /** @type {?} */
        NxMobileToggleButtonComponent.prototype.checked;
        /** @type {?} */
        NxMobileToggleButtonComponent.prototype.negative;
        /** @type {?} */
        NxMobileToggleButtonComponent.prototype.disabled;
        /** @type {?} */
        NxMobileToggleButtonComponent.prototype.hint;
        /** @type {?} */
        NxMobileToggleButtonComponent.prototype.label;
        /** @type {?} */
        NxMobileToggleButtonComponent.prototype.circleText;
        /**
         * \@docs-private
         * @type {?}
         */
        NxMobileToggleButtonComponent.prototype.isFirst;
        /**
         * \@docs-private
         * @type {?}
         */
        NxMobileToggleButtonComponent.prototype.isLast;
        /**
         * @type {?}
         * @private
         */
        NxMobileToggleButtonComponent.prototype._changeDetectorRef;
    }

    /**
     * @fileoverview added by tsickle
     * Generated from: circle-toggle/circle-toggle/circle-toggle.component.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var ToggleChangeEvent = /** @class */ (function () {
        function ToggleChangeEvent(button, value) {
            this.button = button;
            this.value = value;
        }
        return ToggleChangeEvent;
    }());
    if (false) {
        /**
         * A toggle button
         * @type {?}
         */
        ToggleChangeEvent.prototype.button;
        /**
         * The value of the toggle button that is sent with the event.
         * @type {?}
         */
        ToggleChangeEvent.prototype.value;
    }
    /** @type {?} */
    var nextId$3 = 0;
    var NxCircleToggleComponent = /** @class */ (function (_super) {
        __extends(NxCircleToggleComponent, _super);
        function NxCircleToggleComponent(/** @docs-private */ toggleGroup, _checkedDispatcher, _changeDetectorRef) {
            var _this = _super.call(this) || this;
            _this.toggleGroup = toggleGroup;
            _this._checkedDispatcher = _checkedDispatcher;
            _this._changeDetectorRef = _changeDetectorRef;
            _this._id = "toggle-button-" + nextId$3++;
            /**
             * \@docs-private
             */
            _this.inGroup = false;
            _this._name = null;
            /**
             * An event that is emitted when the checked state fo the circle toggle changes.
             */
            _this.checkedChange = new core.EventEmitter();
            /**
             * An event that is emitted when the checked state of the circle toggle changes.
             * The event object contains the circle toggle itself and its value (see ToggleChangeEvent).
             */
            _this.selectionChange = new core.EventEmitter();
            _this._checked = false;
            _this._value = null;
            _this._iconName = null;
            _this._svg = null;
            _this._svgChecked = null;
            _this._circleText = null;
            _this._label = null;
            _this._hint = null;
            _this._hover = false;
            /**
             * touched is set to true on touch devices.
             */
            _this._touched = false;
            _this._removeUniqueSelectionListener = (/**
             * @return {?}
             */
            function () { });
            _this.onChangeCallback = (/**
             * @param {?} checked
             * @return {?}
             */
            function (checked) { });
            _this.onTouchedCallback = (/**
             * @return {?}
             */
            function () { });
            if (_this.toggleGroup) {
                _this.name = _this.toggleGroup.name;
            }
            return _this;
        }
        Object.defineProperty(NxCircleToggleComponent.prototype, "id", {
            get: /**
             * @return {?}
             */
            function () {
                return this._id;
            },
            /**
             * Id of the circle toggle.
             *
             * If not set, the circle toggle gets an incremented value by default.
             */
            set: /**
             * Id of the circle toggle.
             *
             * If not set, the circle toggle gets an incremented value by default.
             * @param {?} value
             * @return {?}
             */
            function (value) {
                this._id = value;
                this._changeDetectorRef.markForCheck();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NxCircleToggleComponent.prototype, "name", {
            get: /**
             * @return {?}
             */
            function () {
                return this._name;
            },
            /** Name that is used for accessibility. */
            set: /**
             * Name that is used for accessibility.
             * @param {?} value
             * @return {?}
             */
            function (value) {
                this._name = value;
                this._changeDetectorRef.markForCheck();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NxCircleToggleComponent.prototype, "checked", {
            get: /**
             * @return {?}
             */
            function () {
                return this._checked;
            },
            /** Whether the circle toggle is checked. */
            set: /**
             * Whether the circle toggle is checked.
             * @param {?} value
             * @return {?}
             */
            function (value) {
                /** @type {?} */
                var newValue = coercion.coerceBooleanProperty(value);
                if (this.checked !== newValue) {
                    this._checked = newValue;
                    this._changeDetectorRef.markForCheck();
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NxCircleToggleComponent.prototype, "value", {
            get: /**
             * @return {?}
             */
            function () {
                return this._value;
            },
            /** The value that is used in the model. */
            set: /**
             * The value that is used in the model.
             * @param {?} newValue
             * @return {?}
             */
            function (newValue) {
                this._value = newValue;
                this._changeDetectorRef.markForCheck();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NxCircleToggleComponent.prototype, "iconName", {
            get: /**
             * @return {?}
             */
            function () {
                return this._iconName;
            },
            /** Id of the icon that should be displayed. */
            set: /**
             * Id of the icon that should be displayed.
             * @param {?} name
             * @return {?}
             */
            function (name) {
                this._iconName = name;
                this._changeDetectorRef.markForCheck();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NxCircleToggleComponent.prototype, "svg", {
            get: /**
             * @return {?}
             */
            function () {
                return this._svg;
            },
            /** SVG that is displayed if the circle toggle is unchecked. */
            set: /**
             * SVG that is displayed if the circle toggle is unchecked.
             * @param {?} src
             * @return {?}
             */
            function (src) {
                this._svg = src;
                this._changeDetectorRef.markForCheck();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NxCircleToggleComponent.prototype, "svgChecked", {
            get: /**
             * @return {?}
             */
            function () {
                return this._svgChecked;
            },
            /** SVG that is displayed if the circle toggle is checked. */
            set: /**
             * SVG that is displayed if the circle toggle is checked.
             * @param {?} src
             * @return {?}
             */
            function (src) {
                this._svgChecked = src;
                this._changeDetectorRef.markForCheck();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NxCircleToggleComponent.prototype, "circleText", {
            get: /**
             * @return {?}
             */
            function () {
                return this._circleText;
            },
            /** A text that is displayed inside the circle toggle. */
            set: /**
             * A text that is displayed inside the circle toggle.
             * @param {?} value
             * @return {?}
             */
            function (value) {
                if (value !== this._circleText) {
                    this._circleText = value;
                    this._changeDetectorRef.markForCheck();
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NxCircleToggleComponent.prototype, "label", {
            get: /**
             * @return {?}
             */
            function () {
                return this._label;
            },
            /** Label displayed below the circle. */
            set: /**
             * Label displayed below the circle.
             * @param {?} value
             * @return {?}
             */
            function (value) {
                this._label = value;
                this._changeDetectorRef.markForCheck();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NxCircleToggleComponent.prototype, "hint", {
            get: /**
             * @return {?}
             */
            function () {
                return this._hint;
            },
            /** Additional hint displayed below the label. */
            set: /**
             * Additional hint displayed below the label.
             * @param {?} value
             * @return {?}
             */
            function (value) {
                this._hint = value;
                this._changeDetectorRef.markForCheck();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NxCircleToggleComponent.prototype, "negative", {
            get: /**
             * @return {?}
             */
            function () {
                return this._negative;
            },
            /** Whether the circle toggle uses the negative set of styling. */
            set: /**
             * Whether the circle toggle uses the negative set of styling.
             * @param {?} value
             * @return {?}
             */
            function (value) {
                /** @type {?} */
                var newValue = coercion.coerceBooleanProperty(value);
                if (this.negative !== newValue) {
                    this._negative = newValue;
                    this._changeDetectorRef.markForCheck();
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NxCircleToggleComponent.prototype, "responsive", {
            get: /**
             * @return {?}
             */
            function () {
                return this._responsive;
            },
            /** Whether the circle toggle has a responsive behavior. */
            set: /**
             * Whether the circle toggle has a responsive behavior.
             * @param {?} value
             * @return {?}
             */
            function (value) {
                /** @type {?} */
                var newValue = coercion.coerceBooleanProperty(value);
                if (this.responsive !== newValue) {
                    this._responsive = newValue;
                    this._changeDetectorRef.markForCheck();
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NxCircleToggleComponent.prototype, "disabled", {
            get: /**
             * @return {?}
             */
            function () {
                return this._disabled;
            },
            /** Whether the circle toggle is disabled. */
            set: /**
             * Whether the circle toggle is disabled.
             * @param {?} value
             * @return {?}
             */
            function (value) {
                /** @type {?} */
                var newValue = coercion.coerceBooleanProperty(value);
                if (this.disabled !== newValue) {
                    this._disabled = newValue;
                    this._changeDetectorRef.markForCheck();
                }
            },
            enumerable: true,
            configurable: true
        });
        /** @docs-private */
        /**
         * \@docs-private
         * @return {?}
         */
        NxCircleToggleComponent.prototype.onMouseEnter = /**
         * \@docs-private
         * @return {?}
         */
        function () {
            if (!this._touched) {
                this._hover = true;
            }
        };
        /** @docs-private */
        /**
         * \@docs-private
         * @return {?}
         */
        NxCircleToggleComponent.prototype.onMouseLeave = /**
         * \@docs-private
         * @return {?}
         */
        function () {
            if (!this._touched) {
                this._hover = false;
            }
        };
        /** @docs-private */
        /**
         * \@docs-private
         * @return {?}
         */
        NxCircleToggleComponent.prototype.onTouchStart = /**
         * \@docs-private
         * @return {?}
         */
        function () {
            this._touched = true;
        };
        /**
         * @return {?}
         */
        NxCircleToggleComponent.prototype.ngOnInit = /**
         * @return {?}
         */
        function () {
            if (this.toggleGroup) {
                this.attachListenerForGroup();
            }
        };
        /**
         * @return {?}
         */
        NxCircleToggleComponent.prototype.ngAfterViewInit = /**
         * @return {?}
         */
        function () {
            var _this = this;
            if (this.toggleGroup) {
                Promise.resolve().then((/**
                 * @return {?}
                 */
                function () {
                    _this.inGroup = true;
                    _this.negative = _this.toggleGroup.negative;
                    _this.disabled = _this.toggleGroup.disabled;
                    _this.responsive = _this.toggleGroup.responsive;
                    _this.id = _this.toggleGroup.id + ("-button-" + nextId$3++);
                }));
            }
        };
        /**
         * @return {?}
         */
        NxCircleToggleComponent.prototype.ngOnDestroy = /**
         * @return {?}
         */
        function () {
            // function returned by the listener
            this._removeUniqueSelectionListener();
        };
        /** @docs-private */
        /**
         * \@docs-private
         * @return {?}
         */
        NxCircleToggleComponent.prototype.attachListenerForGroup = /**
         * \@docs-private
         * @return {?}
         */
        function () {
            var _this = this;
            this._removeUniqueSelectionListener =
                this._checkedDispatcher.listen((/**
                 * @param {?} groupId
                 * @param {?} buttonId
                 * @return {?}
                 */
                function (groupId, buttonId) {
                    if (_this.id !== buttonId && groupId === _this.toggleGroup.id) {
                        _this.checked = false;
                    }
                }));
        };
        /**
         * @param {?} newValue
         * @return {?}
         */
        NxCircleToggleComponent.prototype.writeValue = /**
         * @param {?} newValue
         * @return {?}
         */
        function (newValue) {
            this.checked = newValue;
        };
        /**
         * @param {?} fn
         * @return {?}
         */
        NxCircleToggleComponent.prototype.registerOnChange = /**
         * @param {?} fn
         * @return {?}
         */
        function (fn) {
            this.onChangeCallback = fn;
        };
        /**
         * @param {?} fn
         * @return {?}
         */
        NxCircleToggleComponent.prototype.registerOnTouched = /**
         * @param {?} fn
         * @return {?}
         */
        function (fn) {
            this.onTouchedCallback = fn;
        };
        /**
         * @param {?} isDisabled
         * @return {?}
         */
        NxCircleToggleComponent.prototype.setDisabledState = /**
         * @param {?} isDisabled
         * @return {?}
         */
        function (isDisabled) {
            this.disabled = isDisabled;
        };
        /** @docs-private */
        /**
         * \@docs-private
         * @param {?} event
         * @return {?}
         */
        NxCircleToggleComponent.prototype.toggle = /**
         * \@docs-private
         * @param {?} event
         * @return {?}
         */
        function (event) {
            event.preventDefault();
            event.stopPropagation();
            if ((this.toggleGroup && this.checked) || this.disabled) {
                return;
            }
            else {
                this.checked = !this.checked;
                this.onChangeCallback(this.checked);
                this.checkedChange.emit(this.checked);
                this.selectionChange.emit(new ToggleChangeEvent(this, this.value));
                if (this.toggleGroup) {
                    this._checkedDispatcher.notify(this.toggleGroup.id, this.id);
                }
            }
        };
        /**
         * @docs-private
         *
         * method called by the group if the internal value of the group is changed programatically,
         * does not trigger change emission
         */
        /**
         * \@docs-private
         *
         * method called by the group if the internal value of the group is changed programatically,
         * does not trigger change emission
         * @return {?}
         */
        NxCircleToggleComponent.prototype.setGroupSelection = /**
         * \@docs-private
         *
         * method called by the group if the internal value of the group is changed programatically,
         * does not trigger change emission
         * @return {?}
         */
        function () {
            // propagate changes only if the value in the group is different than the button checked value
            if (!this.checked) {
                this.checked = !this.checked;
                this.onChangeCallback(this.checked);
                this._checkedDispatcher.notify(this.toggleGroup.id, this.id);
            }
        };
        Object.defineProperty(NxCircleToggleComponent.prototype, "svgButton", {
            /** @docs-private */
            get: /**
             * \@docs-private
             * @return {?}
             */
            function () {
                return !!this.svg && !!this.svgChecked;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NxCircleToggleComponent.prototype, "svgUrl", {
            /** @docs-private */
            get: /**
             * \@docs-private
             * @return {?}
             */
            function () {
                /** @type {?} */
                var useFilledSvg = this.checked || (!this.disabled && this._hover);
                if (this.negative) {
                    useFilledSvg = !useFilledSvg;
                }
                return useFilledSvg ? this.svgChecked : this.svg;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NxCircleToggleComponent.prototype, "type", {
            /** @docs-private */
            get: /**
             * \@docs-private
             * @return {?}
             */
            function () {
                return this.toggleGroup ? 'radio' : 'checkbox';
            },
            enumerable: true,
            configurable: true
        });
        /** @docs-private */
        /**
         * \@docs-private
         * @param {?} event
         * @return {?}
         */
        NxCircleToggleComponent.prototype.handleEnterKey = /**
         * \@docs-private
         * @param {?} event
         * @return {?}
         */
        function (event) {
            if (!this.toggleGroup) {
                this.toggle(event);
            }
        };
        NxCircleToggleComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'nx-circle-toggle',
                        template: "<input [id]=\"id + '-input'\"\n       class=\"nx-circle-toggle__input\"\n       [attr.aria-labelledby]=\"id + '-label'\"\n       [type]=\"type\"\n       [attr.name]=\"name\"\n       [checked]=\"checked\"\n       [disabled]= \"disabled\"\n       [attr.aria-checked]=\"checked\"\n       (keydown.enter)=\"handleEnterKey($event)\"\n       (click)=\"toggle($event)\">\n<label class=\"nx-circle-toggle__label\"\n  [for]=\"id + '-input'\"\n  [id]=\"id + '-label'\">\n    <nx-icon-toggle-button\n      [label]=\"label\"\n      [hint]=\"hint\"\n      [checked]=\"checked\"\n      [icon]=\"iconName\"\n      [negative]=\"negative\"\n      [svg]=\"svgUrl\"\n      [disabled]=\"disabled\"\n      [inGroup]=\"inGroup\"\n      [touched]=\"_touched\"\n      [circleText]=\"circleText\">\n    </nx-icon-toggle-button>\n    <!-- The mobile toggle button is needed for the responsive mobile version of the component.\n    The display swtich is handled in the css. -->\n    <nx-mobile-toggle-button\n      [label]=\"label\"\n      [hint]=\"hint\"\n      [checked]=\"checked\"\n      [negative]=\"negative\"\n      [disabled]=\"disabled\"\n      [circleText]=\"circleText\">\n    </nx-mobile-toggle-button>\n</label>",
                        changeDetection: core.ChangeDetectionStrategy.OnPush,
                        providers: [
                            {
                                provide: ToggleButton,
                                useExisting: core.forwardRef((/**
                                 * @return {?}
                                 */
                                function () { return NxCircleToggleComponent; }))
                            },
                            {
                                provide: forms.NG_VALUE_ACCESSOR,
                                useExisting: core.forwardRef((/**
                                 * @return {?}
                                 */
                                function () { return NxCircleToggleComponent; })),
                                multi: true
                            }
                        ],
                        host: {
                            '[class.nx-toggle-circle]': 'true',
                            '[class.in-group]': 'inGroup',
                            '[class.is-disabled]': 'disabled',
                            '[class.is-responsive]': 'responsive'
                        },
                        styles: [":host{display:inline-block;vertical-align:top;position:relative}:host:not(.is-responsive){opacity:.9999}:host .nx-circle-toggle__input{opacity:0;position:absolute}:host:not(.in-group){margin-right:64px}@media (max-width:703px){:host:not(.in-group){margin-right:48px}}:host-context([data-whatinput=keyboard]) .nx-circle-toggle__input:focus+.nx-circle-toggle__label ::ng-deep .nx-toggle-circle__check-focus,:host-context([data-whatinput=keyboard]) .nx-circle-toggle__input:focus+.nx-circle-toggle__label ::ng-deep .nx-toggle-circle__icon-wrapper{box-shadow:0 0 0 2px #fff,0 0 0 6px #009de6;box-shadow:var(--focus-box-shadow,0 0 0 2px #fff,0 0 0 6px #009de6)}@media screen and (-ms-high-contrast:active){:host-context([data-whatinput=keyboard]) .nx-circle-toggle__input:focus+.nx-circle-toggle__label ::ng-deep .nx-toggle-circle__check-focus,:host-context([data-whatinput=keyboard]) .nx-circle-toggle__input:focus+.nx-circle-toggle__label ::ng-deep .nx-toggle-circle__icon-wrapper{box-shadow:0 0 0 2px background,0 0 0 6px windowText}}:host-context([data-whatinput=keyboard]) .nx-circle-toggle__input:focus+.nx-circle-toggle__label ::ng-deep nx-mobile-toggle-button{box-shadow:0 0 0 2px #fff,0 0 0 6px #009de6;box-shadow:var(--focus-box-shadow,0 0 0 2px #fff,0 0 0 6px #009de6);z-index:1}@media screen and (-ms-high-contrast:active){:host-context([data-whatinput=keyboard]) .nx-circle-toggle__input:focus+.nx-circle-toggle__label ::ng-deep nx-mobile-toggle-button{box-shadow:0 0 0 2px background,0 0 0 6px windowText}}"]
                    }] }
        ];
        /** @nocollapse */
        NxCircleToggleComponent.ctorParameters = function () { return [
            { type: NxCircleToggleGroupComponent, decorators: [{ type: core.Optional }] },
            { type: collections.UniqueSelectionDispatcher },
            { type: core.ChangeDetectorRef }
        ]; };
        NxCircleToggleComponent.propDecorators = {
            name: [{ type: core.Input }],
            checkedChange: [{ type: core.Output }],
            selectionChange: [{ type: core.Output }],
            checked: [{ type: core.Input }],
            value: [{ type: core.Input }],
            iconName: [{ type: core.Input, args: ['icon',] }],
            svg: [{ type: core.Input }],
            svgChecked: [{ type: core.Input }],
            circleText: [{ type: core.Input }],
            label: [{ type: core.Input }],
            hint: [{ type: core.Input }],
            negative: [{ type: core.Input }],
            responsive: [{ type: core.Input }],
            disabled: [{ type: core.Input }],
            toggleButton: [{ type: core.ViewChild, args: [NxMobileToggleButtonComponent, { static: true },] }],
            onMouseEnter: [{ type: core.HostListener, args: ['mouseenter',] }],
            onMouseLeave: [{ type: core.HostListener, args: ['mouseleave',] }],
            onTouchStart: [{ type: core.HostListener, args: ['touchstart',] }]
        };
        return NxCircleToggleComponent;
    }(ToggleButton));
    if (false) {
        /**
         * @type {?}
         * @private
         */
        NxCircleToggleComponent.prototype._id;
        /**
         * \@docs-private
         * @type {?}
         */
        NxCircleToggleComponent.prototype.inGroup;
        /**
         * @type {?}
         * @private
         */
        NxCircleToggleComponent.prototype._name;
        /**
         * An event that is emitted when the checked state fo the circle toggle changes.
         * @type {?}
         */
        NxCircleToggleComponent.prototype.checkedChange;
        /**
         * An event that is emitted when the checked state of the circle toggle changes.
         * The event object contains the circle toggle itself and its value (see ToggleChangeEvent).
         * @type {?}
         */
        NxCircleToggleComponent.prototype.selectionChange;
        /** @type {?} */
        NxCircleToggleComponent.prototype._checked;
        /**
         * @type {?}
         * @private
         */
        NxCircleToggleComponent.prototype._value;
        /**
         * @type {?}
         * @private
         */
        NxCircleToggleComponent.prototype._iconName;
        /**
         * @type {?}
         * @private
         */
        NxCircleToggleComponent.prototype._svg;
        /**
         * @type {?}
         * @private
         */
        NxCircleToggleComponent.prototype._svgChecked;
        /**
         * @type {?}
         * @private
         */
        NxCircleToggleComponent.prototype._circleText;
        /**
         * @type {?}
         * @private
         */
        NxCircleToggleComponent.prototype._label;
        /**
         * @type {?}
         * @private
         */
        NxCircleToggleComponent.prototype._hint;
        /**
         * @type {?}
         * @private
         */
        NxCircleToggleComponent.prototype._negative;
        /**
         * @type {?}
         * @private
         */
        NxCircleToggleComponent.prototype._responsive;
        /**
         * @type {?}
         * @private
         */
        NxCircleToggleComponent.prototype._disabled;
        /**
         * \@docs-private
         * @type {?}
         */
        NxCircleToggleComponent.prototype.toggleButton;
        /**
         * @type {?}
         * @private
         */
        NxCircleToggleComponent.prototype._hover;
        /**
         * touched is set to true on touch devices.
         * @type {?}
         */
        NxCircleToggleComponent.prototype._touched;
        /** @type {?} */
        NxCircleToggleComponent.prototype._removeUniqueSelectionListener;
        /**
         * @type {?}
         * @private
         */
        NxCircleToggleComponent.prototype.onChangeCallback;
        /**
         * @type {?}
         * @private
         */
        NxCircleToggleComponent.prototype.onTouchedCallback;
        /**
         * \@docs-private
         * @type {?}
         */
        NxCircleToggleComponent.prototype.toggleGroup;
        /**
         * @type {?}
         * @private
         */
        NxCircleToggleComponent.prototype._checkedDispatcher;
        /**
         * @type {?}
         * @private
         */
        NxCircleToggleComponent.prototype._changeDetectorRef;
    }

    /**
     * @fileoverview added by tsickle
     * Generated from: circle-toggle/icon-toggle-button/icon-toggle-button.component.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * \@docs-private
     */
    var NxIconToggleButtonComponent = /** @class */ (function () {
        function NxIconToggleButtonComponent() {
            this.inGroup = true;
        }
        NxIconToggleButtonComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'nx-icon-toggle-button',
                        template: "<div class=\"nx-toggle-circle__icon-wrapper\">\n  <ng-container *ngIf=\"!inGroup\">\n    <span class=\"nx-toggle-circle__check-icon\">\n      <nx-icon name=\"check\"></nx-icon>\n    </span>\n    <div class=\"nx-toggle-circle__check-focus\"></div>\n  </ng-container>\n  <span class=\"nx-toggle-circle__icon\">\n    <nx-icon size=\"m\" *ngIf=\"icon\" [name]=\"icon\"></nx-icon>\n    <img *ngIf=\"svgUrl\" class=\"nx-toggle-circle__icon-image\" [src]=\"svgUrl\" />\n    <span *ngIf=\"circleText\" class=\"nx-toggle-circle__content-text\">{{circleText}}</span>\n  </span>\n</div>\n<span [class.is-label-bold]=\"hint\" class=\"nx-toggle-circle__label-text\">{{label}}</span>\n<span *ngIf=\"hint\" class=\"nx-toggle-circle__label-hint\">{{hint}}</span>\n",
                        changeDetection: core.ChangeDetectionStrategy.OnPush,
                        host: {
                            '[class.nx-circle-button]': 'true',
                            '[class.is-flipped]': 'checked',
                            '[class.has-checkmark]': '!inGroup',
                            '[class.is-disabled]': 'disabled',
                            '[class.is-negative]': 'negative',
                            '[class.is-touched]': 'touched'
                        },
                        styles: ["@media (max-width:703px){:host-context(.is-responsive){display:none}}:host{display:flex;flex-direction:column;padding:0;align-items:center;cursor:pointer;position:relative}:host .nx-toggle-circle__label-text{font-size:16px;font-size:var(--circle-toggle-label-font-size,16px);line-height:24px;line-height:var(--circle-toggle-label-line-height,24px);font-weight:400;font-weight:var(--circle-toggle-label-font-weight,400);letter-spacing:0;letter-spacing:var(--circle-toggle-label-letter-spacing,0);color:#414141;color:var(--circle-toggle-label-color,#414141);position:relative;display:inline-block;padding-top:12px;max-width:16rem;z-index:1}@media (max-width:703px){:host .nx-toggle-circle__label-text{font-size:14px;font-size:var(--circle-toggle-label-mobile-font-size,14px);line-height:20px;line-height:var(--circle-toggle-label-mobile-line-height,20px);font-weight:400;font-weight:var(--circle-toggle-label-mobile-font-weight,400);letter-spacing:.2px;letter-spacing:var(--circle-toggle-label-mobile-letter-spacing,.2px)}}:host .is-label-bold{font-weight:700}:host .nx-toggle-circle__icon-wrapper{height:80px;width:80px;border-radius:50%;border-color:var(--circle-toggle-border-color,#007ab3);display:flex;align-items:center;justify-content:center;transition:background-color .2s,border-color .2s,box-shadow .2s;border:2px solid #007ab3}@media (max-width:703px){:host .is-label-bold{font-weight:400}:host .nx-toggle-circle__icon-wrapper{height:64px;width:64px}:host .nx-toggle-circle__icon-wrapper .nx-toggle-circle__icon nx-icon{font-size:40px}}:host .nx-toggle-circle__check-icon{background-color:#3da556;background-color:var(--circle-toggle-checkmark-background-color,#3da556);color:#fff;color:var(--circle-toggle-checkmark-color,#fff);border-color:var(--circle-toggle-checkmark-border-color,#fff);border-radius:50%;font-size:24px;width:32px;height:32px;position:absolute;top:-8px;right:calc(50% - 48px);transition:opacity .3s;z-index:1;opacity:0;display:flex;justify-content:center;align-items:center;border:2px solid #fff}:host .nx-toggle-circle__check-focus{border-radius:50%;width:28px;height:28px;position:absolute;top:-6px;right:calc(50% - 48px + 2px);z-index:-1;opacity:0;transition:box-shadow .2s}:host .nx-toggle-circle__content-text{font-size:24px;font-size:var(--circle-toggle-content-text-font-size,24px);line-height:32px;line-height:var(--circle-toggle-content-text-line-height,32px);font-weight:400;font-weight:var(--circle-toggle-content-text-font-weight,400);letter-spacing:.2px;letter-spacing:var(--circle-toggle-content-text-letter-spacing,.2px);color:#006192;color:var(--circle-toggle-content-text-color,#006192)}@media (max-width:703px){:host .nx-toggle-circle__content-text{font-size:20px;font-size:var(--circle-toggle-content-text-mobile-font-size,20px);line-height:28px;line-height:var(--circle-toggle-content-text-mobile-line-height,28px);font-weight:400;font-weight:var(--circle-toggle-content-text-mobile-font-weight,400);letter-spacing:.2px;letter-spacing:var(--circle-toggle-content-text-mobile-letter-spacing,.2px)}:host .nx-toggle-circle__label-hint .nx-toggle-circle__icon-wrapper{width:64px;height:64px}:host .nx-toggle-circle__label-hint .nx-toggle-circle__icon nx-icon{font-size:32px}:host .nx-toggle-circle__label-hint .nx-toggle-circle__check-icon{right:calc(50% - 40px)}:host .nx-toggle-circle__label-hint .nx-toggle-circle__icon-image{width:64px;height:64px}}:host .nx-toggle-circle__label-hint{font-size:16px;font-size:var(--circle-toggle-hint-font-size,16px);line-height:24px;line-height:var(--circle-toggle-hint-line-height,24px);font-weight:400;font-weight:var(--circle-toggle-hint-font-weight,400);letter-spacing:0;letter-spacing:var(--circle-toggle-hint-letter-spacing,0);color:#414141;color:var(--circle-toggle-hint-color,#414141);display:inline-block;transition:color .2s;z-index:1}@media (max-width:703px){:host .nx-toggle-circle__label-hint{font-size:14px;font-size:var(--circle-toggle-hint-mobile-font-size,14px);line-height:20px;line-height:var(--circle-toggle-hint-mobile-line-height,20px);font-weight:300;font-weight:var(--circle-toggle-hint-mobile-font-weight,300);letter-spacing:.2px;letter-spacing:var(--circle-toggle-hint-mobile-letter-spacing,.2px)}}:host .nx-toggle-circle__icon{display:flex;justify-content:center;align-content:center}:host .nx-toggle-circle__icon nx-icon{color:#007ab3;color:var(--circle-toggle-icon-color,#007ab3)}:host .nx-toggle-circle__icon-image{pointer-events:none;position:relative;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}:host(.is-flipped) .nx-toggle-circle__icon-wrapper{background-color:#007ab3;background-color:var(--circle-toggle-selected-background-color,#007ab3);border-color:#007ab3;border-color:var(--circle-toggle-selected-border-color,#007ab3)}:host(.is-flipped) .nx-toggle-circle__icon nx-icon{color:#fff;color:var(--circle-toggle-selected-icon-color,#fff)}:host(.is-flipped) .nx-toggle-circle__content-text{color:#fff;color:var(--circle-toggle-selected-content-text-color,#fff)}:host(.is-flipped) .nx-toggle-circle__check-focus,:host(.is-flipped) .nx-toggle-circle__check-icon{opacity:1}:host:not(.is-disabled):not(.is-negative):not(.is-touched):hover .nx-toggle-circle__icon-wrapper{border-color:#006192;border-color:var(--circle-toggle-hover-border-color,#006192);background-color:#006192;background-color:var(--circle-toggle-hover-background-color,#006192)}:host:not(.is-disabled):not(.is-negative):not(.is-touched):hover:not(.is-flipped) .nx-toggle-circle__icon-wrapper{border-color:#007ab3;border-color:var(--circle-toggle-selected-border-color,#007ab3);background-color:#007ab3;background-color:var(--circle-toggle-selected-background-color,#007ab3)}:host:not(.is-disabled):not(.is-negative):not(.is-touched):hover .nx-toggle-circle__content-text{color:#fff;color:var(--circle-toggle-hover-icon-color,#fff)}:host:not(.is-disabled):not(.is-negative):not(.is-touched):hover .nx-toggle-circle__icon nx-icon{color:#fff;color:var(--circle-toggle-hover-icon-color,#fff)}:host:hover.is-flipped:not(.has-checkmark){cursor:auto}:host(.is-disabled){opacity:.4;cursor:not-allowed}:host(.is-negative) .nx-toggle-circle__icon-wrapper{border-color:#fff;background-color:transparent}:host(.is-negative) .nx-toggle-circle__content-text,:host(.is-negative) .nx-toggle-circle__icon nx-icon,:host(.is-negative) .nx-toggle-circle__label-hint,:host(.is-negative) .nx-toggle-circle__label-text{color:#fff}:host(.is-negative):not(.is-disabled):not(.is-touched):hover .nx-toggle-circle__icon-wrapper,:host(.is-negative.is-flipped) .nx-toggle-circle__icon-wrapper{border-color:#fff;background-color:#fff}:host(.is-negative):not(.is-disabled):not(.is-touched):hover .nx-toggle-circle__icon nx-icon,:host(.is-negative.is-flipped) .nx-toggle-circle__icon nx-icon{color:#007ab3}:host(.is-negative):not(.is-disabled):not(.is-touched):hover .nx-toggle-circle__content-text,:host(.is-negative.is-flipped) .nx-toggle-circle__content-text{color:#006192}@media screen and (-ms-high-contrast:active){.nx-toggle-circle__icon-wrapper{border-color:buttonText;background-color:buttonFace}.nx-toggle-circle__content-text{-ms-high-contrast-adjust:none}.nx-toggle-circle__label-hint,.nx-toggle-circle__label-text{color:buttonText}:host(.is-negative):not(.is-flipped):not(.is-disabled):not(.is-touched) .nx-toggle-circle__content-text,:host(.is-negative):not(.is-flipped):not(.is-disabled):not(.is-touched) .nx-toggle-circle__icon nx-icon,:host:not(.is-flipped) .nx-toggle-circle__content-text,:host:not(.is-flipped) .nx-toggle-circle__icon nx-icon{color:buttonText}:host(.is-flipped) .nx-toggle-circle__icon-wrapper,:host(.is-negative.is-flipped) .nx-toggle-circle__icon-wrapper{background:highlight;border-color:highlight;color:highlightText}:host(.is-flipped) .nx-toggle-circle__content-text,:host(.is-flipped) .nx-toggle-circle__icon nx-icon,:host(.is-negative.is-flipped) .nx-toggle-circle__content-text,:host(.is-negative.is-flipped) .nx-toggle-circle__icon nx-icon{color:highlightText}:host(.is-flipped) .nx-toggle-circle__check-icon,:host(.is-negative.is-flipped) .nx-toggle-circle__check-icon{border-color:windowText;color:windowText}:host.is-negative:not(.is-disabled):not(.is-touched):hover.is-flipped .nx-toggle-circle__content-text,:host.is-negative:not(.is-disabled):not(.is-touched):hover.is-flipped .nx-toggle-circle__icon nx-icon,:host:not(.is-disabled):not(.is-touched):hover.is-flipped .nx-toggle-circle__content-text,:host:not(.is-disabled):not(.is-touched):hover.is-flipped .nx-toggle-circle__icon nx-icon{color:highlightText}:host.is-negative:not(.is-disabled):not(.is-touched):hover:not(.is-flipped) .nx-toggle-circle__content-text,:host.is-negative:not(.is-disabled):not(.is-touched):hover:not(.is-flipped) .nx-toggle-circle__icon nx-icon,:host:not(.is-disabled):not(.is-touched):hover:not(.is-flipped) .nx-toggle-circle__content-text,:host:not(.is-disabled):not(.is-touched):hover:not(.is-flipped) .nx-toggle-circle__icon nx-icon{color:buttonText}:host(.is-disabled),:host(.is-disabled.is-flipped),:host(.is-disabled.is-flipped):hover{opacity:1}:host(.is-disabled) .nx-toggle-circle__icon-wrapper,:host(.is-disabled.is-flipped) .nx-toggle-circle__icon-wrapper,:host(.is-disabled.is-flipped):hover .nx-toggle-circle__icon-wrapper{border-color:GrayText;background:buttonFace;color:GrayText}:host(.is-disabled) .nx-toggle-circle__icon-wrapper .nx-toggle-circle__content-text,:host(.is-disabled) .nx-toggle-circle__icon-wrapper .nx-toggle-circle__icon nx-icon,:host(.is-disabled.is-flipped) .nx-toggle-circle__icon-wrapper .nx-toggle-circle__content-text,:host(.is-disabled.is-flipped) .nx-toggle-circle__icon-wrapper .nx-toggle-circle__icon nx-icon,:host(.is-disabled.is-flipped):hover .nx-toggle-circle__icon-wrapper .nx-toggle-circle__content-text,:host(.is-disabled.is-flipped):hover .nx-toggle-circle__icon-wrapper .nx-toggle-circle__icon nx-icon{color:GrayText}:host(.is-disabled) .nx-toggle-circle__check-icon,:host(.is-disabled.is-flipped) .nx-toggle-circle__check-icon,:host(.is-disabled.is-flipped):hover .nx-toggle-circle__check-icon{border-color:GrayText;color:GrayText}:host(.is-disabled) .nx-toggle-circle__label-hint,:host(.is-disabled) .nx-toggle-circle__label-text,:host(.is-disabled.is-flipped) .nx-toggle-circle__label-hint,:host(.is-disabled.is-flipped) .nx-toggle-circle__label-text,:host(.is-disabled.is-flipped):hover .nx-toggle-circle__label-hint,:host(.is-disabled.is-flipped):hover .nx-toggle-circle__label-text{color:GrayText}}"]
                    }] }
        ];
        NxIconToggleButtonComponent.propDecorators = {
            inGroup: [{ type: core.Input }],
            hint: [{ type: core.Input }],
            label: [{ type: core.Input }],
            checked: [{ type: core.Input }],
            icon: [{ type: core.Input }],
            svgUrl: [{ type: core.Input, args: ['svg',] }],
            disabled: [{ type: core.Input }],
            negative: [{ type: core.Input }],
            touched: [{ type: core.Input }],
            circleText: [{ type: core.Input }]
        };
        return NxIconToggleButtonComponent;
    }());
    if (false) {
        /** @type {?} */
        NxIconToggleButtonComponent.prototype.inGroup;
        /** @type {?} */
        NxIconToggleButtonComponent.prototype.hint;
        /** @type {?} */
        NxIconToggleButtonComponent.prototype.label;
        /** @type {?} */
        NxIconToggleButtonComponent.prototype.checked;
        /** @type {?} */
        NxIconToggleButtonComponent.prototype.icon;
        /** @type {?} */
        NxIconToggleButtonComponent.prototype.svgUrl;
        /** @type {?} */
        NxIconToggleButtonComponent.prototype.disabled;
        /** @type {?} */
        NxIconToggleButtonComponent.prototype.negative;
        /** @type {?} */
        NxIconToggleButtonComponent.prototype.touched;
        /** @type {?} */
        NxIconToggleButtonComponent.prototype.circleText;
    }

    /**
     * @fileoverview added by tsickle
     * Generated from: circle-toggle/circle-toggle.module.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var NxCircleToggleModule = /** @class */ (function () {
        function NxCircleToggleModule() {
        }
        NxCircleToggleModule.decorators = [
            { type: core.NgModule, args: [{
                        declarations: [
                            NxCircleToggleGroupComponent,
                            NxCircleToggleComponent,
                            NxIconToggleButtonComponent,
                            NxMobileToggleButtonComponent
                        ],
                        exports: [
                            NxCircleToggleGroupComponent,
                            NxIconToggleButtonComponent,
                            NxCircleToggleComponent,
                            NxMobileToggleButtonComponent
                        ],
                        imports: [
                            common.CommonModule,
                            icon.NxIconModule
                        ]
                    },] }
        ];
        return NxCircleToggleModule;
    }());

    /**
     * @fileoverview added by tsickle
     * Generated from: circle-toggle/public-api.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * Generated from: list/list.component.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /** @type {?} */
    var DEFAULT_TYPE$3 = 'normal';
    var NxListComponent = /** @class */ (function () {
        function NxListComponent() {
            /**
             * \@docs-private
             */
            this.negative = false;
            /**
             * \@docs-private
             */
            this.orderedCircle = false;
        }
        Object.defineProperty(NxListComponent.prototype, "classNames", {
            get: /**
             * @return {?}
             */
            function () {
                return this._classNames;
            },
            /**
             * Sets the visual appearance of the list. You can combine different values:
             *
             * xsmall | small | normal: The listed input values are expanded to the underlying BEM conform styles based
             * on modifiers. Defaults to normal.
             *
             * negative: Display the list with a negative set of styling.
             *
             * ordered-circle: Display the list item numbers in a color filled circle.
             */
            set: /**
             * Sets the visual appearance of the list. You can combine different values:
             *
             * xsmall | small | normal: The listed input values are expanded to the underlying BEM conform styles based
             * on modifiers. Defaults to normal.
             *
             * negative: Display the list with a negative set of styling.
             *
             * ordered-circle: Display the list item numbers in a color filled circle.
             * @param {?} value
             * @return {?}
             */
            function (value) {
                if (this._classNames === value) {
                    return;
                }
                this._classNames = value;
                var _a = __read(this._classNames.match(/xsmall|small|normal/) || [DEFAULT_TYPE$3], 1), _b = _a[0], type = _b === void 0 ? null : _b;
                this.type = (/** @type {?} */ (type));
                this.negative = !!this._classNames.match(/negative/);
                this.orderedCircle = !!this._classNames.match(/ordered-circle/);
            },
            enumerable: true,
            configurable: true
        });
        NxListComponent.decorators = [
            { type: core.Component, args: [{
                        // tslint:disable-next-line:component-selector
                        selector: 'ul[nxList], ol[nxList]',
                        template: '<ng-content></ng-content>',
                        changeDetection: core.ChangeDetectionStrategy.OnPush,
                        host: {
                            '[class.nx-list--xsmall]': 'type === "xsmall"',
                            '[class.nx-list--small]': 'type === "small"',
                            '[class.nx-list--normal]': 'type === "normal"',
                            '[class.nx-list--negative]': 'negative',
                            '[class.nx-list--ordered-circle]': 'orderedCircle',
                        },
                        styles: [":host{color:#414141;color:var(--list-text-color,#414141);list-style:none;margin-bottom:32px;padding:0;counter-reset:list}:host(.nx-list--normal){font-size:18px;font-size:var(--paragraph-02-font-size,18px);line-height:24px;line-height:var(--paragraph-02-line-height,24px);font-weight:400;font-weight:var(--paragraph-02-font-weight,400);letter-spacing:.2px;letter-spacing:var(--paragraph-02-letter-spacing,.2px)}:host(.nx-list--small){font-size:16px;font-size:var(--paragraph-03-font-size,16px);line-height:24px;line-height:var(--paragraph-03-line-height,24px);font-weight:400;font-weight:var(--paragraph-03-font-weight,400);letter-spacing:0;letter-spacing:var(--paragraph-03-letter-spacing,0)}:host(.nx-list--xsmall){font-size:14px;font-size:var(--paragraph-04-font-size,14px);line-height:20px;line-height:var(--paragraph-04-line-height,20px);font-weight:600;font-weight:var(--paragraph-04-font-weight,600);letter-spacing:.2px;letter-spacing:var(--paragraph-04-letter-spacing,.2px)}:host(.nx-list--negative){color:#fff}:host(.nx-list--negative) ::ng-deep .nx-list__icon{color:#fff}:host ::ng-deep .nx-list__icon{position:absolute;left:0;font-size:24px;font-size:var(--list-icon-size,24px);color:#5a5360;color:var(--list-icon-color,#5a5360);top:50%;transform:translateY(-50%);line-height:24px;line-height:var(--list-icon-size,24px);height:24px;height:var(--list-icon-size,24px)}:host ::ng-deep li{margin-bottom:16px;padding-left:36px;padding-left:calc(var(--list-icon-size,24px) + 12px);position:relative}:host(ul) ::ng-deep>li:not([nxlisticon]):before{background-color:#5a5360;background-color:var(--list-icon-color,#5a5360);border-radius:50%;content:\"\";display:inline-block;height:8px;width:8px;margin-right:16px;position:absolute;margin-left:-24px;margin-left:calc(-1 * var(--list-icon-size,24px));margin-top:8px;margin-top:calc((var(--paragraph-02-line-height,24px) - 8px)/ 2);transform:translateX(-50%)}:host(ul.nx-list--small) ::ng-deep>li:not([nxlisticon]):before{margin-top:8px;margin-top:calc((var(--paragraph-03-line-height,24px) - 8px)/ 2)}:host(ul.nx-list--xsmall) ::ng-deep>li:not([nxlisticon]):before{margin-top:6px;margin-top:calc((var(--paragraph-04-line-height,20px) - 8px)/ 2)}:host(ol) ::ng-deep>li:not([nxlisticon]):before{counter-increment:list;content:counter(list);position:absolute;font-size:inherit;font-weight:700;display:inline-block;width:24px;width:var(--list-icon-size,24px);text-align:center;left:0}:host ::ng-deep li>::ng-deep ol,:host ::ng-deep li>::ng-deep ul{margin-bottom:16px;margin-top:16px}:host(ol.nx-list--ordered-circle) ::ng-deep>li:not([nxlisticon]):before{width:24px;width:var(--list-circle-size,24px);font-size:16px;font-size:var(--paragraph-03-font-size,16px);line-height:24px;line-height:var(--paragraph-03-line-height,24px);font-weight:400;font-weight:var(--paragraph-03-font-weight,400);letter-spacing:0;letter-spacing:var(--paragraph-03-letter-spacing,0);color:#fff;color:var(--list-circle-text-color,#fff);left:0;top:50%;transform:translateY(-50%);z-index:2}@media screen and (-ms-high-contrast:active){:host(ul) ::ng-deep>li:not([nxlisticon]):before{background-color:windowText}:host(ol.nx-list--ordered-circle) ::ng-deep>li:not([nxlisticon]):before{border:1px solid windowText;border-radius:50%}:host(ol.nx-list--ordered-circle) ::ng-deep>li:not([nxlisticon]):after{color:windowText}}:host(ol.nx-list--ordered-circle) ::ng-deep>li:not([nxlisticon]):after{border-radius:50%;width:24px;width:var(--list-circle-size,24px);height:24px;height:var(--list-circle-size,24px);background-color:#5a5360;background-color:var(--list-icon-color,#5a5360);left:0;top:50%;transform:translateY(-50%);content:'';position:absolute}:host(ol.nx-list--ordered-circle.nx-list--negative)::ng-deep>li:not([nxlisticon]):after{background-color:#fff}:host(ol.nx-list--ordered-circle.nx-list--negative)::ng-deep>li:not([nxlisticon]):before{color:#5a5360}:host(ul.nx-list--negative) ::ng-deep>li:not([nxlisticon]):before{background-color:#fff}"]
                    }] }
        ];
        NxListComponent.propDecorators = {
            classNames: [{ type: core.Input, args: ['nxList',] }]
        };
        return NxListComponent;
    }());
    if (false) {
        /**
         * @type {?}
         * @private
         */
        NxListComponent.prototype._classNames;
        /**
         * \@docs-private
         * @type {?}
         */
        NxListComponent.prototype.type;
        /**
         * \@docs-private
         * @type {?}
         */
        NxListComponent.prototype.negative;
        /**
         * \@docs-private
         * @type {?}
         */
        NxListComponent.prototype.orderedCircle;
    }

    /**
     * @fileoverview added by tsickle
     * Generated from: list/list-icon.component.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var NxListIconComponent = /** @class */ (function () {
        function NxListIconComponent() {
        }
        NxListIconComponent.decorators = [
            { type: core.Component, args: [{
                        // tslint:disable-next-line:component-selector
                        selector: 'li[nxListIcon]',
                        template: "\n    <span class=\"nx-list__icon\">\n      <nx-icon [name]='name'></nx-icon>\n    </span>\n    <ng-content></ng-content>"
                    }] }
        ];
        NxListIconComponent.propDecorators = {
            viewRefPrefix: [{ type: core.ViewChild, args: ['viewRefPrefix', { read: core.ViewContainerRef, static: false },] }],
            name: [{ type: core.Input, args: ['nxListIcon',] }]
        };
        return NxListIconComponent;
    }());
    if (false) {
        /**
         * \@docs-private
         * @type {?}
         */
        NxListIconComponent.prototype.viewRefPrefix;
        /**
         * Sets the name of the icon to be displayed.
         * @type {?}
         */
        NxListIconComponent.prototype.name;
    }

    /**
     * @fileoverview added by tsickle
     * Generated from: list/list.module.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var NxListModule = /** @class */ (function () {
        function NxListModule() {
        }
        NxListModule.decorators = [
            { type: core.NgModule, args: [{
                        declarations: [NxListComponent, NxListIconComponent],
                        imports: [icon.NxIconModule],
                        exports: [NxListComponent, NxListIconComponent],
                        bootstrap: [icon.NxIconComponent]
                    },] }
        ];
        return NxListModule;
    }());

    /**
     * @fileoverview added by tsickle
     * Generated from: list/public-api.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * Generated from: radio-toggle/radio-toggle-button-base.component.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /** @type {?} */
    var nextId$4 = 0;
    /**
     * \@docs-private
     */
    var NxRadioToggleButtonBaseComponent = /** @class */ (function () {
        function NxRadioToggleButtonBaseComponent(renderer) {
            this.renderer = renderer;
            /**
             * \@docs-private
             */
            this.toggleButtonId = 'nx-radio-toggle-button-' + nextId$4++;
        }
        /** @docs-private */
        /**
         * \@docs-private
         * @param {?} event
         * @return {?}
         */
        NxRadioToggleButtonBaseComponent.prototype.triggerInputClick = /**
         * \@docs-private
         * @param {?} event
         * @return {?}
         */
        function (event) {
            event.stopPropagation();
            this.toggleInput.nativeElement.click();
        };
        /** @docs-private */
        /**
         * \@docs-private
         * @return {?}
         */
        NxRadioToggleButtonBaseComponent.prototype.setFirstButton = /**
         * \@docs-private
         * @return {?}
         */
        function () {
            this.renderer.addClass(this.labelContainer.nativeElement, 'nx-radio-toggle__label-container--first');
        };
        /** @docs-private */
        /**
         * \@docs-private
         * @return {?}
         */
        NxRadioToggleButtonBaseComponent.prototype.setLastButton = /**
         * \@docs-private
         * @return {?}
         */
        function () {
            this.renderer.addClass(this.labelContainer.nativeElement, 'nx-radio-toggle__label-container--last');
        };
        /** @docs-private */
        /**
         * \@docs-private
         * @return {?}
         */
        NxRadioToggleButtonBaseComponent.prototype.resetClasses = /**
         * \@docs-private
         * @return {?}
         */
        function () {
            utils.removeClasses(this.renderer, this.labelContainer, 'nx-radio-toggle__label-container--first nx-radio-toggle__label-container--last');
        };
        NxRadioToggleButtonBaseComponent.propDecorators = {
            value: [{ type: core.Input, args: ['nxValue',] }],
            labelContainer: [{ type: core.ViewChild, args: ['toggleButtonLabelContainer', { static: true },] }],
            toggleInput: [{ type: core.ViewChild, args: ['toggleInput', { static: true },] }]
        };
        return NxRadioToggleButtonBaseComponent;
    }());
    if (false) {
        /**
         * \@docs-private
         * @type {?}
         */
        NxRadioToggleButtonBaseComponent.prototype.toggleButtonId;
        /**
         * \@docs-private
         * @type {?}
         */
        NxRadioToggleButtonBaseComponent.prototype.value;
        /**
         * \@docs-private
         * @type {?}
         */
        NxRadioToggleButtonBaseComponent.prototype.labelContainer;
        /**
         * \@docs-private
         * @type {?}
         */
        NxRadioToggleButtonBaseComponent.prototype.toggleInput;
        /**
         * \@docs-private
         * @type {?}
         * @protected
         */
        NxRadioToggleButtonBaseComponent.prototype.renderer;
    }

    /**
     * @fileoverview added by tsickle
     * Generated from: radio-toggle/radio-toggle.component.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /** @type {?} */
    var nextId$5 = 0;
    /** @type {?} */
    var MAPPING$1 = {
        'negative': 'nx-radio-toggle--negative',
        'small': 'nx-radio-toggle--small',
    };
    var NxRadioToggleComponent = /** @class */ (function () {
        function NxRadioToggleComponent(renderer, _changeDetectorRef, ngControl, _errorStateMatcher, _parentForm, _parentFormGroup) {
            this.renderer = renderer;
            this._changeDetectorRef = _changeDetectorRef;
            this.ngControl = ngControl;
            this._errorStateMatcher = _errorStateMatcher;
            this._parentForm = _parentForm;
            this._parentFormGroup = _parentFormGroup;
            this._toggleId = (nextId$5++).toString();
            this._destroyed = new rxjs.Subject();
            this._disabled = false;
            /**
             * \@docs-private
             */
            this.errorState = false;
            // emits to signal children to run change detection
            this._disableChange = new rxjs.Subject();
            /**
             * \@docs-private
             */
            this.toggleButtons = new core.QueryList();
            this.onTouchedCallback = (/**
             * @return {?}
             */
            function () { });
            this.onChangeCallback = (/**
             * @param {?} option
             * @return {?}
             */
            function (option) { });
            if (this.ngControl) {
                // Note: we provide the value accessor through here, instead of
                // the `providers` to avoid running into a circular import.
                this.ngControl.valueAccessor = this;
            }
        }
        Object.defineProperty(NxRadioToggleComponent.prototype, "disabled", {
            get: /**
             * @return {?}
             */
            function () {
                return this._disabled;
            },
            /** Sets the component to the disabled state.*/
            set: /**
             * Sets the component to the disabled state.
             * @param {?} value
             * @return {?}
             */
            function (value) {
                /** @type {?} */
                var coerced = coercion.coerceBooleanProperty(value);
                if (this._disabled !== coerced) {
                    this._disabled = coerced;
                    this._disableChange.next();
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NxRadioToggleComponent.prototype, "name", {
            get: /**
             * @return {?}
             */
            function () {
                return this._name;
            },
            /** Sets the name used for accessibility. */
            set: /**
             * Sets the name used for accessibility.
             * @param {?} value
             * @return {?}
             */
            function (value) {
                if (this._name !== value) {
                    this._name = value;
                    this._changeDetectorRef.markForCheck();
                }
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        NxRadioToggleComponent.prototype.ngAfterViewInit = /**
         * @return {?}
         */
        function () {
            this.subscribeToToggleButtonsChange();
        };
        /**
         * @return {?}
         */
        NxRadioToggleComponent.prototype.ngAfterContentInit = /**
         * @return {?}
         */
        function () {
            var _this = this;
            /** @type {?} */
            var changedOrDestroyed = rxjs.merge(this.toggleButtons.changes, this._destroyed);
            rxjs.merge.apply(void 0, __spread(this.toggleButtons.map((/**
             * @param {?} button
             * @return {?}
             */
            function (button) { return button.onChecked; })))).pipe(operators.takeUntil(changedOrDestroyed))
                .subscribe((/**
             * @param {?} change
             * @return {?}
             */
            function (change) {
                _this._selection = change.value;
                _this.onChangeCallback(_this._selection);
            }));
        };
        /**
         * @return {?}
         */
        NxRadioToggleComponent.prototype.ngOnDestroy = /**
         * @return {?}
         */
        function () {
            this._destroyed.next();
            this._destroyed.complete();
            this._disableChange.complete();
        };
        /**
         * @return {?}
         */
        NxRadioToggleComponent.prototype.ngDoCheck = /**
         * @return {?}
         */
        function () {
            if (this.ngControl) {
                // We need to re-evaluate this on every change detection cycle, because there are some
                // error triggers that we can't subscribe to (e.g. parent form submissions). This means
                // that whatever logic is in here has to be super lean or we risk destroying the performance.
                this.updateErrorState();
            }
        };
        /** @docs-private */
        /**
         * \@docs-private
         * @return {?}
         */
        NxRadioToggleComponent.prototype.subscribeToToggleButtonsChange = /**
         * \@docs-private
         * @return {?}
         */
        function () {
            var _this = this;
            this.toggleButtons.changes
                .pipe(operators.startWith(this.toggleButtons), operators.filter((/**
             * @param {?} toggles
             * @return {?}
             */
            function (toggles) { return toggles.length > 0; })), operators.takeUntil(this._destroyed)).subscribe((/**
             * @param {?} toggles
             * @return {?}
             */
            function (toggles) {
                toggles.forEach((/**
                 * @param {?} toggle
                 * @return {?}
                 */
                function (toggle) {
                    toggle.resetClasses();
                    if (toggle.value === _this.selection) {
                        // We need to defer the selection for the edge case that the button with the value of this.selection
                        // didn't exist yet but was added afterwards to prevent changed after checked errors
                        setTimeout((/**
                         * @return {?}
                         */
                        function () { return toggle.select(); }));
                    }
                }));
                toggles.first.setFirstButton();
                toggles.last.setLastButton();
            }));
        };
        /**
         * @param {?} onChangeCallback
         * @return {?}
         */
        NxRadioToggleComponent.prototype.registerOnChange = /**
         * @param {?} onChangeCallback
         * @return {?}
         */
        function (onChangeCallback) {
            this.onChangeCallback = onChangeCallback;
        };
        /**
         * @param {?} onTouchedCallback
         * @return {?}
         */
        NxRadioToggleComponent.prototype.registerOnTouched = /**
         * @param {?} onTouchedCallback
         * @return {?}
         */
        function (onTouchedCallback) {
            this.onTouchedCallback = onTouchedCallback;
        };
        /** Preselects the respective options. */
        /**
         * Preselects the respective options.
         * @param {?} value
         * @return {?}
         */
        NxRadioToggleComponent.prototype.writeValue = /**
         * Preselects the respective options.
         * @param {?} value
         * @return {?}
         */
        function (value) {
            var _this = this;
            this._selection = value;
            /** @type {?} */
            var correspondingButton = this.toggleButtons.find((/**
             * @param {?} button
             * @return {?}
             */
            function (button) { return button.value === _this._selection; }));
            if (correspondingButton) {
                ((/** @type {?} */ (correspondingButton))).select();
            }
        };
        /**
         * @param {?} isDisabled
         * @return {?}
         */
        NxRadioToggleComponent.prototype.setDisabledState = /**
         * @param {?} isDisabled
         * @return {?}
         */
        function (isDisabled) {
            this.disabled = isDisabled;
        };
        Object.defineProperty(NxRadioToggleComponent.prototype, "id", {
            /** @docs-private */
            get: /**
             * \@docs-private
             * @return {?}
             */
            function () {
                return "nx-radio-toggle-" + this._toggleId;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NxRadioToggleComponent.prototype, "style", {
            /** Sets the modifiers for the component. */
            set: /**
             * Sets the modifiers for the component.
             * @param {?} value
             * @return {?}
             */
            function (value) {
                var _this = this;
                /** @type {?} */
                var modifierClasses = utils.mapClassNames(value, [], MAPPING$1);
                modifierClasses.split(' ')
                    .forEach((/**
                 * @param {?} className
                 * @return {?}
                 */
                function (className) { return _this.renderer.addClass(_this.toggleContainer.nativeElement, className); }));
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NxRadioToggleComponent.prototype, "selection", {
            get: /**
             * @return {?}
             */
            function () {
                return this._selection;
            },
            /** @docs-private */
            set: /**
             * \@docs-private
             * @param {?} selection
             * @return {?}
             */
            function (selection) {
                this._selection = selection;
                this.onChangeCallback(selection);
            },
            enumerable: true,
            configurable: true
        });
        /** @docs-private */
        /**
         * \@docs-private
         * @param {?} value
         * @return {?}
         */
        NxRadioToggleComponent.prototype.change = /**
         * \@docs-private
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this.onChangeCallback(value);
            if (this.onTouchedCallback) {
                this.onTouchedCallback();
            }
        };
        /** @docs-private */
        /**
         * \@docs-private
         * @return {?}
         */
        NxRadioToggleComponent.prototype.updateErrorState = /**
         * \@docs-private
         * @return {?}
         */
        function () {
            /** @type {?} */
            var oldState = this.errorState;
            /** @type {?} */
            var parent = this._parentFormGroup || this._parentForm;
            /** @type {?} */
            var control = this.ngControl ? (/** @type {?} */ (this.ngControl.control)) : null;
            /** @type {?} */
            var newState = this._errorStateMatcher.isErrorState(control, parent);
            if (newState !== oldState) {
                this.errorState = newState;
            }
        };
        NxRadioToggleComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'nx-radio-toggle',
                        template: "<div #toggleContainer class=\"nx-radio-toggle\" role=\"radiogroup\" [attr.aria-label]=\"name\">\n   <ng-content></ng-content>\n</div>\n",
                        changeDetection: core.ChangeDetectionStrategy.OnPush,
                        styles: [":host{display:block}.nx-radio-toggle{display:flex;height:100%}@media (max-width:703px){.nx-radio-toggle{flex-direction:column;text-align:center;width:100%;justify-content:center;align-items:center}}"]
                    }] }
        ];
        /** @nocollapse */
        NxRadioToggleComponent.ctorParameters = function () { return [
            { type: core.Renderer2 },
            { type: core.ChangeDetectorRef },
            { type: forms.NgControl, decorators: [{ type: core.Optional }, { type: core.Self }] },
            { type: utils.ErrorStateMatcher },
            { type: forms.NgForm, decorators: [{ type: core.Optional }] },
            { type: forms.FormGroupDirective, decorators: [{ type: core.Optional }] }
        ]; };
        NxRadioToggleComponent.propDecorators = {
            disabled: [{ type: core.Input, args: ['nxDisabled',] }],
            toggleContainer: [{ type: core.ViewChild, args: ['toggleContainer', { static: true },] }],
            name: [{ type: core.Input, args: ['nxName',] }],
            toggleButtons: [{ type: core.ContentChildren, args: [NxRadioToggleButtonBaseComponent,] }],
            writeValue: [{ type: core.Input, args: ['nxSelection',] }],
            style: [{ type: core.Input, args: ['nxStyle',] }]
        };
        return NxRadioToggleComponent;
    }());
    if (false) {
        /**
         * @type {?}
         * @private
         */
        NxRadioToggleComponent.prototype._toggleId;
        /**
         * @type {?}
         * @private
         */
        NxRadioToggleComponent.prototype._selection;
        /**
         * @type {?}
         * @private
         */
        NxRadioToggleComponent.prototype._destroyed;
        /**
         * @type {?}
         * @private
         */
        NxRadioToggleComponent.prototype._disabled;
        /**
         * \@docs-private
         * @type {?}
         */
        NxRadioToggleComponent.prototype.errorState;
        /** @type {?} */
        NxRadioToggleComponent.prototype._disableChange;
        /**
         * @type {?}
         * @private
         */
        NxRadioToggleComponent.prototype.toggleContainer;
        /**
         * @type {?}
         * @private
         */
        NxRadioToggleComponent.prototype._name;
        /**
         * \@docs-private
         * @type {?}
         */
        NxRadioToggleComponent.prototype.toggleButtons;
        /**
         * @type {?}
         * @private
         */
        NxRadioToggleComponent.prototype.onTouchedCallback;
        /**
         * @type {?}
         * @private
         */
        NxRadioToggleComponent.prototype.onChangeCallback;
        /**
         * @type {?}
         * @private
         */
        NxRadioToggleComponent.prototype.renderer;
        /**
         * @type {?}
         * @private
         */
        NxRadioToggleComponent.prototype._changeDetectorRef;
        /**
         * \@docs-private
         * @type {?}
         */
        NxRadioToggleComponent.prototype.ngControl;
        /**
         * @type {?}
         * @private
         */
        NxRadioToggleComponent.prototype._errorStateMatcher;
        /**
         * @type {?}
         * @private
         */
        NxRadioToggleComponent.prototype._parentForm;
        /**
         * @type {?}
         * @private
         */
        NxRadioToggleComponent.prototype._parentFormGroup;
    }

    /**
     * @fileoverview added by tsickle
     * Generated from: radio-toggle/radio-toggle-button.component.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * \@docs-private
     */
    var /**
     * \@docs-private
     */
    NxRadioToggleButtonChange = /** @class */ (function () {
        function NxRadioToggleButtonChange(source, value) {
            this.source = source;
            this.value = value;
        }
        return NxRadioToggleButtonChange;
    }());
    if (false) {
        /** @type {?} */
        NxRadioToggleButtonChange.prototype.source;
        /** @type {?} */
        NxRadioToggleButtonChange.prototype.value;
    }
    var NxRadioToggleButtonComponent = /** @class */ (function (_super) {
        __extends(NxRadioToggleButtonComponent, _super);
        function NxRadioToggleButtonComponent(radioToggle, 
        /** @docs-private */
        renderer, _changeDetectorRef, _toggleDispatcher) {
            var _this = _super.call(this, renderer) || this;
            _this.radioToggle = radioToggle;
            _this._changeDetectorRef = _changeDetectorRef;
            _this._toggleDispatcher = _toggleDispatcher;
            /**
             * \@docs-private
             */
            // emits when the button is checked to notify the group
            _this.onChecked = new rxjs.Subject();
            _this._destroyed = new rxjs.Subject();
            _this._disabled = false;
            _this._selected = false;
            /**
             * Unregister function for _expansionDispatcher.
             */
            _this._removeUniqueSelectionListener = (/**
             * @return {?}
             */
            function () { });
            _this._removeUniqueSelectionListener = _this._toggleDispatcher.listen((/**
             * @param {?} id
             * @param {?} radioToggleId
             * @return {?}
             */
            function (id, radioToggleId) {
                if (_this.radioToggle && _this.radioToggle.id === radioToggleId && _this.id !== id) {
                    _this._selected = false;
                    // need to let change detector know in case that the select() function was called on another button
                    _this._changeDetectorRef.markForCheck();
                }
            }));
            _this.radioToggle._disableChange.pipe(operators.takeUntil(_this._destroyed)).subscribe((/**
             * @return {?}
             */
            function () {
                _this._changeDetectorRef.markForCheck();
            }));
            return _this;
        }
        Object.defineProperty(NxRadioToggleButtonComponent.prototype, "disabled", {
            get: /**
             * @return {?}
             */
            function () {
                return this._disabled || (this.radioToggle && this.radioToggle.disabled);
            },
            /** @docs-private */
            set: /**
             * \@docs-private
             * @param {?} value
             * @return {?}
             */
            function (value) {
                this._disabled = coercion.coerceBooleanProperty(value);
                this._changeDetectorRef.markForCheck();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NxRadioToggleButtonComponent.prototype, "selected", {
            get: /**
             * @return {?}
             */
            function () {
                return this._selected;
            },
            /** Sets the checked state and notify siblings and the parent group about the change */
            // Only use this if you want the onChecked event to be fired, this will inform the parent about the change!
            // To select a button without firing the event use the select() function
            set: /**
             * Sets the checked state and notify siblings and the parent group about the change
             * @param {?} value
             * @return {?}
             */
            // Only use this if you want the onChecked event to be fired, this will inform the parent about the change!
            // To select a button without firing the event use the select() function
            function (value) {
                if (this._selected !== value) {
                    this._selected = value;
                    if (this._selected) {
                        this._notifySiblings();
                        this._emitCheckedEvent();
                        if (this.radioToggle !== null) {
                            this.radioToggle.change(this.value);
                        }
                    }
                    this._changeDetectorRef.markForCheck();
                }
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        NxRadioToggleButtonComponent.prototype.ngOnDestroy = /**
         * @return {?}
         */
        function () {
            this._removeUniqueSelectionListener();
            this._destroyed.next();
            this._destroyed.complete();
        };
        Object.defineProperty(NxRadioToggleButtonComponent.prototype, "toggleId", {
            /** @docs-private */
            get: /**
             * \@docs-private
             * @return {?}
             */
            function () {
                return this.radioToggle.id;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NxRadioToggleButtonComponent.prototype, "id", {
            /** @docs-private */
            get: /**
             * \@docs-private
             * @return {?}
             */
            function () {
                return this.toggleButtonId;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @private
         * @return {?}
         */
        NxRadioToggleButtonComponent.prototype._notifySiblings = /**
         * @private
         * @return {?}
         */
        function () {
            /** @type {?} */
            var toggleId = this.radioToggle ? this.radioToggle.id : this.id;
            this._toggleDispatcher.notify(this.id, toggleId);
        };
        /**
         * @private
         * @return {?}
         */
        NxRadioToggleButtonComponent.prototype._emitCheckedEvent = /**
         * @private
         * @return {?}
         */
        function () {
            this.onChecked.next(new NxRadioToggleButtonChange(this, this.value));
        };
        // Does NOT emit the onChecked event. Useful when you need to set initial
        // state. Used by the parent to set checked states on initialization and during
        // writeValue() changes.
        /** @docs-private */
        // Does NOT emit the onChecked event. Useful when you need to set initial
        // state. Used by the parent to set checked states on initialization and during
        // writeValue() changes.
        /**
         * \@docs-private
         * @return {?}
         */
        NxRadioToggleButtonComponent.prototype.select = 
        // Does NOT emit the onChecked event. Useful when you need to set initial
        // state. Used by the parent to set checked states on initialization and during
        // writeValue() changes.
        /**
         * \@docs-private
         * @return {?}
         */
        function () {
            if (!this._selected) {
                this._selected = true;
                this._notifySiblings();
            }
            this._changeDetectorRef.markForCheck();
        };
        /** @docs-private */
        /**
         * \@docs-private
         * @return {?}
         */
        NxRadioToggleButtonComponent.prototype.onKeyupSpace = /**
         * \@docs-private
         * @return {?}
         */
        function () {
            this._selected = false;
            this._notifySiblings();
        };
        /** @docs-private */
        /**
         * \@docs-private
         * @return {?}
         */
        NxRadioToggleButtonComponent.prototype._controlInvalid = /**
         * \@docs-private
         * @return {?}
         */
        function () {
            return !!(this.radioToggle && this.radioToggle.errorState);
        };
        NxRadioToggleButtonComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'nx-radio-toggle-button',
                        changeDetection: core.ChangeDetectionStrategy.OnPush,
                        template: "<input [attr.id]=\"toggleButtonId\"\n    #toggleInput\n    [attr.name]=\"toggleId\"\n    [checked]=\"selected\"\n    class=\"nx-radio-toggle__input\"\n    type=\"radio\"\n    (click)=\"selected = true\"\n    [disabled]=\"disabled\">\n<div (click)=\"triggerInputClick($event)\" #toggleButtonLabelContainer class=\"nx-radio-toggle__label-container\">\n  <label [attr.for]=\"toggleButtonId\" class=\"nx-radio-toggle__label\">\n      <nx-icon class=\"nx-toggle-button__mobile-check\" name=\"check\" aria-hidden=\"true\"></nx-icon>\n      <ng-content></ng-content>\n  </label>\n</div>\n\n\n",
                        providers: [
                            {
                                provide: NxRadioToggleButtonBaseComponent, useExisting: core.forwardRef((/**
                                 * @return {?}
                                 */
                                function () { return NxRadioToggleButtonComponent; }))
                            }
                        ],
                        host: {
                            '[class.has-error]': '_controlInvalid() || null',
                            '[attr.aria-invalid]': '_controlInvalid() || null'
                        },
                        styles: [":host{display:flex;position:relative;flex-direction:row}:host.has-error .nx-radio-toggle__input:checked+.nx-radio-toggle__label-container{border-color:#dc3149;border-color:var(--danger,#dc3149);background-color:#dc3149;background-color:var(--danger,#dc3149)}:host.has-error .nx-radio-toggle__label-container{border-color:#dc3149;border-color:var(--danger,#dc3149);color:#dc3149;color:var(--danger,#dc3149)}:host.has-error:hover .nx-radio-toggle__label-container{color:#fff}.nx-radio-toggle__input{opacity:0;position:absolute}.nx-radio-toggle__input:active+.nx-radio-toggle__label-container{background-color:#003781;background-color:var(--toggle-button-active-background-color,#003781);border-color:#003781;border-color:var(--toggle-button-active-border-color,#003781);color:#fff;color:var(--toggle-button-active-text-color,#fff)}.nx-radio-toggle__input:checked:disabled+.nx-radio-toggle__label-container{background-color:rgba(0,122,179,.4);background-color:var(--toggle-button-disabled-selected-background-color,rgba(0,122,179,.4));border-color:transparent;border-color:var(--toggle-button-disabled-selected-border-color,transparent);color:rgba(255,255,255,.4);color:var(--toggle-button-disabled-selected-text-color,rgba(255,255,255,.4))}.nx-radio-toggle__input:disabled+.nx-radio-toggle__label-container{background-color:#fff;background-color:var(--toggle-button-disabled-background-color,#fff);border-color:rgba(0,122,179,.4);border-color:var(--toggle-button-disabled-border-color,rgba(0,122,179,.4));color:rgba(0,97,146,.4);color:var(--toggle-button-disabled-text-color,rgba(0,97,146,.4));cursor:not-allowed}.nx-radio-toggle__input:disabled+.nx-radio-toggle__label-container .nx-radio-toggle__label{cursor:not-allowed}@media screen and (-ms-high-contrast:active){.nx-radio-toggle__input:disabled+.nx-radio-toggle__label-container{border-color:GrayText;color:GrayText}}.nx-radio-toggle__input:checked+.nx-radio-toggle__label-container{background-color:#007ab3;background-color:var(--toggle-button-selected-background-color,#007ab3);border-color:#007ab3;border-color:var(--toggle-button-selected-border-color,#007ab3);color:#fff;color:var(--toggle-button-selected-text-color,#fff);cursor:default}.nx-radio-toggle__input:checked+.nx-radio-toggle__label-container .nx-radio-toggle__label{cursor:default}.nx-toggle-button__mobile-check{display:none;font-size:24px;margin-right:8px;height:24px}:host-context(.nx-radio-toggle--small) .nx-radio-toggle__label-container{font-size:14px;font-size:var(--toggle-button-small-font-size,14px);line-height:16px;line-height:var(--toggle-button-small-line-height,16px);font-weight:600;font-weight:var(--toggle-button-small-font-weight,600);letter-spacing:1px;letter-spacing:var(--toggle-button-small-letter-spacing,1px);min-height:16px;padding:6px;text-transform:none}.nx-radio-toggle{-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;cursor:pointer}.nx-radio-toggle__label-container.nx-radio-toggle__label-container--first{border-radius:4px 0 0 4px;border-width:2px 0 2px 2px}@media (max-width:703px){:host{width:100%}.nx-radio-toggle__input:checked+.nx-radio-toggle__label-container .nx-toggle-button__mobile-check{display:inline-block}:host-context(.nx-radio-toggle--small) .nx-radio-toggle__label-container{font-size:16px;font-size:var(--toggle-button-large-font-size,16px);line-height:24px;line-height:var(--toggle-button-large-line-height,24px);font-weight:600;font-weight:var(--toggle-button-large-font-weight,600);letter-spacing:1px;letter-spacing:var(--toggle-button-large-letter-spacing,1px);padding:11px 31px}.nx-radio-toggle__label-container.nx-radio-toggle__label-container--first{border-width:2px 2px 1px;border-radius:4px 4px 0 0}}.nx-radio-toggle__label-container.nx-radio-toggle__label-container--last{border-top-right-radius:4px;border-bottom-right-radius:4px;border-width:2px}.nx-radio-toggle__label-container{font-size:16px;font-size:var(--toggle-button-large-font-size,16px);line-height:24px;line-height:var(--toggle-button-large-line-height,24px);font-weight:600;font-weight:var(--toggle-button-large-font-weight,600);letter-spacing:1px;letter-spacing:var(--toggle-button-large-letter-spacing,1px);padding:10px 30px;color:#006192;color:var(--toggle-button-unselected-text-color,#006192);background-color:transparent;background-color:var(--toggle-button-unselected-background-color,transparent);border-color:#007ab3;border-color:var(--toggle-button-unselected-border-color,#007ab3);border-style:solid;border-radius:0;border-width:2px 0 2px 2px;cursor:pointer;flex-grow:1;text-align:center;text-transform:uppercase;text-transform:var(--button-text-transform,uppercase);transition:background-color .2s,border-color .2s,color .2s;display:flex;align-items:center;height:100%;min-height:24px}@media (max-width:703px){.nx-radio-toggle__label-container.nx-radio-toggle__label-container--last{border-width:1px 2px 2px;border-radius:0 0 4px 4px}.nx-radio-toggle__label-container.nx-radio-toggle__label-container--last.nx-radio-toggle__label-container--first{border-radius:4px;border-width:2px}.nx-radio-toggle__label-container{border-width:1px 2px;justify-content:center;padding:11px 31px}}.nx-radio-toggle__label-container:hover{background-color:#006192;background-color:var(--toggle-button-hover-background-color,#006192);border-color:#006192;border-color:var(--toggle-button-hover-border-color,#006192);color:#fff;color:var(--toggle-button-hover-text-color,#fff)}@media screen and (-ms-high-contrast:active){.nx-radio-toggle__input:checked+.nx-radio-toggle__label-container{background-color:highlight;border-color:buttonText}.nx-radio-toggle__input:checked+.nx-radio-toggle__label-container .nx-radio-toggle__label{-ms-high-contrast-adjust:none;color:highlightText}.nx-radio-toggle__label-container{border-color:buttonText;background-color:buttonFace;color:buttonText}.nx-radio-toggle__label-container .nx-radio-toggle__label{-ms-high-contrast-adjust:none}}:host-context(.nx-radio-toggle--negative) .nx-radio-toggle__input:focus+.nx-radio-toggle__label-container{background-color:#d9d9d9;border-color:#d9d9d9;color:#007ab3}:host-context(.nx-radio-toggle--negative) .nx-radio-toggle__input:active+.nx-radio-toggle__label-container{background-color:#c2c2c2;border-color:#c2c2c2;color:#007ab3}:host-context(.nx-radio-toggle--negative) .nx-radio-toggle__input:disabled:checked+.nx-radio-toggle__label-container{background-color:rgba(255,255,255,.4);border-color:transparent;color:rgba(65,65,65,.4)}:host-context(.nx-radio-toggle--negative) .nx-radio-toggle__input:disabled+.nx-radio-toggle__label-container{background-color:transparent;border-color:rgba(255,255,255,.4);color:rgba(255,255,255,.4)}:host-context(.nx-radio-toggle--negative) .nx-radio-toggle__input:checked+.nx-radio-toggle__label-container{background-color:#fff;border-color:#fff;color:#006192}:host-context(.nx-radio-toggle--negative) .nx-radio-toggle__label-container{border-color:#fff;color:#fff}:host-context(.nx-radio-toggle--negative) .nx-radio-toggle__label-container:hover{background-color:#d9d9d9;border-color:#d9d9d9;color:#006192}.nx-radio-toggle__label{display:flex;align-items:center;cursor:pointer}:host-context([data-whatinput=keyboard]) .nx-radio-toggle__input:focus+.nx-radio-toggle__label-container{box-shadow:0 0 0 2px #fff,0 0 0 6px #009de6;box-shadow:var(--focus-box-shadow,0 0 0 2px #fff,0 0 0 6px #009de6);z-index:1}@media screen and (-ms-high-contrast:active){:host-context([data-whatinput=keyboard]) .nx-radio-toggle__input:focus+.nx-radio-toggle__label-container{box-shadow:0 0 0 2px background,0 0 0 6px windowText}}"]
                    }] }
        ];
        /** @nocollapse */
        NxRadioToggleButtonComponent.ctorParameters = function () { return [
            { type: NxRadioToggleComponent, decorators: [{ type: core.Inject, args: [core.forwardRef((/**
                             * @return {?}
                             */
                            function () { return NxRadioToggleComponent; })),] }] },
            { type: core.Renderer2 },
            { type: core.ChangeDetectorRef },
            { type: collections.UniqueSelectionDispatcher }
        ]; };
        NxRadioToggleButtonComponent.propDecorators = {
            disabled: [{ type: core.Input, args: ['nxDisabled',] }],
            selected: [{ type: core.Input, args: ['nxSelected',] }],
            onKeyupSpace: [{ type: core.HostListener, args: ['keyup.space',] }]
        };
        return NxRadioToggleButtonComponent;
    }(NxRadioToggleButtonBaseComponent));
    if (false) {
        /**
         * \@docs-private
         * @type {?}
         */
        NxRadioToggleButtonComponent.prototype.onChecked;
        /**
         * @type {?}
         * @private
         */
        NxRadioToggleButtonComponent.prototype._destroyed;
        /**
         * @type {?}
         * @private
         */
        NxRadioToggleButtonComponent.prototype._disabled;
        /**
         * @type {?}
         * @private
         */
        NxRadioToggleButtonComponent.prototype._selected;
        /**
         * Unregister function for _expansionDispatcher.
         * @type {?}
         * @private
         */
        NxRadioToggleButtonComponent.prototype._removeUniqueSelectionListener;
        /**
         * @type {?}
         * @private
         */
        NxRadioToggleButtonComponent.prototype.radioToggle;
        /**
         * @type {?}
         * @private
         */
        NxRadioToggleButtonComponent.prototype._changeDetectorRef;
        /**
         * @type {?}
         * @private
         */
        NxRadioToggleButtonComponent.prototype._toggleDispatcher;
    }

    /**
     * @fileoverview added by tsickle
     * Generated from: radio-toggle/radio-toggle.module.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var NxRadioToggleModule = /** @class */ (function () {
        function NxRadioToggleModule() {
        }
        NxRadioToggleModule.decorators = [
            { type: core.NgModule, args: [{
                        declarations: [NxRadioToggleComponent, NxRadioToggleButtonComponent],
                        exports: [NxRadioToggleComponent, NxRadioToggleButtonComponent],
                        imports: [common.CommonModule, forms.FormsModule, icon.NxIconModule]
                    },] }
        ];
        return NxRadioToggleModule;
    }());

    /**
     * @fileoverview added by tsickle
     * Generated from: radio-toggle/public-api.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * Generated from: spinner/spinner.component.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /** @type {?} */
    var DEFAULT_SIZE$1 = 'small';
    var NxSpinnerComponent = /** @class */ (function () {
        function NxSpinnerComponent(_changeDetectorRef) {
            this._changeDetectorRef = _changeDetectorRef;
            this._size = DEFAULT_SIZE$1;
            this._negative = false;
        }
        Object.defineProperty(NxSpinnerComponent.prototype, "size", {
            get: /**
             * @return {?}
             */
            function () {
                return this._size;
            },
            /** Sets the size of the spinner. Default is 'small'. */
            set: /**
             * Sets the size of the spinner. Default is 'small'.
             * @param {?} value
             * @return {?}
             */
            function (value) {
                if (value !== this._size) {
                    this._size = value;
                    this._changeDetectorRef.markForCheck();
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NxSpinnerComponent.prototype, "negative", {
            get: /**
             * @return {?}
             */
            function () {
                return this._negative;
            },
            /** Whether the spinner should use a negative styling. */
            set: /**
             * Whether the spinner should use a negative styling.
             * @param {?} value
             * @return {?}
             */
            function (value) {
                if (value !== this._negative) {
                    this._negative = coercion.coerceBooleanProperty(value);
                    this._changeDetectorRef.markForCheck();
                }
            },
            enumerable: true,
            configurable: true
        });
        NxSpinnerComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'nx-spinner',
                        template: "<div class=\"nx-spinner__spin-block\">\n  <div class=\"nx-spinner__edge-left\"></div>\n  <div class=\"nx-spinner__edge-right\"></div>\n</div>",
                        changeDetection: core.ChangeDetectionStrategy.OnPush,
                        host: {
                            '[class.nx-spinner--small]': 'size === "small"',
                            '[class.nx-spinner--medium]': 'size === "medium"',
                            '[class.nx-spinner--large]': 'size === "large"',
                            '[class.nx-spinner--negative]': 'negative',
                            '[attr.role]': '"status"',
                            '[attr.aria-busy]': '"true"',
                            '[attr.aria-live]': '"assertive"',
                        },
                        styles: ["@-webkit-keyframes spin{0%{transform:rotate(45deg)}100%{transform:rotate(405deg)}}@keyframes spin{0%{transform:rotate(45deg)}100%{transform:rotate(405deg)}}:host{position:relative;display:block}:host(.nx-spinner--small){width:16px;height:16px}:host(.nx-spinner--medium){width:24px;height:24px}:host(.nx-spinner--large){width:40px;height:40px}.nx-spinner__spin-block{width:100%;height:100%;transform:rotate(45deg);border-style:solid;border-radius:50%;border-color:#007ab3 #ececec #ececec;border-color:var(--spinner-background-color,#ececec);border-top-color:var(--spinner-indicator-color,#007ab3);-webkit-animation-name:spin;animation-name:spin;-webkit-animation-duration:.8s;animation-duration:.8s;-webkit-animation-iteration-count:infinite;animation-iteration-count:infinite;-webkit-animation-timing-function:linear;animation-timing-function:linear}:host(.nx-spinner--small) .nx-spinner__spin-block{border-width:calc(1.6px)}:host(.nx-spinner--medium) .nx-spinner__spin-block{border-width:calc(2.4px)}:host(.nx-spinner--large) .nx-spinner__spin-block{border-width:calc(4px)}.nx-spinner__edge-left,.nx-spinner__edge-right{width:12%;height:12%;border-radius:50%;background-color:#007ab3;background-color:var(--spinner-indicator-color,#007ab3);position:absolute;top:4%}.nx-spinner__edge-left{left:4%}.nx-spinner__edge-right{right:4%}:host(.nx-spinner--negative) .nx-spinner__spin-block{border-color:#fff rgba(250,247,239,.35) rgba(250,247,239,.35)}:host(.nx-spinner--negative) .nx-spinner__edge-left,:host(.nx-spinner--negative) .nx-spinner__edge-right{background-color:#fff}@media screen and (-ms-high-contrast:active){.nx-spinner__spin-block{border-color:window highlight highlight}}"]
                    }] }
        ];
        /** @nocollapse */
        NxSpinnerComponent.ctorParameters = function () { return [
            { type: core.ChangeDetectorRef }
        ]; };
        NxSpinnerComponent.propDecorators = {
            size: [{ type: core.Input, args: ['nxSize',] }],
            negative: [{ type: core.Input }]
        };
        return NxSpinnerComponent;
    }());
    if (false) {
        /**
         * @type {?}
         * @private
         */
        NxSpinnerComponent.prototype._size;
        /**
         * @type {?}
         * @private
         */
        NxSpinnerComponent.prototype._negative;
        /**
         * @type {?}
         * @private
         */
        NxSpinnerComponent.prototype._changeDetectorRef;
    }

    /**
     * @fileoverview added by tsickle
     * Generated from: spinner/spinner.module.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var NxSpinnerModule = /** @class */ (function () {
        function NxSpinnerModule() {
        }
        NxSpinnerModule.decorators = [
            { type: core.NgModule, args: [{
                        declarations: [
                            NxSpinnerComponent
                        ],
                        imports: [
                            common.CommonModule
                        ],
                        exports: [
                            NxSpinnerComponent
                        ],
                        bootstrap: [],
                        providers: []
                    },] }
        ];
        return NxSpinnerModule;
    }());

    /**
     * @fileoverview added by tsickle
     * Generated from: spinner/public-api.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * Generated from: modal/modal.service.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * \@docs-private
     */
    var NxModalService = /** @class */ (function () {
        function NxModalService() {
            this.subject = new rxjs.Subject();
            this.close$ = this.subject.asObservable();
        }
        /**
         * @return {?}
         */
        NxModalService.prototype.close = /**
         * @return {?}
         */
        function () {
            this.subject.next();
        };
        NxModalService.decorators = [
            { type: core.Injectable }
        ];
        return NxModalService;
    }());
    if (false) {
        /**
         * @type {?}
         * @private
         */
        NxModalService.prototype.subject;
        /** @type {?} */
        NxModalService.prototype.close$;
    }

    /**
     * @fileoverview added by tsickle
     * Generated from: modal/animations.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /** @type {?} */
    var fadeIn = animations.animation([
        animations.style({ opacity: 0 }),
        animations.animate('300ms', animations.style({ opacity: 1 }))
    ]);
    /** @type {?} */
    var fadeOut = animations.animation(animations.animate('300ms', animations.style({ opacity: 0 })));
    /** @type {?} */
    var scaleUp = animations.animation([
        animations.style({ transform: 'scale(1)', opacity: 1 }),
        animations.animate('250ms', animations.style({ transform: 'scale(1.3)', opacity: 0 }))
    ]);
    /** @type {?} */
    var scaleDown = animations.animation([
        animations.style({ transform: 'scale(1.3)', opacity: 0 }),
        animations.animate('250ms', animations.style({ transform: 'scale(1)', opacity: 1 }))
    ]);

    /**
     * @fileoverview added by tsickle
     * Generated from: modal/modal.component.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * Container for the action buttons in a modal. Has a fixed position at the bottom of the modal on scroll.
     */
    var NxModalActionsDirective = /** @class */ (function () {
        function NxModalActionsDirective() {
        }
        NxModalActionsDirective.decorators = [
            { type: core.Directive, args: [{
                        selector: '[nxModalActions]',
                        host: {
                            '[class.nx-modal__actions]': 'true'
                        }
                    },] }
        ];
        return NxModalActionsDirective;
    }());
    /**
     * Scrollable container for the content of a modal.
     */
    var NxModalContentDirective = /** @class */ (function () {
        function NxModalContentDirective() {
        }
        NxModalContentDirective.decorators = [
            { type: core.Directive, args: [{
                        selector: '[nxModalContent]',
                        host: {
                            '[class.nx-modal__content]': 'true'
                        }
                    },] }
        ];
        return NxModalContentDirective;
    }());
    var NxModalComponent = /** @class */ (function () {
        function NxModalComponent(modalService, eventManager, _changeDetectorRef) {
            this.modalService = modalService;
            this.eventManager = eventManager;
            this._changeDetectorRef = _changeDetectorRef;
            this._closeButtonLabel = 'Close dialog';
            /**
             * Whether the modal view should close when the user hits the escape key.
             * Default is true.
             */
            this.hideOnEsc = true;
            /**
             * Whether the modal view should close when the user clicks on the backdrop.
             * Default is true.
             */
            this.hideOnClickOutside = true;
            /**
             * Whether the modal view should have a close icon in the upper right corner.
             * Default is true.
             */
            this.showCloseIcon = true;
            /**
             * An event emitted when the user clicks on the backdrop or uses the built-in close button.
             * This event can be applied in conjunction with the custom open state handling
             * of a modal to close it when requested by the user.
             */
            this.closeEvent = new core.EventEmitter();
            this.closeSubscription = rxjs.Subscription.EMPTY;
            this.removeEventListener = undefined;
        }
        Object.defineProperty(NxModalComponent.prototype, "closeButtonLabel", {
            get: /**
             * @return {?}
             */
            function () {
                return this._closeButtonLabel;
            },
            /** Sets the 'aria-label' of the modal close button needed for accessibility.
             *
             * Default value is 'Close dialog'.
             */
            set: /**
             * Sets the 'aria-label' of the modal close button needed for accessibility.
             *
             * Default value is 'Close dialog'.
             * @param {?} value
             * @return {?}
             */
            function (value) {
                if (value !== this._closeButtonLabel) {
                    this._closeButtonLabel = value;
                    this._changeDetectorRef.markForCheck();
                }
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        NxModalComponent.prototype.ngOnInit = /**
         * @return {?}
         */
        function () {
            var _this = this;
            this.closeSubscription = this.modalService.close$.subscribe((/**
             * @return {?}
             */
            function () { return _this.closeEvent.emit(); }));
            this.removeEventListener = this.eventManager.addGlobalEventListener('window', 'keyup.esc', (/**
             * @return {?}
             */
            function () {
                if (_this.hideOnEsc) {
                    _this.modalService.close();
                }
            }));
        };
        /**
         * @return {?}
         */
        NxModalComponent.prototype.ngOnDestroy = /**
         * @return {?}
         */
        function () {
            this.removeEventListener();
            this.closeSubscription.unsubscribe();
        };
        /** @docs-private */
        /**
         * \@docs-private
         * @return {?}
         */
        NxModalComponent.prototype.clickOutsideModal = /**
         * \@docs-private
         * @return {?}
         */
        function () {
            if (this.hideOnClickOutside) {
                this.modalService.close();
            }
        };
        /** @docs-private */
        /**
         * \@docs-private
         * @return {?}
         */
        NxModalComponent.prototype.closeButtonClick = /**
         * \@docs-private
         * @return {?}
         */
        function () {
            this.modalService.close();
        };
        /** @docs-private */
        /**
         * \@docs-private
         * @param {?} evt
         * @return {?}
         */
        NxModalComponent.prototype.cancelClick = /**
         * \@docs-private
         * @param {?} evt
         * @return {?}
         */
        function (evt) {
            evt.stopPropagation();
        };
        NxModalComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'nx-modal',
                        template: "<div class=\"nx-modal\" role=\"dialog\" cdkTrapFocus cdkTrapFocusAutoCapture cdkFocusInitial>\n  <div class=\"nx-modal__backdrop\" (click)=\"clickOutsideModal()\">\n    <div class=\"nx-modal__position\">\n      <div class=\"nx-modal__container\" (click)=\"cancelClick($event)\" [@scaleUpDown]>\n\n        <button\n          (click)=\"closeButtonClick()\"\n          *ngIf=\"showCloseIcon\"\n          [attr.aria-label]=\"closeButtonLabel\"\n          class=\"nx-modal__close\"\n          type=\"button\">\n          <nx-icon name=\"close\"></nx-icon>\n        </button>\n\n        <div class=\"nx-modal__content-wrapper\">\n          <ng-container *ngIf=\"body else projectContent\">\n            <ng-container *ngTemplateOutlet=\"body\"></ng-container>\n          </ng-container>\n\n          <ng-template #projectContent>\n            <ng-content></ng-content>\n          </ng-template>\n        </div>\n      </div>\n    </div>\n  </div>\n</div>\n",
                        changeDetection: core.ChangeDetectionStrategy.OnPush,
                        animations: [
                            animations.trigger('fadeInOut', [
                                animations.transition(':enter', [
                                    animations.useAnimation(fadeIn),
                                    animations.query('@scaleUpDown', [
                                        animations.animateChild()
                                    ])
                                ]),
                                animations.transition(':leave', [
                                    animations.query('@scaleUpDown', [
                                        animations.animateChild()
                                    ]),
                                    animations.useAnimation(fadeOut)
                                ])
                            ]),
                            animations.trigger('scaleUpDown', [
                                animations.transition(':enter', animations.useAnimation(scaleDown)),
                                animations.transition(':leave', animations.useAnimation(scaleUp))
                            ])
                        ],
                        host: {
                            '[@fadeInOut]': '',
                            '[class.nx-modal--fixed-width]': 'size === "fixed"'
                        },
                        styles: [":host{position:relative;z-index:1000}.nx-modal{display:flex;position:fixed;width:100vw;height:100vh;top:0;bottom:0;left:0;right:0;z-index:1000;align-items:center;justify-content:center;transition:opacity .3s}.nx-modal__backdrop{background-color:rgba(0,0,0,.35);height:100%;left:0;position:absolute;top:0;width:100%;z-index:-1}.nx-modal__position{position:absolute;display:inline-block;top:50%;left:50%;transform:translate(-50%,-50%);z-index:20}.nx-modal__container{border-radius:4px;box-shadow:0 8px 24px rgba(65,65,65,.35);background:#fff;background:var(--modal-background-color,#fff);color:#414141;color:var(--modal-text-color,#414141)}.nx-modal__content-wrapper{padding:40px 40px 48px;max-height:calc(100vh - 48px);overflow-y:auto}@media (max-width:703px){.nx-modal__content-wrapper{max-height:70vh;padding:40px 32px 48px}}.nx-modal__close{background-color:transparent;border:none;cursor:pointer;position:absolute;top:16px;right:16px;height:24px;outline:0;padding:0;color:#414141;color:var(--modal-close-icon-color,#414141)}.nx-modal__close nx-icon{font-size:24px}.nx-modal__close::-moz-focus-inner{border:0}:host-context([data-whatinput=keyboard]) .nx-modal__close:focus{box-shadow:0 0 0 2px #fff,0 0 0 6px #009de6;box-shadow:var(--focus-box-shadow,0 0 0 2px #fff,0 0 0 6px #009de6);border-radius:4px}@media (max-width:703px){.nx-modal__position{width:100%}.nx-modal__container{position:relative;max-width:calc(100vw - 16px);max-height:70vh;margin:0 auto}}:host(.nx-modal--fixed-width) .nx-modal__container{width:736px;max-width:calc(100vw - 16px)}::ng-deep .nx-modal__actions{height:72px;border-top:1px solid #d9d9d9;border-top:1px solid var(--modal-actions-border-color,#d9d9d9);display:flex;align-items:center;justify-content:flex-end;padding:0 40px;position:absolute;bottom:0;left:0;width:100%;border-bottom-left-radius:4px;border-bottom-right-radius:4px;background:#fff;background:var(--modal-actions-background-color,#fff)}::ng-deep .nx-modal__content{overflow-y:auto;max-height:calc(100vh - 72px - 48px)}@media (max-width:703px){::ng-deep .nx-modal__content{max-height:calc(70vh - 72px - 48px)}}@media screen and (-ms-high-contrast:active){:host-context([data-whatinput=keyboard]) .nx-modal__close:focus{box-shadow:0 0 0 2px background,0 0 0 6px windowText}.nx-modal__content-wrapper,::ng-deep .nx-modal__actions{border:2px solid windowText}}"]
                    }] }
        ];
        /** @nocollapse */
        NxModalComponent.ctorParameters = function () { return [
            { type: NxModalService },
            { type: platformBrowser.EventManager },
            { type: core.ChangeDetectorRef }
        ]; };
        NxModalComponent.propDecorators = {
            closeButtonLabel: [{ type: core.Input }],
            body: [{ type: core.Input, args: ['nxBody',] }],
            hideOnEsc: [{ type: core.Input, args: ['nxHideOnEsc',] }],
            hideOnClickOutside: [{ type: core.Input, args: ['nxHideOnClickOutside',] }],
            showCloseIcon: [{ type: core.Input, args: ['nxShowCloseIcon',] }],
            size: [{ type: core.Input, args: ['nxSize',] }],
            closeEvent: [{ type: core.Output, args: ['nxClose',] }]
        };
        return NxModalComponent;
    }());
    if (false) {
        /**
         * @type {?}
         * @private
         */
        NxModalComponent.prototype._closeButtonLabel;
        /**
         * A template reference variable pointing to the template
         * which contains the content of the modal view.
         * @type {?}
         */
        NxModalComponent.prototype.body;
        /**
         * Whether the modal view should close when the user hits the escape key.
         * Default is true.
         * @type {?}
         */
        NxModalComponent.prototype.hideOnEsc;
        /**
         * Whether the modal view should close when the user clicks on the backdrop.
         * Default is true.
         * @type {?}
         */
        NxModalComponent.prototype.hideOnClickOutside;
        /**
         * Whether the modal view should have a close icon in the upper right corner.
         * Default is true.
         * @type {?}
         */
        NxModalComponent.prototype.showCloseIcon;
        /**
         * Controls the width of the dialog.
         * On `auto` the width is controlled by the content width,
         * on `fixed` the dialog gets a fixed width of 736px if the viewport is big enough.
         * @type {?}
         */
        NxModalComponent.prototype.size;
        /**
         * An event emitted when the user clicks on the backdrop or uses the built-in close button.
         * This event can be applied in conjunction with the custom open state handling
         * of a modal to close it when requested by the user.
         * @type {?}
         */
        NxModalComponent.prototype.closeEvent;
        /**
         * @type {?}
         * @private
         */
        NxModalComponent.prototype.closeSubscription;
        /**
         * @type {?}
         * @private
         */
        NxModalComponent.prototype.removeEventListener;
        /**
         * @type {?}
         * @private
         */
        NxModalComponent.prototype.modalService;
        /**
         * @type {?}
         * @private
         */
        NxModalComponent.prototype.eventManager;
        /**
         * @type {?}
         * @private
         */
        NxModalComponent.prototype._changeDetectorRef;
    }

    /**
     * @fileoverview added by tsickle
     * Generated from: modal/modal-open-on-click.directive.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var NxOpenModalOnClickDirective = /** @class */ (function () {
        function NxOpenModalOnClickDirective(templateRef, viewContainer, modalService) {
            var _this = this;
            this.templateRef = templateRef;
            this.viewContainer = viewContainer;
            this.modalService = modalService;
            /**
             * \@docs-private
             */
            this.clickHandler = (/**
             * @param {?} event
             * @return {?}
             */
            function (event) {
                _this.viewContainer.clear();
                // instantiate the template onto which this directive is applied
                /** @type {?} */
                var viewRef = _this.viewContainer.createEmbeddedView(_this.templateRef);
                // we need to mark the viewRef explicitly if the modal is used inside another
                // component that is using onPush change detection
                viewRef.markForCheck();
                event.preventDefault();
                event.stopPropagation();
            });
        }
        /**
         * @return {?}
         */
        NxOpenModalOnClickDirective.prototype.ngOnInit = /**
         * @return {?}
         */
        function () {
            var _this = this;
            this.subscription = this.modalService.close$.subscribe((/**
             * @return {?}
             */
            function () { return _this.viewContainer.clear(); }));
        };
        /**
         * @return {?}
         */
        NxOpenModalOnClickDirective.prototype.ngOnDestroy = /**
         * @return {?}
         */
        function () {
            var _this = this;
            this.elements.forEach((/**
             * @param {?} el
             * @return {?}
             */
            function (el) {
                if (el.removeEventListener) {
                    el.removeEventListener('click', _this.clickHandler);
                }
            }));
            this.subscription.unsubscribe();
        };
        Object.defineProperty(NxOpenModalOnClickDirective.prototype, "nxOpenModalOnClick", {
            /**
             * One or multiple template reference variables pointing to elements
             * which should trigger opening the modal on click.
             *
             * Value: A single template reference variable or an array of template reference variables.
             */
            set: /**
             * One or multiple template reference variables pointing to elements
             * which should trigger opening the modal on click.
             *
             * Value: A single template reference variable or an array of template reference variables.
             * @param {?} elements
             * @return {?}
             */
            function (elements) {
                var _this = this;
                // also support the case where only one element is passed, check for the length property to be sure elements is an array
                if (elements.length) {
                    this.elements = elements;
                }
                else {
                    this.elements = [elements];
                }
                // add a click event listener to any element passed as property to this directive
                this.elements.forEach((/**
                 * @param {?} el
                 * @return {?}
                 */
                function (el) {
                    if (el.addEventListener) {
                        el.addEventListener('click', _this.clickHandler);
                        // workaround until refactoring: if the reference is a component
                        // reference the component has to implement a getter to its own elementRef
                    }
                    else if (el.elementRef) {
                        el.elementRef.nativeElement.addEventListener('click', _this.clickHandler);
                    }
                    else {
                        console.warn("nxOpenModalOnClick: Given Element doesn't appear to be an ElementRef.", el);
                    }
                }));
            },
            enumerable: true,
            configurable: true
        });
        NxOpenModalOnClickDirective.decorators = [
            { type: core.Directive, args: [{ selector: '[nxOpenModalOnClick]' },] }
        ];
        /** @nocollapse */
        NxOpenModalOnClickDirective.ctorParameters = function () { return [
            { type: core.TemplateRef },
            { type: core.ViewContainerRef },
            { type: NxModalService }
        ]; };
        NxOpenModalOnClickDirective.propDecorators = {
            nxOpenModalOnClick: [{ type: core.Input }]
        };
        return NxOpenModalOnClickDirective;
    }());
    if (false) {
        /**
         * \@docs-private
         * @type {?}
         */
        NxOpenModalOnClickDirective.prototype.elements;
        /**
         * @type {?}
         * @private
         */
        NxOpenModalOnClickDirective.prototype.subscription;
        /**
         * \@docs-private
         * @type {?}
         */
        NxOpenModalOnClickDirective.prototype.clickHandler;
        /**
         * @type {?}
         * @private
         */
        NxOpenModalOnClickDirective.prototype.templateRef;
        /**
         * @type {?}
         * @private
         */
        NxOpenModalOnClickDirective.prototype.viewContainer;
        /**
         * @type {?}
         * @private
         */
        NxOpenModalOnClickDirective.prototype.modalService;
    }

    /**
     * @fileoverview added by tsickle
     * Generated from: modal/modal.module.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var NxModalModule = /** @class */ (function () {
        function NxModalModule() {
        }
        // define the modal service on root level as an application wide singleton,
        // assuming that we only display one modal at a time, which seems quite reasonable
        // this is static and named "forRoot" by convention
        // define the modal service on root level as an application wide singleton,
        // assuming that we only display one modal at a time, which seems quite reasonable
        // this is static and named "forRoot" by convention
        /**
         * @return {?}
         */
        NxModalModule.forRoot = 
        // define the modal service on root level as an application wide singleton,
        // assuming that we only display one modal at a time, which seems quite reasonable
        // this is static and named "forRoot" by convention
        /**
         * @return {?}
         */
        function () {
            return {
                ngModule: NxModalModule,
                providers: [NxModalService]
            };
        };
        NxModalModule.decorators = [
            { type: core.NgModule, args: [{
                        imports: [common.CommonModule, a11y.A11yModule, icon.NxIconModule],
                        declarations: [
                            NxModalComponent,
                            NxOpenModalOnClickDirective,
                            NxModalActionsDirective,
                            NxModalContentDirective
                        ],
                        exports: [
                            NxModalComponent,
                            NxOpenModalOnClickDirective,
                            NxModalActionsDirective,
                            NxModalContentDirective
                        ],
                    },] }
        ];
        return NxModalModule;
    }());

    /**
     * @fileoverview added by tsickle
     * Generated from: modal/public-api.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * Generated from: modal/index.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * Generated from: switcher/switcher.component.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /** @type {?} */
    var nextId$6 = 0;
    var NxSwitcherComponent = /** @class */ (function () {
        function NxSwitcherComponent(_changeDetectorRef, ngControl, _errorStateMatcher, _parentForm, _parentFormGroup) {
            this._changeDetectorRef = _changeDetectorRef;
            this.ngControl = ngControl;
            this._errorStateMatcher = _errorStateMatcher;
            this._parentForm = _parentForm;
            this._parentFormGroup = _parentFormGroup;
            this._id = "nx-switcher-" + nextId$6++;
            /**
             * \@docs-private
             */
            this.errorState = false;
            this._labelPosition = 'right';
            this._name = null;
            this._checked = false;
            this._big = false;
            this._labelSize = 'large';
            this._negative = false;
            this._disabled = false;
            /**
             * An event is dispatched each time the switcher value is changed
             */
            this.checkedChange = new core.EventEmitter();
            this.onChangeCallback = (/**
             * @param {?} _
             * @return {?}
             */
            function (_) { });
            this.onTouchedCallback = (/**
             * @return {?}
             */
            function () { });
            if (this.ngControl) {
                // Note: we provide the value accessor through here, instead of
                // the `providers` to avoid running into a circular import.
                this.ngControl.valueAccessor = this;
            }
        }
        Object.defineProperty(NxSwitcherComponent.prototype, "id", {
            get: /**
             * @return {?}
             */
            function () {
                return this._id;
            },
            /** Sets the id of the switcher */
            set: /**
             * Sets the id of the switcher
             * @param {?} value
             * @return {?}
             */
            function (value) {
                this._id = value;
                this._changeDetectorRef.markForCheck();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NxSwitcherComponent.prototype, "labelPosition", {
            get: /**
             * @return {?}
             */
            function () {
                return this._labelPosition;
            },
            /** Specifies the placement of the label */
            set: /**
             * Specifies the placement of the label
             * @param {?} value
             * @return {?}
             */
            function (value) {
                this._labelPosition = value;
                this._changeDetectorRef.markForCheck();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NxSwitcherComponent.prototype, "name", {
            get: /**
             * @return {?}
             */
            function () {
                return this._name;
            },
            /** Sets the label text of the switcher */
            set: /**
             * Sets the label text of the switcher
             * @param {?} value
             * @return {?}
             */
            function (value) {
                this._name = value;
                this._changeDetectorRef.markForCheck();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NxSwitcherComponent.prototype, "checked", {
            get: /**
             * @return {?}
             */
            function () {
                return this._checked;
            },
            /** Whether the switcher is checked (on) or unchecked (off) */
            set: /**
             * Whether the switcher is checked (on) or unchecked (off)
             * @param {?} value
             * @return {?}
             */
            function (value) {
                this._checked = value;
                this._changeDetectorRef.markForCheck();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NxSwitcherComponent.prototype, "big", {
            get: /**
             * @return {?}
             */
            function () {
                return this._big;
            },
            /** Whether the big switcher is used */
            set: /**
             * Whether the big switcher is used
             * @param {?} value
             * @return {?}
             */
            function (value) {
                /** @type {?} */
                var newValue = coercion.coerceBooleanProperty(value);
                this._big = newValue;
                this._changeDetectorRef.markForCheck();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NxSwitcherComponent.prototype, "labelSize", {
            get: /**
             * @return {?}
             */
            function () {
                return this._labelSize;
            },
            /** Sets the size of the label */
            set: /**
             * Sets the size of the label
             * @param {?} value
             * @return {?}
             */
            function (value) {
                this._labelSize = value;
                this._changeDetectorRef.markForCheck();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NxSwitcherComponent.prototype, "negative", {
            get: /**
             * @return {?}
             */
            function () {
                return this._negative;
            },
            /** Whether the style for a dark background is used */
            set: /**
             * Whether the style for a dark background is used
             * @param {?} value
             * @return {?}
             */
            function (value) {
                /** @type {?} */
                var newValue = coercion.coerceBooleanProperty(value);
                this._negative = newValue;
                this._changeDetectorRef.markForCheck();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NxSwitcherComponent.prototype, "disabled", {
            get: /**
             * @return {?}
             */
            function () {
                return this._disabled;
            },
            /** Whether the switcher is in the disabled state */
            set: /**
             * Whether the switcher is in the disabled state
             * @param {?} value
             * @return {?}
             */
            function (value) {
                /** @type {?} */
                var newValue = coercion.coerceBooleanProperty(value);
                this._disabled = newValue;
                this._changeDetectorRef.markForCheck();
            },
            enumerable: true,
            configurable: true
        });
        /** Allows to toggle between the states */
        /**
         * Allows to toggle between the states
         * @return {?}
         */
        NxSwitcherComponent.prototype.toggle = /**
         * Allows to toggle between the states
         * @return {?}
         */
        function () {
            if (!this.disabled) {
                this.checked = !this.checked;
                this.onChangeCallback(this.checked);
                this.checkedChange.emit(this.checked);
                if (this.onTouchedCallback) {
                    this.onTouchedCallback();
                }
            }
        };
        /**
         * @param {?} value
         * @return {?}
         */
        NxSwitcherComponent.prototype.writeValue = /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            if (value === null) {
                value = false;
            }
            if (value !== this.checked) {
                this.checked = value;
            }
        };
        /**
         * @param {?} fn
         * @return {?}
         */
        NxSwitcherComponent.prototype.registerOnChange = /**
         * @param {?} fn
         * @return {?}
         */
        function (fn) {
            this.onChangeCallback = fn;
        };
        /**
         * @param {?} fn
         * @return {?}
         */
        NxSwitcherComponent.prototype.registerOnTouched = /**
         * @param {?} fn
         * @return {?}
         */
        function (fn) {
            this.onTouchedCallback = fn;
        };
        /**
         * @return {?}
         */
        NxSwitcherComponent.prototype.ngDoCheck = /**
         * @return {?}
         */
        function () {
            if (this.ngControl) {
                // We need to re-evaluate this on every change detection cycle, because there are some
                // error triggers that we can't subscribe to (e.g. parent form submissions). This means
                // that whatever logic is in here has to be super lean or we risk destroying the performance.
                this.updateErrorState();
            }
        };
        /**
         * @param {?} isDisabled
         * @return {?}
         */
        NxSwitcherComponent.prototype.setDisabledState = /**
         * @param {?} isDisabled
         * @return {?}
         */
        function (isDisabled) {
            this.disabled = isDisabled;
        };
        /** @docs-private */
        /**
         * \@docs-private
         * @return {?}
         */
        NxSwitcherComponent.prototype.touch = /**
         * \@docs-private
         * @return {?}
         */
        function () {
            this.onTouchedCallback();
        };
        /** @docs-private */
        /**
         * \@docs-private
         * @return {?}
         */
        NxSwitcherComponent.prototype.updateErrorState = /**
         * \@docs-private
         * @return {?}
         */
        function () {
            /** @type {?} */
            var oldState = this.errorState;
            /** @type {?} */
            var parent = this._parentFormGroup || this._parentForm;
            /** @type {?} */
            var control = this.ngControl ? (/** @type {?} */ (this.ngControl.control)) : null;
            /** @type {?} */
            var newState = this._errorStateMatcher.isErrorState(control, parent);
            if (newState !== oldState) {
                this.errorState = newState;
            }
        };
        Object.defineProperty(NxSwitcherComponent.prototype, "labelHasContent", {
            /** @docs-private */
            get: /**
             * \@docs-private
             * @return {?}
             */
            function () {
                return !!this._switcherLabelWrapper.nativeElement.innerHTML.trim();
            },
            enumerable: true,
            configurable: true
        });
        /** @docs-private
         * Callback for when the content of the label has changed.
         */
        /**
         * \@docs-private
         * Callback for when the content of the label has changed.
         * @return {?}
         */
        NxSwitcherComponent.prototype.labelContentChanged = /**
         * \@docs-private
         * Callback for when the content of the label has changed.
         * @return {?}
         */
        function () {
            this._changeDetectorRef.detectChanges();
        };
        NxSwitcherComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'nx-switcher',
                        template: "<input type=\"checkbox\" [id]=\"id\" [attr.name]=\"name\" [disabled]=\"disabled\" [checked]=\"checked\" (click)=\"toggle()\" (blur)=\"touch()\"\n  role=\"switch\"\n  [attr.aria-checked]=\"checked\"\n  class=\"nx-switcher__input\">\n<label [attr.for]=\"id\" class=\"nx-switcher__label\" [class.has-label]=\"labelHasContent\">\n  <div class=\"nx-switcher__toggle\">\n    <div class=\"nx-switcher__dot\">\n      <nx-icon *ngIf=\"big\" name=\"check\"></nx-icon>\n    </div>\n  </div>\n  <div class=\"nx-switcher__label-text\" #switcherLabelWrapper (cdkObserveContent)=\"labelContentChanged()\">\n    <ng-content></ng-content>\n  </div>\n</label>\n\n",
                        changeDetection: core.ChangeDetectionStrategy.OnPush,
                        host: {
                            /* the host id should be set to null, otherwise nx-switcher and its <input> get the same id
                                and on label click the input click is not triggered (double id problem) */
                            '[attr.id]': 'null',
                            '[class.is-negative]': 'negative',
                            '[class.is-checked]': 'checked',
                            '[class.is-big]': 'big',
                            '[class.nx-switcher--small-label]': 'labelSize === "small"',
                            '[class.nx-switcher--large-label]': 'labelSize === "large"',
                            '[class.is-disabled]': 'disabled',
                            '[class.is-swapped]': 'labelPosition === "left"',
                            '[class.has-error]': 'errorState',
                            '[attr.aria-invalid]': 'errorState'
                        },
                        styles: [":host{position:relative;display:flex}:host(.is-swapped) .nx-switcher__label{flex-direction:row-reverse}:host(.is-swapped) .nx-switcher__label.has-label .nx-switcher__toggle{margin-left:12px}.nx-switcher__input{opacity:0;position:absolute}.nx-switcher__label{font-size:20px;font-size:var(--switcher-large-font-size,20px);line-height:28px;line-height:var(--switcher-large-line-height,28px);font-weight:400;font-weight:var(--switcher-large-font-weight,400);letter-spacing:.2px;letter-spacing:var(--switcher-large-letter-spacing,.2px);cursor:pointer;display:flex;position:relative}.nx-switcher__toggle{position:relative;display:inline-block;width:48px;min-width:48px;height:24px;background-color:#767676;background-color:var(--switcher-unchecked-background-color,#767676);border-radius:16px;transition:background-color .2s}:host(:not(.is-swapped)) .has-label .nx-switcher__toggle{margin-right:12px}.nx-switcher__dot{position:absolute;height:20px;width:20px;left:2px;bottom:2px;background-color:#fff;background-color:var(--switcher-dot-background-color,#fff);border-radius:16px;transform:translate(0);transition:transform .2s}:host(.is-checked) .nx-switcher__dot{transform:translate(24px)}:host(.is-checked) .nx-switcher__toggle{background-color:#007ab3;background-color:var(--switcher-checked-background-color,#007ab3)}:host(.is-checked.is-negative) .nx-switcher__toggle{background-color:rgba(255,255,255,.4)}:host(.is-big) .nx-switcher__toggle{width:56px;min-width:56px;height:32px}:host(.is-big) .nx-switcher__dot{height:28px;width:28px}:host(.is-big) nx-icon{position:absolute;top:2px;left:2px;font-size:24px;opacity:0;color:#006192;color:var(--switcher-checked-icon-color,#006192)}:host(.is-big).is-checked nx-icon{opacity:1;transition:opacity .2s}:host(.is-big).nx-switcher--large-label .has-label .nx-switcher__label-text{margin-top:2px;margin-top:var(--switcher-big-large-label-text-margin-top,2px)}:host(.is-big).nx-switcher--large-label .has-label .nx-switcher__toggle{margin-top:0;margin-top:var(--switcher-big-large-label-control-margin-top,0)}:host(.is-big).nx-switcher--small-label .has-label .nx-switcher__label-text{margin-top:4px;margin-top:var(--switcher-big-small-label-text-margin-top,4px)}:host(.is-big).nx-switcher--small-label .has-label .nx-switcher__toggle{margin-top:0;margin-top:var(--switcher-big-small-label-control-margin-top,0)}:host(.nx-switcher--large-label) .has-label .nx-switcher__label-text{margin-top:0;margin-top:var(--switcher-large-label-text-margin-top,0)}:host(.nx-switcher--large-label) .has-label .nx-switcher__toggle{margin-top:2px;margin-top:var(--switcher-large-label-control-margin-top,2px)}:host(.nx-switcher--small-label) .nx-switcher__label{font-size:16px;font-size:var(--switcher-small-font-size,16px);line-height:24px;line-height:var(--switcher-small-line-height,24px);font-weight:400;font-weight:var(--switcher-small-font-weight,400);letter-spacing:0;letter-spacing:var(--switcher-small-letter-spacing,0)}:host(.nx-switcher--small-label) .has-label .nx-switcher__label-text{margin-top:0;margin-top:var(--switcher-small-label-text-margin-top,0)}:host(.nx-switcher--small-label) .has-label .nx-switcher__toggle{margin-top:0;margin-top:var(--switcher-small-label-control-margin-top,0)}:host(.is-negative) .nx-switcher__label{color:#fff}:host(.is-negative) .nx-switcher__dot{background-color:#fff}:host(.is-negative) .nx-switcher__toggle{background-color:rgba(255,255,255,.4)}:host-context([data-whatinput=keyboard]) .nx-switcher__input:focus+.nx-switcher__label .nx-switcher__toggle{box-shadow:0 0 0 2px #fff,0 0 0 6px #009de6;box-shadow:var(--focus-box-shadow,0 0 0 2px #fff,0 0 0 6px #009de6)}:host(.is-disabled) .nx-switcher__toggle{background-color:#c2c2c2;background-color:var(--switcher-disabled-background-color,#c2c2c2)}:host(.is-disabled) .nx-switcher__dot{background-color:#dadada;background-color:var(--switcher-disabled-dot-background-color,#dadada)}:host(.is-disabled) .nx-switcher__label{cursor:not-allowed;color:#c2c2c2;color:var(--switcher-disabled-text-color,#c2c2c2)}:host(.is-disabled) nx-icon{color:#c2c2c2;color:var(--switcher-disabled-icon-color,#c2c2c2)}:host(.has-error) .nx-switcher__toggle{background-color:#dc3149;background-color:var(--danger,#dc3149)}@media screen and (-ms-high-contrast:active){:host-context([data-whatinput=keyboard]) .nx-switcher__input:focus+.nx-switcher__label .nx-switcher__toggle{box-shadow:0 0 0 2px background,0 0 0 6px windowText}.nx-switcher__label{color:buttonText}.nx-switcher__toggle{color:highlightText;background-color:highlight}:host:not(.is-checked) .nx-switcher__toggle{background-color:buttonFace;border:2px solid buttonText;color:buttonText}:host:not(.is-checked) .nx-switcher__dot{left:0;bottom:0;box-shadow:0 0 0 2px buttonText;background-color:buttonText}:host(.is-checked) .nx-switcher__dot{background-color:highlightText}:host(.is-checked) .nx-switcher__dot nx-icon{color:highlight}:host(.is-disabled) .nx-switcher__label{color:GrayText}:host(.is-disabled) .nx-switcher__toggle{color:GrayText}:host(.is-disabled) .nx-switcher__dot{opacity:1;background-color:GrayText}:host(.is-disabled):not(.is-checked) .nx-switcher__toggle{border:2px solid GrayText}:host(.is-disabled):not(.is-checked) .nx-switcher__dot{box-shadow:0 0 0 2px GrayText}:host(.is-disabled).is-checked .nx-switcher__toggle{background-color:GrayText}:host(.is-disabled).is-checked .nx-switcher__dot{background-color:window}:host(.is-disabled).is-checked .nx-switcher__dot nx-icon{color:GrayText}}"]
                    }] }
        ];
        /** @nocollapse */
        NxSwitcherComponent.ctorParameters = function () { return [
            { type: core.ChangeDetectorRef },
            { type: forms.NgControl, decorators: [{ type: core.Optional }, { type: core.Self }] },
            { type: utils.ErrorStateMatcher },
            { type: forms.NgForm, decorators: [{ type: core.Optional }] },
            { type: forms.FormGroupDirective, decorators: [{ type: core.Optional }] }
        ]; };
        NxSwitcherComponent.propDecorators = {
            _switcherLabelWrapper: [{ type: core.ViewChild, args: ['switcherLabelWrapper', { static: true },] }],
            id: [{ type: core.Input }],
            labelPosition: [{ type: core.Input }],
            name: [{ type: core.Input }],
            checked: [{ type: core.Input }],
            big: [{ type: core.Input, args: ['nxBig',] }],
            labelSize: [{ type: core.Input }],
            negative: [{ type: core.Input, args: ['nxNegative',] }],
            disabled: [{ type: core.Input }],
            checkedChange: [{ type: core.Output, args: ['checkedChange',] }]
        };
        return NxSwitcherComponent;
    }());
    if (false) {
        /**
         * @type {?}
         * @private
         */
        NxSwitcherComponent.prototype._id;
        /**
         * \@docs-private
         * @type {?}
         */
        NxSwitcherComponent.prototype.errorState;
        /**
         * \@docs-private
         * @type {?}
         */
        NxSwitcherComponent.prototype._switcherLabelWrapper;
        /**
         * @type {?}
         * @private
         */
        NxSwitcherComponent.prototype._labelPosition;
        /**
         * @type {?}
         * @private
         */
        NxSwitcherComponent.prototype._name;
        /**
         * @type {?}
         * @private
         */
        NxSwitcherComponent.prototype._checked;
        /**
         * @type {?}
         * @private
         */
        NxSwitcherComponent.prototype._big;
        /**
         * @type {?}
         * @private
         */
        NxSwitcherComponent.prototype._labelSize;
        /**
         * @type {?}
         * @private
         */
        NxSwitcherComponent.prototype._negative;
        /**
         * @type {?}
         * @private
         */
        NxSwitcherComponent.prototype._disabled;
        /**
         * An event is dispatched each time the switcher value is changed
         * @type {?}
         */
        NxSwitcherComponent.prototype.checkedChange;
        /**
         * @type {?}
         * @private
         */
        NxSwitcherComponent.prototype.onChangeCallback;
        /**
         * @type {?}
         * @private
         */
        NxSwitcherComponent.prototype.onTouchedCallback;
        /**
         * @type {?}
         * @private
         */
        NxSwitcherComponent.prototype._changeDetectorRef;
        /** @type {?} */
        NxSwitcherComponent.prototype.ngControl;
        /**
         * @type {?}
         * @private
         */
        NxSwitcherComponent.prototype._errorStateMatcher;
        /**
         * @type {?}
         * @private
         */
        NxSwitcherComponent.prototype._parentForm;
        /**
         * @type {?}
         * @private
         */
        NxSwitcherComponent.prototype._parentFormGroup;
    }

    /**
     * @fileoverview added by tsickle
     * Generated from: switcher/switcher.module.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var NxSwitcherModule = /** @class */ (function () {
        function NxSwitcherModule() {
        }
        NxSwitcherModule.decorators = [
            { type: core.NgModule, args: [{
                        declarations: [NxSwitcherComponent],
                        exports: [NxSwitcherComponent],
                        imports: [common.CommonModule, icon.NxIconModule, observers.ObserversModule]
                    },] }
        ];
        return NxSwitcherModule;
    }());

    /**
     * @fileoverview added by tsickle
     * Generated from: switcher/public-api.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * Generated from: popover/popover-content.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * Popover content that will be rendered lazily
     * after the popover is opened for the first time.
     */
    var NxPopoverContentDirective = /** @class */ (function () {
        function NxPopoverContentDirective(_template) {
            this._template = _template;
        }
        NxPopoverContentDirective.decorators = [
            { type: core.Directive, args: [{
                        selector: 'ng-template[nxPopoverContent]'
                    },] }
        ];
        /** @nocollapse */
        NxPopoverContentDirective.ctorParameters = function () { return [
            { type: core.TemplateRef }
        ]; };
        return NxPopoverContentDirective;
    }());
    if (false) {
        /** @type {?} */
        NxPopoverContentDirective.prototype._template;
    }

    /**
     * @fileoverview added by tsickle
     * Generated from: popover/popover.component.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var NxPopoverComponent = /** @class */ (function () {
        function NxPopoverComponent() {
            /**
             * Event emitted when the popover is closed.
             */
            this.closed = new core.EventEmitter();
            /**
             * \@docs-private
             */
            this.closeButtonClick = new rxjs.Subject();
            /**
             * \@docs-private
             */
            this.showCloseButton = false;
            /**
             * \@docs-private
             */
            this.arrowStyle = {};
        }
        /**
         * @return {?}
         */
        NxPopoverComponent.prototype.ngOnDestroy = /**
         * @return {?}
         */
        function () {
            this.closed.complete();
        };
        // emit to notify the popover trigger directive that the close button was clicked
        /** @docs-private */
        // emit to notify the popover trigger directive that the close button was clicked
        /**
         * \@docs-private
         * @return {?}
         */
        NxPopoverComponent.prototype.emitCloseButtonClick = 
        // emit to notify the popover trigger directive that the close button was clicked
        /**
         * \@docs-private
         * @return {?}
         */
        function () {
            this.closeButtonClick.next();
        };
        /** @docs-private */
        /**
         * \@docs-private
         * @param {?} $event
         * @return {?}
         */
        NxPopoverComponent.prototype._onCloseKeyup = /**
         * \@docs-private
         * @param {?} $event
         * @return {?}
         */
        function ($event) {
            if ($event && ($event.keyCode === keycodes.ENTER || $event.keyCode === keycodes.SPACE)) {
                this.emitCloseButtonClick();
            }
            $event.preventDefault();
        };
        /** @docs-private */
        /**
         * \@docs-private
         * @return {?}
         */
        NxPopoverComponent.prototype.emitClosedEvent = /**
         * \@docs-private
         * @return {?}
         */
        function () {
            this.closed.emit();
        };
        Object.defineProperty(NxPopoverComponent.prototype, "classList", {
            /** @docs-private */
            get: /**
             * \@docs-private
             * @return {?}
             */
            function () {
                if (this.direction) {
                    return ["nx-popover--" + this.direction];
                }
            },
            enumerable: true,
            configurable: true
        });
        /** Prevent the popover from closing when the user clicks on the popover content. */
        /**
         * Prevent the popover from closing when the user clicks on the popover content.
         * @param {?} event
         * @return {?}
         */
        NxPopoverComponent.prototype._onClick = /**
         * Prevent the popover from closing when the user clicks on the popover content.
         * @param {?} event
         * @return {?}
         */
        function (event) {
            event.stopPropagation();
        };
        NxPopoverComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'nx-popover',
                        template: "<ng-template>\n  <div [ngClass]=\"classList\" role=\"tooltip\" aria-hidden=\"false\" (click)=\"_onClick($event)\">\n    <div class=\"nx-popover__content\" tabindex=\"0\">\n        <div class=\"nx-popover__arrow\" [ngStyle]=\"arrowStyle\">\n          </div>\n      <span\n          aria-label=\"close\"\n          tabindex=\"0\"\n          role=\"button\"\n          class=\"nx-popover__close-icon\"\n          (click)=\"emitCloseButtonClick()\"\n          (keyup)=\"_onCloseKeyup($event)\"\n          *ngIf=\"showCloseButton\">\n        <nx-icon aria-hidden=\"true\" name=\"close\"></nx-icon>\n        </span>\n\n      <span [id]=\"id\">\n        <ng-content></ng-content>\n        <ng-container [ngTemplateOutlet]=\"_lazyContent?._template\"></ng-container>\n      </span>\n    </div>\n  </div>\n</ng-template>\n",
                        changeDetection: core.ChangeDetectionStrategy.OnPush,
                        exportAs: 'nxPopover',
                        styles: [".nx-popover__content{font-size:16px;font-size:var(--popover-content-font-size,16px);line-height:24px;line-height:var(--popover-content-line-height,24px);font-weight:400;font-weight:var(--popover-content-font-weight,400);letter-spacing:0;letter-spacing:var(--popover-content-letter-spacing,0);background-color:#fff;background-color:var(--popover-background-color,#fff);color:#414141;color:var(--popover-text-color,#414141);border:1px solid #d9d9d9;border:1px solid var(--popover-border-color,#d9d9d9);border-radius:4px;box-shadow:0 2px 4px rgba(65,65,65,.5);padding:23px;display:inline-block}.nx-popover__content:focus{outline:0}.nx-popover__content::-moz-focus-inner{border:0}.nx-popover__close-icon{display:flex;position:absolute;top:4px;right:4px;cursor:pointer;font-size:16px;font-size:var(--popover-close-icon-size,16px);color:#d9d9d9;color:var(--popover-close-icon-color,#d9d9d9);border-radius:2px}.nx-popover__close-icon:focus{outline:0}.nx-popover__close-icon::-moz-focus-inner{border:0}::ng-deep [data-whatinput=keyboard] .nx-popover__close-icon:focus,::ng-deep [data-whatinput=keyboard] .nx-popover__content:focus{box-shadow:0 0 0 2px #fff,0 0 0 6px #009de6;box-shadow:var(--focus-box-shadow,0 0 0 2px #fff,0 0 0 6px #009de6)}@media screen and (-ms-high-contrast:active){::ng-deep [data-whatinput=keyboard] .nx-popover__close-icon:focus,::ng-deep [data-whatinput=keyboard] .nx-popover__content:focus{box-shadow:0 0 0 2px background,0 0 0 6px windowText}}.nx-popover__arrow{width:12px;height:12px;background-color:inherit;position:absolute;transform:translate(-50%,0);border-top:1px solid #d9d9d9;border-top:1px solid var(--popover-border-color,#d9d9d9);border-left:1px solid #d9d9d9;border-left:1px solid var(--popover-border-color,#d9d9d9)}.nx-popover--top .nx-popover__arrow{transform:translate(-50%,0) rotate(225deg);bottom:-5px;box-shadow:2px 2px 1px 1px #fff,-2px -2px 4px rgba(65,65,65,.5);box-shadow:2px 2px 1px 1px var(--popover-background-color,#fff),-2px -2px 4px rgba(65,65,65,.5)}.nx-popover--right .nx-popover__arrow{transform:translate(0,-50%) rotate(-45deg);left:-5px}.nx-popover--bottom .nx-popover__arrow{transform:translate(-50%,0) rotate(45deg);top:-5px}.nx-popover--left .nx-popover__arrow{transform:translate(0,-50%) rotate(135deg);right:-5px}"]
                    }] }
        ];
        /** @nocollapse */
        NxPopoverComponent.ctorParameters = function () { return []; };
        NxPopoverComponent.propDecorators = {
            templateRef: [{ type: core.ViewChild, args: [core.TemplateRef, { static: false },] }],
            _lazyContent: [{ type: core.ContentChild, args: [NxPopoverContentDirective, { static: false },] }],
            closed: [{ type: core.Output, args: ['nxClosed',] }]
        };
        return NxPopoverComponent;
    }());
    if (false) {
        /**
         * \@docs-private
         * @type {?}
         */
        NxPopoverComponent.prototype.templateRef;
        /**
         * Content that will be rendered lazily.
         * @type {?}
         */
        NxPopoverComponent.prototype._lazyContent;
        /**
         * Event emitted when the popover is closed.
         * @type {?}
         */
        NxPopoverComponent.prototype.closed;
        /**
         * \@docs-private
         * @type {?}
         */
        NxPopoverComponent.prototype.closeButtonClick;
        /**
         * \@docs-private
         * @type {?}
         */
        NxPopoverComponent.prototype.id;
        /**
         * \@docs-private
         * @type {?}
         */
        NxPopoverComponent.prototype.direction;
        /**
         * \@docs-private
         * @type {?}
         */
        NxPopoverComponent.prototype.showCloseButton;
        /**
         * \@docs-private
         * @type {?}
         */
        NxPopoverComponent.prototype.arrowStyle;
    }

    /**
     * @fileoverview added by tsickle
     * Generated from: popover/popover-trigger.directive.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /** @type {?} */
    var nextId$7 = 0;
    /** @type {?} */
    var fallbacks = [
        {
            originX: 'start',
            originY: 'bottom',
            overlayX: 'start',
            overlayY: 'top',
            offsetX: 0,
            offsetY: 16
        },
        {
            originX: 'end',
            originY: 'top',
            overlayX: 'end',
            overlayY: 'bottom',
            offsetX: 0,
            offsetY: -16
        },
        {
            originX: 'center',
            originY: 'bottom',
            overlayX: 'center',
            overlayY: 'top',
            offsetX: 0,
            offsetY: 16
        },
        {
            originX: 'end',
            originY: 'bottom',
            overlayX: 'end',
            overlayY: 'top',
            offsetX: 0,
            offsetY: 16
        },
        {
            originX: 'end',
            originY: 'center',
            overlayX: 'start',
            overlayY: 'center',
            offsetX: 16,
            offsetY: 0
        },
        {
            originX: 'start',
            originY: 'center',
            overlayX: 'end',
            overlayY: 'center',
            offsetX: -16,
            offsetY: 0
        },
        {
            originX: 'center',
            originY: 'top',
            overlayX: 'center',
            overlayY: 'bottom',
            offsetX: 0,
            offsetY: -16
        },
        {
            originX: 'start',
            originY: 'top',
            overlayX: 'start',
            overlayY: 'bottom',
            offsetX: 0,
            offsetY: -16
        }
    ];
    var NxPopoverTriggerDirective = /** @class */ (function () {
        function NxPopoverTriggerDirective(overlay, elementRef, viewContainerRef, eventManager, _focusTrapFactory, _focusMonitor, _ngZone, _platform, _document) {
            var _this = this;
            this.overlay = overlay;
            this.elementRef = elementRef;
            this.viewContainerRef = viewContainerRef;
            this.eventManager = eventManager;
            this._focusTrapFactory = _focusTrapFactory;
            this._focusMonitor = _focusMonitor;
            this._ngZone = _ngZone;
            this._platform = _platform;
            this._document = _document;
            this._destroyed = new rxjs.Subject();
            this._show = false;
            this._closeable = null;
            /**
             * Element that was focused before the Popover was opened. Save this to restore upon close.
             */
            this._elementFocusedBeforePopoverWasOpened = null;
            this._manualListeners = new Map();
            /**
             * \@docs-private
             */
            this.id = 'nx-popover-' + nextId$7++;
            /**
             * An event is emitted if the visibility status of the popover changes.
             */
            this.changeShow = new core.EventEmitter();
            this._closeOnClickOutside = true;
            /**
             * Sets the desired direction to open the popover. E.g., right, left, bottom, top
             */
            this.direction = 'right';
            /**
             * Whether the popover will be opened automatically.
             */
            this.popoverInitialVisible = false;
            /**
             * An event is emitted when the visibility of the popopver changes.
             */
            this.visibleChange = new core.EventEmitter();
            /**
             * Whether the popover opens in modal state.
             */
            this.modal = false;
            // If nxPopoverTrigger equals to 'hover' the popover opens on mouseenter and closes on mouseout.
            // If nxPopoverTrigger equals to 'click' the popover opens on click and closes on a click of the close icon or pressing ESC key.
            // If nxPopoverTrigger equals to 'manual' the popover opens only when programatically requested.
            /**
             * Sets the way to trigger the popover. Options are hover, click, manual
             */
            this.trigger = 'click';
            /**
             * Sets the scroll strategy. 'close' closes the popover on scroll while 'reposition' scrolls the popover with the origin.
             */
            this.scrollStrategy = 'close';
            this._documentClickObservable = rxjs.fromEvent(document, 'click');
            /** @type {?} */
            var element = elementRef.nativeElement;
            if (!this._platform.IOS && !this._platform.ANDROID) {
                this._manualListeners
                    .set('mouseenter', (/**
                 * @return {?}
                 */
                function () {
                    if (_this.trigger === 'hover') {
                        _this.show = true;
                    }
                }))
                    .set('mouseleave', (/**
                 * @return {?}
                 */
                function () {
                    if (_this.trigger === 'hover') {
                        _this.show = false;
                    }
                }))
                    .set('keydown', (/**
                 * @param {?} event
                 * @return {?}
                 */
                function (event) {
                    switch (event.keyCode) {
                        case keycodes.SPACE:
                        case keycodes.ENTER:
                            _this.handleClick();
                            break;
                        default:
                            return;
                    }
                }));
            }
            else {
                this._manualListeners.set('touchstart', (/**
                 * @return {?}
                 */
                function () {
                    if (_this.trigger === 'hover') {
                        _this.show = true;
                    }
                }));
            }
            this._manualListeners.forEach((/**
             * @param {?} listener
             * @param {?} event
             * @return {?}
             */
            function (listener, event) { return element.addEventListener(event, listener); }));
            this._focusMonitor.monitor(element).pipe(operators.takeUntil(this._destroyed)).subscribe((/**
             * @param {?} origin
             * @return {?}
             */
            function (origin) {
                if (origin === 'keyboard' && _this.trigger === 'hover') {
                    _this._ngZone.run((/**
                     * @return {?}
                     */
                    function () { return _this.show = true; }));
                }
            }));
        }
        Object.defineProperty(NxPopoverTriggerDirective.prototype, "show", {
            get: /**
             * @return {?}
             */
            function () {
                return this._show;
            },
            /** Whether to show or hide the popover. */
            set: /**
             * Whether to show or hide the popover.
             * @param {?} value
             * @return {?}
             */
            function (value) {
                value = coercion.coerceBooleanProperty(value);
                if (this._show !== value) {
                    this._show = value;
                    if (this._show) {
                        this.openPopover();
                    }
                    else {
                        this.closePopover();
                    }
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NxPopoverTriggerDirective.prototype, "closeable", {
            get: /**
             * @return {?}
             */
            function () {
                return this._closeable;
            },
            /** Whether to show a close button. By default a close icon is only shown for trigger type click. */
            set: /**
             * Whether to show a close button. By default a close icon is only shown for trigger type click.
             * @param {?} value
             * @return {?}
             */
            function (value) {
                this._closeable = coercion.coerceBooleanProperty(value);
                if (this.popover) {
                    this.popover.showCloseButton = this.isCloseable();
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NxPopoverTriggerDirective.prototype, "closeOnClickOutside", {
            get: /**
             * @return {?}
             */
            function () {
                return this._closeOnClickOutside;
            },
            /** Whether the popover should be closed on click outside of the popover in the trigger modes 'manual' and 'click'. */
            set: /**
             * Whether the popover should be closed on click outside of the popover in the trigger modes 'manual' and 'click'.
             * @param {?} value
             * @return {?}
             */
            function (value) {
                this._closeOnClickOutside = coercion.coerceBooleanProperty(value);
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        NxPopoverTriggerDirective.prototype.ngOnInit = /**
         * @return {?}
         */
        function () {
            this.popover.showCloseButton = this.isCloseable();
        };
        /**
         * @return {?}
         */
        NxPopoverTriggerDirective.prototype.ngAfterViewInit = /**
         * @return {?}
         */
        function () {
            var _this = this;
            this.popover.id = this.id;
            this.eventManager.addGlobalEventListener('window', 'keyup.esc', (/**
             * @return {?}
             */
            function () {
                if (_this.isOpen) {
                    _this.show = false;
                }
            }));
            this.popover.closeButtonClick.pipe(operators.takeUntil(this._destroyed)).subscribe((/**
             * @return {?}
             */
            function () {
                _this.show = false;
            }));
            if (this.popoverInitialVisible || this._show) {
                this.show = true;
            }
        };
        /**
         * @return {?}
         */
        NxPopoverTriggerDirective.prototype.ngOnDestroy = /**
         * @return {?}
         */
        function () {
            var _this = this;
            this.show = false;
            // Clean up the event listeners set in the constructor
            this._manualListeners.forEach((/**
             * @param {?} listener
             * @param {?} event
             * @return {?}
             */
            function (listener, event) {
                _this.elementRef.nativeElement.removeEventListener(event, listener);
            }));
            this._manualListeners.clear();
            this._destroyed.next();
            this._destroyed.complete();
        };
        Object.defineProperty(NxPopoverTriggerDirective.prototype, "isOpen", {
            /** @docs-private */
            get: /**
             * \@docs-private
             * @return {?}
             */
            function () {
                return this.overlayRef && this.createOverlay().hasAttached();
            },
            enumerable: true,
            configurable: true
        });
        /** @docs-private */
        /**
         * \@docs-private
         * @return {?}
         */
        NxPopoverTriggerDirective.prototype.isCloseable = /**
         * \@docs-private
         * @return {?}
         */
        function () {
            return (this.trigger === 'click' && this._closeable === null) || this._closeable;
        };
        /** Update the popover with the given position strategy. */
        /**
         * Update the popover with the given position strategy.
         * @return {?}
         */
        NxPopoverTriggerDirective.prototype.updatePosition = /**
         * Update the popover with the given position strategy.
         * @return {?}
         */
        function () {
            if (this._positionStrategy) {
                this._positionStrategy.apply();
            }
        };
        /** @docs-private */
        /**
         * \@docs-private
         * @return {?}
         */
        NxPopoverTriggerDirective.prototype.handleClick = /**
         * \@docs-private
         * @return {?}
         */
        function () {
            if (this.trigger === 'click') {
                this.show = !this.isOpen;
            }
            else if (this.trigger === 'hover') {
                this.show = true;
            }
        };
        /** Open the popover instance. */
        /**
         * Open the popover instance.
         * @return {?}
         */
        NxPopoverTriggerDirective.prototype.open = /**
         * Open the popover instance.
         * @return {?}
         */
        function () {
            this.show = true;
        };
        /** Close the popover instance. */
        /**
         * Close the popover instance.
         * @return {?}
         */
        NxPopoverTriggerDirective.prototype.close = /**
         * Close the popover instance.
         * @return {?}
         */
        function () {
            this.show = false;
        };
        /** Toggle the popover instance. */
        /**
         * Toggle the popover instance.
         * @return {?}
         */
        NxPopoverTriggerDirective.prototype.toggle = /**
         * Toggle the popover instance.
         * @return {?}
         */
        function () {
            this.show = !this.show;
        };
        /**
         * @private
         * @return {?}
         */
        NxPopoverTriggerDirective.prototype.openPopover = /**
         * @private
         * @return {?}
         */
        function () {
            if (!this.createOverlay().hasAttached()) {
                this._embeddedViewRef = this.createOverlay().attach(this.portal);
                /** @type {?} */
                var element = (/** @type {?} */ (this._embeddedViewRef.rootNodes[0]));
                this._focusTrap = this._focusTrapFactory.create(element);
                this._elementFocusedBeforePopoverWasOpened = this.elementRef.nativeElement;
                this._autoFocusFirstTabbableElement(element);
                // attach a close click listener only if it makes sense (ignore it on hover e.g.)
                if (this.shouldReactOnClickOutside()) {
                    this.waitForClose();
                }
            }
        };
        /**
         * Autofocus the first tabbable element inside of the popover, if there is not a tabbable element,
         * focus the popover instead.
         */
        /**
         * Autofocus the first tabbable element inside of the popover, if there is not a tabbable element,
         * focus the popover instead.
         * @private
         * @param {?} element
         * @return {?}
         */
        NxPopoverTriggerDirective.prototype._autoFocusFirstTabbableElement = /**
         * Autofocus the first tabbable element inside of the popover, if there is not a tabbable element,
         * focus the popover instead.
         * @private
         * @param {?} element
         * @return {?}
         */
        function (element) {
            this._focusTrap.focusInitialElementWhenReady().then((/**
             * @param {?} hasMovedFocus
             * @return {?}
             */
            function (hasMovedFocus) {
                // If we didn't find any focusable elements inside the popover, focus the
                // container so the user can't tab into other elements behind it.
                if (!hasMovedFocus) {
                    element.focus();
                }
            }));
        };
        /**
         * @private
         * @return {?}
         */
        NxPopoverTriggerDirective.prototype.shouldReactOnClickOutside = /**
         * @private
         * @return {?}
         */
        function () {
            return (!this.modal && this.closeOnClickOutside);
        };
        // detaches the overlay
        // we are listening to the detachments observable which will then emit the nxClosed event
        // on the popover component
        // detaches the overlay
        // we are listening to the detachments observable which will then emit the nxClosed event
        // on the popover component
        /**
         * @private
         * @return {?}
         */
        NxPopoverTriggerDirective.prototype.closePopover = 
        // detaches the overlay
        // we are listening to the detachments observable which will then emit the nxClosed event
        // on the popover component
        /**
         * @private
         * @return {?}
         */
        function () {
            if (this.overlayRef) {
                this._returnFocusAfterPopover();
                this.overlayRef.detach();
                this._embeddedViewRef = null;
                this._focusTrap.destroy();
            }
        };
        /**
         * @private
         * @return {?}
         */
        NxPopoverTriggerDirective.prototype.createOverlay = /**
         * @private
         * @return {?}
         */
        function () {
            if (!this.overlayRef) {
                this.portal = new portal.TemplatePortal(this.popover.templateRef, this.viewContainerRef);
                /** @type {?} */
                var overlayState = new overlay.OverlayConfig();
                overlayState.positionStrategy = this.getPosition();
                this._positionStrategy = overlayState.positionStrategy;
                if (this.scrollStrategy === 'reposition') {
                    overlayState.scrollStrategy = this.overlay.scrollStrategies.reposition();
                }
                else {
                    overlayState.scrollStrategy = this.overlay.scrollStrategies.close();
                }
                overlayState.scrollStrategy.enable();
                if (this.modal && this.trigger === 'click') {
                    overlayState.hasBackdrop = true;
                }
                this.overlayRef = this.overlay.create(overlayState);
                this.subscribeToPositions((/** @type {?} */ (overlayState.positionStrategy)));
                this._subscribeToAttach();
                this._subscribeToDetach();
                if (this.modal) {
                    this._subscribeToBackdropClick();
                }
            }
            return this.overlayRef;
        };
        /**
         * @private
         * @param {?} position
         * @return {?}
         */
        NxPopoverTriggerDirective.prototype.subscribeToPositions = /**
         * @private
         * @param {?} position
         * @return {?}
         */
        function (position) {
            var _this = this;
            position.positionChanges.pipe(operators.takeUntil(this._destroyed)).subscribe((/**
             * @param {?} change
             * @return {?}
             */
            function (change) {
                /** @type {?} */
                var pair = change.connectionPair;
                _this.positionOverlay(pair);
                _this.positionArrow(pair);
                // These position changes arrive too late,
                // We have to trigger the change detection manually
                // as it's detached from any render hierarchy
                // and only updated by the overlay when attached.
                if (_this._embeddedViewRef && !_this._embeddedViewRef.destroyed) {
                    _this._embeddedViewRef.detectChanges();
                }
            }));
        };
        // for modal popovers close the popover on backdrop clicks
        // for modal popovers close the popover on backdrop clicks
        /**
         * @private
         * @return {?}
         */
        NxPopoverTriggerDirective.prototype._subscribeToBackdropClick = 
        // for modal popovers close the popover on backdrop clicks
        /**
         * @private
         * @return {?}
         */
        function () {
            var _this = this;
            this.overlayRef.backdropClick().pipe(operators.takeUntil(this._destroyed)).subscribe((/**
             * @param {?} event
             * @return {?}
             */
            function (event) {
                _this.show = false;
            }));
        };
        // Emit the nxClosed and the show status change event on the popover component when the overlay detaches
        // Emit the nxClosed and the show status change event on the popover component when the overlay detaches
        /**
         * @private
         * @return {?}
         */
        NxPopoverTriggerDirective.prototype._subscribeToDetach = 
        // Emit the nxClosed and the show status change event on the popover component when the overlay detaches
        /**
         * @private
         * @return {?}
         */
        function () {
            var _this = this;
            this.overlayRef.detachments().pipe(operators.takeUntil(this._destroyed)).subscribe((/**
             * @param {?} data
             * @return {?}
             */
            function (data) {
                // This is an exception: when the popover is closed by a scrolling event,
                // then only the detached method is called but the show state variable remains unchanged.
                if (_this.show) {
                    _this.show = false;
                }
                _this.changeShow.emit(_this._show);
                _this.popover.emitClosedEvent();
            }));
        };
        /**
         * @private
         * @return {?}
         */
        NxPopoverTriggerDirective.prototype._subscribeToAttach = /**
         * @private
         * @return {?}
         */
        function () {
            var _this = this;
            this.overlayRef.attachments().pipe(operators.takeUntil(this._destroyed)).subscribe((/**
             * @param {?} data
             * @return {?}
             */
            function (data) {
                _this.changeShow.emit(_this._show);
            }));
        };
        // subscribe to document clicks when trigger='click' to close the popover on clicks on the background
        // subscribe to document clicks when trigger='click' to close the popover on clicks on the background
        /**
         * @private
         * @return {?}
         */
        NxPopoverTriggerDirective.prototype.waitForClose = 
        // subscribe to document clicks when trigger='click' to close the popover on clicks on the background
        /**
         * @private
         * @return {?}
         */
        function () {
            var _this = this;
            return this._documentClickObservable
                .pipe(operators.map((/**
             * @param {?} event
             * @return {?}
             */
            function (event) { return event.target; })), operators.filter((/**
             * @param {?} target
             * @return {?}
             */
            function (target) { return !_this.elementRef.nativeElement.contains(target); })), operators.takeUntil(this.popover.closed))
                .subscribe((/**
             * @return {?}
             */
            function () {
                _this.show = false;
            }));
        };
        /**
         * @private
         * @param {?} pair
         * @return {?}
         */
        NxPopoverTriggerDirective.prototype.positionOverlay = /**
         * @private
         * @param {?} pair
         * @return {?}
         */
        function (pair) {
            if (pair.originX === 'end' && pair.overlayX === 'start') {
                this.popover.direction = 'right';
            }
            else if (pair.originY === 'bottom' && pair.overlayY === 'top') {
                this.popover.direction = 'bottom';
            }
            else if (pair.originX === 'start' && pair.overlayX === 'end') {
                this.popover.direction = 'left';
            }
            else if (pair.originY === 'top' && pair.overlayY === 'bottom') {
                this.popover.direction = 'top';
            }
        };
        /**
         * @private
         * @param {?} pair
         * @return {?}
         */
        NxPopoverTriggerDirective.prototype.positionArrow = /**
         * @private
         * @param {?} pair
         * @return {?}
         */
        function (pair) {
            /** @type {?} */
            var parentElementPositionX = this.elementRef.nativeElement.getBoundingClientRect().left;
            /** @type {?} */
            var parentElementWidth = this.elementRef.nativeElement.getBoundingClientRect().width / 2;
            /** @type {?} */
            var parentElementLeftOffset = this.overlayRef.overlayElement.parentElement.offsetLeft;
            /** @type {?} */
            var overlayElementLeftOffset = this.overlayRef.overlayElement.offsetLeft;
            // calculation for x position of the parent element. In this case, overlay left offset is the one thing to consider.
            /** @type {?} */
            var targetPosition = (parentElementPositionX + parentElementWidth) - (parentElementLeftOffset + overlayElementLeftOffset);
            if (pair.originX === pair.overlayX) {
                /** @type {?} */
                var direction = 'left';
                /** @type {?} */
                var arrowStyle = {};
                arrowStyle[direction] = targetPosition + 'px';
                this.popover.arrowStyle = arrowStyle;
            }
            if ((pair.originY === 'bottom' || pair.originY === 'top') && pair.overlayX === 'center') {
                this.popover.arrowStyle = { left: targetPosition + 'px' };
            }
            if ((pair.originX === 'end' || pair.originX === 'start') && pair.overlayY === 'center') {
                this.popover.arrowStyle = { top: '50%' };
            }
        };
        /**
         * @private
         * @return {?}
         */
        NxPopoverTriggerDirective.prototype.getPosition = /**
         * @private
         * @return {?}
         */
        function () {
            /** @type {?} */
            var positions;
            /** @type {?} */
            var offsetX = 0;
            /** @type {?} */
            var offsetY = 0;
            if (this.direction === 'top') {
                positions = [{
                        overlayX: 'center',
                        overlayY: 'bottom',
                        originX: 'center',
                        originY: 'top'
                    }];
                offsetX = 0;
                offsetY = -20;
            }
            else if (this.direction === 'right') {
                positions = [{
                        overlayX: 'start',
                        overlayY: 'center',
                        originX: 'end',
                        originY: 'center'
                    }];
                offsetX = 20;
                offsetY = 0;
            }
            else if (this.direction === 'bottom') {
                positions = [{
                        overlayX: 'center',
                        overlayY: 'top',
                        originX: 'center',
                        originY: 'bottom'
                    }];
                offsetX = 0;
                offsetY = 20;
            }
            else if (this.direction === 'left') {
                positions = [{
                        overlayX: 'end',
                        overlayY: 'center',
                        originX: 'start',
                        originY: 'center'
                    }];
                offsetX = -20;
                offsetY = 0;
            }
            return this.overlay.position().flexibleConnectedTo(this.elementRef)
                .withPositions(__spread(positions, fallbacks))
                .withDefaultOffsetX(offsetX)
                .withDefaultOffsetY(offsetY);
        };
        /** Returns the focus to the element focused before the Popover was open. */
        /**
         * Returns the focus to the element focused before the Popover was open.
         * @private
         * @return {?}
         */
        NxPopoverTriggerDirective.prototype._returnFocusAfterPopover = /**
         * Returns the focus to the element focused before the Popover was open.
         * @private
         * @return {?}
         */
        function () {
            /** @type {?} */
            var toFocus = this._elementFocusedBeforePopoverWasOpened;
            // We need the extra check, because IE can set the `activeElement` to null in some cases.
            if (toFocus && typeof toFocus.focus === 'function') {
                toFocus.focus();
            }
        };
        NxPopoverTriggerDirective.decorators = [
            { type: core.Directive, args: [{
                        selector: '[nxPopoverTriggerFor]',
                        exportAs: 'nxPopoverTrigger',
                        host: {
                            '(click)': 'handleClick()',
                            'aria-haspopup': 'true',
                            '[attr.aria-expanded]': 'isOpen',
                            '[attr.aria-describedby]': 'isOpen ? id : null'
                        }
                    },] }
        ];
        /** @nocollapse */
        NxPopoverTriggerDirective.ctorParameters = function () { return [
            { type: overlay.Overlay },
            { type: core.ElementRef },
            { type: core.ViewContainerRef },
            { type: platformBrowser.EventManager },
            { type: a11y.FocusTrapFactory },
            { type: a11y.FocusMonitor },
            { type: core.NgZone },
            { type: platform.Platform },
            { type: undefined, decorators: [{ type: core.Optional }, { type: core.Inject, args: [common.DOCUMENT,] }] }
        ]; };
        NxPopoverTriggerDirective.propDecorators = {
            changeShow: [{ type: core.Output, args: ['nxPopoverShowChange',] }],
            show: [{ type: core.Input, args: ['nxPopoverShow',] }],
            closeable: [{ type: core.Input, args: ['nxPopoverCloseable',] }],
            closeOnClickOutside: [{ type: core.Input }],
            popover: [{ type: core.Input, args: ['nxPopoverTriggerFor',] }],
            direction: [{ type: core.Input, args: ['nxPopoverDirection',] }],
            popoverInitialVisible: [{ type: core.Input, args: ['nxPopoverInitialVisible',] }],
            visibleChange: [{ type: core.Input, args: ['nxPopoverVisibleChange',] }],
            modal: [{ type: core.Input, args: ['nxPopoverModal',] }],
            trigger: [{ type: core.Input, args: ['nxPopoverTrigger',] }],
            scrollStrategy: [{ type: core.Input, args: ['nxPopoverScrollStrategy',] }]
        };
        return NxPopoverTriggerDirective;
    }());
    if (false) {
        /**
         * @type {?}
         * @private
         */
        NxPopoverTriggerDirective.prototype.overlayRef;
        /**
         * @type {?}
         * @private
         */
        NxPopoverTriggerDirective.prototype.portal;
        /**
         * @type {?}
         * @private
         */
        NxPopoverTriggerDirective.prototype._destroyed;
        /**
         * @type {?}
         * @private
         */
        NxPopoverTriggerDirective.prototype._show;
        /**
         * @type {?}
         * @private
         */
        NxPopoverTriggerDirective.prototype._closeable;
        /**
         * @type {?}
         * @private
         */
        NxPopoverTriggerDirective.prototype._positionStrategy;
        /**
         * @type {?}
         * @private
         */
        NxPopoverTriggerDirective.prototype._embeddedViewRef;
        /**
         * @type {?}
         * @private
         */
        NxPopoverTriggerDirective.prototype._documentClickObservable;
        /**
         * The class that traps and manages focus within the popover.
         * @type {?}
         * @private
         */
        NxPopoverTriggerDirective.prototype._focusTrap;
        /**
         * Element that was focused before the Popover was opened. Save this to restore upon close.
         * @type {?}
         * @private
         */
        NxPopoverTriggerDirective.prototype._elementFocusedBeforePopoverWasOpened;
        /**
         * @type {?}
         * @private
         */
        NxPopoverTriggerDirective.prototype._manualListeners;
        /**
         * \@docs-private
         * @type {?}
         */
        NxPopoverTriggerDirective.prototype.id;
        /**
         * An event is emitted if the visibility status of the popover changes.
         * @type {?}
         */
        NxPopoverTriggerDirective.prototype.changeShow;
        /**
         * @type {?}
         * @private
         */
        NxPopoverTriggerDirective.prototype._closeOnClickOutside;
        /**
         * Links the trigger with the popover to open.
         * @type {?}
         */
        NxPopoverTriggerDirective.prototype.popover;
        /**
         * Sets the desired direction to open the popover. E.g., right, left, bottom, top
         * @type {?}
         */
        NxPopoverTriggerDirective.prototype.direction;
        /**
         * Whether the popover will be opened automatically.
         * @type {?}
         */
        NxPopoverTriggerDirective.prototype.popoverInitialVisible;
        /**
         * An event is emitted when the visibility of the popopver changes.
         * @type {?}
         */
        NxPopoverTriggerDirective.prototype.visibleChange;
        /**
         * Whether the popover opens in modal state.
         * @type {?}
         */
        NxPopoverTriggerDirective.prototype.modal;
        /**
         * Sets the way to trigger the popover. Options are hover, click, manual
         * @type {?}
         */
        NxPopoverTriggerDirective.prototype.trigger;
        /**
         * Sets the scroll strategy. 'close' closes the popover on scroll while 'reposition' scrolls the popover with the origin.
         * @type {?}
         */
        NxPopoverTriggerDirective.prototype.scrollStrategy;
        /**
         * @type {?}
         * @private
         */
        NxPopoverTriggerDirective.prototype.overlay;
        /**
         * @type {?}
         * @private
         */
        NxPopoverTriggerDirective.prototype.elementRef;
        /**
         * @type {?}
         * @private
         */
        NxPopoverTriggerDirective.prototype.viewContainerRef;
        /**
         * @type {?}
         * @private
         */
        NxPopoverTriggerDirective.prototype.eventManager;
        /**
         * @type {?}
         * @private
         */
        NxPopoverTriggerDirective.prototype._focusTrapFactory;
        /**
         * @type {?}
         * @private
         */
        NxPopoverTriggerDirective.prototype._focusMonitor;
        /**
         * @type {?}
         * @private
         */
        NxPopoverTriggerDirective.prototype._ngZone;
        /**
         * @type {?}
         * @private
         */
        NxPopoverTriggerDirective.prototype._platform;
        /**
         * @type {?}
         * @private
         */
        NxPopoverTriggerDirective.prototype._document;
    }

    /**
     * @fileoverview added by tsickle
     * Generated from: popover/popover.module.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var NxPopoverModule = /** @class */ (function () {
        function NxPopoverModule() {
        }
        NxPopoverModule.decorators = [
            { type: core.NgModule, args: [{
                        imports: [
                            common.CommonModule,
                            overlay.OverlayModule,
                            icon.NxIconModule
                        ],
                        declarations: [
                            NxPopoverTriggerDirective,
                            NxPopoverComponent,
                            NxPopoverContentDirective
                        ],
                        exports: [
                            NxPopoverTriggerDirective,
                            NxPopoverComponent,
                            NxPopoverContentDirective
                        ]
                    },] }
        ];
        return NxPopoverModule;
    }());

    /**
     * @fileoverview added by tsickle
     * Generated from: popover/public-api.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * Generated from: popover/index.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * Generated from: taglist/tag.component.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var NxTagComponent = /** @class */ (function () {
        function NxTagComponent(_changeDetectorRef) {
            this._changeDetectorRef = _changeDetectorRef;
            this._tabindex = -1;
            /**
             * An event is dispatched each time when the tag is clicked.
             */
            this.clicked = new core.EventEmitter();
            /**
             * An event is dispatched each time when the tag is removed.
             */
            this.removed = new core.EventEmitter();
        }
        Object.defineProperty(NxTagComponent.prototype, "removable", {
            get: /**
             * @return {?}
             */
            function () {
                return this._removable;
            },
            /** Whether the tag is removeable. */
            set: /**
             * Whether the tag is removeable.
             * @param {?} value
             * @return {?}
             */
            function (value) {
                this._removable = coercion.coerceBooleanProperty(value);
                this._changeDetectorRef.markForCheck();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NxTagComponent.prototype, "tabindex", {
            get: /**
             * @return {?}
             */
            function () {
                return this.removable ? 0 : this._tabindex;
            },
            /**
             * Sets the tab-index of a tag. Default value: -1.
             *
             * If `nxAllowTagDeletion` of the taglist is set to true, the default value is 0.
             */
            set: /**
             * Sets the tab-index of a tag. Default value: -1.
             *
             * If `nxAllowTagDeletion` of the taglist is set to true, the default value is 0.
             * @param {?} value
             * @return {?}
             */
            function (value) {
                this._tabindex = coercion.coerceNumberProperty(value);
                this._changeDetectorRef.markForCheck();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NxTagComponent.prototype, "value", {
            get: /**
             * @return {?}
             */
            function () {
                return this._value;
            },
            /** Sets the value of the tag. */
            set: /**
             * Sets the value of the tag.
             * @param {?} value
             * @return {?}
             */
            function (value) {
                if (this._value !== value) {
                    this._value = value;
                    this._changeDetectorRef.markForCheck();
                }
            },
            enumerable: true,
            configurable: true
        });
        /** @docs-private */
        // Emit the removed event that the parent can remove the value
        /**
         * \@docs-private
         * @param {?} event
         * @return {?}
         */
        // Emit the removed event that the parent can remove the value
        NxTagComponent.prototype.removeClickHandler = /**
         * \@docs-private
         * @param {?} event
         * @return {?}
         */
        // Emit the removed event that the parent can remove the value
        function (event) {
            event.stopPropagation();
            this.removed.emit(this.value);
        };
        /** @docs-private */
        /**
         * \@docs-private
         * @param {?} event
         * @return {?}
         */
        NxTagComponent.prototype.removeKeyHandler = /**
         * \@docs-private
         * @param {?} event
         * @return {?}
         */
        function (event) {
            if (this.removable && (event.keyCode === keycodes.DELETE || event.keyCode === keycodes.BACKSPACE)) {
                event.preventDefault();
                event.stopPropagation();
                this.removed.emit(this.value);
            }
            if (event.keyCode === keycodes.ENTER) {
                this.clicked.emit(this.value);
            }
        };
        /** @docs-private */
        /**
         * \@docs-private
         * @return {?}
         */
        NxTagComponent.prototype.tagClickHandler = /**
         * \@docs-private
         * @return {?}
         */
        function () {
            this.clicked.emit(this.value);
        };
        NxTagComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'nx-tag',
                        template: "{{ value }}\n<span role=\"link\" aria-label=\"close\" class=\"nx-tag__close\" *ngIf=\"removable\"\n    (click)=\"removeClickHandler($event)\">\n    <nx-icon class=\"nx-tag__close-icon\" name=\"close\"></nx-icon>\n</span>",
                        changeDetection: core.ChangeDetectionStrategy.OnPush,
                        host: {
                            '(click)': 'tagClickHandler()',
                            '(keydown)': 'removeKeyHandler($event)',
                            '[attr.tabindex]': 'tabindex'
                        },
                        styles: [":host{font-size:14px;font-size:var(--taglist-font-size,14px);line-height:16px;line-height:var(--taglist-line-height,16px);font-weight:600;font-weight:var(--taglist-font-weight,600);letter-spacing:1px;letter-spacing:var(--taglist-letter-spacing,1px);height:auto;max-width:100%;color:#767676;color:var(--taglist-color,#767676);background-color:transparent;background-color:var(--taglist-background-color,transparent);padding:6px 14px;display:flex;align-items:center;border:2px solid #d9d9d9;border:2px solid var(--taglist-border-color,#d9d9d9);border-radius:4px;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;transition:background-color .2s,box-shadow .2s;cursor:pointer}:host:hover{border-color:#c2c2c2;border-color:var(--taglist-hover-border-color,#c2c2c2);color:#5b5b5b;color:var(--taglist-hover-color,#5b5b5b);background-color:#ececec;background-color:var(--taglist-hover-background-color,#ececec)}:host:focus{outline:transparent solid 2px}:host-context([data-whatinput=keyboard]):focus{box-shadow:0 0 0 2px #fff,0 0 0 6px #009de6;box-shadow:var(--focus-box-shadow,0 0 0 2px #fff,0 0 0 6px #009de6)}.nx-tag__close-icon{outline:0;display:block;font-size:16px;font-size:var(--taglist-close-icon-size,16px)}.nx-tag__close{margin-left:8px}:host-context(.nx-taglist--keyword){padding:14px 22px}@media screen and (-ms-high-contrast:active){:host-context([data-whatinput=keyboard]):focus{box-shadow:0 0 0 2px background,0 0 0 6px windowText}:host,:host:focus,:host:hover{color:buttonText;background-color:buttonFace;border-color:buttonText;-ms-high-contrast-adjust:none}}"]
                    }] }
        ];
        /** @nocollapse */
        NxTagComponent.ctorParameters = function () { return [
            { type: core.ChangeDetectorRef }
        ]; };
        NxTagComponent.propDecorators = {
            removable: [{ type: core.Input }],
            tabindex: [{ type: core.Input }],
            value: [{ type: core.Input }],
            clicked: [{ type: core.Output }],
            removed: [{ type: core.Output }]
        };
        return NxTagComponent;
    }());
    if (false) {
        /**
         * @type {?}
         * @private
         */
        NxTagComponent.prototype._removable;
        /**
         * @type {?}
         * @private
         */
        NxTagComponent.prototype._tabindex;
        /**
         * @type {?}
         * @private
         */
        NxTagComponent.prototype._value;
        /**
         * An event is dispatched each time when the tag is clicked.
         * @type {?}
         */
        NxTagComponent.prototype.clicked;
        /**
         * An event is dispatched each time when the tag is removed.
         * @type {?}
         */
        NxTagComponent.prototype.removed;
        /**
         * @type {?}
         * @private
         */
        NxTagComponent.prototype._changeDetectorRef;
    }

    /**
     * @fileoverview added by tsickle
     * Generated from: taglist/taglist.component.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var NxTaglistComponent = /** @class */ (function () {
        function NxTaglistComponent(_changeDetectorRef) {
            this._changeDetectorRef = _changeDetectorRef;
            /**
             * An event is dispatched each time when the list of tags changed.
             */
            this.tagsChange = new core.EventEmitter();
            /**
             * An event is dispatched each time when a tag is clicked.
             */
            this.tagClickEvent = new core.EventEmitter();
            this._tags = [];
            this._tabindex = -1;
            this._allowTagDeletion = true;
            this._isKeywordList = false;
            this._labelProperty = 'nxTaglistLabel';
            this._valueFormatterFn = (/**
             * @param {?} value
             * @return {?}
             */
            function (value) { return value; });
            this._onChange = (/**
             * @return {?}
             */
            function () { });
            this._onTouched = (/**
             * @return {?}
             */
            function () { });
        }
        Object.defineProperty(NxTaglistComponent.prototype, "tags", {
            get: /**
             * @return {?}
             */
            function () {
                return this._tags;
            },
            /** Sets the list of tags. */
            set: /**
             * Sets the list of tags.
             * @param {?} value
             * @return {?}
             */
            function (value) {
                this._tags = value;
                this._changeDetectorRef.markForCheck();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NxTaglistComponent.prototype, "tabindex", {
            get: /**
             * @return {?}
             */
            function () {
                return this.allowTagDeletion ? 0 : this._tabindex;
            },
            /** Sets the tabindex of the contained tags. Default value: -1. */
            set: /**
             * Sets the tabindex of the contained tags. Default value: -1.
             * @param {?} value
             * @return {?}
             */
            function (value) {
                this._tabindex = coercion.coerceNumberProperty(value);
                this._changeDetectorRef.markForCheck();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NxTaglistComponent.prototype, "allowTagDeletion", {
            get: /**
             * @return {?}
             */
            function () {
                return this._allowTagDeletion;
            },
            /** Whether the tags can be removed from the list. Default: true. */
            set: /**
             * Whether the tags can be removed from the list. Default: true.
             * @param {?} value
             * @return {?}
             */
            function (value) {
                this._allowTagDeletion = coercion.coerceBooleanProperty(value);
                this._changeDetectorRef.markForCheck();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NxTaglistComponent.prototype, "isKeywordList", {
            get: /**
             * @return {?}
             */
            function () {
                return this._isKeywordList;
            },
            /** Whether the tags can be styled as keywords. */
            set: /**
             * Whether the tags can be styled as keywords.
             * @param {?} value
             * @return {?}
             */
            function (value) {
                this._isKeywordList = coercion.coerceBooleanProperty(value);
                this._changeDetectorRef.markForCheck();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NxTaglistComponent.prototype, "labelProp", {
            get: /**
             * @return {?}
             */
            function () {
                return this._labelProperty;
            },
            /** Sets the label property, in case tags represent objects. */
            set: /**
             * Sets the label property, in case tags represent objects.
             * @param {?} value
             * @return {?}
             */
            function (value) {
                if (this._labelProperty !== value) {
                    this._labelProperty = value;
                    this._changeDetectorRef.markForCheck();
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NxTaglistComponent.prototype, "labelledby", {
            get: /**
             * @return {?}
             */
            function () {
                return this._ariaLabelledBy;
            },
            /** Sets the label property to improve accessibility. */
            set: /**
             * Sets the label property to improve accessibility.
             * @param {?} value
             * @return {?}
             */
            function (value) {
                if (this._ariaLabelledBy !== value) {
                    this._ariaLabelledBy = value;
                    this._changeDetectorRef.markForCheck();
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NxTaglistComponent.prototype, "valueFormatter", {
            get: /**
             * @return {?}
             */
            function () {
                return this._valueFormatterFn;
            },
            /** Sets the customization function for tag value.  */
            set: /**
             * Sets the customization function for tag value.
             * @param {?} fn
             * @return {?}
             */
            function (fn) {
                this._valueFormatterFn = fn;
                this._changeDetectorRef.markForCheck();
            },
            enumerable: true,
            configurable: true
        });
        /** Allows to delete a tag given index. Takes index of the tag to be deleted as a parameter */
        /**
         * Allows to delete a tag given index. Takes index of the tag to be deleted as a parameter
         * @param {?} index
         * @param {?} value
         * @return {?}
         */
        NxTaglistComponent.prototype.delete = /**
         * Allows to delete a tag given index. Takes index of the tag to be deleted as a parameter
         * @param {?} index
         * @param {?} value
         * @return {?}
         */
        function (index, value) {
            if (this.allowTagDeletion) {
                this.tags = __spread(this.tags.slice(0, index), this.tags.slice(index + 1));
                // focus next element after deletion
                if (this.tagChildren.toArray()[index + 1]) {
                    this.tagChildren.toArray()[index + 1].nativeElement.focus();
                }
                this._onChange(this.tags);
                this.tagsChange.emit(this.tags);
            }
        };
        /** Allows to add a tag. Takes tag object as an input */
        /**
         * Allows to add a tag. Takes tag object as an input
         * @param {?} tag
         * @return {?}
         */
        NxTaglistComponent.prototype.addTag = /**
         * Allows to add a tag. Takes tag object as an input
         * @param {?} tag
         * @return {?}
         */
        function (tag) {
            var _this = this;
            if (!tag) {
                return;
            }
            // make sure tag is either string or has the configured label prop and is not yet in the list
            if ((typeof tag === 'string' && this.tags.indexOf(tag) === -1) ||
                (tag[this.labelProp] && this.tags.filter((/**
                 * @param {?} t
                 * @return {?}
                 */
                function (t) { return t[_this.labelProp] === tag[_this.labelProp]; })).length < 1)) {
                this.tags = __spread(this.tags, [tag]);
                this._onChange(this.tags);
                this.tagsChange.emit(this.tags);
            }
        };
        /** Allows to clear the tag list. */
        /**
         * Allows to clear the tag list.
         * @return {?}
         */
        NxTaglistComponent.prototype.clearTags = /**
         * Allows to clear the tag list.
         * @return {?}
         */
        function () {
            this.tags = [];
            this._onChange(this.tags);
            this.tagsChange.emit(this.tags);
        };
        /** @docs-private */
        /**
         * \@docs-private
         * @param {?} tags
         * @return {?}
         */
        NxTaglistComponent.prototype.writeValue = /**
         * \@docs-private
         * @param {?} tags
         * @return {?}
         */
        function (tags) {
            this.tags = tags;
        };
        /**
         * @param {?} fn
         * @return {?}
         */
        NxTaglistComponent.prototype.registerOnChange = /**
         * @param {?} fn
         * @return {?}
         */
        function (fn) {
            this._onChange = fn;
        };
        /**
         * @param {?} fn
         * @return {?}
         */
        NxTaglistComponent.prototype.registerOnTouched = /**
         * @param {?} fn
         * @return {?}
         */
        function (fn) {
            this._onTouched = fn;
        };
        /** @docs-private */
        /**
         * \@docs-private
         * @param {?} tag
         * @return {?}
         */
        NxTaglistComponent.prototype.renderTag = /**
         * \@docs-private
         * @param {?} tag
         * @return {?}
         */
        function (tag) {
            /** @type {?} */
            var tagStr = typeof tag === 'string' ? tag : tag[this.labelProp];
            return this.valueFormatter(tagStr);
        };
        /** @docs-private */
        /**
         * \@docs-private
         * @param {?} index
         * @param {?} value
         * @return {?}
         */
        NxTaglistComponent.prototype.tagClick = /**
         * \@docs-private
         * @param {?} index
         * @param {?} value
         * @return {?}
         */
        function (index, value) {
            this.tagClickEvent.emit(this.tags[index]);
        };
        NxTaglistComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'nx-taglist',
                        template: "  <ul class=\"nx-taglist\" *ngIf=\"tags.length > 0\">\n    <li class=\"nx-taglist__list-item\" tabindex=\"-1\" *ngFor=\"let tag of tags; let i = index\">\n      <nx-tag [value]=\"renderTag(tag)\" [removable]=\"allowTagDeletion\" [tabindex]=\"tabindex\" (clicked)=\"tagClick(i, $event)\" (removed)=\"delete(i, $event)\"></nx-tag>\n  </li>\n  </ul>\n  <ng-content *ngIf=\"tags.length < 1\"></ng-content>\n",
                        changeDetection: core.ChangeDetectionStrategy.OnPush,
                        providers: [
                            {
                                provide: forms.NG_VALUE_ACCESSOR,
                                useExisting: core.forwardRef((/**
                                 * @return {?}
                                 */
                                function () { return NxTaglistComponent; })),
                                multi: true
                            }
                        ],
                        host: {
                            '[class.nx-taglist--keyword]': 'isKeywordList',
                            '[attr.aria-labelledby]': 'labelledby || null',
                            '[attr.tabindex]': '-1'
                        },
                        styles: [":host{position:relative;min-height:32px;margin-bottom:32px;display:flex;justify-content:space-between}:host:focus{outline:0}.nx-taglist{display:flex;flex-wrap:wrap}.nx-taglist__list-item{list-style:none;margin-right:12px;margin-bottom:12px;flex-wrap:wrap;display:flex}@media (max-width:703px){.nx-taglist--keyword{justify-content:center}}"]
                    }] }
        ];
        /** @nocollapse */
        NxTaglistComponent.ctorParameters = function () { return [
            { type: core.ChangeDetectorRef }
        ]; };
        NxTaglistComponent.propDecorators = {
            tagsChange: [{ type: core.Output, args: ['nxTagsChange',] }],
            tagClickEvent: [{ type: core.Output, args: ['nxTagClick',] }],
            tagChildren: [{ type: core.ViewChildren, args: [NxTagComponent, { read: core.ElementRef },] }],
            tags: [{ type: core.Input, args: ['nxTags',] }],
            tabindex: [{ type: core.Input }],
            allowTagDeletion: [{ type: core.Input, args: ['nxAllowTagDeletion',] }],
            isKeywordList: [{ type: core.Input, args: ['nxIsKeywordList',] }],
            labelProp: [{ type: core.Input, args: ['nxLabelProperty',] }],
            labelledby: [{ type: core.Input, args: ['aria-labelledby',] }],
            valueFormatter: [{ type: core.Input, args: ['nxValueFormatter',] }]
        };
        return NxTaglistComponent;
    }());
    if (false) {
        /**
         * An event is dispatched each time when the list of tags changed.
         * @type {?}
         */
        NxTaglistComponent.prototype.tagsChange;
        /**
         * An event is dispatched each time when a tag is clicked.
         * @type {?}
         */
        NxTaglistComponent.prototype.tagClickEvent;
        /**
         * \@docs-private
         * @type {?}
         */
        NxTaglistComponent.prototype.tagChildren;
        /**
         * @type {?}
         * @private
         */
        NxTaglistComponent.prototype._tags;
        /**
         * @type {?}
         * @private
         */
        NxTaglistComponent.prototype._tabindex;
        /**
         * @type {?}
         * @private
         */
        NxTaglistComponent.prototype._allowTagDeletion;
        /**
         * @type {?}
         * @private
         */
        NxTaglistComponent.prototype._isKeywordList;
        /**
         * @type {?}
         * @private
         */
        NxTaglistComponent.prototype._labelProperty;
        /**
         * @type {?}
         * @private
         */
        NxTaglistComponent.prototype._ariaLabelledBy;
        /**
         * @type {?}
         * @private
         */
        NxTaglistComponent.prototype._valueFormatterFn;
        /**
         * @type {?}
         * @private
         */
        NxTaglistComponent.prototype._onChange;
        /**
         * @type {?}
         * @private
         */
        NxTaglistComponent.prototype._onTouched;
        /**
         * @type {?}
         * @private
         */
        NxTaglistComponent.prototype._changeDetectorRef;
    }

    /**
     * @fileoverview added by tsickle
     * Generated from: taglist/taglist.module.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var NxTaglistModule = /** @class */ (function () {
        function NxTaglistModule() {
        }
        NxTaglistModule.decorators = [
            { type: core.NgModule, args: [{
                        declarations: [NxTaglistComponent, NxTagComponent],
                        exports: [NxTaglistComponent, NxTagComponent],
                        imports: [common.CommonModule, icon.NxIconModule]
                    },] }
        ];
        return NxTaglistModule;
    }());

    /**
     * @fileoverview added by tsickle
     * Generated from: taglist/public-api.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * Generated from: image/image.directive.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var NxImageDirective = /** @class */ (function () {
        function NxImageDirective() {
            console.warn('Directive nxImg which was used together with nxFigure ' +
                'is now deprecated and not required anymore. Please remove it from your ' +
                'tag. Check the documentation for more details.');
        }
        NxImageDirective.decorators = [
            { type: core.Directive, args: [{
                        selector: 'img[nxImg]'
                    },] }
        ];
        /** @nocollapse */
        NxImageDirective.ctorParameters = function () { return []; };
        return NxImageDirective;
    }());

    /**
     * @fileoverview added by tsickle
     * Generated from: image/figure.component.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /** @type {?} */
    var DEFAULT_SIZE$2 = 'auto';
    var NxFigureComponent = /** @class */ (function () {
        function NxFigureComponent() {
        }
        Object.defineProperty(NxFigureComponent.prototype, "classNames", {
            get: /**
             * @return {?}
             */
            function () {
                return this._classNames;
            },
            /**
             * Sets the type of the visual appearance of the image.
             * The default value  is 'auto'.
             */
            set: /**
             * Sets the type of the visual appearance of the image.
             * The default value  is 'auto'.
             * @param {?} value
             * @return {?}
             */
            function (value) {
                if (this._classNames === value) {
                    return;
                }
                this._classNames = value;
                /** @type {?} */
                var sizeRegex = /^(auto|1by1|1dot8by1|1dot2by1|1by1dot1|2dot6by1)$/;
                var _a = __read(this._classNames.match(sizeRegex) || [DEFAULT_SIZE$2], 1), _b = _a[0], size = _b === void 0 ? null : _b;
                this.size = (/** @type {?} */ (size));
                this.rounded = !!this._classNames.match(/rounded/);
            },
            enumerable: true,
            configurable: true
        });
        NxFigureComponent.decorators = [
            { type: core.Component, args: [{
                        // tslint:disable-next-line:component-selector
                        selector: 'figure[nxFigure]',
                        template: '<ng-content></ng-content>',
                        changeDetection: core.ChangeDetectionStrategy.OnPush,
                        host: {
                            '[class.nx-image--auto]': 'size === "auto" && !rounded',
                            '[class.nx-image--1by1]': 'size === "1by1"',
                            '[class.nx-image--1dot8by1]': 'size === "1dot8by1"',
                            '[class.nx-image--1dot2by1]': 'size === "1dot2by1"',
                            '[class.nx-image--1by1dot1]': 'size === "1by1dot1"',
                            '[class.nx-image--2dot6by1]': 'size === "2dot6by1"',
                            '[class.nx-image--rounded]': 'rounded'
                        },
                        styles: [":host{display:block;position:relative;line-height:0}:host ::ng-deep img{display:block;font-family:\"object-fit: cover;\";-o-object-fit:cover;object-fit:cover;height:100%;width:100%}:host(.nx-image--auto) ::ng-deep img{height:auto}:host(:not(.nx-image--auto)) ::ng-deep img{position:absolute;top:0;left:0}:host(.nx-image--rounded){padding-top:100%}:host(.nx-image--rounded) ::ng-deep img{border-radius:50%;bottom:0;left:0;position:absolute;right:0;top:0}:host(.nx-image--1by1){padding-top:100%}:host(.nx-image--1dot8by1){padding-top:55.55556%}:host(.nx-image--1dot2by1){padding-top:83.33333%}:host(.nx-image--1by1dot1){padding-top:110%}:host(.nx-image--2dot6by1){padding-top:38.46154%}:host(.nx-image--1by1dot4){padding-top:140%}"]
                    }] }
        ];
        NxFigureComponent.propDecorators = {
            classNames: [{ type: core.Input, args: ['nxFigure',] }]
        };
        return NxFigureComponent;
    }());
    if (false) {
        /**
         * @type {?}
         * @private
         */
        NxFigureComponent.prototype._classNames;
        /**
         * \@docs-private
         * @type {?}
         */
        NxFigureComponent.prototype.rounded;
        /**
         * \@docs-private
         * @type {?}
         */
        NxFigureComponent.prototype.size;
    }

    /**
     * @fileoverview added by tsickle
     * Generated from: image/image.module.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var NxImageModule = /** @class */ (function () {
        function NxImageModule() {
        }
        NxImageModule.decorators = [
            { type: core.NgModule, args: [{
                        declarations: [NxFigureComponent, NxImageDirective],
                        exports: [NxFigureComponent, NxImageDirective]
                    },] }
        ];
        return NxImageModule;
    }());

    /**
     * @fileoverview added by tsickle
     * Generated from: image/public-api.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * Generated from: video/video.component.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var NxVideoComponent = /** @class */ (function () {
        function NxVideoComponent(sanitizer, _changeDetectorRef) {
            this.sanitizer = sanitizer;
            this._changeDetectorRef = _changeDetectorRef;
            this._videoId = null;
            this._altText = '';
            this._playButtonAriaLabel = '';
            this._previewImageSrc = null;
            this._showPlayerControls = true;
            this._allowFullScreen = true;
            this._interfaceLanguage = null;
            /**
             * \@docs-private
             */
            this.showPlayer = false;
        }
        Object.defineProperty(NxVideoComponent.prototype, "videoId", {
            get: /**
             * @return {?}
             */
            function () {
                return this._videoId;
            },
            /** Sets the id of the YouTube video. */
            set: /**
             * Sets the id of the YouTube video.
             * @param {?} value
             * @return {?}
             */
            function (value) {
                if (this._videoId !== value) {
                    this._videoId = value;
                    this._changeDetectorRef.markForCheck();
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NxVideoComponent.prototype, "altText", {
            get: /**
             * @return {?}
             */
            function () {
                return this._altText;
            },
            /** Sets the value of the alt attribute for the preview image. */
            set: /**
             * Sets the value of the alt attribute for the preview image.
             * @param {?} value
             * @return {?}
             */
            function (value) {
                if (this._altText !== value) {
                    this._altText = value;
                    this._changeDetectorRef.markForCheck();
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NxVideoComponent.prototype, "nxPlayButtonAriaLabel", {
            get: /**
             * @return {?}
             */
            function () {
                return this._playButtonAriaLabel;
            },
            /** Sets the value of the aria-label attribute on the play button (Default: Play Video). */
            set: /**
             * Sets the value of the aria-label attribute on the play button (Default: Play Video).
             * @param {?} value
             * @return {?}
             */
            function (value) {
                if (this._playButtonAriaLabel !== value) {
                    this._playButtonAriaLabel = value;
                    this._changeDetectorRef.markForCheck();
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NxVideoComponent.prototype, "previewImageSrc", {
            get: /**
             * @return {?}
             */
            function () {
                return this._previewImageSrc;
            },
            /** Sets the preview image. If this is not provided, an image from YouTube will be used as default. */
            set: /**
             * Sets the preview image. If this is not provided, an image from YouTube will be used as default.
             * @param {?} value
             * @return {?}
             */
            function (value) {
                if (this._previewImageSrc !== value) {
                    this._previewImageSrc = value;
                    this._changeDetectorRef.markForCheck();
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NxVideoComponent.prototype, "showPlayerControls", {
            get: /**
             * @return {?}
             */
            function () {
                return this._showPlayerControls;
            },
            /** Sets player controls. If set to false, player controls are not available. */
            set: /**
             * Sets player controls. If set to false, player controls are not available.
             * @param {?} value
             * @return {?}
             */
            function (value) {
                this._showPlayerControls = coercion.coerceBooleanProperty(value);
                this._changeDetectorRef.markForCheck();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NxVideoComponent.prototype, "allowFullScreen", {
            get: /**
             * @return {?}
             */
            function () {
                return this._allowFullScreen;
            },
            /** Sets fullscreen option. If set to false, fullscreen option is not available. */
            set: /**
             * Sets fullscreen option. If set to false, fullscreen option is not available.
             * @param {?} value
             * @return {?}
             */
            function (value) {
                this._allowFullScreen = coercion.coerceBooleanProperty(value);
                this._changeDetectorRef.markForCheck();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NxVideoComponent.prototype, "interfaceLanguage", {
            get: /**
             * @return {?}
             */
            function () {
                return this._interfaceLanguage;
            },
            /** Sets interface language. Can be used to override the interface language determined by YouTube. */
            set: /**
             * Sets interface language. Can be used to override the interface language determined by YouTube.
             * @param {?} value
             * @return {?}
             */
            function (value) {
                if (this._interfaceLanguage !== value) {
                    this._interfaceLanguage = value;
                    this._changeDetectorRef.markForCheck();
                }
            },
            enumerable: true,
            configurable: true
        });
        /** @docs-private */
        /**
         * \@docs-private
         * @return {?}
         */
        NxVideoComponent.prototype.select = /**
         * \@docs-private
         * @return {?}
         */
        function () {
            this.showPlayer = true;
            this._changeDetectorRef.markForCheck();
        };
        Object.defineProperty(NxVideoComponent.prototype, "videoSrc", {
            /** Returns the safe resource URL of the YouTube video, given video id.  */
            get: /**
             * Returns the safe resource URL of the YouTube video, given video id.
             * @return {?}
             */
            function () {
                /** @type {?} */
                var url = "https://www.youtube.com/embed/" + this.videoId + "?rel=0&showinfo=0&autoplay=1";
                if (!this.showPlayerControls) {
                    url += '&controls=0';
                }
                if (!this.allowFullScreen) {
                    url += '&fs=0';
                }
                if (this.interfaceLanguage) {
                    url += "&hl=" + this.interfaceLanguage;
                }
                return this.sanitizer.bypassSecurityTrustResourceUrl(url);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NxVideoComponent.prototype, "imgSrc", {
            /** Returns the preview image source URL, given video id. */
            get: /**
             * Returns the preview image source URL, given video id.
             * @return {?}
             */
            function () {
                return this.previewImageSrc ? this.previewImageSrc : "https://img.youtube.com/vi/" + this.videoId + "/sddefault.jpg";
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NxVideoComponent.prototype, "playButtonAriaLabel", {
            /** Returns the labels for the control buttons. */
            get: /**
             * Returns the labels for the control buttons.
             * @return {?}
             */
            function () {
                /** @type {?} */
                var defaultLabel = this.altText ? this.altText + " - Play Video" : 'Play Video';
                return this.nxPlayButtonAriaLabel ? this.nxPlayButtonAriaLabel : defaultLabel;
            },
            enumerable: true,
            configurable: true
        });
        NxVideoComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'nx-video',
                        template: "<div class=\"nx-video\">\n  <div class=\"nx-video__iframe\">\n\n    <div *ngIf=\"!showPlayer\">\n\n      <button class=\"nx-video__play-button\"\n              (click)=\"select()\"\n              [attr.aria-label]=\"playButtonAriaLabel\"\n              (keydown.enter)=\"select()\">\n        <nx-icon class=\"nx-video__high-contrast-icon\" name=\"play\" size=\"s\"></nx-icon>\n      </button>\n      <img [src]=\"imgSrc\" class=\"nx-video__thumbnail\"\n           [alt]=\"altText\"\n           (click)=\"select()\"\n           (keydown.enter)=\"select()\">\n\n    </div>\n    <div *ngIf=\"videoId && showPlayer\">\n      <iframe title=\"video\" class=\"nx-video__iframe\" [attr.allowfullscreen]=\"allowFullScreen\" [src]=\"videoSrc\"></iframe>\n    </div>\n\n  </div>\n</div>\n",
                        changeDetection: core.ChangeDetectionStrategy.OnPush,
                        styles: [".nx-video{position:relative;padding-bottom:56.25%;overflow:hidden;width:100%;height:auto}.nx-video__iframe{position:absolute;top:0;left:0;width:100%;height:100%;border:none}.nx-video__thumbnail{position:absolute;cursor:pointer;width:100%;top:50%;left:50%;transform:translate(-50%,-50%);opacity:.7}.nx-video__play-button{border:none;background:url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0naHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcnIHhtbG5zOnhsaW5rPSdodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rJyB3aWR0aD0nODhweCcgaGVpZ2h0PSc1NnB4JyB2aWV3Qm94PScwIDAgODggNTYnIHZlcnNpb249JzEuMSc+PHRpdGxlPkF0b20gLyBNZWRpYSAvIFlvdVR1YmUgUGxheWVyIC8gW0Fzc2V0c10gLyBQbGF5IEJ1dHRvbjwvdGl0bGU+PGRlc2M+Q3JlYXRlZCB3aXRoIFNrZXRjaC48L2Rlc2M+PGRlZnM+PHJlY3QgaWQ9J3BhdGgtMScgeD0nMCcgeT0nMCcgd2lkdGg9Jzg4JyBoZWlnaHQ9JzU2JyByeD0nOCcvPjxmaWx0ZXIgeD0nLTQwLjklJyB5PSctNjQuMyUnIHdpZHRoPScxODEuOCUnIGhlaWdodD0nMjI4LjYlJyBmaWx0ZXJVbml0cz0nb2JqZWN0Qm91bmRpbmdCb3gnIGlkPSdmaWx0ZXItMic+PGZlT2Zmc2V0IGR4PScwJyBkeT0nMCcgaW49J1NvdXJjZUFscGhhJyByZXN1bHQ9J3NoYWRvd09mZnNldE91dGVyMScvPjxmZUdhdXNzaWFuQmx1ciBzdGREZXZpYXRpb249JzEyJyBpbj0nc2hhZG93T2Zmc2V0T3V0ZXIxJyByZXN1bHQ9J3NoYWRvd0JsdXJPdXRlcjEnLz48ZmVDb2xvck1hdHJpeCB2YWx1ZXM9JzAgMCAwIDAgMCAgIDAgMCAwIDAgMCAgIDAgMCAwIDAgMCAgMCAwIDAgMC41IDAnIHR5cGU9J21hdHJpeCcgaW49J3NoYWRvd0JsdXJPdXRlcjEnLz48L2ZpbHRlcj48L2RlZnM+PGcgaWQ9J0F0b20tLy1NZWRpYS0vLVlvdVR1YmUtUGxheWVyLS8tW0Fzc2V0c10tLy1QbGF5LUJ1dHRvbicgc3Ryb2tlPSdub25lJyBzdHJva2Utd2lkdGg9JzEnIGZpbGw9J25vbmUnIGZpbGwtcnVsZT0nZXZlbm9kZCc+PGcgaWQ9J0JhY2tncm91bmQnIG9wYWNpdHk9JzAuODAxMjM0MTQ5Jz48dXNlIGZpbGw9J2JsYWNrJyBmaWxsLW9wYWNpdHk9JzEnIGZpbHRlcj0ndXJsKCNmaWx0ZXItMiknIHhsaW5rOmhyZWY9JyNwYXRoLTEnLz48dXNlIGZpbGw9JyM0MTQxNDEnIGZpbGwtcnVsZT0nZXZlbm9kZCcgeGxpbms6aHJlZj0nI3BhdGgtMScvPjwvZz48cGF0aCBkPSdNNTQuMjExMTQ1NiwyOC44OTQ0MjcyIEwzMy40NDcyMTM2LDM5LjI3NjM5MzIgQzMyLjk1MzIzNTEsMzkuNTIzMzgyNSAzMi4zNTI1NjIxLDM5LjMyMzE1ODEgMzIuMTA1NTcyOCwzOC44MjkxNzk2IEMzMi4wMzYxNDUxLDM4LjY5MDMyNDIgMzIsMzguNTM3MjExMSAzMiwzOC4zODE5NjYgTDMyLDE3LjYxODAzNCBDMzIsMTcuMDY1NzQ5MiAzMi40NDc3MTUzLDE2LjYxODAzNCAzMywxNi42MTgwMzQgQzMzLjE1NTI0NTEsMTYuNjE4MDM0IDMzLjMwODM1ODIsMTYuNjU0MTc5MSAzMy40NDcyMTM2LDE2LjcyMzYwNjggTDU0LjIxMTE0NTYsMjcuMTA1NTcyOCBDNTQuNzA1MTI0MSwyNy4zNTI1NjIxIDU0LjkwNTM0ODUsMjcuOTUzMjM1MSA1NC42NTgzNTkyLDI4LjQ0NzIxMzYgQzU0LjU2MTU5NTUsMjguNjQwNzQxIDU0LjQwNDY3MywyOC43OTc2NjM1IDU0LjIxMTE0NTYsMjguODk0NDI3MiBaJyBpZD0nVHJpYW5nbGUnIGZpbGw9JyNGRkZGRkYnLz48L2c+PC9zdmc+) center no-repeat;cursor:pointer;position:absolute;width:88px;height:56px;z-index:1;border-radius:4px}.nx-video__play-button::-moz-focus-inner{border:0}.nx-video__play-button:focus{outline:0}.nx-video__high-contrast-icon{display:none}.nx-video__play-button,.nx-video__play-button:before{top:50%;left:50%;transform:translate(-50%,-50%)}:host-context([data-whatinput=keyboard]) .nx-video__play-button:focus{box-shadow:0 0 0 2px #fff,0 0 0 6px #009de6;box-shadow:var(--focus-box-shadow,0 0 0 2px #fff,0 0 0 6px #009de6)}@media screen and (-ms-high-contrast:active){.nx-video__play-button{background:buttonFace;border:1px solid buttonText;color:buttonText}.nx-video__high-contrast-icon{display:inline-flex;vertical-align:middle}:host-context([data-whatinput=keyboard]) .nx-video__play-button:focus{box-shadow:0 0 0 2px background,0 0 0 6px windowText}}"]
                    }] }
        ];
        /** @nocollapse */
        NxVideoComponent.ctorParameters = function () { return [
            { type: platformBrowser.DomSanitizer },
            { type: core.ChangeDetectorRef }
        ]; };
        NxVideoComponent.propDecorators = {
            videoId: [{ type: core.Input, args: ['nxVideoId',] }],
            altText: [{ type: core.Input, args: ['nxAltText',] }],
            nxPlayButtonAriaLabel: [{ type: core.Input, args: ['nxPlayButtonAriaLabel',] }],
            previewImageSrc: [{ type: core.Input, args: ['nxPreviewImageSrc',] }],
            showPlayerControls: [{ type: core.Input, args: ['nxShowPlayerControls',] }],
            allowFullScreen: [{ type: core.Input, args: ['nxAllowFullScreen',] }],
            interfaceLanguage: [{ type: core.Input, args: ['nxInterfaceLanguage',] }]
        };
        return NxVideoComponent;
    }());
    if (false) {
        /**
         * @type {?}
         * @private
         */
        NxVideoComponent.prototype._videoId;
        /**
         * @type {?}
         * @private
         */
        NxVideoComponent.prototype._altText;
        /**
         * @type {?}
         * @private
         */
        NxVideoComponent.prototype._playButtonAriaLabel;
        /**
         * @type {?}
         * @private
         */
        NxVideoComponent.prototype._previewImageSrc;
        /**
         * @type {?}
         * @private
         */
        NxVideoComponent.prototype._showPlayerControls;
        /**
         * @type {?}
         * @private
         */
        NxVideoComponent.prototype._allowFullScreen;
        /**
         * @type {?}
         * @private
         */
        NxVideoComponent.prototype._interfaceLanguage;
        /**
         * \@docs-private
         * @type {?}
         */
        NxVideoComponent.prototype.showPlayer;
        /**
         * @type {?}
         * @private
         */
        NxVideoComponent.prototype.sanitizer;
        /**
         * @type {?}
         * @private
         */
        NxVideoComponent.prototype._changeDetectorRef;
    }

    /**
     * @fileoverview added by tsickle
     * Generated from: video/video.module.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var NxVideoModule = /** @class */ (function () {
        function NxVideoModule() {
        }
        NxVideoModule.decorators = [
            { type: core.NgModule, args: [{
                        declarations: [NxVideoComponent],
                        exports: [NxVideoComponent],
                        imports: [common.CommonModule, icon.NxIconModule]
                    },] }
        ];
        return NxVideoModule;
    }());

    /**
     * @fileoverview added by tsickle
     * Generated from: video/public-api.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * Generated from: dropdown/dropdown-errors.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * Returns an exception to be thrown when attempting to change a select's `multiple` option
     * after initialization.
     * \@docs-private
     * @return {?}
     */
    function getNxDropdownDynamicMultipleError() {
        return Error('Cannot change `multiselect` mode of select after initialization.');
    }
    /**
     * Returns an exception to be thrown when attempting to assign a non-array value to a select
     * in `multiselect` mode. Note that `undefined` and `null` are still valid values to allow for
     * resetting the value.
     * \@docs-private
     * @return {?}
     */
    function getNxDropdownNonArrayValueError() {
        return Error('Value must be an array in multiselect mode.');
    }
    /**
     * Returns an exception to be thrown when assigning a non-function value to the comparator
     * used to determine if a value corresponds to an option. Note that whether the function
     * actually takes two values and returns a boolean is not checked.
     * @return {?}
     */
    function getNxDropdownNonFunctionValueError() {
        return Error('`compareWith` must be a function.');
    }

    /**
     * @fileoverview added by tsickle
     * Generated from: dropdown/dropdown.control.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * @abstract
     */
    var NxDropdownControl = /** @class */ (function (_super) {
        __extends(NxDropdownControl, _super);
        function NxDropdownControl() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            /**
             * Whether the dropdown should allow multi selection and additional checkboxes are shown.
             *
             * Note: Please make sure the value you bind is an array. If not an error is thrown!
             */
            _this.isMultiSelect = false;
            return _this;
        }
        NxDropdownControl.propDecorators = {
            isMultiSelect: [{ type: core.Input, args: ['nxIsMultiselect',] }]
        };
        return NxDropdownControl;
    }(formfield.NxFormfieldControl));
    if (false) {
        /**
         * Whether the dropdown should allow multi selection and additional checkboxes are shown.
         *
         * Note: Please make sure the value you bind is an array. If not an error is thrown!
         * @type {?}
         */
        NxDropdownControl.prototype.isMultiSelect;
        /**
         * \@docs-private
         * @abstract
         * @param {?} value
         * @return {?}
         */
        NxDropdownControl.prototype.formatValue = function (value) { };
    }

    /**
     * @fileoverview added by tsickle
     * Generated from: dropdown/group/dropdown-group.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var NxDropdownGroupComponent = /** @class */ (function () {
        function NxDropdownGroupComponent() {
        }
        NxDropdownGroupComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'nx-dropdown-group',
                        template: "<div class=\"nx-dropdown-results__group\">\n  <div class=\"nx-dropdown-results__group-label\">{{label}}</div>\n  <ng-content></ng-content>\n</div>\n",
                        changeDetection: core.ChangeDetectionStrategy.OnPush,
                        styles: [":host{display:block}:host:first-child .nx-dropdown-results__group{background:rgba(236,236,236,.5);background:var(--dropdown-group-section-background-color,rgba(236,236,236,.5))}:host:first-child .nx-dropdown-results__group-label{padding-top:16px}.nx-dropdown-results__group-label{font-size:12px;font-size:var(--formfield-label-font-size,12px);line-height:16px;line-height:var(--formfield-label-line-height,16px);font-weight:var(--formfield-label-font-weight,600);letter-spacing:.5px;letter-spacing:var(--formfield-label-letter-spacing,.5px);font-style:italic;font-weight:700;padding:24px 32px 16px}"]
                    }] }
        ];
        NxDropdownGroupComponent.propDecorators = {
            label: [{ type: core.Input, args: ['nxLabel',] }]
        };
        return NxDropdownGroupComponent;
    }());
    if (false) {
        /**
         * Label displayed in the group.
         * @type {?}
         */
        NxDropdownGroupComponent.prototype.label;
    }

    /**
     * @fileoverview added by tsickle
     * Generated from: dropdown/item/dropdown-item.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var NxDropdownItemChange = /** @class */ (function () {
        function NxDropdownItemChange(item, isUserInput) {
            if (isUserInput === void 0) { isUserInput = false; }
            this.item = item;
            this.isUserInput = isUserInput;
        }
        return NxDropdownItemChange;
    }());
    if (false) {
        /**
         * Reference to the option that emitted the event.
         * @type {?}
         */
        NxDropdownItemChange.prototype.item;
        /**
         * Whether the change in the option's value was a result of a user action.
         * @type {?}
         */
        NxDropdownItemChange.prototype.isUserInput;
    }
    /**
     * the unique id counter
     * @type {?}
     */
    var nextId$8 = 0;
    var NxDropdownItemComponent = /** @class */ (function () {
        function NxDropdownItemComponent(_dropdown, group, _changeDetectorRef, _elementRef) {
            var _this = this;
            this._dropdown = _dropdown;
            this.group = group;
            this._changeDetectorRef = _changeDetectorRef;
            this._elementRef = _elementRef;
            this._hidden = false;
            this._mostRecentViewValue = '';
            this._id = "nx-dropdown-item-" + nextId$8++;
            this._selected = false;
            /**
             * Emits whenever the component is destroyed.
             */
            this._destroy = new rxjs.Subject();
            /**
             * Event emitted when the option is selected or deselected.
             */
            // tslint:disable-next-line:no-output-on-prefix
            this.onSelectionChange = new core.EventEmitter();
            /**
             * Emits when the state of the option changes and any parents have to be notified.
             */
            this._stateChanges = new rxjs.Subject();
            ((/** @type {?} */ (this._dropdown))).filterChanges.pipe(operators.takeUntil(this._destroy)).subscribe((/**
             * @param {?} value
             * @return {?}
             */
            function (value) {
                _this._showOrHideByFilter(value);
            }));
            // reset the hidden state when dropdown closes that on next open the user is seeing the full list again
            ((/** @type {?} */ (this._dropdown)))._closedStream.pipe(operators.takeUntil(this._destroy)).subscribe((/**
             * @return {?}
             */
            function () {
                _this._hidden = false;
            }));
        }
        Object.defineProperty(NxDropdownItemComponent.prototype, "id", {
            /** The unique ID of the option. */
            get: /**
             * The unique ID of the option.
             * @return {?}
             */
            function () { return this._id; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NxDropdownItemComponent.prototype, "selected", {
            /** Whether the item is selected. */
            get: /**
             * Whether the item is selected.
             * @return {?}
             */
            function () {
                return this._selected;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NxDropdownItemComponent.prototype, "active", {
            /** Whether the item is active. */
            get: /**
             * Whether the item is active.
             * @return {?}
             */
            function () {
                return this._active;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NxDropdownItemComponent.prototype, "multiselect", {
            /**
             * @docs-private
             * Whether the parent dropdown is in multiselect mode.
             */
            get: /**
             * \@docs-private
             * Whether the parent dropdown is in multiselect mode.
             * @return {?}
             */
            function () {
                return this._dropdown && this._dropdown.isMultiSelect;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        NxDropdownItemComponent.prototype.ngAfterViewChecked = /**
         * @return {?}
         */
        function () {
            // Since the parent dropdown component could be using the item's label to display the selected values
            // and it doesn't have a way of knowing if the item's label has changed
            // we have to check for changes in the DOM ourselves and dispatch an event. These checks are
            // relatively cheap, however we still limit them only to selected options in order to avoid
            // hitting the DOM too often.
            if (this._selected) {
                /** @type {?} */
                var viewValue = this.viewValue;
                if (viewValue !== this._mostRecentViewValue) {
                    this._mostRecentViewValue = viewValue;
                    this._stateChanges.next();
                }
            }
        };
        /**
         * @return {?}
         */
        NxDropdownItemComponent.prototype.ngOnDestroy = /**
         * @return {?}
         */
        function () {
            this._stateChanges.complete();
            this._destroy.next();
            this._destroy.complete();
        };
        /**
         * @param {?} event
         * @return {?}
         */
        NxDropdownItemComponent.prototype._onClick = /**
         * @param {?} event
         * @return {?}
         */
        function (event) {
            /* preventDefault to stop triggering the event twice when you click on the checkbox or the label inside the item */
            event.preventDefault();
            event.stopPropagation();
            this._selectViaInteraction();
        };
        /**
        * `Selects the option while indicating the selection came from the user. Used to
        * determine if the select's view -> model callback should be invoked.`
        */
        /**
         * `Selects the option while indicating the selection came from the user. Used to
         * determine if the select's view -> model callback should be invoked.`
         * @return {?}
         */
        NxDropdownItemComponent.prototype._selectViaInteraction = /**
         * `Selects the option while indicating the selection came from the user. Used to
         * determine if the select's view -> model callback should be invoked.`
         * @return {?}
         */
        function () {
            this._selected = this.multiselect ? !this._selected : true;
            this._changeDetectorRef.markForCheck();
            this._emitSelectionChangeEvent(true);
        };
        /** @docs-private */
        /**
         * \@docs-private
         * @return {?}
         */
        NxDropdownItemComponent.prototype.show = /**
         * \@docs-private
         * @return {?}
         */
        function () {
            this._hidden = false;
            this._changeDetectorRef.markForCheck();
        };
        /** @docs-private */
        /**
         * \@docs-private
         * @return {?}
         */
        NxDropdownItemComponent.prototype.hide = /**
         * \@docs-private
         * @return {?}
         */
        function () {
            this._hidden = true;
            this._changeDetectorRef.markForCheck();
        };
        /**
         * @private
         * @param {?} search
         * @return {?}
         */
        NxDropdownItemComponent.prototype._showOrHideByFilter = /**
         * @private
         * @param {?} search
         * @return {?}
         */
        function (search) {
            /** @type {?} */
            var constraint = ((/** @type {?} */ (this._dropdown))).filterFn(search, this.viewValue);
            this._hidden = constraint ? false : true;
            this._changeDetectorRef.markForCheck();
        };
        Object.defineProperty(NxDropdownItemComponent.prototype, "_formattedValue", {
            get: /**
             * @return {?}
             */
            function () {
                return ((/** @type {?} */ (this._dropdown))).valueFormatter(this.value);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NxDropdownItemComponent.prototype, "viewValue", {
            /** @docs-private */
            get: /**
             * \@docs-private
             * @return {?}
             */
            function () {
                return (this._elementRef.nativeElement.textContent || '').trim();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NxDropdownItemComponent.prototype, "elementRef", {
            /** @docs-private */
            get: /**
             * \@docs-private
             * @return {?}
             */
            function () {
                return this._elementRef;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        NxDropdownItemComponent.prototype.select = /**
         * @return {?}
         */
        function () {
            if (!this._selected) {
                this._selected = true;
                this._changeDetectorRef.markForCheck();
                this._emitSelectionChangeEvent();
            }
        };
        /** @docs-private */
        /**
         * \@docs-private
         * @return {?}
         */
        NxDropdownItemComponent.prototype.deselect = /**
         * \@docs-private
         * @return {?}
         */
        function () {
            if (this._selected) {
                this._selected = false;
                this._changeDetectorRef.markForCheck();
                this._emitSelectionChangeEvent();
            }
        };
        /** @docs-private */
        /**
         * \@docs-private
         * @return {?}
         */
        NxDropdownItemComponent.prototype.focus = /**
         * \@docs-private
         * @return {?}
         */
        function () {
            this._elementRef.nativeElement.focus();
        };
        /**
         * @private
         * @param {?=} isUserInput
         * @return {?}
         */
        NxDropdownItemComponent.prototype._emitSelectionChangeEvent = /**
         * @private
         * @param {?=} isUserInput
         * @return {?}
         */
        function (isUserInput) {
            if (isUserInput === void 0) { isUserInput = false; }
            this.onSelectionChange.emit(new NxDropdownItemChange(this, isUserInput));
        };
        /** @docs-private */
        /**
         * \@docs-private
         * @return {?}
         */
        NxDropdownItemComponent.prototype.setActiveStyles = /**
         * \@docs-private
         * @return {?}
         */
        function () {
            this._active = true;
            this._changeDetectorRef.markForCheck();
        };
        /** @docs-private */
        /**
         * \@docs-private
         * @return {?}
         */
        NxDropdownItemComponent.prototype.setInactiveStyles = /**
         * \@docs-private
         * @return {?}
         */
        function () {
            this._active = false;
            this._changeDetectorRef.markForCheck();
        };
        /**
         * Returns the list item's text label. Implemented as a part of the ListKeyManagerOption.
         * @docs-private */
        /**
         * Returns the list item's text label. Implemented as a part of the ListKeyManagerOption.
         * \@docs-private
         * @return {?}
         */
        NxDropdownItemComponent.prototype.getLabel = /**
         * Returns the list item's text label. Implemented as a part of the ListKeyManagerOption.
         * \@docs-private
         * @return {?}
         */
        function () {
            return this.viewValue;
        };
        /**
         * @param {?} element
         * @return {?}
         */
        NxDropdownItemComponent.prototype._isContentEmpty = /**
         * @param {?} element
         * @return {?}
         */
        function (element) {
            return element.children.length === 0 && !element.textContent.trim();
        };
        /**
         * @return {?}
         */
        NxDropdownItemComponent.prototype._onLabelChange = /**
         * @return {?}
         */
        function () {
            // trigger change detection when the label content changes for the case that ng-content was empty before.
            // this is also important when the label comes in deferred, e.g. by a delayed observable,
            // then first the default label derived from the value is shown
            // and after the value from the async observable is ready we need to trigger change detection that the derived label
            // gets hidden again.
            // Notice(!): the event of (cdkObserveContent) is run outside of the ngZone
            // We run detectChanges directly here as markForCheck wasn't enough to always trigger change detection correctly
            this._changeDetectorRef.detectChanges();
        };
        NxDropdownItemComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'nx-dropdown-item',
                        template: "<div #container class=\"nx-dropdown-results__option\"\n     [ngClass]=\"{'nx-dropdown-results__option--selected': selected}\">\n\n   <nx-checkbox *ngIf=\"multiselect\" [checked]=\"selected\">\n      <ng-container *ngTemplateOutlet=\"contentTemplate\"></ng-container>\n    </nx-checkbox>\n\n    <span *ngIf=\"!multiselect\" class=\"nx-dropdown-results__option-checkicon\">\n       <nx-icon name=\"check\" aria-hidden=\"true\"></nx-icon>\n    </span>\n\n    <ng-container *ngIf=\"!multiselect\">\n      <ng-container *ngTemplateOutlet=\"contentTemplate\"></ng-container>\n    </ng-container>\n</div>\n\n<ng-template #contentTemplate>\n  <div class=\"nx-dropdown-results__option-label\" >\n    <span #content (cdkObserveContent)=\"_onLabelChange()\">\n      <ng-content></ng-content>\n    </span>\n    <ng-container *ngIf=\"_isContentEmpty(content)\">\n      {{_formattedValue}}\n    </ng-container>\n  </div>\n</ng-template>\n",
                        changeDetection: core.ChangeDetectionStrategy.OnPush,
                        host: {
                            '[id]': 'id',
                            'role': 'option',
                            '[attr.aria-selected]': 'selected.toString()',
                            '[class.nx-hidden]': '_hidden',
                            '[class.nx-dropdown-item--active]': 'active',
                            '[class.nx-selected]': 'selected',
                            '[class.nx-multiselect]': 'multiselect',
                            '(click)': '_onClick($event)'
                        },
                        styles: [":host{display:block}:host(.nx-hidden){display:none}:host:first-child .nx-dropdown-results__option{padding-top:16px}:host:last-child .nx-dropdown-results__option{padding-bottom:16px}nx-checkbox{margin-bottom:0}.nx-dropdown-results__option{font-size:20px;font-size:var(--dropdown-item-font-size,20px);line-height:28px;line-height:var(--dropdown-item-line-height,28px);font-weight:400;font-weight:var(--dropdown-item-font-weight,400);letter-spacing:.2px;letter-spacing:var(--dropdown-item-letter-spacing,.2px);padding:8px 32px 8px 8px;cursor:pointer;position:relative;display:flex;max-width:100%;white-space:nowrap}.nx-dropdown-results__option-label{padding:0 12px;margin:0 -12px;color:#414141;color:var(--dropdown-item-text-color,#414141);white-space:pre-line}@media screen and (-ms-high-contrast:active){.nx-dropdown-results__option-label{-ms-high-contrast-adjust:none;color:buttonText;background-color:buttonFace;border-radius:4px}}:host(.nx-multiselect) .nx-dropdown-results__option{display:block;padding-left:32px}:host(.nx-selected):hover .nx-dropdown-results__option-checkicon,:host(.nx-selected):hover .nx-dropdown-results__option-label,:host:hover .nx-dropdown-results__option-label{color:#006192;color:var(--hover-primary,#006192)}@media screen and (-ms-high-contrast:active){:host(.nx-dropdown-item--active):not(.nx-multiselect) .nx-dropdown-results__option-label,:host:hover .nx-dropdown-results__option-label{color:highlightText;background-color:highlight}:host(.nx-dropdown-item--active):not(.nx-multiselect) .nx-dropdown-results__option-checkicon{-ms-high-contrast-adjust:none;color:highlightText;background:highlight;z-index:1}}:host(.nx-selected) .nx-dropdown-results__option-checkicon{opacity:1}:host(.nx-selected) .nx-dropdown-results__option-label{color:#414141;color:var(--dropdown-item-selected-color,#414141)}.nx-dropdown-results__option-checkicon{opacity:0;margin-right:8px;height:28px;height:var(--dropdown-item-line-height,28px);color:#414141;color:var(--dropdown-item-checkmark-color,#414141)}.nx-dropdown-results__option-checkicon nx-icon{line-height:28px;line-height:var(--dropdown-item-line-height,28px);font-size:16px}\n:host-context([data-whatinput=\"keyboard\"] .nx-dropdown__panel-body.is-stable).nx-dropdown-item--active .nx-dropdown-results__option .nx-dropdown-results__option-label {\n  border-radius: 4px;\n  box-shadow: 0 0 0 2px #ffffff, 0 0 0 6px #009DE6;\n  box-shadow: var(--focus-box-shadow, 0 0 0 2px #ffffff, 0 0 0 6px #009DE6); }\n  @media screen and (-ms-high-contrast: active) {\n    :host-context([data-whatinput=\"keyboard\"] .nx-dropdown__panel-body.is-stable).nx-dropdown-item--active .nx-dropdown-results__option .nx-dropdown-results__option-label {\n      box-shadow: 0 0 0 2px background, 0 0 0 6px windowText; } }\n\n\n:host-context([data-whatinput=\"keyboard\"] .nx-dropdown__panel-body.is-stable).nx-multiselect.nx-dropdown-item--active .nx-dropdown-results__option .nx-dropdown-results__option-label {\n  box-shadow: none; }\n  @media screen and (-ms-high-contrast: active) {\n    :host-context([data-whatinput=\"keyboard\"] .nx-dropdown__panel-body.is-stable).nx-multiselect.nx-dropdown-item--active .nx-dropdown-results__option .nx-dropdown-results__option-label {\n      box-shadow: none; } }\n\n:host-context([data-whatinput=\"keyboard\"] .nx-dropdown__panel-body.is-stable).nx-multiselect.nx-dropdown-item--active ::ng-deep .nx-checkbox__label {\n  border-radius: 4px;\n  box-shadow: 0 0 0 2px #ffffff, 0 0 0 6px #009DE6;\n  box-shadow: var(--focus-box-shadow, 0 0 0 2px #ffffff, 0 0 0 6px #009DE6); }\n  @media screen and (-ms-high-contrast: active) {\n    :host-context([data-whatinput=\"keyboard\"] .nx-dropdown__panel-body.is-stable).nx-multiselect.nx-dropdown-item--active ::ng-deep .nx-checkbox__label {\n      box-shadow: 0 0 0 2px background, 0 0 0 6px windowText; } }\n\n:host(.nx-selected.nx-dropdown-item--active) .nx-dropdown-results__option-label{padding-left:24px;margin-left:-24px}:host ::ng-deep .nx-checkbox__label{padding:0 4px;margin:0 -4px}"]
                    }] }
        ];
        /** @nocollapse */
        NxDropdownItemComponent.ctorParameters = function () { return [
            { type: NxDropdownControl, decorators: [{ type: core.Inject, args: [NxDropdownControl,] }] },
            { type: NxDropdownGroupComponent, decorators: [{ type: core.Optional }] },
            { type: core.ChangeDetectorRef },
            { type: core.ElementRef }
        ]; };
        NxDropdownItemComponent.propDecorators = {
            value: [{ type: core.Input, args: ['nxValue',] }],
            onSelectionChange: [{ type: core.Output }],
            containerElement: [{ type: core.ViewChild, args: ['container', { static: true },] }]
        };
        return NxDropdownItemComponent;
    }());
    if (false) {
        /** @type {?} */
        NxDropdownItemComponent.prototype._hidden;
        /**
         * @type {?}
         * @private
         */
        NxDropdownItemComponent.prototype._mostRecentViewValue;
        /**
         * @type {?}
         * @private
         */
        NxDropdownItemComponent.prototype._id;
        /**
         * The value of the dropdown item.
         * You can't use undefined, null and '' (empty strings)
         * as they are sentinel values signalling empty data.
         * @type {?}
         */
        NxDropdownItemComponent.prototype.value;
        /**
         * @type {?}
         * @private
         */
        NxDropdownItemComponent.prototype._selected;
        /**
         * @type {?}
         * @private
         */
        NxDropdownItemComponent.prototype._active;
        /**
         * Emits whenever the component is destroyed.
         * @type {?}
         * @private
         */
        NxDropdownItemComponent.prototype._destroy;
        /**
         * Event emitted when the option is selected or deselected.
         * @type {?}
         */
        NxDropdownItemComponent.prototype.onSelectionChange;
        /**
         * Emits when the state of the option changes and any parents have to be notified.
         * @type {?}
         */
        NxDropdownItemComponent.prototype._stateChanges;
        /**
         * \@docs-private
         * The wrapping div in the template. Used by dropdown to use the container height for scrolling.
         * @type {?}
         */
        NxDropdownItemComponent.prototype.containerElement;
        /**
         * @type {?}
         * @private
         */
        NxDropdownItemComponent.prototype._dropdown;
        /**
         * \@docs-private
         * @type {?}
         */
        NxDropdownItemComponent.prototype.group;
        /**
         * @type {?}
         * @private
         */
        NxDropdownItemComponent.prototype._changeDetectorRef;
        /**
         * @type {?}
         * @private
         */
        NxDropdownItemComponent.prototype._elementRef;
    }

    /**
     * @fileoverview added by tsickle
     * Generated from: dropdown/closed-label.directive.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    // This Directive solely purpose is to mark given ng-template and project it into the required destination.
    var NxDropdownClosedLabelDirective = /** @class */ (function () {
        function NxDropdownClosedLabelDirective(templateRef) {
            this.templateRef = templateRef;
        }
        NxDropdownClosedLabelDirective.decorators = [
            { type: core.Directive, args: [{
                        selector: '[nxClosedLabel]'
                    },] }
        ];
        /** @nocollapse */
        NxDropdownClosedLabelDirective.ctorParameters = function () { return [
            { type: core.TemplateRef }
        ]; };
        return NxDropdownClosedLabelDirective;
    }());
    if (false) {
        /** @type {?} */
        NxDropdownClosedLabelDirective.prototype.templateRef;
    }

    /**
     * @fileoverview added by tsickle
     * Generated from: dropdown/dropdown.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * Change event object that is emitted when the select value has changed.
     * @template T
     */
    var   /**
     * Change event object that is emitted when the select value has changed.
     * @template T
     */
    NxDropdownSelectChange = /** @class */ (function () {
        function NxDropdownSelectChange(source, value) {
            this.source = source;
            this.value = value;
        }
        return NxDropdownSelectChange;
    }());
    if (false) {
        /**
         * Reference to the select that emitted the change event.
         * @type {?}
         */
        NxDropdownSelectChange.prototype.source;
        /**
         * Current value of the select that emitted the event.
         * @type {?}
         */
        NxDropdownSelectChange.prototype.value;
    }
    /**
     * @return {?}
     */
    function getPositions() {
        return [{
                originX: 'start',
                originY: 'top',
                overlayX: 'start',
                overlayY: 'top'
            }, {
                originX: 'start',
                originY: 'center',
                overlayX: 'start',
                overlayY: 'center'
            }, {
                originX: 'start',
                originY: 'bottom',
                overlayX: 'start',
                overlayY: 'bottom'
            }];
    }
    var NxDropdownComponent = /** @class */ (function (_super) {
        __extends(NxDropdownComponent, _super);
        function NxDropdownComponent(_changeDetectorRef, _elementRef, _ngZone, tabIndex, formFieldComponent, ngControl, _parentForm, _parentFormGroup) {
            var _this = _super.call(this) || this;
            _this._changeDetectorRef = _changeDetectorRef;
            _this._elementRef = _elementRef;
            _this._ngZone = _ngZone;
            _this.formFieldComponent = formFieldComponent;
            _this.ngControl = ngControl;
            _this._parentForm = _parentForm;
            _this._parentFormGroup = _parentFormGroup;
            // The dropdown currently doesn't support readonly of the NxFormfieldControl so we hardcode it here
            _this.readonly = false;
            _this._disabled = false;
            _this._focused = false;
            /**
             * Whether or not the overlay panel is open.
             */
            _this._panelOpen = false;
            /**
             * \@docs-private
             */
            _this.errorState = false;
            /**
             * \@docs-private
             */
            _this.isStable = false;
            /**
             * Name of this control that is used inside the formfield component
             * \@docs-private
             */
            _this.controlType = 'nx-dropdown';
            /**
             * The minimal space between the viewport and the overlay
             */
            _this._overlayViewportMargin = 16;
            /**
             * \@docs-private
             * Emits when internal state changes to inform formfield about it.
             */
            _this.stateChanges = new rxjs.Subject();
            /**
             * The IDs of child options to be passed to the aria-owns attribute.
             */
            _this._optionIds = '';
            _this._tabIndex = 0;
            /**
             * \@docs-private
             */
            _this.currentFilter = '';
            /**
             * Label to describe the component.
             */
            _this._ariaLabel = '';
            _this._style = '';
            /**
             * Whether the dropdown should render in its negative style or not.
             */
            _this._negative = false;
            /**
             * Whether the dropdown should be shown with an additional filter input.
             */
            _this.showFilter = false;
            /**
             * Text displayed as placeholder for the filter.
             */
            _this.filterPlaceholder = '';
            /**
             * Event emitted when the select panel has been toggled.
             */
            _this.openedChange = new core.EventEmitter();
            /**
             * Event emitted when the select has been opened.
             */
            _this._openedStream = _this.openedChange.pipe(operators.filter((/**
             * @param {?} o
             * @return {?}
             */
            function (o) { return o; })), operators.map((/**
             * @return {?}
             */
            function () { })));
            /**
             * Event emitted when the select has been closed.
             */
            _this._closedStream = _this.openedChange.pipe(operators.filter((/**
             * @param {?} o
             * @return {?}
             */
            function (o) { return !o; })), operators.map((/**
             * @return {?}
             */
            function () { })));
            /**
             * Event emitted when the user types in the filter input.
             */
            _this.filterChanges = new rxjs.Subject();
            /**
             * Event that emits whenever the raw value of the select changes. This is here primarily
             * to facilitate the two-way binding for the `value` input.
             * \@docs-private
             */
            _this.valueChange = new core.EventEmitter();
            /**
             * Event emitted when the selected value has been changed.
             */
            _this.selectionChange = new core.EventEmitter();
            /**
             * \@docs-private
             */
            _this.optionSelectionChanges = rxjs.defer((/**
             * @return {?}
             */
            function () {
                if (_this.options) {
                    return rxjs.merge.apply(void 0, __spread(_this.options.map((/**
                     * @param {?} option
                     * @return {?}
                     */
                    function (option) { return option.onSelectionChange; }))));
                }
                return _this._ngZone.onStable
                    .asObservable()
                    .pipe(operators.take(1), operators.switchMap((/**
                 * @return {?}
                 */
                function () { return _this.optionSelectionChanges; })));
            }));
            /**
             * Emits whenever the component is destroyed.
             */
            _this._destroy = new rxjs.Subject();
            /**
             * Function that transforms the value into a string.
             * This function is used for displaying and filtering the content
             * ( Default: (value) => value ? value.toString() : null; ).
             */
            _this.valueFormatter = (/**
             * @param {?} value
             * @return {?}
             */
            function (value) {
                return value == null ? '' : value.toString();
            });
            /**
             * Comparison function to specify which option is displayed. Defaults to object equality.
             */
            _this._compareWith = (/**
             * @param {?} o1
             * @param {?} o2
             * @return {?}
             */
            function (o1, o2) { return o1 === o2; });
            _this._filterFn = (/**
             * @param {?} search
             * @param {?} itemValue
             * @return {?}
             */
            function (search, itemValue) {
                return itemValue.toLocaleLowerCase().indexOf(search.toLocaleLowerCase()) >= 0;
            });
            /**
             * `View -> model callback called when value changes`
             */
            _this._onChange = (/**
             * @return {?}
             */
            function () { });
            /**
             * `View -> model callback called when select has been touched`
             */
            _this._onTouched = (/**
             * @return {?}
             */
            function () { });
            if (_this.ngControl) {
                // Note: we provide the value accessor through here, instead of
                // the `providers` to avoid running into a circular import.
                _this.ngControl.valueAccessor = _this;
            }
            _this._positions = getPositions();
            _this.tabIndex = parseInt(tabIndex, 10) || 0;
            return _this;
        }
        Object.defineProperty(NxDropdownComponent.prototype, "tabIndex", {
            get: /**
             * @return {?}
             */
            function () { return this.disabled ? -1 : this._tabIndex; },
            set: /**
             * @param {?} value
             * @return {?}
             */
            function (value) {
                // If the specified tabIndex value is null or undefined, fall back to the default value.
                this._tabIndex = value != null ? value : 0;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NxDropdownComponent.prototype, "value", {
            /** Selected value */
            get: /**
             * Selected value
             * @return {?}
             */
            function () { return this._value; },
            set: /**
             * @param {?} newValue
             * @return {?}
             */
            function (newValue) {
                if (newValue !== this._value) {
                    this.writeValue(newValue);
                    this._value = newValue;
                    this._onChange(newValue);
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NxDropdownComponent.prototype, "disabled", {
            /** Whether the dropdown is disabled. */
            get: /**
             * Whether the dropdown is disabled.
             * @return {?}
             */
            function () {
                return this._disabled;
            },
            set: /**
             * @param {?} value
             * @return {?}
             */
            function (value) {
                this._disabled = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NxDropdownComponent.prototype, "styles", {
            /** If set to 'negative', the component is displayed with the negative set of styles. */
            set: /**
             * If set to 'negative', the component is displayed with the negative set of styles.
             * @param {?} value
             * @return {?}
             */
            function (value) {
                if (this._style === value) {
                    return;
                }
                this._style = value;
                this._negative = !!this._style.match(/negative/);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NxDropdownComponent.prototype, "closedDropdownLabel", {
            /** @docs-private */
            get: /**
             * \@docs-private
             * @return {?}
             */
            function () {
                return this._closedDropdownLabel;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NxDropdownComponent.prototype, "selected", {
            /**
             * @docs-private
             * The currently selected option.
             */
            get: /**
             * \@docs-private
             * The currently selected option.
             * @return {?}
             */
            function () {
                return this.isMultiSelect ? this._selectionModel.selected : this._selectionModel.selected[0];
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NxDropdownComponent.prototype, "panelOpen", {
            /** @docs-private */
            get: /**
             * \@docs-private
             * @return {?}
             */
            function () {
                return this._panelOpen;
            },
            set: /**
             * @param {?} value
             * @return {?}
             */
            function (value) {
                this._panelOpen = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NxDropdownComponent.prototype, "label", {
            /** @docs-private */
            get: /**
             * \@docs-private
             * @return {?}
             */
            function () {
                return this.formFieldComponent ? this.formFieldComponent.label : '';
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NxDropdownComponent.prototype, "compareWith", {
            /**
             * Function to compare the option values with the selected values. The first argument
             * is a value from an option. The second is a value from the selection. A boolean
             * should be returned.
             */
            get: /**
             * Function to compare the option values with the selected values. The first argument
             * is a value from an option. The second is a value from the selection. A boolean
             * should be returned.
             * @return {?}
             */
            function () { return this._compareWith; },
            set: /**
             * @param {?} fn
             * @return {?}
             */
            function (fn) {
                if (typeof fn !== 'function') {
                    throw getNxDropdownNonFunctionValueError();
                }
                this._compareWith = fn;
                if (this._selectionModel) {
                    // A different comparator means the selection could change.
                    this._initializeSelection();
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NxDropdownComponent.prototype, "filterFn", {
            /**
             * Function to be used when the user types into the search filter. The first argument is the user input,
             * the second argument is the dropdown item value. The dropdown items will use this function to set their
             * visibility state.
             * A boolean should be returned.
             */
            get: /**
             * Function to be used when the user types into the search filter. The first argument is the user input,
             * the second argument is the dropdown item value. The dropdown items will use this function to set their
             * visibility state.
             * A boolean should be returned.
             * @return {?}
             */
            function () { return this._filterFn; },
            set: /**
             * @param {?} fn
             * @return {?}
             */
            function (fn) {
                if (typeof fn !== 'function') {
                    throw getNxDropdownNonFunctionValueError();
                }
                this._filterFn = fn;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NxDropdownComponent.prototype, "focused", {
            /**
             * @docs-private
             * Whether the select is focused.
             */
            get: /**
             * \@docs-private
             * Whether the select is focused.
             * @return {?}
             */
            function () {
                return this._focused || this.panelOpen;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NxDropdownComponent.prototype, "elementRef", {
            /** @docs-private */
            get: /**
             * \@docs-private
             * @return {?}
             */
            function () {
                return this._elementRef;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        NxDropdownComponent.prototype.ngDoCheck = /**
         * @return {?}
         */
        function () {
            if (this.ngControl) {
                this.updateErrorState();
            }
        };
        /**
         * @return {?}
         */
        NxDropdownComponent.prototype.ngOnInit = /**
         * @return {?}
         */
        function () {
            this._selectionModel = new collections.SelectionModel(this.isMultiSelect);
        };
        /**
         * @return {?}
         */
        NxDropdownComponent.prototype.ngAfterContentInit = /**
         * @return {?}
         */
        function () {
            var _this = this;
            this._closedDropdownLabel =
                this._customClosedDropdownLabel && this._customClosedDropdownLabel.templateRef || this._defaultClosedDropdownLabel;
            this._initKeyManager();
            this._selectionModel.changed.pipe(operators.takeUntil(this._destroy)).subscribe((/**
             * @param {?} event
             * @return {?}
             */
            function (event) {
                event.added.forEach((/**
                 * @param {?} option
                 * @return {?}
                 */
                function (option) { return option.select(); }));
                event.removed.forEach((/**
                 * @param {?} option
                 * @return {?}
                 */
                function (option) { return option.deselect(); }));
            }));
            this.options.changes.pipe(operators.startWith(null), operators.takeUntil(this._destroy)).subscribe((/**
             * @return {?}
             */
            function () {
                _this._resetOptions();
                _this._initializeSelection();
            }));
        };
        /**
         * @return {?}
         */
        NxDropdownComponent.prototype.ngOnDestroy = /**
         * @return {?}
         */
        function () {
            this._destroy.next();
            this._destroy.complete();
        };
        /** @docs-private */
        /**
         * \@docs-private
         * @param {?} control
         * @param {?} form
         * @return {?}
         */
        NxDropdownComponent.prototype.isErrorState = /**
         * \@docs-private
         * @param {?} control
         * @param {?} form
         * @return {?}
         */
        function (control, form) {
            return !!(control && control.invalid && (control.touched || (form && form.submitted)));
        };
        /** @docs-private */
        /**
         * \@docs-private
         * @return {?}
         */
        NxDropdownComponent.prototype.updateErrorState = /**
         * \@docs-private
         * @return {?}
         */
        function () {
            /** @type {?} */
            var oldState = this.errorState;
            /** @type {?} */
            var parent = this._parentFormGroup || this._parentForm;
            /** @type {?} */
            var control = this.ngControl ? (/** @type {?} */ (this.ngControl.control)) : null;
            /** @type {?} */
            var newState = this.isErrorState(control, parent);
            if (newState !== oldState) {
                this.errorState = newState;
                this.stateChanges.next();
            }
        };
        /** Sets up a key manager to listen to keyboard events on the overlay panel. */
        /**
         * Sets up a key manager to listen to keyboard events on the overlay panel.
         * @private
         * @return {?}
         */
        NxDropdownComponent.prototype._initKeyManager = /**
         * Sets up a key manager to listen to keyboard events on the overlay panel.
         * @private
         * @return {?}
         */
        function () {
            var _this = this;
            this._keyManager = new a11y.ActiveDescendantKeyManager(this.options)
                .withTypeAhead()
                .withWrap()
                .withVerticalOrientation()
                .withHorizontalOrientation('ltr')
                .skipPredicate((/**
             * @param {?} item
             * @return {?}
             */
            function (item) { return item._hidden; }));
            this._keyManager.tabOut.pipe(operators.takeUntil(this._destroy)).subscribe((/**
             * @return {?}
             */
            function () {
                // Restore focus to the trigger before closing. Ensures that the focus
                // position won't be lost if the user got focus into the overlay.
                _this.closePanel();
            }));
            this._keyManager.change.pipe(operators.takeUntil(this._destroy)).subscribe((/**
             * @return {?}
             */
            function () {
                if (_this._panelOpen && _this.panel) {
                    // Delay the auto scrolling until all items have settled otherwise the item containers might
                    // not exist yet
                    _this._ngZone.onStable
                        .asObservable()
                        .pipe(operators.take(1)).subscribe((/**
                     * @return {?}
                     */
                    function () {
                        _this._scrollActiveOptionIntoView();
                    }));
                }
                else if (!_this._panelOpen && !_this.isMultiSelect && _this._keyManager.activeItem) {
                    _this._keyManager.activeItem._selectViaInteraction();
                }
            }));
        };
        /**
         * @private
         * @return {?}
         */
        NxDropdownComponent.prototype._resetOptions = /**
         * @private
         * @return {?}
         */
        function () {
            var _this = this;
            /** @type {?} */
            var changedOrDestroyed = rxjs.merge(this.options.changes, this._destroy);
            this.optionSelectionChanges.pipe(operators.takeUntil(changedOrDestroyed)).subscribe((/**
             * @param {?} event
             * @return {?}
             */
            function (event) {
                _this._onSelect(event.item, event.isUserInput);
                if (event.isUserInput && !_this.isMultiSelect && _this._panelOpen) {
                    _this.closePanel();
                }
            }));
            // Listen to changes in the internal state of the options and react accordingly.
            // Handles cases like the labels of the selected options changing.
            rxjs.merge.apply(void 0, __spread(this.options.map((/**
             * @param {?} option
             * @return {?}
             */
            function (option) { return option._stateChanges; })))).pipe(operators.takeUntil(changedOrDestroyed))
                .subscribe((/**
             * @return {?}
             */
            function () {
                // defer it for the next cycle to not run in changed after checked errors
                // the combination of dropdown-item notifying parent and when the parent
                // tries to fetch the triggerValue from the child throws these errors
                setTimeout((/**
                 * @return {?}
                 */
                function () {
                    _this._changeDetectorRef.markForCheck();
                    _this.stateChanges.next();
                }));
            }));
            this._setOptionIds();
        };
        /** Records option IDs to pass to the aria-owns property. */
        /**
         * Records option IDs to pass to the aria-owns property.
         * @private
         * @return {?}
         */
        NxDropdownComponent.prototype._setOptionIds = /**
         * Records option IDs to pass to the aria-owns property.
         * @private
         * @return {?}
         */
        function () {
            this._optionIds = this.options.map((/**
             * @param {?} option
             * @return {?}
             */
            function (option) { return option.id; })).join(' ');
        };
        /** Invoked when an option is clicked. */
        /**
         * Invoked when an option is clicked.
         * @private
         * @param {?} option
         * @param {?} isUserInput
         * @return {?}
         */
        NxDropdownComponent.prototype._onSelect = /**
         * Invoked when an option is clicked.
         * @private
         * @param {?} option
         * @param {?} isUserInput
         * @return {?}
         */
        function (option, isUserInput) {
            /** @type {?} */
            var wasSelected = this._selectionModel.isSelected(option);
            if (option.value == null && !this.isMultiSelect) {
                option.deselect();
                this._selectionModel.clear();
                this._propagateChanges(option.value);
            }
            else {
                option.selected ? this._selectionModel.select(option) : this._selectionModel.deselect(option);
                if (isUserInput) {
                    this._keyManager.setActiveItem(option);
                }
                if (this.isMultiSelect) {
                    this._sortValues();
                }
            }
            if (wasSelected !== this._selectionModel.isSelected(option)) {
                this._propagateChanges();
            }
            this.stateChanges.next();
        };
        /**
         * @private
         * @return {?}
         */
        NxDropdownComponent.prototype._initializeSelection = /**
         * @private
         * @return {?}
         */
        function () {
            var _this = this;
            // Defer setting the value in order to avoid the "Expression
            // has changed after it was checked" errors from Angular.
            Promise.resolve().then((/**
             * @return {?}
             */
            function () {
                _this._setSelectionByValue(_this.ngControl ? _this.ngControl.value : _this._value);
            }));
        };
        /**
         * Sets the selected option based on a value. If no option can be
         * found with the designated value, the select trigger is cleared.
         */
        /**
         * Sets the selected option based on a value. If no option can be
         * found with the designated value, the select trigger is cleared.
         * @private
         * @param {?} value
         * @return {?}
         */
        NxDropdownComponent.prototype._setSelectionByValue = /**
         * Sets the selected option based on a value. If no option can be
         * found with the designated value, the select trigger is cleared.
         * @private
         * @param {?} value
         * @return {?}
         */
        function (value) {
            var _this = this;
            if (this.isMultiSelect && value) {
                if (!Array.isArray(value)) {
                    throw getNxDropdownNonArrayValueError();
                }
                this._selectionModel.clear();
                value.forEach((/**
                 * @param {?} currentValue
                 * @return {?}
                 */
                function (currentValue) { return _this._selectValue(currentValue); }));
                this._sortValues();
            }
            else {
                this._selectionModel.clear();
                /** @type {?} */
                var correspondingOption = this._selectValue(value);
                // Shift focus to the active item. Note that we shouldn't do this in multiple
                // mode, because we don't know what option the user interacted with last.
                if (correspondingOption) {
                    this._keyManager.setActiveItem(correspondingOption);
                }
            }
            this._changeDetectorRef.markForCheck();
        };
        /**
         * Finds and selects and option based on its value.
         * @returns Option that has the corresponding value.
         */
        /**
         * Finds and selects and option based on its value.
         * @private
         * @param {?} value
         * @return {?} Option that has the corresponding value.
         */
        NxDropdownComponent.prototype._selectValue = /**
         * Finds and selects and option based on its value.
         * @private
         * @param {?} value
         * @return {?} Option that has the corresponding value.
         */
        function (value) {
            var _this = this;
            /** @type {?} */
            var correspondingOption = this.options.find((/**
             * @param {?} option
             * @return {?}
             */
            function (option) {
                try {
                    // Treat null as a special reset value.
                    return option.value != null && _this._compareWith(option.value, value);
                }
                catch (error) {
                    if (core.isDevMode()) {
                        // Notify developers of errors in their comparator.
                        console.warn(error);
                    }
                    return false;
                }
            }));
            if (correspondingOption) {
                this._selectionModel.select(correspondingOption);
            }
            return correspondingOption;
        };
        /** Emits change event to set the model value. */
        /**
         * Emits change event to set the model value.
         * @private
         * @param {?=} fallbackValue
         * @return {?}
         */
        NxDropdownComponent.prototype._propagateChanges = /**
         * Emits change event to set the model value.
         * @private
         * @param {?=} fallbackValue
         * @return {?}
         */
        function (fallbackValue) {
            /** @type {?} */
            var valueToEmit = null;
            if (this.isMultiSelect) {
                valueToEmit = ((/** @type {?} */ (this.selected))).map((/**
                 * @param {?} option
                 * @return {?}
                 */
                function (option) { return option.value; }));
            }
            else {
                valueToEmit = this.selected ? ((/** @type {?} */ (this.selected))).value : fallbackValue;
            }
            this._value = valueToEmit;
            this.valueChange.emit(valueToEmit);
            this._onChange(valueToEmit);
            this.selectionChange.emit(new NxDropdownSelectChange(this, valueToEmit));
            this._changeDetectorRef.markForCheck();
        };
        /** Sorts the selected values in the selected based on their order in the panel. */
        /**
         * Sorts the selected values in the selected based on their order in the panel.
         * @private
         * @return {?}
         */
        NxDropdownComponent.prototype._sortValues = /**
         * Sorts the selected values in the selected based on their order in the panel.
         * @private
         * @return {?}
         */
        function () {
            if (this.isMultiSelect) {
                /** @type {?} */
                var options_1 = this.options.toArray();
                this._selectionModel.sort((/**
                 * @param {?} a
                 * @param {?} b
                 * @return {?}
                 */
                function (a, b) { return options_1.indexOf(a) - options_1.indexOf(b); }));
                this.stateChanges.next();
            }
        };
        /** Adds a offset to the overlay position, so the formfield label and the dropdown panel header are vertically aligned. */
        /**
         * Adds a offset to the overlay position, so the formfield label and the dropdown panel header are vertically aligned.
         * @private
         * @return {?}
         */
        NxDropdownComponent.prototype._updatePositionOffset = /**
         * Adds a offset to the overlay position, so the formfield label and the dropdown panel header are vertically aligned.
         * @private
         * @return {?}
         */
        function () {
            /** @type {?} */
            var offset = 0;
            if (this.formFieldComponent !== null) {
                /** @type {?} */
                var formFieldRect = this.formFieldComponent.elementRef.nativeElement.getBoundingClientRect();
                /** @type {?} */
                var dropdownRect = this._elementRef.nativeElement.getBoundingClientRect();
                /** @type {?} */
                var panelHeader = this.overlayDir.overlayRef.overlayElement.querySelector('.nx-dropdown__panel-header');
                /** @type {?} */
                var panelHeaderPaddingTop = panelHeader ? parseInt(getComputedStyle(panelHeader).paddingTop, 10) : 0;
                offset = formFieldRect.top - dropdownRect.top - panelHeaderPaddingTop;
            }
            this._positions[0].offsetY = offset;
        };
        /** Focuses the select element. */
        /**
         * Focuses the select element.
         * @return {?}
         */
        NxDropdownComponent.prototype.focus = /**
         * Focuses the select element.
         * @return {?}
         */
        function () {
            this._elementRef.nativeElement.focus();
        };
        /** Opens the panel of the dropdown. */
        /**
         * Opens the panel of the dropdown.
         * @return {?}
         */
        NxDropdownComponent.prototype.openPanel = /**
         * Opens the panel of the dropdown.
         * @return {?}
         */
        function () {
            if (this.disabled || !this.options || !this.options.length || this._panelOpen) {
                return;
            }
            this._panelOpen = true;
            this._triggerRect = this.trigger.nativeElement.getBoundingClientRect();
            this._keyManager.withHorizontalOrientation(null);
            this._highlightCorrectOption();
            this._changeDetectorRef.markForCheck();
        };
        /** Closes the panel of the dropdown. */
        /**
         * Closes the panel of the dropdown.
         * @return {?}
         */
        NxDropdownComponent.prototype.closePanel = /**
         * Closes the panel of the dropdown.
         * @return {?}
         */
        function () {
            var _this = this;
            if (this._panelOpen) {
                this._panelOpen = false;
                this.isStable = false;
                this._keyManager.withHorizontalOrientation('ltr');
                this._changeDetectorRef.markForCheck();
                this._onTouched();
                this.openedChange.emit(false);
                // defer the focus if the dropdown triggers actions that detach
                // a template/view from the DOM to prevent changed after checked errors
                setTimeout((/**
                 * @return {?}
                 */
                function () { return _this.focus(); }));
            }
        };
        // calculate inital scrollTop when the dropdown opens
        // scrolls the selected item to the middle of the panel if possible
        // calculate inital scrollTop when the dropdown opens
        // scrolls the selected item to the middle of the panel if possible
        /**
         * @private
         * @return {?}
         */
        NxDropdownComponent.prototype._calculateScrollTop = 
        // calculate inital scrollTop when the dropdown opens
        // scrolls the selected item to the middle of the panel if possible
        /**
         * @private
         * @return {?}
         */
        function () {
            // reset the scrolltop to make calculation easier
            this.panelBody.nativeElement.scrollTop = 0;
            if (!this.empty) {
                /** @type {?} */
                var offset = this._getItemOffset(this._keyManager.activeItem);
                /** @type {?} */
                var panelHeight = this.panelBody.nativeElement.offsetHeight;
                /** @type {?} */
                var panelRect = this.panelBody.nativeElement.getBoundingClientRect();
                /** @type {?} */
                var middleOfPanel = panelRect.top + panelHeight / 2;
                if (offset > middleOfPanel) {
                    // because we reset the scrollTop to 0 at the top we can simply take the middleOfPanel which is our
                    // target position for the item and subtract it from the offset (which is now always relative to the viewport)
                    this.panelBody.nativeElement.scrollTop = offset - middleOfPanel;
                }
            }
        };
        /** Scrolls the active option into view. */
        /**
         * Scrolls the active option into view.
         * @private
         * @return {?}
         */
        NxDropdownComponent.prototype._scrollActiveOptionIntoView = /**
         * Scrolls the active option into view.
         * @private
         * @return {?}
         */
        function () {
            if (!this.panelOpen || !this._keyManager.activeItem) {
                return;
            }
            /** @type {?} */
            var activeItem = this._keyManager.activeItem.containerElement.nativeElement;
            /** @type {?} */
            var panel = this.panelBody.nativeElement;
            /** @type {?} */
            var panelOffset = panel.offsetTop;
            // how much the overlay is repositioned on the page
            /** @type {?} */
            var panelTopScrollPosition = panel.scrollTop;
            /** @type {?} */
            var panelHeight = panel.clientHeight;
            /** @type {?} */
            var itemTop = activeItem.offsetTop - panelOffset;
            /** @type {?} */
            var itemBottom = activeItem.offsetTop - panelOffset + activeItem.getBoundingClientRect().height;
            // item half or less visible on top
            if (itemTop < panelTopScrollPosition) {
                this.panelBody.nativeElement.scrollTop = itemTop;
                // item half or less visible on bottom
            }
            else if (itemBottom > (panelTopScrollPosition + panelHeight)) {
                this.panelBody.nativeElement.scrollTop = itemBottom - panelHeight;
            }
        };
        /** @docs-private */
        /**
         * \@docs-private
         * @private
         * @param {?} item
         * @return {?}
         */
        NxDropdownComponent.prototype._getItemOffset = /**
         * \@docs-private
         * @private
         * @param {?} item
         * @return {?}
         */
        function (item) {
            /** @type {?} */
            var itemRect = item.containerElement.nativeElement.getBoundingClientRect();
            return itemRect.top + (itemRect.height / 2); // get position of the item's center
        };
        /**
         * @docs-private
         * Formfield Implementation
         */
        /**
         * \@docs-private
         * Formfield Implementation
         * @param {?} ids
         * @return {?}
         */
        NxDropdownComponent.prototype.setDescribedByIds = /**
         * \@docs-private
         * Formfield Implementation
         * @param {?} ids
         * @return {?}
         */
        function (ids) {
            this.ariaDescribedby = ids.join(' ');
        };
        /** @docs-private */
        /**
         * \@docs-private
         * @param {?} value
         * @return {?}
         */
        NxDropdownComponent.prototype.setAriaLabel = /**
         * \@docs-private
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this._ariaLabel = value;
        };
        /**
         * @return {?}
         */
        NxDropdownComponent.prototype._getAriaLabel = /**
         * @return {?}
         */
        function () {
            return this._ariaLabel || (this.formFieldComponent ? this.formFieldComponent.label : null);
        };
        Object.defineProperty(NxDropdownComponent.prototype, "_isInOutlineField", {
            get: /**
             * @return {?}
             */
            function () {
                return this.formFieldComponent !== null
                    && this.formFieldComponent.appearance === 'outline';
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NxDropdownComponent.prototype, "empty", {
            /**
             * @docs-private
             * Whether the select has a value.
             */
            get: /**
             * \@docs-private
             * Whether the select has a value.
             * @return {?}
             */
            function () {
                return !this._selectionModel || this._selectionModel.isEmpty();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NxDropdownComponent.prototype, "hasValue", {
            /** @docs-private */
            get: /**
             * \@docs-private
             * @return {?}
             */
            function () {
                return this._selectionModel.hasValue();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NxDropdownComponent.prototype, "shouldLabelFloat", {
            /** @docs-private */
            get: /**
             * \@docs-private
             * @return {?}
             */
            function () {
                return this.focused || !this.empty;
            },
            enumerable: true,
            configurable: true
        });
        /** End Formfield */
        /** ControlValueAccessor */
        /**
         * Sets the select's value. Part of the ControlValueAccessor interface
         * required to integrate with Angular's core forms API.
         *
         * @param value New value to be written to the model.
         */
        /** End Formfield */
        /** ControlValueAccessor */
        /**
         * Sets the select's value. Part of the ControlValueAccessor interface
         * required to integrate with Angular's core forms API.
         *
         * @param {?} value New value to be written to the model.
         * @return {?}
         */
        NxDropdownComponent.prototype.writeValue = /** End Formfield */
        /** ControlValueAccessor */
        /**
         * Sets the select's value. Part of the ControlValueAccessor interface
         * required to integrate with Angular's core forms API.
         *
         * @param {?} value New value to be written to the model.
         * @return {?}
         */
        function (value) {
            if (this.options) {
                this._setSelectionByValue(value);
            }
        };
        /**
         * @param {?} fn
         * @return {?}
         */
        NxDropdownComponent.prototype.registerOnChange = /**
         * @param {?} fn
         * @return {?}
         */
        function (fn) {
            this._onChange = fn;
        };
        /**
         * @param {?} fn
         * @return {?}
         */
        NxDropdownComponent.prototype.registerOnTouched = /**
         * @param {?} fn
         * @return {?}
         */
        function (fn) {
            this._onTouched = fn;
        };
        /**
         * Disables the select. Part of the ControlValueAccessor interface required
         * to integrate with Angular's core forms API.
         *
         * @param isDisabled Sets whether the component is disabled.
         */
        /**
         * Disables the select. Part of the ControlValueAccessor interface required
         * to integrate with Angular's core forms API.
         *
         * @param {?} isDisabled Sets whether the component is disabled.
         * @return {?}
         */
        NxDropdownComponent.prototype.setDisabledState = /**
         * Disables the select. Part of the ControlValueAccessor interface required
         * to integrate with Angular's core forms API.
         *
         * @param {?} isDisabled Sets whether the component is disabled.
         * @return {?}
         */
        function (isDisabled) {
            this.disabled = isDisabled;
            this._changeDetectorRef.markForCheck();
            this.stateChanges.next();
        };
        /** End ControlValueAccessor */
        /**
         * End ControlValueAccessor
         * @param {?} event
         * @return {?}
         */
        NxDropdownComponent.prototype._handleKeydown = /**
         * End ControlValueAccessor
         * @param {?} event
         * @return {?}
         */
        function (event) {
            this.panelOpen ? this._handleOpenKeydown(event) : this._handleClosedKeydown(event);
        };
        /**
         * @private
         * @param {?} event
         * @return {?}
         */
        NxDropdownComponent.prototype._handleClosedKeydown = /**
         * @private
         * @param {?} event
         * @return {?}
         */
        function (event) {
            /** @type {?} */
            var keyCode = event.keyCode;
            /** @type {?} */
            var isArrowKey = keyCode === keycodes.DOWN_ARROW || keyCode === keycodes.UP_ARROW ||
                keyCode === keycodes.LEFT_ARROW || keyCode === keycodes.RIGHT_ARROW;
            /** @type {?} */
            var isOpenKey = keyCode === keycodes.ENTER || keyCode === keycodes.SPACE;
            // Open the select on ALT + arrow key to match the native <select>
            if (isOpenKey || ((this.isMultiSelect || event.altKey) && isArrowKey)) {
                event.preventDefault(); // prevents the page from scrolling down when pressing space
                this.openPanel();
            }
            else if (!this.isMultiSelect && !this.disabled) {
                this._keyManager.onKeydown(event);
            }
        };
        /**
         * @private
         * @param {?} event
         * @return {?}
         */
        NxDropdownComponent.prototype._handleOpenKeydown = /**
         * @private
         * @param {?} event
         * @return {?}
         */
        function (event) {
            var _this = this;
            /** @type {?} */
            var keyCode = event.keyCode;
            // if has filter all events other than the listed ones should be ignored or handled in _onFilter()
            if (!([keycodes.DOWN_ARROW, keycodes.UP_ARROW, keycodes.HOME, keycodes.END, keycodes.ENTER, keycodes.LEFT_ARROW, keycodes.RIGHT_ARROW, keycodes.SHIFT, keycodes.SPACE, keycodes.TAB].indexOf(keyCode) >= 0)
                && this.showFilter) {
                return;
            }
            /** @type {?} */
            var isArrowKey = keyCode === keycodes.DOWN_ARROW || keyCode === keycodes.UP_ARROW;
            /** @type {?} */
            var manager = this._keyManager;
            /** @type {?} */
            var allHidden = this.options.map((/**
             * @param {?} option
             * @return {?}
             */
            function (option) { return option._hidden; })).every((/**
             * @param {?} option
             * @return {?}
             */
            function (option) { return Boolean(option); }));
            if (keyCode === keycodes.HOME || keyCode === keycodes.END) {
                event.preventDefault();
                keyCode === keycodes.HOME ? manager.setFirstItemActive() : manager.setLastItemActive();
            }
            else if (isArrowKey && event.altKey) {
                // Close the select on ALT + arrow key to match the native <select>
                event.preventDefault();
                this.closePanel();
            }
            else if (keyCode === keycodes.ENTER && manager.activeItem && !allHidden) {
                event.preventDefault();
                manager.activeItem._selectViaInteraction();
            }
            else if (keyCode === keycodes.ENTER && allHidden) {
                event.preventDefault();
                this.closePanel();
            }
            else if (!this.showFilter && keyCode === keycodes.SPACE && manager.activeItem) {
                event.preventDefault();
                manager.activeItem._selectViaInteraction();
            }
            else if (keyCode === keycodes.TAB) {
                this.closePanel();
            }
            else {
                /** @type {?} */
                var previouslyFocusedIndex = manager.activeItemIndex;
                manager.onKeydown(event);
                this._ngZone.onStable
                    .asObservable()
                    .pipe(operators.take(1), operators.delay(251) // we need to defer to get the new activeItemIndex. delay > debouncing of the typeAhead
                ).subscribe((/**
                 * @return {?}
                 */
                function () {
                    _this.isStable = true;
                    _this._changeDetectorRef.detectChanges();
                }));
                if (this.isMultiSelect && isArrowKey && event.shiftKey && manager.activeItem &&
                    manager.activeItemIndex !== previouslyFocusedIndex) {
                    manager.activeItem._selectViaInteraction();
                }
            }
        };
        /** @docs-private */
        /**
         * \@docs-private
         * @param {?} value
         * @return {?}
         */
        NxDropdownComponent.prototype.formatValue = /**
         * \@docs-private
         * @param {?} value
         * @return {?}
         */
        function (value) {
            return this.valueFormatter(value);
        };
        /** Called when the user types in the filter input */
        /**
         * Called when the user types in the filter input
         * @param {?} event
         * @return {?}
         */
        NxDropdownComponent.prototype._onFilter = /**
         * Called when the user types in the filter input
         * @param {?} event
         * @return {?}
         */
        function (event) {
            event.preventDefault();
            this.currentFilter = event.target.value;
            this.filterChanges.next(event.target.value);
            /** @type {?} */
            var allHidden = this.options.map((/**
             * @param {?} option
             * @return {?}
             */
            function (option) { return option._hidden; })).every((/**
             * @param {?} option
             * @return {?}
             */
            function (option) { return Boolean(option); }));
            if (allHidden) {
                this._keyManager.setActiveItem(null);
            }
            else {
                this._keyManager.setFirstItemActive();
            }
        };
        Object.defineProperty(NxDropdownComponent.prototype, "triggerValue", {
            /**
             * @docs-private
             * The value displayed in the trigger.
             */
            get: /**
             * \@docs-private
             * The value displayed in the trigger.
             * @return {?}
             */
            function () {
                if (this.empty) {
                    return '';
                }
                if (this.isMultiSelect) {
                    /** @type {?} */
                    var selectedOptions = this._selectionModel.selected.map((/**
                     * @param {?} option
                     * @return {?}
                     */
                    function (option) { return option.viewValue; }));
                    return selectedOptions.join(', ');
                }
                return this._selectionModel.selected[0].viewValue;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * Highlights the selected item. If no option is selected, it will highlight
         * the first item instead.
         */
        /**
         * Highlights the selected item. If no option is selected, it will highlight
         * the first item instead.
         * @private
         * @return {?}
         */
        NxDropdownComponent.prototype._highlightCorrectOption = /**
         * Highlights the selected item. If no option is selected, it will highlight
         * the first item instead.
         * @private
         * @return {?}
         */
        function () {
            if (this._keyManager) {
                if (this.empty) {
                    this._keyManager.setFirstItemActive();
                }
                else {
                    this._keyManager.setActiveItem(this._selectionModel.selected[0]);
                }
            }
        };
        /**
         * Callback that is invoked when the overlay panel has been attached.
         */
        /**
         * Callback that is invoked when the overlay panel has been attached.
         * @return {?}
         */
        NxDropdownComponent.prototype._onAttached = /**
         * Callback that is invoked when the overlay panel has been attached.
         * @return {?}
         */
        function () {
            var _this = this;
            this.overlayDir.positionChange.pipe(operators.take(1)).subscribe((/**
             * @return {?}
             */
            function () {
                /** @type {?} */
                var overlayRef = _this.overlayDir.overlayRef;
                /** @type {?} */
                var positionStrategy = (/** @type {?} */ (overlayRef.getConfig()
                    .positionStrategy));
                _this._updatePositionOffset();
                positionStrategy.withPositions(_this._positions.slice());
                overlayRef.updatePosition();
                if (_this._keyManager.activeItem) {
                    _this._calculateScrollTop();
                }
                _this._changeDetectorRef.markForCheck();
                _this.openedChange.emit(true);
                // If there is no item selected, the filter takes the focus.
                if (_this.showFilter && !_this._value) {
                    _this.filterInput.nativeElement.focus();
                }
                else {
                    _this.panelBody.nativeElement.focus();
                }
            }));
        };
        /**
         * @return {?}
         */
        NxDropdownComponent.prototype._onFocus = /**
         * @return {?}
         */
        function () {
            if (!this.disabled) {
                this._focused = true;
                this.stateChanges.next();
            }
        };
        /**
         * Calls the touched callback only if the panel is closed. Otherwise, the trigger will
         * "blur" to the panel when it opens, causing a false positive.
         */
        /**
         * Calls the touched callback only if the panel is closed. Otherwise, the trigger will
         * "blur" to the panel when it opens, causing a false positive.
         * @return {?}
         */
        NxDropdownComponent.prototype._onBlur = /**
         * Calls the touched callback only if the panel is closed. Otherwise, the trigger will
         * "blur" to the panel when it opens, causing a false positive.
         * @return {?}
         */
        function () {
            this._focused = false;
            if (this.filterInput && this.showFilter) {
                this._clearFilter();
            }
            if (!this.disabled && !this.panelOpen) {
                this._onTouched();
                this._changeDetectorRef.markForCheck();
                this.stateChanges.next();
            }
        };
        Object.defineProperty(NxDropdownComponent.prototype, "isFilterEmpty", {
            /** @docs-private */
            get: /**
             * \@docs-private
             * @return {?}
             */
            function () {
                return this.currentFilter.length === 0;
            },
            enumerable: true,
            configurable: true
        });
        /** @docs-private */
        /**
         * \@docs-private
         * @return {?}
         */
        NxDropdownComponent.prototype._clearFilter = /**
         * \@docs-private
         * @return {?}
         */
        function () {
            this.filterInput.nativeElement.value = '';
            this.currentFilter = '';
            this.filterChanges.next('');
        };
        /** @docs-private determines the `aria-activedescendant` to be set on the host. */
        /**
         * \@docs-private determines the `aria-activedescendant` to be set on the host.
         * @return {?}
         */
        NxDropdownComponent.prototype._getAriaActiveDescendant = /**
         * \@docs-private determines the `aria-activedescendant` to be set on the host.
         * @return {?}
         */
        function () {
            if (this.panelOpen && this._keyManager && this._keyManager.activeItem) {
                return this._keyManager.activeItem.id;
            }
            return null;
        };
        NxDropdownComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'nx-dropdown',
                        template: "\n<!-- input and stuff-->\n<div cdkOverlayOrigin\n    #origin=\"cdkOverlayOrigin\"\n    class=\"nx-dropdown__container\"\n    #trigger>\n  <div class=\"nx-dropdown__rendered\">\n    <ng-container *ngTemplateOutlet=\"closedDropdownLabel\"></ng-container>\n  </div>\n  <div class=\"nx-dropdown__icon\">\n    <nx-icon class=\"nx-dropdown__chevron\" name=\"chevron-down\"></nx-icon>\n  </div>\n</div>\n\n<ng-template #defaultClosedDropdownLabel>\n  <span *ngIf=\"triggerValue\">{{ triggerValue }}</span>\n</ng-template>\n\n<!-- overlay -->\n<ng-template\n  cdkConnectedOverlay\n  cdkConnectedOverlayHasBackdrop\n  cdkConnectedOverlayBackdropClass=\"cdk-overlay-transparent-backdrop\"\n  [cdkConnectedOverlayOrigin]=\"origin\"\n  [cdkConnectedOverlayOpen]=\"panelOpen\"\n  [cdkConnectedOverlayPositions]=\"_positions\"\n  [cdkConnectedOverlayMinWidth]=\"_triggerRect?.width\"\n  [cdkConnectedOverlayFlexibleDimensions]=\"true\"\n  [cdkConnectedOverlayViewportMargin]=\"_overlayViewportMargin\"\n  [cdkConnectedOverlayPush]=\"true\"\n  (backdropClick)=\"closePanel()\"\n  (attach)=\"_onAttached()\"\n  (detach)=\"closePanel()\">\n\n  <div class=\"nx-dropdown__panel\"\n      [class.has-filter]=\"showFilter\"\n      [class.nx-dropdown__panel--in-outline-field]=\"_isInOutlineField\"\n      (keydown)=\"_handleKeydown($event)\"\n      #panel>\n    <div class=\"nx-dropdown__panel-header\" *ngIf=\"label\">\n      {{ label }}\n    </div>\n    <div class=\"nx-dropdown__filter\" *ngIf=\"showFilter\">\n      <input class=\"nx-dropdown__filter-input\"\n             [class.is-filled]=\"!isFilterEmpty\"\n             #filterInput\n             type=\"text\"\n             (input)=\"_onFilter($event)\"\n             [placeholder]=\"filterPlaceholder\"\n      >\n      <span class=\"nx-dropdown__filter-icon\" *ngIf=\"!isFilterEmpty\" (click)=\"_clearFilter()\">\n        <nx-icon name=\"close\"></nx-icon>\n      </span>\n    </div>\n\n    <div class=\"nx-dropdown__panel-body\"\n         tabindex=\"-1\"\n         role=\"listbox\"\n         #panelBody\n         [class.is-stable]=\"isStable\"\n         [attr.aria-activedescendant]=\"_getAriaActiveDescendant()\"\n         [attr.aria-multiselectable]=\"isMultiSelect\"\n    >\n        <ng-content></ng-content>\n      </div>\n  </div>\n</ng-template>\n",
                        changeDetection: core.ChangeDetectionStrategy.OnPush,
                        providers: [
                            { provide: NxDropdownControl, useExisting: NxDropdownComponent },
                            { provide: formfield.NxFormfieldControl, useExisting: NxDropdownComponent },
                        ],
                        host: {
                            'role': 'button',
                            '[class.nx-dropdown]': 'true',
                            '[class.is-filled]': 'hasValue',
                            '[class.has-focus]': 'focused',
                            '[class.nx-dropdown--negative]': '_negative',
                            '[class.nx-dropdown--disabled]': 'disabled',
                            '[attr.aria-describedby]': 'ariaDescribedby || null',
                            '[attr.aria-required]': 'required',
                            '[attr.aria-label]': '_getAriaLabel()',
                            'aria-haspopup': 'listbox',
                            '[attr.aria-expanded]': 'panelOpen',
                            '[attr.disabled]': 'disabled || null',
                            '[attr.tabindex]': 'tabIndex',
                            '(keydown)': '_handleKeydown($event)',
                            '(focus)': '_onFocus()',
                            '(blur)': '_onBlur()',
                            '(click)': 'openPanel()'
                        },
                        styles: [":host{display:block;width:100%}:host:focus{outline:0}:host(.nx-dropdown--negative):focus{font-weight:600}:host(.nx-dropdown--negative){color:#fff}.nx-dropdown__container{display:flex;justify-content:flex-end;align-items:center;height:100%;cursor:pointer}:host(.nx-dropdown--disabled) .nx-dropdown__container{cursor:not-allowed}.nx-dropdown__rendered{flex:1 1 auto;overflow:hidden;text-overflow:ellipsis;white-space:nowrap}.nx-dropdown__panel{box-shadow:0 2px 4px rgba(65,65,65,.5);border-radius:4px;min-width:100%}.nx-dropdown__panel ::ng-deep .nx-checkbox__label{font-size:20px;font-size:var(--dropdown-item-font-size,20px);line-height:28px;line-height:var(--dropdown-item-line-height,28px);font-weight:400;font-weight:var(--dropdown-item-font-weight,400);letter-spacing:.2px;letter-spacing:var(--dropdown-item-letter-spacing,.2px);display:flex;align-items:center}.nx-dropdown__panel:focus{outline:0}.nx-dropdown__panel--in-outline-field .nx-dropdown__panel-header{font-size:16px;font-size:var(--formfield-outline-label-font-size,16px);line-height:24px;line-height:var(--formfield-outline-label-line-height,24px);font-weight:600;font-weight:var(--formfield-outline-label-font-weight,600);letter-spacing:0;letter-spacing:var(--formfield-outline-label-letter-spacing,0)}.nx-dropdown__panel--in-outline-field .nx-dropdown__panel-body{max-height:calc(5 * (24px + 16px) + 16px);max-height:calc(5 * (var(--dropdown-item-outline-line-height,24px) + 16px) + 16px)}.nx-dropdown__panel--in-outline-field ::ng-deep .nx-dropdown-results__group-label{font-size:16px;font-size:var(--formfield-outline-label-font-size,16px);line-height:24px;line-height:var(--formfield-outline-label-line-height,24px);font-weight:var(--formfield-outline-label-font-weight,600);letter-spacing:0;letter-spacing:var(--formfield-outline-label-letter-spacing,0);font-style:normal;font-weight:700}.nx-dropdown__panel--in-outline-field ::ng-deep nx-dropdown-item .nx-dropdown-results__option,.nx-dropdown__panel--in-outline-field ::ng-deep nx-dropdown-item .nx-dropdown-results__option-label{font-size:16px;font-size:var(--dropdown-item-outline-font-size,16px);line-height:24px;line-height:var(--dropdown-item-outline-line-height,24px);font-weight:400;font-weight:var(--dropdown-item-outline-font-weight,400);letter-spacing:0;letter-spacing:var(--dropdown-item-outline-letter-spacing,0)}.nx-dropdown__panel--in-outline-field ::ng-deep nx-dropdown-item .nx-dropdown-results__option-checkicon{height:24px;height:var(--dropdown-item-outline-line-height,24px)}.nx-dropdown__panel--in-outline-field ::ng-deep .nx-dropdown__filter-input{font-size:16px;font-size:var(--formfield-outline-control-font-size,16px);line-height:24px;line-height:var(--formfield-outline-control-line-height,24px);font-weight:400;font-weight:var(--formfield-outline-control-font-weight,400);letter-spacing:0;letter-spacing:var(--formfield-outline-control-letter-spacing,0)}.nx-dropdown__panel--in-outline-field ::ng-deep .nx-dropdown__filter-input:empty{font-weight:300}.nx-dropdown__icon{font-size:24px;font-size:var(--dropdown-chevron-size,24px);line-height:0}.nx-dropdown__chevron{vertical-align:middle}.nx-dropdown__panel-header{font-size:12px;font-size:var(--formfield-label-font-size,12px);line-height:16px;line-height:var(--formfield-label-line-height,16px);font-weight:600;font-weight:var(--formfield-label-font-weight,600);letter-spacing:.5px;letter-spacing:var(--formfield-label-letter-spacing,.5px);color:#414141;color:var(--dropdown-panel-header-text-color,#414141);background-color:#ececec;background-color:var(--dropdown-panel-header-background-color,#ececec);padding:8px 32px;border-top-left-radius:4px;border-top-right-radius:4px;z-index:1}.nx-dropdown__panel-body{background-color:#fff;background-color:var(--dropdown-panel-background-color,#fff);max-height:calc(5 * (28px + 16px) + 16px);max-height:calc(5 * (var(--dropdown-item-line-height,28px) + 16px) + 16px);overflow-y:auto;outline:0}.nx-dropdown__filter{position:relative;padding:16px 32px 12px;background-color:#fff;background-color:var(--dropdown-panel-background-color,#fff)}.nx-dropdown__filter-input{font-size:20px;font-size:var(--formfield-control-font-size,20px);line-height:28px;line-height:var(--formfield-control-line-height,28px);font-weight:var(--formfield-control-font-weight,600);letter-spacing:.2px;letter-spacing:var(--formfield-control-letter-spacing,.2px);border:0;border-bottom:1px solid #767676;border-bottom:1px var(--dropdown-filter-input-border-color,#767676) solid;color:#414141;color:var(--dropdown-filter-input-text-color,#414141);width:100%;outline:0;background-color:transparent;padding:0 24px 3px 0;font-weight:300}.nx-dropdown__filter-input::-ms-clear{display:none}.nx-dropdown__panel.has-filter ::ng-deep nx-dropdown-item:first-of-type .nx-dropdown-results__option{padding-top:12px}.nx-dropdown__filter-icon{position:absolute;height:24px;right:32px;top:calc(16px + 1px);cursor:pointer}.nx-dropdown__filter-icon nx-icon{font-size:24px}.nx-dropdown__filter-input:focus{border-color:#007ab3;border-color:var(--dropdown-filter-input-active-border-color,#007ab3)}.nx-dropdown__filter-input.is-filled:focus{font-weight:600;color:#007ab3;color:var(--dropdown-filter-input-active-text-color,#007ab3);border-color:#007ab3;border-color:var(--dropdown-filter-input-active-border-color,#007ab3)}.nx-dropdown__filter-input.is-filled:focus+.nx-dropdown__filter-icon{color:#007ab3;color:var(--dropdown-filter-input-active-text-color,#007ab3)}@media screen and (-ms-high-contrast:active){.nx-dropdown__panel{box-shadow:0 0 0 1px windowText}.nx-dropdown__panel-header{border-bottom:1px solid windowText}.nx-dropdown__filter-input{border-bottom-color:buttonText}}"]
                    }] }
        ];
        /** @nocollapse */
        NxDropdownComponent.ctorParameters = function () { return [
            { type: core.ChangeDetectorRef },
            { type: core.ElementRef },
            { type: core.NgZone },
            { type: String, decorators: [{ type: core.Attribute, args: ['tabindex',] }] },
            { type: formfield.NxFormfieldComponent, decorators: [{ type: core.Optional }] },
            { type: forms.NgControl, decorators: [{ type: core.Self }, { type: core.Optional }] },
            { type: forms.NgForm, decorators: [{ type: core.Optional }] },
            { type: forms.FormGroupDirective, decorators: [{ type: core.Optional }] }
        ]; };
        NxDropdownComponent.propDecorators = {
            tabIndex: [{ type: core.Input }],
            _ariaLabel: [{ type: core.Input, args: ['nxAriaLabel',] }],
            value: [{ type: core.Input, args: ['nxValue',] }],
            disabled: [{ type: core.Input, args: ['nxDisabled',] }],
            required: [{ type: core.Input, args: ['nxRequired',] }],
            styles: [{ type: core.Input, args: ['nxStyle',] }],
            showFilter: [{ type: core.Input, args: ['nxShowFilter',] }],
            filterPlaceholder: [{ type: core.Input, args: ['nxFilterPlaceholder',] }],
            openedChange: [{ type: core.Output }],
            _openedStream: [{ type: core.Output, args: ['opened',] }],
            _closedStream: [{ type: core.Output, args: ['closed',] }],
            filterChanges: [{ type: core.Output, args: ['filterInput',] }],
            valueChange: [{ type: core.Output, args: ['nxValueChange',] }],
            selectionChange: [{ type: core.Output }],
            panel: [{ type: core.ViewChild, args: ['panel', { static: false },] }],
            panelBody: [{ type: core.ViewChild, args: ['panelBody', { static: false },] }],
            trigger: [{ type: core.ViewChild, args: ['trigger', { static: true },] }],
            filterInput: [{ type: core.ViewChild, args: ['filterInput', { static: false },] }],
            overlayDir: [{ type: core.ViewChild, args: [overlay.CdkConnectedOverlay, { static: true },] }],
            options: [{ type: core.ContentChildren, args: [NxDropdownItemComponent, { descendants: true },] }],
            groups: [{ type: core.ContentChildren, args: [NxDropdownGroupComponent,] }],
            _customClosedDropdownLabel: [{ type: core.ContentChild, args: [NxDropdownClosedLabelDirective, { static: false },] }],
            _defaultClosedDropdownLabel: [{ type: core.ViewChild, args: ['defaultClosedDropdownLabel', { static: true },] }],
            valueFormatter: [{ type: core.Input, args: ['nxValueFormatter',] }],
            compareWith: [{ type: core.Input }],
            filterFn: [{ type: core.Input }]
        };
        return NxDropdownComponent;
    }(NxDropdownControl));
    if (false) {
        /** @type {?} */
        NxDropdownComponent.prototype.readonly;
        /**
         * @type {?}
         * @private
         */
        NxDropdownComponent.prototype._selectionModel;
        /**
         * @type {?}
         * @protected
         */
        NxDropdownComponent.prototype._disabled;
        /**
         * @type {?}
         * @private
         */
        NxDropdownComponent.prototype._focused;
        /**
         * Whether or not the overlay panel is open.
         * @type {?}
         * @private
         */
        NxDropdownComponent.prototype._panelOpen;
        /**
         * \@docs-private
         * @type {?}
         */
        NxDropdownComponent.prototype.errorState;
        /**
         * \@docs-private
         * @type {?}
         */
        NxDropdownComponent.prototype.isStable;
        /**
         * Name of this control that is used inside the formfield component
         * \@docs-private
         * @type {?}
         */
        NxDropdownComponent.prototype.controlType;
        /**
         * Holds the value from nxValue.
         * @type {?}
         * @private
         */
        NxDropdownComponent.prototype._value;
        /**
         * The minimal space between the viewport and the overlay
         * @type {?}
         */
        NxDropdownComponent.prototype._overlayViewportMargin;
        /**
         * The last measured value for the trigger's client bounding rect.
         * @type {?}
         */
        NxDropdownComponent.prototype._triggerRect;
        /**
         * Holds the panelWidth after panel was attached.
         * @type {?}
         */
        NxDropdownComponent.prototype._panelWidth;
        /**
         * \@docs-private
         * Emits when internal state changes to inform formfield about it.
         * @type {?}
         */
        NxDropdownComponent.prototype.stateChanges;
        /**
         * The IDs of child options to be passed to the aria-owns attribute.
         * @type {?}
         */
        NxDropdownComponent.prototype._optionIds;
        /**
         * \@docs-private
         * @type {?}
         */
        NxDropdownComponent.prototype.ariaDescribedby;
        /**
         * @type {?}
         * @private
         */
        NxDropdownComponent.prototype._tabIndex;
        /**
         * \@docs-private
         * @type {?}
         */
        NxDropdownComponent.prototype.currentFilter;
        /**
         * Label to describe the component.
         * @type {?}
         */
        NxDropdownComponent.prototype._ariaLabel;
        /**
         * Whether the component is required. This adds an aria-required label to the component.
         * @type {?}
         */
        NxDropdownComponent.prototype.required;
        /**
         * @type {?}
         * @private
         */
        NxDropdownComponent.prototype._style;
        /**
         * Whether the dropdown should render in its negative style or not.
         * @type {?}
         */
        NxDropdownComponent.prototype._negative;
        /**
         * Whether the dropdown should be shown with an additional filter input.
         * @type {?}
         */
        NxDropdownComponent.prototype.showFilter;
        /**
         * Text displayed as placeholder for the filter.
         * @type {?}
         */
        NxDropdownComponent.prototype.filterPlaceholder;
        /**
         * Event emitted when the select panel has been toggled.
         * @type {?}
         */
        NxDropdownComponent.prototype.openedChange;
        /**
         * Event emitted when the select has been opened.
         * @type {?}
         */
        NxDropdownComponent.prototype._openedStream;
        /**
         * Event emitted when the select has been closed.
         * @type {?}
         */
        NxDropdownComponent.prototype._closedStream;
        /**
         * Event emitted when the user types in the filter input.
         * @type {?}
         */
        NxDropdownComponent.prototype.filterChanges;
        /**
         * Event that emits whenever the raw value of the select changes. This is here primarily
         * to facilitate the two-way binding for the `value` input.
         * \@docs-private
         * @type {?}
         */
        NxDropdownComponent.prototype.valueChange;
        /**
         * Event emitted when the selected value has been changed.
         * @type {?}
         */
        NxDropdownComponent.prototype.selectionChange;
        /**
         * \@docs-private
         * @type {?}
         */
        NxDropdownComponent.prototype.optionSelectionChanges;
        /**
         * This position config ensures that the top "start" corner of the overlay
         * is aligned with with the top "start" of the origin by default (overlapping
         * the trigger completely). If the panel cannot fit below the trigger, it
         * will fall back to a position above the trigger.
         * @type {?}
         */
        NxDropdownComponent.prototype._positions;
        /**
         * \@docs-private
         * Panel containing the select options.
         * @type {?}
         */
        NxDropdownComponent.prototype.panel;
        /**
         * \@docs-private
         * @type {?}
         */
        NxDropdownComponent.prototype.panelBody;
        /**
         * \@docs-private
         * @type {?}
         */
        NxDropdownComponent.prototype.trigger;
        /**
         * \@docs-private
         * @type {?}
         */
        NxDropdownComponent.prototype.filterInput;
        /**
         * \@docs-private
         * Overlay pane containing the options.
         * @type {?}
         */
        NxDropdownComponent.prototype.overlayDir;
        /**
         * \@docs-private
         * @type {?}
         */
        NxDropdownComponent.prototype.options;
        /**
         * \@docs-private
         * @type {?}
         */
        NxDropdownComponent.prototype.groups;
        /** @type {?} */
        NxDropdownComponent.prototype._customClosedDropdownLabel;
        /**
         * @type {?}
         * @private
         */
        NxDropdownComponent.prototype._defaultClosedDropdownLabel;
        /**
         * @type {?}
         * @private
         */
        NxDropdownComponent.prototype._closedDropdownLabel;
        /**
         * Emits whenever the component is destroyed.
         * @type {?}
         * @private
         */
        NxDropdownComponent.prototype._destroy;
        /**
         * @type {?}
         * @private
         */
        NxDropdownComponent.prototype._keyManager;
        /**
         * Function that transforms the value into a string.
         * This function is used for displaying and filtering the content
         * ( Default: (value) => value ? value.toString() : null; ).
         * @type {?}
         */
        NxDropdownComponent.prototype.valueFormatter;
        /**
         * Comparison function to specify which option is displayed. Defaults to object equality.
         * @type {?}
         * @private
         */
        NxDropdownComponent.prototype._compareWith;
        /**
         * @type {?}
         * @private
         */
        NxDropdownComponent.prototype._filterFn;
        /**
         * `View -> model callback called when value changes`
         * @type {?}
         */
        NxDropdownComponent.prototype._onChange;
        /**
         * `View -> model callback called when select has been touched`
         * @type {?}
         */
        NxDropdownComponent.prototype._onTouched;
        /**
         * @type {?}
         * @private
         */
        NxDropdownComponent.prototype._changeDetectorRef;
        /**
         * @type {?}
         * @private
         */
        NxDropdownComponent.prototype._elementRef;
        /**
         * @type {?}
         * @private
         */
        NxDropdownComponent.prototype._ngZone;
        /**
         * @type {?}
         * @private
         */
        NxDropdownComponent.prototype.formFieldComponent;
        /**
         * \@docs-private
         * @type {?}
         */
        NxDropdownComponent.prototype.ngControl;
        /**
         * @type {?}
         * @private
         */
        NxDropdownComponent.prototype._parentForm;
        /**
         * @type {?}
         * @private
         */
        NxDropdownComponent.prototype._parentFormGroup;
    }

    /**
     * @fileoverview added by tsickle
     * Generated from: dropdown/dropdown.module.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var NxDropdownModule = /** @class */ (function () {
        function NxDropdownModule() {
        }
        NxDropdownModule.decorators = [
            { type: core.NgModule, args: [{
                        imports: [
                            common.CommonModule,
                            formfield.NxFormfieldModule,
                            checkbox.NxCheckboxModule,
                            overlay.OverlayModule,
                            a11y.A11yModule,
                            icon.NxIconModule,
                            observers.ObserversModule
                        ],
                        declarations: [
                            NxDropdownComponent,
                            NxDropdownItemComponent,
                            NxDropdownGroupComponent,
                            NxDropdownClosedLabelDirective
                        ],
                        exports: [
                            NxDropdownComponent,
                            NxDropdownItemComponent,
                            NxDropdownGroupComponent,
                            NxDropdownClosedLabelDirective
                        ]
                    },] }
        ];
        return NxDropdownModule;
    }());

    /**
     * @fileoverview added by tsickle
     * Generated from: dropdown/public-api.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * Generated from: dropdown/index.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * Generated from: autocomplete/autocomplete-option.component.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * Option selected event
     */
    var   /**
     * Option selected event
     */
    NxAutocompleteOptionSelected = /** @class */ (function () {
        function NxAutocompleteOptionSelected(source, isUserInput) {
            if (isUserInput === void 0) { isUserInput = false; }
            this.source = source;
            this.isUserInput = isUserInput;
        }
        return NxAutocompleteOptionSelected;
    }());
    if (false) {
        /**
         * The option that is selected or deselected.
         * @type {?}
         */
        NxAutocompleteOptionSelected.prototype.source;
        /**
         * Whether the input was triggered by the user.
         * @type {?}
         */
        NxAutocompleteOptionSelected.prototype.isUserInput;
    }
    /**
     * Option IDs need to be unique across components, so this counter exists outside of
     * the component definition.
     * @type {?}
     */
    var _uniqueIdCounter = 0;
    var NxAutocompleteOptionComponent = /** @class */ (function () {
        function NxAutocompleteOptionComponent(elementRef, _changeDetectorRef) {
            this.elementRef = elementRef;
            this._changeDetectorRef = _changeDetectorRef;
            this._id = "nx-autocomplete-option-" + _uniqueIdCounter++;
            this._selected = false;
            this._active = false;
            this._disabled = false;
            /**
             * Event emitted when the option is selected or deselected.
             */
            this.onSelectionChange = new core.EventEmitter();
        }
        Object.defineProperty(NxAutocompleteOptionComponent.prototype, "id", {
            /** Id of the autocomplete option. By default it is set to an incremented value. */
            get: /**
             * Id of the autocomplete option. By default it is set to an incremented value.
             * @return {?}
             */
            function () {
                return this._id;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NxAutocompleteOptionComponent.prototype, "selected", {
            /** Whether or not the option is currently selected. */
            get: /**
             * Whether or not the option is currently selected.
             * @return {?}
             */
            function () { return this._selected; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NxAutocompleteOptionComponent.prototype, "active", {
            /**
             * Whether or not the option is currently active and ready to be selected.
             * An active option displays styles as if it is focused, but the
             * focus is actually retained somewhere else. This comes in handy
             * for components like autocomplete where focus must remain on the input.
             */
            get: /**
             * Whether or not the option is currently active and ready to be selected.
             * An active option displays styles as if it is focused, but the
             * focus is actually retained somewhere else. This comes in handy
             * for components like autocomplete where focus must remain on the input.
             * @return {?}
             */
            function () {
                return this._active;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NxAutocompleteOptionComponent.prototype, "disabled", {
            /** Whether the option is disabled. */
            get: /**
             * Whether the option is disabled.
             * @return {?}
             */
            function () { return this._disabled; },
            set: /**
             * @param {?} value
             * @return {?}
             */
            function (value) {
                /** @type {?} */
                var newValue = coercion.coerceBooleanProperty(value);
                if (this._disabled !== newValue) {
                    this._disabled = newValue;
                }
            },
            enumerable: true,
            configurable: true
        });
        /** Ensures the option is selected when activated from the keyboard. */
        /**
         * Ensures the option is selected when activated from the keyboard.
         * @param {?} event
         * @return {?}
         */
        NxAutocompleteOptionComponent.prototype._handleKeydown = /**
         * Ensures the option is selected when activated from the keyboard.
         * @param {?} event
         * @return {?}
         */
        function (event) {
            if (event.keyCode === keycodes.ENTER || event.keyCode === keycodes.SPACE) {
                this._selectViaInteraction();
                // Prevent the page from scrolling down and form submits.
                event.preventDefault();
            }
        };
        /**
         * `Selects the option while indicating the selection came from the user. Used to
         * determine if the select's view -> model callback should be invoked.`
         */
        /**
         * `Selects the option while indicating the selection came from the user. Used to
         * determine if the select's view -> model callback should be invoked.`
         * @return {?}
         */
        NxAutocompleteOptionComponent.prototype._selectViaInteraction = /**
         * `Selects the option while indicating the selection came from the user. Used to
         * determine if the select's view -> model callback should be invoked.`
         * @return {?}
         */
        function () {
            if (!this.disabled) {
                this._selected = true;
                this._changeDetectorRef.markForCheck();
                this._emitSelectionChangeEvent(true);
            }
        };
        /** Returns the correct tabindex for the option depending on disabled state. */
        /**
         * Returns the correct tabindex for the option depending on disabled state.
         * @return {?}
         */
        NxAutocompleteOptionComponent.prototype._getTabIndex = /**
         * Returns the correct tabindex for the option depending on disabled state.
         * @return {?}
         */
        function () {
            return this.disabled ? '-1' : '0';
        };
        /** Emits the selection change event. */
        /**
         * Emits the selection change event.
         * @private
         * @param {?=} isUserInput
         * @return {?}
         */
        NxAutocompleteOptionComponent.prototype._emitSelectionChangeEvent = /**
         * Emits the selection change event.
         * @private
         * @param {?=} isUserInput
         * @return {?}
         */
        function (isUserInput) {
            if (isUserInput === void 0) { isUserInput = false; }
            this.onSelectionChange.emit(new NxAutocompleteOptionSelected(this, isUserInput));
        };
        Object.defineProperty(NxAutocompleteOptionComponent.prototype, "viewValue", {
            /** @docs-private */
            get: /**
             * \@docs-private
             * @return {?}
             */
            function () {
                return (this.elementRef.nativeElement.textContent || '').trim();
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @docs-private
         * This method sets display styles on the option to make it appear
         * active. This is used by the ActiveDescendantKeyManager so key
         * events will display the proper options as active on arrow key events.
         */
        /**
         * \@docs-private
         * This method sets display styles on the option to make it appear
         * active. This is used by the ActiveDescendantKeyManager so key
         * events will display the proper options as active on arrow key events.
         * @return {?}
         */
        NxAutocompleteOptionComponent.prototype.setActiveStyles = /**
         * \@docs-private
         * This method sets display styles on the option to make it appear
         * active. This is used by the ActiveDescendantKeyManager so key
         * events will display the proper options as active on arrow key events.
         * @return {?}
         */
        function () {
            if (!this._active) {
                this._active = true;
                this._changeDetectorRef.markForCheck();
            }
        };
        /**
         * @docs-private
         * This method removes display styles on the option that made it appear
         * active. This is used by the ActiveDescendantKeyManager so key
         * events will display the proper options as active on arrow key events.
         */
        /**
         * \@docs-private
         * This method removes display styles on the option that made it appear
         * active. This is used by the ActiveDescendantKeyManager so key
         * events will display the proper options as active on arrow key events.
         * @return {?}
         */
        NxAutocompleteOptionComponent.prototype.setInactiveStyles = /**
         * \@docs-private
         * This method removes display styles on the option that made it appear
         * active. This is used by the ActiveDescendantKeyManager so key
         * events will display the proper options as active on arrow key events.
         * @return {?}
         */
        function () {
            if (this._active) {
                this._active = false;
                this._changeDetectorRef.markForCheck();
            }
        };
        /**
         * @docs-private
         * Gets the label to be used when determining whether the option should be focused.
         */
        /**
         * \@docs-private
         * Gets the label to be used when determining whether the option should be focused.
         * @return {?}
         */
        NxAutocompleteOptionComponent.prototype.getLabel = /**
         * \@docs-private
         * Gets the label to be used when determining whether the option should be focused.
         * @return {?}
         */
        function () {
            return this.viewValue;
        };
        /** Selects the option. */
        /**
         * Selects the option.
         * @return {?}
         */
        NxAutocompleteOptionComponent.prototype.select = /**
         * Selects the option.
         * @return {?}
         */
        function () {
            this._selected = true;
            this._changeDetectorRef.markForCheck();
            this._emitSelectionChangeEvent();
        };
        /** Deselects the option. */
        /**
         * Deselects the option.
         * @return {?}
         */
        NxAutocompleteOptionComponent.prototype.deselect = /**
         * Deselects the option.
         * @return {?}
         */
        function () {
            this._selected = false;
            this._changeDetectorRef.markForCheck();
            this._emitSelectionChangeEvent();
        };
        /**
         * @docs-private
         * Sets focus onto this option.
         */
        /**
         * \@docs-private
         * Sets focus onto this option.
         * @return {?}
         */
        NxAutocompleteOptionComponent.prototype.focus = /**
         * \@docs-private
         * Sets focus onto this option.
         * @return {?}
         */
        function () {
            /** @type {?} */
            var element = this.elementRef.nativeElement;
            if (typeof element.focus === 'function') {
                element.focus();
            }
        };
        NxAutocompleteOptionComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'nx-autocomplete-option',
                        template: "<div class=\"nx-autocomplete-option\" [class.nx-active]=\"active\">\n  <div class=\"nx-autocomplete-option__label\">\n    <ng-content></ng-content>\n  </div>\n</div>\n",
                        host: {
                            'role': 'option',
                            '[attr.tabindex]': '_getTabIndex()',
                            '[id]': 'id',
                            '[attr.aria-selected]': 'selected.toString()',
                            '[attr.aria-disabled]': 'disabled.toString()',
                            '(click)': '_selectViaInteraction()',
                            '(keydown)': '_handleKeydown($event)',
                            '[class.nx-active]': 'active',
                            '[class.nx-disabled]': 'disabled',
                            '[style.display]': '\'block\'' // needed for to be able to calculate offset height
                        },
                        changeDetection: core.ChangeDetectionStrategy.OnPush,
                        styles: [":host:focus{outline:0}:host:first-child .nx-autocomplete-option{padding-top:16px}:host:last-child .nx-autocomplete-option{padding-bottom:16px}.nx-autocomplete-option{font-size:20px;font-size:var(--dropdown-item-font-size,20px);line-height:28px;line-height:var(--dropdown-item-line-height,28px);font-weight:400;font-weight:var(--dropdown-item-font-weight,400);letter-spacing:.2px;letter-spacing:var(--dropdown-item-letter-spacing,.2px);padding:8px 32px;cursor:pointer;position:relative;display:flex;max-width:100%;white-space:nowrap}.nx-autocomplete-option.nx-active,.nx-autocomplete-option:hover{color:#007ab3}.nx-autocomplete-option__label{padding:0 12px;margin:0 -12px;color:#414141;color:var(--dropdown-item-text-color,#414141)}:host-context([data-whatinput=keyboard]) .nx-autocomplete-option.nx-active .nx-autocomplete-option__label{border-radius:4px;box-shadow:0 0 0 2px #fff,0 0 0 6px #009de6;box-shadow:var(--focus-box-shadow,0 0 0 2px #fff,0 0 0 6px #009de6)}@media screen and (-ms-high-contrast:active){.nx-autocomplete-option.nx-active .nx-autocomplete-option__label,.nx-autocomplete-option:hover .nx-autocomplete-option__label{color:highlightText;background-color:highlight;border-radius:4px}.nx-autocomplete-option__label{-ms-high-contrast-adjust:none;color:buttonText;background-color:buttonFace;border-radius:4px}:host-context([data-whatinput=keyboard]) .nx-autocomplete-option.nx-active .nx-autocomplete-option__label{box-shadow:0 0 0 2px background,0 0 0 6px windowText}}"]
                    }] }
        ];
        /** @nocollapse */
        NxAutocompleteOptionComponent.ctorParameters = function () { return [
            { type: core.ElementRef },
            { type: core.ChangeDetectorRef }
        ]; };
        NxAutocompleteOptionComponent.propDecorators = {
            disabled: [{ type: core.Input }],
            value: [{ type: core.Input }],
            onSelectionChange: [{ type: core.Output }]
        };
        return NxAutocompleteOptionComponent;
    }());
    if (false) {
        /**
         * @type {?}
         * @private
         */
        NxAutocompleteOptionComponent.prototype._id;
        /**
         * @type {?}
         * @private
         */
        NxAutocompleteOptionComponent.prototype._selected;
        /**
         * @type {?}
         * @private
         */
        NxAutocompleteOptionComponent.prototype._active;
        /**
         * @type {?}
         * @private
         */
        NxAutocompleteOptionComponent.prototype._disabled;
        /**
         * The value of the autocomplete option.
         * @type {?}
         */
        NxAutocompleteOptionComponent.prototype.value;
        /**
         * Event emitted when the option is selected or deselected.
         * @type {?}
         */
        NxAutocompleteOptionComponent.prototype.onSelectionChange;
        /**
         * \@docs-private
         * @type {?}
         */
        NxAutocompleteOptionComponent.prototype.elementRef;
        /**
         * @type {?}
         * @private
         */
        NxAutocompleteOptionComponent.prototype._changeDetectorRef;
    }

    /**
     * @fileoverview added by tsickle
     * Generated from: autocomplete/autocomplete.component.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * Autocomplete IDs need to be unique across components, so this counter exists outside of
     * the component definition.
     * @type {?}
     */
    var _uniqueAutocompleteIdCounter = 0;
    /**
     * Event object that is emitted when an autocomplete option is selected.
     */
    var   /**
     * Event object that is emitted when an autocomplete option is selected.
     */
    NxAutocompleteSelectedEvent = /** @class */ (function () {
        function NxAutocompleteSelectedEvent(source, option) {
            this.source = source;
            this.option = option;
        }
        return NxAutocompleteSelectedEvent;
    }());
    if (false) {
        /**
         * Reference to the autocomplete panel that emitted the event.
         * @type {?}
         */
        NxAutocompleteSelectedEvent.prototype.source;
        /**
         * Option that was selected.
         * @type {?}
         */
        NxAutocompleteSelectedEvent.prototype.option;
    }
    var NxAutocompleteComponent = /** @class */ (function () {
        function NxAutocompleteComponent(_changeDetectorRef, _elementRef, formFieldComponent) {
            this._changeDetectorRef = _changeDetectorRef;
            this._elementRef = _elementRef;
            this.formFieldComponent = formFieldComponent;
            /**
             * Whether the autocomplete panel should be visible, depending on option length.
             */
            this.showPanel = false;
            this._isOpen = false;
            this._items = null;
            this._hasItems = false;
            /**
             * Event that is emitted whenever an option from the list is selected.
             */
            this.optionSelected = new core.EventEmitter();
            /**
             * Event that is emitted when the autocomplete panel is opened.
             */
            this.opened = new core.EventEmitter();
            /**
             * Event that is emitted when the autocomplete panel is closed.
             */
            this.closed = new core.EventEmitter();
            this._classList = {};
            /**
             * Unique ID to be used by autocomplete trigger's "aria-owns" property.
             */
            this.id = "nx-autocomplete-" + _uniqueAutocompleteIdCounter++;
            // As autocomplete option can hold any value, we might need a converter
            // to get a string representation, which can be stored in input. Default value ? value.toString() : null.
            /**
             * Value to string converter.
             */
            this.valueFormatter = (/**
             * @param {?} value
             * @return {?}
             */
            function (value) { return value ? value.toString() : null; });
        }
        Object.defineProperty(NxAutocompleteComponent.prototype, "isOpen", {
            /** Whether the autocomplete panel is open. */
            get: /**
             * Whether the autocomplete panel is open.
             * @return {?}
             */
            function () { return this._isOpen && this.showPanel; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NxAutocompleteComponent.prototype, "items", {
            get: /**
             * @return {?}
             */
            function () {
                return this._items;
            },
            /** Items observable. If given, autocomplete takes care of the options and ng-content is discarderd */
            set: /**
             * Items observable. If given, autocomplete takes care of the options and ng-content is discarderd
             * @param {?} val
             * @return {?}
             */
            function (val) {
                var _this = this;
                this._hasItems = true;
                if (Array.isArray(val)) {
                    this._items = val;
                }
                else if (val instanceof rxjs.Observable) {
                    if (this._itemsSubscription) {
                        this._itemsSubscription.unsubscribe();
                    }
                    this._itemsSubscription = val.subscribe((/**
                     * @param {?} itms
                     * @return {?}
                     */
                    function (itms) {
                        _this._items = itms;
                        _this._changeDetectorRef.markForCheck();
                        // and check visibility in next cycle, when options are set
                        setTimeout((/**
                         * @return {?}
                         */
                        function () { return _this._setVisibility(); }));
                    }));
                }
                else if (val === null) {
                    this._items = val;
                }
                else {
                    throw new Error('Invalid argument for autocomplete items. It has to be Array<string> or Observable<Array<string>>');
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NxAutocompleteComponent.prototype, "hasItems", {
            /**
             * @docs-private
             * Is items observable set
             */
            get: /**
             * \@docs-private
             * Is items observable set
             * @return {?}
             */
            function () {
                return this._hasItems;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NxAutocompleteComponent.prototype, "options", {
            /** Autocomplete options */
            get: /**
             * Autocomplete options
             * @return {?}
             */
            function () {
                return this.hasItems ? this._vOptions : this._cOptions;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NxAutocompleteComponent.prototype, "classList", {
            /**
             * Takes classes set on the host nx-autocomplete element and applies them to the panel
             * inside the overlay container to allow for easy styling.
             */
            set: /**
             * Takes classes set on the host nx-autocomplete element and applies them to the panel
             * inside the overlay container to allow for easy styling.
             * @param {?} value
             * @return {?}
             */
            function (value) {
                var _this = this;
                if (value && value.length) {
                    value.split(' ').forEach((/**
                     * @param {?} className
                     * @return {?}
                     */
                    function (className) { return _this._classList[className.trim()] = true; }));
                    this._elementRef.nativeElement.className = '';
                }
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        NxAutocompleteComponent.prototype.ngAfterViewInit = /**
         * @return {?}
         */
        function () {
            this._keyManager = new a11y.ActiveDescendantKeyManager(this.options).withWrap();
            this._setVisibility();
        };
        /**
         * @return {?}
         */
        NxAutocompleteComponent.prototype.ngOnDestroy = /**
         * @return {?}
         */
        function () {
            if (this._itemsSubscription) {
                this._itemsSubscription.unsubscribe();
            }
        };
        /**
         * Sets the panel scrollTop. This allows us to manually scroll to display options
         * above or below the fold, as they are not actually being focused when active.
         */
        /**
         * Sets the panel scrollTop. This allows us to manually scroll to display options
         * above or below the fold, as they are not actually being focused when active.
         * @param {?} scrollTop
         * @return {?}
         */
        NxAutocompleteComponent.prototype._setScrollTop = /**
         * Sets the panel scrollTop. This allows us to manually scroll to display options
         * above or below the fold, as they are not actually being focused when active.
         * @param {?} scrollTop
         * @return {?}
         */
        function (scrollTop) {
            if (this.panel) {
                this.panel.nativeElement.scrollTop = scrollTop;
            }
        };
        /** Returns the panel's scrollTop. */
        /**
         * Returns the panel's scrollTop.
         * @return {?}
         */
        NxAutocompleteComponent.prototype._getScrollTop = /**
         * Returns the panel's scrollTop.
         * @return {?}
         */
        function () {
            return this.panel ? this.panel.nativeElement.scrollTop : 0;
        };
        /** Panel should hide itself when the option list is empty. */
        /**
         * Panel should hide itself when the option list is empty.
         * @return {?}
         */
        NxAutocompleteComponent.prototype._setVisibility = /**
         * Panel should hide itself when the option list is empty.
         * @return {?}
         */
        function () {
            this.showPanel = !!(this.options && this.options.length);
            this._classList['nx-autocomplete-visible'] = this.showPanel;
            this._classList['nx-autocomplete-hidden'] = !this.showPanel;
            this._changeDetectorRef.markForCheck();
        };
        /** Emits the `select` event. */
        /**
         * Emits the `select` event.
         * @param {?} option
         * @return {?}
         */
        NxAutocompleteComponent.prototype._emitSelectEvent = /**
         * Emits the `select` event.
         * @param {?} option
         * @return {?}
         */
        function (option) {
            /** @type {?} */
            var event = new NxAutocompleteSelectedEvent(this, option);
            this.optionSelected.emit(event);
        };
        Object.defineProperty(NxAutocompleteComponent.prototype, "_isInOutlineField", {
            get: /**
             * @return {?}
             */
            function () {
                return this.formFieldComponent !== null
                    && this.formFieldComponent.appearance === 'outline';
            },
            enumerable: true,
            configurable: true
        });
        NxAutocompleteComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'nx-autocomplete',
                        template: "<ng-template>\n  <div class=\"nx-autocomplete-panel\" role=\"listbox\" [id]=\"id\" [ngClass]=\"_classList\"\n  [class.nx-autocomplete-panel--in-outline-field]=\"_isInOutlineField\" #panel>\n    <ng-container *ngIf=\"hasItems\">\n      <nx-autocomplete-option *ngFor=\"let item of items\" [value]=\"item\">\n        {{item}}\n      </nx-autocomplete-option>\n    </ng-container>\n    <ng-container *ngIf=\"!hasItems\">\n      <ng-content></ng-content>\n    </ng-container>\n  </div>\n</ng-template>\n",
                        changeDetection: core.ChangeDetectionStrategy.OnPush,
                        exportAs: 'nxAutocomplete',
                        host: {
                            'class': 'nx-autocomplete'
                        },
                        styles: [":host ::ng-deep .c-input::-ms-clear{width:0;height:0}.nx-autocomplete-panel{background-color:#fff;box-shadow:0 2px 4px rgba(65,65,65,.5);overflow-y:auto;overflow-x:hidden;max-height:280px;width:100%;border-radius:4px}.nx-autocomplete-panel.nx-autocomplete-visible{visibility:visible}.nx-autocomplete-panel.nx-autocomplete-hidden{visibility:hidden}.nx-autocomplete-panel--in-outline-field ::ng-deep nx-autocomplete-option .nx-autocomplete-option,.nx-autocomplete-panel--in-outline-field ::ng-deep nx-autocomplete-option .nx-autocomplete-option__label{font-size:16px;font-size:var(--dropdown-item-outline-font-size,16px);line-height:24px;line-height:var(--dropdown-item-outline-line-height,24px);font-weight:400;font-weight:var(--dropdown-item-outline-font-weight,400);letter-spacing:0;letter-spacing:var(--dropdown-item-outline-letter-spacing,0)}@media screen and (-ms-high-contrast:active){.nx-autocomplete-panel{box-shadow:0 0 0 1px windowText}}"]
                    }] }
        ];
        /** @nocollapse */
        NxAutocompleteComponent.ctorParameters = function () { return [
            { type: core.ChangeDetectorRef },
            { type: core.ElementRef },
            { type: formfield.NxFormfieldComponent, decorators: [{ type: core.Optional }] }
        ]; };
        NxAutocompleteComponent.propDecorators = {
            template: [{ type: core.ViewChild, args: [core.TemplateRef, { static: false },] }],
            panel: [{ type: core.ViewChild, args: ['panel', { static: false },] }],
            items: [{ type: core.Input }],
            optionSelected: [{ type: core.Output }],
            opened: [{ type: core.Output }],
            closed: [{ type: core.Output }],
            _vOptions: [{ type: core.ViewChildren, args: [NxAutocompleteOptionComponent,] }],
            _cOptions: [{ type: core.ContentChildren, args: [NxAutocompleteOptionComponent, { descendants: true },] }],
            classList: [{ type: core.Input, args: ['class',] }],
            valueFormatter: [{ type: core.Input, args: ['nxValueFormatter',] }]
        };
        return NxAutocompleteComponent;
    }());
    if (false) {
        /**
         * Manages active item in option list based on key events.
         * @type {?}
         */
        NxAutocompleteComponent.prototype._keyManager;
        /**
         * Whether the autocomplete panel should be visible, depending on option length.
         * @type {?}
         */
        NxAutocompleteComponent.prototype.showPanel;
        /** @type {?} */
        NxAutocompleteComponent.prototype._isOpen;
        /**
         * \@docs-private
         * @type {?}
         */
        NxAutocompleteComponent.prototype.template;
        /**
         * \@docs-private
         * Element for the panel containing the autocomplete options.
         * @type {?}
         */
        NxAutocompleteComponent.prototype.panel;
        /**
         * @type {?}
         * @private
         */
        NxAutocompleteComponent.prototype._items;
        /**
         * @type {?}
         * @private
         */
        NxAutocompleteComponent.prototype._itemsSubscription;
        /**
         * @type {?}
         * @private
         */
        NxAutocompleteComponent.prototype._hasItems;
        /**
         * Event that is emitted whenever an option from the list is selected.
         * @type {?}
         */
        NxAutocompleteComponent.prototype.optionSelected;
        /**
         * Event that is emitted when the autocomplete panel is opened.
         * @type {?}
         */
        NxAutocompleteComponent.prototype.opened;
        /**
         * Event that is emitted when the autocomplete panel is closed.
         * @type {?}
         */
        NxAutocompleteComponent.prototype.closed;
        /**
         * Autocomplete options in view - ie from items
         * @type {?}
         * @private
         */
        NxAutocompleteComponent.prototype._vOptions;
        /**
         * Autocomplete options in content - ie user provided
         * @type {?}
         * @private
         */
        NxAutocompleteComponent.prototype._cOptions;
        /** @type {?} */
        NxAutocompleteComponent.prototype._classList;
        /**
         * Unique ID to be used by autocomplete trigger's "aria-owns" property.
         * @type {?}
         */
        NxAutocompleteComponent.prototype.id;
        /**
         * Value to string converter.
         * @type {?}
         */
        NxAutocompleteComponent.prototype.valueFormatter;
        /**
         * @type {?}
         * @private
         */
        NxAutocompleteComponent.prototype._changeDetectorRef;
        /**
         * @type {?}
         * @private
         */
        NxAutocompleteComponent.prototype._elementRef;
        /**
         * @type {?}
         * @private
         */
        NxAutocompleteComponent.prototype.formFieldComponent;
    }

    /**
     * @fileoverview added by tsickle
     * Generated from: autocomplete/autocomplete-trigger.directive.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * Provider that allows the autocomplete to register as a ControlValueAccessor.
     * \@docs-private
     * @type {?}
     */
    var NX_AUTOCOMPLETE_VALUE_ACCESSOR = {
        provide: forms.NG_VALUE_ACCESSOR,
        useExisting: core.forwardRef((/**
         * @return {?}
         */
        function () { return NxAutocompleteTriggerDirective; })),
        multi: true
    };
    /**
     * Creates an error to be thrown when attempting to use an autocomplete trigger without a panel.
     * @return {?}
     */
    function getNxAutocompleteMissingPanelError() {
        return Error('Attempting to open an undefined instance of `nx-autocomplete`. ' +
            'Make sure that the id passed to the `nxAutocomplete` is correct and that ' +
            'you\'re attempting to open it after the ngAfterContentInit hook.');
    }
    var NxAutocompleteTriggerDirective = /** @class */ (function () {
        function NxAutocompleteTriggerDirective(_element, _overlay, _viewContainerRef, _zone, _changeDetectorRef, _dir, _nxFormField, _nxWordField, _document, _viewportRuler) {
            var _this = this;
            this._element = _element;
            this._overlay = _overlay;
            this._viewContainerRef = _viewContainerRef;
            this._zone = _zone;
            this._changeDetectorRef = _changeDetectorRef;
            this._dir = _dir;
            this._nxFormField = _nxFormField;
            this._nxWordField = _nxWordField;
            this._document = _document;
            this._viewportRuler = _viewportRuler;
            this._componentDestroyed = false;
            /**
             * Whether or not the label state is being overridden.
             */
            this._manuallyFloatingLabel = false;
            /**
             * Subscription to viewport size changes.
             */
            this._viewportSubscription = rxjs.Subscription.EMPTY;
            /**
             * Stream of keyboard events that can close the panel.
             */
            this._closeKeyEventStream = new rxjs.Subject();
            /**
             * Value changes
             */
            this._valueChanges = new rxjs.Subject();
            this._itemsCb = null;
            this._debounce = 400;
            this._autocompleteDisabled = false;
            this._overlayAttached = false;
            /**
             * Stream of autocomplete option selections.
             */
            this.optionSelections = rxjs.defer((/**
             * @return {?}
             */
            function () {
                if (_this.autocomplete && _this.autocomplete.options) {
                    return rxjs.merge.apply(void 0, __spread(_this.autocomplete.options.map((/**
                     * @param {?} option
                     * @return {?}
                     */
                    function (option) { return option.onSelectionChange; }))));
                }
                // If there are any subscribers before `ngAfterViewInit`, the `autocomplete` will be undefined.
                // Return a stream that we'll replace with the real one once everything is in place.
                return _this._zone.onStable
                    .asObservable()
                    .pipe(operators.take(1), operators.switchMap((/**
                 * @return {?}
                 */
                function () { return _this.optionSelections; })));
            }));
            /**
             * `View -> model callback called when value changes`
             */
            this._onChange = (/**
             * @param {?} val
             * @return {?}
             */
            function (val) {
                _this._valueChanges.next(val);
            });
            /**
             * `View -> model callback called when autocomplete has been touched`
             */
            this._onTouched = (/**
             * @return {?}
             */
            function () { });
        }
        Object.defineProperty(NxAutocompleteTriggerDirective.prototype, "itemsCb", {
            get: /**
             * @return {?}
             */
            function () {
                return this._itemsCb;
            },
            /** The items callback. Called with input value, must return Observable of Array of strings */
            set: /**
             * The items callback. Called with input value, must return Observable of Array of strings
             * @param {?} val
             * @return {?}
             */
            function (val) {
                if (typeof val === 'function') {
                    this._itemsCb = val;
                }
                else {
                    throw new Error('Wrong value type for nxAutocompleteItems');
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NxAutocompleteTriggerDirective.prototype, "debounce", {
            /** Debounce in ms before items callback is triggered. Defaults to 400 */
            set: /**
             * Debounce in ms before items callback is triggered. Defaults to 400
             * @param {?} val
             * @return {?}
             */
            function (val) {
                this._debounce = coercion.coerceNumberProperty(val);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NxAutocompleteTriggerDirective.prototype, "autocompleteDisabled", {
            get: /**
             * @return {?}
             */
            function () {
                return this._autocompleteDisabled;
            },
            /** Whether autocomplete functionality is disabled. */
            set: /**
             * Whether autocomplete functionality is disabled.
             * @param {?} val
             * @return {?}
             */
            function (val) {
                this._autocompleteDisabled = val;
                this._bindAutocompleteItems();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NxAutocompleteTriggerDirective.prototype, "panelOpen", {
            /** Whether or not the autocomplete panel is open. */
            get: /**
             * Whether or not the autocomplete panel is open.
             * @return {?}
             */
            function () {
                return this._overlayAttached && this.autocomplete.showPanel;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NxAutocompleteTriggerDirective.prototype, "activeOption", {
            /** The currently active option, coerced to NxAutocompleteOptionComponent type. */
            get: /**
             * The currently active option, coerced to NxAutocompleteOptionComponent type.
             * @return {?}
             */
            function () {
                if (this.autocomplete && this.autocomplete._keyManager) {
                    return this.autocomplete._keyManager.activeItem;
                }
                return null;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NxAutocompleteTriggerDirective.prototype, "_outsideClickStream", {
            /** Stream of clicks outside of the autocomplete panel. */
            get: /**
             * Stream of clicks outside of the autocomplete panel.
             * @private
             * @return {?}
             */
            function () {
                var _this = this;
                if (!this._document) {
                    return rxjs.of(null);
                }
                return rxjs.merge(rxjs.fromEvent(this._document, 'click'), rxjs.fromEvent(this._document, 'touchend'))
                    .pipe(operators.filter((/**
                 * @param {?} event
                 * @return {?}
                 */
                function (event) {
                    /** @type {?} */
                    var clickTarget = (/** @type {?} */ (event.target));
                    /** @type {?} */
                    var formField = _this._formField ?
                        _this._formField.elementRef.nativeElement : null;
                    return _this._overlayAttached &&
                        clickTarget !== _this._element.nativeElement &&
                        (!formField || !formField.contains(clickTarget)) &&
                        (!!_this._overlayRef && !_this._overlayRef.overlayElement.contains(clickTarget));
                })));
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NxAutocompleteTriggerDirective.prototype, "_formField", {
            get: /**
             * @private
             * @return {?}
             */
            function () {
                if (this._nxFormField) {
                    return this._nxFormField;
                }
                else if (this._nxWordField) {
                    return this._nxWordField;
                }
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        NxAutocompleteTriggerDirective.prototype.ngOnDestroy = /**
         * @return {?}
         */
        function () {
            this._viewportSubscription.unsubscribe();
            this._componentDestroyed = true;
            this._destroyPanel();
            this._closeKeyEventStream.complete();
            if (this._controlValueChangesSubscription) {
                this._controlValueChangesSubscription.unsubscribe();
            }
            if (this._itemsSubscription) {
                this._itemsSubscription.unsubscribe();
            }
        };
        /**
         * @return {?}
         */
        NxAutocompleteTriggerDirective.prototype.ngOnChanges = /**
         * @return {?}
         */
        function () {
            this._bindAutocompleteItems();
        };
        /**
         * @return {?}
         */
        NxAutocompleteTriggerDirective.prototype.ngAfterViewInit = /**
         * @return {?}
         */
        function () {
            this._bindAutocompleteItems();
        };
        /**
         * Binds or rebinds the autocomplete items. Prerequisites:
         * - items callback has to be defined
         * - autocomplete panel has to be bound
         */
        /**
         * Binds or rebinds the autocomplete items. Prerequisites:
         * - items callback has to be defined
         * - autocomplete panel has to be bound
         * @private
         * @return {?}
         */
        NxAutocompleteTriggerDirective.prototype._bindAutocompleteItems = /**
         * Binds or rebinds the autocomplete items. Prerequisites:
         * - items callback has to be defined
         * - autocomplete panel has to be bound
         * @private
         * @return {?}
         */
        function () {
            var _this = this;
            if (this._controlValueChangesSubscription) {
                this._controlValueChangesSubscription.unsubscribe();
            }
            if (typeof this._itemsCb === 'function' && this.autocomplete && !this.autocompleteDisabled) {
                /** @type {?} */
                var itemsSubject_1 = new rxjs.Subject();
                this.autocomplete.items = itemsSubject_1;
                /** @type {?} */
                var valueChanges = this._formField &&
                    this._formField._control &&
                    this._formField._control.ngControl &&
                    this._formField._control.ngControl.valueChanges ?
                    this._formField._control.ngControl.valueChanges : this._valueChanges;
                this._controlValueChangesSubscription = valueChanges.pipe(operators.debounceTime(this._debounce))
                    .subscribe((/**
                 * @param {?} input
                 * @return {?}
                 */
                function (input) {
                    if (_this._itemsSubscription) {
                        _this._itemsSubscription.unsubscribe();
                    }
                    _this._itemsSubscription = _this._itemsCb(input).pipe(operators.first()).subscribe((/**
                     * @param {?} result
                     * @return {?}
                     */
                    function (result) {
                        itemsSubject_1.next(result);
                    }), (/**
                     * @param {?} err
                     * @return {?}
                     */
                    function (err) {
                        // On error reset
                        // TODO: Log error?
                        itemsSubject_1.next([]);
                    }));
                }));
            }
        };
        /** Opens the autocomplete suggestion panel. */
        /**
         * Opens the autocomplete suggestion panel.
         * @return {?}
         */
        NxAutocompleteTriggerDirective.prototype.openPanel = /**
         * Opens the autocomplete suggestion panel.
         * @return {?}
         */
        function () {
            if (!this.autocompleteDisabled) {
                this._attachOverlay();
                this._floatLabel();
            }
        };
        /** Closes the autocomplete suggestion panel. */
        /**
         * Closes the autocomplete suggestion panel.
         * @return {?}
         */
        NxAutocompleteTriggerDirective.prototype.closePanel = /**
         * Closes the autocomplete suggestion panel.
         * @return {?}
         */
        function () {
            this._resetLabel();
            if (!this._overlayAttached) {
                return;
            }
            if (this.panelOpen) {
                // Only emit if the panel was visible.
                this.autocomplete.closed.emit();
            }
            this.autocomplete._isOpen = this._overlayAttached = false;
            if (this._overlayRef && this._overlayRef.hasAttached()) {
                this._overlayRef.detach();
                this._closingActionsSubscription.unsubscribe();
            }
            // Note that in some cases this can end up being called after the component is destroyed.
            // Add a check to ensure that we don't try to run change detection on a destroyed view.
            if (!this._componentDestroyed) {
                // We need to trigger change detection manually, because
                // `fromEvent` doesn't seem to do it at the proper time.
                // This ensures that the label is reset when the
                // user clicks outside.
                this._changeDetectorRef.detectChanges();
            }
        };
        Object.defineProperty(NxAutocompleteTriggerDirective.prototype, "panelClosingActions", {
            /**
             * A stream of actions that should close the autocomplete panel, including
             * when an option is selected, on blur, and when TAB is pressed.
             */
            get: /**
             * A stream of actions that should close the autocomplete panel, including
             * when an option is selected, on blur, and when TAB is pressed.
             * @return {?}
             */
            function () {
                var _this = this;
                return rxjs.merge(this.optionSelections, this.autocomplete._keyManager.tabOut.pipe(operators.filter((/**
                 * @return {?}
                 */
                function () { return _this._overlayAttached; }))), this._closeKeyEventStream, this._outsideClickStream, this._overlayRef ?
                    this._overlayRef.detachments().pipe(operators.filter((/**
                     * @return {?}
                     */
                    function () { return _this._overlayAttached; }))) :
                    rxjs.of());
            },
            enumerable: true,
            configurable: true
        });
        // Implemented as part of ControlValueAccessor.
        // Implemented as part of ControlValueAccessor.
        /**
         * @param {?} value
         * @return {?}
         */
        NxAutocompleteTriggerDirective.prototype.writeValue = 
        // Implemented as part of ControlValueAccessor.
        /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            var _this = this;
            Promise.resolve(null).then((/**
             * @return {?}
             */
            function () { return _this._setTriggerValue(value); }));
        };
        // Implemented as part of ControlValueAccessor.
        // Implemented as part of ControlValueAccessor.
        /**
         * @param {?} fn
         * @return {?}
         */
        NxAutocompleteTriggerDirective.prototype.registerOnChange = 
        // Implemented as part of ControlValueAccessor.
        /**
         * @param {?} fn
         * @return {?}
         */
        function (fn) {
            this._onChange = fn;
        };
        // Implemented as part of ControlValueAccessor.
        // Implemented as part of ControlValueAccessor.
        /**
         * @param {?} fn
         * @return {?}
         */
        NxAutocompleteTriggerDirective.prototype.registerOnTouched = 
        // Implemented as part of ControlValueAccessor.
        /**
         * @param {?} fn
         * @return {?}
         */
        function (fn) {
            this._onTouched = fn;
        };
        // Implemented as part of ControlValueAccessor.
        // Implemented as part of ControlValueAccessor.
        /**
         * @param {?} isDisabled
         * @return {?}
         */
        NxAutocompleteTriggerDirective.prototype.setDisabledState = 
        // Implemented as part of ControlValueAccessor.
        /**
         * @param {?} isDisabled
         * @return {?}
         */
        function (isDisabled) {
            this._element.nativeElement.disabled = isDisabled;
        };
        /**
         * @param {?} event
         * @return {?}
         */
        NxAutocompleteTriggerDirective.prototype._handleKeydown = /**
         * @param {?} event
         * @return {?}
         */
        function (event) {
            /** @type {?} */
            var keyCode = event.keyCode;
            // Prevent the default action on all escape key presses. This is here primarily to bring IE
            // in line with other browsers. By default, pressing escape on IE will cause it to revert
            // the input value to the one that it had on focus, however it won't dispatch any events
            // which means that the model value will be out of sync with the view.
            if (keyCode === keycodes.ESCAPE) {
                event.preventDefault();
            }
            // Close when pressing ESCAPE or ALT + UP_ARROW, based on the a11y guidelines.
            // See: https://www.w3.org/TR/wai-aria-practices-1.1/#textbox-keyboard-interaction
            if (this.panelOpen && (keyCode === keycodes.ESCAPE || (keyCode === keycodes.UP_ARROW && event.altKey))) {
                this._resetActiveItem();
                this._closeKeyEventStream.next();
                event.stopPropagation();
            }
            else if (this.activeOption && keyCode === keycodes.ENTER && this.panelOpen) {
                this.activeOption._selectViaInteraction();
                this._resetActiveItem();
                event.preventDefault();
            }
            else {
                /** @type {?} */
                var prevActiveItem = this.autocomplete._keyManager.activeItem;
                /** @type {?} */
                var isArrowKey = keyCode === keycodes.UP_ARROW || keyCode === keycodes.DOWN_ARROW;
                if (this.panelOpen || keyCode === keycodes.TAB) {
                    this.autocomplete._keyManager.onKeydown(event);
                }
                else if (isArrowKey && this._isFieldEnabled()) {
                    this.openPanel();
                }
                if (isArrowKey || this.autocomplete._keyManager.activeItem !== prevActiveItem) {
                    this._scrollToOption();
                }
            }
        };
        /**
         * @param {?} event
         * @return {?}
         */
        NxAutocompleteTriggerDirective.prototype._handleInput = /**
         * @param {?} event
         * @return {?}
         */
        function (event) {
            /** @type {?} */
            var target = (/** @type {?} */ (event.target));
            /** @type {?} */
            var value = target.value;
            // Based on `NumberValueAccessor` from forms.
            if (target.type === 'number') {
                value = value === '' ? null : parseFloat(value);
            }
            // If the input has a placeholder, IE will fire the `input` event on page load,
            // focus and blur, in addition to when the user actually changed the value. To
            // filter out all of the extra events, we save the value on focus and between
            // `input` events, and we check whether it changed.
            // See: https://connect.microsoft.com/IE/feedback/details/885747/
            if (this._isFieldEnabled() && this._previousValue !== value &&
                document.activeElement === event.target) {
                this._previousValue = value;
                this._onChange(value);
                this.openPanel();
            }
        };
        /**
         * @return {?}
         */
        NxAutocompleteTriggerDirective.prototype._handleFocus = /**
         * @return {?}
         */
        function () {
            if (this._isFieldEnabled()) {
                this._previousValue = this._element.nativeElement.value;
                this.openPanel();
            }
        };
        /**
         * In "auto" mode, the label will animate down as soon as focus is lost.
         * This causes the value to jump when selecting an option with the mouse.
         * This method manually floats the label until the panel can be closed.
         * @param shouldAnimate Whether the label should be animated when it is floated.
         */
        /**
         * In "auto" mode, the label will animate down as soon as focus is lost.
         * This causes the value to jump when selecting an option with the mouse.
         * This method manually floats the label until the panel can be closed.
         * @private
         * @return {?}
         */
        NxAutocompleteTriggerDirective.prototype._floatLabel = /**
         * In "auto" mode, the label will animate down as soon as focus is lost.
         * This causes the value to jump when selecting an option with the mouse.
         * This method manually floats the label until the panel can be closed.
         * @private
         * @return {?}
         */
        function () {
            if (this._nxFormField && this._nxFormField.floatLabel === 'auto') {
                this._nxFormField.floatLabel = 'always';
                this._manuallyFloatingLabel = true;
            }
        };
        /** If the label has been manually elevated, return it to its normal state. */
        /**
         * If the label has been manually elevated, return it to its normal state.
         * @private
         * @return {?}
         */
        NxAutocompleteTriggerDirective.prototype._resetLabel = /**
         * If the label has been manually elevated, return it to its normal state.
         * @private
         * @return {?}
         */
        function () {
            if (this._manuallyFloatingLabel) {
                this._nxFormField.floatLabel = 'auto';
                this._manuallyFloatingLabel = false;
            }
        };
        /**
         * Given that we are not actually focusing active options, we must manually adjust scroll
         * to reveal options below the fold. First, we find the offset of the option from the top
         * of the panel. If that offset is below the fold, the new scrollTop will be the offset -
         * the panel height + the option height, so the active option will be just visible at the
         * bottom of the panel. If that offset is above the top of the visible panel, the new scrollTop
         * will become the offset. If that offset is visible within the panel already, the scrollTop is
         * not adjusted.
         */
        /**
         * Given that we are not actually focusing active options, we must manually adjust scroll
         * to reveal options below the fold. First, we find the offset of the option from the top
         * of the panel. If that offset is below the fold, the new scrollTop will be the offset -
         * the panel height + the option height, so the active option will be just visible at the
         * bottom of the panel. If that offset is above the top of the visible panel, the new scrollTop
         * will become the offset. If that offset is visible within the panel already, the scrollTop is
         * not adjusted.
         * @private
         * @return {?}
         */
        NxAutocompleteTriggerDirective.prototype._scrollToOption = /**
         * Given that we are not actually focusing active options, we must manually adjust scroll
         * to reveal options below the fold. First, we find the offset of the option from the top
         * of the panel. If that offset is below the fold, the new scrollTop will be the offset -
         * the panel height + the option height, so the active option will be just visible at the
         * bottom of the panel. If that offset is above the top of the visible panel, the new scrollTop
         * will become the offset. If that offset is visible within the panel already, the scrollTop is
         * not adjusted.
         * @private
         * @return {?}
         */
        function () {
            if (this.autocomplete.options.length === 0) {
                return;
            }
            /** @type {?} */
            var optionOffset = 0;
            /** @type {?} */
            var optionHeight = this.autocomplete.options.first.elementRef.nativeElement.offsetHeight;
            if (this.autocomplete._keyManager.activeItem) {
                optionOffset = this.autocomplete._keyManager.activeItem.elementRef.nativeElement.offsetTop;
            }
            /** @type {?} */
            var newScrollPosition = _getOptionScrollPosition(optionOffset, optionHeight, this.autocomplete._getScrollTop(), this.autocomplete.panel.nativeElement.offsetHeight);
            this.autocomplete._setScrollTop(newScrollPosition);
        };
        /**
         * This method listens to a stream of panel closing actions and resets the
         * stream every time the option list changes.
         */
        /**
         * This method listens to a stream of panel closing actions and resets the
         * stream every time the option list changes.
         * @private
         * @return {?}
         */
        NxAutocompleteTriggerDirective.prototype._subscribeToClosingActions = /**
         * This method listens to a stream of panel closing actions and resets the
         * stream every time the option list changes.
         * @private
         * @return {?}
         */
        function () {
            var _this = this;
            /** @type {?} */
            var firstStable = this._zone.onStable.asObservable().pipe(operators.take(1));
            /** @type {?} */
            var optionChanges = this.autocomplete.options.changes.pipe(operators.tap((/**
             * @return {?}
             */
            function () { return _this._positionStrategy.reapplyLastPosition(); })), 
            // Defer emitting to the stream until the next tick, because changing
            // bindings in here will cause "changed after checked" errors.
            operators.delay(0));
            // When the zone is stable initially, and when the option list changes...
            return rxjs.merge(firstStable, optionChanges)
                .pipe(
            // create a new stream of panelClosingActions, replacing any previous streams
            // that were created, and flatten it so our stream only emits closing events...
            operators.switchMap((/**
             * @return {?}
             */
            function () {
                _this._resetActiveItem();
                _this.autocomplete._setVisibility();
                return _this.panelClosingActions;
            })), 
            // when the first closing event occurs...
            operators.take(1))
                // set the value, close the panel, and complete.
                .subscribe((/**
             * @param {?} event
             * @return {?}
             */
            function (event) { return _this._setValueAndClose(event); }));
        };
        /** Destroys the autocomplete suggestion panel. */
        /**
         * Destroys the autocomplete suggestion panel.
         * @private
         * @return {?}
         */
        NxAutocompleteTriggerDirective.prototype._destroyPanel = /**
         * Destroys the autocomplete suggestion panel.
         * @private
         * @return {?}
         */
        function () {
            if (this._overlayRef) {
                this.closePanel();
                this._overlayRef.dispose();
                this._overlayRef = null;
            }
        };
        /**
         * @private
         * @param {?} value
         * @return {?}
         */
        NxAutocompleteTriggerDirective.prototype._setTriggerValue = /**
         * @private
         * @param {?} value
         * @return {?}
         */
        function (value) {
            /** @type {?} */
            var toDisplay = this.autocomplete && this.autocomplete.valueFormatter ?
                this.autocomplete.valueFormatter(value) :
                value;
            // Simply falling back to an empty string if the display value is falsy does not work properly.
            // The display value can also be the number zero and shouldn't fall back to an empty string.
            /** @type {?} */
            var inputValue = toDisplay != null ? toDisplay : '';
            // If it's used within a `NxFormField` or `NxWord`, we should set it through the property so it can go
            // through change detection.
            if (this._formField) {
                this._formField._control.value = inputValue;
            }
            else {
                this._element.nativeElement.value = inputValue;
            }
        };
        /**
         * This method closes the panel, and if a value is specified, also sets the associated
         * control to that value. It will also mark the control as dirty if this interaction
         * stemmed from the user.
         */
        /**
         * This method closes the panel, and if a value is specified, also sets the associated
         * control to that value. It will also mark the control as dirty if this interaction
         * stemmed from the user.
         * @private
         * @param {?} event
         * @return {?}
         */
        NxAutocompleteTriggerDirective.prototype._setValueAndClose = /**
         * This method closes the panel, and if a value is specified, also sets the associated
         * control to that value. It will also mark the control as dirty if this interaction
         * stemmed from the user.
         * @private
         * @param {?} event
         * @return {?}
         */
        function (event) {
            if (event && event.source) {
                this._clearPreviousSelectedOption(event.source);
                this._setTriggerValue(event.source.value);
                this._onChange(event.source.value);
                this._element.nativeElement.focus();
                this.autocomplete._emitSelectEvent(event.source);
            }
            this.closePanel();
        };
        /**
         * Clear any previous selected option and emit a selection change event for this option
         */
        /**
         * Clear any previous selected option and emit a selection change event for this option
         * @private
         * @param {?} skip
         * @return {?}
         */
        NxAutocompleteTriggerDirective.prototype._clearPreviousSelectedOption = /**
         * Clear any previous selected option and emit a selection change event for this option
         * @private
         * @param {?} skip
         * @return {?}
         */
        function (skip) {
            this.autocomplete.options.forEach((/**
             * @param {?} option
             * @return {?}
             */
            function (option) {
                if (option !== skip && option.selected) {
                    option.deselect();
                }
            }));
        };
        /**
         * @private
         * @return {?}
         */
        NxAutocompleteTriggerDirective.prototype._attachOverlay = /**
         * @private
         * @return {?}
         */
        function () {
            var _this = this;
            if (!this.autocomplete) {
                throw getNxAutocompleteMissingPanelError();
            }
            if (!this._overlayRef) {
                this._portal = new portal.TemplatePortal(this.autocomplete.template, this._viewContainerRef);
                this._overlayRef = this._overlay.create(this._getOverlayConfig());
                if (this._viewportRuler) {
                    this._viewportSubscription = this._viewportRuler.change().subscribe((/**
                     * @return {?}
                     */
                    function () {
                        if (_this.panelOpen && _this._overlayRef) {
                            _this._overlayRef.updateSize({ minWidth: _this._getHostWidth() });
                        }
                    }));
                }
            }
            else {
                /** Update the panel width, in case the host width has changed */
                this._overlayRef.updateSize({ minWidth: this._getHostWidth() });
            }
            if (this._overlayRef && !this._overlayRef.hasAttached()) {
                this._overlayRef.attach(this._portal);
                this._closingActionsSubscription = this._subscribeToClosingActions();
            }
            /** @type {?} */
            var wasOpen = this.panelOpen;
            this.autocomplete._setVisibility();
            this.autocomplete._isOpen = this._overlayAttached = true;
            // We need to do an extra `panelOpen` check in here, because the
            // autocomplete won't be shown if there are no options.
            if (this.panelOpen && wasOpen !== this.panelOpen) {
                this.autocomplete.opened.emit();
            }
        };
        /**
         * @private
         * @return {?}
         */
        NxAutocompleteTriggerDirective.prototype._getOverlayConfig = /**
         * @private
         * @return {?}
         */
        function () {
            return new overlay.OverlayConfig({
                positionStrategy: this._getOverlayPosition(),
                scrollStrategy: this._scrollStrategy(),
                minWidth: this._getHostWidth(),
                direction: this._dir ? this._dir.value : 'ltr'
            });
        };
        /**
         * @private
         * @return {?}
         */
        NxAutocompleteTriggerDirective.prototype._getOverlayPosition = /**
         * @private
         * @return {?}
         */
        function () {
            this._positionStrategy = this._overlay.position()
                .flexibleConnectedTo(this._getConnectedElement())
                .withViewportMargin(16)
                .withPush(false)
                .withPositions([
                {
                    originX: 'start',
                    originY: 'bottom',
                    overlayX: 'start',
                    overlayY: 'top'
                },
                {
                    originX: 'start',
                    originY: 'top',
                    overlayX: 'start',
                    overlayY: 'bottom',
                }
            ]);
            return this._positionStrategy;
        };
        /**
         * @private
         * @return {?}
         */
        NxAutocompleteTriggerDirective.prototype._scrollStrategy = /**
         * @private
         * @return {?}
         */
        function () {
            return this._overlay.scrollStrategies.reposition();
        };
        /**
         * @private
         * @return {?}
         */
        NxAutocompleteTriggerDirective.prototype._getConnectedElement = /**
         * @private
         * @return {?}
         */
        function () {
            return this._formField ? this._formField.getConnectedOverlayOrigin() : this._element;
        };
        /** Returns the width of the input element, so the panel min-width can match it. */
        /**
         * Returns the width of the input element, so the panel min-width can match it.
         * @private
         * @return {?}
         */
        NxAutocompleteTriggerDirective.prototype._getHostWidth = /**
         * Returns the width of the input element, so the panel min-width can match it.
         * @private
         * @return {?}
         */
        function () {
            return this._getConnectedElement().nativeElement.getBoundingClientRect().width;
        };
        /**
         * Resets the active item to -1 so arrow events will activate the
         * correct options, or to 0 if the consumer opted into it.
         */
        /**
         * Resets the active item to -1 so arrow events will activate the
         * correct options, or to 0 if the consumer opted into it.
         * @private
         * @return {?}
         */
        NxAutocompleteTriggerDirective.prototype._resetActiveItem = /**
         * Resets the active item to -1 so arrow events will activate the
         * correct options, or to 0 if the consumer opted into it.
         * @private
         * @return {?}
         */
        function () {
            this.autocomplete._keyManager.setActiveItem(-1);
        };
        /** Determines whether the panel can be opened. */
        /**
         * Determines whether the panel can be opened.
         * @private
         * @return {?}
         */
        NxAutocompleteTriggerDirective.prototype._isFieldEnabled = /**
         * Determines whether the panel can be opened.
         * @private
         * @return {?}
         */
        function () {
            /** @type {?} */
            var element = this._element.nativeElement;
            return !element.readOnly && !element.disabled;
        };
        NxAutocompleteTriggerDirective.decorators = [
            { type: core.Directive, args: [{
                        selector: "input[nxAutocomplete], textarea[nxAutocomplete]",
                        host: {
                            'role': 'combobox',
                            'autocomplete': 'off',
                            'aria-autocomplete': 'list',
                            '[attr.aria-activedescendant]': 'activeOption?.id',
                            '[attr.aria-expanded]': 'panelOpen.toString()',
                            '[attr.aria-owns]': 'autocomplete?.id',
                            // Note: we use `focusin`, as opposed to `focus`, in order to open the panel
                            // a little earlier. This avoids issues where IE delays the focusing of the input.
                            '(focusin)': '_handleFocus()',
                            '(blur)': '_onTouched()',
                            '(input)': '_handleInput($event)',
                            '(keydown)': '_handleKeydown($event)',
                        },
                        exportAs: 'nxAutocompleteTrigger',
                        providers: [NX_AUTOCOMPLETE_VALUE_ACCESSOR]
                    },] }
        ];
        /** @nocollapse */
        NxAutocompleteTriggerDirective.ctorParameters = function () { return [
            { type: core.ElementRef },
            { type: overlay.Overlay },
            { type: core.ViewContainerRef },
            { type: core.NgZone },
            { type: core.ChangeDetectorRef },
            { type: bidi.Directionality, decorators: [{ type: core.Optional }] },
            { type: formfield.NxFormfieldComponent, decorators: [{ type: core.Optional }, { type: core.Host }] },
            { type: naturalLanguageForm.NxWordComponent, decorators: [{ type: core.Optional }, { type: core.Host }] },
            { type: undefined, decorators: [{ type: core.Optional }, { type: core.Inject, args: [common.DOCUMENT,] }] },
            { type: overlay.ViewportRuler }
        ]; };
        NxAutocompleteTriggerDirective.propDecorators = {
            autocomplete: [{ type: core.Input, args: ['nxAutocomplete',] }],
            itemsCb: [{ type: core.Input, args: ['nxAutocompleteItems',] }],
            debounce: [{ type: core.Input, args: ['nxAutocompleteDebounce',] }],
            autocompleteDisabled: [{ type: core.Input, args: ['nxAutocompleteDisabled',] }]
        };
        return NxAutocompleteTriggerDirective;
    }());
    if (false) {
        /**
         * @type {?}
         * @private
         */
        NxAutocompleteTriggerDirective.prototype._overlayRef;
        /**
         * @type {?}
         * @private
         */
        NxAutocompleteTriggerDirective.prototype._portal;
        /**
         * @type {?}
         * @private
         */
        NxAutocompleteTriggerDirective.prototype._componentDestroyed;
        /**
         * Old value of the native input. Used to work around issues with the `input` event on IE.
         * @type {?}
         * @private
         */
        NxAutocompleteTriggerDirective.prototype._previousValue;
        /**
         * Strategy that is used to position the panel.
         * @type {?}
         * @private
         */
        NxAutocompleteTriggerDirective.prototype._positionStrategy;
        /**
         * Whether or not the label state is being overridden.
         * @type {?}
         * @private
         */
        NxAutocompleteTriggerDirective.prototype._manuallyFloatingLabel;
        /**
         * The subscription for closing actions (some are bound to document).
         * @type {?}
         * @private
         */
        NxAutocompleteTriggerDirective.prototype._closingActionsSubscription;
        /**
         * Subscription to viewport size changes.
         * @type {?}
         * @private
         */
        NxAutocompleteTriggerDirective.prototype._viewportSubscription;
        /**
         * Subscription to control value changes
         * @type {?}
         * @private
         */
        NxAutocompleteTriggerDirective.prototype._controlValueChangesSubscription;
        /**
         * Subscription to items observable
         * @type {?}
         * @private
         */
        NxAutocompleteTriggerDirective.prototype._itemsSubscription;
        /**
         * Stream of keyboard events that can close the panel.
         * @type {?}
         * @private
         */
        NxAutocompleteTriggerDirective.prototype._closeKeyEventStream;
        /**
         * Value changes
         * @type {?}
         * @private
         */
        NxAutocompleteTriggerDirective.prototype._valueChanges;
        /**
         * The autocomplete panel to be attached to this trigger.
         * @type {?}
         */
        NxAutocompleteTriggerDirective.prototype.autocomplete;
        /**
         * @type {?}
         * @private
         */
        NxAutocompleteTriggerDirective.prototype._itemsCb;
        /**
         * @type {?}
         * @private
         */
        NxAutocompleteTriggerDirective.prototype._debounce;
        /**
         * @type {?}
         * @private
         */
        NxAutocompleteTriggerDirective.prototype._autocompleteDisabled;
        /**
         * @type {?}
         * @private
         */
        NxAutocompleteTriggerDirective.prototype._overlayAttached;
        /**
         * Stream of autocomplete option selections.
         * @type {?}
         */
        NxAutocompleteTriggerDirective.prototype.optionSelections;
        /**
         * `View -> model callback called when value changes`
         * @type {?}
         */
        NxAutocompleteTriggerDirective.prototype._onChange;
        /**
         * `View -> model callback called when autocomplete has been touched`
         * @type {?}
         */
        NxAutocompleteTriggerDirective.prototype._onTouched;
        /**
         * @type {?}
         * @private
         */
        NxAutocompleteTriggerDirective.prototype._element;
        /**
         * @type {?}
         * @private
         */
        NxAutocompleteTriggerDirective.prototype._overlay;
        /**
         * @type {?}
         * @private
         */
        NxAutocompleteTriggerDirective.prototype._viewContainerRef;
        /**
         * @type {?}
         * @private
         */
        NxAutocompleteTriggerDirective.prototype._zone;
        /**
         * @type {?}
         * @private
         */
        NxAutocompleteTriggerDirective.prototype._changeDetectorRef;
        /**
         * @type {?}
         * @private
         */
        NxAutocompleteTriggerDirective.prototype._dir;
        /**
         * @type {?}
         * @private
         */
        NxAutocompleteTriggerDirective.prototype._nxFormField;
        /**
         * @type {?}
         * @private
         */
        NxAutocompleteTriggerDirective.prototype._nxWordField;
        /**
         * @type {?}
         * @private
         */
        NxAutocompleteTriggerDirective.prototype._document;
        /**
         * @type {?}
         * @private
         */
        NxAutocompleteTriggerDirective.prototype._viewportRuler;
    }
    /**
     * Determines the position to which to scroll a panel in order for an option to be into view.
     * \@docs-private
     * @param {?} optionOffset Option offset
     * @param {?} optionHeight Height of the options.
     * @param {?} currentScrollPosition Current scroll position of the panel.
     * @param {?} panelHeight Height of the panel.
     * @return {?}
     */
    function _getOptionScrollPosition(optionOffset, optionHeight, currentScrollPosition, panelHeight) {
        if (optionOffset < currentScrollPosition) {
            return optionOffset;
        }
        if (optionOffset + optionHeight > currentScrollPosition + panelHeight) {
            return Math.max(0, optionOffset - panelHeight + optionHeight);
        }
        return currentScrollPosition;
    }

    /**
     * @fileoverview added by tsickle
     * Generated from: autocomplete/autocomplete.module.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var NxAutocompleteModule = /** @class */ (function () {
        function NxAutocompleteModule() {
        }
        NxAutocompleteModule.decorators = [
            { type: core.NgModule, args: [{
                        declarations: [NxAutocompleteComponent, NxAutocompleteOptionComponent, NxAutocompleteTriggerDirective],
                        exports: [NxAutocompleteComponent, NxAutocompleteOptionComponent, NxAutocompleteTriggerDirective],
                        imports: [common.CommonModule, overlay.OverlayModule, a11y.A11yModule]
                    },] }
        ];
        return NxAutocompleteModule;
    }());

    /**
     * @fileoverview added by tsickle
     * Generated from: autocomplete/public-api.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * Generated from: autocomplete/index.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * Generated from: natural-language-form/word.component.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var NxWordComponent = /** @class */ (function () {
        function NxWordComponent(elementRef, _changeDetectorRef, _renderer, _overlay, _viewContainerRef, _overlayPositionBuilder) {
            this.elementRef = elementRef;
            this._changeDetectorRef = _changeDetectorRef;
            this._renderer = _renderer;
            this._overlay = _overlay;
            this._viewContainerRef = _viewContainerRef;
            this._overlayPositionBuilder = _overlayPositionBuilder;
            this.subscription = rxjs.Subscription.EMPTY;
            this.subscriptionValues = rxjs.Subscription.EMPTY;
            /**
             * \@docs-private
             */
            this.inputChanges = new rxjs.Subject();
            this._hasErrors = false;
            /**
             * \@docs-private
             */
            this.currentTextWidth = 0;
            // this will apply different min-widths to our component through our styles
            /**
             * Provide a hint for a minimal width. The actual size will be determined for inputs for each change.
             */
            this.size = 'regular';
        }
        /**
         * @return {?}
         */
        NxWordComponent.prototype.ngOnInit = /**
         * @return {?}
         */
        function () {
            this.setupErrorPopover();
        };
        /**
         * @return {?}
         */
        NxWordComponent.prototype.ngAfterContentInit = /**
         * @return {?}
         */
        function () {
            var _this = this;
            this._validateControlChild();
            this.subscription = this._control.stateChanges.pipe(operators.startWith(null)).subscribe((/**
             * @return {?}
             */
            function () {
                _this._hasErrors = _this._control.errorState;
                _this.updateErrorPopoverState();
                _this._changeDetectorRef.markForCheck();
            }));
            // if we have a ngcontrol available stick to its valueChanges subject
            if (this._control.ngControl) {
                this.subscriptionValues = this._control.ngControl.valueChanges.subscribe((/**
                 * @param {?} value
                 * @return {?}
                 */
                function (value) {
                    _this.updateCurrentTextWidth();
                    _this.inputChanges.next();
                }));
                // in any other case it is a bre input and input changes are signaled through simple state changes
            }
            else {
                this.subscriptionValues = this._control.stateChanges.subscribe((/**
                 * @param {?} value
                 * @return {?}
                 */
                function (value) {
                    _this.updateCurrentTextWidth();
                    _this.inputChanges.next();
                }));
            }
            this._control.setAriaLabel(this.label);
        };
        /**
         * @return {?}
         */
        NxWordComponent.prototype.ngOnDestroy = /**
         * @return {?}
         */
        function () {
            this.subscription.unsubscribe();
        };
        /**
          @docs-private
          Calculate the width of the full text given by the input,
          that value is bound to this component so it can grow.
      
          The involved input is known to have a width of 100% an will fit the additional space given
          which completes the auto growing behavior.
        */
        /**
         * \@docs-private
         * Calculate the width of the full text given by the input,
         * that value is bound to this component so it can grow.
         * The involved input is known to have a width of 100% an will fit the additional space given
         * which completes the auto growing behavior.
         * @return {?}
         */
        NxWordComponent.prototype.updateCurrentTextWidth = /**
         * \@docs-private
         * Calculate the width of the full text given by the input,
         * that value is bound to this component so it can grow.
         * The involved input is known to have a width of 100% an will fit the additional space given
         * which completes the auto growing behavior.
         * @return {?}
         */
        function () {
            // provide the canvas only lazy
            if (!this.measureCanvas) {
                this.measureCanvas = this._renderer.createElement('canvas');
            }
            /** @type {?} */
            var ctx = this.measureCanvas.getContext('2d');
            /** @type {?} */
            var inputRef = this._control.elementRef;
            /** @type {?} */
            var styles = window.getComputedStyle(inputRef.nativeElement);
            ctx.font = utils.getFontShorthand(styles);
            /** @type {?} */
            var metrics = ctx.measureText(this._control.value);
            // add 1px (cursor width) to prevent jumping of the text on blur.
            /** @type {?} */
            var newWidth = metrics.width + parseInt(styles.paddingRight, 10) + parseInt(styles.paddingLeft, 10) + 1;
            // This should be injected via @Host to get an exact reference to NxNaturalLanguageFormComponent
            // Works as promised as long as there is not other tag around the word. Not expected but possible.
            /** @type {?} */
            var parent = this.elementRef.nativeElement.parentElement;
            /** @type {?} */
            var parentMeasurement = parent.getBoundingClientRect();
            // Limit to own given minimal width
            this.currentTextWidth = Math.max(parseInt(styles.minWidth, 10), newWidth);
            // Limit to container width
            this.currentTextWidth = Math.min(this.currentTextWidth, parentMeasurement.width);
            if (this._overlayRef.hasAttached()) {
                this._overlayState.positionStrategy.apply();
            }
        };
        /** @docs-private */
        /**
         * \@docs-private
         * @return {?}
         */
        NxWordComponent.prototype.repositionError = /**
         * \@docs-private
         * @return {?}
         */
        function () {
            if (this._overlayRef.hasAttached()) {
                this._overlayState.positionStrategy.apply();
            }
        };
        // Fail if the required control is missing.
        // Fail if the required control is missing.
        /**
         * @protected
         * @return {?}
         */
        NxWordComponent.prototype._validateControlChild = 
        // Fail if the required control is missing.
        /**
         * @protected
         * @return {?}
         */
        function () {
            if (!this._control) {
                throw new Error('NxWordComponent requires an NxFormfieldControl compatible input.');
            }
        };
        /** @docs-private */
        /**
         * \@docs-private
         * @return {?}
         */
        NxWordComponent.prototype.getConnectedOverlayOrigin = /**
         * \@docs-private
         * @return {?}
         */
        function () {
            return this.elementRef;
        };
        Object.defineProperty(NxWordComponent.prototype, "isFocused", {
            /** @docs-private */
            get: /**
             * \@docs-private
             * @return {?}
             */
            function () {
                return this._control.focused;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NxWordComponent.prototype, "isFilled", {
            /** @docs-private */
            get: /**
             * \@docs-private
             * @return {?}
             */
            function () {
                return !this._control.empty;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NxWordComponent.prototype, "hasDropdown", {
            /** @docs-private */
            get: /**
             * \@docs-private
             * @return {?}
             */
            function () {
                return Boolean(this._dropdown);
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        NxWordComponent.prototype.updateErrorPopoverState = /**
         * @return {?}
         */
        function () {
            if (this._hasErrors && this._errorChildren.length > 0) {
                this.showPopover();
            }
            else {
                this.hidePopover();
            }
        };
        /**
         * @return {?}
         */
        NxWordComponent.prototype.setupErrorPopover = /**
         * @return {?}
         */
        function () {
            var _this = this;
            /** @type {?} */
            var positionStrategy = this._overlayPositionBuilder
                .flexibleConnectedTo(this.elementRef)
                .withLockedPosition(true)
                .withFlexibleDimensions(false)
                .withPush(true)
                .withPositions([{
                    originX: 'center',
                    originY: 'top',
                    overlayX: 'center',
                    overlayY: 'bottom'
                },
                {
                    originX: 'center',
                    originY: 'bottom',
                    overlayX: 'center',
                    overlayY: 'top'
                }])
                .withDefaultOffsetY(-8);
            this._overlayState = new overlay.OverlayConfig();
            this._overlayState.positionStrategy = positionStrategy;
            this._overlayState.scrollStrategy = this._overlay.scrollStrategies.reposition();
            this._overlayRef = this._overlay.create(this._overlayState);
            ((/** @type {?} */ (this._overlayState.positionStrategy))).positionChanges.subscribe((/**
             * @param {?} change
             * @return {?}
             */
            function (change) {
                /** @type {?} */
                var pair = change.connectionPair;
                _this.positionArrow(pair);
                // These position changes arrive too late,
                // We have to trigger the change detection manually
                // as it's detached from any render hierarchy
                // and only updated by the overlay when attached.
                if (_this._embeddedViewRef && !_this._embeddedViewRef.destroyed) {
                    _this._embeddedViewRef.detectChanges();
                }
            }));
        };
        /**
         * @private
         * @param {?} pair
         * @return {?}
         */
        NxWordComponent.prototype.positionArrow = /**
         * @private
         * @param {?} pair
         * @return {?}
         */
        function (pair) {
            /** @type {?} */
            var parentElementPositionX = this.elementRef.nativeElement.getBoundingClientRect().left;
            /** @type {?} */
            var parentElementWidth = this.elementRef.nativeElement.getBoundingClientRect().width / 2;
            /** @type {?} */
            var parentElementLeftOffset = this._overlayRef.overlayElement.parentElement.offsetLeft;
            /** @type {?} */
            var overlayElementLeftOffset = this._overlayRef.overlayElement.offsetLeft;
            // calculation for x position of the parent element. In this case, overlay left offset is the one thing to consider.
            /** @type {?} */
            var targetPosition = (parentElementPositionX + parentElementWidth) - (parentElementLeftOffset + overlayElementLeftOffset);
            if (pair.originY === 'top' && pair.overlayY === 'bottom') {
                this._popover.direction = 'top';
            }
            else {
                this._popover.direction = 'bottom';
            }
            this._popover.arrowStyle = { left: targetPosition + 'px' };
        };
        /**
         * @return {?}
         */
        NxWordComponent.prototype.showPopover = /**
         * @return {?}
         */
        function () {
            if (!this._overlayRef.hasAttached()) {
                /** @type {?} */
                var tooltipPortal = new portal.TemplatePortal(this._popover.templateRef, this._viewContainerRef);
                this._embeddedViewRef = this._overlayRef.attach(tooltipPortal);
            }
        };
        /**
         * @return {?}
         */
        NxWordComponent.prototype.hidePopover = /**
         * @return {?}
         */
        function () {
            this._overlayRef.detach();
        };
        NxWordComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'nx-word',
                        template: "<div>\n  <!-- We only allow formfield controls here -->\n  <div *ngIf=\"!hasDropdown\" class=\"nx-word__inner-wrapper\">\n    <ng-content select=\"[nxInput]\"></ng-content>\n  </div>\n  <ng-content select=\"nx-dropdown\"></ng-content>\n</div>\n\n<nx-popover #popover>\n  <ng-content select=\"[nxError]\"></ng-content>\n</nx-popover>",
                        host: {
                            '[class.size-short]': 'size == "short"',
                            '[class.size-regular]': 'size == "regular"',
                            '[class.size-long]': 'size == "long"',
                            '[class.has-error]': '_hasErrors',
                            '[class.is-focused]': 'isFocused',
                            '[class.is-filled]': 'isFilled',
                            '[class.has-dropdown]': 'hasDropdown',
                        },
                        changeDetection: core.ChangeDetectionStrategy.OnPush,
                        styles: [":host{display:inline-block;position:relative;font-weight:400;text-align:center;-webkit-hyphens:none;-ms-hyphens:none;hyphens:none;width:100%;margin:0 4px}:host .nx-word__inner-wrapper{border-bottom:2px solid #d9d9d9}:host.size-short{min-width:80px}:host.size-regular{min-width:152px}:host.size-long{min-width:360px}@media (max-width:991px){:host.size-long{min-width:280px}}@media (max-width:703px){:host.size-long{min-width:248px}}:host ::ng-deep .c-input{display:inline-block;text-align:inherit;font-size:inherit;line-height:inherit;background:0 0;color:inherit;border:none;outline:0;margin:0;width:100%;max-width:100%;height:auto;box-shadow:none;padding:0 8px}:host ::ng-deep .c-input.is-focused{outline:0;box-shadow:none}:host ::ng-deep .c-input.is-filled,:host ::ng-deep .c-input.is-focused{color:#006192;color:var(--natural-language-form-active-color,#006192);font-weight:400}:host ::ng-deep .c-input.is-disabled{cursor:not-allowed}:host ::ng-deep .c-input::-ms-clear{display:none}:host ::ng-deep nx-dropdown{position:relative;border-bottom:2px solid #d9d9d9}:host ::ng-deep nx-dropdown .nx-dropdown__container{font-size:inherit;margin-bottom:-2px}:host ::ng-deep nx-dropdown.has-focus,:host ::ng-deep nx-dropdown.is-filled{color:#006192;color:var(--natural-language-form-active-color,#006192);border-color:#007ab3;border-color:var(--natural-language-form-active-border-color,#007ab3)}:host ::ng-deep nx-dropdown .nx-dropdown__icon{line-height:inherit}:host ::ng-deep .nx-word__input-wrapper{width:100%}:host(.is-filled) .nx-word__inner-wrapper,:host(.is-focused) .nx-word__inner-wrapper{border-color:#007ab3;border-color:var(--natural-language-form-active-border-color,#007ab3)}:host(.has-error) .nx-word__inner-wrapper{border-color:#dc3149;border-color:var(--natural-language-form-error-border-color,#dc3149)}:host.has-error ::ng-deep nx-dropdown{color:#dc3149;color:var(--natural-language-form-error-color,#dc3149);border-color:#dc3149;border-color:var(--natural-language-form-error-border-color,#dc3149)}:host.has-error ::ng-deep .c-input.has-error{color:#dc3149;color:var(--natural-language-form-error-color,#dc3149)}:host-context(.is-negative) ::ng-deep .nx-dropdown,:host-context(.is-negative) ::ng-deep nx-dropdown,:host-context(.is-negative) ::ng-deep nx-dropdown.is-filled{border-color:#fff;color:#fff}:host-context(.is-negative) ::ng-deep .c-input,:host-context(.is-negative) ::ng-deep .c-input.has-error{color:#fff}:host-context(.is-negative) .nx-word__inner-wrapper{border-color:#fff}.nx-word__inner-wrapper{height:52px;height:var(--natural-language-form-large-line-height,52px)}@media (max-width:991px){:host ::ng-deep nx-dropdown .nx-dropdown__container{font-size:26px}.nx-word__inner-wrapper{height:36px;height:var(--natural-language-form-small-line-height,36px)}}:host-context(.nx-natural-language-form--small) .nx-word__inner-wrapper{height:36px;height:var(--natural-language-form-small-line-height,36px)}@media screen and (-ms-high-contrast:active){.nx-word__inner-wrapper,::ng-deep nx-dropdown{border-bottom-color:buttonText}}"]
                    }] }
        ];
        /** @nocollapse */
        NxWordComponent.ctorParameters = function () { return [
            { type: core.ElementRef },
            { type: core.ChangeDetectorRef },
            { type: core.Renderer2 },
            { type: overlay.Overlay },
            { type: core.ViewContainerRef },
            { type: overlay.OverlayPositionBuilder }
        ]; };
        NxWordComponent.propDecorators = {
            _control: [{ type: core.ContentChild, args: [formfield.NxFormfieldControl, { static: false },] }],
            _errorChildren: [{ type: core.ContentChildren, args: [formfield.NxFormfieldErrorDirective,] }],
            _popover: [{ type: core.ViewChild, args: ['popover', { static: true },] }],
            _dropdown: [{ type: core.ContentChild, args: [dropdown.NxDropdownComponent, { static: false },] }],
            currentTextWidth: [{ type: core.HostBinding, args: ['style.width.px',] }],
            size: [{ type: core.Input, args: ['nxSize',] }],
            label: [{ type: core.Input, args: ['nxLabel',] }]
        };
        return NxWordComponent;
    }());
    if (false) {
        /**
         * @type {?}
         * @private
         */
        NxWordComponent.prototype.subscription;
        /**
         * @type {?}
         * @private
         */
        NxWordComponent.prototype.subscriptionValues;
        /**
         * @type {?}
         * @private
         */
        NxWordComponent.prototype.measureCanvas;
        /**
         * \@docs-private
         * @type {?}
         */
        NxWordComponent.prototype.inputChanges;
        /** @type {?} */
        NxWordComponent.prototype._hasErrors;
        /**
         * @type {?}
         * @private
         */
        NxWordComponent.prototype._overlayRef;
        /**
         * @type {?}
         * @private
         */
        NxWordComponent.prototype._embeddedViewRef;
        /**
         * @type {?}
         * @private
         */
        NxWordComponent.prototype._overlayState;
        /** @type {?} */
        NxWordComponent.prototype._control;
        /** @type {?} */
        NxWordComponent.prototype._errorChildren;
        /** @type {?} */
        NxWordComponent.prototype._popover;
        /** @type {?} */
        NxWordComponent.prototype._dropdown;
        /**
         * \@docs-private
         * @type {?}
         */
        NxWordComponent.prototype.currentTextWidth;
        /**
         * Provide a hint for a minimal width. The actual size will be determined for inputs for each change.
         * @type {?}
         */
        NxWordComponent.prototype.size;
        /**
         * A word doesn't have a set place to show labels.
         * In order to be accessible, you have to provide a label with this property.
         * It will be attached to the given input through `aria-label`.
         * @type {?}
         */
        NxWordComponent.prototype.label;
        /**
         * \@docs-private
         * @type {?}
         */
        NxWordComponent.prototype.elementRef;
        /**
         * @type {?}
         * @private
         */
        NxWordComponent.prototype._changeDetectorRef;
        /**
         * @type {?}
         * @private
         */
        NxWordComponent.prototype._renderer;
        /**
         * @type {?}
         * @private
         */
        NxWordComponent.prototype._overlay;
        /**
         * @type {?}
         * @private
         */
        NxWordComponent.prototype._viewContainerRef;
        /**
         * @type {?}
         * @private
         */
        NxWordComponent.prototype._overlayPositionBuilder;
    }

    /**
     * @fileoverview added by tsickle
     * Generated from: natural-language-form/natural-language-form.component.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /** @type {?} */
    var DEFAULT_SIZE$3 = 'large';
    var NxNaturalLanguageFormComponent = /** @class */ (function () {
        function NxNaturalLanguageFormComponent(_changeDetectorRef) {
            this._changeDetectorRef = _changeDetectorRef;
            this._negative = false;
            /**
             * \@docs-private
             */
            this.resizeEvent$ = new rxjs.Subject();
            /**
             * \@docs-private
             */
            this.updatePopoversSubscription = rxjs.Subscription.EMPTY;
            /**
             * \@docs-private
             */
            this._size = DEFAULT_SIZE$3;
        }
        Object.defineProperty(NxNaturalLanguageFormComponent.prototype, "negative", {
            get: /**
             * @return {?}
             */
            function () {
                return this._negative;
            },
            /** Whether the negative set of stylings should be used. */
            set: /**
             * Whether the negative set of stylings should be used.
             * @param {?} value
             * @return {?}
             */
            function (value) {
                this._negative = coercion.coerceBooleanProperty(value);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NxNaturalLanguageFormComponent.prototype, "size", {
            get: /**
             * @return {?}
             */
            function () {
                return this._size;
            },
            /**
             * Sets the size of the NLF. Default value: large
             */
            set: /**
             * Sets the size of the NLF. Default value: large
             * @param {?} value
             * @return {?}
             */
            function (value) {
                this._size = value;
                this._changeDetectorRef.markForCheck();
            },
            enumerable: true,
            configurable: true
        });
        /** @docs-private */
        /**
         * \@docs-private
         * @param {?} event
         * @return {?}
         */
        NxNaturalLanguageFormComponent.prototype.onResize = /**
         * \@docs-private
         * @param {?} event
         * @return {?}
         */
        function (event) {
            this.resizeEvent$.next();
        };
        /**
         * @return {?}
         */
        NxNaturalLanguageFormComponent.prototype.ngAfterContentInit = /**
         * @return {?}
         */
        function () {
            var _this = this;
            // Collect all words and listen for changes so we can update any open error popover
            // which would otherwise get wrongly positioned.
            /** @type {?} */
            var subjects = this._words.map((/**
             * @param {?} word
             * @return {?}
             */
            function (word) { return word.inputChanges; }));
            /** @type {?} */
            var source = rxjs.merge.apply(void 0, __spread(subjects));
            this.updatePopoversSubscription = source.subscribe((/**
             * @return {?}
             */
            function () {
                _this.updatePositionPopovers();
            }));
            this.resizeObservable = this.resizeEvent$.pipe(operators.throttleTime(500), operators.delay(100));
            this.resizeObservable.subscribe((/**
             * @return {?}
             */
            function () { return _this.resizeWords(); }));
        };
        /** @docs-private */
        /**
         * \@docs-private
         * @return {?}
         */
        NxNaturalLanguageFormComponent.prototype.resizeWords = /**
         * \@docs-private
         * @return {?}
         */
        function () {
            this._words.forEach((/**
             * @param {?} word
             * @return {?}
             */
            function (word) {
                word.updateCurrentTextWidth();
            }));
        };
        /**
         * @return {?}
         */
        NxNaturalLanguageFormComponent.prototype.ngOnDestroy = /**
         * @return {?}
         */
        function () {
            this.updatePopoversSubscription.unsubscribe();
        };
        /** @docs-private */
        /**
         * \@docs-private
         * @return {?}
         */
        NxNaturalLanguageFormComponent.prototype.updatePositionPopovers = /**
         * \@docs-private
         * @return {?}
         */
        function () {
            if (this._words) {
                this._words.forEach((/**
                 * @param {?} word
                 * @return {?}
                 */
                function (word) {
                    word.repositionError();
                }));
            }
        };
        NxNaturalLanguageFormComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'nx-natural-language-form',
                        template: "<div class=\"nx-natural-language-form__wrapper\">\n    <ng-content></ng-content>\n</div>",
                        changeDetection: core.ChangeDetectionStrategy.OnPush,
                        host: {
                            '[class.is-negative]': 'negative',
                            '[class.nx-natural-language-form--small]': 'size === "small"',
                            '[class.nx-natural-language-form--large]': 'size === "large"',
                        },
                        styles: [":host{display:block;font-size:40px;font-size:var(--natural-language-form-large-font-size,40px);line-height:52px;line-height:var(--natural-language-form-large-line-height,52px);font-weight:300;font-weight:var(--natural-language-form-large-font-weight,300);letter-spacing:.3px;letter-spacing:var(--natural-language-form-large-letter-spacing,.3px);color:#414141;color:var(--natural-language-form-text-color,#414141);padding-top:72px;padding-bottom:80px}:host ::ng-deep .c-input{font-size:inherit;line-height:inherit}:host ::ng-deep nx-word+nx-word{margin-left:2px}:host.is-negative{color:#fff}@media (max-width:991px){:host{font-size:26px;font-size:var(--natural-language-form-small-font-size,26px);line-height:36px;line-height:var(--natural-language-form-small-line-height,36px);font-weight:300;font-weight:var(--natural-language-form-small-font-weight,300);letter-spacing:.3px;letter-spacing:var(--natural-language-form-small-letter-spacing,.3px)}}.nx-natural-language-form__wrapper{display:flex;flex-wrap:wrap}.nx-natural-language-form__wrapper>::ng-deep *{margin-bottom:8px}:host(.nx-natural-language-form--small){font-size:26px;font-size:var(--natural-language-form-small-font-size,26px);line-height:36px;line-height:var(--natural-language-form-small-line-height,36px);font-weight:300;font-weight:var(--natural-language-form-small-font-weight,300);letter-spacing:.3px;letter-spacing:var(--natural-language-form-small-letter-spacing,.3px)}:host(.nx-natural-language-form--small) ::ng-deep .c-input{font-size:inherit;line-height:inherit}"]
                    }] }
        ];
        /** @nocollapse */
        NxNaturalLanguageFormComponent.ctorParameters = function () { return [
            { type: core.ChangeDetectorRef }
        ]; };
        NxNaturalLanguageFormComponent.propDecorators = {
            _words: [{ type: core.ContentChildren, args: [NxWordComponent,] }],
            negative: [{ type: core.Input, args: ['nxNegative',] }],
            size: [{ type: core.Input }],
            onResize: [{ type: core.HostListener, args: ['window:orientationchange', ['$event'],] }, { type: core.HostListener, args: ['window:resize', ['$event'],] }]
        };
        return NxNaturalLanguageFormComponent;
    }());
    if (false) {
        /**
         * @type {?}
         * @private
         */
        NxNaturalLanguageFormComponent.prototype._negative;
        /**
         * \@docs-private
         * @type {?}
         */
        NxNaturalLanguageFormComponent.prototype.resizeEvent$;
        /**
         * \@docs-private
         * @type {?}
         */
        NxNaturalLanguageFormComponent.prototype.resizeObservable;
        /** @type {?} */
        NxNaturalLanguageFormComponent.prototype._words;
        /**
         * \@docs-private
         * @type {?}
         */
        NxNaturalLanguageFormComponent.prototype.updatePopoversSubscription;
        /**
         * \@docs-private
         * @type {?}
         * @private
         */
        NxNaturalLanguageFormComponent.prototype._size;
        /**
         * @type {?}
         * @private
         */
        NxNaturalLanguageFormComponent.prototype._changeDetectorRef;
    }

    /**
     * @fileoverview added by tsickle
     * Generated from: natural-language-form/natural-language-form.module.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var NxNaturalLanguageFormModule = /** @class */ (function () {
        function NxNaturalLanguageFormModule() {
        }
        NxNaturalLanguageFormModule.decorators = [
            { type: core.NgModule, args: [{
                        imports: [
                            common.CommonModule,
                            input.NxInputModule,
                            popover.NxPopoverModule
                        ],
                        declarations: [
                            NxNaturalLanguageFormComponent,
                            NxWordComponent
                        ],
                        exports: [
                            NxNaturalLanguageFormComponent,
                            NxWordComponent
                        ]
                    },] }
        ];
        return NxNaturalLanguageFormModule;
    }());

    /**
     * @fileoverview added by tsickle
     * Generated from: natural-language-form/public-api.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * Generated from: message/message/message.component.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /** @type {?} */
    var ICONS = {
        info: 'info-circle',
        error: 'exclamation-triangle',
        success: 'check-circle',
        warning: 'exclamation-circle'
    };
    var NxMessageComponent = /** @class */ (function () {
        function NxMessageComponent(_changeDetectorRef) {
            this._changeDetectorRef = _changeDetectorRef;
            this._context = 'regular';
            this._showIcon = false;
            this._closable = false;
            this._closeButtonLabel = 'Close dialog';
            /**
             * Event emitted when the close icon of the message has been clicked.
             */
            this.closeEvent = new core.EventEmitter();
        }
        Object.defineProperty(NxMessageComponent.prototype, "context", {
            get: /**
             * @return {?}
             */
            function () {
                return this._context;
            },
            /**
             * Sets the context of the message.
             * The message box will color accordingly. Default: 'regular' */
            set: /**
             * Sets the context of the message.
             * The message box will color accordingly. Default: 'regular'
             * @param {?} value
             * @return {?}
             */
            function (value) {
                if (value !== this._context) {
                    this._context = value;
                    this._icon = this.getIconName();
                    this._changeDetectorRef.markForCheck();
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NxMessageComponent.prototype, "showIcon", {
            get: /**
             * @return {?}
             */
            function () {
                return this._showIcon;
            },
            /**
             * Whether an icon that belongs to the context of the message should be displayed.
             *
             * **Important:** The `showIcon` attribute should always be set to `true` due to deprecation.
             *
             * @deprecated The `showIcon` attribute should be always true in future. Messages without an icon are deprecated.
             * @deletion-target 9.0.0
             * */
            set: /**
             * Whether an icon that belongs to the context of the message should be displayed.
             *
             * **Important:** The `showIcon` attribute should always be set to `true` due to deprecation.
             *
             * @deprecated The `showIcon` attribute should be always true in future. Messages without an icon are deprecated.
             * \@deletion-target 9.0.0
             *
             * @param {?} value
             * @return {?}
             */
            function (value) {
                this._showIcon = coercion.coerceBooleanProperty(value);
                this._changeDetectorRef.markForCheck();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NxMessageComponent.prototype, "closable", {
            get: /**
             * @return {?}
             */
            function () {
                return this._closable;
            },
            /** Whether a message should have a close icon in order to be dismissed. */
            set: /**
             * Whether a message should have a close icon in order to be dismissed.
             * @param {?} value
             * @return {?}
             */
            function (value) {
                /** @type {?} */
                var newValue = coercion.coerceBooleanProperty(value);
                if (newValue !== this._closable) {
                    this._closable = newValue;
                    this._changeDetectorRef.markForCheck();
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NxMessageComponent.prototype, "icon", {
            /** @docs-private */
            get: /**
             * \@docs-private
             * @return {?}
             */
            function () {
                return this._icon;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NxMessageComponent.prototype, "closeButtonLabel", {
            get: /**
             * @return {?}
             */
            function () {
                return this._closeButtonLabel;
            },
            /** Sets the label of the close button of the message. */
            set: /**
             * Sets the label of the close button of the message.
             * @param {?} value
             * @return {?}
             */
            function (value) {
                if (value !== this._closeButtonLabel) {
                    this._closeButtonLabel = value;
                    this._changeDetectorRef.markForCheck();
                }
            },
            enumerable: true,
            configurable: true
        });
        /** @docs-private */
        /**
         * \@docs-private
         * @return {?}
         */
        NxMessageComponent.prototype._emitCloseEvent = /**
         * \@docs-private
         * @return {?}
         */
        function () {
            this.closeEvent.emit();
        };
        /** @docs-private */
        /**
         * \@docs-private
         * @return {?}
         */
        NxMessageComponent.prototype.getIconName = /**
         * \@docs-private
         * @return {?}
         */
        function () {
            if (this._context === 'info') {
                return ICONS.info;
            }
            else if (this._context === 'error') {
                return ICONS.error;
            }
            else if (this._context === 'success') {
                return ICONS.success;
            }
            else if (this._context === 'warning') {
                return ICONS.warning;
            }
            return '';
        };
        NxMessageComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'nx-message',
                        template: "<nx-icon *ngIf=\"showIcon && context !== 'regular'\"\n         class=\"nx-message__icon\"\n         [name]=\"icon\"\n         size=\"s\">\n</nx-icon>\n<button\n  *ngIf=\"closable\"\n  (click)=\"_emitCloseEvent()\"\n  [attr.aria-label]=\"closeButtonLabel\"\n  tabindex=\"0\"\n  class=\"nx-message__close-icon\">\n    <nx-icon\n      name=\"close\"\n      size=\"s\"\n      aria-hidden=\"true\">\n    </nx-icon>\n</button>\n\n\n<div class=\"nx-message__content-wrapper\">\n  <div class=\"nx-message__content\">\n    <ng-content></ng-content>\n  </div>\n</div>\n",
                        changeDetection: core.ChangeDetectionStrategy.OnPush,
                        exportAs: 'nxMessage',
                        host: {
                            '[class.context-info]': 'context === "info"',
                            '[class.context-error]': 'context === "error"',
                            '[class.context-success]': 'context === "success"',
                            '[class.context-warning]': 'context === "warning"',
                            '[class.nx-message--closable]': 'closable'
                        },
                        styles: [":host{font-size:16px;font-size:var(--message-font-size,16px);line-height:24px;line-height:var(--message-line-height,24px);font-weight:400;font-weight:var(--message-font-weight,400);letter-spacing:0;letter-spacing:var(--message-letter-spacing,0);color:#414141;color:var(--message-text-color,#414141);border-radius:4px;border-radius:var(--message-border-radius,4px);width:100%;display:flex;align-items:flex-start;text-align:left;position:relative;border:1px solid;padding:23px;margin:12px 0}.nx-message__content-wrapper{max-width:100%}:host,:host(.context-regular){border-color:#414141;border-color:var(--message-regular-border-color,#414141);background-color:#fff;background-color:var(--message-regular-background-color,#fff)}:host(.context-info){border-color:#496ebd;border-color:var(--message-info-border-color,#496ebd);background-color:#ecf0f8;background-color:var(--message-info-background-color,#ecf0f8)}:host(.context-info) .nx-message__icon{color:#496ebd;color:var(--message-info-icon-color,#496ebd)}:host(.context-error){border-color:#dc3149;border-color:var(--message-error-border-color,#dc3149);background-color:#fbeaec;background-color:var(--message-error-background-color,#fbeaec)}:host(.context-error) .nx-message__icon{color:#dc3149;color:var(--message-error-icon-color,#dc3149)}:host(.context-success){border-color:#1e8927;border-color:var(--message-success-border-color,#1e8927);background-color:#e8f3e9;background-color:var(--message-success-background-color,#e8f3e9)}:host(.context-success) .nx-message__icon{color:#1e8927;color:var(--message-success-icon-color,#1e8927)}:host(.context-warning){border-color:#efbe25;border-color:var(--message-warning-border-color,#efbe25);background-color:#fdf8e9;background-color:var(--message-warning-background-color,#fdf8e9)}:host(.context-warning) .nx-message__icon{color:#efbe25;color:var(--message-warning-icon-color,#efbe25)}.nx-message__icon{margin-right:16px}@media (max-width:703px){:host{padding:31px;display:block}:host(.context-error) .nx-message__icon~.nx-message__content-wrapper .nx-message__content,:host(.context-info) .nx-message__icon~.nx-message__content-wrapper .nx-message__content,:host(.context-success) .nx-message__icon~.nx-message__content-wrapper .nx-message__content,:host(.context-warning) .nx-message__icon~.nx-message__content-wrapper .nx-message__content{display:inline;margin-left:31px}.nx-message__icon{position:absolute}}:host(.nx-message--closable){padding-right:39px}@media (max-width:703px){:host(.nx-message--closable){padding-right:31px}}.nx-message__close-icon{position:absolute;top:16px;right:16px;cursor:pointer;background-color:transparent;border:none;outline:0;padding:0;display:flex;align-items:center}.nx-message__close-icon nx-icon{color:#414141;color:var(--message-close-icon-color,#414141);font-size:16px}:host-context([data-whatinput=keyboard]) .nx-message__close-icon:focus{box-shadow:0 0 0 2px #fff,0 0 0 6px #009de6;box-shadow:var(--focus-box-shadow,0 0 0 2px #fff,0 0 0 6px #009de6);border-radius:4px}@media screen and (-ms-high-contrast:active){:host(.context-error) .nx-message__icon,:host(.context-info) .nx-message__icon,:host(.context-success) .nx-message__icon,:host(.context-warning) .nx-message__icon{color:windowText}:host-context([data-whatinput=keyboard]) .nx-message__close-icon:focus{box-shadow:0 0 0 2px background,0 0 0 6px windowText}}"]
                    }] }
        ];
        /** @nocollapse */
        NxMessageComponent.ctorParameters = function () { return [
            { type: core.ChangeDetectorRef }
        ]; };
        NxMessageComponent.propDecorators = {
            context: [{ type: core.Input, args: ['nxContext',] }],
            showIcon: [{ type: core.Input }],
            closable: [{ type: core.Input }],
            closeButtonLabel: [{ type: core.Input }],
            closeEvent: [{ type: core.Output, args: ['close',] }]
        };
        return NxMessageComponent;
    }());
    if (false) {
        /**
         * @type {?}
         * @private
         */
        NxMessageComponent.prototype._context;
        /**
         * @type {?}
         * @private
         */
        NxMessageComponent.prototype._showIcon;
        /**
         * @type {?}
         * @private
         */
        NxMessageComponent.prototype._closable;
        /**
         * @type {?}
         * @private
         */
        NxMessageComponent.prototype._icon;
        /**
         * @type {?}
         * @private
         */
        NxMessageComponent.prototype._closeButtonLabel;
        /**
         * Event emitted when the close icon of the message has been clicked.
         * @type {?}
         */
        NxMessageComponent.prototype.closeEvent;
        /**
         * @type {?}
         * @private
         */
        NxMessageComponent.prototype._changeDetectorRef;
    }

    /**
     * @fileoverview added by tsickle
     * Generated from: message/message-toast/message-toast-animations.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * Animations used by the Message Toast.
     * \@docs-private
     * @type {?}
     */
    var messageToastAnimations = {
        toastState: animations.trigger('state', [
            animations.state('initial, void, hidden', animations.style({ opacity: 0, transform: 'translateY(100%)' })),
            animations.state('visible', animations.style({ opacity: 1 })),
            animations.transition('* => visible', animations.animate('300ms cubic-bezier(0, 0, 0.2, 1)', animations.style({ opacity: 1, transform: 'translateY(0)' }))),
            animations.transition('* => hidden', animations.animate('300ms cubic-bezier(0, 0, 0.2, 1)', animations.style({ opacity: 0, transform: 'translateY(200%)' }))),
        ])
    };

    /**
     * @fileoverview added by tsickle
     * Generated from: message/message-toast/message-toast-config.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * Configuration used when opening a message toast.
     */
    var   /**
     * Configuration used when opening a message toast.
     */
    NxMessageToastConfig = /** @class */ (function () {
        function NxMessageToastConfig() {
            /**
             * The politeness level for the LiveAnnouncer announcement.
             *
             *  Default value: 'polite'.
             */
            this.politeness = 'polite';
            /**
             * Message to be announced by the LiveAnnouncer. When opening a toast message without a custom
             * component or template, the announcement message will default to the specified message.
             *
             * Default value: ''.
             */
            this.announcementMessage = '';
            /**
             * The length of time in milliseconds to wait before automatically dismissing the message toast.
             *
             * Default value: 3000.
             */
            this.duration = 3000;
            /**
             * Context of the message toast.
             *
             * Default value: 'info'.
             */
            this.context = 'info';
        }
        return NxMessageToastConfig;
    }());
    if (false) {
        /**
         * The politeness level for the LiveAnnouncer announcement.
         *
         *  Default value: 'polite'.
         * @type {?}
         */
        NxMessageToastConfig.prototype.politeness;
        /**
         * Message to be announced by the LiveAnnouncer. When opening a toast message without a custom
         * component or template, the announcement message will default to the specified message.
         *
         * Default value: ''.
         * @type {?}
         */
        NxMessageToastConfig.prototype.announcementMessage;
        /**
         * The length of time in milliseconds to wait before automatically dismissing the message toast.
         *
         * Default value: 3000.
         * @type {?}
         */
        NxMessageToastConfig.prototype.duration;
        /**
         * Context of the message toast.
         *
         * Default value: 'info'.
         * @type {?}
         */
        NxMessageToastConfig.prototype.context;
    }
    /**
     * \@docs-private
     * Needed so that the user text data can be injected in the message toastcomponent
     */
    var   /**
     * \@docs-private
     * Needed so that the user text data can be injected in the message toastcomponent
     */
    NxMessageToastData = /** @class */ (function () {
        function NxMessageToastData(data) {
            this.data = data;
        }
        return NxMessageToastData;
    }());
    if (false) {
        /** @type {?} */
        NxMessageToastData.prototype.data;
    }

    /**
     * @fileoverview added by tsickle
     * Generated from: message/message-toast/message-toast.component.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /** @type {?} */
    var ICONS$1 = {
        info: 'info-circle',
        success: 'check-circle',
    };
    /**
     * Internal component that wraps user-provided message toastcontent.
     * \@docs-private
     */
    var NxMessageToastComponent = /** @class */ (function (_super) {
        __extends(NxMessageToastComponent, _super);
        function NxMessageToastComponent(_ngZone, _changeDetectorRef, config, data) {
            var _this = _super.call(this) || this;
            _this._ngZone = _ngZone;
            _this._changeDetectorRef = _changeDetectorRef;
            _this.config = config;
            _this.data = data;
            /**
             * Whether the component has been destroyed.
             */
            _this._destroyed = false;
            /**
             * Subject for notifying that the message toasthas exited from view.
             */
            _this._onExit = new rxjs.Subject();
            /**
             * Subject for notifying that the message toasthas finished entering the view.
             */
            _this._onEnter = new rxjs.Subject();
            /**
             * The state of the message toastanimations.
             */
            _this._animationState = 'void';
            _this._context = _this.config.context;
            _this._setAriaLabels();
            return _this;
        }
        /** Attach a component portal as content to this message toastcontainer. */
        /**
         * Attach a component portal as content to this message toastcontainer.
         * @template T
         * @param {?} portal
         * @return {?}
         */
        NxMessageToastComponent.prototype.attachComponentPortal = /**
         * Attach a component portal as content to this message toastcontainer.
         * @template T
         * @param {?} portal
         * @return {?}
         */
        function (portal) {
            this._assertNotAttached();
            return this._portalOutlet.attachComponentPortal(portal);
        };
        /** Attach a template portal as content to this message toastcontainer. */
        /**
         * Attach a template portal as content to this message toastcontainer.
         * @template C
         * @param {?} portal
         * @return {?}
         */
        NxMessageToastComponent.prototype.attachTemplatePortal = /**
         * Attach a template portal as content to this message toastcontainer.
         * @template C
         * @param {?} portal
         * @return {?}
         */
        function (portal) {
            this._assertNotAttached();
            return this._portalOutlet.attachTemplatePortal(portal);
        };
        /** Handle end of animations, updating the state of the notification. */
        /**
         * Handle end of animations, updating the state of the notification.
         * @param {?} event
         * @return {?}
         */
        NxMessageToastComponent.prototype.onAnimationEnd = /**
         * Handle end of animations, updating the state of the notification.
         * @param {?} event
         * @return {?}
         */
        function (event) {
            var fromState = event.fromState, toState = event.toState;
            if ((toState === 'void' && fromState !== 'void') || toState === 'hidden') {
                this._completeExit();
            }
            if (toState === 'visible') {
                // Note: we shouldn't use `this` inside the zone callback,
                // because it can cause a memory leak.
                /** @type {?} */
                var onEnter_1 = this._onEnter;
                this._ngZone.run((/**
                 * @return {?}
                 */
                function () {
                    onEnter_1.next();
                    onEnter_1.complete();
                }));
            }
        };
        /** Begin animation of message toastentrance into view. */
        /**
         * Begin animation of message toastentrance into view.
         * @return {?}
         */
        NxMessageToastComponent.prototype.enter = /**
         * Begin animation of message toastentrance into view.
         * @return {?}
         */
        function () {
            if (!this._destroyed) {
                this._animationState = 'visible';
                this._changeDetectorRef.detectChanges();
            }
        };
        /** Begin animation of the message toastexiting from view. */
        /**
         * Begin animation of the message toastexiting from view.
         * @return {?}
         */
        NxMessageToastComponent.prototype.exit = /**
         * Begin animation of the message toastexiting from view.
         * @return {?}
         */
        function () {
            // Note: this one transitions to `hidden`, rather than `void`, in order to handle the case
            // where multiple notifications are opened in quick succession (e.g. two consecutive calls to
            // `NxMessageToastService.open`).
            this._animationState = 'hidden';
        };
        /** Makes sure the exit callbacks have been invoked when the element is destroyed. */
        /**
         * Makes sure the exit callbacks have been invoked when the element is destroyed.
         * @return {?}
         */
        NxMessageToastComponent.prototype.ngOnDestroy = /**
         * Makes sure the exit callbacks have been invoked when the element is destroyed.
         * @return {?}
         */
        function () {
            this._destroyed = true;
            this._completeExit();
        };
        /**
         * Waits for the zone to settle before removing the element. Helps prevent
         * errors where we end up removing an element which is in the middle of an animation.
         */
        /**
         * Waits for the zone to settle before removing the element. Helps prevent
         * errors where we end up removing an element which is in the middle of an animation.
         * @private
         * @return {?}
         */
        NxMessageToastComponent.prototype._completeExit = /**
         * Waits for the zone to settle before removing the element. Helps prevent
         * errors where we end up removing an element which is in the middle of an animation.
         * @private
         * @return {?}
         */
        function () {
            var _this = this;
            this._ngZone.onMicrotaskEmpty.asObservable().pipe(operators.take(1)).subscribe((/**
             * @return {?}
             */
            function () {
                _this._onExit.next();
                _this._onExit.complete();
            }));
        };
        /** Asserts that no content is already attached to the container. */
        /**
         * Asserts that no content is already attached to the container.
         * @private
         * @return {?}
         */
        NxMessageToastComponent.prototype._assertNotAttached = /**
         * Asserts that no content is already attached to the container.
         * @private
         * @return {?}
         */
        function () {
            if (this._portalOutlet.hasAttached()) {
                throw Error('Attempting to attach message toastcontent after content is already attached');
            }
        };
        /**
         * @return {?}
         */
        NxMessageToastComponent.prototype._getIconName = /**
         * @return {?}
         */
        function () {
            return this._context === 'success' ? ICONS$1.success : ICONS$1.info;
        };
        /**
         * @return {?}
         */
        NxMessageToastComponent.prototype._setAriaLabels = /**
         * @return {?}
         */
        function () {
            // Based on the ARIA spec, `alert` and `status` roles have an
            // implicit `assertive` and `polite` politeness respectively.
            if (this.config.politeness === 'assertive' && !this.config.announcementMessage) {
                this._role = 'alert';
            }
            else if (this.config.politeness === 'off') {
                this._role = null;
            }
            else {
                this._role = 'status';
            }
        };
        NxMessageToastComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'nx-message-toast',
                        template: "<nx-icon class=\"nx-message__icon\" [name]=\"_getIconName()\" size=\"s\">\n</nx-icon>\n\n<div class=\"nx-message__content-wrapper\">\n    <!-- Used when opening from a template -->\n    <ng-template cdkPortalOutlet></ng-template>\n    <!-- Used when opening only with custom text-->\n    <ng-container *ngIf=\"data\">{{data.data}}</ng-container>\n</div>\n",
                        host: {
                            '[attr.role]': '_role',
                            '[class.context-info]': '_context === "info"',
                            '[class.context-success]': '_context === "success"',
                            '[@state]': '_animationState',
                            '(@state.done)': 'onAnimationEnd($event)'
                        },
                        animations: [messageToastAnimations.toastState],
                        styles: [":host{font-size:16px;font-size:var(--message-font-size,16px);line-height:24px;line-height:var(--message-line-height,24px);font-weight:400;font-weight:var(--message-font-weight,400);letter-spacing:0;letter-spacing:var(--message-letter-spacing,0);color:#414141;color:var(--message-text-color,#414141);border-radius:4px;border-radius:var(--message-border-radius,4px);width:100%;display:flex;align-items:flex-start;text-align:left;position:relative;border:1px solid;padding:23px 23px 23px 63px;margin:12px 0;box-shadow:0 2px 4px rgba(65,65,65,.5);box-shadow:var(--message-box-shadow,0 2px 4px rgba(65,65,65,.5));max-width:352px}@media (max-width:703px){:host{padding:23px 23px 23px 63px;display:block}}:host(.context-info){border-color:#496ebd;border-color:var(--message-info-border-color,#496ebd);background-color:#ecf0f8;background-color:var(--message-info-background-color,#ecf0f8)}:host(.context-info) .nx-message__icon{color:#496ebd;color:var(--message-info-icon-color,#496ebd)}:host(.context-success){border-color:#1e8927;border-color:var(--message-success-border-color,#1e8927);background-color:#e8f3e9;background-color:var(--message-success-background-color,#e8f3e9)}:host(.context-success) .nx-message__icon{color:#1e8927;color:var(--message-success-icon-color,#1e8927)}@media screen and (-ms-high-contrast:active){:host(.context-info) .nx-message__icon,:host(.context-success) .nx-message__icon{color:windowText}}.nx-message__icon{position:absolute;top:23px;left:23px}"]
                    }] }
        ];
        /** @nocollapse */
        NxMessageToastComponent.ctorParameters = function () { return [
            { type: core.NgZone },
            { type: core.ChangeDetectorRef },
            { type: NxMessageToastConfig },
            { type: NxMessageToastData }
        ]; };
        NxMessageToastComponent.propDecorators = {
            _portalOutlet: [{ type: core.ViewChild, args: [portal.CdkPortalOutlet, { static: true },] }]
        };
        return NxMessageToastComponent;
    }(portal.BasePortalOutlet));
    if (false) {
        /**
         * Whether the component has been destroyed.
         * @type {?}
         * @private
         */
        NxMessageToastComponent.prototype._destroyed;
        /**
         * The portal outlet inside of this container into which the message toastcontent will be loaded.
         * @type {?}
         */
        NxMessageToastComponent.prototype._portalOutlet;
        /**
         * Subject for notifying that the message toasthas exited from view.
         * @type {?}
         */
        NxMessageToastComponent.prototype._onExit;
        /**
         * Subject for notifying that the message toasthas finished entering the view.
         * @type {?}
         */
        NxMessageToastComponent.prototype._onEnter;
        /**
         * The state of the message toastanimations.
         * @type {?}
         */
        NxMessageToastComponent.prototype._animationState;
        /**
         * ARIA role for the message toastcontainer.
         * @type {?}
         */
        NxMessageToastComponent.prototype._role;
        /** @type {?} */
        NxMessageToastComponent.prototype._context;
        /**
         * @type {?}
         * @private
         */
        NxMessageToastComponent.prototype._ngZone;
        /**
         * @type {?}
         * @private
         */
        NxMessageToastComponent.prototype._changeDetectorRef;
        /**
         * The message toastconfiguration.
         * @type {?}
         */
        NxMessageToastComponent.prototype.config;
        /**
         * Injected data into the notifciation.
         * @type {?}
         */
        NxMessageToastComponent.prototype.data;
    }

    /**
     * @fileoverview added by tsickle
     * Generated from: message/message.module.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var NxMessageModule = /** @class */ (function () {
        function NxMessageModule() {
        }
        NxMessageModule.decorators = [
            { type: core.NgModule, args: [{
                        imports: [
                            common.CommonModule,
                            icon.NxIconModule,
                            overlay.OverlayModule,
                            portal.PortalModule
                        ],
                        declarations: [
                            NxMessageComponent,
                            NxMessageToastComponent
                        ],
                        exports: [
                            NxMessageComponent
                        ],
                        entryComponents: [
                            NxMessageToastComponent
                        ]
                    },] }
        ];
        return NxMessageModule;
    }());

    /**
     * @fileoverview added by tsickle
     * Generated from: message/message-toast/message-toast-ref.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * Maximum amount of milliseconds that can be passed into setTimeout.
     * @type {?}
     */
    var MAX_TIMEOUT = Math.pow(2, 31) - 1;
    var NxMessageToastRef = /** @class */ (function () {
        function NxMessageToastRef(toastInstance, _overlayRef) {
            var _this = this;
            this._overlayRef = _overlayRef;
            /**
             * Subject for notifying the user that the message toasthas been dismissed.
             */
            this._afterDismissed = new rxjs.Subject();
            /**
             * Subject for notifying the user that the message toasthas opened and appeared.
             */
            this._afterOpened = new rxjs.Subject();
            this.toastInstance = toastInstance;
            toastInstance._onExit.subscribe((/**
             * @return {?}
             */
            function () { return _this._finishDismiss(); }));
        }
        /** Dismisses the message toast. */
        /**
         * Dismisses the message toast.
         * @return {?}
         */
        NxMessageToastRef.prototype.dismiss = /**
         * Dismisses the message toast.
         * @return {?}
         */
        function () {
            if (!this._afterDismissed.closed) {
                this.toastInstance.exit();
            }
            clearTimeout(this._durationTimeoutId);
        };
        /** Dismisses the message toastafter some duration */
        /**
         * Dismisses the message toastafter some duration
         * @param {?} duration
         * @return {?}
         */
        NxMessageToastRef.prototype._dismissAfter = /**
         * Dismisses the message toastafter some duration
         * @param {?} duration
         * @return {?}
         */
        function (duration) {
            var _this = this;
            // Note that we need to cap the duration to the maximum value for setTimeout, because
            // it'll revert to 1 if somebody passes in something greater (e.g. `Infinity`). See #17234.
            this._durationTimeoutId = setTimeout((/**
             * @return {?}
             */
            function () { return _this.dismiss(); }), Math.min(duration, MAX_TIMEOUT));
        };
        /** Marks the message toastas opened */
        /**
         * Marks the message toastas opened
         * @return {?}
         */
        NxMessageToastRef.prototype._open = /**
         * Marks the message toastas opened
         * @return {?}
         */
        function () {
            if (!this._afterOpened.closed) {
                this._afterOpened.next();
                this._afterOpened.complete();
            }
        };
        /** Cleans up the DOM after closing. */
        /**
         * Cleans up the DOM after closing.
         * @private
         * @return {?}
         */
        NxMessageToastRef.prototype._finishDismiss = /**
         * Cleans up the DOM after closing.
         * @private
         * @return {?}
         */
        function () {
            this._overlayRef.dispose();
            this._afterDismissed.next();
            this._afterDismissed.complete();
        };
        /** Gets an observable that is notified when the message toastis finished closing. */
        /**
         * Gets an observable that is notified when the message toastis finished closing.
         * @return {?}
         */
        NxMessageToastRef.prototype.afterDismissed = /**
         * Gets an observable that is notified when the message toastis finished closing.
         * @return {?}
         */
        function () {
            return this._afterDismissed.asObservable();
        };
        /** Gets an observable that is notified when the message toasthas opened and appeared. */
        /**
         * Gets an observable that is notified when the message toasthas opened and appeared.
         * @return {?}
         */
        NxMessageToastRef.prototype.afterOpened = /**
         * Gets an observable that is notified when the message toasthas opened and appeared.
         * @return {?}
         */
        function () {
            return this.toastInstance._onEnter;
        };
        return NxMessageToastRef;
    }());
    if (false) {
        /**
         * The instance of the component making up the content of the message toast.
         * \@docs-private
         * @type {?}
         */
        NxMessageToastRef.prototype.toastInstance;
        /**
         * Subject for notifying the user that the message toasthas been dismissed.
         * @type {?}
         * @private
         */
        NxMessageToastRef.prototype._afterDismissed;
        /**
         * Subject for notifying the user that the message toasthas opened and appeared.
         * @type {?}
         * @private
         */
        NxMessageToastRef.prototype._afterOpened;
        /**
         * Timeout ID for the duration setTimeout call. Used to clear the timeout if the message toastis
         * dismissed before the duration passes.
         * @type {?}
         * @private
         */
        NxMessageToastRef.prototype._durationTimeoutId;
        /**
         * @type {?}
         * @private
         */
        NxMessageToastRef.prototype._overlayRef;
    }

    /**
     * @fileoverview added by tsickle
     * Generated from: message/message-toast/message-toast.service.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * Injection token that can be used to specify default message toast.
     * @type {?}
     */
    var NX_MESSAGE_TOAST_DEFAULT_CONFIG = new core.InjectionToken('NX_MESSAGE_TOAST_DEFAULT_CONFIG');
    /**
     * A service for dispatching and displaying toast messages.
     */
    var NxMessageToastService = /** @class */ (function () {
        function NxMessageToastService(_overlay, _injector, _live, _parentMessageToastService, _defaultConfig) {
            this._overlay = _overlay;
            this._injector = _injector;
            this._live = _live;
            this._parentMessageToastService = _parentMessageToastService;
            this._defaultConfig = _defaultConfig;
            /**
             * Reference to the current message toast in the view *at this level* (in the Angular injector tree).
             * If there is a parent message toast service, all operations should delegate to that parent
             * via `_oldToastMessageRef`.
             */
            this._toastRefAtThisLevel = null;
        }
        Object.defineProperty(NxMessageToastService.prototype, "_oldToastMessageRef", {
            /** Reference to the currently opened message toastat *any* level. */
            get: /**
             * Reference to the currently opened message toastat *any* level.
             * @return {?}
             */
            function () {
                /** @type {?} */
                var parent = this._parentMessageToastService;
                return parent ? parent._oldToastMessageRef : this._toastRefAtThisLevel;
            },
            set: /**
             * @param {?} value
             * @return {?}
             */
            function (value) {
                if (this._parentMessageToastService) {
                    this._parentMessageToastService._oldToastMessageRef = value;
                }
                else {
                    this._toastRefAtThisLevel = value;
                }
            },
            enumerable: true,
            configurable: true
        });
        /** Creates and dispatches a message toastwith a custom text.
         *
         * @param text Text to be used for the message toast.
         * @param config Extra configuration for the message toast.
        */
        /**
         * Creates and dispatches a message toastwith a custom text.
         *
         * @param {?} text Text to be used for the message toast.
         * @param {?=} config Extra configuration for the message toast.
         * @return {?}
         */
        NxMessageToastService.prototype.open = /**
         * Creates and dispatches a message toastwith a custom text.
         *
         * @param {?} text Text to be used for the message toast.
         * @param {?=} config Extra configuration for the message toast.
         * @return {?}
         */
        function (text, config) {
            /** @type {?} */
            var currentConfig = __assign({}, new NxMessageToastConfig(), this._defaultConfig, config);
            /** @type {?} */
            var overlayRef = this._createOverlay(currentConfig);
            /** @type {?} */
            var injector = this._createInjector(currentConfig, new NxMessageToastData(text), this._injector);
            /** @type {?} */
            var componentPortal = new portal.ComponentPortal(NxMessageToastComponent, undefined, injector);
            /** @type {?} */
            var componentRef = overlayRef.attach(componentPortal);
            /** @type {?} */
            var toastRef = new NxMessageToastRef(componentRef.instance, overlayRef);
            this._animateToast(toastRef, currentConfig);
            this._oldToastMessageRef = toastRef;
            return this._oldToastMessageRef;
        };
        /** Creates and dispatches a message toastwith a custom template for the content.
         *
         * @param template Template to be used for the message toast.
         * @param config Extra configuration for the message toast.
        */
        /**
         * Creates and dispatches a message toastwith a custom template for the content.
         *
         * @param {?} template Template to be used for the message toast.
         * @param {?=} config Extra configuration for the message toast.
         * @return {?}
         */
        NxMessageToastService.prototype.openFromTemplate = /**
         * Creates and dispatches a message toastwith a custom template for the content.
         *
         * @param {?} template Template to be used for the message toast.
         * @param {?=} config Extra configuration for the message toast.
         * @return {?}
         */
        function (template, config) {
            /** @type {?} */
            var currentConfig = __assign({}, new NxMessageToastConfig(), this._defaultConfig, config);
            /** @type {?} */
            var overlayRef = this._createOverlay(currentConfig);
            /** @type {?} */
            var container = this._attachToastComponent(overlayRef, currentConfig);
            /** @type {?} */
            var toastRef = new NxMessageToastRef(container, overlayRef);
            /** @type {?} */
            var portal$1 = new portal.TemplatePortal(template, (/** @type {?} */ (null)), toastRef);
            container.attachTemplatePortal(portal$1);
            this._animateToast(toastRef, currentConfig);
            this._oldToastMessageRef = toastRef;
            return this._oldToastMessageRef;
        };
        // Attaches the message toastcontainer component to the overlay.
        // Attaches the message toastcontainer component to the overlay.
        /**
         * @private
         * @param {?} overlayRef
         * @param {?} config
         * @return {?}
         */
        NxMessageToastService.prototype._attachToastComponent = 
        // Attaches the message toastcontainer component to the overlay.
        /**
         * @private
         * @param {?} overlayRef
         * @param {?} config
         * @return {?}
         */
        function (overlayRef, config) {
            /** @type {?} */
            var injector = this._createInjector(config, null, this._injector);
            /** @type {?} */
            var containerPortal = new portal.ComponentPortal(NxMessageToastComponent, null, injector);
            /** @type {?} */
            var containerRef = overlayRef.attach(containerPortal);
            containerRef.instance.config = config;
            return containerRef.instance;
        };
        // Creates a new overlay and places it in the correct place.
        // Creates a new overlay and places it in the correct place.
        /**
         * @private
         * @param {?} config
         * @return {?}
         */
        NxMessageToastService.prototype._createOverlay = 
        // Creates a new overlay and places it in the correct place.
        /**
         * @private
         * @param {?} config
         * @return {?}
         */
        function (config) {
            /** @type {?} */
            var overlayConfig = new overlay.OverlayConfig();
            /** @type {?} */
            var positionStrategy = this._overlay.position().global();
            positionStrategy.bottom('0');
            positionStrategy.centerHorizontally();
            overlayConfig.positionStrategy = positionStrategy;
            return this._overlay.create(overlayConfig);
        };
        /** Animates the old message toastout and the new one in. */
        /**
         * Animates the old message toastout and the new one in.
         * @private
         * @param {?} toastRef
         * @param {?} config
         * @return {?}
         */
        NxMessageToastService.prototype._animateToast = /**
         * Animates the old message toastout and the new one in.
         * @private
         * @param {?} toastRef
         * @param {?} config
         * @return {?}
         */
        function (toastRef, config) {
            var _this = this;
            // When the message toastis dismissed, clear the reference to it.
            toastRef.afterDismissed().subscribe((/**
             * @return {?}
             */
            function () {
                // Clear the message toastref if it hasn't already been replaced by a newer message toast.
                if (_this._oldToastMessageRef === toastRef) {
                    _this._oldToastMessageRef = null;
                }
                if (config.announcementMessage) {
                    _this._live.clear();
                }
            }));
            if (this._oldToastMessageRef) {
                // If a message toastis opened, dismiss it and enter the
                // new message toastafter exit animation is complete.
                this._oldToastMessageRef.afterDismissed().subscribe((/**
                 * @return {?}
                 */
                function () {
                    toastRef.toastInstance.enter();
                }));
                this._oldToastMessageRef.dismiss();
            }
            else {
                // If no message toastis in view, enter the message toast.
                toastRef.toastInstance.enter();
            }
            // If a message toastduration is provided, set up dismiss based on after the message toastis opened.
            if (config.duration && config.duration > 0) {
                toastRef.afterOpened().subscribe((/**
                 * @return {?}
                 */
                function () { return toastRef._dismissAfter((/** @type {?} */ (config.duration))); }));
            }
            if (config.announcementMessage) {
                this._live.announce(config.announcementMessage, config.politeness);
            }
        };
        /**
         * @private
         * @param {?} config
         * @param {?} data
         * @param {?} injector
         * @return {?}
         */
        NxMessageToastService.prototype._createInjector = /**
         * @private
         * @param {?} config
         * @param {?} data
         * @param {?} injector
         * @return {?}
         */
        function (config, data, injector) {
            /** @type {?} */
            var tokens = new WeakMap();
            tokens.set(NxMessageToastConfig, config);
            tokens.set(NxMessageToastData, data);
            return new portal.PortalInjector(injector, tokens);
        };
        /**
         * Dismisses the currently visible message toast.
         */
        /**
         * Dismisses the currently visible message toast.
         * @return {?}
         */
        NxMessageToastService.prototype.dismiss = /**
         * Dismisses the currently visible message toast.
         * @return {?}
         */
        function () {
            if (this._oldToastMessageRef) {
                this._oldToastMessageRef.dismiss();
            }
        };
        /**
         * @return {?}
         */
        NxMessageToastService.prototype.ngOnDestroy = /**
         * @return {?}
         */
        function () {
            if (this._toastRefAtThisLevel) {
                this._toastRefAtThisLevel.dismiss();
            }
        };
        NxMessageToastService.decorators = [
            { type: core.Injectable, args: [{ providedIn: NxMessageModule },] }
        ];
        /** @nocollapse */
        NxMessageToastService.ctorParameters = function () { return [
            { type: overlay.Overlay },
            { type: core.Injector },
            { type: a11y.LiveAnnouncer },
            { type: NxMessageToastService, decorators: [{ type: core.Optional }, { type: core.SkipSelf }] },
            { type: NxMessageToastConfig, decorators: [{ type: core.Optional }, { type: core.Inject, args: [NX_MESSAGE_TOAST_DEFAULT_CONFIG,] }] }
        ]; };
        /** @nocollapse */ NxMessageToastService.ngInjectableDef = core.defineInjectable({ factory: function NxMessageToastService_Factory() { return new NxMessageToastService(core.inject(overlay.Overlay), core.inject(core.INJECTOR), core.inject(a11y.LiveAnnouncer), core.inject(NxMessageToastService, 12), core.inject(NX_MESSAGE_TOAST_DEFAULT_CONFIG, 8)); }, token: NxMessageToastService, providedIn: NxMessageModule });
        return NxMessageToastService;
    }());
    if (false) {
        /**
         * Reference to the current message toast in the view *at this level* (in the Angular injector tree).
         * If there is a parent message toast service, all operations should delegate to that parent
         * via `_oldToastMessageRef`.
         * @type {?}
         * @private
         */
        NxMessageToastService.prototype._toastRefAtThisLevel;
        /**
         * @type {?}
         * @private
         */
        NxMessageToastService.prototype._overlay;
        /**
         * @type {?}
         * @private
         */
        NxMessageToastService.prototype._injector;
        /**
         * @type {?}
         * @private
         */
        NxMessageToastService.prototype._live;
        /**
         * @type {?}
         * @private
         */
        NxMessageToastService.prototype._parentMessageToastService;
        /**
         * @type {?}
         * @private
         */
        NxMessageToastService.prototype._defaultConfig;
    }

    /**
     * @fileoverview added by tsickle
     * Generated from: message/public-api.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * Generated from: message/index.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * Generated from: page-search/page-search.component.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var NxPageSearchComponent = /** @class */ (function () {
        function NxPageSearchComponent(_changeDetectorRef) {
            this._changeDetectorRef = _changeDetectorRef;
            /**
             * An event emitted when the user clicks the search button.
             */
            this.buttonClick = new core.EventEmitter();
            this._buttonLabel = null;
            this._hideSearchButton = false;
            this._buttonLayout = '12,12,12,2';
            this._contentLayout = null;
        }
        Object.defineProperty(NxPageSearchComponent.prototype, "buttonLabel", {
            get: /**
             * @return {?}
             */
            function () {
                return this._buttonLabel;
            },
            /** Sets the text label of the button. */
            set: /**
             * Sets the text label of the button.
             * @param {?} value
             * @return {?}
             */
            function (value) {
                if (this._buttonLabel !== value) {
                    this._buttonLabel = value;
                    this._changeDetectorRef.markForCheck();
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NxPageSearchComponent.prototype, "hideSearchButton", {
            get: /**
             * @return {?}
             */
            function () {
                return this._hideSearchButton;
            },
            /** Whether the search button should be hidden. */
            set: /**
             * Whether the search button should be hidden.
             * @param {?} value
             * @return {?}
             */
            function (value) {
                this._hideSearchButton = coercion.coerceBooleanProperty(value);
                this._changeDetectorRef.markForCheck();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NxPageSearchComponent.prototype, "buttonLayout", {
            get: /**
             * @return {?}
             */
            function () {
                return this._buttonLayout;
            },
            /** Layout of the search button inside of a NxGrid. Default: 12,12,12,2. */
            set: /**
             * Layout of the search button inside of a NxGrid. Default: 12,12,12,2.
             * @param {?} value
             * @return {?}
             */
            function (value) {
                if (this._buttonLayout !== value) {
                    this._buttonLayout = value;
                    this._changeDetectorRef.markForCheck();
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NxPageSearchComponent.prototype, "contentLayout", {
            get: /**
             * @return {?}
             */
            function () {
                if (this._contentLayout) {
                    return this._contentLayout;
                }
                return !this.hideSearchButton ? '12,12,12,10' : '12';
            },
            /** Layout of the content area inside of a NxGrid. Default: 12,12,12,10 | 12 (if search button is hidden). */
            set: /**
             * Layout of the content area inside of a NxGrid. Default: 12,12,12,10 | 12 (if search button is hidden).
             * @param {?} value
             * @return {?}
             */
            function (value) {
                if (this._contentLayout !== value) {
                    this._contentLayout = value;
                    this._changeDetectorRef.markForCheck();
                }
            },
            enumerable: true,
            configurable: true
        });
        /** @docs-private */
        /**
         * \@docs-private
         * @return {?}
         */
        NxPageSearchComponent.prototype.onButtonClick = /**
         * \@docs-private
         * @return {?}
         */
        function () {
            this.buttonClick.emit();
        };
        NxPageSearchComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'nx-page-search',
                        template: "<div class=\"nx-pagesearch\">\n  <div nxLayout=\"grid\">\n    <div nxRow>\n      <div [nxCol]=\"contentLayout\" class=\"nx-pagesearch--content\">\n        <ng-content></ng-content>\n      </div>\n      <div [nxCol]=\"buttonLayout\" *ngIf=\"!hideSearchButton\" class=\"nx-pagesearch__actions\">\n        <button nxButton=\"primary medium\" (click)=\"onButtonClick()\" type=\"button\">{{buttonLabel}}</button>\n      </div>\n    </div>\n  </div>\n</div>\n",
                        changeDetection: core.ChangeDetectionStrategy.OnPush,
                        host: {
                            '[attr.role]': '"search"'
                        },
                        styles: [".nx-pagesearch{padding:32px 0;background:#fff;background:var(--page-search-background-color,#fff);box-shadow:0 2px 4px rgba(65,65,65,.5);box-shadow:var(--page-search-box-shadow,0 2px 4px rgba(65,65,65,.5))}.nx-pagesearch ::ng-deep .nx-formfield__wrapper{padding-bottom:0}.nx-pagesearch ::ng-deep .c-input{height:auto;font-size:30px;font-size:var(--page-search-font-size,30px);line-height:36px;line-height:var(--page-search-line-height,36px);font-weight:600;font-weight:var(--page-search-font-weight,600);letter-spacing:.3px;letter-spacing:var(--page-search-letter-spacing,.3px)}.nx-pagesearch ::ng-deep .c-input.is-filled{font-weight:600}.nx-pagesearch ::ng-deep .c-input::-webkit-input-placeholder{font-weight:300}.nx-pagesearch ::ng-deep .c-input::-moz-placeholder{font-weight:300}.nx-pagesearch ::ng-deep .c-input:-ms-input-placeholder{font-weight:300}.nx-pagesearch ::ng-deep .c-input::-ms-input-placeholder{font-weight:300}.nx-pagesearch ::ng-deep .c-input::placeholder{font-weight:300}.nx-pagesearch ::ng-deep .nx-formfield__input-container{align-items:center}.nx-pagesearch ::ng-deep .nx-formfield__prefix,.nx-pagesearch ::ng-deep .nx-formfield__suffix{color:#007ab3;color:var(--page-search-icon-color,#007ab3)}.nx-pagesearch ::ng-deep .nx-formfield__suffix{cursor:pointer}.nx-pagesearch ::ng-deep button{margin:0}.nx-pagesearch ::ng-deep .nx-icon--auto{font-size:24px}.nx-pagesearch .nx-pagesearch__actions{display:flex;align-items:center;margin-top:0}@media (max-width:991px){.nx-pagesearch .nx-pagesearch__actions{margin-top:16px}}"]
                    }] }
        ];
        /** @nocollapse */
        NxPageSearchComponent.ctorParameters = function () { return [
            { type: core.ChangeDetectorRef }
        ]; };
        NxPageSearchComponent.propDecorators = {
            buttonClick: [{ type: core.Output, args: ['nxButtonClick',] }],
            buttonLabel: [{ type: core.Input, args: ['nxButtonLabel',] }],
            hideSearchButton: [{ type: core.Input, args: ['nxHideSearchButton',] }],
            buttonLayout: [{ type: core.Input, args: ['nxButtonLayout',] }],
            contentLayout: [{ type: core.Input, args: ['nxContentLayout',] }]
        };
        return NxPageSearchComponent;
    }());
    if (false) {
        /**
         * An event emitted when the user clicks the search button.
         * @type {?}
         */
        NxPageSearchComponent.prototype.buttonClick;
        /**
         * @type {?}
         * @private
         */
        NxPageSearchComponent.prototype._buttonLabel;
        /**
         * @type {?}
         * @private
         */
        NxPageSearchComponent.prototype._hideSearchButton;
        /**
         * @type {?}
         * @private
         */
        NxPageSearchComponent.prototype._buttonLayout;
        /**
         * @type {?}
         * @private
         */
        NxPageSearchComponent.prototype._contentLayout;
        /**
         * @type {?}
         * @private
         */
        NxPageSearchComponent.prototype._changeDetectorRef;
    }

    /**
     * @fileoverview added by tsickle
     * Generated from: page-search/page-search.module.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var NxPageSearchModule = /** @class */ (function () {
        function NxPageSearchModule() {
        }
        NxPageSearchModule.decorators = [
            { type: core.NgModule, args: [{
                        imports: [
                            common.CommonModule,
                            autocomplete.NxAutocompleteModule,
                            formfield.NxFormfieldModule,
                            button.NxButtonModule,
                            grid.NxGridModule
                        ],
                        declarations: [
                            NxPageSearchComponent
                        ],
                        exports: [
                            NxPageSearchComponent
                        ]
                    },] }
        ];
        return NxPageSearchModule;
    }());

    /**
     * @fileoverview added by tsickle
     * Generated from: page-search/public-api.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * Generated from: rating/rating.component.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var NxRatingComponent = /** @class */ (function () {
        function NxRatingComponent(_changeDetectorRef) {
            this._changeDetectorRef = _changeDetectorRef;
            this._value = 0;
            this._disabled = false;
            this._negative = false;
            this._startLabel = null;
            this._endLabel = null;
            this._ariaLabel = ['1/5', '2/5', '3/5', '4/5', '5/5'];
            /**
             * An event is dispatched each time when the rating changes.
             */
            this.valueChange = new core.EventEmitter();
            this.onTouchedCallback = (/**
             * @return {?}
             */
            function () { });
            this.onChangeCallback = (/**
             * @param {?} option
             * @return {?}
             */
            function (option) { });
        }
        Object.defineProperty(NxRatingComponent.prototype, "value", {
            get: /**
             * @return {?}
             */
            function () {
                return this._value;
            },
            /** Sets the selected rating 1 - 5. */
            set: /**
             * Sets the selected rating 1 - 5.
             * @param {?} newValue
             * @return {?}
             */
            function (newValue) {
                this._value = coercion.coerceNumberProperty(newValue);
                this._changeDetectorRef.markForCheck();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NxRatingComponent.prototype, "disabled", {
            get: /**
             * @return {?}
             */
            function () {
                return this._disabled;
            },
            /** Whether the rating component should be disabled. */
            set: /**
             * Whether the rating component should be disabled.
             * @param {?} newValue
             * @return {?}
             */
            function (newValue) {
                if (this._disabled === newValue) {
                    return;
                }
                this._disabled = coercion.coerceBooleanProperty(newValue);
                this._changeDetectorRef.markForCheck();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NxRatingComponent.prototype, "negative", {
            get: /**
             * @return {?}
             */
            function () {
                return this._negative;
            },
            /** Whether the negative colors be used. */
            set: /**
             * Whether the negative colors be used.
             * @param {?} newValue
             * @return {?}
             */
            function (newValue) {
                if (this._negative === newValue) {
                    return;
                }
                this._negative = coercion.coerceBooleanProperty(newValue);
                this._changeDetectorRef.markForCheck();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NxRatingComponent.prototype, "startLabel", {
            get: /**
             * @return {?}
             */
            function () {
                return this._startLabel;
            },
            /** Sets the label painted at the start of the rating component. */
            set: /**
             * Sets the label painted at the start of the rating component.
             * @param {?} newValue
             * @return {?}
             */
            function (newValue) {
                this._startLabel = newValue;
                this._changeDetectorRef.markForCheck();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NxRatingComponent.prototype, "endLabel", {
            get: /**
             * @return {?}
             */
            function () {
                return this._endLabel;
            },
            /** Sets the label painted at the end of the rating component. */
            set: /**
             * Sets the label painted at the end of the rating component.
             * @param {?} newValue
             * @return {?}
             */
            function (newValue) {
                this._endLabel = newValue;
                this._changeDetectorRef.markForCheck();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NxRatingComponent.prototype, "ariaLabel", {
            get: /**
             * @return {?}
             */
            function () {
                return this._ariaLabel;
            },
            set: /**
             * @param {?} newAriaLabels
             * @return {?}
             */
            function (newAriaLabels) {
                this._ariaLabel = newAriaLabels;
                this._changeDetectorRef.markForCheck();
            },
            enumerable: true,
            configurable: true
        });
        /** Whether the given rating is selected. */
        /**
         * Whether the given rating is selected.
         * @param {?} index
         * @return {?}
         */
        NxRatingComponent.prototype.isSelected = /**
         * Whether the given rating is selected.
         * @param {?} index
         * @return {?}
         */
        function (index) {
            return index <= this.value;
        };
        /** Allows to set the rating. */
        /**
         * Allows to set the rating.
         * @param {?} value
         * @return {?}
         */
        NxRatingComponent.prototype.setSelection = /**
         * Allows to set the rating.
         * @param {?} value
         * @return {?}
         */
        function (value) {
            if (!this.disabled) {
                this.value = value;
                this.valueChange.emit(value);
                this.onTouchedCallback();
                this.onChangeCallback(this.value);
            }
        };
        /** @docs-private */
        /**
         * \@docs-private
         * @param {?} event
         * @param {?} rating
         * @return {?}
         */
        NxRatingComponent.prototype.handleKeyUp = /**
         * \@docs-private
         * @param {?} event
         * @param {?} rating
         * @return {?}
         */
        function (event, rating) {
            /** @type {?} */
            var keyCode = event.keyCode;
            event.preventDefault();
            event.stopPropagation();
            if (keyCode === keycodes.ENTER) {
                this.setSelection(rating);
            }
            if (keyCode === keycodes.RIGHT_ARROW) {
                this.value = Math.min(this.value + 1, 5);
                /** @type {?} */
                var elementRef = this.icons.toArray()[this.value - 1];
                elementRef.nativeElement.focus();
            }
            if (keyCode === keycodes.LEFT_ARROW) {
                this.value = Math.max(this.value - 1, 1);
                /** @type {?} */
                var elementRef = this.icons.toArray()[this.value - 1];
                elementRef.nativeElement.focus();
            }
        };
        /**
         * @param {?} value
         * @return {?}
         */
        NxRatingComponent.prototype.writeValue = /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this.value = value;
        };
        /**
         * @param {?} callback
         * @return {?}
         */
        NxRatingComponent.prototype.registerOnChange = /**
         * @param {?} callback
         * @return {?}
         */
        function (callback) {
            this.onChangeCallback = callback;
        };
        /**
         * @param {?} callback
         * @return {?}
         */
        NxRatingComponent.prototype.registerOnTouched = /**
         * @param {?} callback
         * @return {?}
         */
        function (callback) {
            this.onTouchedCallback = callback;
        };
        /**
         * @param {?} isDisabled
         * @return {?}
         */
        NxRatingComponent.prototype.setDisabledState = /**
         * @param {?} isDisabled
         * @return {?}
         */
        function (isDisabled) {
            this.disabled = isDisabled;
        };
        /** @docs-private */
        /**
         * \@docs-private
         * @param {?} rating
         * @return {?}
         */
        NxRatingComponent.prototype.getAriaLabel = /**
         * \@docs-private
         * @param {?} rating
         * @return {?}
         */
        function (rating) {
            return this.ariaLabel[rating - 1];
        };
        /** @docs-private */
        /**
         * \@docs-private
         * @param {?} rating
         * @return {?}
         */
        NxRatingComponent.prototype.getIconName = /**
         * \@docs-private
         * @param {?} rating
         * @return {?}
         */
        function (rating) {
            return 'star' + ((!this.isSelected(rating)) ? '-o' : '');
        };
        NxRatingComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'nx-rating',
                        template: "  <div class=\"nx-rating__container\" role=\"radiogroup\">\n    <nx-icon *ngFor=\"let rating of [1,2,3,4,5]\"\n      (click)=\"setSelection(rating)\"\n      (keyup)=\"handleKeyUp($event, rating)\"\n      role=\"radio\"\n      [attr.aria-label]=\"getAriaLabel(rating)\"\n      [attr.aria-checked]=\"isSelected(rating)\"\n      [tabindex]=\"disabled ? -1 : 0\"\n      class=\"nx-rating__icon\"\n      [name]=\"getIconName(rating)\"\n      size=\"m\">\n    </nx-icon>\n  </div>\n  <div class=\"nx-rating__label\" *ngIf=\"startLabel || endLabel\">\n    <span class=\"nx-rating__label--start\">{{startLabel}}</span>\n    <span class=\"nx-rating__label--end\">{{endLabel}}</span>\n  </div>\n",
                        changeDetection: core.ChangeDetectionStrategy.OnPush,
                        providers: [
                            {
                                provide: forms.NG_VALUE_ACCESSOR,
                                useExisting: core.forwardRef((/**
                                 * @return {?}
                                 */
                                function () { return NxRatingComponent; })),
                                multi: true
                            }
                        ],
                        host: {
                            '[class.nx-rating--negative]': 'negative',
                            '[class.nx-rating--disabled]': 'disabled',
                        },
                        styles: [":host{display:inline-block}:host(.nx-rating--negative) .nx-rating__icon,:host(.nx-rating--negative) .nx-rating__label{color:#fff}:host(.nx-rating--disabled){cursor:not-allowed;outline:0}:host(.nx-rating--disabled) .nx-rating__label{color:#c2c2c2;color:var(--rating-disabled-label-color,#c2c2c2)}:host(.nx-rating--disabled) .nx-rating__icon{color:#c2c2c2;color:var(--rating-disabled-icon-color,#c2c2c2);cursor:not-allowed}.nx-rating__container{display:flex}.nx-rating__label{display:flex;font-size:16px;font-size:var(--rating-label-font-size,16px);line-height:24px;line-height:var(--rating-label-line-height,24px);font-weight:400;font-weight:var(--rating-label-font-weight,400);letter-spacing:0;letter-spacing:var(--rating-label-letter-spacing,0);color:#414141;color:var(--rating-label-color,#414141)}.nx-rating__label--end{margin-left:auto}.nx-rating__icon{font-size:40px;font-size:var(--rating-icon-size,40px);color:#414141;color:var(--rating-icon-color,#414141);width:auto;background:0 0;border:none;margin-right:16px;cursor:pointer;outline:0}.nx-rating__icon:last-child{margin-right:0}:host-context([data-whatinput=keyboard]) .nx-rating__icon:focus{box-shadow:0 0 0 2px #fff,0 0 0 6px #009de6;box-shadow:var(--focus-box-shadow,0 0 0 2px #fff,0 0 0 6px #009de6);border-radius:4px}@media screen and (-ms-high-contrast:active){:host-context([data-whatinput=keyboard]) .nx-rating__icon:focus{box-shadow:0 0 0 2px background,0 0 0 6px windowText}.nx-rating__icon{color:buttonText}:host(.nx-rating--disabled) .nx-rating__icon,:host(.nx-rating--disabled) .nx-rating__label{color:GrayText}.nx-rating__label{-ms-high-contrast-adjust:none}}"]
                    }] }
        ];
        /** @nocollapse */
        NxRatingComponent.ctorParameters = function () { return [
            { type: core.ChangeDetectorRef }
        ]; };
        NxRatingComponent.propDecorators = {
            value: [{ type: core.Input, args: ['nxValue',] }],
            disabled: [{ type: core.Input, args: ['nxDisabled',] }],
            negative: [{ type: core.Input, args: ['nxNegative',] }],
            startLabel: [{ type: core.Input, args: ['nxStartLabel',] }],
            endLabel: [{ type: core.Input, args: ['nxEndLabel',] }],
            ariaLabel: [{ type: core.Input, args: ['nxAriaLabel',] }],
            valueChange: [{ type: core.Output, args: ['nxValueChange',] }],
            icons: [{ type: core.ViewChildren, args: [icon.NxIconComponent, { read: core.ElementRef },] }]
        };
        return NxRatingComponent;
    }());
    if (false) {
        /**
         * @type {?}
         * @private
         */
        NxRatingComponent.prototype._value;
        /**
         * @type {?}
         * @private
         */
        NxRatingComponent.prototype._disabled;
        /**
         * @type {?}
         * @private
         */
        NxRatingComponent.prototype._negative;
        /**
         * @type {?}
         * @private
         */
        NxRatingComponent.prototype._startLabel;
        /**
         * @type {?}
         * @private
         */
        NxRatingComponent.prototype._endLabel;
        /**
         * @type {?}
         * @private
         */
        NxRatingComponent.prototype._ariaLabel;
        /**
         * An event is dispatched each time when the rating changes.
         * @type {?}
         */
        NxRatingComponent.prototype.valueChange;
        /**
         * \@docs-private
         * @type {?}
         */
        NxRatingComponent.prototype.icons;
        /**
         * @type {?}
         * @private
         */
        NxRatingComponent.prototype.onTouchedCallback;
        /**
         * @type {?}
         * @private
         */
        NxRatingComponent.prototype.onChangeCallback;
        /**
         * @type {?}
         * @private
         */
        NxRatingComponent.prototype._changeDetectorRef;
    }

    /**
     * @fileoverview added by tsickle
     * Generated from: rating/rating.module.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var NxRatingModule = /** @class */ (function () {
        function NxRatingModule() {
        }
        NxRatingModule.decorators = [
            { type: core.NgModule, args: [{
                        imports: [
                            common.CommonModule,
                            icon.NxIconModule
                        ],
                        declarations: [
                            NxRatingComponent
                        ],
                        exports: [
                            NxRatingComponent
                        ]
                    },] }
        ];
        return NxRatingModule;
    }());

    /**
     * @fileoverview added by tsickle
     * Generated from: rating/public-api.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * Generated from: rating/index.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * Generated from: number-stepper/number-stepper-intl.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var NxNumberStepperIntl = /** @class */ (function () {
        function NxNumberStepperIntl() {
            /**
             * Stream that emits whenever the labels here are changed. Use this to notify
             * components if the labels have changed after initialization.
             */
            this.changes = new rxjs.Subject();
            /**
             * The aria label for the decrement '-' button
             */
            this.decrementAriaLabel = 'Decrement';
            /**
             * The aria label for the increment '+' button
             */
            this.incrementAriaLabel = 'Increment';
        }
        NxNumberStepperIntl.decorators = [
            { type: core.Injectable }
        ];
        return NxNumberStepperIntl;
    }());
    if (false) {
        /**
         * Stream that emits whenever the labels here are changed. Use this to notify
         * components if the labels have changed after initialization.
         * @type {?}
         */
        NxNumberStepperIntl.prototype.changes;
        /**
         * The aria label for the decrement '-' button
         * @type {?}
         */
        NxNumberStepperIntl.prototype.decrementAriaLabel;
        /**
         * The aria label for the increment '+' button
         * @type {?}
         */
        NxNumberStepperIntl.prototype.incrementAriaLabel;
    }

    /**
     * @fileoverview added by tsickle
     * Generated from: number-stepper/auto-resize.directive.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * \@docs-private
     */
    var NxAutoResizeDirective = /** @class */ (function () {
        function NxAutoResizeDirective(_element, _renderer, _cdr) {
            this._element = _element;
            this._renderer = _renderer;
            this._cdr = _cdr;
            this._resize = true;
            this.updateInputWidth = this.updateInputWidth.bind(this);
        }
        Object.defineProperty(NxAutoResizeDirective.prototype, "resize", {
            get: /**
             * @return {?}
             */
            function () {
                return this._resize;
            },
            set: /**
             * @param {?} value
             * @return {?}
             */
            function (value) {
                this._resize = coercion.coerceBooleanProperty(value);
                if (this._resize) {
                    this._addEventListener();
                    this.updateInputWidth();
                }
                else {
                    this._removeEventListener();
                }
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        NxAutoResizeDirective.prototype.ngAfterViewInit = /**
         * @return {?}
         */
        function () {
            if (this.resize) {
                this._addEventListener();
            }
        };
        /**
         * @return {?}
         */
        NxAutoResizeDirective.prototype.ngOnDestroy = /**
         * @return {?}
         */
        function () {
            this._removeEventListener();
        };
        /**
         * @return {?}
         */
        NxAutoResizeDirective.prototype.updateInputWidth = /**
         * @return {?}
         */
        function () {
            /** @type {?} */
            var measureCanvas = this._renderer.createElement('canvas');
            /** @type {?} */
            var ctx = measureCanvas.getContext('2d');
            /** @type {?} */
            var styles = window.getComputedStyle(this._element.nativeElement);
            ctx.font = utils.getFontShorthand(styles);
            /** @type {?} */
            var metrics = ctx.measureText(this._element.nativeElement.value);
            /** @type {?} */
            var padding = this.sumStyles(styles.paddingLeft, styles.paddingRight);
            /** @type {?} */
            var border = this.sumStyles(styles.borderLeftWidth, styles.borderRightWidth);
            // the pixels are needed, because despite the correct calculation the last pixels of a number are always cut
            /** @type {?} */
            var newWidth = metrics.width + padding + border + 16;
            // Limit to own given minimal width
            /** @type {?} */
            var parsed = parseFloat(styles.minWidth);
            this.width = Math.max(Number.isNaN(parsed) ? 0 : parsed, newWidth);
            // needed when the outer component is onPush
            this._cdr.markForCheck();
        };
        /**
         * @return {?}
         */
        NxAutoResizeDirective.prototype._addEventListener = /**
         * @return {?}
         */
        function () {
            this._element.nativeElement.addEventListener('input', this.updateInputWidth, true);
            this._element.nativeElement.addEventListener('change', this.updateInputWidth, true);
        };
        /**
         * @return {?}
         */
        NxAutoResizeDirective.prototype._removeEventListener = /**
         * @return {?}
         */
        function () {
            this._element.nativeElement.removeEventListener('input', this.updateInputWidth, true);
            this._element.nativeElement.removeEventListener('change', this.updateInputWidth, true);
        };
        /**
         * @param {?} left
         * @param {?} right
         * @return {?}
         */
        NxAutoResizeDirective.prototype.sumStyles = /**
         * @param {?} left
         * @param {?} right
         * @return {?}
         */
        function (left, right) {
            left = parseInt(left, 10);
            right = parseInt(right, 10);
            left = Number.isNaN(left) ? 0 : left;
            right = Number.isNaN(right) ? 0 : right;
            return left + right;
        };
        NxAutoResizeDirective.decorators = [
            { type: core.Directive, args: [{
                        selector: 'input[nxAutoResize]'
                    },] }
        ];
        /** @nocollapse */
        NxAutoResizeDirective.ctorParameters = function () { return [
            { type: core.ElementRef },
            { type: core.Renderer2 },
            { type: core.ChangeDetectorRef }
        ]; };
        NxAutoResizeDirective.propDecorators = {
            width: [{ type: core.HostBinding, args: ['style.width.px',] }],
            resize: [{ type: core.Input, args: ['nxAutoResize',] }]
        };
        return NxAutoResizeDirective;
    }());
    if (false) {
        /** @type {?} */
        NxAutoResizeDirective.prototype.width;
        /**
         * @type {?}
         * @private
         */
        NxAutoResizeDirective.prototype._resize;
        /**
         * @type {?}
         * @private
         */
        NxAutoResizeDirective.prototype._element;
        /**
         * @type {?}
         * @private
         */
        NxAutoResizeDirective.prototype._renderer;
        /**
         * @type {?}
         * @private
         */
        NxAutoResizeDirective.prototype._cdr;
    }

    /**
     * @fileoverview added by tsickle
     * Generated from: number-stepper/number-stepper.component.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /** @type {?} */
    var SIZE_MAPPING = {
        big: 'nx-stepper--big',
        normal: ''
    };
    /** @type {?} */
    var DEFAULT_CLASSES$1 = ['nx-stepper'];
    /** @type {?} */
    var INPUT_CLASSES = ['nx-stepper__input'];
    /** @type {?} */
    var ALLOWED_CHARACTERS = new RegExp(/^-?[0-9]\d*(\.\d+)?$/g);
    /** @type {?} */
    var CUSTOM_VALUE_ACCESSOR = {
        provide: forms.NG_VALUE_ACCESSOR,
        useExisting: core.forwardRef((/**
         * @return {?}
         */
        function () { return NxNumberStepperComponent; })),
        multi: true
    };
    /** @type {?} */
    var CUSTOM_VALIDATOR = {
        provide: forms.NG_VALIDATORS,
        useExisting: core.forwardRef((/**
         * @return {?}
         */
        function () { return NxNumberStepperComponent; })),
        multi: true
    };
    /** @type {?} */
    var nextUniqueId = 0;
    var NxNumberStepperComponent = /** @class */ (function (_super) {
        __extends(NxNumberStepperComponent, _super);
        function NxNumberStepperComponent(_changeDetectorRef, _renderer, _elementRef, _intl) {
            var _this = _super.call(this, SIZE_MAPPING, DEFAULT_CLASSES$1, _elementRef, _renderer) || this;
            _this._changeDetectorRef = _changeDetectorRef;
            _this._intl = _intl;
            _this._step = 1;
            _this._min = 0;
            _this._max = 100;
            _this._value = 0;
            _this._label = null;
            _this._resize = false;
            _this._negative = false;
            _this._leadingZero = true;
            /**
             * \@docs-private
             */
            _this.inputClassNames = utils.mapClassNames('regular', INPUT_CLASSES);
            /**
             * \@docs-private
             */
            _this.inputId = "nx-number-stepper-" + nextUniqueId++;
            /**
             * \@docs-private
             */
            _this.ariaDescribedBy = null;
            /**
             * An event emitted on value change.
             */
            _this.valueChange = new core.EventEmitter();
            _this.onChangeCallback = (/**
             * @param {?} _
             * @return {?}
             */
            function (_) { });
            /**
             * \@docs-private
             */
            _this.onTouchedCallback = (/**
             * @return {?}
             */
            function () { });
            _this._intlSubscription = _this._intl.changes.subscribe((/**
             * @return {?}
             */
            function () { return _this._changeDetectorRef.markForCheck(); }));
            return _this;
        }
        Object.defineProperty(NxNumberStepperComponent.prototype, "resize", {
            get: /**
             * @return {?}
             */
            function () {
                return this._resize;
            },
            /** Whether the input should be resized. Default: false */
            set: /**
             * Whether the input should be resized. Default: false
             * @param {?} value
             * @return {?}
             */
            function (value) {
                this._resize = coercion.coerceBooleanProperty(value);
                this._changeDetectorRef.markForCheck();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NxNumberStepperComponent.prototype, "label", {
            get: /**
             * @return {?}
             */
            function () {
                return this._label;
            },
            /** Defines the the label shown above the stepper input. */
            set: /**
             * Defines the the label shown above the stepper input.
             * @param {?} value
             * @return {?}
             */
            function (value) {
                if (this._label !== value) {
                    this._label = value;
                    this._changeDetectorRef.markForCheck();
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NxNumberStepperComponent.prototype, "step", {
            get: /**
             * @return {?}
             */
            function () {
                return this._step;
            },
            /** Sets the step size. Default: 1 */
            set: /**
             * Sets the step size. Default: 1
             * @param {?} value
             * @return {?}
             */
            function (value) {
                // only internal changes no need to call markForCheck
                this._step = Number(value);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NxNumberStepperComponent.prototype, "min", {
            get: /**
             * @return {?}
             */
            function () {
                return this._min;
            },
            /** Sets the minimum accepted number. Default: 0 */
            set: /**
             * Sets the minimum accepted number. Default: 0
             * @param {?} value
             * @return {?}
             */
            function (value) {
                this._min = Number(value);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NxNumberStepperComponent.prototype, "max", {
            get: /**
             * @return {?}
             */
            function () {
                return this._max;
            },
            /** Sets the maximum accepted number. Default: 100 */
            set: /**
             * Sets the maximum accepted number. Default: 100
             * @param {?} value
             * @return {?}
             */
            function (value) {
                this._max = Number(value);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NxNumberStepperComponent.prototype, "value", {
            get: /**
             * @return {?}
             */
            function () {
                return this._value;
            },
            /** Sets the value of the number-stepper. */
            set: /**
             * Sets the value of the number-stepper.
             * @param {?} value
             * @return {?}
             */
            function (value) {
                this._value = value;
                if (this._value !== null) {
                    this.setInputValue(this._value);
                }
                else {
                    this.setInputValue(0);
                }
                this._changeDetectorRef.markForCheck();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NxNumberStepperComponent.prototype, "negative", {
            get: /**
             * @return {?}
             */
            function () {
                return this._negative;
            },
            /** Whether the negative set of styling should be used. */
            set: /**
             * Whether the negative set of styling should be used.
             * @param {?} value
             * @return {?}
             */
            function (value) {
                if (this._negative !== value) {
                    this._negative = coercion.coerceBooleanProperty(value);
                    this._changeDetectorRef.markForCheck();
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NxNumberStepperComponent.prototype, "leadingZero", {
            get: /**
             * @return {?}
             */
            function () {
                return this._leadingZero;
            },
            /** Whether the number stepper value should have a leading zero.
             *
             * Default value is true.
             */
            set: /**
             * Whether the number stepper value should have a leading zero.
             *
             * Default value is true.
             * @param {?} value
             * @return {?}
             */
            function (value) {
                if (this._leadingZero !== value) {
                    this._leadingZero = coercion.coerceBooleanProperty(value);
                    this.setInputValue(this.value);
                    this._changeDetectorRef.markForCheck();
                }
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        NxNumberStepperComponent.prototype.ngOnInit = /**
         * @return {?}
         */
        function () {
            this.setInputValue(this._value);
        };
        /**
         * @return {?}
         */
        NxNumberStepperComponent.prototype.ngAfterViewInit = /**
         * @return {?}
         */
        function () {
            if (this.ngContentWrapper) {
                this.ariaDescribedBy = this.ngContentWrapper.nativeElement.children.length > 0 ? "label-for-" + this.inputId : null;
            }
        };
        /**
         * @return {?}
         */
        NxNumberStepperComponent.prototype.ngOnDestroy = /**
         * @return {?}
         */
        function () {
            this._intlSubscription.unsubscribe();
        };
        /** @docs-private */
        /**
         * \@docs-private
         * @param {?} value
         * @return {?}
         */
        NxNumberStepperComponent.prototype.setInputValue = /**
         * \@docs-private
         * @param {?} value
         * @return {?}
         */
        function (value) {
            var _this = this;
            if (this.leadingZero) {
                this.numberInputValue = utils.pad(value.toString(), 2);
            }
            else {
                this.numberInputValue = value.toString();
            }
            // use timeout to get the current value of numberInputValue
            setTimeout((/**
             * @return {?}
             */
            function () {
                _this.triggerResize();
            }));
        };
        /* ControlValueAccessor Implementations */
        /* ControlValueAccessor Implementations */
        /**
         * @param {?} value
         * @return {?}
         */
        NxNumberStepperComponent.prototype.writeValue = /* ControlValueAccessor Implementations */
        /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this.value = value;
        };
        /**
         * @param {?} onChange
         * @return {?}
         */
        NxNumberStepperComponent.prototype.registerOnChange = /**
         * @param {?} onChange
         * @return {?}
         */
        function (onChange) {
            this.onChangeCallback = onChange;
        };
        /**
         * @param {?} onTouched
         * @return {?}
         */
        NxNumberStepperComponent.prototype.registerOnTouched = /**
         * @param {?} onTouched
         * @return {?}
         */
        function (onTouched) {
            this.onTouchedCallback = onTouched;
        };
        /** @docs-private */
        /**
         * \@docs-private
         * @param {?} event
         * @return {?}
         */
        NxNumberStepperComponent.prototype.onInputChange = /**
         * \@docs-private
         * @param {?} event
         * @return {?}
         */
        function (event) {
            if (!this.validateUserInput(event.target.value)) {
                this._value = null;
            }
            else {
                this._value = Number(event.target.value);
            }
            // setInputValue() should be called so that numberInputValue is updated with the user input
            if (this._value !== null) {
                this.setInputValue(this._value);
            }
            this.valueChange.emit(this._value);
            this.onChangeCallback(this._value);
        };
        /** @docs-private */
        /**
         * \@docs-private
         * @param {?} input
         * @return {?}
         */
        NxNumberStepperComponent.prototype.validateUserInput = /**
         * \@docs-private
         * @param {?} input
         * @return {?}
         */
        function (input) {
            return !!input.match(ALLOWED_CHARACTERS);
        };
        /** @docs-private */
        /**
         * \@docs-private
         * @return {?}
         */
        NxNumberStepperComponent.prototype.incrementOnClick = /**
         * \@docs-private
         * @return {?}
         */
        function () {
            this._increment();
            this.onTouchedCallback();
        };
        /** @docs-private */
        /**
         * \@docs-private
         * @return {?}
         */
        NxNumberStepperComponent.prototype.incrementOnKey = /**
         * \@docs-private
         * @return {?}
         */
        function () {
            this._increment();
        };
        /** @docs-private */
        /**
         * \@docs-private
         * @return {?}
         */
        NxNumberStepperComponent.prototype._increment = /**
         * \@docs-private
         * @return {?}
         */
        function () {
            /** @type {?} */
            var newValue;
            if (this.isBetweenLimits(this._value)) {
                newValue = this.getNextGreaterValue(this._value);
            }
            else {
                newValue = this.enforceLimits(this._value);
            }
            this.value = newValue;
            this.valueChange.emit(this._value);
            this.onChangeCallback(this._value);
        };
        /** @docs-private */
        /**
         * \@docs-private
         * @return {?}
         */
        NxNumberStepperComponent.prototype.triggerResize = /**
         * \@docs-private
         * @return {?}
         */
        function () {
            if (this.resize) {
                this.autoResize.updateInputWidth();
                this._changeDetectorRef.markForCheck();
            }
        };
        /** @docs-private */
        /**
         * \@docs-private
         * @return {?}
         */
        NxNumberStepperComponent.prototype.decrementOnClick = /**
         * \@docs-private
         * @return {?}
         */
        function () {
            this._decrement();
            this.onTouchedCallback();
        };
        /** @docs-private */
        /**
         * \@docs-private
         * @return {?}
         */
        NxNumberStepperComponent.prototype.decrementOnKey = /**
         * \@docs-private
         * @return {?}
         */
        function () {
            this._decrement();
        };
        /** @docs-private */
        /**
         * \@docs-private
         * @return {?}
         */
        NxNumberStepperComponent.prototype._decrement = /**
         * \@docs-private
         * @return {?}
         */
        function () {
            /** @type {?} */
            var newValue;
            if (this.isBetweenLimits(this._value)) {
                newValue = this.getNextLowerValue(this._value);
            }
            else {
                newValue = this.enforceLimits(this._value);
            }
            this.value = newValue;
            this.valueChange.emit(this._value);
            this.onChangeCallback(this._value);
        };
        /** @docs-private */
        /**
         * \@docs-private
         * @param {?} value
         * @return {?}
         */
        NxNumberStepperComponent.prototype.enforceLimits = /**
         * \@docs-private
         * @param {?} value
         * @return {?}
         */
        function (value) {
            if (value > this._max) {
                return this._max;
            }
            else if (value < this._min) {
                return this._min;
            }
            return value;
        };
        /** @docs-private */
        /**
         * \@docs-private
         * @param {?} start
         * @return {?}
         */
        NxNumberStepperComponent.prototype.getNextLowerValue = /**
         * \@docs-private
         * @param {?} start
         * @return {?}
         */
        function (start) {
            // if there is an invalid input start is null
            if (!start) {
                start = 0;
            }
            /** @type {?} */
            var next;
            if (this.isValidStep(start)) {
                next = (new decimal_js.Decimal(start).minus(new decimal_js.Decimal(this._step))).toNumber();
            }
            else {
                next = new decimal_js.Decimal(start).toNearest(this._step, decimal_js.Decimal.ROUND_DOWN).toNumber();
            }
            return this.enforceLimits(next);
        };
        /** @docs-private */
        /**
         * \@docs-private
         * @param {?} start
         * @return {?}
         */
        NxNumberStepperComponent.prototype.getNextGreaterValue = /**
         * \@docs-private
         * @param {?} start
         * @return {?}
         */
        function (start) {
            /** @type {?} */
            var next;
            if (!start) {
                start = 0;
            }
            if (this.isValidStep(start)) {
                next = (new decimal_js.Decimal(start).plus(new decimal_js.Decimal(this._step))).toNumber();
            }
            else {
                next = new decimal_js.Decimal(start).toNearest(this._step, decimal_js.Decimal.ROUND_UP).toNumber();
            }
            return this.enforceLimits(next);
        };
        /** @docs-private */
        /**
         * \@docs-private
         * @param {?} value
         * @return {?}
         */
        NxNumberStepperComponent.prototype.isBetweenLimits = /**
         * \@docs-private
         * @param {?} value
         * @return {?}
         */
        function (value) {
            return value <= this._max && value >= this._min;
        };
        /** @docs-private */
        /**
         * \@docs-private
         * @return {?}
         */
        NxNumberStepperComponent.prototype.isMinimum = /**
         * \@docs-private
         * @return {?}
         */
        function () {
            return this._value === this._min;
        };
        /** @docs-private */
        /**
         * \@docs-private
         * @return {?}
         */
        NxNumberStepperComponent.prototype.isMaximum = /**
         * \@docs-private
         * @return {?}
         */
        function () {
            return this._value === this._max;
        };
        /** @docs-private */
        /**
         * \@docs-private
         * @param {?} value
         * @return {?}
         */
        NxNumberStepperComponent.prototype.isValidStep = /**
         * \@docs-private
         * @param {?} value
         * @return {?}
         */
        function (value) {
            if (value === null) {
                value = new decimal_js.Decimal(0);
            }
            /** @type {?} */
            var min = new decimal_js.Decimal(this._min);
            /** @type {?} */
            var valueDec = new decimal_js.Decimal(value);
            /** @type {?} */
            var checkValue = (min.minus(valueDec)).mod(new decimal_js.Decimal(this._step)).toNumber();
            if (this.isBetweenLimits(value) && ((this.isMinimum() || this.isMaximum()) ||
                checkValue === 0)) {
                return true;
            }
            return false;
        };
        /** @docs-private */
        /**
         * \@docs-private
         * @param {?} value
         * @return {?}
         */
        NxNumberStepperComponent.prototype.userInputToNumber = /**
         * \@docs-private
         * @param {?} value
         * @return {?}
         */
        function (value) {
            /** @type {?} */
            var current = value === '' ? 0 : value;
            return parseInt(current, 10);
        };
        /**
         * @return {?}
         */
        NxNumberStepperComponent.prototype._validateFn = /**
         * @return {?}
         */
        function () {
            // the manual user input must match min + n * step, e.g. minimum 1 step 2: 1, 3, 5, 7 etc.
            if (!this.isValidStep(this._value)) {
                return { nxNumberStepperStepError: 'Value is not a valid step' };
            }
            else if (this._value === null) {
                return { nxNumberStepperFormatError: 'Not a valid number' };
            }
            return null;
        };
        /** @docs-private */
        /**
         * \@docs-private
         * @param {?} c
         * @return {?}
         */
        NxNumberStepperComponent.prototype.validate = /**
         * \@docs-private
         * @param {?} c
         * @return {?}
         */
        function (c) {
            return this._validateFn();
        };
        Object.defineProperty(NxNumberStepperComponent.prototype, "_buttonType", {
            get: /**
             * @return {?}
             */
            function () {
                return 'secondary' + (this.negative ? ' negative' : '');
            },
            enumerable: true,
            configurable: true
        });
        NxNumberStepperComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'nx-number-stepper',
                        template: "<div *ngIf=\"label\" class=\"nx-stepper__label\">\n  <label [for]=\"inputId\">\n    {{label}}\n  </label>\n</div>\n<div class=\"nx-stepper__label\" #customLabel *ngIf=\"!label\" [id]=\"ariaDescribedBy\">\n  <ng-content></ng-content>\n</div>\n<div class=\"nx-stepper__input-container\">\n  <button\n    [attr.aria-label]=\"_intl.decrementAriaLabel\"\n    [nxButton]=\"_buttonType\"\n    class=\"nx-stepper__down nx-stepper__control\"\n    (click)=\"decrementOnClick()\"\n    [disabled]=\"value <= min\"\n    type=\"button\">\n    <nx-icon name=\"minus\" size=\"s\"></nx-icon>\n  </button>\n  <div class=\"nx-stepper__input-wrapper\">\n    <div class=\"nx-stepper__inner-wrapper\">\n        <ng-content select=\"nx-number-stepper-prefix\"></ng-content>\n\n        <input [nxAutoResize]=\"resize\" [value]=\"numberInputValue\"\n        [attr.aria-describedby]=\"ariaDescribedBy\"\n        [id]=\"inputId\" [ngClass]=\"inputClassNames\"\n        (input)=\"onInputChange($event)\"\n        (keydown.arrowup)=\"incrementOnKey()\"\n        (keydown.arrowdown)=\"decrementOnKey()\"\n        (blur)=\"onTouchedCallback()\"/>\n\n        <ng-content select=\"nx-number-stepper-suffix\"></ng-content>\n    </div>\n    <div class=\"nx-stepper__input-underline\"></div>\n  </div>\n\n  <button\n    [attr.aria-label]=\"_intl.incrementAriaLabel\"\n    [nxButton]=\"_buttonType\"\n    class=\"nx-stepper__up nx-stepper__control\"\n    (click)=\"incrementOnClick()\"\n    [disabled]=\"value >= max\"\n    type=\"button\">\n    <nx-icon name=\"plus\" size=\"s\"></nx-icon>\n  </button>\n</div>\n",
                        changeDetection: core.ChangeDetectionStrategy.OnPush,
                        inputs: ['classNames: nxSize'],
                        host: {
                            '[class.is-negative]': 'negative'
                        },
                        providers: [CUSTOM_VALUE_ACCESSOR, CUSTOM_VALIDATOR],
                        styles: [":host{display:block}:host input{padding:0}.nx-stepper__input-container{align-items:flex-end;display:flex;margin-top:12px}.nx-stepper__label{display:flex;font-size:20px;font-size:var(--number-stepper-label-font-size,20px);line-height:28px;line-height:var(--number-stepper-label-line-height,28px);font-weight:400;font-weight:var(--number-stepper-label-font-weight,400);letter-spacing:.2px;letter-spacing:var(--number-stepper-label-letter-spacing,.2px)}.nx-stepper__control{width:32px;height:32px;min-height:32px;font-size:24px;margin:0;padding:0}.nx-stepper__input{width:56px;min-width:56px}.nx-stepper__input,::ng-deep .nx-stepper__prefix,::ng-deep .nx-stepper__suffix{font-size:20px;font-size:var(--number-stepper-small-font-size,20px);line-height:28px;line-height:var(--number-stepper-small-line-height,28px);font-weight:400;font-weight:var(--number-stepper-small-font-weight,400);letter-spacing:.2px;letter-spacing:var(--number-stepper-small-letter-spacing,.2px);color:#414141;color:var(--number-stepper-color,#414141);background:0 0;outline:0;border:0;text-align:center}::ng-deep .nx-stepper__suffix{margin-left:4px}::ng-deep .nx-stepper__prefix{margin-right:4px}.nx-stepper__input-wrapper{display:flex;align-items:center;flex-direction:column;margin:0 16px}.nx-stepper__inner-wrapper{height:28px;display:flex;align-items:baseline}.nx-stepper__input-underline{width:100%;margin-top:2px;height:2px;background:#414141;background:var(--number-stepper-underline-color,#414141)}:host.nx-stepper--big .nx-stepper__control{width:72px;min-height:48px;margin-bottom:0}:host.nx-stepper--big .nx-stepper__input{width:72px;min-width:72px}:host.nx-stepper--big .nx-stepper__input,:host.nx-stepper--big ::ng-deep .nx-stepper__prefix,:host.nx-stepper--big ::ng-deep .nx-stepper__suffix{font-size:40px;font-size:var(--number-stepper-large-font-size,40px);line-height:48px;line-height:var(--number-stepper-large-line-height,48px);font-weight:400;font-weight:var(--number-stepper-large-font-weight,400);letter-spacing:.3px;letter-spacing:var(--number-stepper-large-letter-spacing,.3px);height:48px;padding:0;margin-bottom:0}:host.nx-stepper--big .nx-stepper__input-wrapper{margin:0 24px}:host.nx-stepper--big .nx-stepper__input-underline{margin-top:-2px}:host.nx-stepper--big .nx-stepper__inner-wrapper{height:48px}:host.is-negative .nx-stepper__label,:host.is-negative ::ng-deep .nx-stepper__prefix,:host.is-negative ::ng-deep .nx-stepper__suffix{color:#fff}:host.is-negative .nx-stepper__input{color:#fff}:host.is-negative .nx-stepper__input-underline{background:#fff}@media screen and (-ms-high-contrast:active){button.nx-stepper__control:disabled{border-color:GrayText;color:GrayText;opacity:1}.nx-stepper__input{color:buttonText}::ng-deep .nx-stepper__prefix,::ng-deep .nx-stepper__suffix,:host.nx-stepper--big ::ng-deep .nx-stepper__prefix,:host.nx-stepper--big ::ng-deep .nx-stepper__suffix{-ms-high-contrast-adjust:none;color:windowText}.nx-stepper__inner-wrapper{background:buttonFace}.nx-stepper__input-underline{background:buttonText}}"]
                    }] }
        ];
        /** @nocollapse */
        NxNumberStepperComponent.ctorParameters = function () { return [
            { type: core.ChangeDetectorRef },
            { type: core.Renderer2 },
            { type: core.ElementRef },
            { type: NxNumberStepperIntl }
        ]; };
        NxNumberStepperComponent.propDecorators = {
            ngContentWrapper: [{ type: core.ViewChild, args: ['customLabel', { static: false },] }],
            autoResize: [{ type: core.ViewChild, args: [NxAutoResizeDirective, { static: true },] }],
            valueChange: [{ type: core.Output, args: ['nxValueChange',] }],
            resize: [{ type: core.Input, args: ['nxResize',] }],
            label: [{ type: core.Input, args: ['nxLabel',] }],
            step: [{ type: core.Input, args: ['nxStep',] }],
            min: [{ type: core.Input, args: ['nxMin',] }],
            max: [{ type: core.Input, args: ['nxMax',] }],
            value: [{ type: core.Input, args: ['nxValue',] }],
            negative: [{ type: core.Input }],
            leadingZero: [{ type: core.Input }]
        };
        return NxNumberStepperComponent;
    }(core$1.MappedStyles));
    if (false) {
        /**
         * @type {?}
         * @private
         */
        NxNumberStepperComponent.prototype._step;
        /**
         * @type {?}
         * @private
         */
        NxNumberStepperComponent.prototype._min;
        /**
         * @type {?}
         * @private
         */
        NxNumberStepperComponent.prototype._max;
        /**
         * @type {?}
         * @private
         */
        NxNumberStepperComponent.prototype._value;
        /**
         * @type {?}
         * @private
         */
        NxNumberStepperComponent.prototype._label;
        /**
         * @type {?}
         * @private
         */
        NxNumberStepperComponent.prototype._resize;
        /**
         * @type {?}
         * @private
         */
        NxNumberStepperComponent.prototype._intlSubscription;
        /**
         * @type {?}
         * @private
         */
        NxNumberStepperComponent.prototype._negative;
        /**
         * @type {?}
         * @private
         */
        NxNumberStepperComponent.prototype._leadingZero;
        /**
         * \@docs-private
         * @type {?}
         */
        NxNumberStepperComponent.prototype.numberInputValue;
        /**
         * Defines the size of the number stepper.
         *
         * Values: big | normal. Default: normal
         * @type {?}
         */
        NxNumberStepperComponent.prototype.classNames;
        /**
         * \@docs-private
         * @type {?}
         */
        NxNumberStepperComponent.prototype.inputClassNames;
        /**
         * \@docs-private
         * @type {?}
         */
        NxNumberStepperComponent.prototype.inputId;
        /**
         * \@docs-private
         * @type {?}
         */
        NxNumberStepperComponent.prototype.inputWidth;
        /**
         * \@docs-private
         * @type {?}
         */
        NxNumberStepperComponent.prototype.ariaDescribedBy;
        /**
         * \@docs-private
         * @type {?}
         */
        NxNumberStepperComponent.prototype.ngContentWrapper;
        /**
         * \@docs-private
         * @type {?}
         */
        NxNumberStepperComponent.prototype.autoResize;
        /**
         * An event emitted on value change.
         * @type {?}
         */
        NxNumberStepperComponent.prototype.valueChange;
        /**
         * @type {?}
         * @private
         */
        NxNumberStepperComponent.prototype.onChangeCallback;
        /**
         * \@docs-private
         * @type {?}
         */
        NxNumberStepperComponent.prototype.onTouchedCallback;
        /**
         * @type {?}
         * @private
         */
        NxNumberStepperComponent.prototype._changeDetectorRef;
        /** @type {?} */
        NxNumberStepperComponent.prototype._intl;
    }

    /**
     * @fileoverview added by tsickle
     * Generated from: number-stepper/number-stepper-prefix.directive.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * Directive used to pass a suffix to the number stepper.
     */
    var NxNumberStepperPrefixDirective = /** @class */ (function () {
        function NxNumberStepperPrefixDirective() {
        }
        NxNumberStepperPrefixDirective.decorators = [
            { type: core.Directive, args: [{
                        // tslint:disable-next-line:directive-selector
                        selector: 'nx-number-stepper-prefix',
                        host: {
                            'class': 'nx-stepper__prefix'
                        }
                    },] }
        ];
        return NxNumberStepperPrefixDirective;
    }());

    /**
     * @fileoverview added by tsickle
     * Generated from: number-stepper/number-stepper-suffix.directive.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * Directive used to pass a suffix to the number stepper.
     */
    var NxNumberStepperSuffixDirective = /** @class */ (function () {
        function NxNumberStepperSuffixDirective() {
        }
        NxNumberStepperSuffixDirective.decorators = [
            { type: core.Directive, args: [{
                        // tslint:disable-next-line:directive-selector
                        selector: 'nx-number-stepper-suffix',
                        host: {
                            'class': 'nx-stepper__suffix'
                        }
                    },] }
        ];
        return NxNumberStepperSuffixDirective;
    }());

    /**
     * @fileoverview added by tsickle
     * Generated from: number-stepper/number-stepper.module.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var NxNumberStepperModule = /** @class */ (function () {
        function NxNumberStepperModule() {
        }
        NxNumberStepperModule.decorators = [
            { type: core.NgModule, args: [{
                        imports: [
                            input.NxInputModule,
                            forms.FormsModule,
                            icon.NxIconModule,
                            button.NxButtonModule,
                            common.CommonModule
                        ],
                        exports: [
                            NxNumberStepperComponent,
                            NxAutoResizeDirective,
                            NxNumberStepperPrefixDirective,
                            NxNumberStepperSuffixDirective
                        ],
                        declarations: [
                            NxNumberStepperComponent,
                            NxAutoResizeDirective,
                            NxNumberStepperPrefixDirective,
                            NxNumberStepperSuffixDirective
                        ],
                        providers: [NxNumberStepperIntl],
                    },] }
        ];
        return NxNumberStepperModule;
    }());

    /**
     * @fileoverview added by tsickle
     * Generated from: number-stepper/public-api.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * Generated from: pagination/pagination-texts.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * Interface for providing custom labels in a simple pagination.
     * With an implementation you can localize your pagination with the NX_PAGINATION_TEXTS injection token.
     * @record
     */
    function IPaginationTexts() { }
    if (false) {
        /**
         * Label that should replace 'previous'.
         * @type {?}
         */
        IPaginationTexts.prototype.previous;
        /**
         * Label that should replace 'next'.
         * @type {?}
         */
        IPaginationTexts.prototype.next;
        /**
         * Label that should replace 'first'.
         *
         * Optional attribute needed only for the advanced pagination.
         * @type {?|undefined}
         */
        IPaginationTexts.prototype.first;
        /**
         * Label that should replace 'last'.
         *
         * Optional attribute needed only for the advanced pagination.
         * @type {?|undefined}
         */
        IPaginationTexts.prototype.last;
        /**
         * Label that should replace 'of'.
         * @type {?}
         */
        IPaginationTexts.prototype.ofLabel;
        /**
         * Label that should replace the aria label.
         * @type {?}
         */
        IPaginationTexts.prototype.ariaLabel;
    }
    /** @type {?} */
    var DefaultPaginationTexts = {
        previous: 'Previous',
        next: 'Next',
        first: 'First',
        last: 'Last',
        ofLabel: 'of',
        ariaLabel: 'Please select your page'
    };
    /**
     * InjectionToken for pagination that can be used to override default locale code.
     * @type {?}
     */
    var NX_PAGINATION_TEXTS = new core.InjectionToken('nx-pagination-texts');

    /**
     * @fileoverview added by tsickle
     * Generated from: pagination/pagination-utils.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * \@docs-private
     */
    var NxPaginationUtils = /** @class */ (function () {
        function NxPaginationUtils() {
            this._pagesMobile = 3;
            this._elipsisText = '...';
            this._classExpanded = 'expanded-view';
        }
        /**
         * @param {?} currentPage
         * @param {?} totalPages
         * @return {?}
         */
        NxPaginationUtils.prototype.getPages = /**
         * @param {?} currentPage
         * @param {?} totalPages
         * @return {?}
         */
        function (currentPage, totalPages) {
            /** @type {?} */
            var pages = [];
            /** @type {?} */
            var start = [];
            /** @type {?} */
            var middle = [];
            /** @type {?} */
            var end = [];
            // First array -> start
            start = this.getStartArray(currentPage, totalPages);
            // Second array -> middle
            middle = this.getMiddleArray(currentPage, totalPages);
            // Third array -> end
            end = this.getEndArray(currentPage, totalPages);
            pages = __spread(start, middle, end);
            return pages;
        };
        /**
         * @param {?} currentPage
         * @param {?} totalPages
         * @return {?}
         */
        NxPaginationUtils.prototype.getMiddleArray = /**
         * @param {?} currentPage
         * @param {?} totalPages
         * @return {?}
         */
        function (currentPage, totalPages) {
            /** @type {?} */
            var pageNumber = currentPage < 6 ? 4 : currentPage - 1;
            /** @type {?} */
            var middle = [];
            while (middle.length < 3 &&
                pageNumber >= 2 &&
                pageNumber <= totalPages - 3 &&
                (pageNumber <= currentPage + 1 && pageNumber >= currentPage - 1)) {
                middle.push(this.createPaginationItem(pageNumber, pageNumber));
                pageNumber++;
            }
            return middle;
        };
        /**
         * @param {?} currentPage
         * @param {?} totalPages
         * @return {?}
         */
        NxPaginationUtils.prototype.getEndArray = /**
         * @param {?} currentPage
         * @param {?} totalPages
         * @return {?}
         */
        function (currentPage, totalPages) {
            /** @type {?} */
            var end = [];
            /** @type {?} */
            var currentItemToShow = totalPages <= 3 ? totalPages + 1 :
                totalPages <= 6 ? totalPages - (totalPages - 4) : totalPages - 2;
            /** @type {?} */
            var showEllipsis = currentPage < totalPages - 4;
            while (currentItemToShow <= totalPages) {
                /** @type {?} */
                var endItem = end.length === 0 && showEllipsis ?
                    this.createPaginationItem(this._elipsisText, currentItemToShow, true) :
                    this.createPaginationItem(currentItemToShow, currentItemToShow, true);
                end.push(endItem);
                currentItemToShow++;
            }
            return end;
        };
        /**
         * @param {?} currentPage
         * @param {?} totalPages
         * @return {?}
         */
        NxPaginationUtils.prototype.getStartArray = /**
         * @param {?} currentPage
         * @param {?} totalPages
         * @return {?}
         */
        function (currentPage, totalPages) {
            /** @type {?} */
            var counterPages = 0;
            /** @type {?} */
            var start = [];
            /** @type {?} */
            var maxSizeArray = 3;
            while (counterPages < maxSizeArray && counterPages < totalPages) {
                /** @type {?} */
                var startItem = counterPages === 2 && currentPage > 5 ?
                    this.createPaginationItem(this._elipsisText, counterPages, true) :
                    this.createPaginationItem(counterPages + 1, counterPages + 1, true);
                start.push(startItem);
                counterPages++;
            }
            return start;
        };
        /**
         * @param {?} currentPage
         * @param {?} totalPages
         * @return {?}
         */
        NxPaginationUtils.prototype.getMobilePages = /**
         * @param {?} currentPage
         * @param {?} totalPages
         * @return {?}
         */
        function (currentPage, totalPages) {
            var _this = this;
            // if we have less pages than the number we want to display take all
            if (totalPages < this._pagesMobile) {
                return Array.from(Array(totalPages).keys()).map((/**
                 * @param {?} item
                 * @return {?}
                 */
                function (item) { return _this.createPaginationItem(item + 1, item + 1); }));
            }
            switch (currentPage) {
                // first page active
                case 1:
                    return [1, 2, 3].map((/**
                     * @param {?} item
                     * @return {?}
                     */
                    function (item) { return _this.createPaginationItem(item, item); }));
                // last page active
                case totalPages:
                    return [totalPages - 2, totalPages - 1, totalPages].map((/**
                     * @param {?} item
                     * @return {?}
                     */
                    function (item) { return _this.createPaginationItem(item, item); }));
                // any other page active
                default:
                    return [currentPage - 1, currentPage, currentPage + 1].map((/**
                     * @param {?} item
                     * @return {?}
                     */
                    function (item) { return _this.createPaginationItem(item, item); }));
            }
        };
        /**
         * @private
         * @param {?} label
         * @param {?} value
         * @param {?=} classExpanded
         * @return {?}
         */
        NxPaginationUtils.prototype.createPaginationItem = /**
         * @private
         * @param {?} label
         * @param {?} value
         * @param {?=} classExpanded
         * @return {?}
         */
        function (label, value, classExpanded) {
            return { label: label, value: value, class: classExpanded ? this._classExpanded : '' };
        };
        NxPaginationUtils.decorators = [
            { type: core.Injectable }
        ];
        return NxPaginationUtils;
    }());
    if (false) {
        /**
         * @type {?}
         * @private
         */
        NxPaginationUtils.prototype._pagesMobile;
        /**
         * @type {?}
         * @private
         */
        NxPaginationUtils.prototype._elipsisText;
        /**
         * @type {?}
         * @private
         */
        NxPaginationUtils.prototype._classExpanded;
    }

    /**
     * @fileoverview added by tsickle
     * Generated from: pagination/pagination.component.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * \@docs-private
     * @record
     */
    function Page() { }
    if (false) {
        /** @type {?} */
        Page.prototype.label;
        /** @type {?} */
        Page.prototype.value;
        /** @type {?} */
        Page.prototype.class;
    }
    var NxPaginationComponent = /** @class */ (function () {
        function NxPaginationComponent(paginationTexts, paginationUtilsService, _changeDetectorRef) {
            this.paginationUtilsService = paginationUtilsService;
            this._changeDetectorRef = _changeDetectorRef;
            this._type = 'simple';
            /**
             * \@docs-private
             */
            this.totalNumberPages = 0;
            /**
             * An event emitted when the previous page button is clicked.
             */
            this.nxGoPrev = new core.EventEmitter();
            /**
             * An event emitted when the next page button is clicked
             */
            this.nxGoNext = new core.EventEmitter();
            /**
             * An event emitted when a page number is clicked.
             * Provides the number of the page as parameter.
             */
            this.nxGoPage = new core.EventEmitter();
            this.paginationTexts = paginationTexts || DefaultPaginationTexts;
        }
        Object.defineProperty(NxPaginationComponent.prototype, "page", {
            get: /**
             * @return {?}
             */
            function () { return this._page; },
            /** Sets the current page. */
            set: /**
             * Sets the current page.
             * @param {?} value
             * @return {?}
             */
            function (value) {
                this._page = value;
                this._changeDetectorRef.markForCheck();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NxPaginationComponent.prototype, "count", {
            get: /**
             * @return {?}
             */
            function () { return this._count; },
            /** Number of total items over all pages. */
            set: /**
             * Number of total items over all pages.
             * @param {?} value
             * @return {?}
             */
            function (value) {
                this._count = value;
                this.totalNumberPages = this.calculateTotalPages();
                this._changeDetectorRef.markForCheck();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NxPaginationComponent.prototype, "perPage", {
            get: /**
             * @return {?}
             */
            function () { return this._perPage; },
            /** Sets the number of items you want to show per page. */
            set: /**
             * Sets the number of items you want to show per page.
             * @param {?} value
             * @return {?}
             */
            function (value) {
                this._perPage = value;
                this.totalNumberPages = this.calculateTotalPages();
                this._changeDetectorRef.markForCheck();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NxPaginationComponent.prototype, "type", {
            get: /**
             * @return {?}
             */
            function () { return this._type; },
            /**
             * Determines the type of pagination.
             *
             * Values: simple | advanced, default: simple.
             */
            set: /**
             * Determines the type of pagination.
             *
             * Values: simple | advanced, default: simple.
             * @param {?} value
             * @return {?}
             */
            function (value) {
                this._type = value;
                this._changeDetectorRef.markForCheck();
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        NxPaginationComponent.prototype.ngOnInit = /**
         * @return {?}
         */
        function () {
            this.totalNumberPages = this.calculateTotalPages();
        };
        /**
         * @return {?}
         */
        NxPaginationComponent.prototype.ngAfterContentInit = /**
         * @return {?}
         */
        function () {
            if (this.type === 'advanced' && (!this.paginationTexts.last || !this.paginationTexts.first)) {
                console.warn('Please define aria labels for the last and first arrows.');
            }
        };
        /** Returns the number of the first page. */
        /**
         * Returns the number of the first page.
         * @return {?}
         */
        NxPaginationComponent.prototype.getMin = /**
         * Returns the number of the first page.
         * @return {?}
         */
        function () {
            return this.totalNumberPages > 0 ? 1 : 0;
        };
        /** Returns the number of the last page. */
        /**
         * Returns the number of the last page.
         * @return {?}
         */
        NxPaginationComponent.prototype.getMax = /**
         * Returns the number of the last page.
         * @return {?}
         */
        function () {
            /** @type {?} */
            var max = this._perPage * this._page;
            if (max > this._count) {
                max = this._count;
            }
            return max;
        };
        /** Returns the total number of pages */
        /**
         * Returns the total number of pages
         * @return {?}
         */
        NxPaginationComponent.prototype.calculateTotalPages = /**
         * Returns the total number of pages
         * @return {?}
         */
        function () {
            return Math.ceil(this._count / this._perPage) || 0;
        };
        /** Directs to the page with number n. */
        /**
         * Directs to the page with number n.
         * @param {?} n
         * @return {?}
         */
        NxPaginationComponent.prototype.onPage = /**
         * Directs to the page with number n.
         * @param {?} n
         * @return {?}
         */
        function (n) {
            this.nxGoPage.emit(n);
        };
        /** Directs to the previous page. */
        /**
         * Directs to the previous page.
         * @return {?}
         */
        NxPaginationComponent.prototype.onPrev = /**
         * Directs to the previous page.
         * @return {?}
         */
        function () {
            if (!this._isPaginationPreviousDisabled()) {
                this.nxGoPrev.emit();
            }
        };
        /** Directs to the next page. */
        /**
         * Directs to the next page.
         * @return {?}
         */
        NxPaginationComponent.prototype.onNext = /**
         * Directs to the next page.
         * @return {?}
         */
        function () {
            if (!this._isPaginationNextDisabled()) {
                this.nxGoNext.emit();
            }
        };
        /** Directs to the first page. */
        /**
         * Directs to the first page.
         * @return {?}
         */
        NxPaginationComponent.prototype.onFirst = /**
         * Directs to the first page.
         * @return {?}
         */
        function () {
            if (!this._isPaginationPreviousDisabled()) {
                this.onPage(1);
            }
        };
        /** Directs to the last page. */
        /**
         * Directs to the last page.
         * @return {?}
         */
        NxPaginationComponent.prototype.onLast = /**
         * Directs to the last page.
         * @return {?}
         */
        function () {
            if (!this._isPaginationNextDisabled()) {
                this.onPage(this.totalNumberPages);
            }
        };
        /** Returns if the current page is the last page. */
        /**
         * Returns if the current page is the last page.
         * @return {?}
         */
        NxPaginationComponent.prototype.lastPage = /**
         * Returns if the current page is the last page.
         * @return {?}
         */
        function () {
            return this._perPage * this._page >= this._count;
        };
        /** @docs-private */
        /**
         * \@docs-private
         * @return {?}
         */
        NxPaginationComponent.prototype.getPages = /**
         * \@docs-private
         * @return {?}
         */
        function () {
            return this.paginationUtilsService.getPages(this._page, this.totalNumberPages);
        };
        /** @docs-private */
        /**
         * \@docs-private
         * @return {?}
         */
        NxPaginationComponent.prototype.getMobilePages = /**
         * \@docs-private
         * @return {?}
         */
        function () {
            return this.paginationUtilsService.getMobilePages(this._page, this.totalNumberPages);
        };
        /** @docs-private */
        /**
         * \@docs-private
         * @param {?} page
         * @return {?}
         */
        NxPaginationComponent.prototype.getPaginationItemClasses = /**
         * \@docs-private
         * @param {?} page
         * @return {?}
         */
        function (page) {
            /** @type {?} */
            var classes = {
                'is-ellipsis': page.label === '...',
                'nx-pagination__item--expanded-view': page.class === 'expanded-view'
            };
            return classes;
        };
        /** @docs-private */
        /**
         * \@docs-private
         * @param {?} page
         * @return {?}
         */
        NxPaginationComponent.prototype.getPaginationNumberClasses = /**
         * \@docs-private
         * @param {?} page
         * @return {?}
         */
        function (page) {
            /** @type {?} */
            var classes = {
                'is-active': page.value === this.page,
                'nx-pagination__ellipsis': page.label === '...',
                'nx-pagination__link': page.label !== '...'
            };
            return classes;
        };
        /** Returns true, if `nxCount` is greater than 0, else false. */
        /**
         * Returns true, if `nxCount` is greater than 0, else false.
         * @return {?}
         */
        NxPaginationComponent.prototype.isPaginationVisible = /**
         * Returns true, if `nxCount` is greater than 0, else false.
         * @return {?}
         */
        function () {
            return this.count > 0;
        };
        /** Returns true, if `nxCount` is greater than 0 and the type of pagination is 'simple', else false. */
        /**
         * Returns true, if `nxCount` is greater than 0 and the type of pagination is 'simple', else false.
         * @return {?}
         */
        NxPaginationComponent.prototype.isPaginationCompactVisible = /**
         * Returns true, if `nxCount` is greater than 0 and the type of pagination is 'simple', else false.
         * @return {?}
         */
        function () {
            return this.type.includes('simple') && this.count > 0;
        };
        /** @docs-private */
        /**
         * \@docs-private
         * @return {?}
         */
        NxPaginationComponent.prototype.isPaginationContainerVisible = /**
         * \@docs-private
         * @return {?}
         */
        function () {
            return this.type.includes('advanced');
        };
        /**
         * @return {?}
         */
        NxPaginationComponent.prototype._isPaginationPreviousDisabled = /**
         * @return {?}
         */
        function () {
            return this.page === this.getMin();
        };
        /**
         * @return {?}
         */
        NxPaginationComponent.prototype._isPaginationNextDisabled = /**
         * @return {?}
         */
        function () {
            return this.page === this.totalNumberPages;
        };
        NxPaginationComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'nx-pagination',
                        template: "<nav *ngIf=\"isPaginationVisible()\"  aria-label=\"Page navigation\" class=\"nx-pagination\" >\n  <ul *ngIf=\"isPaginationContainerVisible()\"  [attr.aria-label]=\"paginationTexts.ariaLabel\" class=\"nx-pagination__container\">\n    <li class=\"nx-pagination__item\">\n      <button\n        [attr.aria-label]=\"paginationTexts.first\"\n        [class.is-disabled]=\"_isPaginationPreviousDisabled()\"\n        [tabindex]=\"_isPaginationPreviousDisabled() ? -1 : 0\"\n        class=\"nx-pagination__link nx-pagination__link--first\"\n        (click)=\"onFirst()\">\n        <nx-icon class=\"nx-pagination__arrow\" name=\"arrow-first\"></nx-icon>\n      </button>\n    </li>\n    <li class=\"nx-pagination__item nx-pagination__item-previous\">\n      <button\n        [attr.aria-label]=\"paginationTexts.previous\"\n        [class.is-disabled]=\"_isPaginationPreviousDisabled()\"\n        [tabindex]=\"_isPaginationPreviousDisabled() ? -1 : 0\"\n        class=\"nx-pagination__link nx-pagination__link--previous\"\n        (click)=\"onPrev()\">\n        <nx-icon class=\"nx-pagination__arrow\" name=\"arrow-left\"></nx-icon>\n      </button>\n    </li>\n    <li *ngFor=\"let pageNum of getPages()\" class=\"nx-pagination__item nx-pagination__item--desktop\" [ngClass]=\"getPaginationItemClasses(pageNum)\">\n      <button class=\"nx-pagination--number\"\n        *ngIf=\"pageNum.label !== '...'\"\n        (click)=\"onPage(pageNum.value)\"\n        [attr.aria-current]=\"(pageNum.value === page) ? 'page' : ''\"\n        [ngClass]=\"getPaginationNumberClasses(pageNum)\">\n        {{ pageNum.label }}\n      </button>\n      <span *ngIf=\"pageNum.label === '...'\">\n        {{ pageNum.label }}\n      </span>\n    </li>\n    <li *ngFor=\"let pageNum of getMobilePages()\" class=\"nx-pagination__item nx-pagination__item--mobile\" [ngClass]=\"getPaginationItemClasses(pageNum)\">\n      <button class=\"nx-pagination--number\"\n        (click)=\"onPage(pageNum.value)\"\n        [attr.aria-current]=\"(pageNum.value === page) ? 'page' : ''\"\n        [ngClass]=\"getPaginationNumberClasses(pageNum)\">\n        {{ pageNum.label }}\n      </button>\n    </li>\n    <li class=\"nx-pagination__item nx-pagination__item-next\">\n      <button\n        [attr.aria-label]=\"paginationTexts.next\"\n        [class.is-disabled]=\"_isPaginationNextDisabled()\"\n        [tabindex]=\"_isPaginationNextDisabled() ? -1 : 0\"\n        class=\"nx-pagination__link nx-pagination__link--next\"\n        (click)=\"onNext()\">\n        <nx-icon class=\"nx-pagination__arrow\" name=\"arrow-right\"></nx-icon>\n      </button>\n    </li>\n    <li class=\"nx-pagination__item\">\n      <button\n        [attr.aria-label]=\"paginationTexts.last\"\n        [class.is-disabled]=\"_isPaginationNextDisabled()\"\n        [tabindex]=\"_isPaginationNextDisabled() ? -1 : 0\"\n        class=\"nx-pagination__link nx-pagination__link--last\"\n        (click)=\"onLast()\">\n        <nx-icon class=\"nx-pagination__arrow\" name=\"arrow-last\"></nx-icon>\n      </button>\n    </li>\n  </ul>\n</nav>\n<nav *ngIf=\"isPaginationCompactVisible()\" [attr.aria-label]=\"paginationTexts.ariaLabel\" class=\"nx-pagination-compact\" >\n  <button [attr.aria-label]=\"paginationTexts.previous\"\n    class=\"nx-pagination-compact__previous\"\n    [class.is-disabled]=\"_isPaginationPreviousDisabled()\"\n    [tabindex]=\"_isPaginationPreviousDisabled() ? -1 : 0\"\n\n    (click)=\"onPrev()\">\n    <nx-icon class=\"nx-pagination__arrow\" name=\"arrow-left\"></nx-icon>\n    <span class=\"nx-pagination-compact__direction-label\">\n      {{ paginationTexts.previous }}\n    </span>\n  </button>\n  <div class=\"nx-pagination-compact__display\">\n      <span class=\"nx-pagination-compact__current-page\">{{ page }}</span>\n      <span class=\"nx-pagination-compact__page-separator\"> {{ paginationTexts.ofLabel }} </span>\n      <span class=\"nx-pagination-compact__total-pages\">{{ totalNumberPages }}</span>\n  </div>\n  <button\n    class=\"nx-pagination-compact__next\"\n    [class.is-disabled]=\"_isPaginationNextDisabled()\"\n    [tabindex]=\"_isPaginationNextDisabled() ? -1 : 0\"\n    [attr.aria-label]=\"paginationTexts.next\"\n    (click)=\"onNext()\">\n    <span class=\"nx-pagination-compact__direction-label\"> {{ paginationTexts.next }} </span>\n    <nx-icon class=\"nx-pagination__arrow\" name=\"arrow-right\"></nx-icon>\n  </button>\n</nav>\n",
                        changeDetection: core.ChangeDetectionStrategy.OnPush,
                        styles: [":host button:focus{outline:0}:host button::-moz-focus-inner{border:0}.nx-pagination__container{display:flex;font-size:16px;font-size:var(--pagination-font-size,16px);line-height:24px;line-height:var(--pagination-line-height,24px);font-weight:400;font-weight:var(--pagination-font-weight,400);letter-spacing:0;letter-spacing:var(--pagination-letter-spacing,0);margin:8px 0;padding:0}@media (min-width:704px){.nx-pagination__container{margin:8px 0 40px}}.nx-pagination__item{margin:0 16px;list-style:none;font-weight:600;font-weight:var(--pagination-item-font-weight,600)}.nx-pagination__item:first-child,.nx-pagination__item:last-child{margin:0}.nx-pagination__item.is-ellipsis{color:#414141;color:var(--pagination-text-color,#414141)}.nx-pagination__item--expanded-view{display:block}.nx-pagination__link{color:#006192;color:var(--pagination-link-color,#006192);padding:0;text-decoration:none;background-color:transparent;border:0;cursor:pointer}.nx-pagination__link.is-active{color:#414141;color:var(--pagination-text-color,#414141);font-weight:700;cursor:default}nx-icon.nx-pagination__arrow{font-size:24px;font-size:var(--pagination-icon-size,24px)}.nx-pagination-compact{display:flex;font-size:16px;font-size:var(--pagination-font-size,16px);line-height:24px;line-height:var(--pagination-line-height,24px);font-weight:400;font-weight:var(--pagination-font-weight,400);letter-spacing:0;letter-spacing:var(--pagination-letter-spacing,0);margin:16px 0;padding:0}@media (min-width:704px){.nx-pagination-compact{margin:40px 0}}.nx-pagination-compact__display{color:#414141;color:var(--pagination-text-color,#414141);display:flex}.nx-pagination-compact__current-page{font-weight:700;margin-right:8px}.nx-pagination-compact__total-pages{margin-left:8px}.nx-pagination-compact__next,.nx-pagination-compact__previous,.nx-pagination__arrow-first,.nx-pagination__arrow-last{color:#006192;color:var(--pagination-link-color,#006192);font-weight:600;font-weight:var(--pagination-icon-font-weight,600);text-decoration:none;text-transform:uppercase;display:flex;align-items:center;padding:0;background-color:transparent;cursor:pointer;border:0}.nx-pagination-compact__previous{margin-right:32px}.nx-pagination-compact__next{margin-left:32px}.nx-pagination-compact__direction-label{font-size:16px;font-size:var(--pagination-compact-direction-font-size,16px);line-height:24px;line-height:var(--pagination-compact-direction-line-height,24px);font-weight:600;font-weight:var(--pagination-compact-direction-font-weight,600);letter-spacing:1px;letter-spacing:var(--pagination-compact-direction-letter-spacing,1px)}.nx-pagination-compact__direction-label:first-child{margin-right:8px}.nx-pagination-compact__direction-label:last-child{margin-left:8px}.nx-pagination-compact__next.is-disabled,.nx-pagination-compact__previous.is-disabled,.nx-pagination__link.is-disabled{color:rgba(0,97,146,.4);color:var(--pagination-link-disabled-color,rgba(0,97,146,.4));cursor:not-allowed}:host-context([data-whatinput=keyboard]) .nx-pagination--number:focus,:host-context([data-whatinput=keyboard]) .nx-pagination-compact__next:focus,:host-context([data-whatinput=keyboard]) .nx-pagination-compact__previous:focus,:host-context([data-whatinput=keyboard]) .nx-pagination__link:focus{box-shadow:0 0 0 2px #fff,0 0 0 6px #009de6;box-shadow:var(--focus-box-shadow,0 0 0 2px #fff,0 0 0 6px #009de6);border-radius:4px}@media screen and (-ms-high-contrast:active){.nx-pagination__link.is-active{border-bottom:4px solid windowText}.nx-pagination-compact__next.is-disabled,.nx-pagination-compact__previous.is-disabled,.nx-pagination__link.is-disabled{color:GrayText}:host-context([data-whatinput=keyboard]) .nx-pagination--number:focus,:host-context([data-whatinput=keyboard]) .nx-pagination-compact__next:focus,:host-context([data-whatinput=keyboard]) .nx-pagination-compact__previous:focus,:host-context([data-whatinput=keyboard]) .nx-pagination__link:focus{box-shadow:0 0 0 2px background,0 0 0 6px windowText}}.nx-pagination__link--first,.nx-pagination__link--last,.nx-pagination__link--next,.nx-pagination__link--previous{display:flex;align-items:center}.nx-pagination__item-next{margin-right:8px}.nx-pagination__item-previous{margin-left:8px}.nx-pagination-compact__direction-label,.nx-pagination__item--desktop,.nx-pagination__link--first,.nx-pagination__link--last{display:block}.nx-pagination__item--mobile{display:none}@media (max-width:703px){.nx-pagination-compact__direction-label,.nx-pagination__item--desktop,.nx-pagination__link--first,.nx-pagination__link--last{display:none}.nx-pagination__item--mobile{display:block}}"]
                    }] }
        ];
        /** @nocollapse */
        NxPaginationComponent.ctorParameters = function () { return [
            { type: undefined, decorators: [{ type: core.Optional }, { type: core.Inject, args: [NX_PAGINATION_TEXTS,] }] },
            { type: NxPaginationUtils },
            { type: core.ChangeDetectorRef }
        ]; };
        NxPaginationComponent.propDecorators = {
            page: [{ type: core.Input, args: ['nxPage',] }],
            count: [{ type: core.Input, args: ['nxCount',] }],
            perPage: [{ type: core.Input, args: ['nxPerPage',] }],
            type: [{ type: core.Input, args: ['nxType',] }],
            nxGoPrev: [{ type: core.Output }],
            nxGoNext: [{ type: core.Output }],
            nxGoPage: [{ type: core.Output }]
        };
        return NxPaginationComponent;
    }());
    if (false) {
        /**
         * @type {?}
         * @private
         */
        NxPaginationComponent.prototype._page;
        /**
         * @type {?}
         * @private
         */
        NxPaginationComponent.prototype._count;
        /**
         * @type {?}
         * @private
         */
        NxPaginationComponent.prototype._perPage;
        /**
         * @type {?}
         * @private
         */
        NxPaginationComponent.prototype._type;
        /**
         * \@docs-private
         * @type {?}
         */
        NxPaginationComponent.prototype.paginationTexts;
        /**
         * \@docs-private
         * @type {?}
         */
        NxPaginationComponent.prototype.totalNumberPages;
        /**
         * An event emitted when the previous page button is clicked.
         * @type {?}
         */
        NxPaginationComponent.prototype.nxGoPrev;
        /**
         * An event emitted when the next page button is clicked
         * @type {?}
         */
        NxPaginationComponent.prototype.nxGoNext;
        /**
         * An event emitted when a page number is clicked.
         * Provides the number of the page as parameter.
         * @type {?}
         */
        NxPaginationComponent.prototype.nxGoPage;
        /**
         * @type {?}
         * @private
         */
        NxPaginationComponent.prototype.paginationUtilsService;
        /**
         * @type {?}
         * @private
         */
        NxPaginationComponent.prototype._changeDetectorRef;
    }

    /**
     * @fileoverview added by tsickle
     * Generated from: pagination/pagination.module.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var NxPaginationModule = /** @class */ (function () {
        function NxPaginationModule() {
        }
        NxPaginationModule.decorators = [
            { type: core.NgModule, args: [{
                        imports: [
                            common.CommonModule, icon.NxIconModule
                        ],
                        declarations: [
                            NxPaginationComponent
                        ],
                        exports: [
                            NxPaginationComponent
                        ],
                        providers: [
                            NxPaginationUtils
                        ]
                    },] }
        ];
        return NxPaginationModule;
    }());

    /**
     * @fileoverview added by tsickle
     * Generated from: pagination/public-api.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * Generated from: pagination/index.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * Generated from: dynamic-table/tabledata-source.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var TableDataSource = /** @class */ (function (_super) {
        __extends(TableDataSource, _super);
        function TableDataSource(_datachange) {
            var _this = _super.call(this) || this;
            _this._datachange = _datachange;
            return _this;
        }
        /** @docs-private Connect function called by the table to retrieve one stream containing the data to render. */
        /**
         * \@docs-private Connect function called by the table to retrieve one stream containing the data to render.
         * @return {?}
         */
        TableDataSource.prototype.connect = /**
         * \@docs-private Connect function called by the table to retrieve one stream containing the data to render.
         * @return {?}
         */
        function () {
            return this._datachange;
        };
        /** @docs-private */
        /**
         * \@docs-private
         * @return {?}
         */
        TableDataSource.prototype.disconnect = /**
         * \@docs-private
         * @return {?}
         */
        function () { };
        return TableDataSource;
    }(collections.DataSource));
    if (false) {
        /**
         * @type {?}
         * @private
         */
        TableDataSource.prototype._datachange;
    }

    /**
     * @fileoverview added by tsickle
     * Generated from: dynamic-table/dynamic-table.component.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var NxDynamicTableComponent = /** @class */ (function () {
        function NxDynamicTableComponent(el, _changeDetectorRef) {
            this.el = el;
            this._changeDetectorRef = _changeDetectorRef;
            this._dataChange = new rxjs.BehaviorSubject([]);
            /**
             * An event is dispatched when a row is clicked.
             */
            this.nxRowClick = new core.EventEmitter();
        }
        Object.defineProperty(NxDynamicTableComponent.prototype, "data", {
            get: /**
             * @return {?}
             */
            function () {
                return this._data;
            },
            /** Sets the data that it will show in the table. */
            set: /**
             * Sets the data that it will show in the table.
             * @param {?} value
             * @return {?}
             */
            function (value) {
                this._data = value
                    .filter((/**
                 * @param {?} element
                 * @return {?}
                 */
                function (element) { return element; }));
                // If user dont pass displayedColumns the table will show all data and the name of columns will be the key of data
                if (!this._displayedColumns) {
                    /** @type {?} */
                    var keys_1 = [];
                    /** @type {?} */
                    var cArray_1 = [];
                    // For catch keys of data Objects and assing title, key and type string by default to displayedColumns
                    this._data
                        .forEach((/**
                     * @param {?} element
                     * @return {?}
                     */
                    function (element) {
                        for (var key in element) {
                            if (keys_1.indexOf(key) === -1) {
                                keys_1.push(key);
                                cArray_1.push({ title: key, key: key, type: 'string' });
                            }
                        }
                    }));
                    this._columnKeys = keys_1;
                    this._displayedColumns = cArray_1;
                    // need to call markForCheck as the setter changes displayedColumns here
                    // sidenote: isn't needed for the data itself as it gets passed to the cdk-table
                    // by the datasource observable
                    this._changeDetectorRef.markForCheck();
                }
                this._dataChange.next(this._data);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NxDynamicTableComponent.prototype, "displayedColumns", {
            get: /**
             * @return {?}
             */
            function () {
                return this._displayedColumns;
            },
            /** Sets the name order and type of columns. */
            set: /**
             * Sets the name order and type of columns.
             * @param {?} value
             * @return {?}
             */
            function (value) {
                this._displayedColumns = value;
                this._columnKeys = value.map((/**
                 * @param {?} column
                 * @return {?}
                 */
                function (column) { return column.key; }));
                this._changeDetectorRef.markForCheck();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NxDynamicTableComponent.prototype, "dataSource", {
            /** @docs-private */
            get: /**
             * \@docs-private
             * @return {?}
             */
            function () {
                return this._dataSource;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NxDynamicTableComponent.prototype, "columnKeys", {
            /** @docs-private */
            get: /**
             * \@docs-private
             * @return {?}
             */
            function () {
                return this._columnKeys;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        NxDynamicTableComponent.prototype.ngOnInit = /**
         * @return {?}
         */
        function () {
            if (!this._data) {
                this._data = [];
                this._dataChange.next(this._data);
            }
            this._dataSource = new TableDataSource(this._dataChange);
        };
        /** @docs-private */
        /**
         * \@docs-private
         * @param {?} row
         * @return {?}
         */
        NxDynamicTableComponent.prototype.handleRowClick = /**
         * \@docs-private
         * @param {?} row
         * @return {?}
         */
        function (row) {
            this.nxRowClick.emit(row);
        };
        /** @docs-private */
        /**
         * \@docs-private
         * @param {?} element
         * @return {?}
         */
        NxDynamicTableComponent.prototype.isNumeric = /**
         * \@docs-private
         * @param {?} element
         * @return {?}
         */
        function (element) {
            if (element.type === 'numeric') {
                return true;
            }
            return false;
        };
        NxDynamicTableComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'nx-dynamic-table',
                        template: "<div class=\"nx-table__container\" *ngIf=\"data && data.length > 0\">\n  <div class=\"nx-table__scroll\">\n    <cdk-table [dataSource]=\"dataSource\" class=\"nx-table\">\n      <!-- Column Definition -->\n      <ng-container *ngFor=\"let element of displayedColumns\" cdkColumnDef=\"{{element.key}}\">\n        <cdk-header-cell *cdkHeaderCellDef class=\"nx-table__header-cell\"\n                         [ngClass]=\"{'nx-table__header-cell--number': isNumeric(element) }\">\n          <div class=\"nx-table__header-title--block\">\n            <span class=\"nx-table__header-title\"> {{element.title}}</span>\n          </div>\n        </cdk-header-cell>\n        <cdk-cell *cdkCellDef=\"let row\" class=\"nx-table__cell\"\n                  [ngClass]=\"{'nx-table__cell--number': isNumeric(element) }\" [innerHTML]=\"row[element.key]\"></cdk-cell>\n      </ng-container>\n\n      <!-- Header and Row Declarations -->\n      <cdk-header-row *cdkHeaderRowDef=\"columnKeys\" class=\"nx-table__header-row\"></cdk-header-row>\n      <cdk-row *cdkRowDef=\"let row; columns: columnKeys\" class=\"nx-table__row\"\n               (dblclick)=\"handleRowClick(row)\"></cdk-row>\n\n    </cdk-table>\n  </div>\n</div>\n<div class=\"nx-table__appendix\" *ngIf=\"data.length === 0\">\n  <ng-content></ng-content>\n</div>\n",
                        changeDetection: core.ChangeDetectionStrategy.OnPush,
                        styles: [".nx-table{font-size:16px;font-size:var(--table-cell-font-size,16px);line-height:24px;line-height:var(--table-cell-line-height,24px);font-weight:400;font-weight:var(--table-cell-font-weight,400);letter-spacing:0;letter-spacing:var(--table-cell-letter-spacing,0);color:#414141;color:var(--table-cell-color,#414141);text-align:left;width:100%;display:table}.nx-table__container{margin:32px 0}.nx-table__scroll{max-width:100%;overflow:hidden;overflow-x:auto}.nx-table__header-cell{font-size:16px;font-size:var(--table-header-cell-font-size,16px);line-height:24px;line-height:var(--table-header-cell-line-height,24px);font-weight:600;font-weight:var(--table-header-cell-font-weight,600);letter-spacing:0;letter-spacing:var(--table-header-cell-letter-spacing,0);color:#414141;color:var(--table-header-cell-color,#414141);background:0 0;background:var(--table-header-cell-background-color,transparent);border-top:1px solid #d9d9d9;border-top:1px solid var(--table-cell-border-top-color,#d9d9d9);border-bottom:2px solid #414141;border-bottom:2px solid var(--table-header-border-bottom-color,#414141);padding:23px 16px 22px;position:relative}.nx-table__header-cell--number{display:flex;position:relative}.nx-table__header-cell--number .nx-table__header-title--block{justify-content:flex-end}.nx-table__cell--number,.nx-table__header-cell--number{text-align:right}.nx-table__header-row,.nx-table__row{display:table-row;vertical-align:inherit;background-color:transparent}.nx-table__row{background:0 0;background:var(--table-row-background-color,transparent)}.nx-table__cell{border-bottom:1px solid #d9d9d9;border-bottom:1px solid var(--table-header-border-top-color,#d9d9d9);padding:24px 16px 23px;vertical-align:top}.nx-table__row:last-child .nx-table__cell{padding-bottom:22px;border-bottom:2px solid #414141;border-bottom:2px solid var(--table-header-border-bottom-color,#414141)}.nx-table__cell,.nx-table__header-cell{display:table-cell;vertical-align:inherit}"]
                    }] }
        ];
        /** @nocollapse */
        NxDynamicTableComponent.ctorParameters = function () { return [
            { type: core.ElementRef },
            { type: core.ChangeDetectorRef }
        ]; };
        NxDynamicTableComponent.propDecorators = {
            data: [{ type: core.Input, args: ['nxData',] }],
            displayedColumns: [{ type: core.Input, args: ['nxDisplayedColumns',] }],
            nxRowClick: [{ type: core.Output }]
        };
        return NxDynamicTableComponent;
    }());
    if (false) {
        /**
         * @type {?}
         * @private
         */
        NxDynamicTableComponent.prototype._dataChange;
        /**
         * @type {?}
         * @private
         */
        NxDynamicTableComponent.prototype._dataSource;
        /**
         * @type {?}
         * @private
         */
        NxDynamicTableComponent.prototype._data;
        /**
         * @type {?}
         * @private
         */
        NxDynamicTableComponent.prototype._displayedColumns;
        /**
         * @type {?}
         * @private
         */
        NxDynamicTableComponent.prototype._columnKeys;
        /**
         * An event is dispatched when a row is clicked.
         * @type {?}
         */
        NxDynamicTableComponent.prototype.nxRowClick;
        /**
         * @type {?}
         * @private
         */
        NxDynamicTableComponent.prototype.el;
        /**
         * @type {?}
         * @private
         */
        NxDynamicTableComponent.prototype._changeDetectorRef;
    }

    /**
     * @fileoverview added by tsickle
     * Generated from: dynamic-table/dynamic-table.module.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var NxDynamicTableModule = /** @class */ (function () {
        function NxDynamicTableModule() {
        }
        NxDynamicTableModule.decorators = [
            { type: core.NgModule, args: [{
                        declarations: [NxDynamicTableComponent],
                        exports: [NxDynamicTableComponent],
                        imports: [common.CommonModule, table.CdkTableModule, scrolling.ScrollingModule]
                    },] }
        ];
        return NxDynamicTableModule;
    }());

    /**
     * @fileoverview added by tsickle
     * Generated from: dynamic-table/public-api.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * Generated from: accordion/accordion.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /** @type {?} */
    var DEFAULT_TYPE$4 = 'regular';
    var NxAccordionDirective = /** @class */ (function (_super) {
        __extends(NxAccordionDirective, _super);
        function NxAccordionDirective() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this._style = 'regular';
            _this._negative = null;
            return _this;
        }
        Object.defineProperty(NxAccordionDirective.prototype, "style", {
            get: /**
             * @return {?}
             */
            function () {
                return this._style;
            },
            /**
             * Value for the styling that should be chosen.
             * Default value: 'regular'
             */
            set: /**
             * Value for the styling that should be chosen.
             * Default value: 'regular'
             * @param {?} value
             * @return {?}
             */
            function (value) {
                value = value ? value : DEFAULT_TYPE$4;
                var _a = __read(value.match(/regular|light/) || [DEFAULT_TYPE$4], 1), newValue = _a[0];
                this._style = (/** @type {?} */ (newValue));
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NxAccordionDirective.prototype, "negative", {
            get: /**
             * @return {?}
             */
            function () {
                return this._negative;
            },
            /** Whether the negative set of styles should be used. */
            set: /**
             * Whether the negative set of styles should be used.
             * @param {?} value
             * @return {?}
             */
            function (value) {
                this._negative = coercion.coerceBooleanProperty(value);
            },
            enumerable: true,
            configurable: true
        });
        NxAccordionDirective.decorators = [
            { type: core.Directive, args: [{
                        // tslint:disable-next-line:directive-selector
                        selector: 'nx-accordion',
                        host: {
                            '[class.nx-accordion]': 'true',
                            'role': 'presentation'
                        }
                    },] }
        ];
        NxAccordionDirective.propDecorators = {
            style: [{ type: core.Input, args: ['nxStyle',] }],
            negative: [{ type: core.Input }]
        };
        return NxAccordionDirective;
    }(accordion.CdkAccordion));
    if (false) {
        /**
         * @type {?}
         * @private
         */
        NxAccordionDirective.prototype._style;
        /**
         * @type {?}
         * @private
         */
        NxAccordionDirective.prototype._negative;
    }

    /**
     * @fileoverview added by tsickle
     * Generated from: accordion/accordion-animations.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /** @type {?} */
    var nxAccordionAnimations = {
        bodyExpansion: animations.trigger('bodyExpansion', [
            animations.state('closed', animations.style({ height: '0px', visibility: 'hidden' })),
            animations.state('open', animations.style({ height: '*', visibility: 'visible' })),
            animations.transition('open <=> closed', animations.animate('.5s cubic-bezier(0.86, 0, 0.07, 1)'))
        ]),
        indicatorRotate: animations.trigger('indicatorRotate', [
            animations.state('closed', animations.style({ transform: 'rotate(0deg)' })),
            animations.state('open', animations.style({ transform: 'rotate(180deg)' })),
            animations.transition('open <=> closed', animations.animate('.3s ease')),
        ])
    };

    /**
     * @fileoverview added by tsickle
     * Generated from: accordion/expansion-panel-body.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var NxExpansionPanelBodyDirective = /** @class */ (function () {
        function NxExpansionPanelBodyDirective(_template) {
            this._template = _template;
        }
        NxExpansionPanelBodyDirective.decorators = [
            { type: core.Directive, args: [{ selector: '[nxExpansionPanelBody]' },] }
        ];
        /** @nocollapse */
        NxExpansionPanelBodyDirective.ctorParameters = function () { return [
            { type: core.TemplateRef }
        ]; };
        return NxExpansionPanelBodyDirective;
    }());
    if (false) {
        /** @type {?} */
        NxExpansionPanelBodyDirective.prototype._template;
    }

    /**
     * @fileoverview added by tsickle
     * Generated from: accordion/expansion-panel.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /** @type {?} */
    var nextId$9 = 0;
    /** @type {?} */
    var DEFAULT_TYPE$5 = 'regular';
    var 0 = undefined;
    var NxExpansionPanelComponent = /** @class */ (function (_super) {
        __extends(NxExpansionPanelComponent, _super);
        function NxExpansionPanelComponent(accordion, _changeDetectorRef, _expansionDispatcher, _viewContainerRef) {
            var _this = _super.call(this, accordion, _changeDetectorRef, _expansionDispatcher) || this;
            _this._viewContainerRef = _viewContainerRef;
            _this._negative = null;
            _this._accordionStyle = DEFAULT_TYPE$5;
            _this._style = null;
            _this._headerId = "nx-expansion-panel-header-" + nextId$9++;
            /**
             * Stream that emits for changes in `\@Input` properties.
             */
            _this._inputChanges = new rxjs.Subject();
            _this.accordion = accordion;
            return _this;
        }
        Object.defineProperty(NxExpansionPanelComponent.prototype, "negative", {
            get: /**
             * @return {?}
             */
            function () {
                return this._negative;
            },
            /** Whether the negative set of styles should be used. */
            set: /**
             * Whether the negative set of styles should be used.
             * @param {?} value
             * @return {?}
             */
            function (value) {
                this._negative = coercion.coerceBooleanProperty(value);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NxExpansionPanelComponent.prototype, "style", {
            get: /**
             * @return {?}
             */
            function () {
                return this._style;
            },
            /**
             * Value for the styling that should be chosen.
             * Default value: 'regular'.
             */
            set: /**
             * Value for the styling that should be chosen.
             * Default value: 'regular'.
             * @param {?} value
             * @return {?}
             */
            function (value) {
                value = value ? value : DEFAULT_TYPE$5;
                var _a = __read(value.match(/regular|light/) || [DEFAULT_TYPE$5], 1), newValue = _a[0];
                this._style = (/** @type {?} */ (newValue));
                this._accordionStyle = (/** @type {?} */ (newValue));
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NxExpansionPanelComponent.prototype, "portal", {
            /** @docs-private */
            get: /**
             * \@docs-private
             * @return {?}
             */
            function () {
                return this._portal;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        NxExpansionPanelComponent.prototype.ngAfterContentInit = /**
         * @return {?}
         */
        function () {
            var _this = this;
            if (this.lazyContent) {
                // Render the content as soon as the panel becomes open.
                this.opened.pipe(operators.startWith(null), operators.filter((/**
                 * @return {?}
                 */
                function () { return _this.expanded && !_this._portal; })), operators.take(1)).subscribe((/**
                 * @return {?}
                 */
                function () {
                    _this._portal = new portal.TemplatePortal(_this.lazyContent._template, _this._viewContainerRef);
                }));
            }
            // Inherit appearance given by the accordion (if any).
            if (Boolean(this.accordion)) {
                if (this.style === null && this.accordion.style !== null) {
                    this.style = this.accordion.style;
                }
                if (this.negative === null && this.accordion.negative !== null) {
                    this.negative = this.accordion.negative;
                }
            }
        };
        /**
         * @param {?} changes
         * @return {?}
         */
        NxExpansionPanelComponent.prototype.ngOnChanges = /**
         * @param {?} changes
         * @return {?}
         */
        function (changes) {
            this._inputChanges.next(changes);
        };
        /**
         * @return {?}
         */
        NxExpansionPanelComponent.prototype.ngOnDestroy = /**
         * @return {?}
         */
        function () {
            _super.prototype.ngOnDestroy.call(this);
            this._inputChanges.complete();
        };
        /** @docs-private */
        /**
         * \@docs-private
         * @return {?}
         */
        NxExpansionPanelComponent.prototype.getOpenState = /**
         * \@docs-private
         * @return {?}
         */
        function () {
            return this.expanded ? 'open' : 'closed';
        };
        NxExpansionPanelComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'nx-expansion-panel',
                        exportAs: 'NxExpansionPanelComponent',
                        template: "<ng-content select=\"nx-expansion-panel-header\"></ng-content>\n\n<div class=\"nx-expansion-panel__content\" role=\"region\" [@bodyExpansion]=\"getOpenState()\"\n  [attr.aria-labelledby]=\"_headerId\" [id]=\"id\">\n  <div class=\"nx-expansion-panel__body\">\n    <ng-content></ng-content>\n    <ng-template [cdkPortalOutlet]=\"portal\"></ng-template>\n  </div>\n</div>",
                        changeDetection: core.ChangeDetectionStrategy.OnPush,
                        animations: [nxAccordionAnimations.bodyExpansion],
                        host: {
                            '[class.nx-expanded]': 'expanded',
                            '[class.nx-expansion-panel--light]': '_accordionStyle === "light"',
                            '[class.nx-expansion-panel--regular]': '_accordionStyle === "regular"',
                            '[class.nx-expansion-panel--negative]': 'negative',
                            '[class.is-disabled]': 'disabled',
                        },
                        providers: [
                            // Provide NxAccordionDirective as undefined to prevent nested expansion panels from registering
                            // to the same accordion.
                            { provide: NxAccordionDirective, useValue: 0 },
                        ],
                        styles: [":host{display:block}:host(.nx-expansion-panel--negative) ::ng-deep div.nx-expansion-panel__body *{color:#fff}.nx-expansion-panel__content{overflow:hidden;display:block}.nx-expansion-panel__body{font-size:16px;font-size:var(--accordion-body-font-size,16px);line-height:24px;line-height:var(--accordion-body-line-height,24px);font-weight:400;font-weight:var(--accordion-body-font-weight,400);letter-spacing:0;letter-spacing:var(--accordion-body-letter-spacing,0);padding:24px 88px 32px 32px;padding:var(--accordion-regular-body-padding,24px 88px 32px 32px)}:host(.nx-expansion-panel--regular){margin-top:16px;margin-top:var(--accordion-regular-header-top-margin,16px)}:host(.nx-expansion-panel--regular) ::ng-deep .nx-expansion-panel__header-content{box-shadow:inset 0 1px 0 0 transparent;box-shadow:inset 0 1px 0 0 var(--accordion-regular-border-color,transparent)}:host(.nx-expansion-panel--regular):last-child,:host(.nx-expansion-panel--regular):only-child{box-shadow:0 1px 0 0 transparent;box-shadow:0 1px 0 0 var(--accordion-regular-border-color,transparent)}@media (max-width:703px){.nx-expansion-panel__body{padding:24px 16px 32px}:host(.nx-expansion-panel--regular){margin-top:0}:host(.nx-expansion-panel--regular) ::ng-deep .nx-expansion-panel__header-content{box-shadow:inset 0 1px 0 0 #d9d9d9}:host(.nx-expansion-panel--regular):last-child ::ng-deep .nx-expansion-panel__header-content,:host(.nx-expansion-panel--regular):only-child ::ng-deep .nx-expansion-panel__header-content{box-shadow:inset 0 1px 0 0 #d9d9d9,inset 0 -1px 0 0 #d9d9d9}:host(.nx-expansion-panel--regular).nx-expanded ::ng-deep .nx-expansion-panel__header-content{box-shadow:inset 0 1px 0 0 #d9d9d9,inset 0 -1px 0 0 #d9d9d9}}:host(.nx-expansion-panel--light) .nx-expansion-panel__body{padding:24px 88px 32px 32px;padding:var(--accordion-light-body-padding,24px 88px 32px 32px)}:host(.nx-expansion-panel--light):not(.nx-expansion-panel--negative) ::ng-deep .nx-expansion-panel__header-content{box-shadow:inset 0 1px 0 0 #d9d9d9}:host(.nx-expansion-panel--light):not(.nx-expansion-panel--negative):last-child,:host(.nx-expansion-panel--light):not(.nx-expansion-panel--negative):only-child{box-shadow:0 1px 0 0 #d9d9d9}:host(.nx-expansion-panel--light.nx-expansion-panel--negative){color:#fff}:host(.nx-expansion-panel--light.nx-expansion-panel--negative) ::ng-deep .nx-expansion-panel__header-content{box-shadow:inset 0 1px 0 0 #fff}:host(.nx-expansion-panel--light.nx-expansion-panel--negative):last-child,:host(.nx-expansion-panel--light.nx-expansion-panel--negative):only-child{box-shadow:0 1px 0 0 #fff}@media screen and (-ms-high-contrast:active){:host{border-color:windowText;color:buttonText}:host.nx-expansion-panel--regular{border:1px solid buttonText}:host.is-disabled{border-color:GrayText}:host.nx-expansion-panel--light.nx-expansion-panel--negative ::ng-deep .nx-expansion-panel__header-content,:host.nx-expansion-panel--light:not(.nx-expansion-panel--negative) ::ng-deep .nx-expansion-panel__header-content{box-shadow:inset 0 1px 0 0 windowText}:host.nx-expansion-panel--light.nx-expansion-panel--negative:last-child,:host.nx-expansion-panel--light.nx-expansion-panel--negative:only-child,:host.nx-expansion-panel--light:not(.nx-expansion-panel--negative):last-child,:host.nx-expansion-panel--light:not(.nx-expansion-panel--negative):only-child{box-shadow:0 1px 0 0 windowText}}"]
                    }] }
        ];
        /** @nocollapse */
        NxExpansionPanelComponent.ctorParameters = function () { return [
            { type: NxAccordionDirective, decorators: [{ type: core.Optional }, { type: core.SkipSelf }] },
            { type: core.ChangeDetectorRef },
            { type: collections.UniqueSelectionDispatcher },
            { type: core.ViewContainerRef }
        ]; };
        NxExpansionPanelComponent.propDecorators = {
            negative: [{ type: core.Input }],
            style: [{ type: core.Input, args: ['nxStyle',] }],
            lazyContent: [{ type: core.ContentChild, args: [NxExpansionPanelBodyDirective, { static: false },] }]
        };
        return NxExpansionPanelComponent;
    }(accordion.CdkAccordionItem));
    if (false) {
        /**
         * @type {?}
         * @private
         */
        NxExpansionPanelComponent.prototype._negative;
        /** @type {?} */
        NxExpansionPanelComponent.prototype._accordionStyle;
        /**
         * @type {?}
         * @private
         */
        NxExpansionPanelComponent.prototype._style;
        /**
         * \@docs-private
         * @type {?}
         */
        NxExpansionPanelComponent.prototype.lazyContent;
        /**
         * @type {?}
         * @private
         */
        NxExpansionPanelComponent.prototype._portal;
        /**
         * \@docs-private
         * @type {?}
         */
        NxExpansionPanelComponent.prototype.accordion;
        /** @type {?} */
        NxExpansionPanelComponent.prototype._headerId;
        /**
         * Stream that emits for changes in `\@Input` properties.
         * @type {?}
         */
        NxExpansionPanelComponent.prototype._inputChanges;
        /**
         * @type {?}
         * @private
         */
        NxExpansionPanelComponent.prototype._viewContainerRef;
    }

    /**
     * @fileoverview added by tsickle
     * Generated from: accordion/expansion-panel-header.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var NxExpansionPanelHeaderComponent = /** @class */ (function () {
        function NxExpansionPanelHeaderComponent(panel, _changeDetectorRef) {
            var _this = this;
            this.panel = panel;
            this._changeDetectorRef = _changeDetectorRef;
            this._parentChangeSubscription = rxjs.Subscription.EMPTY;
            this._parentChangeSubscription = rxjs.merge(panel.opened, panel.closed, panel._inputChanges.pipe(operators.filter((/**
             * @param {?} changes
             * @return {?}
             */
            function (changes) { return !!(changes.hideToggle || changes.disabled); }))))
                .subscribe((/**
             * @return {?}
             */
            function () { return _this._changeDetectorRef.markForCheck(); }));
        }
        /**
         * @return {?}
         */
        NxExpansionPanelHeaderComponent.prototype.ngOnDestroy = /**
         * @return {?}
         */
        function () {
            this._parentChangeSubscription.unsubscribe();
        };
        /** @docs-private */
        /**
         * \@docs-private
         * @return {?}
         */
        NxExpansionPanelHeaderComponent.prototype.isExpanded = /**
         * \@docs-private
         * @return {?}
         */
        function () {
            return this.panel.expanded;
        };
        /** @docs-private */
        /**
         * \@docs-private
         * @return {?}
         */
        NxExpansionPanelHeaderComponent.prototype.getOpenState = /**
         * \@docs-private
         * @return {?}
         */
        function () {
            return this.panel.getOpenState();
        };
        /**
         * @return {?}
         */
        NxExpansionPanelHeaderComponent.prototype._getPanelId = /**
         * @return {?}
         */
        function () {
            return this.panel.id;
        };
        /**
         * Toggle the expansion panel.
         */
        /**
         * Toggle the expansion panel.
         * @return {?}
         */
        NxExpansionPanelHeaderComponent.prototype.toggle = /**
         * Toggle the expansion panel.
         * @return {?}
         */
        function () {
            this.panel.toggle();
        };
        /** @docs-private */
        /**
         * \@docs-private
         * @param {?} event
         * @return {?}
         */
        NxExpansionPanelHeaderComponent.prototype.keydown = /**
         * \@docs-private
         * @param {?} event
         * @return {?}
         */
        function (event) {
            switch (event.keyCode) {
                case keycodes.SPACE:
                case keycodes.ENTER:
                    event.preventDefault();
                    this.toggle();
                    break;
                default:
                    return;
            }
        };
        NxExpansionPanelHeaderComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'nx-expansion-panel-header',
                        template: "<div class=\"nx-expansion-panel__header-content\">\n  <ng-content select=\"nx-expansion-panel-title\"></ng-content>\n  <ng-content select=\"nx-expansion-panel-description\"></ng-content>\n  <nx-icon\n    [@indicatorRotate]=\"getOpenState()\"\n    class=\"nx-expansion-panel__chevron\"\n    name=\"chevron-down\">\n  </nx-icon>\n</div>",
                        changeDetection: core.ChangeDetectionStrategy.OnPush,
                        animations: [nxAccordionAnimations.indicatorRotate],
                        host: {
                            '[class.nx-expanded]': 'isExpanded()',
                            'class': 'nx-expansion-panel__header',
                            'role': 'button',
                            '[attr.id]': 'panel._headerId',
                            '[attr.tabindex]': 'panel.disabled ? -1 : 0',
                            '[attr.aria-controls]': '_getPanelId()',
                            '[attr.aria-expanded]': 'isExpanded()',
                            '[attr.aria-disabled]': 'panel.disabled',
                            '[class.is-disabled]': 'panel.disabled',
                            '(keydown)': 'keydown($event)',
                            '(click)': 'toggle()'
                        },
                        styles: [":host:focus{outline:0}.nx-expansion-panel__header-content{width:100%;cursor:pointer;align-items:center;display:flex;justify-content:space-between;position:relative;outline:0;border:none;color:#414141;color:var(--accordion-regular-header-text-color,#414141);background:#f5f5f5;background:var(--accordion-regular-header-background-color,#f5f5f5);padding:24px 32px;padding:var(--accordion-regular-header-padding,24px 32px)}:host-context(.nx-expansion-panel--regular):not(.is-disabled) .nx-expansion-panel__header-content:hover{color:#414141;color:var(--accordion-regular-header-hover-text-color,#414141)}:host-context(.nx-expansion-panel--regular):not(.is-disabled) .nx-expansion-panel__header-content:hover .nx-expansion-panel__chevron{color:#006192;color:var(--accordion-regular-hover-chevron-color,#006192)}::ng-deep .nx-expansion-panel__header-title{font-size:26px;font-size:var(--accordion-regular-font-size,26px);line-height:32px;line-height:var(--accordion-regular-line-height,32px);font-weight:300;font-weight:var(--accordion-regular-font-weight,300);letter-spacing:.3px;letter-spacing:var(--accordion-regular-letter-spacing,.3px);text-align:left;margin-right:32px}@media (max-width:703px){.nx-expansion-panel__header-content{padding:16px}::ng-deep .nx-expansion-panel__header-title{font-size:20px;font-size:var(--accordion-regular-mobile-font-size,20px);line-height:28px;line-height:var(--accordion-regular-mobile-line-height,28px);font-weight:400;font-weight:var(--accordion-regular-mobile-font-weight,400);letter-spacing:.2px;letter-spacing:var(--accordion-regular-mobile-letter-spacing,.2px);margin-right:16px}}.nx-expansion-panel__chevron{pointer-events:none;font-size:24px;font-size:var(--accordion-chevron-size,24px)}:host(:not(.is-disabled)) .nx-expansion-panel__chevron{color:#006192;color:var(--accordion-regular-chevron-color,#006192)}:host-context(.nx-expansion-panel--light) .nx-expansion-panel__header-content{padding:24px 32px;padding:var(--accordion-light-header-padding,24px 32px);margin-top:0;background:0 0}:host-context(.nx-expansion-panel--light) .nx-expansion-panel__chevron{color:#006192;color:var(--accordion-light-chevron-color,#006192)}:host-context(.nx-expansion-panel--light) ::ng-deep .nx-expansion-panel__header-title{font-size:20px;font-size:var(--accordion-light-font-size,20px);line-height:28px;line-height:var(--accordion-light-line-height,28px);font-weight:400;font-weight:var(--accordion-light-font-weight,400);letter-spacing:.2px;letter-spacing:var(--accordion-light-letter-spacing,.2px)}@media (max-width:703px){:host-context(.nx-expansion-panel--light) ::ng-deep .nx-expansion-panel__header-title{font-size:14px;font-size:var(--accordion-light-mobile-font-size,14px);line-height:20px;line-height:var(--accordion-light-mobile-line-height,20px);font-weight:600;font-weight:var(--accordion-light-mobile-font-weight,600);letter-spacing:.2px;letter-spacing:var(--accordion-light-mobile-letter-spacing,.2px)}}:host-context(.nx-expansion-panel--light:not(.nx-expansion-panel--negative)) .nx-expansion-panel__header-content{color:#006192;color:var(--accordion-light-header-text-color,#006192)}:host-context(.nx-expansion-panel--light:not(.nx-expansion-panel--negative)):not(.is-disabled) .nx-expansion-panel__header-content:hover{color:#006192;color:var(--accordion-light-header-hover-text-color,#006192)}:host-context(.nx-expansion-panel--light:not(.nx-expansion-panel--negative)):not(.is-disabled) .nx-expansion-panel__header-content:hover .nx-expansion-panel__chevron{color:#006192;color:var(--accordion-light-hover-chevron-color,#006192)}:host-context(.nx-expansion-panel--light.nx-expansion-panel--negative) .nx-expansion-panel__header-content{color:#fff}:host-context(.nx-expansion-panel--light.nx-expansion-panel--negative) .nx-expansion-panel__chevron{color:#fff}:host.is-disabled.is-disabled .nx-expansion-panel__chevron,:host.is-disabled.is-disabled .nx-expansion-panel__header-content{cursor:not-allowed;color:#c2c2c2;color:var(--accordion-disabled-color,#c2c2c2)}:host-context([data-whatinput=keyboard]):focus .nx-expansion-panel__header-content{box-shadow:0 0 0 2px #fff,0 0 0 6px #009de6;box-shadow:var(--focus-box-shadow,0 0 0 2px #fff,0 0 0 6px #009de6);z-index:1}@media screen and (-ms-high-contrast:active){:host-context([data-whatinput=keyboard]):focus .nx-expansion-panel__header-content{box-shadow:0 0 0 2px background,0 0 0 6px windowText}:host{-ms-high-contrast-adjust:none}:host-context(.nx-expansion-panel--light.nx-expansion-panel--negative) .nx-expansion-panel__header-content,:host-context(.nx-expansion-panel--light.nx-expansion-panel--negative):not(.is-disabled) .nx-expansion-panel__header-content:hover,:host-context(.nx-expansion-panel--light:not(.nx-expansion-panel--negative)) .nx-expansion-panel__header-content,:host-context(.nx-expansion-panel--light:not(.nx-expansion-panel--negative)):not(.is-disabled) .nx-expansion-panel__header-content:hover,:host-context(.nx-expansion-panel--regular):not(.is-disabled) .nx-expansion-panel__header-content,:host-context(.nx-expansion-panel--regular):not(.is-disabled):not(.is-disabled) .nx-expansion-panel__header-content:hover{color:buttonText;background-color:buttonFace}:host-context(.nx-expansion-panel--light.nx-expansion-panel--negative) .nx-expansion-panel__header-content .nx-expansion-panel__chevron,:host-context(.nx-expansion-panel--light.nx-expansion-panel--negative):not(.is-disabled) .nx-expansion-panel__header-content:hover .nx-expansion-panel__chevron,:host-context(.nx-expansion-panel--light:not(.nx-expansion-panel--negative)) .nx-expansion-panel__header-content .nx-expansion-panel__chevron,:host-context(.nx-expansion-panel--light:not(.nx-expansion-panel--negative)):not(.is-disabled) .nx-expansion-panel__header-content:hover .nx-expansion-panel__chevron,:host-context(.nx-expansion-panel--regular):not(.is-disabled) .nx-expansion-panel__header-content .nx-expansion-panel__chevron,:host-context(.nx-expansion-panel--regular):not(.is-disabled):not(.is-disabled) .nx-expansion-panel__header-content:hover .nx-expansion-panel__chevron{color:buttonText}:host.is-disabled.is-disabled .nx-expansion-panel__header-content{color:GrayText;background-color:buttonFace}:host.is-disabled.is-disabled .nx-expansion-panel__header-content .nx-expansion-panel__chevron{color:GrayText}}"]
                    }] }
        ];
        /** @nocollapse */
        NxExpansionPanelHeaderComponent.ctorParameters = function () { return [
            { type: NxExpansionPanelComponent, decorators: [{ type: core.Host }] },
            { type: core.ChangeDetectorRef }
        ]; };
        return NxExpansionPanelHeaderComponent;
    }());
    if (false) {
        /**
         * @type {?}
         * @private
         */
        NxExpansionPanelHeaderComponent.prototype._parentChangeSubscription;
        /**
         * \@docs-private
         * @type {?}
         */
        NxExpansionPanelHeaderComponent.prototype.panel;
        /**
         * @type {?}
         * @private
         */
        NxExpansionPanelHeaderComponent.prototype._changeDetectorRef;
    }
    /**
     * This directive is to be used inside of the NxExpansionPanelHeader component.
     */
    var NxExpansionPanelDescriptionDirective = /** @class */ (function () {
        function NxExpansionPanelDescriptionDirective() {
        }
        NxExpansionPanelDescriptionDirective.decorators = [
            { type: core.Directive, args: [{
                        // tslint:disable-next-line:directive-selector
                        selector: 'nx-expansion-panel-description',
                        host: {
                            class: 'nx-expansion-panel__header-description'
                        }
                    },] }
        ];
        return NxExpansionPanelDescriptionDirective;
    }());
    /**
     * This directive is to be used inside of the NxExpansionPanelHeader component.
     */
    var NxExpansionPanelTitleDirective = /** @class */ (function () {
        function NxExpansionPanelTitleDirective() {
        }
        NxExpansionPanelTitleDirective.decorators = [
            { type: core.Directive, args: [{
                        // tslint:disable-next-line:directive-selector
                        selector: 'nx-expansion-panel-title',
                        host: {
                            class: 'nx-expansion-panel__header-title'
                        }
                    },] }
        ];
        return NxExpansionPanelTitleDirective;
    }());

    /**
     * @fileoverview added by tsickle
     * Generated from: accordion/accordion.module.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var NxAccordionModule = /** @class */ (function () {
        function NxAccordionModule() {
        }
        NxAccordionModule.decorators = [
            { type: core.NgModule, args: [{
                        imports: [
                            common.CommonModule,
                            portal.PortalModule,
                            icon.NxIconModule
                        ],
                        exports: [
                            NxAccordionDirective,
                            NxExpansionPanelComponent,
                            NxExpansionPanelHeaderComponent,
                            NxExpansionPanelDescriptionDirective,
                            NxExpansionPanelTitleDirective,
                            NxExpansionPanelBodyDirective
                        ],
                        declarations: [
                            NxAccordionDirective,
                            NxExpansionPanelComponent,
                            NxExpansionPanelHeaderComponent,
                            NxExpansionPanelDescriptionDirective,
                            NxExpansionPanelTitleDirective,
                            NxExpansionPanelBodyDirective
                        ],
                        providers: [],
                    },] }
        ];
        return NxAccordionModule;
    }());

    /**
     * @fileoverview added by tsickle
     * Generated from: accordion/public-api.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * Generated from: accordion/index.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * Generated from: tabs/tab-group-base.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * \@docs-private
     * @abstract
     */
    var   /**
     * \@docs-private
     * @abstract
     */
    NxTabGroupBase = /** @class */ (function () {
        function NxTabGroupBase() {
        }
        return NxTabGroupBase;
    }());

    /**
     * @fileoverview added by tsickle
     * Generated from: tabs/tab-header-outlet.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * \@docs-private
     */
    var NxTabHeaderOutletComponent = /** @class */ (function () {
        function NxTabHeaderOutletComponent(_tabGroup) {
            this._tabGroup = _tabGroup;
        }
        /**
         * @return {?}
         */
        NxTabHeaderOutletComponent.prototype.ngOnInit = /**
         * @return {?}
         */
        function () {
            var _this = this;
            this._appearanceSubscription = ((/** @type {?} */ (this._tabGroup)))._appearanceChange.subscribe((/**
             * @return {?}
             */
            function () {
                _this.detach();
            }));
            this.attach();
        };
        /**
         * @return {?}
         */
        NxTabHeaderOutletComponent.prototype.attach = /**
         * @return {?}
         */
        function () {
            this._outlet.insert(this.content);
        };
        /**
         * @return {?}
         */
        NxTabHeaderOutletComponent.prototype.detach = /**
         * @return {?}
         */
        function () {
            /** @type {?} */
            var index = this._outlet.indexOf(this.content);
            if (index !== -1) {
                this._outlet.detach(index);
            }
        };
        /**
         * @return {?}
         */
        NxTabHeaderOutletComponent.prototype.ngOnDestroy = /**
         * @return {?}
         */
        function () {
            this._appearanceSubscription.unsubscribe();
        };
        NxTabHeaderOutletComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'nx-tab-header-outlet',
                        template: '<ng-container #outlet></ng-container>'
                    }] }
        ];
        /** @nocollapse */
        NxTabHeaderOutletComponent.ctorParameters = function () { return [
            { type: NxTabGroupBase }
        ]; };
        NxTabHeaderOutletComponent.propDecorators = {
            _outlet: [{ type: core.ViewChild, args: ['outlet', { static: true, read: core.ViewContainerRef },] }],
            content: [{ type: core.Input }]
        };
        return NxTabHeaderOutletComponent;
    }());
    if (false) {
        /** @type {?} */
        NxTabHeaderOutletComponent.prototype._outlet;
        /** @type {?} */
        NxTabHeaderOutletComponent.prototype.content;
        /**
         * @type {?}
         * @private
         */
        NxTabHeaderOutletComponent.prototype._appearanceSubscription;
        /**
         * @type {?}
         * @private
         */
        NxTabHeaderOutletComponent.prototype._tabGroup;
    }

    /**
     * @fileoverview added by tsickle
     * Generated from: tabs/tab-label.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * \@docs-private
     */
    var NxTabLabelDirective = /** @class */ (function (_super) {
        __extends(NxTabLabelDirective, _super);
        function NxTabLabelDirective() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        NxTabLabelDirective.decorators = [
            { type: core.Directive, args: [{ selector: '[nxTabLabel]' },] }
        ];
        return NxTabLabelDirective;
    }(portal.CdkPortal));

    /**
     * @fileoverview added by tsickle
     * Generated from: tabs/tab-content.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * Decorates the `ng-template` tags and reads out the template from it.
     */
    var NxTabContentDirective = /** @class */ (function () {
        function NxTabContentDirective(/** @docs-private */ template) {
            this.template = template;
        }
        NxTabContentDirective.decorators = [
            { type: core.Directive, args: [{ selector: '[nxTabContent]' },] }
        ];
        /** @nocollapse */
        NxTabContentDirective.ctorParameters = function () { return [
            { type: core.TemplateRef }
        ]; };
        return NxTabContentDirective;
    }());
    if (false) {
        /**
         * \@docs-private
         * @type {?}
         */
        NxTabContentDirective.prototype.template;
    }

    /**
     * @fileoverview added by tsickle
     * Generated from: tabs/tab.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var NxTabComponent = /** @class */ (function () {
        function NxTabComponent(_tabGroup) {
            this._tabGroup = _tabGroup;
            this._disabled = false;
            /**
             * Emits whenever the internal state of the tab changes.
             */
            this._stateChanges = new rxjs.Subject();
            /**
             * Whether the tab is currently active.
             */
            this.isActive = false;
            if (!this._tabGroup) {
                throw Error("The nx-tab element has to be wrapped in a nx-tab-group to work.\n      Please provide a nx-tab-group element and place your tabs inside it.");
            }
        }
        Object.defineProperty(NxTabComponent.prototype, "templateLabel", {
            /**
             * Content for the tab label given by `<ng-template nxTabLabel>`.
             * @docs-private
             * */
            get: /**
             * Content for the tab label given by `<ng-template nxTabLabel>`.
             * \@docs-private
             *
             * @return {?}
             */
            function () { return this._templateLabel; },
            set: /**
             * @param {?} value
             * @return {?}
             */
            function (value) {
                // Only update the templateLabel via query if there is actually
                // a nxTabLabel found. This works around an issue where a user may have
                // manually set `templateLabel` during creation mode, which would then get clobbered
                // by `undefined` when this query resolves.
                if (value) {
                    this._templateLabel = value;
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NxTabComponent.prototype, "label", {
            /** Sets the label of the tab shown in the tablist. */
            get: /**
             * Sets the label of the tab shown in the tablist.
             * @return {?}
             */
            function () {
                return this._label;
            },
            set: /**
             * @param {?} value
             * @return {?}
             */
            function (value) {
                if (this._label !== value) {
                    this._label = value;
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NxTabComponent.prototype, "disabled", {
            /** Sets the tab to disabled. */
            get: /**
             * Sets the tab to disabled.
             * @return {?}
             */
            function () {
                return (this._tabGroup && ((/** @type {?} */ (this._tabGroup))).disabled) ?
                    ((/** @type {?} */ (this._tabGroup))).disabled : this._disabled;
            },
            set: /**
             * @param {?} value
             * @return {?}
             */
            function (value) {
                if (this._disabled !== value) {
                    this._disabled = value;
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NxTabComponent.prototype, "headerViewRef", {
            /** @docs-private */
            get: /**
             * \@docs-private
             * @return {?}
             */
            function () {
                return this._headerViewRef;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NxTabComponent.prototype, "contentViewRef", {
            /** @docs-private */
            get: /**
             * \@docs-private
             * @return {?}
             */
            function () {
                // for lazy loading we only create the viewref when it is asked for
                if (!this._contentViewRef) {
                    /** @type {?} */
                    var contentTemplate = this._explicitContent || this._implicitContent;
                    this._contentViewRef = contentTemplate.createEmbeddedView({});
                }
                return this._contentViewRef;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @param {?} changes
         * @return {?}
         */
        NxTabComponent.prototype.ngOnChanges = /**
         * @param {?} changes
         * @return {?}
         */
        function (changes) {
            if (changes.hasOwnProperty('label') || changes.hasOwnProperty('disabled')) {
                this._stateChanges.next();
            }
        };
        /**
         * @return {?}
         */
        NxTabComponent.prototype.ngAfterContentInit = /**
         * @return {?}
         */
        function () {
            if (this.templateLabel) {
                this._headerViewRef = this.templateLabel.createEmbeddedView({});
            }
        };
        /**
         * @return {?}
         */
        NxTabComponent.prototype.ngOnDestroy = /**
         * @return {?}
         */
        function () {
            this._stateChanges.complete();
            this._contentViewRef.destroy();
            if (this._headerViewRef) {
                this._headerViewRef.destroy();
            }
        };
        NxTabComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'nx-tab',
                        exportAs: 'nxTab',
                        template: "<ng-template><ng-content></ng-content></ng-template>\n",
                        changeDetection: core.ChangeDetectionStrategy.OnPush
                    }] }
        ];
        /** @nocollapse */
        NxTabComponent.ctorParameters = function () { return [
            { type: NxTabGroupBase, decorators: [{ type: core.Inject, args: [NxTabGroupBase,] }, { type: core.Optional }, { type: core.Host }] }
        ]; };
        NxTabComponent.propDecorators = {
            templateLabel: [{ type: core.ContentChild, args: [NxTabLabelDirective, { read: core.TemplateRef, static: true },] }],
            _implicitContent: [{ type: core.ViewChild, args: [core.TemplateRef, { static: true },] }],
            _explicitContent: [{ type: core.ContentChild, args: [NxTabContentDirective, { read: core.TemplateRef, static: true },] }],
            label: [{ type: core.Input }],
            disabled: [{ type: core.Input }]
        };
        return NxTabComponent;
    }());
    if (false) {
        /**
         * @type {?}
         * @private
         */
        NxTabComponent.prototype._label;
        /**
         * @type {?}
         * @private
         */
        NxTabComponent.prototype._disabled;
        /**
         * Emits whenever the internal state of the tab changes.
         * @type {?}
         */
        NxTabComponent.prototype._stateChanges;
        /**
         * @type {?}
         * @private
         */
        NxTabComponent.prototype._templateLabel;
        /**
         * Template inside the NxTab view that contains an `<ng-content>`.
         * @type {?}
         */
        NxTabComponent.prototype._implicitContent;
        /**
         * Template provided in the tab content that will be used if present, used to enable lazy-loading
         * @type {?}
         */
        NxTabComponent.prototype._explicitContent;
        /**
         * @type {?}
         * @private
         */
        NxTabComponent.prototype._headerViewRef;
        /**
         * @type {?}
         * @private
         */
        NxTabComponent.prototype._contentViewRef;
        /**
         * Whether the tab is currently active.
         * @type {?}
         */
        NxTabComponent.prototype.isActive;
        /**
         * @type {?}
         * @private
         */
        NxTabComponent.prototype._tabGroup;
    }

    /**
     * @fileoverview added by tsickle
     * Generated from: tabs/tab-body.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * \@docs-private
     */
    var NxTabBodyComponent = /** @class */ (function () {
        function NxTabBodyComponent(_tabGroup) {
            this._tabGroup = _tabGroup;
            this._active = false;
        }
        Object.defineProperty(NxTabBodyComponent.prototype, "active", {
            get: /**
             * @return {?}
             */
            function () {
                return this._active;
            },
            set: /**
             * @param {?} value
             * @return {?}
             */
            function (value) {
                this._active = coercion.coerceBooleanProperty(value);
                if (this._active) {
                    this.attach();
                }
                else {
                    this.detach();
                }
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        NxTabBodyComponent.prototype.ngOnInit = /**
         * @return {?}
         */
        function () {
            var _this = this;
            this._appearanceSubscription = ((/** @type {?} */ (this._tabGroup)))._appearanceChange.subscribe((/**
             * @return {?}
             */
            function () {
                _this.detach();
            }));
        };
        /**
         * @return {?}
         */
        NxTabBodyComponent.prototype.ngOnDestroy = /**
         * @return {?}
         */
        function () {
            this._appearanceSubscription.unsubscribe();
        };
        /**
         * @return {?}
         */
        NxTabBodyComponent.prototype.attach = /**
         * @return {?}
         */
        function () {
            this._outlet.insert(this.tab.contentViewRef);
        };
        /**
         * @return {?}
         */
        NxTabBodyComponent.prototype.detach = /**
         * @return {?}
         */
        function () {
            /** @type {?} */
            var index = this._outlet.indexOf(this.tab.contentViewRef);
            if (index !== -1) {
                this._outlet.detach(index);
            }
        };
        NxTabBodyComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'nx-tab-body',
                        template: "<ng-container #outlet></ng-container>",
                        changeDetection: core.ChangeDetectionStrategy.OnPush,
                        styles: [":host{display:block}"]
                    }] }
        ];
        /** @nocollapse */
        NxTabBodyComponent.ctorParameters = function () { return [
            { type: NxTabGroupBase }
        ]; };
        NxTabBodyComponent.propDecorators = {
            _outlet: [{ type: core.ViewChild, args: ['outlet', { static: true, read: core.ViewContainerRef },] }],
            tab: [{ type: core.Input }],
            active: [{ type: core.Input }]
        };
        return NxTabBodyComponent;
    }());
    if (false) {
        /**
         * @type {?}
         * @private
         */
        NxTabBodyComponent.prototype._appearanceSubscription;
        /** @type {?} */
        NxTabBodyComponent.prototype._outlet;
        /** @type {?} */
        NxTabBodyComponent.prototype.tab;
        /**
         * @type {?}
         * @private
         */
        NxTabBodyComponent.prototype._active;
        /**
         * @type {?}
         * @private
         */
        NxTabBodyComponent.prototype._tabGroup;
    }

    /**
     * @fileoverview added by tsickle
     * Generated from: tabs/tab-label-wrapper.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * \@docs-private
     */
    var NxTabLabelWrapperDirective = /** @class */ (function () {
        function NxTabLabelWrapperDirective(elementRef) {
            this.elementRef = elementRef;
            this._disabled = false;
        }
        Object.defineProperty(NxTabLabelWrapperDirective.prototype, "disabled", {
            /** Whether the tab group is disabled. Default: false. */
            get: /**
             * Whether the tab group is disabled. Default: false.
             * @return {?}
             */
            function () {
                return this._disabled;
            },
            set: /**
             * @param {?} value
             * @return {?}
             */
            function (value) {
                /** @type {?} */
                var newValue = coercion.coerceBooleanProperty(value);
                if (this.disabled !== newValue) {
                    this._disabled = newValue;
                }
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        NxTabLabelWrapperDirective.prototype.focus = /**
         * @return {?}
         */
        function () {
            this.elementRef.nativeElement.focus();
        };
        NxTabLabelWrapperDirective.decorators = [
            { type: core.Directive, args: [{ selector: '[nxTabLabelWrapper]' },] }
        ];
        /** @nocollapse */
        NxTabLabelWrapperDirective.ctorParameters = function () { return [
            { type: core.ElementRef }
        ]; };
        NxTabLabelWrapperDirective.propDecorators = {
            disabled: [{ type: core.Input }]
        };
        return NxTabLabelWrapperDirective;
    }());
    if (false) {
        /**
         * @type {?}
         * @private
         */
        NxTabLabelWrapperDirective.prototype._disabled;
        /** @type {?} */
        NxTabLabelWrapperDirective.prototype.elementRef;
    }

    /**
     * @fileoverview added by tsickle
     * Generated from: tabs/tab-header.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * \@docs-private
     */
    var NxTabHeaderComponent = /** @class */ (function () {
        function NxTabHeaderComponent(_changeDetectorRef) {
            this._changeDetectorRef = _changeDetectorRef;
            this._selectedIndex = 0;
            this._autoselect = true;
            this.selectFocusedIndex = new core.EventEmitter();
            this.indexFocused = new core.EventEmitter();
        }
        Object.defineProperty(NxTabHeaderComponent.prototype, "selectedIndex", {
            get: /**
             * @return {?}
             */
            function () {
                return this._selectedIndex;
            },
            set: /**
             * @param {?} value
             * @return {?}
             */
            function (value) {
                this._selectedIndex = value;
                if (this._keyManager) {
                    this._keyManager.updateActiveItem(value);
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NxTabHeaderComponent.prototype, "focusIndex", {
            get: /**
             * @return {?}
             */
            function () {
                return this._keyManager ? this._keyManager.activeItemIndex : 0;
            },
            set: /**
             * @param {?} value
             * @return {?}
             */
            function (value) {
                if (!this._isValidIndex(value) || this.focusIndex === value || !this._keyManager) {
                    return;
                }
                this._keyManager.setActiveItem(value);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NxTabHeaderComponent.prototype, "autoselect", {
            get: /**
             * @return {?}
             */
            function () {
                return this._autoselect;
            },
            set: /**
             * @param {?} value
             * @return {?}
             */
            function (value) {
                this._autoselect = value;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        NxTabHeaderComponent.prototype.ngAfterContentInit = /**
         * @return {?}
         */
        function () {
            this._keyManager = new a11y.FocusKeyManager(this.labels).withHorizontalOrientation('ltr').withWrap();
            this._keyManager.updateActiveItem(0);
            this._changeDetectorRef.markForCheck();
        };
        /**
         * @private
         * @param {?} idx
         * @return {?}
         */
        NxTabHeaderComponent.prototype._isValidIndex = /**
         * @private
         * @param {?} idx
         * @return {?}
         */
        function (idx) {
            if (!this.labels) {
                return true;
            }
            /** @type {?} */
            var tab = this.labels.toArray()[idx] || null;
            return !!tab && !tab.disabled;
        };
        /**
         * Handles keyboard inputs on the labels
         * If autoselect is enabled the tab gets changed immediately
         * If autoselect is disabled only the focus changes but the user still has to select the item
         * by himself
         */
        /**
         * Handles keyboard inputs on the labels
         * If autoselect is enabled the tab gets changed immediately
         * If autoselect is disabled only the focus changes but the user still has to select the item
         * by himself
         * @param {?} event
         * @return {?}
         */
        NxTabHeaderComponent.prototype.handleKeydown = /**
         * Handles keyboard inputs on the labels
         * If autoselect is enabled the tab gets changed immediately
         * If autoselect is disabled only the focus changes but the user still has to select the item
         * by himself
         * @param {?} event
         * @return {?}
         */
        function (event) {
            switch (event.keyCode) {
                case keycodes.HOME:
                    this._keyManager.setFirstItemActive();
                    event.preventDefault();
                    break;
                case keycodes.END:
                    this._keyManager.setLastItemActive();
                    event.preventDefault();
                    break;
                case keycodes.ENTER:
                case keycodes.SPACE:
                    this.selectFocusedIndex.emit(this._keyManager.activeItemIndex);
                    event.preventDefault();
                    break;
                default:
                    this._keyManager.onKeydown(event);
            }
            if (this.autoselect) {
                this.selectFocusedIndex.emit(this._keyManager.activeItemIndex);
            }
            else if (event.keyCode !== keycodes.ENTER && event.keyCode !== keycodes.SPACE) {
                this.indexFocused.emit(this._keyManager.activeItemIndex);
            }
        };
        NxTabHeaderComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'nx-tab-header',
                        template: "<div class=\"nx-tab-header\" (keydown)=\"handleKeydown($event)\" role=\"tablist\">\n  <ng-content></ng-content>\n</div>",
                        changeDetection: core.ChangeDetectionStrategy.OnPush,
                        styles: [":host{display:block}.nx-tab-header{display:flex;align-items:flex-end;justify-content:center;padding:60px 0}"]
                    }] }
        ];
        /** @nocollapse */
        NxTabHeaderComponent.ctorParameters = function () { return [
            { type: core.ChangeDetectorRef }
        ]; };
        NxTabHeaderComponent.propDecorators = {
            selectedIndex: [{ type: core.Input }],
            autoselect: [{ type: core.Input }],
            selectFocusedIndex: [{ type: core.Output }],
            indexFocused: [{ type: core.Output }],
            labels: [{ type: core.ContentChildren, args: [NxTabLabelWrapperDirective,] }]
        };
        return NxTabHeaderComponent;
    }());
    if (false) {
        /**
         * @type {?}
         * @private
         */
        NxTabHeaderComponent.prototype._keyManager;
        /**
         * @type {?}
         * @private
         */
        NxTabHeaderComponent.prototype._selectedIndex;
        /**
         * @type {?}
         * @private
         */
        NxTabHeaderComponent.prototype._autoselect;
        /** @type {?} */
        NxTabHeaderComponent.prototype.selectFocusedIndex;
        /** @type {?} */
        NxTabHeaderComponent.prototype.indexFocused;
        /** @type {?} */
        NxTabHeaderComponent.prototype.labels;
        /**
         * @type {?}
         * @private
         */
        NxTabHeaderComponent.prototype._changeDetectorRef;
    }

    /**
     * @fileoverview added by tsickle
     * Generated from: tabs/tab-group.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var NxTabChangeEvent = /** @class */ (function () {
        function NxTabChangeEvent() {
        }
        return NxTabChangeEvent;
    }());
    if (false) {
        /**
         * The index of the selected or focused tab.
         * @type {?}
         */
        NxTabChangeEvent.prototype.index;
        /**
         * The component instance of the selected or focused tab.
         * @type {?}
         */
        NxTabChangeEvent.prototype.tab;
    }
    /** @type {?} */
    var nextId$a = 0;
    /** @type {?} */
    var MOBILE_BREAKPOINT = 480;
    var NxTabGroupComponent = /** @class */ (function () {
        function NxTabGroupComponent(_changeDetectorRef) {
            this._changeDetectorRef = _changeDetectorRef;
            this._selectedIndex = null;
            this._negative = false;
            this._disabled = false;
            this._indexToSelect = 0;
            this._autoselect = true;
            this._mobileAccordion = true;
            this._showAccordion = false;
            /**
             * An event emitted when the selected tab has changed.
             */
            this.selectedIndexChange = new core.EventEmitter();
            /**
             * An event emitted when the selected tab has changed.
             */
            this.selectedTabChange = new core.EventEmitter();
            /**
             * An event emitted when focus has changed within a tab group.
             *
             * **Note:** is not supported in mobile view.
             */
            this.focusChange = new core.EventEmitter();
            /**
             * Subscription to tabs being added/removed.
             */
            this._tabsSubscription = rxjs.Subscription.EMPTY;
            /**
             * Subscription to changes in the tab labels.
             */
            this._tabLabelSubscription = rxjs.Subscription.EMPTY;
            this._disabledTabsCache = [];
            this._appearanceChange = new rxjs.Subject();
            this._groupId = nextId$a++;
        }
        Object.defineProperty(NxTabGroupComponent.prototype, "selectedIndex", {
            /** Sets the selected tab. */
            get: /**
             * Sets the selected tab.
             * @return {?}
             */
            function () {
                return this._selectedIndex;
            },
            set: /**
             * @param {?} value
             * @return {?}
             */
            function (value) {
                this._indexToSelect = coercion.coerceNumberProperty(value, null);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NxTabGroupComponent.prototype, "negative", {
            /** Whether the negative set of styling should be used. */
            get: /**
             * Whether the negative set of styling should be used.
             * @return {?}
             */
            function () {
                return this._negative;
            },
            set: /**
             * @param {?} value
             * @return {?}
             */
            function (value) {
                if (value !== this._negative) {
                    this._negative = coercion.coerceBooleanProperty(value);
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NxTabGroupComponent.prototype, "disabled", {
            /** Whether the tab group is disabled. Default: false. */
            get: /**
             * Whether the tab group is disabled. Default: false.
             * @return {?}
             */
            function () {
                return this._disabled;
            },
            set: /**
             * @param {?} value
             * @return {?}
             */
            function (value) {
                if (value !== this._disabled) {
                    this._disabled = coercion.coerceBooleanProperty(value);
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NxTabGroupComponent.prototype, "autoselect", {
            /** Whether the tab should be immediately selected on focus. */
            get: /**
             * Whether the tab should be immediately selected on focus.
             * @return {?}
             */
            function () {
                return this._autoselect;
            },
            set: /**
             * @param {?} value
             * @return {?}
             */
            function (value) {
                this._autoselect = coercion.coerceBooleanProperty(value);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NxTabGroupComponent.prototype, "mobileAccordion", {
            /** Whether the tabs should to accordion on mobile viewports. */
            get: /**
             * Whether the tabs should to accordion on mobile viewports.
             * @return {?}
             */
            function () {
                return this._mobileAccordion;
            },
            set: /**
             * @param {?} value
             * @return {?}
             */
            function (value) {
                this._mobileAccordion = coercion.coerceBooleanProperty(value);
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        NxTabGroupComponent.prototype.ngOnInit = /**
         * @return {?}
         */
        function () {
            this._switchAppearance(window.innerWidth);
        };
        /**
         * @return {?}
         */
        NxTabGroupComponent.prototype.ngAfterContentInit = /**
         * @return {?}
         */
        function () {
            var _this = this;
            this._subscribeToTabLabels();
            // Subscribe to changes in the amount of tabs, in order to be
            // able to re-render the content as new tabs are added or removed.
            this._tabsSubscription = this.tabs.changes.subscribe((/**
             * @return {?}
             */
            function () {
                /** @type {?} */
                var indexToSelect = _this._clampTabIndex(_this._indexToSelect);
                // Maintain the previously-selected tab if a new tab is added or removed and there is no
                // explicit change that selects a different tab.
                if (indexToSelect === _this._selectedIndex) {
                    /** @type {?} */
                    var tabs = _this.tabs.toArray();
                    for (var i = 0; i < tabs.length; i++) {
                        if (tabs[i].isActive) {
                            // Assign both to the `_indexToSelect` and `_selectedIndex` so we don't fire a changed
                            // event, otherwise the consumer may end up in an infinite loop in some edge cases like
                            // adding a tab within the `selectedIndexChange` event.
                            _this._indexToSelect = _this._selectedIndex = i;
                            break;
                        }
                    }
                }
                _this._changeDetectorRef.markForCheck();
            }));
        };
        /**
          * After the content is checked, this component knows what tabs have been defined
          * and what the selected index should be.
          */
        /**
         * After the content is checked, this component knows what tabs have been defined
         * and what the selected index should be.
         * @return {?}
         */
        NxTabGroupComponent.prototype.ngAfterContentChecked = /**
         * After the content is checked, this component knows what tabs have been defined
         * and what the selected index should be.
         * @return {?}
         */
        function () {
            var _this = this;
            // Don't clamp the `indexToSelect` immediately in the setter because it can happen that
            // the amount of tabs changes before the actual change detection runs.
            /** @type {?} */
            var indexToSelect = this._indexToSelect = this._clampTabIndex(this._indexToSelect);
            // If the active tab is disabled select the next focusable tab
            // if all tabs are disabled, allow selection of disabled active tab.
            if (!this.disabled && this.tabs.toArray()[indexToSelect].disabled) {
                /** @type {?} */
                var nextFocusable = this.tabs.toArray()
                    .map((/**
                 * @param {?} tab
                 * @param {?} index
                 * @return {?}
                 */
                function (tab, index) { return ({ tab: tab, index: index }); }))
                    .find((/**
                 * @param {?} item
                 * @return {?}
                 */
                function (item) { return !item.tab.disabled; }));
                indexToSelect = nextFocusable ? nextFocusable.index : indexToSelect;
            }
            // If the index to select was disabled previously leave the selection on the current
            // so that the selection does not jump from one to another tab.
            if (this._disabledTabsCache[this._indexToSelect]) {
                this._indexToSelect = this.selectedIndex;
            }
            // If there is a change in selected index, emit a change event. Should not trigger if
            // the selected index has not yet been initialized.
            if (this._selectedIndex !== indexToSelect) {
                /** @type {?} */
                var isFirstRun_1 = this._selectedIndex == null;
                if (!isFirstRun_1) {
                    this.selectedTabChange.emit(this._createChangeEvent(indexToSelect));
                }
                // Changing these values after change detection has run
                // since the checked content may contain references to them.
                Promise.resolve().then((/**
                 * @return {?}
                 */
                function () {
                    _this.tabs.forEach((/**
                     * @param {?} tab
                     * @param {?} index
                     * @return {?}
                     */
                    function (tab, index) { return tab.isActive = index === indexToSelect; }));
                    if (!isFirstRun_1) {
                        _this.selectedIndexChange.emit(indexToSelect);
                    }
                }));
            }
            if (this._selectedIndex !== indexToSelect) {
                this._selectedIndex = indexToSelect;
                this._changeDetectorRef.markForCheck();
            }
            // cache the previous disabled status of all tabs
            if (!this.disabled) {
                this.tabs.toArray().forEach((/**
                 * @param {?} tab
                 * @param {?} index
                 * @return {?}
                 */
                function (tab, index) { return _this._disabledTabsCache[index] = tab.disabled; }));
            }
        };
        /**
         * @return {?}
         */
        NxTabGroupComponent.prototype.ngOnDestroy = /**
         * @return {?}
         */
        function () {
            this._tabsSubscription.unsubscribe();
            this._tabLabelSubscription.unsubscribe();
        };
        /**
        * Subscribes to changes in the tab labels. This is needed, because the @Input for the label is
        * on the NxTab component, whereas the data binding is inside the NxTabGroup. In order for the
        * binding to be updated, we need to subscribe to changes in it and trigger change detection
        * manually.
        */
        /**
         * Subscribes to changes in the tab labels. This is needed, because the \@Input for the label is
         * on the NxTab component, whereas the data binding is inside the NxTabGroup. In order for the
         * binding to be updated, we need to subscribe to changes in it and trigger change detection
         * manually.
         * @private
         * @return {?}
         */
        NxTabGroupComponent.prototype._subscribeToTabLabels = /**
         * Subscribes to changes in the tab labels. This is needed, because the \@Input for the label is
         * on the NxTab component, whereas the data binding is inside the NxTabGroup. In order for the
         * binding to be updated, we need to subscribe to changes in it and trigger change detection
         * manually.
         * @private
         * @return {?}
         */
        function () {
            var _this = this;
            if (this._tabLabelSubscription) {
                this._tabLabelSubscription.unsubscribe();
            }
            this._tabLabelSubscription = rxjs.merge.apply(void 0, __spread(this.tabs.map((/**
             * @param {?} tab
             * @return {?}
             */
            function (tab) { return tab._stateChanges; })))).subscribe((/**
             * @return {?}
             */
            function () { return _this._changeDetectorRef.markForCheck(); }));
        };
        /** Clamps the given index to the bounds of 0 and the tabs length. */
        /**
         * Clamps the given index to the bounds of 0 and the tabs length.
         * @private
         * @param {?} index
         * @return {?}
         */
        NxTabGroupComponent.prototype._clampTabIndex = /**
         * Clamps the given index to the bounds of 0 and the tabs length.
         * @private
         * @param {?} index
         * @return {?}
         */
        function (index) {
            // Note the `|| 0`, which ensures that values like NaN can't get through
            // and which would otherwise throw the component into an infinite loop
            // (since Math.max(NaN, 0) === NaN).
            return Math.min(this.tabs.length - 1, Math.max(index || 0, 0));
        };
        /** @docs-private */
        /**
         * \@docs-private
         * @param {?} index
         * @return {?}
         */
        NxTabGroupComponent.prototype.focusChanged = /**
         * \@docs-private
         * @param {?} index
         * @return {?}
         */
        function (index) {
            this.focusChange.emit(this._createChangeEvent(index));
        };
        /**
         * @private
         * @param {?} index
         * @return {?}
         */
        NxTabGroupComponent.prototype._createChangeEvent = /**
         * @private
         * @param {?} index
         * @return {?}
         */
        function (index) {
            /** @type {?} */
            var event = new NxTabChangeEvent;
            event.index = index;
            if (this.tabs && this.tabs.length) {
                event.tab = this.tabs.toArray()[index];
            }
            return event;
        };
        /** @docs-private */
        /**
         * \@docs-private
         * @param {?} index
         * @return {?}
         */
        NxTabGroupComponent.prototype.handleClick = /**
         * \@docs-private
         * @param {?} index
         * @return {?}
         */
        function (index) {
            /** @type {?} */
            var clickedTab = this.tabs.toArray()[index];
            if (!this.disabled && !clickedTab.disabled) {
                this.selectedIndex = this.tabHeader.focusIndex = index;
            }
        };
        /**
         * @docs-private
         * Returns the tabindex for a tab label
         */
        /**
         * \@docs-private
         * Returns the tabindex for a tab label
         * @param {?} tab
         * @param {?} idx
         * @return {?}
         */
        NxTabGroupComponent.prototype.getTabIndex = /**
         * \@docs-private
         * Returns the tabindex for a tab label
         * @param {?} tab
         * @param {?} idx
         * @return {?}
         */
        function (tab, idx) {
            return (this.selectedIndex === idx && !tab.disabled && !this.disabled) ? 0 : -1;
        };
        /** Returns a unique id for each tab label element */
        /**
         * Returns a unique id for each tab label element
         * @param {?} i
         * @return {?}
         */
        NxTabGroupComponent.prototype._getTabLabelId = /**
         * Returns a unique id for each tab label element
         * @param {?} i
         * @return {?}
         */
        function (i) {
            return "nx-tab-label-" + this._groupId + "-" + i;
        };
        /** Returns a unique id for each tab content element */
        /**
         * Returns a unique id for each tab content element
         * @param {?} i
         * @return {?}
         */
        NxTabGroupComponent.prototype._getTabContentId = /**
         * Returns a unique id for each tab content element
         * @param {?} i
         * @return {?}
         */
        function (i) {
            return "nx-tab-content-" + this._groupId + "-" + i;
        };
        /** @docs-private */
        /**
         * \@docs-private
         * @param {?} event
         * @return {?}
         */
        NxTabGroupComponent.prototype.onResize = /**
         * \@docs-private
         * @param {?} event
         * @return {?}
         */
        function (event) {
            this._switchAppearance(event.target.innerWidth);
        };
        /**
         * @private
         * @param {?} viewPortWidth
         * @return {?}
         */
        NxTabGroupComponent.prototype._switchAppearance = /**
         * @private
         * @param {?} viewPortWidth
         * @return {?}
         */
        function (viewPortWidth) {
            if (!this._mobileAccordion) {
                return;
            }
            // notify the outlets to detach the viewrefs for header and body before
            // we switch the appearance. this way we only instantiate the templates
            // once so that they do not get destroyed during the switch
            if (viewPortWidth <= MOBILE_BREAKPOINT && !this._showAccordion) {
                this._appearanceChange.next();
                this._showMobileVersion();
            }
            else if (viewPortWidth > MOBILE_BREAKPOINT && this._showAccordion) {
                this._appearanceChange.next();
                this._showDesktopVersion();
            }
        };
        /**
         * @private
         * @return {?}
         */
        NxTabGroupComponent.prototype._showMobileVersion = /**
         * @private
         * @return {?}
         */
        function () {
            this._showAccordion = true;
            this._changeDetectorRef.markForCheck();
        };
        /**
         * @private
         * @return {?}
         */
        NxTabGroupComponent.prototype._showDesktopVersion = /**
         * @private
         * @return {?}
         */
        function () {
            this._showAccordion = false;
            this._changeDetectorRef.markForCheck();
        };
        /**
         * Emulate the tab change event when an accordion panel is opened in
         * mobile viewports.
         */
        /**
         * Emulate the tab change event when an accordion panel is opened in
         * mobile viewports.
         * @param {?} index
         * @return {?}
         */
        NxTabGroupComponent.prototype._panelOpened = /**
         * Emulate the tab change event when an accordion panel is opened in
         * mobile viewports.
         * @param {?} index
         * @return {?}
         */
        function (index) {
            this.selectedIndex = index;
        };
        NxTabGroupComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'nx-tab-group',
                        template: "\n\n  <ng-container *ngIf=\"!_showAccordion\">\n  <nx-tab-header\n      #tabHeader\n      [selectedIndex]=\"selectedIndex\"\n      (selectFocusedIndex)=\"selectedIndex = $event\"\n      (indexFocused)=\"focusChanged($event)\"\n      [autoselect]=\"autoselect\">\n    <button\n      type=\"button\"\n      nxTabLabelWrapper\n      *ngFor=\"let tab of tabs; let i = index\"\n      role=\"tab\"\n      (click)=\"handleClick(i)\"\n      class=\"nx-tab-header__item\"\n      [id]=\"_getTabLabelId(i)\"\n      [attr.aria-controls]=\"_getTabContentId(i)\"\n      [attr.aria-selected]=\"selectedIndex == i\"\n      [attr.tabindex]=\"getTabIndex(tab, i)\"\n      [disabled]=\"tab.disabled\"\n      [class.nx-tab-header__item--disabled]=\"tab.disabled\"\n      [class.nx-tab-header__item--active]=\"selectedIndex == i\">\n      <div class=\"nx-tab-label__content\">\n        <nx-tab-header-outlet *ngIf=\"tab.templateLabel\" [content]=\"tab.headerViewRef\"></nx-tab-header-outlet>\n        <ng-container *ngIf=\"!tab.templateLabel\">{{tab.label}}</ng-container>\n      </div>\n    </button>\n  </nx-tab-header>\n\n  <div class=\"nx-tab-body__container\">\n    <nx-tab-body\n      *ngFor=\"let tab of tabs; let i = index\"\n      [id]=\"_getTabContentId(i)\"\n      role=\"tabpanel\"\n      [attr.tabindex]=\"(selectedIndex == i) ? 0 : -1\"\n      class=\"nx-tab__body\"\n      [attr.aria-labelledby]=\"_getTabContentId(i)\"\n      [class.nx-tab__body--active]=\"selectedIndex == i\"\n      [tab]=\"tab\"\n      [active]=\"selectedIndex == i\"\n    ></nx-tab-body>\n  </div>\n</ng-container>\n\n<nx-accordion *ngIf=\"_showAccordion\" [negative]=\"negative\">\n  <nx-expansion-panel *ngFor=\"let tab of tabs; let i = index\"\n                      [expanded]=\"selectedIndex === i\"\n                      (opened)=\"_panelOpened(i)\"\n                      [disabled]=\"tab.disabled\"\n  >\n    <nx-expansion-panel-header>\n      <nx-expansion-panel-title>\n        <nx-tab-header-outlet *ngIf=\"tab.templateLabel\" [content]=\"tab.headerViewRef\"></nx-tab-header-outlet>\n        <ng-container *ngIf=\"!tab.templateLabel\">{{tab.label}}</ng-container>\n      </nx-expansion-panel-title>\n    </nx-expansion-panel-header>\n    <!-- this is not lazy loading this is a trick because the portal gets added here -->\n    <!-- so we could rewrite the tab-body component that it takes care of \"lazy loading\" and the\n    accordion wouldn't know about it -->\n    <!-- active=true is a trick because we want to keep the content attached for better user experience along with expansion panel animation.  -->\n    <nx-tab-body [active]=\"true\" [tab]=\"tab\"></nx-tab-body>\n  </nx-expansion-panel>\n</nx-accordion>\n",
                        changeDetection: core.ChangeDetectionStrategy.OnPush,
                        host: {
                            '[class.is-negative]': 'negative',
                            '[class.is-disabled]': 'disabled'
                        },
                        providers: [{ provide: NxTabGroupBase, useExisting: NxTabGroupComponent }],
                        styles: [":host{display:block}.nx-tab-header__item{font-size:18px;font-size:var(--tab-item-font-size,18px);line-height:24px;line-height:var(--tab-item-line-height,24px);font-weight:400;font-weight:var(--tab-item-font-weight,400);letter-spacing:.2px;letter-spacing:var(--tab-item-letter-spacing,.2px);text-decoration:none;border:#006192;background:0 0;color:#006192;color:var(--tab-item-color,#006192);border-color:var(--tab-item-border-color,#006192);border-bottom-width:2px;border-bottom-style:solid;padding:0 16px 6px;outline:0;margin:0}.nx-tab-header__item:hover:not(.nx-tab-header__item--disabled){cursor:pointer}.nx-tab-header__item::-moz-focus-inner{border:0}.nx-tab-header__item--active{border-width:4px;font-weight:700;transition:font-weight .3s;padding-bottom:4px}@media screen and (-ms-high-contrast:active){.nx-tab-header__item{background-color:buttonFace;border-color:buttonText;color:buttonText;-ms-high-contrast-adjust:none}.nx-tab-header__item--active{background-color:highlight;color:highlightText;border-color:highlight}}.nx-tab-header__item--disabled{border-color:#c2c2c2;border-color:var(--tab-item-disabled-border-color,#c2c2c2);color:#c2c2c2;color:var(--tab-item-disabled-color,#c2c2c2);cursor:not-allowed}.nx-tab-label__content{display:inline-flex;justify-content:center;align-items:center;white-space:nowrap}:host-context([data-whatinput=keyboard]) .nx-tab-header__item:focus{box-shadow:0 0 0 2px #fff,0 0 0 6px #009de6;box-shadow:var(--focus-box-shadow,0 0 0 2px #fff,0 0 0 6px #009de6);border-radius:4px}@media screen and (-ms-high-contrast:active){.nx-tab-header__item--disabled{border-color:GrayText;background-color:buttonFace;color:GrayText}:host-context([data-whatinput=keyboard]) .nx-tab-header__item:focus{box-shadow:0 0 0 2px background,0 0 0 6px windowText}}:host(.is-negative){color:#fff}:host(.is-negative) .nx-tab-header__item{color:#fff;border-bottom-color:#fff}:host(.is-negative) .nx-tab-header__item.nx-tab-header__item--disabled{border-color:rgba(255,255,255,.4);border-color:var(--tab-item-disabled-border-color,#c2c2c2);color:var(--tab-item-disabled-color,#c2c2c2);cursor:not-allowed;color:rgba(255,255,255,.4);color:var(--tab-item-disabled-negative-color,rgba(255,255,255,.4));border-color:var(--tab-item-disabled-negative-color,rgba(255,255,255,.4))}@media screen and (-ms-high-contrast:active){:host(.is-negative) .nx-tab-header__item.nx-tab-header__item--disabled{border-color:GrayText;background-color:buttonFace;color:GrayText}}:host(.is-disabled){cursor:not-allowed}:host(.is-disabled.is-negative) .nx-tab-header__item{border-color:rgba(255,255,255,.4);border-color:var(--tab-item-disabled-border-color,#c2c2c2);color:var(--tab-item-disabled-color,#c2c2c2);cursor:not-allowed;color:rgba(255,255,255,.4);color:var(--tab-item-disabled-negative-color,rgba(255,255,255,.4));border-color:var(--tab-item-disabled-negative-color,rgba(255,255,255,.4))}@media screen and (-ms-high-contrast:active){:host(.is-disabled.is-negative) .nx-tab-header__item{border-color:GrayText;background-color:buttonFace}:host(.is-negative){color:buttonText}:host(.is-negative) .nx-tab-header__item{color:buttonText;border-bottom-color:buttonText}:host(.is-negative) .nx-tab-header__item--active{background-color:highlight;color:highlightText;border-color:highlight;-ms-high-contrast-adjust:none}:host(.is-disabled.is-negative) .nx-tab-header__item{color:GrayText;border-bottom-color:GrayText}}"]
                    }] }
        ];
        /** @nocollapse */
        NxTabGroupComponent.ctorParameters = function () { return [
            { type: core.ChangeDetectorRef }
        ]; };
        NxTabGroupComponent.propDecorators = {
            tabs: [{ type: core.ContentChildren, args: [NxTabComponent,] }],
            tabBodyChildren: [{ type: core.ViewChildren, args: [NxTabBodyComponent,] }],
            tabHeader: [{ type: core.ViewChild, args: ['tabHeader', { static: false },] }],
            panels: [{ type: core.ViewChildren, args: [accordion$1.NxExpansionPanelComponent,] }],
            accordion: [{ type: core.ViewChild, args: [accordion$1.NxAccordionDirective, { static: false },] }],
            selectedIndex: [{ type: core.Input }],
            negative: [{ type: core.Input }],
            disabled: [{ type: core.Input }],
            autoselect: [{ type: core.Input }],
            mobileAccordion: [{ type: core.Input }],
            selectedIndexChange: [{ type: core.Output }],
            selectedTabChange: [{ type: core.Output }],
            focusChange: [{ type: core.Output }],
            onResize: [{ type: core.HostListener, args: ['window:resize', ['$event'],] }]
        };
        return NxTabGroupComponent;
    }());
    if (false) {
        /**
         * @type {?}
         * @private
         */
        NxTabGroupComponent.prototype._selectedIndex;
        /**
         * @type {?}
         * @private
         */
        NxTabGroupComponent.prototype._groupId;
        /**
         * @type {?}
         * @private
         */
        NxTabGroupComponent.prototype._negative;
        /**
         * @type {?}
         * @private
         */
        NxTabGroupComponent.prototype._disabled;
        /**
         * @type {?}
         * @private
         */
        NxTabGroupComponent.prototype._indexToSelect;
        /**
         * @type {?}
         * @private
         */
        NxTabGroupComponent.prototype._autoselect;
        /**
         * @type {?}
         * @private
         */
        NxTabGroupComponent.prototype._mobileAccordion;
        /** @type {?} */
        NxTabGroupComponent.prototype._showAccordion;
        /**
         * \@docs-private
         * @type {?}
         */
        NxTabGroupComponent.prototype.tabs;
        /**
         * \@docs-private
         * @type {?}
         */
        NxTabGroupComponent.prototype.tabBodyChildren;
        /**
         * \@docs-private
         * @type {?}
         */
        NxTabGroupComponent.prototype.tabHeader;
        /**
         * \@docs-private
         * @type {?}
         */
        NxTabGroupComponent.prototype.panels;
        /**
         * \@docs-private
         * @type {?}
         */
        NxTabGroupComponent.prototype.accordion;
        /**
         * An event emitted when the selected tab has changed.
         * @type {?}
         */
        NxTabGroupComponent.prototype.selectedIndexChange;
        /**
         * An event emitted when the selected tab has changed.
         * @type {?}
         */
        NxTabGroupComponent.prototype.selectedTabChange;
        /**
         * An event emitted when focus has changed within a tab group.
         *
         * **Note:** is not supported in mobile view.
         * @type {?}
         */
        NxTabGroupComponent.prototype.focusChange;
        /**
         * Subscription to tabs being added/removed.
         * @type {?}
         * @private
         */
        NxTabGroupComponent.prototype._tabsSubscription;
        /**
         * Subscription to changes in the tab labels.
         * @type {?}
         * @private
         */
        NxTabGroupComponent.prototype._tabLabelSubscription;
        /**
         * @type {?}
         * @private
         */
        NxTabGroupComponent.prototype._disabledTabsCache;
        /** @type {?} */
        NxTabGroupComponent.prototype._appearanceChange;
        /**
         * @type {?}
         * @private
         */
        NxTabGroupComponent.prototype._changeDetectorRef;
    }

    /**
     * @fileoverview added by tsickle
     * Generated from: tabs/tab-nav-bar.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var NxTabNavBarComponent = /** @class */ (function () {
        function NxTabNavBarComponent(_changeDetectorRef) {
            this._changeDetectorRef = _changeDetectorRef;
            this._negative = false;
            this._disabled = false;
        }
        Object.defineProperty(NxTabNavBarComponent.prototype, "negative", {
            get: /**
             * @return {?}
             */
            function () {
                return this._negative;
            },
            /** Whether the tab nav bar has negative styling. */
            set: /**
             * Whether the tab nav bar has negative styling.
             * @param {?} value
             * @return {?}
             */
            function (value) {
                /** @type {?} */
                var newValue = coercion.coerceBooleanProperty(value);
                if (newValue !== this.negative) {
                    this._negative = newValue;
                    this._changeDetectorRef.markForCheck();
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NxTabNavBarComponent.prototype, "disabled", {
            get: /**
             * @return {?}
             */
            function () {
                return this._disabled;
            },
            /** Whether the tab nav bar has disabled styling. */
            set: /**
             * Whether the tab nav bar has disabled styling.
             * @param {?} value
             * @return {?}
             */
            function (value) {
                /** @type {?} */
                var newValue = coercion.coerceBooleanProperty(value);
                if (newValue !== this.disabled) {
                    this._disabled = newValue;
                    this._changeDetectorRef.markForCheck();
                }
            },
            enumerable: true,
            configurable: true
        });
        NxTabNavBarComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'nx-tab-nav-bar',
                        template: "<ng-content></ng-content>",
                        changeDetection: core.ChangeDetectionStrategy.OnPush,
                        host: {
                            '[class.is-negative]': 'negative',
                            '[class.is-disabled]': 'disabled',
                            'role': 'navigation',
                        },
                        styles: [":host{display:flex;align-items:flex-end;justify-content:center}:host ::ng-deep a.nx-tab-link{font-size:18px;font-size:var(--tab-item-font-size,18px);line-height:24px;line-height:var(--tab-item-line-height,24px);font-weight:400;font-weight:var(--tab-item-font-weight,400);letter-spacing:.2px;letter-spacing:var(--tab-item-letter-spacing,.2px);text-decoration:none;border:#006192;background:0 0;color:#006192;color:var(--tab-item-color,#006192);border-color:var(--tab-item-border-color,#006192);border-bottom-width:2px;border-bottom-style:solid;padding:0 16px 6px;outline:0;margin:0}:host ::ng-deep a.nx-tab-link.is-active{border-width:4px;font-weight:700;transition:font-weight .3s;padding-bottom:4px}@media screen and (-ms-high-contrast:active){:host ::ng-deep a.nx-tab-link{background-color:buttonFace;border-color:buttonText;color:buttonText;-ms-high-contrast-adjust:none}:host ::ng-deep a.nx-tab-link.is-active{background-color:highlight;color:highlightText;border-color:highlight}}:host(.is-negative){color:#fff}:host(.is-negative) ::ng-deep a.nx-tab-link{color:#fff;border-bottom-color:#fff}:host(.is-negative) ::ng-deep a.nx-tab-link.is-disabled{color:rgba(255,255,255,.4);color:var(--tab-item-disabled-negative-color,rgba(255,255,255,.4));border-color:rgba(255,255,255,.4);border-color:var(--tab-item-disabled-negative-color,rgba(255,255,255,.4))}:host ::ng-deep a.nx-tab-link.is-disabled{border-color:#c2c2c2;border-color:var(--tab-item-disabled-border-color,#c2c2c2);color:#c2c2c2;color:var(--tab-item-disabled-color,#c2c2c2);cursor:not-allowed}@media screen and (-ms-high-contrast:active){:host(.is-negative) ::ng-deep a.nx-tab-link.is-active{background-color:highlight;color:highlightText;border-color:windowFrame}:host ::ng-deep a.nx-tab-link.is-disabled{border-color:GrayText;background-color:buttonFace;color:GrayText}}:host(.is-disabled){cursor:not-allowed}:host(.is-disabled.is-negative) ::ng-deep a.nx-tab-link{color:rgba(255,255,255,.4);color:var(--tab-item-disabled-negative-color,rgba(255,255,255,.4));border-color:rgba(255,255,255,.4);border-color:var(--tab-item-disabled-negative-color,rgba(255,255,255,.4))}:host-context([data-whatinput=keyboard]) ::ng-deep .nx-tab-link:not(.is-disabled):focus{box-shadow:0 0 0 2px #fff,0 0 0 6px #009de6;box-shadow:var(--focus-box-shadow,0 0 0 2px #fff,0 0 0 6px #009de6);border-radius:4px}@media screen and (-ms-high-contrast:active){:host-context([data-whatinput=keyboard]) ::ng-deep .nx-tab-link:not(.is-disabled):focus{box-shadow:0 0 0 2px background,0 0 0 6px windowText}:host(.is-negative){color:buttonText}:host(.is-negative) ::ng-deep a.nx-tab-link{color:buttonText;border-bottom-color:buttonText}:host(.is-negative) ::ng-deep a.nx-tab-link.is-active{background-color:highlight;color:highlightText;border-color:highlight}:host(.is-negative) ::ng-deep a.nx-tab-link.is-disabled{color:GrayText;border-bottom-color:GrayText}}"]
                    }] }
        ];
        /** @nocollapse */
        NxTabNavBarComponent.ctorParameters = function () { return [
            { type: core.ChangeDetectorRef }
        ]; };
        NxTabNavBarComponent.propDecorators = {
            negative: [{ type: core.Input }],
            disabled: [{ type: core.Input }]
        };
        return NxTabNavBarComponent;
    }());
    if (false) {
        /**
         * @type {?}
         * @private
         */
        NxTabNavBarComponent.prototype._negative;
        /**
         * @type {?}
         * @private
         */
        NxTabNavBarComponent.prototype._disabled;
        /**
         * @type {?}
         * @private
         */
        NxTabNavBarComponent.prototype._changeDetectorRef;
    }
    var NxTabLinkDirective = /** @class */ (function () {
        function NxTabLinkDirective(_tabNavBar) {
            this._tabNavBar = _tabNavBar;
            this._active = false;
            this._disabled = false;
            if (!this._tabNavBar) {
                throw Error("The nx-tab-link element has to be wrapped in a nx-tab-nav-bar to work.");
            }
        }
        Object.defineProperty(NxTabLinkDirective.prototype, "active", {
            /** Whether the tab link is active and has the active styling. */
            get: /**
             * Whether the tab link is active and has the active styling.
             * @return {?}
             */
            function () {
                return this._active;
            },
            set: /**
             * @param {?} value
             * @return {?}
             */
            function (value) {
                /** @type {?} */
                var newValue = coercion.coerceBooleanProperty(value);
                if (newValue !== this._active) {
                    this._active = value;
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NxTabLinkDirective.prototype, "disabled", {
            /** Whether the tab link is disabled. Default: false. */
            get: /**
             * Whether the tab link is disabled. Default: false.
             * @return {?}
             */
            function () {
                return (this._tabNavBar && this._tabNavBar.disabled) ? this._tabNavBar.disabled : this._disabled;
            },
            set: /**
             * @param {?} value
             * @return {?}
             */
            function (value) {
                /** @type {?} */
                var newValue = coercion.coerceBooleanProperty(value);
                if (newValue !== this._disabled) {
                    this._disabled = value;
                }
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        NxTabLinkDirective.prototype._getTabIndex = /**
         * @return {?}
         */
        function () {
            return (this.disabled) ? '-1' : '0';
        };
        NxTabLinkDirective.decorators = [
            { type: core.Directive, args: [{
                        selector: '[nxTabLink]',
                        host: {
                            '[class.nx-tab-link]': 'true',
                            '[class.is-active]': 'active',
                            '[class.is-disabled]': 'disabled',
                            '[attr.aria-current]': 'active',
                            '[attr.tabindex]': '_getTabIndex()',
                            '[attr.aria-disabled]': 'disabled.toString()',
                        }
                    },] }
        ];
        /** @nocollapse */
        NxTabLinkDirective.ctorParameters = function () { return [
            { type: NxTabNavBarComponent, decorators: [{ type: core.Optional }, { type: core.SkipSelf }] }
        ]; };
        NxTabLinkDirective.propDecorators = {
            active: [{ type: core.Input }],
            disabled: [{ type: core.Input }]
        };
        return NxTabLinkDirective;
    }());
    if (false) {
        /**
         * @type {?}
         * @private
         */
        NxTabLinkDirective.prototype._active;
        /**
         * @type {?}
         * @private
         */
        NxTabLinkDirective.prototype._disabled;
        /**
         * @type {?}
         * @private
         */
        NxTabLinkDirective.prototype._tabNavBar;
    }

    /**
     * @fileoverview added by tsickle
     * Generated from: tabs/tabs.module.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var NxTabsModule = /** @class */ (function () {
        function NxTabsModule() {
        }
        NxTabsModule.decorators = [
            { type: core.NgModule, args: [{
                        imports: [
                            common.CommonModule,
                            portal.PortalModule,
                            accordion$1.NxAccordionModule
                        ],
                        exports: [
                            NxTabComponent,
                            NxTabGroupComponent,
                            NxTabLabelDirective,
                            NxTabLabelWrapperDirective,
                            NxTabHeaderComponent,
                            NxTabBodyComponent,
                            NxTabNavBarComponent,
                            NxTabLinkDirective,
                            NxTabContentDirective
                        ],
                        declarations: [
                            NxTabComponent,
                            NxTabGroupComponent,
                            NxTabLabelDirective,
                            NxTabLabelWrapperDirective,
                            NxTabHeaderComponent,
                            NxTabBodyComponent,
                            NxTabNavBarComponent,
                            NxTabLinkDirective,
                            NxTabContentDirective,
                            NxTabHeaderOutletComponent
                        ],
                        providers: [],
                    },] }
        ];
        return NxTabsModule;
    }());

    /**
     * @fileoverview added by tsickle
     * Generated from: tabs/public-api.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * Generated from: core/breakpoints.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /** @type {?} */
    var BREAKPOINT_MOBILE = '(max-width: 703px)';
    /** @type {?} */
    var BREAKPOINT_TABLET = '(min-width: 704px) and (max-width: 992px)';
    /** @type {?} */
    var BREAKPOINT_DESKTOP = '(min-width: 993px)';

    /**
     * @fileoverview added by tsickle
     * Generated from: core/mapped-styles.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var MappedStyles = /** @class */ (function () {
        function MappedStyles(mapping, baseClasses, _elementRef, _renderer) {
            if (baseClasses === void 0) { baseClasses = []; }
            this.mapping = mapping;
            this.baseClasses = baseClasses;
            this._elementRef = _elementRef;
            this._renderer = _renderer;
            this.classNames = '';
        }
        Object.defineProperty(MappedStyles.prototype, "classNames", {
            get: /**
             * @return {?}
             */
            function () {
                return this._classNames;
            },
            set: /**
             * @param {?} value
             * @return {?}
             */
            function (value) {
                if (this._classNames === value) {
                    return;
                }
                utils.removeClasses(this._renderer, this._elementRef, this._classNamesSanitized);
                this._classNamesSanitized = utils.mapClassNames(value, this.baseClasses, this.mapping);
                this._classNames = value;
                utils.appendClasses(this._renderer, this._elementRef, this._classNamesSanitized);
            },
            enumerable: true,
            configurable: true
        });
        return MappedStyles;
    }());
    if (false) {
        /**
         * @type {?}
         * @private
         */
        MappedStyles.prototype._classNames;
        /**
         * @type {?}
         * @private
         */
        MappedStyles.prototype._classNamesSanitized;
        /**
         * @type {?}
         * @private
         */
        MappedStyles.prototype.mapping;
        /**
         * @type {?}
         * @private
         */
        MappedStyles.prototype.baseClasses;
        /**
         * @type {?}
         * @protected
         */
        MappedStyles.prototype._elementRef;
        /**
         * @type {?}
         * @protected
         */
        MappedStyles.prototype._renderer;
    }

    /**
     * @fileoverview added by tsickle
     * Generated from: core/public-api.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * Generated from: card/card.component.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var NxCardComponent = /** @class */ (function () {
        function NxCardComponent(_changeDetectorRef, tabindex) {
            this._changeDetectorRef = _changeDetectorRef;
            this._disabled = false;
            /**
             * Event emitted when the selected value has changed.
             *
             * This output  property of the card is deprecated,
             * as its selectable properties are deprecated as well.
             * Please use the selectable card component instead.
             *
             * @deprecated
             * \@deletion-target 10.0.0
             */
            this.selectedChange = new core.EventEmitter();
            this._tabindex = tabindex;
        }
        Object.defineProperty(NxCardComponent.prototype, "selectable", {
            get: /**
             * @return {?}
             */
            function () {
                return this._selectable;
            },
            /**
             * Whether this card is selectable or not.
             *
             * The selectable property of the card is deprecated.
             * Please use the selectable card component instead.
             *
             * @deprecated
             * @deletion-target 10.0.0
             */
            set: /**
             * Whether this card is selectable or not.
             *
             * The selectable property of the card is deprecated.
             * Please use the selectable card component instead.
             *
             * @deprecated
             * \@deletion-target 10.0.0
             * @param {?} value
             * @return {?}
             */
            function (value) {
                this._selectable = coercion.coerceBooleanProperty(value);
                this._changeDetectorRef.markForCheck();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NxCardComponent.prototype, "selected", {
            get: /**
             * @return {?}
             */
            function () {
                return this._selected;
            },
            /**
             * Whether this card is selected or not.
             *
             * The selected property of the card is deprecated.
             * Please use the selectable card component instead.
             *
             * @deprecated
             * @deletion-target 10.0.0
            */
            set: /**
             * Whether this card is selected or not.
             *
             * The selected property of the card is deprecated.
             * Please use the selectable card component instead.
             *
             * @deprecated
             * \@deletion-target 10.0.0
             * @param {?} value
             * @return {?}
             */
            function (value) {
                this._selected = coercion.coerceBooleanProperty(value);
                this._changeDetectorRef.markForCheck();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NxCardComponent.prototype, "disabled", {
            get: /**
             * @return {?}
             */
            function () {
                return this._disabled;
            },
            /**
             * Whether a selectable card is disabled or not.
             *
             * The disabled property of the card will be deprecated,
             * as its selectable properties are deprecated as well.
             * Please use the selectable card component instead.
             *
             * @deprecated
             * @deletion-target 10.0.0
            */
            set: /**
             * Whether a selectable card is disabled or not.
             *
             * The disabled property of the card will be deprecated,
             * as its selectable properties are deprecated as well.
             * Please use the selectable card component instead.
             *
             * @deprecated
             * \@deletion-target 10.0.0
             * @param {?} value
             * @return {?}
             */
            function (value) {
                this._disabled = coercion.coerceBooleanProperty(value);
                this._changeDetectorRef.markForCheck();
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        NxCardComponent.prototype._toggleSelected = /**
         * @return {?}
         */
        function () {
            if (this.selectable && !this.disabled) {
                this.selected = !this.selected;
                this.selectedChange.emit(this.selected);
            }
        };
        /**
         * @return {?}
         */
        NxCardComponent.prototype._getTabindex = /**
         * @return {?}
         */
        function () {
            if (this.disabled) {
                return '-1';
            }
            if (this.selectable) {
                return this._tabindex || '0';
            }
            return this._tabindex || '';
        };
        NxCardComponent.decorators = [
            { type: core.Component, args: [{
                        template: '<ng-content></ng-content>',
                        selector: 'nx-card',
                        changeDetection: core.ChangeDetectionStrategy.OnPush,
                        host: {
                            'class': 'nx-card',
                            '[class.is-selectable]': 'selectable',
                            '[class.is-selected]': 'selected',
                            '[class.is-disabled]': 'disabled',
                            '[attr.aria-disabled]': 'disabled',
                            '(click)': '_toggleSelected()',
                            '(keydown.enter)': '_toggleSelected()',
                            '[attr.tabindex]': '_getTabindex()'
                        },
                        styles: [":host{background:#fff;background:var(--card-background-color,#fff);border-color:var(--card-border-color,#d9d9d9);border-width:var(--card-border-width,1px);border-radius:4px;border-radius:var(--card-border-radius,4px);box-shadow:none;display:inline-block;margin-bottom:24px;padding:23px;transition:background-color .2s,box-shadow .2s;border:1px solid #d9d9d9}:host:focus,:host:hover{outline:0}:host.is-selectable{cursor:pointer}:host.is-selectable:hover{background:#f5f5f5;background:var(--card-background-hover-color,#f5f5f5)}:host.is-selected{box-shadow:0 8px 24px rgba(65,65,65,.35);background:#f5f5f5;background:var(--card-background-selected-color,#f5f5f5)}:host.is-disabled{cursor:not-allowed;opacity:.4}:host.is-disabled:hover{background:#fff;background:var(--card-background-color,#fff)}:host-context([data-whatinput=keyboard]):focus{box-shadow:0 0 0 2px #fff,0 0 0 6px #009de6;box-shadow:var(--focus-box-shadow,0 0 0 2px #fff,0 0 0 6px #009de6)}@media screen and (-ms-high-contrast:active){:host-context([data-whatinput=keyboard]):focus{box-shadow:0 0 0 2px background,0 0 0 6px windowText}:host.is-selectable{border-color:buttonText}:host.is-selected{border-width:3px;padding:21px;border-color:highlight}:host.is-disabled{opacity:1;border-color:GrayText;color:GrayText}}"]
                    }] }
        ];
        /** @nocollapse */
        NxCardComponent.ctorParameters = function () { return [
            { type: core.ChangeDetectorRef },
            { type: String, decorators: [{ type: core.Attribute, args: ['tabindex',] }] }
        ]; };
        NxCardComponent.propDecorators = {
            selectable: [{ type: core.Input }],
            selected: [{ type: core.Input }],
            disabled: [{ type: core.Input }],
            selectedChange: [{ type: core.Output }]
        };
        return NxCardComponent;
    }());
    if (false) {
        /** @type {?} */
        NxCardComponent.prototype._tabindex;
        /**
         * @type {?}
         * @private
         */
        NxCardComponent.prototype._selectable;
        /**
         * @type {?}
         * @private
         */
        NxCardComponent.prototype._selected;
        /**
         * @type {?}
         * @private
         */
        NxCardComponent.prototype._disabled;
        /**
         * Event emitted when the selected value has changed.
         *
         * This output  property of the card is deprecated,
         * as its selectable properties are deprecated as well.
         * Please use the selectable card component instead.
         *
         * @deprecated
         * \@deletion-target 10.0.0
         * @type {?}
         */
        NxCardComponent.prototype.selectedChange;
        /**
         * @type {?}
         * @private
         */
        NxCardComponent.prototype._changeDetectorRef;
    }

    /**
     * @fileoverview added by tsickle
     * Generated from: card/card.module.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var NxCardModule = /** @class */ (function () {
        function NxCardModule() {
        }
        NxCardModule.decorators = [
            { type: core.NgModule, args: [{
                        declarations: [NxCardComponent],
                        exports: [NxCardComponent],
                        imports: [
                            common.CommonModule
                        ]
                    },] }
        ];
        return NxCardModule;
    }());

    /**
     * @fileoverview added by tsickle
     * Generated from: card/selectable-card.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * \@docs-private
     * @abstract
     */
    var   /**
     * \@docs-private
     * @abstract
     */
    SelectableCard = /** @class */ (function () {
        function SelectableCard() {
        }
        return SelectableCard;
    }());
    if (false) {
        /** @type {?} */
        SelectableCard.prototype.id;
        /** @type {?} */
        SelectableCard.prototype.value;
        /** @type {?} */
        SelectableCard.prototype.checked;
        /** @type {?} */
        SelectableCard.prototype.name;
        /** @type {?} */
        SelectableCard.prototype.negative;
        /** @type {?} */
        SelectableCard.prototype.disabled;
        /** @type {?} */
        SelectableCard.prototype.checkedChange;
        /** @type {?} */
        SelectableCard.prototype.selectionChange;
    }

    /**
     * @fileoverview added by tsickle
     * Generated from: card/selectable-card-change-event.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var NxSelectableCardChangeEvent = /** @class */ (function () {
        function NxSelectableCardChangeEvent(checked, value, card) {
            this.checked = checked;
            this.value = value;
            this.card = card;
        }
        return NxSelectableCardChangeEvent;
    }());
    if (false) {
        /**
         * The checked value of the selectable card.
         * @type {?}
         */
        NxSelectableCardChangeEvent.prototype.checked;
        /**
         * The value of the selectable card.
         * @type {?}
         */
        NxSelectableCardChangeEvent.prototype.value;
        /**
         * The component instance of the selectable card which emitted the change event.
         * @type {?}
         */
        NxSelectableCardChangeEvent.prototype.card;
    }

    /**
     * @fileoverview added by tsickle
     * Generated from: card/selectable-card.component.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /** @type {?} */
    var nextId$b = 0;
    var NxSelectableCardComponent = /** @class */ (function (_super) {
        __extends(NxSelectableCardComponent, _super);
        function NxSelectableCardComponent(_changeDetectorRef, _errorStateMatcher, ngControl, _parentForm, _parentFormGroup) {
            var _this = _super.call(this) || this;
            _this._changeDetectorRef = _changeDetectorRef;
            _this._errorStateMatcher = _errorStateMatcher;
            _this.ngControl = ngControl;
            _this._parentForm = _parentForm;
            _this._parentFormGroup = _parentFormGroup;
            _this._id = (nextId$b++).toString();
            _this._checked = false;
            _this._disabled = false;
            _this._negative = false;
            _this._tabindex = '0';
            /**
             * \@docs-private
             */
            _this._errorListIds = '';
            /**
             * \@docs-private
             */
            _this.errorState = false;
            /**
             * \@docs-private
             */
            _this.stateChanges = new rxjs.Subject();
            /**
             * An event is dispatched each time the selectable card value is changed
             */
            _this.selectionChange = new core.EventEmitter();
            /**
             * An event is dispatched each time the selectable card value is changed
             */
            _this.checkedChange = new core.EventEmitter();
            /**
             * \@docs-private
             */
            _this.onChangeCallback = (/**
             * @param {?} _
             * @return {?}
             */
            function (_) { });
            _this.onTouchedCallback = (/**
             * @param {?} _
             * @return {?}
             */
            function (_) { });
            if (_this.ngControl) {
                // Note: we provide the value accessor through here, instead of
                // the `providers` to avoid running into a circular import.
                _this.ngControl.valueAccessor = _this;
            }
            return _this;
        }
        Object.defineProperty(NxSelectableCardComponent.prototype, "id", {
            get: /**
             * @return {?}
             */
            function () {
                return "nx-selectable-card-" + this._id;
            },
            /**
             * Id of the selectable card.
             *
             * If not set, the selectable card gets an incremented value by default.
             */
            set: /**
             * Id of the selectable card.
             *
             * If not set, the selectable card gets an incremented value by default.
             * @param {?} value
             * @return {?}
             */
            function (value) {
                if (value !== this._id) {
                    this._id = value;
                    this._changeDetectorRef.markForCheck();
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NxSelectableCardComponent.prototype, "checked", {
            get: /**
             * @return {?}
             */
            function () {
                return this._checked;
            },
            /** Whether the selectable card  is checked. */
            set: /**
             * Whether the selectable card  is checked.
             * @param {?} value
             * @return {?}
             */
            function (value) {
                /** @type {?} */
                var newValue = coercion.coerceBooleanProperty(value);
                if (newValue !== this._checked) {
                    this._checked = newValue;
                    this._changeDetectorRef.markForCheck();
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NxSelectableCardComponent.prototype, "value", {
            /** The value attribute of the native input element  */
            get: /**
             * The value attribute of the native input element
             * @return {?}
             */
            function () {
                return this._value;
            },
            set: /**
             * @param {?} value
             * @return {?}
             */
            function (value) {
                if (value) {
                    this._value = value;
                }
                this._changeDetectorRef.markForCheck();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NxSelectableCardComponent.prototype, "disabled", {
            get: /**
             * @return {?}
             */
            function () {
                return this._disabled || null;
            },
            /** Whether the selectable card is disabled. */
            set: /**
             * Whether the selectable card is disabled.
             * @param {?} value
             * @return {?}
             */
            function (value) {
                /** @type {?} */
                var newValue = coercion.coerceBooleanProperty(value);
                if (newValue !== this._disabled) {
                    this._disabled = newValue;
                    this._changeDetectorRef.markForCheck();
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NxSelectableCardComponent.prototype, "negative", {
            get: /**
             * @return {?}
             */
            function () {
                return this._negative || null;
            },
            /** Whether the selectable card is negative. */
            set: /**
             * Whether the selectable card is negative.
             * @param {?} value
             * @return {?}
             */
            function (value) {
                /** @type {?} */
                var newValue = coercion.coerceBooleanProperty(value);
                if (newValue !== this._negative) {
                    this._negative = newValue;
                    this._changeDetectorRef.markForCheck();
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NxSelectableCardComponent.prototype, "required", {
            /** Whether the selectable card is required. */
            get: /**
             * Whether the selectable card is required.
             * @return {?}
             */
            function () {
                return this._required;
            },
            set: /**
             * @param {?} value
             * @return {?}
             */
            function (value) {
                this._required = coercion.coerceBooleanProperty(value);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NxSelectableCardComponent.prototype, "name", {
            /** Name of the selectable card. */
            get: /**
             * Name of the selectable card.
             * @return {?}
             */
            function () {
                return this._name;
            },
            set: /**
             * @param {?} value
             * @return {?}
             */
            function (value) {
                this._name = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NxSelectableCardComponent.prototype, "tabindex", {
            /** The tabIndex of the element */
            get: /**
             * The tabIndex of the element
             * @return {?}
             */
            function () {
                if (this.disabled) {
                    return '-1';
                }
                return this._tabindex;
            },
            set: /**
             * @param {?} value
             * @return {?}
             */
            function (value) {
                this._tabindex = value;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        NxSelectableCardComponent.prototype.ngAfterContentInit = /**
         * @return {?}
         */
        function () {
            var _this = this;
            this._errorList.changes.subscribe((/**
             * @param {?} value
             * @return {?}
             */
            function (value) {
                _this._errorListIds = value.map((/**
                 * @param {?} errorItem
                 * @return {?}
                 */
                function (errorItem) {
                    return errorItem.id;
                })).join(' ');
                _this._changeDetectorRef.markForCheck();
            }));
            this._errorListIds = this._errorList.map((/**
             * @param {?} errorItem
             * @return {?}
             */
            function (errorItem) {
                return errorItem.id;
            })).join(' ');
        };
        /**
         * @param {?} fn
         * @return {?}
         */
        NxSelectableCardComponent.prototype.registerOnChange = /**
         * @param {?} fn
         * @return {?}
         */
        function (fn) {
            this.onChangeCallback = fn;
        };
        /**
         * @param {?} onTouched
         * @return {?}
         */
        NxSelectableCardComponent.prototype.registerOnTouched = /**
         * @param {?} onTouched
         * @return {?}
         */
        function (onTouched) {
            this.onTouchedCallback = onTouched;
        };
        /**
         * @param {?} isDisabled
         * @return {?}
         */
        NxSelectableCardComponent.prototype.setDisabledState = /**
         * @param {?} isDisabled
         * @return {?}
         */
        function (isDisabled) {
            this.disabled = isDisabled;
        };
        /**
         * @param {?} value
         * @return {?}
         */
        NxSelectableCardComponent.prototype.writeValue = /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this.checked = !!value;
        };
        /**
         * @return {?}
         */
        NxSelectableCardComponent.prototype.ngDoCheck = /**
         * @return {?}
         */
        function () {
            if (this.ngControl) {
                // We need to re-evaluate this on every change detection cycle, because there are some
                // error triggers that we can't subscribe to (e.g. parent form submissions). This means
                // that whatever logic is in here has to be super lean or we risk destroying the performance.
                this.updateErrorState();
            }
        };
        /** @docs-private */
        /**
         * \@docs-private
         * @return {?}
         */
        NxSelectableCardComponent.prototype.updateErrorState = /**
         * \@docs-private
         * @return {?}
         */
        function () {
            /** @type {?} */
            var oldState = this.errorState;
            /** @type {?} */
            var parent = this._parentFormGroup || this._parentForm;
            /** @type {?} */
            var control = this.ngControl ? (/** @type {?} */ (this.ngControl.control)) : null;
            /** @type {?} */
            var newState = this._errorStateMatcher.isErrorState(control, parent);
            if (newState !== oldState) {
                this.errorState = newState;
                this.stateChanges.next();
            }
        };
        /** Toggles the checked state of the selectable card . */
        /**
         * Toggles the checked state of the selectable card .
         * @return {?}
         */
        NxSelectableCardComponent.prototype.toggle = /**
         * Toggles the checked state of the selectable card .
         * @return {?}
         */
        function () {
            if (!this.disabled) {
                this.checked = !this.checked;
            }
        };
        /** @docs-private */
        /**
         * \@docs-private
         * @param {?} event
         * @return {?}
         */
        NxSelectableCardComponent.prototype._onInputClick = /**
         * \@docs-private
         * @param {?} event
         * @return {?}
         */
        function (event) {
            // We have to stop propagation for click events on the visual hidden input element.
            // By default, when a user clicks on a label element, a generated click event will be
            // stop the propagation of the native click on the checkbox input so that a click is not triggered twice
            // Preventing bubbling for the second event will solve that issue.
            event.stopPropagation();
            if (!this.disabled) {
                this.toggle();
                this._emitChangeEvent();
            }
        };
        /** @docs-private */
        /**
         * \@docs-private
         * @param {?} event
         * @return {?}
         */
        NxSelectableCardComponent.prototype._onInteractionEvent = /**
         * \@docs-private
         * @param {?} event
         * @return {?}
         */
        function (event) {
            // We always have to stop propagation on the change event.
            // Otherwise the change event, from the input element, will bubble up and
            // emit its event object to the `change` output.
            event.stopPropagation();
        };
        /** @docs-private */
        /**
         * \@docs-private
         * @private
         * @return {?}
         */
        NxSelectableCardComponent.prototype._emitChangeEvent = /**
         * \@docs-private
         * @private
         * @return {?}
         */
        function () {
            /** @type {?} */
            var event = new NxSelectableCardChangeEvent(this.checked, this.value, this);
            this.onChangeCallback(this.checked);
            this.selectionChange.emit(event);
            this.checkedChange.emit(this.checked);
        };
        NxSelectableCardComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'nx-selectable-card',
                        template: "<input #input\n       type=\"checkbox\"\n       [checked]=\"checked\"\n       [value]=\"value || null\"\n       [attr.disabled]=\"disabled\"\n       (change)=\"_onInteractionEvent($event)\"\n       (blur)=\"onTouchedCallback($event)\"\n       [attr.id]=\"id\"\n       [attr.name]=\"name\"\n       (click)=\"_onInputClick($event)\"\n       [required]=\"required\"\n       [attr.aria-required]=\"required\"\n       [attr.tabindex]=\"tabindex\"\n       [attr.aria-invalid]=\"errorState\"\n       [attr.aria-describedby]=\"_errorListIds || null\"\n>\n\n<label [attr.for]=\"id\" [class.is-disabled]=\"disabled\">\n  <ng-container *ngTemplateOutlet=\"selectableCardContent\"></ng-container>\n</label>\n\n<ng-content *ngIf=\"errorState\" select=\"nx-error\"></ng-content>\n\n<ng-template #selectableCardContent>\n  <nx-icon name=\"check-circle\" size=\"s\" class=\"checked-icon\"></nx-icon>\n  <div class=\"nx-selectable-card--headline\">\n    <ng-content select=\"nx-card-header\"></ng-content>\n  </div>\n  <div class=\"nx-selectable-card--content\">\n    <ng-content></ng-content>\n  </div>\n  <div class=\"nx-selectable-card--footer\">\n    <ng-content select=\"nx-card-footer\"></ng-content>\n  </div>\n</ng-template>\n",
                        changeDetection: core.ChangeDetectionStrategy.OnPush,
                        providers: [{ provide: SelectableCard, useExisting: core.forwardRef((/**
                                 * @return {?}
                                 */
                                function () { return NxSelectableCardComponent; })) }],
                        host: {
                            '[class.is-checked]': 'checked',
                            '[class.is-disabled]': 'disabled',
                            '[class.has-error]': 'errorState',
                            '[attr.aria-invalid]': 'errorState',
                            '[attr.role]': '"checkbox"',
                            '[attr.aria-checked]': 'checked'
                        },
                        styles: [":host{display:block}:host input{position:absolute;height:0;width:0;overflow:hidden;opacity:0}:host label{border:1px solid #999;border:var(--selectable-card-border-width,1px) solid var(--selectable-card-border-color,#999);display:block;position:relative;padding:16px;cursor:pointer;width:100%;margin-bottom:8px;border-radius:4px;border-radius:var(--selectable-card-border-radius,4px);background:#fff;background:var(--selectable-card-background-color,#fff)}:host:focus{outline:0}:host::-moz-focus-inner{border:0}:host input:checked+label{background:#f5f5f5;background:var(--selectable-card-background-selected-color,#f5f5f5);border-color:#414141;border-color:var(--selectable-card-border-selected-color,#414141)}:host input:checked+label ::ng-deep nx-icon.checked-icon{display:block}:host label:active,:host label:hover{background:#f5f5f5;background:var(--selectable-card-background-hover-color,#f5f5f5);border-color:#414141;border-color:var(--selectable-card-border-hover-color,#414141)}:host input:checked+label:hover{background:#ececec;background:var(--selectable-card-background-selected-hover-color,#ececec)}:host ::ng-deep nx-icon.checked-icon{position:absolute;right:8px;top:8px;display:none}:host(.is-disabled) label{border-color:#ececec;border-color:var(--selectable-card-border-disabled-color,#ececec);cursor:not-allowed}:host(.is-disabled) label:hover{background:#fff;background:var(--selectable-card-background-disabled-color,#fff)}:host(.is-disabled) input:checked+label{background:#f5f5f5;background:var(--selectable-card-background-disabled-selected-color,#f5f5f5);border-color:#c2c2c2;border-color:var(--selectable-card-border-disabled-selected-color,#c2c2c2)}:host(.is-disabled) input:checked+label ::ng-deep nx-icon.checked-icon{display:block;color:#c2c2c2;color:var(--selectable-card-icon-diabled-color,#c2c2c2)}:host(.has-error) input:checked+label,:host(.has-error) input:checked+label:hover,:host(.has-error) label,:host(.has-error) label:hover{border-color:#dc3149;border-color:var(--selectable-card-border-error-color,#dc3149)}:host-context([data-whatinput=keyboard]) :host:focus label,:host-context([data-whatinput=keyboard]) input:focus+label{box-shadow:0 0 0 2px #fff,0 0 0 6px #009de6;box-shadow:var(--focus-box-shadow,0 0 0 2px #fff,0 0 0 6px #009de6)}@media screen and (-ms-high-contrast:active){:host-context([data-whatinput=keyboard]) :host:focus label,:host-context([data-whatinput=keyboard]) input:focus+label{box-shadow:0 0 0 2px background,0 0 0 6px windowText}:host label{border-color:buttonText}:host input:checked+label{border-width:3px;padding:14px;border-color:highlight}:host(.is-disabled) input:checked+label,:host(.is-disabled) label{border-color:GrayText;color:GrayText}:host(.is-disabled) input:checked+label ::ng-deep nx-icon.checked-icon,:host(.is-disabled) label ::ng-deep nx-icon.checked-icon{color:GrayText}}"]
                    }] }
        ];
        /** @nocollapse */
        NxSelectableCardComponent.ctorParameters = function () { return [
            { type: core.ChangeDetectorRef },
            { type: utils.ErrorStateMatcher },
            { type: forms.NgControl, decorators: [{ type: core.Self }, { type: core.Optional }] },
            { type: forms.NgForm, decorators: [{ type: core.Optional }] },
            { type: forms.FormGroupDirective, decorators: [{ type: core.Optional }] }
        ]; };
        NxSelectableCardComponent.propDecorators = {
            _errorList: [{ type: core.ContentChildren, args: [base.NxErrorComponent,] }],
            selectionChange: [{ type: core.Output }],
            checkedChange: [{ type: core.Output }],
            id: [{ type: core.Input }],
            checked: [{ type: core.Input }],
            value: [{ type: core.Input }],
            disabled: [{ type: core.Input }],
            negative: [{ type: core.Input }],
            required: [{ type: core.Input }],
            name: [{ type: core.Input }],
            tabindex: [{ type: core.Input }]
        };
        return NxSelectableCardComponent;
    }(SelectableCard));
    if (false) {
        /**
         * @type {?}
         * @private
         */
        NxSelectableCardComponent.prototype._id;
        /**
         * @type {?}
         * @private
         */
        NxSelectableCardComponent.prototype._checked;
        /**
         * @type {?}
         * @private
         */
        NxSelectableCardComponent.prototype._disabled;
        /**
         * @type {?}
         * @private
         */
        NxSelectableCardComponent.prototype._value;
        /**
         * @type {?}
         * @private
         */
        NxSelectableCardComponent.prototype._name;
        /**
         * @type {?}
         * @private
         */
        NxSelectableCardComponent.prototype._negative;
        /**
         * @type {?}
         * @private
         */
        NxSelectableCardComponent.prototype._tabindex;
        /**
         * @type {?}
         * @private
         */
        NxSelectableCardComponent.prototype._required;
        /**
         * \@docs-private
         * @type {?}
         */
        NxSelectableCardComponent.prototype._errorListIds;
        /**
         * \@docs-private
         * @type {?}
         */
        NxSelectableCardComponent.prototype._errorList;
        /**
         * \@docs-private
         * @type {?}
         */
        NxSelectableCardComponent.prototype.errorState;
        /**
         * \@docs-private
         * @type {?}
         */
        NxSelectableCardComponent.prototype.stateChanges;
        /**
         * An event is dispatched each time the selectable card value is changed
         * @type {?}
         */
        NxSelectableCardComponent.prototype.selectionChange;
        /**
         * An event is dispatched each time the selectable card value is changed
         * @type {?}
         */
        NxSelectableCardComponent.prototype.checkedChange;
        /**
         * \@docs-private
         * @type {?}
         */
        NxSelectableCardComponent.prototype.onChangeCallback;
        /** @type {?} */
        NxSelectableCardComponent.prototype.onTouchedCallback;
        /**
         * @type {?}
         * @private
         */
        NxSelectableCardComponent.prototype._changeDetectorRef;
        /**
         * @type {?}
         * @private
         */
        NxSelectableCardComponent.prototype._errorStateMatcher;
        /** @type {?} */
        NxSelectableCardComponent.prototype.ngControl;
        /**
         * @type {?}
         * @private
         */
        NxSelectableCardComponent.prototype._parentForm;
        /**
         * @type {?}
         * @private
         */
        NxSelectableCardComponent.prototype._parentFormGroup;
    }

    /**
     * @fileoverview added by tsickle
     * Generated from: card/card-header.component.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var NxCardHeaderComponent = /** @class */ (function () {
        function NxCardHeaderComponent() {
        }
        NxCardHeaderComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'nx-card-header',
                        template: "<ng-content></ng-content>\n",
                        changeDetection: core.ChangeDetectionStrategy.OnPush
                    }] }
        ];
        return NxCardHeaderComponent;
    }());

    /**
     * @fileoverview added by tsickle
     * Generated from: card/card-footer.component.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var NxCardFooterComponent = /** @class */ (function () {
        function NxCardFooterComponent() {
        }
        NxCardFooterComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'nx-card-footer',
                        template: "<ng-content></ng-content>\n",
                        changeDetection: core.ChangeDetectionStrategy.OnPush
                    }] }
        ];
        return NxCardFooterComponent;
    }());

    /**
     * @fileoverview added by tsickle
     * Generated from: card/selectable-card.module.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var NxSelectableCardModule = /** @class */ (function () {
        function NxSelectableCardModule() {
        }
        NxSelectableCardModule.decorators = [
            { type: core.NgModule, args: [{
                        declarations: [
                            NxSelectableCardComponent,
                            NxCardHeaderComponent,
                            NxCardFooterComponent
                        ],
                        exports: [
                            NxSelectableCardComponent,
                            NxCardHeaderComponent,
                            NxCardFooterComponent
                        ],
                        imports: [
                            common.CommonModule,
                            icon.NxIconModule,
                            base.NxErrorModule
                        ]
                    },] }
        ];
        return NxSelectableCardModule;
    }());

    exports.BREAKPOINT_DESKTOP = BREAKPOINT_DESKTOP;
    exports.BREAKPOINT_MOBILE = BREAKPOINT_MOBILE;
    exports.BREAKPOINT_TABLET = BREAKPOINT_TABLET;
    exports.DefaultPaginationTexts = DefaultPaginationTexts;
    exports.MappedStyles = MappedStyles;
    exports.NX_AUTOCOMPLETE_VALUE_ACCESSOR = NX_AUTOCOMPLETE_VALUE_ACCESSOR;
    exports.NX_MESSAGE_TOAST_DEFAULT_CONFIG = NX_MESSAGE_TOAST_DEFAULT_CONFIG;
    exports.NX_PAGINATION_TEXTS = NX_PAGINATION_TEXTS;
    exports.NdbxModule = NdbxModule;
    exports.NxAccordionDirective = NxAccordionDirective;
    exports.NxAccordionModule = NxAccordionModule;
    exports.NxAutocompleteComponent = NxAutocompleteComponent;
    exports.NxAutocompleteModule = NxAutocompleteModule;
    exports.NxAutocompleteOptionComponent = NxAutocompleteOptionComponent;
    exports.NxAutocompleteOptionSelected = NxAutocompleteOptionSelected;
    exports.NxAutocompleteSelectedEvent = NxAutocompleteSelectedEvent;
    exports.NxAutocompleteTriggerDirective = NxAutocompleteTriggerDirective;
    exports.NxButtonBase = NxButtonBase;
    exports.NxButtonComponent = NxButtonComponent;
    exports.NxButtonModule = NxButtonModule;
    exports.NxCardComponent = NxCardComponent;
    exports.NxCardFooterComponent = NxCardFooterComponent;
    exports.NxCardHeaderComponent = NxCardHeaderComponent;
    exports.NxCardModule = NxCardModule;
    exports.NxCheckboxChangeEvent = NxCheckboxChangeEvent;
    exports.NxCheckboxComponent = NxCheckboxComponent;
    exports.NxCheckboxGroupComponent = NxCheckboxGroupComponent;
    exports.NxCheckboxModule = NxCheckboxModule;
    exports.NxCircleToggleComponent = NxCircleToggleComponent;
    exports.NxCircleToggleGroupComponent = NxCircleToggleGroupComponent;
    exports.NxCircleToggleModule = NxCircleToggleModule;
    exports.NxCopytextComponent = NxCopytextComponent;
    exports.NxCopytextModule = NxCopytextModule;
    exports.NxDropdownComponent = NxDropdownComponent;
    exports.NxDropdownGroupComponent = NxDropdownGroupComponent;
    exports.NxDropdownItemChange = NxDropdownItemChange;
    exports.NxDropdownItemComponent = NxDropdownItemComponent;
    exports.NxDropdownModule = NxDropdownModule;
    exports.NxDropdownSelectChange = NxDropdownSelectChange;
    exports.NxDynamicTableComponent = NxDynamicTableComponent;
    exports.NxDynamicTableModule = NxDynamicTableModule;
    exports.NxExpansionPanelComponent = NxExpansionPanelComponent;
    exports.NxFigureComponent = NxFigureComponent;
    exports.NxHeadlineComponent = NxHeadlineComponent;
    exports.NxHeadlineModule = NxHeadlineModule;
    exports.NxIconButtonComponent = NxIconButtonComponent;
    exports.NxIconToggleButtonComponent = NxIconToggleButtonComponent;
    exports.NxImageDirective = NxImageDirective;
    exports.NxImageModule = NxImageModule;
    exports.NxLinkComponent = NxLinkComponent;
    exports.NxLinkModule = NxLinkModule;
    exports.NxListComponent = NxListComponent;
    exports.NxListModule = NxListModule;
    exports.NxMessageComponent = NxMessageComponent;
    exports.NxMessageModule = NxMessageModule;
    exports.NxMessageToastComponent = NxMessageToastComponent;
    exports.NxMessageToastConfig = NxMessageToastConfig;
    exports.NxMessageToastData = NxMessageToastData;
    exports.NxMessageToastRef = NxMessageToastRef;
    exports.NxMessageToastService = NxMessageToastService;
    exports.NxMobileToggleButtonComponent = NxMobileToggleButtonComponent;
    exports.NxModalActionsDirective = NxModalActionsDirective;
    exports.NxModalComponent = NxModalComponent;
    exports.NxModalContentDirective = NxModalContentDirective;
    exports.NxModalModule = NxModalModule;
    exports.NxModalService = NxModalService;
    exports.NxNaturalLanguageFormComponent = NxNaturalLanguageFormComponent;
    exports.NxNaturalLanguageFormModule = NxNaturalLanguageFormModule;
    exports.NxNumberStepperComponent = NxNumberStepperComponent;
    exports.NxNumberStepperIntl = NxNumberStepperIntl;
    exports.NxNumberStepperModule = NxNumberStepperModule;
    exports.NxNumberStepperPrefixDirective = NxNumberStepperPrefixDirective;
    exports.NxNumberStepperSuffixDirective = NxNumberStepperSuffixDirective;
    exports.NxOpenModalOnClickDirective = NxOpenModalOnClickDirective;
    exports.NxPageSearchComponent = NxPageSearchComponent;
    exports.NxPageSearchModule = NxPageSearchModule;
    exports.NxPaginationComponent = NxPaginationComponent;
    exports.NxPaginationModule = NxPaginationModule;
    exports.NxPaginationUtils = NxPaginationUtils;
    exports.NxPopoverComponent = NxPopoverComponent;
    exports.NxPopoverContentDirective = NxPopoverContentDirective;
    exports.NxPopoverModule = NxPopoverModule;
    exports.NxPopoverTriggerDirective = NxPopoverTriggerDirective;
    exports.NxRadioChange = NxRadioChange;
    exports.NxRadioComponent = NxRadioComponent;
    exports.NxRadioGroupComponent = NxRadioGroupComponent;
    exports.NxRadioModule = NxRadioModule;
    exports.NxRadioToggleComponent = NxRadioToggleComponent;
    exports.NxRadioToggleModule = NxRadioToggleModule;
    exports.NxRatingComponent = NxRatingComponent;
    exports.NxRatingModule = NxRatingModule;
    exports.NxSelectableCardComponent = NxSelectableCardComponent;
    exports.NxSelectableCardModule = NxSelectableCardModule;
    exports.NxSpinnerComponent = NxSpinnerComponent;
    exports.NxSpinnerModule = NxSpinnerModule;
    exports.NxSwitcherComponent = NxSwitcherComponent;
    exports.NxSwitcherModule = NxSwitcherModule;
    exports.NxTabBodyComponent = NxTabBodyComponent;
    exports.NxTabChangeEvent = NxTabChangeEvent;
    exports.NxTabComponent = NxTabComponent;
    exports.NxTabContentDirective = NxTabContentDirective;
    exports.NxTabGroupComponent = NxTabGroupComponent;
    exports.NxTabHeaderComponent = NxTabHeaderComponent;
    exports.NxTabLabelDirective = NxTabLabelDirective;
    exports.NxTabLinkDirective = NxTabLinkDirective;
    exports.NxTabNavBarComponent = NxTabNavBarComponent;
    exports.NxTabsModule = NxTabsModule;
    exports.NxTaglistComponent = NxTaglistComponent;
    exports.NxTaglistModule = NxTaglistModule;
    exports.NxVideoComponent = NxVideoComponent;
    exports.NxVideoModule = NxVideoModule;
    exports.NxWordComponent = NxWordComponent;
    exports.ToggleChangeEvent = ToggleChangeEvent;
    exports.getNxAutocompleteMissingPanelError = getNxAutocompleteMissingPanelError;
    exports.messageToastAnimations = messageToastAnimations;
    exports.a = ToggleButton;
    exports.b = NxListIconComponent;
    exports.c = NxRadioToggleButtonBaseComponent;
    exports.d = NxRadioToggleButtonComponent;
    exports.e = fadeIn;
    exports.f = fadeOut;
    exports.g = scaleUp;
    exports.h = scaleDown;
    exports.i = NxTagComponent;
    exports.j = NxDropdownControl;
    exports.k = NxDropdownClosedLabelDirective;
    exports.l = NxAutoResizeDirective;
    exports.m = nxAccordionAnimations;
    exports.n = NxExpansionPanelBodyDirective;
    exports.o = NxExpansionPanelHeaderComponent;
    exports.p = NxExpansionPanelDescriptionDirective;
    exports.q = NxExpansionPanelTitleDirective;
    exports.r = NxTabGroupBase;
    exports.s = NxTabLabelWrapperDirective;
    exports.t = NxTabHeaderOutletComponent;
    exports.u = SelectableCard;

    Object.defineProperty(exports, '__esModule', { value: true });

})));
//# sourceMappingURL=allianz-ngx-ndbx.umd.js.map
