(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@angular/core'), require('@angular/common'), require('@angular/cdk/coercion'), require('@allianz/ngx-ndbx/utils'), require('@angular/forms'), require('rxjs'), require('rxjs/operators'), require('@angular/cdk/collections'), require('@allianz/ngx-ndbx/icon')) :
    typeof define === 'function' && define.amd ? define('@allianz/ngx-ndbx/radio-toggle', ['exports', '@angular/core', '@angular/common', '@angular/cdk/coercion', '@allianz/ngx-ndbx/utils', '@angular/forms', 'rxjs', 'rxjs/operators', '@angular/cdk/collections', '@allianz/ngx-ndbx/icon'], factory) :
    (global = global || self, factory((global.allianz = global.allianz || {}, global.allianz['ngx-ndbx'] = global.allianz['ngx-ndbx'] || {}, global.allianz['ngx-ndbx']['radio-toggle'] = {}), global.ng.core, global.ng.common, global.ng.cdk.coercion, global.allianz['ngx-ndbx'].utils, global.ng.forms, global.rxjs, global.rxjs.operators, global.ng.cdk.collections, global.allianz['ngx-ndbx'].icon));
}(this, (function (exports, core, common, coercion, utils, forms, rxjs, operators, collections, icon) { 'use strict';

    /*! *****************************************************************************
    Copyright (c) Microsoft Corporation. All rights reserved.
    Licensed under the Apache License, Version 2.0 (the "License"); you may not use
    this file except in compliance with the License. You may obtain a copy of the
    License at http://www.apache.org/licenses/LICENSE-2.0

    THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
    WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
    MERCHANTABLITY OR NON-INFRINGEMENT.

    See the Apache Version 2.0 License for specific language governing permissions
    and limitations under the License.
    ***************************************************************************** */
    /* global Reflect, Promise */

    var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };

    function __extends(d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    }

    var __assign = function() {
        __assign = Object.assign || function __assign(t) {
            for (var s, i = 1, n = arguments.length; i < n; i++) {
                s = arguments[i];
                for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
            }
            return t;
        };
        return __assign.apply(this, arguments);
    };

    function __rest(s, e) {
        var t = {};
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
            t[p] = s[p];
        if (s != null && typeof Object.getOwnPropertySymbols === "function")
            for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
                if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                    t[p[i]] = s[p[i]];
            }
        return t;
    }

    function __decorate(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    }

    function __param(paramIndex, decorator) {
        return function (target, key) { decorator(target, key, paramIndex); }
    }

    function __metadata(metadataKey, metadataValue) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(metadataKey, metadataValue);
    }

    function __awaiter(thisArg, _arguments, P, generator) {
        return new (P || (P = Promise))(function (resolve, reject) {
            function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
            function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
            function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
            step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
    }

    function __generator(thisArg, body) {
        var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
        return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
        function verb(n) { return function (v) { return step([n, v]); }; }
        function step(op) {
            if (f) throw new TypeError("Generator is already executing.");
            while (_) try {
                if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
                if (y = 0, t) op = [op[0] & 2, t.value];
                switch (op[0]) {
                    case 0: case 1: t = op; break;
                    case 4: _.label++; return { value: op[1], done: false };
                    case 5: _.label++; y = op[1]; op = [0]; continue;
                    case 7: op = _.ops.pop(); _.trys.pop(); continue;
                    default:
                        if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                        if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                        if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                        if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                        if (t[2]) _.ops.pop();
                        _.trys.pop(); continue;
                }
                op = body.call(thisArg, _);
            } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
            if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
        }
    }

    function __exportStar(m, exports) {
        for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
    }

    function __values(o) {
        var m = typeof Symbol === "function" && o[Symbol.iterator], i = 0;
        if (m) return m.call(o);
        return {
            next: function () {
                if (o && i >= o.length) o = void 0;
                return { value: o && o[i++], done: !o };
            }
        };
    }

    function __read(o, n) {
        var m = typeof Symbol === "function" && o[Symbol.iterator];
        if (!m) return o;
        var i = m.call(o), r, ar = [], e;
        try {
            while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
        }
        catch (error) { e = { error: error }; }
        finally {
            try {
                if (r && !r.done && (m = i["return"])) m.call(i);
            }
            finally { if (e) throw e.error; }
        }
        return ar;
    }

    function __spread() {
        for (var ar = [], i = 0; i < arguments.length; i++)
            ar = ar.concat(__read(arguments[i]));
        return ar;
    }

    function __spreadArrays() {
        for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
        for (var r = Array(s), k = 0, i = 0; i < il; i++)
            for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
                r[k] = a[j];
        return r;
    };

    function __await(v) {
        return this instanceof __await ? (this.v = v, this) : new __await(v);
    }

    function __asyncGenerator(thisArg, _arguments, generator) {
        if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
        var g = generator.apply(thisArg, _arguments || []), i, q = [];
        return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i;
        function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }
        function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }
        function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }
        function fulfill(value) { resume("next", value); }
        function reject(value) { resume("throw", value); }
        function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }
    }

    function __asyncDelegator(o) {
        var i, p;
        return i = {}, verb("next"), verb("throw", function (e) { throw e; }), verb("return"), i[Symbol.iterator] = function () { return this; }, i;
        function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === "return" } : f ? f(v) : v; } : f; }
    }

    function __asyncValues(o) {
        if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
        var m = o[Symbol.asyncIterator], i;
        return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);
        function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }
        function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }
    }

    function __makeTemplateObject(cooked, raw) {
        if (Object.defineProperty) { Object.defineProperty(cooked, "raw", { value: raw }); } else { cooked.raw = raw; }
        return cooked;
    };

    function __importStar(mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
        result.default = mod;
        return result;
    }

    function __importDefault(mod) {
        return (mod && mod.__esModule) ? mod : { default: mod };
    }

    /**
     * @fileoverview added by tsickle
     * Generated from: radio-toggle-button-base.component.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /** @type {?} */
    var nextId = 0;
    /**
     * \@docs-private
     */
    var NxRadioToggleButtonBaseComponent = /** @class */ (function () {
        function NxRadioToggleButtonBaseComponent(renderer) {
            this.renderer = renderer;
            /**
             * \@docs-private
             */
            this.toggleButtonId = 'nx-radio-toggle-button-' + nextId++;
        }
        /** @docs-private */
        /**
         * \@docs-private
         * @param {?} event
         * @return {?}
         */
        NxRadioToggleButtonBaseComponent.prototype.triggerInputClick = /**
         * \@docs-private
         * @param {?} event
         * @return {?}
         */
        function (event) {
            event.stopPropagation();
            this.toggleInput.nativeElement.click();
        };
        /** @docs-private */
        /**
         * \@docs-private
         * @return {?}
         */
        NxRadioToggleButtonBaseComponent.prototype.setFirstButton = /**
         * \@docs-private
         * @return {?}
         */
        function () {
            this.renderer.addClass(this.labelContainer.nativeElement, 'nx-radio-toggle__label-container--first');
        };
        /** @docs-private */
        /**
         * \@docs-private
         * @return {?}
         */
        NxRadioToggleButtonBaseComponent.prototype.setLastButton = /**
         * \@docs-private
         * @return {?}
         */
        function () {
            this.renderer.addClass(this.labelContainer.nativeElement, 'nx-radio-toggle__label-container--last');
        };
        /** @docs-private */
        /**
         * \@docs-private
         * @return {?}
         */
        NxRadioToggleButtonBaseComponent.prototype.resetClasses = /**
         * \@docs-private
         * @return {?}
         */
        function () {
            utils.removeClasses(this.renderer, this.labelContainer, 'nx-radio-toggle__label-container--first nx-radio-toggle__label-container--last');
        };
        NxRadioToggleButtonBaseComponent.propDecorators = {
            value: [{ type: core.Input, args: ['nxValue',] }],
            labelContainer: [{ type: core.ViewChild, args: ['toggleButtonLabelContainer', { static: true },] }],
            toggleInput: [{ type: core.ViewChild, args: ['toggleInput', { static: true },] }]
        };
        return NxRadioToggleButtonBaseComponent;
    }());
    if (false) {
        /**
         * \@docs-private
         * @type {?}
         */
        NxRadioToggleButtonBaseComponent.prototype.toggleButtonId;
        /**
         * \@docs-private
         * @type {?}
         */
        NxRadioToggleButtonBaseComponent.prototype.value;
        /**
         * \@docs-private
         * @type {?}
         */
        NxRadioToggleButtonBaseComponent.prototype.labelContainer;
        /**
         * \@docs-private
         * @type {?}
         */
        NxRadioToggleButtonBaseComponent.prototype.toggleInput;
        /**
         * \@docs-private
         * @type {?}
         * @protected
         */
        NxRadioToggleButtonBaseComponent.prototype.renderer;
    }

    /**
     * @fileoverview added by tsickle
     * Generated from: radio-toggle.component.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /** @type {?} */
    var nextId$1 = 0;
    /** @type {?} */
    var MAPPING = {
        'negative': 'nx-radio-toggle--negative',
        'small': 'nx-radio-toggle--small',
    };
    var NxRadioToggleComponent = /** @class */ (function () {
        function NxRadioToggleComponent(renderer, _changeDetectorRef, ngControl, _errorStateMatcher, _parentForm, _parentFormGroup) {
            this.renderer = renderer;
            this._changeDetectorRef = _changeDetectorRef;
            this.ngControl = ngControl;
            this._errorStateMatcher = _errorStateMatcher;
            this._parentForm = _parentForm;
            this._parentFormGroup = _parentFormGroup;
            this._toggleId = (nextId$1++).toString();
            this._destroyed = new rxjs.Subject();
            this._disabled = false;
            /**
             * \@docs-private
             */
            this.errorState = false;
            // emits to signal children to run change detection
            this._disableChange = new rxjs.Subject();
            /**
             * \@docs-private
             */
            this.toggleButtons = new core.QueryList();
            this.onTouchedCallback = (/**
             * @return {?}
             */
            function () { });
            this.onChangeCallback = (/**
             * @param {?} option
             * @return {?}
             */
            function (option) { });
            if (this.ngControl) {
                // Note: we provide the value accessor through here, instead of
                // the `providers` to avoid running into a circular import.
                this.ngControl.valueAccessor = this;
            }
        }
        Object.defineProperty(NxRadioToggleComponent.prototype, "disabled", {
            get: /**
             * @return {?}
             */
            function () {
                return this._disabled;
            },
            /** Sets the component to the disabled state.*/
            set: /**
             * Sets the component to the disabled state.
             * @param {?} value
             * @return {?}
             */
            function (value) {
                /** @type {?} */
                var coerced = coercion.coerceBooleanProperty(value);
                if (this._disabled !== coerced) {
                    this._disabled = coerced;
                    this._disableChange.next();
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NxRadioToggleComponent.prototype, "name", {
            get: /**
             * @return {?}
             */
            function () {
                return this._name;
            },
            /** Sets the name used for accessibility. */
            set: /**
             * Sets the name used for accessibility.
             * @param {?} value
             * @return {?}
             */
            function (value) {
                if (this._name !== value) {
                    this._name = value;
                    this._changeDetectorRef.markForCheck();
                }
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        NxRadioToggleComponent.prototype.ngAfterViewInit = /**
         * @return {?}
         */
        function () {
            this.subscribeToToggleButtonsChange();
        };
        /**
         * @return {?}
         */
        NxRadioToggleComponent.prototype.ngAfterContentInit = /**
         * @return {?}
         */
        function () {
            var _this = this;
            /** @type {?} */
            var changedOrDestroyed = rxjs.merge(this.toggleButtons.changes, this._destroyed);
            rxjs.merge.apply(void 0, __spread(this.toggleButtons.map((/**
             * @param {?} button
             * @return {?}
             */
            function (button) { return button.onChecked; })))).pipe(operators.takeUntil(changedOrDestroyed))
                .subscribe((/**
             * @param {?} change
             * @return {?}
             */
            function (change) {
                _this._selection = change.value;
                _this.onChangeCallback(_this._selection);
            }));
        };
        /**
         * @return {?}
         */
        NxRadioToggleComponent.prototype.ngOnDestroy = /**
         * @return {?}
         */
        function () {
            this._destroyed.next();
            this._destroyed.complete();
            this._disableChange.complete();
        };
        /**
         * @return {?}
         */
        NxRadioToggleComponent.prototype.ngDoCheck = /**
         * @return {?}
         */
        function () {
            if (this.ngControl) {
                // We need to re-evaluate this on every change detection cycle, because there are some
                // error triggers that we can't subscribe to (e.g. parent form submissions). This means
                // that whatever logic is in here has to be super lean or we risk destroying the performance.
                this.updateErrorState();
            }
        };
        /** @docs-private */
        /**
         * \@docs-private
         * @return {?}
         */
        NxRadioToggleComponent.prototype.subscribeToToggleButtonsChange = /**
         * \@docs-private
         * @return {?}
         */
        function () {
            var _this = this;
            this.toggleButtons.changes
                .pipe(operators.startWith(this.toggleButtons), operators.filter((/**
             * @param {?} toggles
             * @return {?}
             */
            function (toggles) { return toggles.length > 0; })), operators.takeUntil(this._destroyed)).subscribe((/**
             * @param {?} toggles
             * @return {?}
             */
            function (toggles) {
                toggles.forEach((/**
                 * @param {?} toggle
                 * @return {?}
                 */
                function (toggle) {
                    toggle.resetClasses();
                    if (toggle.value === _this.selection) {
                        // We need to defer the selection for the edge case that the button with the value of this.selection
                        // didn't exist yet but was added afterwards to prevent changed after checked errors
                        setTimeout((/**
                         * @return {?}
                         */
                        function () { return toggle.select(); }));
                    }
                }));
                toggles.first.setFirstButton();
                toggles.last.setLastButton();
            }));
        };
        /**
         * @param {?} onChangeCallback
         * @return {?}
         */
        NxRadioToggleComponent.prototype.registerOnChange = /**
         * @param {?} onChangeCallback
         * @return {?}
         */
        function (onChangeCallback) {
            this.onChangeCallback = onChangeCallback;
        };
        /**
         * @param {?} onTouchedCallback
         * @return {?}
         */
        NxRadioToggleComponent.prototype.registerOnTouched = /**
         * @param {?} onTouchedCallback
         * @return {?}
         */
        function (onTouchedCallback) {
            this.onTouchedCallback = onTouchedCallback;
        };
        /** Preselects the respective options. */
        /**
         * Preselects the respective options.
         * @param {?} value
         * @return {?}
         */
        NxRadioToggleComponent.prototype.writeValue = /**
         * Preselects the respective options.
         * @param {?} value
         * @return {?}
         */
        function (value) {
            var _this = this;
            this._selection = value;
            /** @type {?} */
            var correspondingButton = this.toggleButtons.find((/**
             * @param {?} button
             * @return {?}
             */
            function (button) { return button.value === _this._selection; }));
            if (correspondingButton) {
                ((/** @type {?} */ (correspondingButton))).select();
            }
        };
        /**
         * @param {?} isDisabled
         * @return {?}
         */
        NxRadioToggleComponent.prototype.setDisabledState = /**
         * @param {?} isDisabled
         * @return {?}
         */
        function (isDisabled) {
            this.disabled = isDisabled;
        };
        Object.defineProperty(NxRadioToggleComponent.prototype, "id", {
            /** @docs-private */
            get: /**
             * \@docs-private
             * @return {?}
             */
            function () {
                return "nx-radio-toggle-" + this._toggleId;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NxRadioToggleComponent.prototype, "style", {
            /** Sets the modifiers for the component. */
            set: /**
             * Sets the modifiers for the component.
             * @param {?} value
             * @return {?}
             */
            function (value) {
                var _this = this;
                /** @type {?} */
                var modifierClasses = utils.mapClassNames(value, [], MAPPING);
                modifierClasses.split(' ')
                    .forEach((/**
                 * @param {?} className
                 * @return {?}
                 */
                function (className) { return _this.renderer.addClass(_this.toggleContainer.nativeElement, className); }));
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NxRadioToggleComponent.prototype, "selection", {
            get: /**
             * @return {?}
             */
            function () {
                return this._selection;
            },
            /** @docs-private */
            set: /**
             * \@docs-private
             * @param {?} selection
             * @return {?}
             */
            function (selection) {
                this._selection = selection;
                this.onChangeCallback(selection);
            },
            enumerable: true,
            configurable: true
        });
        /** @docs-private */
        /**
         * \@docs-private
         * @param {?} value
         * @return {?}
         */
        NxRadioToggleComponent.prototype.change = /**
         * \@docs-private
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this.onChangeCallback(value);
            if (this.onTouchedCallback) {
                this.onTouchedCallback();
            }
        };
        /** @docs-private */
        /**
         * \@docs-private
         * @return {?}
         */
        NxRadioToggleComponent.prototype.updateErrorState = /**
         * \@docs-private
         * @return {?}
         */
        function () {
            /** @type {?} */
            var oldState = this.errorState;
            /** @type {?} */
            var parent = this._parentFormGroup || this._parentForm;
            /** @type {?} */
            var control = this.ngControl ? (/** @type {?} */ (this.ngControl.control)) : null;
            /** @type {?} */
            var newState = this._errorStateMatcher.isErrorState(control, parent);
            if (newState !== oldState) {
                this.errorState = newState;
            }
        };
        NxRadioToggleComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'nx-radio-toggle',
                        template: "<div #toggleContainer class=\"nx-radio-toggle\" role=\"radiogroup\" [attr.aria-label]=\"name\">\n   <ng-content></ng-content>\n</div>\n",
                        changeDetection: core.ChangeDetectionStrategy.OnPush,
                        styles: [":host{display:block}.nx-radio-toggle{display:flex;height:100%}@media (max-width:703px){.nx-radio-toggle{flex-direction:column;text-align:center;width:100%;justify-content:center;align-items:center}}"]
                    }] }
        ];
        /** @nocollapse */
        NxRadioToggleComponent.ctorParameters = function () { return [
            { type: core.Renderer2 },
            { type: core.ChangeDetectorRef },
            { type: forms.NgControl, decorators: [{ type: core.Optional }, { type: core.Self }] },
            { type: utils.ErrorStateMatcher },
            { type: forms.NgForm, decorators: [{ type: core.Optional }] },
            { type: forms.FormGroupDirective, decorators: [{ type: core.Optional }] }
        ]; };
        NxRadioToggleComponent.propDecorators = {
            disabled: [{ type: core.Input, args: ['nxDisabled',] }],
            toggleContainer: [{ type: core.ViewChild, args: ['toggleContainer', { static: true },] }],
            name: [{ type: core.Input, args: ['nxName',] }],
            toggleButtons: [{ type: core.ContentChildren, args: [NxRadioToggleButtonBaseComponent,] }],
            writeValue: [{ type: core.Input, args: ['nxSelection',] }],
            style: [{ type: core.Input, args: ['nxStyle',] }]
        };
        return NxRadioToggleComponent;
    }());
    if (false) {
        /**
         * @type {?}
         * @private
         */
        NxRadioToggleComponent.prototype._toggleId;
        /**
         * @type {?}
         * @private
         */
        NxRadioToggleComponent.prototype._selection;
        /**
         * @type {?}
         * @private
         */
        NxRadioToggleComponent.prototype._destroyed;
        /**
         * @type {?}
         * @private
         */
        NxRadioToggleComponent.prototype._disabled;
        /**
         * \@docs-private
         * @type {?}
         */
        NxRadioToggleComponent.prototype.errorState;
        /** @type {?} */
        NxRadioToggleComponent.prototype._disableChange;
        /**
         * @type {?}
         * @private
         */
        NxRadioToggleComponent.prototype.toggleContainer;
        /**
         * @type {?}
         * @private
         */
        NxRadioToggleComponent.prototype._name;
        /**
         * \@docs-private
         * @type {?}
         */
        NxRadioToggleComponent.prototype.toggleButtons;
        /**
         * @type {?}
         * @private
         */
        NxRadioToggleComponent.prototype.onTouchedCallback;
        /**
         * @type {?}
         * @private
         */
        NxRadioToggleComponent.prototype.onChangeCallback;
        /**
         * @type {?}
         * @private
         */
        NxRadioToggleComponent.prototype.renderer;
        /**
         * @type {?}
         * @private
         */
        NxRadioToggleComponent.prototype._changeDetectorRef;
        /**
         * \@docs-private
         * @type {?}
         */
        NxRadioToggleComponent.prototype.ngControl;
        /**
         * @type {?}
         * @private
         */
        NxRadioToggleComponent.prototype._errorStateMatcher;
        /**
         * @type {?}
         * @private
         */
        NxRadioToggleComponent.prototype._parentForm;
        /**
         * @type {?}
         * @private
         */
        NxRadioToggleComponent.prototype._parentFormGroup;
    }

    /**
     * @fileoverview added by tsickle
     * Generated from: radio-toggle-button.component.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * \@docs-private
     */
    var /**
     * \@docs-private
     */
    NxRadioToggleButtonChange = /** @class */ (function () {
        function NxRadioToggleButtonChange(source, value) {
            this.source = source;
            this.value = value;
        }
        return NxRadioToggleButtonChange;
    }());
    if (false) {
        /** @type {?} */
        NxRadioToggleButtonChange.prototype.source;
        /** @type {?} */
        NxRadioToggleButtonChange.prototype.value;
    }
    var NxRadioToggleButtonComponent = /** @class */ (function (_super) {
        __extends(NxRadioToggleButtonComponent, _super);
        function NxRadioToggleButtonComponent(radioToggle, 
        /** @docs-private */
        renderer, _changeDetectorRef, _toggleDispatcher) {
            var _this = _super.call(this, renderer) || this;
            _this.radioToggle = radioToggle;
            _this._changeDetectorRef = _changeDetectorRef;
            _this._toggleDispatcher = _toggleDispatcher;
            /**
             * \@docs-private
             */
            // emits when the button is checked to notify the group
            _this.onChecked = new rxjs.Subject();
            _this._destroyed = new rxjs.Subject();
            _this._disabled = false;
            _this._selected = false;
            /**
             * Unregister function for _expansionDispatcher.
             */
            _this._removeUniqueSelectionListener = (/**
             * @return {?}
             */
            function () { });
            _this._removeUniqueSelectionListener = _this._toggleDispatcher.listen((/**
             * @param {?} id
             * @param {?} radioToggleId
             * @return {?}
             */
            function (id, radioToggleId) {
                if (_this.radioToggle && _this.radioToggle.id === radioToggleId && _this.id !== id) {
                    _this._selected = false;
                    // need to let change detector know in case that the select() function was called on another button
                    _this._changeDetectorRef.markForCheck();
                }
            }));
            _this.radioToggle._disableChange.pipe(operators.takeUntil(_this._destroyed)).subscribe((/**
             * @return {?}
             */
            function () {
                _this._changeDetectorRef.markForCheck();
            }));
            return _this;
        }
        Object.defineProperty(NxRadioToggleButtonComponent.prototype, "disabled", {
            get: /**
             * @return {?}
             */
            function () {
                return this._disabled || (this.radioToggle && this.radioToggle.disabled);
            },
            /** @docs-private */
            set: /**
             * \@docs-private
             * @param {?} value
             * @return {?}
             */
            function (value) {
                this._disabled = coercion.coerceBooleanProperty(value);
                this._changeDetectorRef.markForCheck();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NxRadioToggleButtonComponent.prototype, "selected", {
            get: /**
             * @return {?}
             */
            function () {
                return this._selected;
            },
            /** Sets the checked state and notify siblings and the parent group about the change */
            // Only use this if you want the onChecked event to be fired, this will inform the parent about the change!
            // To select a button without firing the event use the select() function
            set: /**
             * Sets the checked state and notify siblings and the parent group about the change
             * @param {?} value
             * @return {?}
             */
            // Only use this if you want the onChecked event to be fired, this will inform the parent about the change!
            // To select a button without firing the event use the select() function
            function (value) {
                if (this._selected !== value) {
                    this._selected = value;
                    if (this._selected) {
                        this._notifySiblings();
                        this._emitCheckedEvent();
                        if (this.radioToggle !== null) {
                            this.radioToggle.change(this.value);
                        }
                    }
                    this._changeDetectorRef.markForCheck();
                }
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        NxRadioToggleButtonComponent.prototype.ngOnDestroy = /**
         * @return {?}
         */
        function () {
            this._removeUniqueSelectionListener();
            this._destroyed.next();
            this._destroyed.complete();
        };
        Object.defineProperty(NxRadioToggleButtonComponent.prototype, "toggleId", {
            /** @docs-private */
            get: /**
             * \@docs-private
             * @return {?}
             */
            function () {
                return this.radioToggle.id;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NxRadioToggleButtonComponent.prototype, "id", {
            /** @docs-private */
            get: /**
             * \@docs-private
             * @return {?}
             */
            function () {
                return this.toggleButtonId;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @private
         * @return {?}
         */
        NxRadioToggleButtonComponent.prototype._notifySiblings = /**
         * @private
         * @return {?}
         */
        function () {
            /** @type {?} */
            var toggleId = this.radioToggle ? this.radioToggle.id : this.id;
            this._toggleDispatcher.notify(this.id, toggleId);
        };
        /**
         * @private
         * @return {?}
         */
        NxRadioToggleButtonComponent.prototype._emitCheckedEvent = /**
         * @private
         * @return {?}
         */
        function () {
            this.onChecked.next(new NxRadioToggleButtonChange(this, this.value));
        };
        // Does NOT emit the onChecked event. Useful when you need to set initial
        // state. Used by the parent to set checked states on initialization and during
        // writeValue() changes.
        /** @docs-private */
        // Does NOT emit the onChecked event. Useful when you need to set initial
        // state. Used by the parent to set checked states on initialization and during
        // writeValue() changes.
        /**
         * \@docs-private
         * @return {?}
         */
        NxRadioToggleButtonComponent.prototype.select = 
        // Does NOT emit the onChecked event. Useful when you need to set initial
        // state. Used by the parent to set checked states on initialization and during
        // writeValue() changes.
        /**
         * \@docs-private
         * @return {?}
         */
        function () {
            if (!this._selected) {
                this._selected = true;
                this._notifySiblings();
            }
            this._changeDetectorRef.markForCheck();
        };
        /** @docs-private */
        /**
         * \@docs-private
         * @return {?}
         */
        NxRadioToggleButtonComponent.prototype.onKeyupSpace = /**
         * \@docs-private
         * @return {?}
         */
        function () {
            this._selected = false;
            this._notifySiblings();
        };
        /** @docs-private */
        /**
         * \@docs-private
         * @return {?}
         */
        NxRadioToggleButtonComponent.prototype._controlInvalid = /**
         * \@docs-private
         * @return {?}
         */
        function () {
            return !!(this.radioToggle && this.radioToggle.errorState);
        };
        NxRadioToggleButtonComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'nx-radio-toggle-button',
                        changeDetection: core.ChangeDetectionStrategy.OnPush,
                        template: "<input [attr.id]=\"toggleButtonId\"\n    #toggleInput\n    [attr.name]=\"toggleId\"\n    [checked]=\"selected\"\n    class=\"nx-radio-toggle__input\"\n    type=\"radio\"\n    (click)=\"selected = true\"\n    [disabled]=\"disabled\">\n<div (click)=\"triggerInputClick($event)\" #toggleButtonLabelContainer class=\"nx-radio-toggle__label-container\">\n  <label [attr.for]=\"toggleButtonId\" class=\"nx-radio-toggle__label\">\n      <nx-icon class=\"nx-toggle-button__mobile-check\" name=\"check\" aria-hidden=\"true\"></nx-icon>\n      <ng-content></ng-content>\n  </label>\n</div>\n\n\n",
                        providers: [
                            {
                                provide: NxRadioToggleButtonBaseComponent, useExisting: core.forwardRef((/**
                                 * @return {?}
                                 */
                                function () { return NxRadioToggleButtonComponent; }))
                            }
                        ],
                        host: {
                            '[class.has-error]': '_controlInvalid() || null',
                            '[attr.aria-invalid]': '_controlInvalid() || null'
                        },
                        styles: [":host{display:flex;position:relative;flex-direction:row}:host.has-error .nx-radio-toggle__input:checked+.nx-radio-toggle__label-container{border-color:#dc3149;border-color:var(--danger,#dc3149);background-color:#dc3149;background-color:var(--danger,#dc3149)}:host.has-error .nx-radio-toggle__label-container{border-color:#dc3149;border-color:var(--danger,#dc3149);color:#dc3149;color:var(--danger,#dc3149)}:host.has-error:hover .nx-radio-toggle__label-container{color:#fff}.nx-radio-toggle__input{opacity:0;position:absolute}.nx-radio-toggle__input:active+.nx-radio-toggle__label-container{background-color:#003781;background-color:var(--toggle-button-active-background-color,#003781);border-color:#003781;border-color:var(--toggle-button-active-border-color,#003781);color:#fff;color:var(--toggle-button-active-text-color,#fff)}.nx-radio-toggle__input:checked:disabled+.nx-radio-toggle__label-container{background-color:rgba(0,122,179,.4);background-color:var(--toggle-button-disabled-selected-background-color,rgba(0,122,179,.4));border-color:transparent;border-color:var(--toggle-button-disabled-selected-border-color,transparent);color:rgba(255,255,255,.4);color:var(--toggle-button-disabled-selected-text-color,rgba(255,255,255,.4))}.nx-radio-toggle__input:disabled+.nx-radio-toggle__label-container{background-color:#fff;background-color:var(--toggle-button-disabled-background-color,#fff);border-color:rgba(0,122,179,.4);border-color:var(--toggle-button-disabled-border-color,rgba(0,122,179,.4));color:rgba(0,97,146,.4);color:var(--toggle-button-disabled-text-color,rgba(0,97,146,.4));cursor:not-allowed}.nx-radio-toggle__input:disabled+.nx-radio-toggle__label-container .nx-radio-toggle__label{cursor:not-allowed}@media screen and (-ms-high-contrast:active){.nx-radio-toggle__input:disabled+.nx-radio-toggle__label-container{border-color:GrayText;color:GrayText}}.nx-radio-toggle__input:checked+.nx-radio-toggle__label-container{background-color:#007ab3;background-color:var(--toggle-button-selected-background-color,#007ab3);border-color:#007ab3;border-color:var(--toggle-button-selected-border-color,#007ab3);color:#fff;color:var(--toggle-button-selected-text-color,#fff);cursor:default}.nx-radio-toggle__input:checked+.nx-radio-toggle__label-container .nx-radio-toggle__label{cursor:default}.nx-toggle-button__mobile-check{display:none;font-size:24px;margin-right:8px;height:24px}:host-context(.nx-radio-toggle--small) .nx-radio-toggle__label-container{font-size:14px;font-size:var(--toggle-button-small-font-size,14px);line-height:16px;line-height:var(--toggle-button-small-line-height,16px);font-weight:600;font-weight:var(--toggle-button-small-font-weight,600);letter-spacing:1px;letter-spacing:var(--toggle-button-small-letter-spacing,1px);min-height:16px;padding:6px;text-transform:none}.nx-radio-toggle{-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;cursor:pointer}.nx-radio-toggle__label-container.nx-radio-toggle__label-container--first{border-radius:4px 0 0 4px;border-width:2px 0 2px 2px}@media (max-width:703px){:host{width:100%}.nx-radio-toggle__input:checked+.nx-radio-toggle__label-container .nx-toggle-button__mobile-check{display:inline-block}:host-context(.nx-radio-toggle--small) .nx-radio-toggle__label-container{font-size:16px;font-size:var(--toggle-button-large-font-size,16px);line-height:24px;line-height:var(--toggle-button-large-line-height,24px);font-weight:600;font-weight:var(--toggle-button-large-font-weight,600);letter-spacing:1px;letter-spacing:var(--toggle-button-large-letter-spacing,1px);padding:11px 31px}.nx-radio-toggle__label-container.nx-radio-toggle__label-container--first{border-width:2px 2px 1px;border-radius:4px 4px 0 0}}.nx-radio-toggle__label-container.nx-radio-toggle__label-container--last{border-top-right-radius:4px;border-bottom-right-radius:4px;border-width:2px}.nx-radio-toggle__label-container{font-size:16px;font-size:var(--toggle-button-large-font-size,16px);line-height:24px;line-height:var(--toggle-button-large-line-height,24px);font-weight:600;font-weight:var(--toggle-button-large-font-weight,600);letter-spacing:1px;letter-spacing:var(--toggle-button-large-letter-spacing,1px);padding:10px 30px;color:#006192;color:var(--toggle-button-unselected-text-color,#006192);background-color:transparent;background-color:var(--toggle-button-unselected-background-color,transparent);border-color:#007ab3;border-color:var(--toggle-button-unselected-border-color,#007ab3);border-style:solid;border-radius:0;border-width:2px 0 2px 2px;cursor:pointer;flex-grow:1;text-align:center;text-transform:uppercase;text-transform:var(--button-text-transform,uppercase);transition:background-color .2s,border-color .2s,color .2s;display:flex;align-items:center;height:100%;min-height:24px}@media (max-width:703px){.nx-radio-toggle__label-container.nx-radio-toggle__label-container--last{border-width:1px 2px 2px;border-radius:0 0 4px 4px}.nx-radio-toggle__label-container.nx-radio-toggle__label-container--last.nx-radio-toggle__label-container--first{border-radius:4px;border-width:2px}.nx-radio-toggle__label-container{border-width:1px 2px;justify-content:center;padding:11px 31px}}.nx-radio-toggle__label-container:hover{background-color:#006192;background-color:var(--toggle-button-hover-background-color,#006192);border-color:#006192;border-color:var(--toggle-button-hover-border-color,#006192);color:#fff;color:var(--toggle-button-hover-text-color,#fff)}@media screen and (-ms-high-contrast:active){.nx-radio-toggle__input:checked+.nx-radio-toggle__label-container{background-color:highlight;border-color:buttonText}.nx-radio-toggle__input:checked+.nx-radio-toggle__label-container .nx-radio-toggle__label{-ms-high-contrast-adjust:none;color:highlightText}.nx-radio-toggle__label-container{border-color:buttonText;background-color:buttonFace;color:buttonText}.nx-radio-toggle__label-container .nx-radio-toggle__label{-ms-high-contrast-adjust:none}}:host-context(.nx-radio-toggle--negative) .nx-radio-toggle__input:focus+.nx-radio-toggle__label-container{background-color:#d9d9d9;border-color:#d9d9d9;color:#007ab3}:host-context(.nx-radio-toggle--negative) .nx-radio-toggle__input:active+.nx-radio-toggle__label-container{background-color:#c2c2c2;border-color:#c2c2c2;color:#007ab3}:host-context(.nx-radio-toggle--negative) .nx-radio-toggle__input:disabled:checked+.nx-radio-toggle__label-container{background-color:rgba(255,255,255,.4);border-color:transparent;color:rgba(65,65,65,.4)}:host-context(.nx-radio-toggle--negative) .nx-radio-toggle__input:disabled+.nx-radio-toggle__label-container{background-color:transparent;border-color:rgba(255,255,255,.4);color:rgba(255,255,255,.4)}:host-context(.nx-radio-toggle--negative) .nx-radio-toggle__input:checked+.nx-radio-toggle__label-container{background-color:#fff;border-color:#fff;color:#006192}:host-context(.nx-radio-toggle--negative) .nx-radio-toggle__label-container{border-color:#fff;color:#fff}:host-context(.nx-radio-toggle--negative) .nx-radio-toggle__label-container:hover{background-color:#d9d9d9;border-color:#d9d9d9;color:#006192}.nx-radio-toggle__label{display:flex;align-items:center;cursor:pointer}:host-context([data-whatinput=keyboard]) .nx-radio-toggle__input:focus+.nx-radio-toggle__label-container{box-shadow:0 0 0 2px #fff,0 0 0 6px #009de6;box-shadow:var(--focus-box-shadow,0 0 0 2px #fff,0 0 0 6px #009de6);z-index:1}@media screen and (-ms-high-contrast:active){:host-context([data-whatinput=keyboard]) .nx-radio-toggle__input:focus+.nx-radio-toggle__label-container{box-shadow:0 0 0 2px background,0 0 0 6px windowText}}"]
                    }] }
        ];
        /** @nocollapse */
        NxRadioToggleButtonComponent.ctorParameters = function () { return [
            { type: NxRadioToggleComponent, decorators: [{ type: core.Inject, args: [core.forwardRef((/**
                             * @return {?}
                             */
                            function () { return NxRadioToggleComponent; })),] }] },
            { type: core.Renderer2 },
            { type: core.ChangeDetectorRef },
            { type: collections.UniqueSelectionDispatcher }
        ]; };
        NxRadioToggleButtonComponent.propDecorators = {
            disabled: [{ type: core.Input, args: ['nxDisabled',] }],
            selected: [{ type: core.Input, args: ['nxSelected',] }],
            onKeyupSpace: [{ type: core.HostListener, args: ['keyup.space',] }]
        };
        return NxRadioToggleButtonComponent;
    }(NxRadioToggleButtonBaseComponent));
    if (false) {
        /**
         * \@docs-private
         * @type {?}
         */
        NxRadioToggleButtonComponent.prototype.onChecked;
        /**
         * @type {?}
         * @private
         */
        NxRadioToggleButtonComponent.prototype._destroyed;
        /**
         * @type {?}
         * @private
         */
        NxRadioToggleButtonComponent.prototype._disabled;
        /**
         * @type {?}
         * @private
         */
        NxRadioToggleButtonComponent.prototype._selected;
        /**
         * Unregister function for _expansionDispatcher.
         * @type {?}
         * @private
         */
        NxRadioToggleButtonComponent.prototype._removeUniqueSelectionListener;
        /**
         * @type {?}
         * @private
         */
        NxRadioToggleButtonComponent.prototype.radioToggle;
        /**
         * @type {?}
         * @private
         */
        NxRadioToggleButtonComponent.prototype._changeDetectorRef;
        /**
         * @type {?}
         * @private
         */
        NxRadioToggleButtonComponent.prototype._toggleDispatcher;
    }

    /**
     * @fileoverview added by tsickle
     * Generated from: radio-toggle.module.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var NxRadioToggleModule = /** @class */ (function () {
        function NxRadioToggleModule() {
        }
        NxRadioToggleModule.decorators = [
            { type: core.NgModule, args: [{
                        declarations: [NxRadioToggleComponent, NxRadioToggleButtonComponent],
                        exports: [NxRadioToggleComponent, NxRadioToggleButtonComponent],
                        imports: [common.CommonModule, forms.FormsModule, icon.NxIconModule]
                    },] }
        ];
        return NxRadioToggleModule;
    }());

    exports.NxRadioToggleComponent = NxRadioToggleComponent;
    exports.NxRadioToggleModule = NxRadioToggleModule;
    exports.ɵa = NxRadioToggleButtonBaseComponent;
    exports.ɵb = NxRadioToggleButtonComponent;

    Object.defineProperty(exports, '__esModule', { value: true });

})));
//# sourceMappingURL=allianz-ngx-ndbx-radio-toggle.umd.js.map
