(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@angular/cdk/a11y'), require('@angular/cdk/overlay'), require('@angular/common'), require('@angular/core'), require('@angular/cdk/keycodes'), require('@angular/cdk/coercion'), require('@allianz/ngx-ndbx/formfield'), require('rxjs'), require('@angular/cdk/bidi'), require('@angular/cdk/portal'), require('@angular/forms'), require('rxjs/operators'), require('@allianz/ngx-ndbx/natural-language-form')) :
    typeof define === 'function' && define.amd ? define('@allianz/ngx-ndbx/autocomplete', ['exports', '@angular/cdk/a11y', '@angular/cdk/overlay', '@angular/common', '@angular/core', '@angular/cdk/keycodes', '@angular/cdk/coercion', '@allianz/ngx-ndbx/formfield', 'rxjs', '@angular/cdk/bidi', '@angular/cdk/portal', '@angular/forms', 'rxjs/operators', '@allianz/ngx-ndbx/natural-language-form'], factory) :
    (global = global || self, factory((global.allianz = global.allianz || {}, global.allianz['ngx-ndbx'] = global.allianz['ngx-ndbx'] || {}, global.allianz['ngx-ndbx'].autocomplete = {}), global.ng.cdk.a11y, global.ng.cdk.overlay, global.ng.common, global.ng.core, global.ng.cdk.keycodes, global.ng.cdk.coercion, global.allianz['ngx-ndbx'].formfield, global.rxjs, global.ng.cdk.bidi, global.ng.cdk.portal, global.ng.forms, global.rxjs.operators, global.allianz['ngx-ndbx']['natural-language-form']));
}(this, (function (exports, a11y, overlay, common, core, keycodes, coercion, formfield, rxjs, bidi, portal, forms, operators, naturalLanguageForm) { 'use strict';

    /*! *****************************************************************************
    Copyright (c) Microsoft Corporation. All rights reserved.
    Licensed under the Apache License, Version 2.0 (the "License"); you may not use
    this file except in compliance with the License. You may obtain a copy of the
    License at http://www.apache.org/licenses/LICENSE-2.0

    THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
    WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
    MERCHANTABLITY OR NON-INFRINGEMENT.

    See the Apache Version 2.0 License for specific language governing permissions
    and limitations under the License.
    ***************************************************************************** */
    /* global Reflect, Promise */

    var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };

    function __extends(d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    }

    var __assign = function() {
        __assign = Object.assign || function __assign(t) {
            for (var s, i = 1, n = arguments.length; i < n; i++) {
                s = arguments[i];
                for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
            }
            return t;
        };
        return __assign.apply(this, arguments);
    };

    function __rest(s, e) {
        var t = {};
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
            t[p] = s[p];
        if (s != null && typeof Object.getOwnPropertySymbols === "function")
            for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
                if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                    t[p[i]] = s[p[i]];
            }
        return t;
    }

    function __decorate(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    }

    function __param(paramIndex, decorator) {
        return function (target, key) { decorator(target, key, paramIndex); }
    }

    function __metadata(metadataKey, metadataValue) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(metadataKey, metadataValue);
    }

    function __awaiter(thisArg, _arguments, P, generator) {
        return new (P || (P = Promise))(function (resolve, reject) {
            function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
            function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
            function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
            step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
    }

    function __generator(thisArg, body) {
        var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
        return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
        function verb(n) { return function (v) { return step([n, v]); }; }
        function step(op) {
            if (f) throw new TypeError("Generator is already executing.");
            while (_) try {
                if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
                if (y = 0, t) op = [op[0] & 2, t.value];
                switch (op[0]) {
                    case 0: case 1: t = op; break;
                    case 4: _.label++; return { value: op[1], done: false };
                    case 5: _.label++; y = op[1]; op = [0]; continue;
                    case 7: op = _.ops.pop(); _.trys.pop(); continue;
                    default:
                        if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                        if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                        if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                        if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                        if (t[2]) _.ops.pop();
                        _.trys.pop(); continue;
                }
                op = body.call(thisArg, _);
            } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
            if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
        }
    }

    function __exportStar(m, exports) {
        for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
    }

    function __values(o) {
        var m = typeof Symbol === "function" && o[Symbol.iterator], i = 0;
        if (m) return m.call(o);
        return {
            next: function () {
                if (o && i >= o.length) o = void 0;
                return { value: o && o[i++], done: !o };
            }
        };
    }

    function __read(o, n) {
        var m = typeof Symbol === "function" && o[Symbol.iterator];
        if (!m) return o;
        var i = m.call(o), r, ar = [], e;
        try {
            while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
        }
        catch (error) { e = { error: error }; }
        finally {
            try {
                if (r && !r.done && (m = i["return"])) m.call(i);
            }
            finally { if (e) throw e.error; }
        }
        return ar;
    }

    function __spread() {
        for (var ar = [], i = 0; i < arguments.length; i++)
            ar = ar.concat(__read(arguments[i]));
        return ar;
    }

    function __spreadArrays() {
        for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
        for (var r = Array(s), k = 0, i = 0; i < il; i++)
            for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
                r[k] = a[j];
        return r;
    };

    function __await(v) {
        return this instanceof __await ? (this.v = v, this) : new __await(v);
    }

    function __asyncGenerator(thisArg, _arguments, generator) {
        if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
        var g = generator.apply(thisArg, _arguments || []), i, q = [];
        return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i;
        function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }
        function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }
        function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }
        function fulfill(value) { resume("next", value); }
        function reject(value) { resume("throw", value); }
        function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }
    }

    function __asyncDelegator(o) {
        var i, p;
        return i = {}, verb("next"), verb("throw", function (e) { throw e; }), verb("return"), i[Symbol.iterator] = function () { return this; }, i;
        function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === "return" } : f ? f(v) : v; } : f; }
    }

    function __asyncValues(o) {
        if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
        var m = o[Symbol.asyncIterator], i;
        return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);
        function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }
        function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }
    }

    function __makeTemplateObject(cooked, raw) {
        if (Object.defineProperty) { Object.defineProperty(cooked, "raw", { value: raw }); } else { cooked.raw = raw; }
        return cooked;
    };

    function __importStar(mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
        result.default = mod;
        return result;
    }

    function __importDefault(mod) {
        return (mod && mod.__esModule) ? mod : { default: mod };
    }

    /**
     * @fileoverview added by tsickle
     * Generated from: autocomplete-option.component.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * Option selected event
     */
    var   /**
     * Option selected event
     */
    NxAutocompleteOptionSelected = /** @class */ (function () {
        function NxAutocompleteOptionSelected(source, isUserInput) {
            if (isUserInput === void 0) { isUserInput = false; }
            this.source = source;
            this.isUserInput = isUserInput;
        }
        return NxAutocompleteOptionSelected;
    }());
    if (false) {
        /**
         * The option that is selected or deselected.
         * @type {?}
         */
        NxAutocompleteOptionSelected.prototype.source;
        /**
         * Whether the input was triggered by the user.
         * @type {?}
         */
        NxAutocompleteOptionSelected.prototype.isUserInput;
    }
    /**
     * Option IDs need to be unique across components, so this counter exists outside of
     * the component definition.
     * @type {?}
     */
    var _uniqueIdCounter = 0;
    var NxAutocompleteOptionComponent = /** @class */ (function () {
        function NxAutocompleteOptionComponent(elementRef, _changeDetectorRef) {
            this.elementRef = elementRef;
            this._changeDetectorRef = _changeDetectorRef;
            this._id = "nx-autocomplete-option-" + _uniqueIdCounter++;
            this._selected = false;
            this._active = false;
            this._disabled = false;
            /**
             * Event emitted when the option is selected or deselected.
             */
            this.onSelectionChange = new core.EventEmitter();
        }
        Object.defineProperty(NxAutocompleteOptionComponent.prototype, "id", {
            /** Id of the autocomplete option. By default it is set to an incremented value. */
            get: /**
             * Id of the autocomplete option. By default it is set to an incremented value.
             * @return {?}
             */
            function () {
                return this._id;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NxAutocompleteOptionComponent.prototype, "selected", {
            /** Whether or not the option is currently selected. */
            get: /**
             * Whether or not the option is currently selected.
             * @return {?}
             */
            function () { return this._selected; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NxAutocompleteOptionComponent.prototype, "active", {
            /**
             * Whether or not the option is currently active and ready to be selected.
             * An active option displays styles as if it is focused, but the
             * focus is actually retained somewhere else. This comes in handy
             * for components like autocomplete where focus must remain on the input.
             */
            get: /**
             * Whether or not the option is currently active and ready to be selected.
             * An active option displays styles as if it is focused, but the
             * focus is actually retained somewhere else. This comes in handy
             * for components like autocomplete where focus must remain on the input.
             * @return {?}
             */
            function () {
                return this._active;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NxAutocompleteOptionComponent.prototype, "disabled", {
            /** Whether the option is disabled. */
            get: /**
             * Whether the option is disabled.
             * @return {?}
             */
            function () { return this._disabled; },
            set: /**
             * @param {?} value
             * @return {?}
             */
            function (value) {
                /** @type {?} */
                var newValue = coercion.coerceBooleanProperty(value);
                if (this._disabled !== newValue) {
                    this._disabled = newValue;
                }
            },
            enumerable: true,
            configurable: true
        });
        /** Ensures the option is selected when activated from the keyboard. */
        /**
         * Ensures the option is selected when activated from the keyboard.
         * @param {?} event
         * @return {?}
         */
        NxAutocompleteOptionComponent.prototype._handleKeydown = /**
         * Ensures the option is selected when activated from the keyboard.
         * @param {?} event
         * @return {?}
         */
        function (event) {
            if (event.keyCode === keycodes.ENTER || event.keyCode === keycodes.SPACE) {
                this._selectViaInteraction();
                // Prevent the page from scrolling down and form submits.
                event.preventDefault();
            }
        };
        /**
         * `Selects the option while indicating the selection came from the user. Used to
         * determine if the select's view -> model callback should be invoked.`
         */
        /**
         * `Selects the option while indicating the selection came from the user. Used to
         * determine if the select's view -> model callback should be invoked.`
         * @return {?}
         */
        NxAutocompleteOptionComponent.prototype._selectViaInteraction = /**
         * `Selects the option while indicating the selection came from the user. Used to
         * determine if the select's view -> model callback should be invoked.`
         * @return {?}
         */
        function () {
            if (!this.disabled) {
                this._selected = true;
                this._changeDetectorRef.markForCheck();
                this._emitSelectionChangeEvent(true);
            }
        };
        /** Returns the correct tabindex for the option depending on disabled state. */
        /**
         * Returns the correct tabindex for the option depending on disabled state.
         * @return {?}
         */
        NxAutocompleteOptionComponent.prototype._getTabIndex = /**
         * Returns the correct tabindex for the option depending on disabled state.
         * @return {?}
         */
        function () {
            return this.disabled ? '-1' : '0';
        };
        /** Emits the selection change event. */
        /**
         * Emits the selection change event.
         * @private
         * @param {?=} isUserInput
         * @return {?}
         */
        NxAutocompleteOptionComponent.prototype._emitSelectionChangeEvent = /**
         * Emits the selection change event.
         * @private
         * @param {?=} isUserInput
         * @return {?}
         */
        function (isUserInput) {
            if (isUserInput === void 0) { isUserInput = false; }
            this.onSelectionChange.emit(new NxAutocompleteOptionSelected(this, isUserInput));
        };
        Object.defineProperty(NxAutocompleteOptionComponent.prototype, "viewValue", {
            /** @docs-private */
            get: /**
             * \@docs-private
             * @return {?}
             */
            function () {
                return (this.elementRef.nativeElement.textContent || '').trim();
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @docs-private
         * This method sets display styles on the option to make it appear
         * active. This is used by the ActiveDescendantKeyManager so key
         * events will display the proper options as active on arrow key events.
         */
        /**
         * \@docs-private
         * This method sets display styles on the option to make it appear
         * active. This is used by the ActiveDescendantKeyManager so key
         * events will display the proper options as active on arrow key events.
         * @return {?}
         */
        NxAutocompleteOptionComponent.prototype.setActiveStyles = /**
         * \@docs-private
         * This method sets display styles on the option to make it appear
         * active. This is used by the ActiveDescendantKeyManager so key
         * events will display the proper options as active on arrow key events.
         * @return {?}
         */
        function () {
            if (!this._active) {
                this._active = true;
                this._changeDetectorRef.markForCheck();
            }
        };
        /**
         * @docs-private
         * This method removes display styles on the option that made it appear
         * active. This is used by the ActiveDescendantKeyManager so key
         * events will display the proper options as active on arrow key events.
         */
        /**
         * \@docs-private
         * This method removes display styles on the option that made it appear
         * active. This is used by the ActiveDescendantKeyManager so key
         * events will display the proper options as active on arrow key events.
         * @return {?}
         */
        NxAutocompleteOptionComponent.prototype.setInactiveStyles = /**
         * \@docs-private
         * This method removes display styles on the option that made it appear
         * active. This is used by the ActiveDescendantKeyManager so key
         * events will display the proper options as active on arrow key events.
         * @return {?}
         */
        function () {
            if (this._active) {
                this._active = false;
                this._changeDetectorRef.markForCheck();
            }
        };
        /**
         * @docs-private
         * Gets the label to be used when determining whether the option should be focused.
         */
        /**
         * \@docs-private
         * Gets the label to be used when determining whether the option should be focused.
         * @return {?}
         */
        NxAutocompleteOptionComponent.prototype.getLabel = /**
         * \@docs-private
         * Gets the label to be used when determining whether the option should be focused.
         * @return {?}
         */
        function () {
            return this.viewValue;
        };
        /** Selects the option. */
        /**
         * Selects the option.
         * @return {?}
         */
        NxAutocompleteOptionComponent.prototype.select = /**
         * Selects the option.
         * @return {?}
         */
        function () {
            this._selected = true;
            this._changeDetectorRef.markForCheck();
            this._emitSelectionChangeEvent();
        };
        /** Deselects the option. */
        /**
         * Deselects the option.
         * @return {?}
         */
        NxAutocompleteOptionComponent.prototype.deselect = /**
         * Deselects the option.
         * @return {?}
         */
        function () {
            this._selected = false;
            this._changeDetectorRef.markForCheck();
            this._emitSelectionChangeEvent();
        };
        /**
         * @docs-private
         * Sets focus onto this option.
         */
        /**
         * \@docs-private
         * Sets focus onto this option.
         * @return {?}
         */
        NxAutocompleteOptionComponent.prototype.focus = /**
         * \@docs-private
         * Sets focus onto this option.
         * @return {?}
         */
        function () {
            /** @type {?} */
            var element = this.elementRef.nativeElement;
            if (typeof element.focus === 'function') {
                element.focus();
            }
        };
        NxAutocompleteOptionComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'nx-autocomplete-option',
                        template: "<div class=\"nx-autocomplete-option\" [class.nx-active]=\"active\">\n  <div class=\"nx-autocomplete-option__label\">\n    <ng-content></ng-content>\n  </div>\n</div>\n",
                        host: {
                            'role': 'option',
                            '[attr.tabindex]': '_getTabIndex()',
                            '[id]': 'id',
                            '[attr.aria-selected]': 'selected.toString()',
                            '[attr.aria-disabled]': 'disabled.toString()',
                            '(click)': '_selectViaInteraction()',
                            '(keydown)': '_handleKeydown($event)',
                            '[class.nx-active]': 'active',
                            '[class.nx-disabled]': 'disabled',
                            '[style.display]': '\'block\'' // needed for to be able to calculate offset height
                        },
                        changeDetection: core.ChangeDetectionStrategy.OnPush,
                        styles: [":host:focus{outline:0}:host:first-child .nx-autocomplete-option{padding-top:16px}:host:last-child .nx-autocomplete-option{padding-bottom:16px}.nx-autocomplete-option{font-size:20px;font-size:var(--dropdown-item-font-size,20px);line-height:28px;line-height:var(--dropdown-item-line-height,28px);font-weight:400;font-weight:var(--dropdown-item-font-weight,400);letter-spacing:.2px;letter-spacing:var(--dropdown-item-letter-spacing,.2px);padding:8px 32px;cursor:pointer;position:relative;display:flex;max-width:100%;white-space:nowrap}.nx-autocomplete-option.nx-active,.nx-autocomplete-option:hover{color:#007ab3}.nx-autocomplete-option__label{padding:0 12px;margin:0 -12px;color:#414141;color:var(--dropdown-item-text-color,#414141)}:host-context([data-whatinput=keyboard]) .nx-autocomplete-option.nx-active .nx-autocomplete-option__label{border-radius:4px;box-shadow:0 0 0 2px #fff,0 0 0 6px #009de6;box-shadow:var(--focus-box-shadow,0 0 0 2px #fff,0 0 0 6px #009de6)}@media screen and (-ms-high-contrast:active){.nx-autocomplete-option.nx-active .nx-autocomplete-option__label,.nx-autocomplete-option:hover .nx-autocomplete-option__label{color:highlightText;background-color:highlight;border-radius:4px}.nx-autocomplete-option__label{-ms-high-contrast-adjust:none;color:buttonText;background-color:buttonFace;border-radius:4px}:host-context([data-whatinput=keyboard]) .nx-autocomplete-option.nx-active .nx-autocomplete-option__label{box-shadow:0 0 0 2px background,0 0 0 6px windowText}}"]
                    }] }
        ];
        /** @nocollapse */
        NxAutocompleteOptionComponent.ctorParameters = function () { return [
            { type: core.ElementRef },
            { type: core.ChangeDetectorRef }
        ]; };
        NxAutocompleteOptionComponent.propDecorators = {
            disabled: [{ type: core.Input }],
            value: [{ type: core.Input }],
            onSelectionChange: [{ type: core.Output }]
        };
        return NxAutocompleteOptionComponent;
    }());
    if (false) {
        /**
         * @type {?}
         * @private
         */
        NxAutocompleteOptionComponent.prototype._id;
        /**
         * @type {?}
         * @private
         */
        NxAutocompleteOptionComponent.prototype._selected;
        /**
         * @type {?}
         * @private
         */
        NxAutocompleteOptionComponent.prototype._active;
        /**
         * @type {?}
         * @private
         */
        NxAutocompleteOptionComponent.prototype._disabled;
        /**
         * The value of the autocomplete option.
         * @type {?}
         */
        NxAutocompleteOptionComponent.prototype.value;
        /**
         * Event emitted when the option is selected or deselected.
         * @type {?}
         */
        NxAutocompleteOptionComponent.prototype.onSelectionChange;
        /**
         * \@docs-private
         * @type {?}
         */
        NxAutocompleteOptionComponent.prototype.elementRef;
        /**
         * @type {?}
         * @private
         */
        NxAutocompleteOptionComponent.prototype._changeDetectorRef;
    }

    /**
     * @fileoverview added by tsickle
     * Generated from: autocomplete.component.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * Autocomplete IDs need to be unique across components, so this counter exists outside of
     * the component definition.
     * @type {?}
     */
    var _uniqueAutocompleteIdCounter = 0;
    /**
     * Event object that is emitted when an autocomplete option is selected.
     */
    var   /**
     * Event object that is emitted when an autocomplete option is selected.
     */
    NxAutocompleteSelectedEvent = /** @class */ (function () {
        function NxAutocompleteSelectedEvent(source, option) {
            this.source = source;
            this.option = option;
        }
        return NxAutocompleteSelectedEvent;
    }());
    if (false) {
        /**
         * Reference to the autocomplete panel that emitted the event.
         * @type {?}
         */
        NxAutocompleteSelectedEvent.prototype.source;
        /**
         * Option that was selected.
         * @type {?}
         */
        NxAutocompleteSelectedEvent.prototype.option;
    }
    var NxAutocompleteComponent = /** @class */ (function () {
        function NxAutocompleteComponent(_changeDetectorRef, _elementRef, formFieldComponent) {
            this._changeDetectorRef = _changeDetectorRef;
            this._elementRef = _elementRef;
            this.formFieldComponent = formFieldComponent;
            /**
             * Whether the autocomplete panel should be visible, depending on option length.
             */
            this.showPanel = false;
            this._isOpen = false;
            this._items = null;
            this._hasItems = false;
            /**
             * Event that is emitted whenever an option from the list is selected.
             */
            this.optionSelected = new core.EventEmitter();
            /**
             * Event that is emitted when the autocomplete panel is opened.
             */
            this.opened = new core.EventEmitter();
            /**
             * Event that is emitted when the autocomplete panel is closed.
             */
            this.closed = new core.EventEmitter();
            this._classList = {};
            /**
             * Unique ID to be used by autocomplete trigger's "aria-owns" property.
             */
            this.id = "nx-autocomplete-" + _uniqueAutocompleteIdCounter++;
            // As autocomplete option can hold any value, we might need a converter
            // to get a string representation, which can be stored in input. Default value ? value.toString() : null.
            /**
             * Value to string converter.
             */
            this.valueFormatter = (/**
             * @param {?} value
             * @return {?}
             */
            function (value) { return value ? value.toString() : null; });
        }
        Object.defineProperty(NxAutocompleteComponent.prototype, "isOpen", {
            /** Whether the autocomplete panel is open. */
            get: /**
             * Whether the autocomplete panel is open.
             * @return {?}
             */
            function () { return this._isOpen && this.showPanel; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NxAutocompleteComponent.prototype, "items", {
            get: /**
             * @return {?}
             */
            function () {
                return this._items;
            },
            /** Items observable. If given, autocomplete takes care of the options and ng-content is discarderd */
            set: /**
             * Items observable. If given, autocomplete takes care of the options and ng-content is discarderd
             * @param {?} val
             * @return {?}
             */
            function (val) {
                var _this = this;
                this._hasItems = true;
                if (Array.isArray(val)) {
                    this._items = val;
                }
                else if (val instanceof rxjs.Observable) {
                    if (this._itemsSubscription) {
                        this._itemsSubscription.unsubscribe();
                    }
                    this._itemsSubscription = val.subscribe((/**
                     * @param {?} itms
                     * @return {?}
                     */
                    function (itms) {
                        _this._items = itms;
                        _this._changeDetectorRef.markForCheck();
                        // and check visibility in next cycle, when options are set
                        setTimeout((/**
                         * @return {?}
                         */
                        function () { return _this._setVisibility(); }));
                    }));
                }
                else if (val === null) {
                    this._items = val;
                }
                else {
                    throw new Error('Invalid argument for autocomplete items. It has to be Array<string> or Observable<Array<string>>');
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NxAutocompleteComponent.prototype, "hasItems", {
            /**
             * @docs-private
             * Is items observable set
             */
            get: /**
             * \@docs-private
             * Is items observable set
             * @return {?}
             */
            function () {
                return this._hasItems;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NxAutocompleteComponent.prototype, "options", {
            /** Autocomplete options */
            get: /**
             * Autocomplete options
             * @return {?}
             */
            function () {
                return this.hasItems ? this._vOptions : this._cOptions;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NxAutocompleteComponent.prototype, "classList", {
            /**
             * Takes classes set on the host nx-autocomplete element and applies them to the panel
             * inside the overlay container to allow for easy styling.
             */
            set: /**
             * Takes classes set on the host nx-autocomplete element and applies them to the panel
             * inside the overlay container to allow for easy styling.
             * @param {?} value
             * @return {?}
             */
            function (value) {
                var _this = this;
                if (value && value.length) {
                    value.split(' ').forEach((/**
                     * @param {?} className
                     * @return {?}
                     */
                    function (className) { return _this._classList[className.trim()] = true; }));
                    this._elementRef.nativeElement.className = '';
                }
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        NxAutocompleteComponent.prototype.ngAfterViewInit = /**
         * @return {?}
         */
        function () {
            this._keyManager = new a11y.ActiveDescendantKeyManager(this.options).withWrap();
            this._setVisibility();
        };
        /**
         * @return {?}
         */
        NxAutocompleteComponent.prototype.ngOnDestroy = /**
         * @return {?}
         */
        function () {
            if (this._itemsSubscription) {
                this._itemsSubscription.unsubscribe();
            }
        };
        /**
         * Sets the panel scrollTop. This allows us to manually scroll to display options
         * above or below the fold, as they are not actually being focused when active.
         */
        /**
         * Sets the panel scrollTop. This allows us to manually scroll to display options
         * above or below the fold, as they are not actually being focused when active.
         * @param {?} scrollTop
         * @return {?}
         */
        NxAutocompleteComponent.prototype._setScrollTop = /**
         * Sets the panel scrollTop. This allows us to manually scroll to display options
         * above or below the fold, as they are not actually being focused when active.
         * @param {?} scrollTop
         * @return {?}
         */
        function (scrollTop) {
            if (this.panel) {
                this.panel.nativeElement.scrollTop = scrollTop;
            }
        };
        /** Returns the panel's scrollTop. */
        /**
         * Returns the panel's scrollTop.
         * @return {?}
         */
        NxAutocompleteComponent.prototype._getScrollTop = /**
         * Returns the panel's scrollTop.
         * @return {?}
         */
        function () {
            return this.panel ? this.panel.nativeElement.scrollTop : 0;
        };
        /** Panel should hide itself when the option list is empty. */
        /**
         * Panel should hide itself when the option list is empty.
         * @return {?}
         */
        NxAutocompleteComponent.prototype._setVisibility = /**
         * Panel should hide itself when the option list is empty.
         * @return {?}
         */
        function () {
            this.showPanel = !!(this.options && this.options.length);
            this._classList['nx-autocomplete-visible'] = this.showPanel;
            this._classList['nx-autocomplete-hidden'] = !this.showPanel;
            this._changeDetectorRef.markForCheck();
        };
        /** Emits the `select` event. */
        /**
         * Emits the `select` event.
         * @param {?} option
         * @return {?}
         */
        NxAutocompleteComponent.prototype._emitSelectEvent = /**
         * Emits the `select` event.
         * @param {?} option
         * @return {?}
         */
        function (option) {
            /** @type {?} */
            var event = new NxAutocompleteSelectedEvent(this, option);
            this.optionSelected.emit(event);
        };
        Object.defineProperty(NxAutocompleteComponent.prototype, "_isInOutlineField", {
            get: /**
             * @return {?}
             */
            function () {
                return this.formFieldComponent !== null
                    && this.formFieldComponent.appearance === 'outline';
            },
            enumerable: true,
            configurable: true
        });
        NxAutocompleteComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'nx-autocomplete',
                        template: "<ng-template>\n  <div class=\"nx-autocomplete-panel\" role=\"listbox\" [id]=\"id\" [ngClass]=\"_classList\"\n  [class.nx-autocomplete-panel--in-outline-field]=\"_isInOutlineField\" #panel>\n    <ng-container *ngIf=\"hasItems\">\n      <nx-autocomplete-option *ngFor=\"let item of items\" [value]=\"item\">\n        {{item}}\n      </nx-autocomplete-option>\n    </ng-container>\n    <ng-container *ngIf=\"!hasItems\">\n      <ng-content></ng-content>\n    </ng-container>\n  </div>\n</ng-template>\n",
                        changeDetection: core.ChangeDetectionStrategy.OnPush,
                        exportAs: 'nxAutocomplete',
                        host: {
                            'class': 'nx-autocomplete'
                        },
                        styles: [":host ::ng-deep .c-input::-ms-clear{width:0;height:0}.nx-autocomplete-panel{background-color:#fff;box-shadow:0 2px 4px rgba(65,65,65,.5);overflow-y:auto;overflow-x:hidden;max-height:280px;width:100%;border-radius:4px}.nx-autocomplete-panel.nx-autocomplete-visible{visibility:visible}.nx-autocomplete-panel.nx-autocomplete-hidden{visibility:hidden}.nx-autocomplete-panel--in-outline-field ::ng-deep nx-autocomplete-option .nx-autocomplete-option,.nx-autocomplete-panel--in-outline-field ::ng-deep nx-autocomplete-option .nx-autocomplete-option__label{font-size:16px;font-size:var(--dropdown-item-outline-font-size,16px);line-height:24px;line-height:var(--dropdown-item-outline-line-height,24px);font-weight:400;font-weight:var(--dropdown-item-outline-font-weight,400);letter-spacing:0;letter-spacing:var(--dropdown-item-outline-letter-spacing,0)}@media screen and (-ms-high-contrast:active){.nx-autocomplete-panel{box-shadow:0 0 0 1px windowText}}"]
                    }] }
        ];
        /** @nocollapse */
        NxAutocompleteComponent.ctorParameters = function () { return [
            { type: core.ChangeDetectorRef },
            { type: core.ElementRef },
            { type: formfield.NxFormfieldComponent, decorators: [{ type: core.Optional }] }
        ]; };
        NxAutocompleteComponent.propDecorators = {
            template: [{ type: core.ViewChild, args: [core.TemplateRef, { static: false },] }],
            panel: [{ type: core.ViewChild, args: ['panel', { static: false },] }],
            items: [{ type: core.Input }],
            optionSelected: [{ type: core.Output }],
            opened: [{ type: core.Output }],
            closed: [{ type: core.Output }],
            _vOptions: [{ type: core.ViewChildren, args: [NxAutocompleteOptionComponent,] }],
            _cOptions: [{ type: core.ContentChildren, args: [NxAutocompleteOptionComponent, { descendants: true },] }],
            classList: [{ type: core.Input, args: ['class',] }],
            valueFormatter: [{ type: core.Input, args: ['nxValueFormatter',] }]
        };
        return NxAutocompleteComponent;
    }());
    if (false) {
        /**
         * Manages active item in option list based on key events.
         * @type {?}
         */
        NxAutocompleteComponent.prototype._keyManager;
        /**
         * Whether the autocomplete panel should be visible, depending on option length.
         * @type {?}
         */
        NxAutocompleteComponent.prototype.showPanel;
        /** @type {?} */
        NxAutocompleteComponent.prototype._isOpen;
        /**
         * \@docs-private
         * @type {?}
         */
        NxAutocompleteComponent.prototype.template;
        /**
         * \@docs-private
         * Element for the panel containing the autocomplete options.
         * @type {?}
         */
        NxAutocompleteComponent.prototype.panel;
        /**
         * @type {?}
         * @private
         */
        NxAutocompleteComponent.prototype._items;
        /**
         * @type {?}
         * @private
         */
        NxAutocompleteComponent.prototype._itemsSubscription;
        /**
         * @type {?}
         * @private
         */
        NxAutocompleteComponent.prototype._hasItems;
        /**
         * Event that is emitted whenever an option from the list is selected.
         * @type {?}
         */
        NxAutocompleteComponent.prototype.optionSelected;
        /**
         * Event that is emitted when the autocomplete panel is opened.
         * @type {?}
         */
        NxAutocompleteComponent.prototype.opened;
        /**
         * Event that is emitted when the autocomplete panel is closed.
         * @type {?}
         */
        NxAutocompleteComponent.prototype.closed;
        /**
         * Autocomplete options in view - ie from items
         * @type {?}
         * @private
         */
        NxAutocompleteComponent.prototype._vOptions;
        /**
         * Autocomplete options in content - ie user provided
         * @type {?}
         * @private
         */
        NxAutocompleteComponent.prototype._cOptions;
        /** @type {?} */
        NxAutocompleteComponent.prototype._classList;
        /**
         * Unique ID to be used by autocomplete trigger's "aria-owns" property.
         * @type {?}
         */
        NxAutocompleteComponent.prototype.id;
        /**
         * Value to string converter.
         * @type {?}
         */
        NxAutocompleteComponent.prototype.valueFormatter;
        /**
         * @type {?}
         * @private
         */
        NxAutocompleteComponent.prototype._changeDetectorRef;
        /**
         * @type {?}
         * @private
         */
        NxAutocompleteComponent.prototype._elementRef;
        /**
         * @type {?}
         * @private
         */
        NxAutocompleteComponent.prototype.formFieldComponent;
    }

    /**
     * @fileoverview added by tsickle
     * Generated from: autocomplete-trigger.directive.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * Provider that allows the autocomplete to register as a ControlValueAccessor.
     * \@docs-private
     * @type {?}
     */
    var NX_AUTOCOMPLETE_VALUE_ACCESSOR = {
        provide: forms.NG_VALUE_ACCESSOR,
        useExisting: core.forwardRef((/**
         * @return {?}
         */
        function () { return NxAutocompleteTriggerDirective; })),
        multi: true
    };
    /**
     * Creates an error to be thrown when attempting to use an autocomplete trigger without a panel.
     * @return {?}
     */
    function getNxAutocompleteMissingPanelError() {
        return Error('Attempting to open an undefined instance of `nx-autocomplete`. ' +
            'Make sure that the id passed to the `nxAutocomplete` is correct and that ' +
            'you\'re attempting to open it after the ngAfterContentInit hook.');
    }
    var NxAutocompleteTriggerDirective = /** @class */ (function () {
        function NxAutocompleteTriggerDirective(_element, _overlay, _viewContainerRef, _zone, _changeDetectorRef, _dir, _nxFormField, _nxWordField, _document, _viewportRuler) {
            var _this = this;
            this._element = _element;
            this._overlay = _overlay;
            this._viewContainerRef = _viewContainerRef;
            this._zone = _zone;
            this._changeDetectorRef = _changeDetectorRef;
            this._dir = _dir;
            this._nxFormField = _nxFormField;
            this._nxWordField = _nxWordField;
            this._document = _document;
            this._viewportRuler = _viewportRuler;
            this._componentDestroyed = false;
            /**
             * Whether or not the label state is being overridden.
             */
            this._manuallyFloatingLabel = false;
            /**
             * Subscription to viewport size changes.
             */
            this._viewportSubscription = rxjs.Subscription.EMPTY;
            /**
             * Stream of keyboard events that can close the panel.
             */
            this._closeKeyEventStream = new rxjs.Subject();
            /**
             * Value changes
             */
            this._valueChanges = new rxjs.Subject();
            this._itemsCb = null;
            this._debounce = 400;
            this._autocompleteDisabled = false;
            this._overlayAttached = false;
            /**
             * Stream of autocomplete option selections.
             */
            this.optionSelections = rxjs.defer((/**
             * @return {?}
             */
            function () {
                if (_this.autocomplete && _this.autocomplete.options) {
                    return rxjs.merge.apply(void 0, __spread(_this.autocomplete.options.map((/**
                     * @param {?} option
                     * @return {?}
                     */
                    function (option) { return option.onSelectionChange; }))));
                }
                // If there are any subscribers before `ngAfterViewInit`, the `autocomplete` will be undefined.
                // Return a stream that we'll replace with the real one once everything is in place.
                return _this._zone.onStable
                    .asObservable()
                    .pipe(operators.take(1), operators.switchMap((/**
                 * @return {?}
                 */
                function () { return _this.optionSelections; })));
            }));
            /**
             * `View -> model callback called when value changes`
             */
            this._onChange = (/**
             * @param {?} val
             * @return {?}
             */
            function (val) {
                _this._valueChanges.next(val);
            });
            /**
             * `View -> model callback called when autocomplete has been touched`
             */
            this._onTouched = (/**
             * @return {?}
             */
            function () { });
        }
        Object.defineProperty(NxAutocompleteTriggerDirective.prototype, "itemsCb", {
            get: /**
             * @return {?}
             */
            function () {
                return this._itemsCb;
            },
            /** The items callback. Called with input value, must return Observable of Array of strings */
            set: /**
             * The items callback. Called with input value, must return Observable of Array of strings
             * @param {?} val
             * @return {?}
             */
            function (val) {
                if (typeof val === 'function') {
                    this._itemsCb = val;
                }
                else {
                    throw new Error('Wrong value type for nxAutocompleteItems');
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NxAutocompleteTriggerDirective.prototype, "debounce", {
            /** Debounce in ms before items callback is triggered. Defaults to 400 */
            set: /**
             * Debounce in ms before items callback is triggered. Defaults to 400
             * @param {?} val
             * @return {?}
             */
            function (val) {
                this._debounce = coercion.coerceNumberProperty(val);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NxAutocompleteTriggerDirective.prototype, "autocompleteDisabled", {
            get: /**
             * @return {?}
             */
            function () {
                return this._autocompleteDisabled;
            },
            /** Whether autocomplete functionality is disabled. */
            set: /**
             * Whether autocomplete functionality is disabled.
             * @param {?} val
             * @return {?}
             */
            function (val) {
                this._autocompleteDisabled = val;
                this._bindAutocompleteItems();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NxAutocompleteTriggerDirective.prototype, "panelOpen", {
            /** Whether or not the autocomplete panel is open. */
            get: /**
             * Whether or not the autocomplete panel is open.
             * @return {?}
             */
            function () {
                return this._overlayAttached && this.autocomplete.showPanel;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NxAutocompleteTriggerDirective.prototype, "activeOption", {
            /** The currently active option, coerced to NxAutocompleteOptionComponent type. */
            get: /**
             * The currently active option, coerced to NxAutocompleteOptionComponent type.
             * @return {?}
             */
            function () {
                if (this.autocomplete && this.autocomplete._keyManager) {
                    return this.autocomplete._keyManager.activeItem;
                }
                return null;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NxAutocompleteTriggerDirective.prototype, "_outsideClickStream", {
            /** Stream of clicks outside of the autocomplete panel. */
            get: /**
             * Stream of clicks outside of the autocomplete panel.
             * @private
             * @return {?}
             */
            function () {
                var _this = this;
                if (!this._document) {
                    return rxjs.of(null);
                }
                return rxjs.merge(rxjs.fromEvent(this._document, 'click'), rxjs.fromEvent(this._document, 'touchend'))
                    .pipe(operators.filter((/**
                 * @param {?} event
                 * @return {?}
                 */
                function (event) {
                    /** @type {?} */
                    var clickTarget = (/** @type {?} */ (event.target));
                    /** @type {?} */
                    var formField = _this._formField ?
                        _this._formField.elementRef.nativeElement : null;
                    return _this._overlayAttached &&
                        clickTarget !== _this._element.nativeElement &&
                        (!formField || !formField.contains(clickTarget)) &&
                        (!!_this._overlayRef && !_this._overlayRef.overlayElement.contains(clickTarget));
                })));
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NxAutocompleteTriggerDirective.prototype, "_formField", {
            get: /**
             * @private
             * @return {?}
             */
            function () {
                if (this._nxFormField) {
                    return this._nxFormField;
                }
                else if (this._nxWordField) {
                    return this._nxWordField;
                }
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        NxAutocompleteTriggerDirective.prototype.ngOnDestroy = /**
         * @return {?}
         */
        function () {
            this._viewportSubscription.unsubscribe();
            this._componentDestroyed = true;
            this._destroyPanel();
            this._closeKeyEventStream.complete();
            if (this._controlValueChangesSubscription) {
                this._controlValueChangesSubscription.unsubscribe();
            }
            if (this._itemsSubscription) {
                this._itemsSubscription.unsubscribe();
            }
        };
        /**
         * @return {?}
         */
        NxAutocompleteTriggerDirective.prototype.ngOnChanges = /**
         * @return {?}
         */
        function () {
            this._bindAutocompleteItems();
        };
        /**
         * @return {?}
         */
        NxAutocompleteTriggerDirective.prototype.ngAfterViewInit = /**
         * @return {?}
         */
        function () {
            this._bindAutocompleteItems();
        };
        /**
         * Binds or rebinds the autocomplete items. Prerequisites:
         * - items callback has to be defined
         * - autocomplete panel has to be bound
         */
        /**
         * Binds or rebinds the autocomplete items. Prerequisites:
         * - items callback has to be defined
         * - autocomplete panel has to be bound
         * @private
         * @return {?}
         */
        NxAutocompleteTriggerDirective.prototype._bindAutocompleteItems = /**
         * Binds or rebinds the autocomplete items. Prerequisites:
         * - items callback has to be defined
         * - autocomplete panel has to be bound
         * @private
         * @return {?}
         */
        function () {
            var _this = this;
            if (this._controlValueChangesSubscription) {
                this._controlValueChangesSubscription.unsubscribe();
            }
            if (typeof this._itemsCb === 'function' && this.autocomplete && !this.autocompleteDisabled) {
                /** @type {?} */
                var itemsSubject_1 = new rxjs.Subject();
                this.autocomplete.items = itemsSubject_1;
                /** @type {?} */
                var valueChanges = this._formField &&
                    this._formField._control &&
                    this._formField._control.ngControl &&
                    this._formField._control.ngControl.valueChanges ?
                    this._formField._control.ngControl.valueChanges : this._valueChanges;
                this._controlValueChangesSubscription = valueChanges.pipe(operators.debounceTime(this._debounce))
                    .subscribe((/**
                 * @param {?} input
                 * @return {?}
                 */
                function (input) {
                    if (_this._itemsSubscription) {
                        _this._itemsSubscription.unsubscribe();
                    }
                    _this._itemsSubscription = _this._itemsCb(input).pipe(operators.first()).subscribe((/**
                     * @param {?} result
                     * @return {?}
                     */
                    function (result) {
                        itemsSubject_1.next(result);
                    }), (/**
                     * @param {?} err
                     * @return {?}
                     */
                    function (err) {
                        // On error reset
                        // TODO: Log error?
                        itemsSubject_1.next([]);
                    }));
                }));
            }
        };
        /** Opens the autocomplete suggestion panel. */
        /**
         * Opens the autocomplete suggestion panel.
         * @return {?}
         */
        NxAutocompleteTriggerDirective.prototype.openPanel = /**
         * Opens the autocomplete suggestion panel.
         * @return {?}
         */
        function () {
            if (!this.autocompleteDisabled) {
                this._attachOverlay();
                this._floatLabel();
            }
        };
        /** Closes the autocomplete suggestion panel. */
        /**
         * Closes the autocomplete suggestion panel.
         * @return {?}
         */
        NxAutocompleteTriggerDirective.prototype.closePanel = /**
         * Closes the autocomplete suggestion panel.
         * @return {?}
         */
        function () {
            this._resetLabel();
            if (!this._overlayAttached) {
                return;
            }
            if (this.panelOpen) {
                // Only emit if the panel was visible.
                this.autocomplete.closed.emit();
            }
            this.autocomplete._isOpen = this._overlayAttached = false;
            if (this._overlayRef && this._overlayRef.hasAttached()) {
                this._overlayRef.detach();
                this._closingActionsSubscription.unsubscribe();
            }
            // Note that in some cases this can end up being called after the component is destroyed.
            // Add a check to ensure that we don't try to run change detection on a destroyed view.
            if (!this._componentDestroyed) {
                // We need to trigger change detection manually, because
                // `fromEvent` doesn't seem to do it at the proper time.
                // This ensures that the label is reset when the
                // user clicks outside.
                this._changeDetectorRef.detectChanges();
            }
        };
        Object.defineProperty(NxAutocompleteTriggerDirective.prototype, "panelClosingActions", {
            /**
             * A stream of actions that should close the autocomplete panel, including
             * when an option is selected, on blur, and when TAB is pressed.
             */
            get: /**
             * A stream of actions that should close the autocomplete panel, including
             * when an option is selected, on blur, and when TAB is pressed.
             * @return {?}
             */
            function () {
                var _this = this;
                return rxjs.merge(this.optionSelections, this.autocomplete._keyManager.tabOut.pipe(operators.filter((/**
                 * @return {?}
                 */
                function () { return _this._overlayAttached; }))), this._closeKeyEventStream, this._outsideClickStream, this._overlayRef ?
                    this._overlayRef.detachments().pipe(operators.filter((/**
                     * @return {?}
                     */
                    function () { return _this._overlayAttached; }))) :
                    rxjs.of());
            },
            enumerable: true,
            configurable: true
        });
        // Implemented as part of ControlValueAccessor.
        // Implemented as part of ControlValueAccessor.
        /**
         * @param {?} value
         * @return {?}
         */
        NxAutocompleteTriggerDirective.prototype.writeValue = 
        // Implemented as part of ControlValueAccessor.
        /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            var _this = this;
            Promise.resolve(null).then((/**
             * @return {?}
             */
            function () { return _this._setTriggerValue(value); }));
        };
        // Implemented as part of ControlValueAccessor.
        // Implemented as part of ControlValueAccessor.
        /**
         * @param {?} fn
         * @return {?}
         */
        NxAutocompleteTriggerDirective.prototype.registerOnChange = 
        // Implemented as part of ControlValueAccessor.
        /**
         * @param {?} fn
         * @return {?}
         */
        function (fn) {
            this._onChange = fn;
        };
        // Implemented as part of ControlValueAccessor.
        // Implemented as part of ControlValueAccessor.
        /**
         * @param {?} fn
         * @return {?}
         */
        NxAutocompleteTriggerDirective.prototype.registerOnTouched = 
        // Implemented as part of ControlValueAccessor.
        /**
         * @param {?} fn
         * @return {?}
         */
        function (fn) {
            this._onTouched = fn;
        };
        // Implemented as part of ControlValueAccessor.
        // Implemented as part of ControlValueAccessor.
        /**
         * @param {?} isDisabled
         * @return {?}
         */
        NxAutocompleteTriggerDirective.prototype.setDisabledState = 
        // Implemented as part of ControlValueAccessor.
        /**
         * @param {?} isDisabled
         * @return {?}
         */
        function (isDisabled) {
            this._element.nativeElement.disabled = isDisabled;
        };
        /**
         * @param {?} event
         * @return {?}
         */
        NxAutocompleteTriggerDirective.prototype._handleKeydown = /**
         * @param {?} event
         * @return {?}
         */
        function (event) {
            /** @type {?} */
            var keyCode = event.keyCode;
            // Prevent the default action on all escape key presses. This is here primarily to bring IE
            // in line with other browsers. By default, pressing escape on IE will cause it to revert
            // the input value to the one that it had on focus, however it won't dispatch any events
            // which means that the model value will be out of sync with the view.
            if (keyCode === keycodes.ESCAPE) {
                event.preventDefault();
            }
            // Close when pressing ESCAPE or ALT + UP_ARROW, based on the a11y guidelines.
            // See: https://www.w3.org/TR/wai-aria-practices-1.1/#textbox-keyboard-interaction
            if (this.panelOpen && (keyCode === keycodes.ESCAPE || (keyCode === keycodes.UP_ARROW && event.altKey))) {
                this._resetActiveItem();
                this._closeKeyEventStream.next();
                event.stopPropagation();
            }
            else if (this.activeOption && keyCode === keycodes.ENTER && this.panelOpen) {
                this.activeOption._selectViaInteraction();
                this._resetActiveItem();
                event.preventDefault();
            }
            else {
                /** @type {?} */
                var prevActiveItem = this.autocomplete._keyManager.activeItem;
                /** @type {?} */
                var isArrowKey = keyCode === keycodes.UP_ARROW || keyCode === keycodes.DOWN_ARROW;
                if (this.panelOpen || keyCode === keycodes.TAB) {
                    this.autocomplete._keyManager.onKeydown(event);
                }
                else if (isArrowKey && this._isFieldEnabled()) {
                    this.openPanel();
                }
                if (isArrowKey || this.autocomplete._keyManager.activeItem !== prevActiveItem) {
                    this._scrollToOption();
                }
            }
        };
        /**
         * @param {?} event
         * @return {?}
         */
        NxAutocompleteTriggerDirective.prototype._handleInput = /**
         * @param {?} event
         * @return {?}
         */
        function (event) {
            /** @type {?} */
            var target = (/** @type {?} */ (event.target));
            /** @type {?} */
            var value = target.value;
            // Based on `NumberValueAccessor` from forms.
            if (target.type === 'number') {
                value = value === '' ? null : parseFloat(value);
            }
            // If the input has a placeholder, IE will fire the `input` event on page load,
            // focus and blur, in addition to when the user actually changed the value. To
            // filter out all of the extra events, we save the value on focus and between
            // `input` events, and we check whether it changed.
            // See: https://connect.microsoft.com/IE/feedback/details/885747/
            if (this._isFieldEnabled() && this._previousValue !== value &&
                document.activeElement === event.target) {
                this._previousValue = value;
                this._onChange(value);
                this.openPanel();
            }
        };
        /**
         * @return {?}
         */
        NxAutocompleteTriggerDirective.prototype._handleFocus = /**
         * @return {?}
         */
        function () {
            if (this._isFieldEnabled()) {
                this._previousValue = this._element.nativeElement.value;
                this.openPanel();
            }
        };
        /**
         * In "auto" mode, the label will animate down as soon as focus is lost.
         * This causes the value to jump when selecting an option with the mouse.
         * This method manually floats the label until the panel can be closed.
         * @param shouldAnimate Whether the label should be animated when it is floated.
         */
        /**
         * In "auto" mode, the label will animate down as soon as focus is lost.
         * This causes the value to jump when selecting an option with the mouse.
         * This method manually floats the label until the panel can be closed.
         * @private
         * @return {?}
         */
        NxAutocompleteTriggerDirective.prototype._floatLabel = /**
         * In "auto" mode, the label will animate down as soon as focus is lost.
         * This causes the value to jump when selecting an option with the mouse.
         * This method manually floats the label until the panel can be closed.
         * @private
         * @return {?}
         */
        function () {
            if (this._nxFormField && this._nxFormField.floatLabel === 'auto') {
                this._nxFormField.floatLabel = 'always';
                this._manuallyFloatingLabel = true;
            }
        };
        /** If the label has been manually elevated, return it to its normal state. */
        /**
         * If the label has been manually elevated, return it to its normal state.
         * @private
         * @return {?}
         */
        NxAutocompleteTriggerDirective.prototype._resetLabel = /**
         * If the label has been manually elevated, return it to its normal state.
         * @private
         * @return {?}
         */
        function () {
            if (this._manuallyFloatingLabel) {
                this._nxFormField.floatLabel = 'auto';
                this._manuallyFloatingLabel = false;
            }
        };
        /**
         * Given that we are not actually focusing active options, we must manually adjust scroll
         * to reveal options below the fold. First, we find the offset of the option from the top
         * of the panel. If that offset is below the fold, the new scrollTop will be the offset -
         * the panel height + the option height, so the active option will be just visible at the
         * bottom of the panel. If that offset is above the top of the visible panel, the new scrollTop
         * will become the offset. If that offset is visible within the panel already, the scrollTop is
         * not adjusted.
         */
        /**
         * Given that we are not actually focusing active options, we must manually adjust scroll
         * to reveal options below the fold. First, we find the offset of the option from the top
         * of the panel. If that offset is below the fold, the new scrollTop will be the offset -
         * the panel height + the option height, so the active option will be just visible at the
         * bottom of the panel. If that offset is above the top of the visible panel, the new scrollTop
         * will become the offset. If that offset is visible within the panel already, the scrollTop is
         * not adjusted.
         * @private
         * @return {?}
         */
        NxAutocompleteTriggerDirective.prototype._scrollToOption = /**
         * Given that we are not actually focusing active options, we must manually adjust scroll
         * to reveal options below the fold. First, we find the offset of the option from the top
         * of the panel. If that offset is below the fold, the new scrollTop will be the offset -
         * the panel height + the option height, so the active option will be just visible at the
         * bottom of the panel. If that offset is above the top of the visible panel, the new scrollTop
         * will become the offset. If that offset is visible within the panel already, the scrollTop is
         * not adjusted.
         * @private
         * @return {?}
         */
        function () {
            if (this.autocomplete.options.length === 0) {
                return;
            }
            /** @type {?} */
            var optionOffset = 0;
            /** @type {?} */
            var optionHeight = this.autocomplete.options.first.elementRef.nativeElement.offsetHeight;
            if (this.autocomplete._keyManager.activeItem) {
                optionOffset = this.autocomplete._keyManager.activeItem.elementRef.nativeElement.offsetTop;
            }
            /** @type {?} */
            var newScrollPosition = _getOptionScrollPosition(optionOffset, optionHeight, this.autocomplete._getScrollTop(), this.autocomplete.panel.nativeElement.offsetHeight);
            this.autocomplete._setScrollTop(newScrollPosition);
        };
        /**
         * This method listens to a stream of panel closing actions and resets the
         * stream every time the option list changes.
         */
        /**
         * This method listens to a stream of panel closing actions and resets the
         * stream every time the option list changes.
         * @private
         * @return {?}
         */
        NxAutocompleteTriggerDirective.prototype._subscribeToClosingActions = /**
         * This method listens to a stream of panel closing actions and resets the
         * stream every time the option list changes.
         * @private
         * @return {?}
         */
        function () {
            var _this = this;
            /** @type {?} */
            var firstStable = this._zone.onStable.asObservable().pipe(operators.take(1));
            /** @type {?} */
            var optionChanges = this.autocomplete.options.changes.pipe(operators.tap((/**
             * @return {?}
             */
            function () { return _this._positionStrategy.reapplyLastPosition(); })), 
            // Defer emitting to the stream until the next tick, because changing
            // bindings in here will cause "changed after checked" errors.
            operators.delay(0));
            // When the zone is stable initially, and when the option list changes...
            return rxjs.merge(firstStable, optionChanges)
                .pipe(
            // create a new stream of panelClosingActions, replacing any previous streams
            // that were created, and flatten it so our stream only emits closing events...
            operators.switchMap((/**
             * @return {?}
             */
            function () {
                _this._resetActiveItem();
                _this.autocomplete._setVisibility();
                return _this.panelClosingActions;
            })), 
            // when the first closing event occurs...
            operators.take(1))
                // set the value, close the panel, and complete.
                .subscribe((/**
             * @param {?} event
             * @return {?}
             */
            function (event) { return _this._setValueAndClose(event); }));
        };
        /** Destroys the autocomplete suggestion panel. */
        /**
         * Destroys the autocomplete suggestion panel.
         * @private
         * @return {?}
         */
        NxAutocompleteTriggerDirective.prototype._destroyPanel = /**
         * Destroys the autocomplete suggestion panel.
         * @private
         * @return {?}
         */
        function () {
            if (this._overlayRef) {
                this.closePanel();
                this._overlayRef.dispose();
                this._overlayRef = null;
            }
        };
        /**
         * @private
         * @param {?} value
         * @return {?}
         */
        NxAutocompleteTriggerDirective.prototype._setTriggerValue = /**
         * @private
         * @param {?} value
         * @return {?}
         */
        function (value) {
            /** @type {?} */
            var toDisplay = this.autocomplete && this.autocomplete.valueFormatter ?
                this.autocomplete.valueFormatter(value) :
                value;
            // Simply falling back to an empty string if the display value is falsy does not work properly.
            // The display value can also be the number zero and shouldn't fall back to an empty string.
            /** @type {?} */
            var inputValue = toDisplay != null ? toDisplay : '';
            // If it's used within a `NxFormField` or `NxWord`, we should set it through the property so it can go
            // through change detection.
            if (this._formField) {
                this._formField._control.value = inputValue;
            }
            else {
                this._element.nativeElement.value = inputValue;
            }
        };
        /**
         * This method closes the panel, and if a value is specified, also sets the associated
         * control to that value. It will also mark the control as dirty if this interaction
         * stemmed from the user.
         */
        /**
         * This method closes the panel, and if a value is specified, also sets the associated
         * control to that value. It will also mark the control as dirty if this interaction
         * stemmed from the user.
         * @private
         * @param {?} event
         * @return {?}
         */
        NxAutocompleteTriggerDirective.prototype._setValueAndClose = /**
         * This method closes the panel, and if a value is specified, also sets the associated
         * control to that value. It will also mark the control as dirty if this interaction
         * stemmed from the user.
         * @private
         * @param {?} event
         * @return {?}
         */
        function (event) {
            if (event && event.source) {
                this._clearPreviousSelectedOption(event.source);
                this._setTriggerValue(event.source.value);
                this._onChange(event.source.value);
                this._element.nativeElement.focus();
                this.autocomplete._emitSelectEvent(event.source);
            }
            this.closePanel();
        };
        /**
         * Clear any previous selected option and emit a selection change event for this option
         */
        /**
         * Clear any previous selected option and emit a selection change event for this option
         * @private
         * @param {?} skip
         * @return {?}
         */
        NxAutocompleteTriggerDirective.prototype._clearPreviousSelectedOption = /**
         * Clear any previous selected option and emit a selection change event for this option
         * @private
         * @param {?} skip
         * @return {?}
         */
        function (skip) {
            this.autocomplete.options.forEach((/**
             * @param {?} option
             * @return {?}
             */
            function (option) {
                if (option !== skip && option.selected) {
                    option.deselect();
                }
            }));
        };
        /**
         * @private
         * @return {?}
         */
        NxAutocompleteTriggerDirective.prototype._attachOverlay = /**
         * @private
         * @return {?}
         */
        function () {
            var _this = this;
            if (!this.autocomplete) {
                throw getNxAutocompleteMissingPanelError();
            }
            if (!this._overlayRef) {
                this._portal = new portal.TemplatePortal(this.autocomplete.template, this._viewContainerRef);
                this._overlayRef = this._overlay.create(this._getOverlayConfig());
                if (this._viewportRuler) {
                    this._viewportSubscription = this._viewportRuler.change().subscribe((/**
                     * @return {?}
                     */
                    function () {
                        if (_this.panelOpen && _this._overlayRef) {
                            _this._overlayRef.updateSize({ minWidth: _this._getHostWidth() });
                        }
                    }));
                }
            }
            else {
                /** Update the panel width, in case the host width has changed */
                this._overlayRef.updateSize({ minWidth: this._getHostWidth() });
            }
            if (this._overlayRef && !this._overlayRef.hasAttached()) {
                this._overlayRef.attach(this._portal);
                this._closingActionsSubscription = this._subscribeToClosingActions();
            }
            /** @type {?} */
            var wasOpen = this.panelOpen;
            this.autocomplete._setVisibility();
            this.autocomplete._isOpen = this._overlayAttached = true;
            // We need to do an extra `panelOpen` check in here, because the
            // autocomplete won't be shown if there are no options.
            if (this.panelOpen && wasOpen !== this.panelOpen) {
                this.autocomplete.opened.emit();
            }
        };
        /**
         * @private
         * @return {?}
         */
        NxAutocompleteTriggerDirective.prototype._getOverlayConfig = /**
         * @private
         * @return {?}
         */
        function () {
            return new overlay.OverlayConfig({
                positionStrategy: this._getOverlayPosition(),
                scrollStrategy: this._scrollStrategy(),
                minWidth: this._getHostWidth(),
                direction: this._dir ? this._dir.value : 'ltr'
            });
        };
        /**
         * @private
         * @return {?}
         */
        NxAutocompleteTriggerDirective.prototype._getOverlayPosition = /**
         * @private
         * @return {?}
         */
        function () {
            this._positionStrategy = this._overlay.position()
                .flexibleConnectedTo(this._getConnectedElement())
                .withViewportMargin(16)
                .withPush(false)
                .withPositions([
                {
                    originX: 'start',
                    originY: 'bottom',
                    overlayX: 'start',
                    overlayY: 'top'
                },
                {
                    originX: 'start',
                    originY: 'top',
                    overlayX: 'start',
                    overlayY: 'bottom',
                }
            ]);
            return this._positionStrategy;
        };
        /**
         * @private
         * @return {?}
         */
        NxAutocompleteTriggerDirective.prototype._scrollStrategy = /**
         * @private
         * @return {?}
         */
        function () {
            return this._overlay.scrollStrategies.reposition();
        };
        /**
         * @private
         * @return {?}
         */
        NxAutocompleteTriggerDirective.prototype._getConnectedElement = /**
         * @private
         * @return {?}
         */
        function () {
            return this._formField ? this._formField.getConnectedOverlayOrigin() : this._element;
        };
        /** Returns the width of the input element, so the panel min-width can match it. */
        /**
         * Returns the width of the input element, so the panel min-width can match it.
         * @private
         * @return {?}
         */
        NxAutocompleteTriggerDirective.prototype._getHostWidth = /**
         * Returns the width of the input element, so the panel min-width can match it.
         * @private
         * @return {?}
         */
        function () {
            return this._getConnectedElement().nativeElement.getBoundingClientRect().width;
        };
        /**
         * Resets the active item to -1 so arrow events will activate the
         * correct options, or to 0 if the consumer opted into it.
         */
        /**
         * Resets the active item to -1 so arrow events will activate the
         * correct options, or to 0 if the consumer opted into it.
         * @private
         * @return {?}
         */
        NxAutocompleteTriggerDirective.prototype._resetActiveItem = /**
         * Resets the active item to -1 so arrow events will activate the
         * correct options, or to 0 if the consumer opted into it.
         * @private
         * @return {?}
         */
        function () {
            this.autocomplete._keyManager.setActiveItem(-1);
        };
        /** Determines whether the panel can be opened. */
        /**
         * Determines whether the panel can be opened.
         * @private
         * @return {?}
         */
        NxAutocompleteTriggerDirective.prototype._isFieldEnabled = /**
         * Determines whether the panel can be opened.
         * @private
         * @return {?}
         */
        function () {
            /** @type {?} */
            var element = this._element.nativeElement;
            return !element.readOnly && !element.disabled;
        };
        NxAutocompleteTriggerDirective.decorators = [
            { type: core.Directive, args: [{
                        selector: "input[nxAutocomplete], textarea[nxAutocomplete]",
                        host: {
                            'role': 'combobox',
                            'autocomplete': 'off',
                            'aria-autocomplete': 'list',
                            '[attr.aria-activedescendant]': 'activeOption?.id',
                            '[attr.aria-expanded]': 'panelOpen.toString()',
                            '[attr.aria-owns]': 'autocomplete?.id',
                            // Note: we use `focusin`, as opposed to `focus`, in order to open the panel
                            // a little earlier. This avoids issues where IE delays the focusing of the input.
                            '(focusin)': '_handleFocus()',
                            '(blur)': '_onTouched()',
                            '(input)': '_handleInput($event)',
                            '(keydown)': '_handleKeydown($event)',
                        },
                        exportAs: 'nxAutocompleteTrigger',
                        providers: [NX_AUTOCOMPLETE_VALUE_ACCESSOR]
                    },] }
        ];
        /** @nocollapse */
        NxAutocompleteTriggerDirective.ctorParameters = function () { return [
            { type: core.ElementRef },
            { type: overlay.Overlay },
            { type: core.ViewContainerRef },
            { type: core.NgZone },
            { type: core.ChangeDetectorRef },
            { type: bidi.Directionality, decorators: [{ type: core.Optional }] },
            { type: formfield.NxFormfieldComponent, decorators: [{ type: core.Optional }, { type: core.Host }] },
            { type: naturalLanguageForm.NxWordComponent, decorators: [{ type: core.Optional }, { type: core.Host }] },
            { type: undefined, decorators: [{ type: core.Optional }, { type: core.Inject, args: [common.DOCUMENT,] }] },
            { type: overlay.ViewportRuler }
        ]; };
        NxAutocompleteTriggerDirective.propDecorators = {
            autocomplete: [{ type: core.Input, args: ['nxAutocomplete',] }],
            itemsCb: [{ type: core.Input, args: ['nxAutocompleteItems',] }],
            debounce: [{ type: core.Input, args: ['nxAutocompleteDebounce',] }],
            autocompleteDisabled: [{ type: core.Input, args: ['nxAutocompleteDisabled',] }]
        };
        return NxAutocompleteTriggerDirective;
    }());
    if (false) {
        /**
         * @type {?}
         * @private
         */
        NxAutocompleteTriggerDirective.prototype._overlayRef;
        /**
         * @type {?}
         * @private
         */
        NxAutocompleteTriggerDirective.prototype._portal;
        /**
         * @type {?}
         * @private
         */
        NxAutocompleteTriggerDirective.prototype._componentDestroyed;
        /**
         * Old value of the native input. Used to work around issues with the `input` event on IE.
         * @type {?}
         * @private
         */
        NxAutocompleteTriggerDirective.prototype._previousValue;
        /**
         * Strategy that is used to position the panel.
         * @type {?}
         * @private
         */
        NxAutocompleteTriggerDirective.prototype._positionStrategy;
        /**
         * Whether or not the label state is being overridden.
         * @type {?}
         * @private
         */
        NxAutocompleteTriggerDirective.prototype._manuallyFloatingLabel;
        /**
         * The subscription for closing actions (some are bound to document).
         * @type {?}
         * @private
         */
        NxAutocompleteTriggerDirective.prototype._closingActionsSubscription;
        /**
         * Subscription to viewport size changes.
         * @type {?}
         * @private
         */
        NxAutocompleteTriggerDirective.prototype._viewportSubscription;
        /**
         * Subscription to control value changes
         * @type {?}
         * @private
         */
        NxAutocompleteTriggerDirective.prototype._controlValueChangesSubscription;
        /**
         * Subscription to items observable
         * @type {?}
         * @private
         */
        NxAutocompleteTriggerDirective.prototype._itemsSubscription;
        /**
         * Stream of keyboard events that can close the panel.
         * @type {?}
         * @private
         */
        NxAutocompleteTriggerDirective.prototype._closeKeyEventStream;
        /**
         * Value changes
         * @type {?}
         * @private
         */
        NxAutocompleteTriggerDirective.prototype._valueChanges;
        /**
         * The autocomplete panel to be attached to this trigger.
         * @type {?}
         */
        NxAutocompleteTriggerDirective.prototype.autocomplete;
        /**
         * @type {?}
         * @private
         */
        NxAutocompleteTriggerDirective.prototype._itemsCb;
        /**
         * @type {?}
         * @private
         */
        NxAutocompleteTriggerDirective.prototype._debounce;
        /**
         * @type {?}
         * @private
         */
        NxAutocompleteTriggerDirective.prototype._autocompleteDisabled;
        /**
         * @type {?}
         * @private
         */
        NxAutocompleteTriggerDirective.prototype._overlayAttached;
        /**
         * Stream of autocomplete option selections.
         * @type {?}
         */
        NxAutocompleteTriggerDirective.prototype.optionSelections;
        /**
         * `View -> model callback called when value changes`
         * @type {?}
         */
        NxAutocompleteTriggerDirective.prototype._onChange;
        /**
         * `View -> model callback called when autocomplete has been touched`
         * @type {?}
         */
        NxAutocompleteTriggerDirective.prototype._onTouched;
        /**
         * @type {?}
         * @private
         */
        NxAutocompleteTriggerDirective.prototype._element;
        /**
         * @type {?}
         * @private
         */
        NxAutocompleteTriggerDirective.prototype._overlay;
        /**
         * @type {?}
         * @private
         */
        NxAutocompleteTriggerDirective.prototype._viewContainerRef;
        /**
         * @type {?}
         * @private
         */
        NxAutocompleteTriggerDirective.prototype._zone;
        /**
         * @type {?}
         * @private
         */
        NxAutocompleteTriggerDirective.prototype._changeDetectorRef;
        /**
         * @type {?}
         * @private
         */
        NxAutocompleteTriggerDirective.prototype._dir;
        /**
         * @type {?}
         * @private
         */
        NxAutocompleteTriggerDirective.prototype._nxFormField;
        /**
         * @type {?}
         * @private
         */
        NxAutocompleteTriggerDirective.prototype._nxWordField;
        /**
         * @type {?}
         * @private
         */
        NxAutocompleteTriggerDirective.prototype._document;
        /**
         * @type {?}
         * @private
         */
        NxAutocompleteTriggerDirective.prototype._viewportRuler;
    }
    /**
     * Determines the position to which to scroll a panel in order for an option to be into view.
     * \@docs-private
     * @param {?} optionOffset Option offset
     * @param {?} optionHeight Height of the options.
     * @param {?} currentScrollPosition Current scroll position of the panel.
     * @param {?} panelHeight Height of the panel.
     * @return {?}
     */
    function _getOptionScrollPosition(optionOffset, optionHeight, currentScrollPosition, panelHeight) {
        if (optionOffset < currentScrollPosition) {
            return optionOffset;
        }
        if (optionOffset + optionHeight > currentScrollPosition + panelHeight) {
            return Math.max(0, optionOffset - panelHeight + optionHeight);
        }
        return currentScrollPosition;
    }

    /**
     * @fileoverview added by tsickle
     * Generated from: autocomplete.module.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var NxAutocompleteModule = /** @class */ (function () {
        function NxAutocompleteModule() {
        }
        NxAutocompleteModule.decorators = [
            { type: core.NgModule, args: [{
                        declarations: [NxAutocompleteComponent, NxAutocompleteOptionComponent, NxAutocompleteTriggerDirective],
                        exports: [NxAutocompleteComponent, NxAutocompleteOptionComponent, NxAutocompleteTriggerDirective],
                        imports: [common.CommonModule, overlay.OverlayModule, a11y.A11yModule]
                    },] }
        ];
        return NxAutocompleteModule;
    }());

    exports.NX_AUTOCOMPLETE_VALUE_ACCESSOR = NX_AUTOCOMPLETE_VALUE_ACCESSOR;
    exports.NxAutocompleteComponent = NxAutocompleteComponent;
    exports.NxAutocompleteModule = NxAutocompleteModule;
    exports.NxAutocompleteOptionComponent = NxAutocompleteOptionComponent;
    exports.NxAutocompleteOptionSelected = NxAutocompleteOptionSelected;
    exports.NxAutocompleteSelectedEvent = NxAutocompleteSelectedEvent;
    exports.NxAutocompleteTriggerDirective = NxAutocompleteTriggerDirective;
    exports.getNxAutocompleteMissingPanelError = getNxAutocompleteMissingPanelError;

    Object.defineProperty(exports, '__esModule', { value: true });

})));
//# sourceMappingURL=allianz-ngx-ndbx-autocomplete.umd.js.map
