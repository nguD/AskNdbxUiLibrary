{"version":3,"sources":["ng://@allianz/ngx-ndbx/input/input.directive.ts","ng://@allianz/ngx-ndbx/input/password-toggle.component.ts","ng://@allianz/ngx-ndbx/input/input.module.ts"],"names":["NX_INPUT_VALUE_ACCESSOR","InjectionToken","INVALID_TYPES","NEVER_EMPTY","filter","t","getSupportedInputTypes","has","nextUniqueId","NxInputDirective","_elementRef","_platform","ngControl","_parentForm","_parentFormGroup","_errorStateMatcher","inputValueAccessor","_autofillMonitor","this","_type","_uid","_disabled","_required","_readonly","errorState","controlType","autofilled","stateChanges","Subject","focused","id","_inputValueAccessor","nativeElement","_previousNativeValue","value","nodeName","toLowerCase","Object","defineProperty","prototype","_id","coerceBooleanProperty","next","disabled","_validateType","_isTextarea","type","empty","_placeholder","ngOnInit","_this","isBrowser","monitor","subscribe","event","isAutofilled","_onInput","_focusChanged","isFocused","readonly","ngOnChanges","ngOnDestroy","complete","stopMonitoring","ngDoCheck","updateErrorState","_dirtyCheckNativeValue","oldState","parent","control","newState","isErrorState","setDescribedByIds","ids","_ariaDescribedby","join","setAriaLabel","_ariaLabel","_isBadInput","validity","badInput","_isNeverEmpty","indexOf","Error","placeholder","length","newValue","Directive","args","selector","exportAs","host","[class.c-input]","[attr.id]","[class.is-filled]","[class.is-disabled]","[class.has-error]","[class.is-focused]","[attr.disabled]","[attr.readonly]","[attr.required]","[attr.aria-label]","[attr.aria-describedby]","[attr.aria-invalid]","[attr.aria-required]","[attr.placeholder]","(blur)","(focus)","(input)","providers","provide","NxFormfieldControl","useExisting","ElementRef","Platform","NgControl","decorators","Optional","Self","NgForm","FormGroupDirective","ErrorStateMatcher","Inject","AutofillMonitor","Input","visibilityIcons","show","hide","NxPasswordToggleComponent","_changeDetectorRef","_currentIcon","_pressed","markForCheck","ngAfterViewInit","console","warn","toggleInputType","toggleIcon","_onKeydown","$event","keyCode","ENTER","SPACE","Component","template","[attr.tabindex]","[attr.aria-pressed]","role","(click)","(keydown)","changeDetection","ChangeDetectionStrategy","OnPush","ChangeDetectorRef","NxInputModule","NgModule","imports","CommonModule","NxFormfieldModule","NxIconModule","declarations","exports"],"mappings":"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","sourcesContent":["import { coerceBooleanProperty } from '@angular/cdk/coercion';\nimport { getSupportedInputTypes, Platform } from '@angular/cdk/platform';\nimport {\n  Inject,\n  Directive,\n  DoCheck,\n  ElementRef,\n  Input,\n  OnChanges,\n  OnDestroy,\n  Optional,\n  Self,\n  InjectionToken,\n  OnInit\n} from '@angular/core';\nimport { FormControl, FormGroupDirective, NgControl, NgForm } from '@angular/forms';\nimport { Subject } from 'rxjs';\nimport { AutofillMonitor } from '@angular/cdk/text-field';\n\nimport { NxFormfieldControl } from '@allianz/ngx-ndbx/formfield';\nimport { ErrorStateMatcher } from '@allianz/ngx-ndbx/utils';\n\nexport const NX_INPUT_VALUE_ACCESSOR = new InjectionToken<{value: any}>('NX_INPUT_VALUE_ACCESSOR');\n\nconst INVALID_TYPES = [\n  'button',\n  'checkbox',\n  'file',\n  'hidden',\n  'image',\n  'radio',\n  'range',\n  'reset',\n  'submit'\n];\n\nconst NEVER_EMPTY = [\n  'date',\n  'datetime',\n  'datetime-local',\n  'month',\n  'time',\n  'week'\n].filter(t => getSupportedInputTypes().has(t));\n\nlet nextUniqueId = 0;\n\n@Directive({\n  selector: 'input[nxInput], textarea[nxInput], select[nxInput]',\n  exportAs: 'nxInput',\n  host: {\n    '[class.c-input]': 'true',\n    '[attr.id]': 'id',\n    '[class.is-filled]': 'empty === false',\n    '[class.is-disabled]': 'disabled',\n    '[class.has-error]': 'errorState',\n    '[class.is-focused]': 'focused',\n    '[attr.disabled]': 'disabled || null',\n    '[attr.readonly]': 'readonly || null',\n    '[attr.required]': 'required || null',\n    '[attr.aria-label]': '_ariaLabel || null',\n    '[attr.aria-describedby]': '_ariaDescribedby || null',\n    '[attr.aria-invalid]': 'errorState',\n    '[attr.aria-required]': 'required.toString()',\n    '[attr.placeholder]': 'placeholder || null',\n    '(blur)': '_focusChanged(false)',\n    '(focus)': '_focusChanged(true)',\n    '(input)': '_onInput()',\n  },\n  providers: [{provide: NxFormfieldControl, useExisting: NxInputDirective}],\n})\nexport class NxInputDirective implements OnInit, DoCheck, OnChanges, OnDestroy, NxFormfieldControl<any> {\n\n  protected _type = 'text';\n\n  protected _id: string;\n  protected _uid = `nx-input-${nextUniqueId++}`;\n  protected _previousNativeValue: any;\n  protected _disabled = false;\n  protected _required = false;\n  private _readonly: boolean = false;\n  private _inputValueAccessor: {value: any};\n  public _ariaDescribedby: string;\n  private _placeholder: string;\n\n  @Input('nxAriaLabel') _ariaLabel: string;\n\n  /** @docs-private */\n  errorState: boolean = false;\n\n  /**\n   * Name of this control that is used inside the formfield component\n   * @docs-private\n   */\n  controlType: string = 'nx-input';\n\n  /**\n  * @docs-private\n  */\n  autofilled = false;\n\n  /** @docs-private */\n  stateChanges = new Subject<void>();\n\n  /** @docs-private */\n  focused = false;\n\n  /** The id of the input. */\n  @Input()\n  get id() {\n    return this._id;\n  }\n  set id(value: string) {\n    this._id = value || this._uid;\n  }\n\n  /** The input element's value. */\n  @Input()\n  get value(): any { return this._inputValueAccessor.value; }\n  set value(value: any) {\n    if (value !== this.value) {\n      this._inputValueAccessor.value = value;\n    }\n  }\n\n  /** Whether the element is readonly. */\n  @Input()\n  get readonly(): boolean { return this._readonly; }\n  set readonly(value: boolean) {\n    this._readonly = coerceBooleanProperty(value);\n    this.stateChanges.next();\n  }\n\n  /** Whether the input is disabled. */\n  @Input()\n  get disabled(): boolean {\n    if (this.ngControl && this.ngControl.disabled !== null) {\n      return this.ngControl.disabled;\n    }\n    return this._disabled;\n  }\n  set disabled(value: boolean) {\n    this._disabled = coerceBooleanProperty(value);\n\n    // Browsers may not fire the blur event if the input is disabled too quickly.\n    // Reset from here to ensure that the element doesn't become stuck.\n    if (this.focused) {\n      this.focused = false;\n      this.stateChanges.next();\n    }\n  }\n\n  /** Whether the element is required. */\n  @Input()\n  get required() { return this._required; }\n  set required(value: any) { this._required = coerceBooleanProperty(value); }\n\n  /** Sets the type of the input element (e.g. password, text etc). */\n  @Input()\n  get type() { return this._type; }\n  set type(value: string) {\n    this._type = value || 'text';\n    this._validateType();\n\n    // When using Angular inputs, developers are no longer able to set the properties on the native\n    // input element. To ensure that bindings for `type` work, we need to sync the setter\n    // with the native property. Textarea elements don't support the type property or attribute.\n    if (!this._isTextarea() && getSupportedInputTypes().has(this._type)) {\n      this._elementRef.nativeElement.type = this._type;\n    }\n  }\n\n  /**\n   * Sets the text for the input placeholder\n   */\n  @Input()\n  get placeholder() {\n    return this.empty ? this._placeholder : '';\n  }\n  set placeholder(value: string) {\n    this._placeholder = value;\n  }\n\n  constructor(\n    protected _elementRef: ElementRef,\n    protected _platform: Platform,\n    /** @docs-private */\n    @Optional() @Self() public ngControl: NgControl,\n    @Optional() private _parentForm: NgForm,\n    @Optional() private _parentFormGroup: FormGroupDirective,\n    private _errorStateMatcher: ErrorStateMatcher,\n    @Optional() @Self() @Inject(NX_INPUT_VALUE_ACCESSOR) inputValueAccessor: any,\n    private _autofillMonitor: AutofillMonitor,\n  ) {\n    this.id = this.id;\n\n    // This will enable other directives to plugin itself as the value accessor\n    // by using the NX_INPUT_VALUE_ACCESSOR Token. Default is the given input field.\n    // TODO eliminate injected dateValueAccessor once we have intra-package support in ng-packagr\n    // See the datefield for details.\n    this._inputValueAccessor = inputValueAccessor || this._elementRef.nativeElement;\n    this._previousNativeValue = this.value;\n\n    if (this._elementRef.nativeElement.nodeName.toLowerCase() === 'textarea') {\n      this.controlType = 'textarea';\n    }\n  }\n\n  ngOnInit() {\n    if (this._platform.isBrowser) {\n      this._autofillMonitor.monitor(this._elementRef.nativeElement).subscribe(event => {\n        this.autofilled = event.isAutofilled;\n        this.stateChanges.next();\n      });\n    }\n  }\n\n  /** @docs-private */\n  get elementRef(): ElementRef {\n    return this._elementRef;\n  }\n\n  _onInput() {\n    // force to to run change detection so we know about changes in the native form input\n  }\n\n  _focusChanged(isFocused: boolean) {\n    if (isFocused !== this.focused && !this.readonly) {\n      this.focused = isFocused;\n      this.stateChanges.next();\n    }\n  }\n\n  ngOnChanges() {\n    this.stateChanges.next();\n  }\n\n  ngOnDestroy() {\n    this.stateChanges.complete();\n\n    if (this._platform.isBrowser) {\n      this._autofillMonitor.stopMonitoring(this._elementRef.nativeElement);\n    }\n  }\n\n  ngDoCheck() {\n    if (this.ngControl) {\n      // We need to re-evaluate this on every change detection cycle, because there are some\n      // error triggers that we can't subscribe to (e.g. parent form submissions). This means\n      // that whatever logic is in here has to be super lean or we risk destroying the performance.\n      this.updateErrorState();\n    }\n\n    // We need to dirty-check the native element's value, because there are some cases where\n    // we won't be notified when it changes (e.g. the consumer isn't using forms or they're\n    // updating the value using `emitEvent: false`).\n    this._dirtyCheckNativeValue();\n  }\n\n  /** @docs-private */\n  updateErrorState() {\n    const oldState = this.errorState;\n    const parent = this._parentFormGroup || this._parentForm;\n    const control = this.ngControl ? this.ngControl.control as FormControl : null;\n    const newState = this._errorStateMatcher.isErrorState(control, parent);\n\n    if (newState !== oldState) {\n      this.errorState = newState;\n      this.stateChanges.next();\n    }\n  }\n\n  /**\n   * Set a list of ids that is currently describing this input\n   * (if you have hints and errors for example).\n   */\n  setDescribedByIds(ids: string[]) {\n    this._ariaDescribedby = ids.join(' ');\n  }\n\n  // allow to set a arial label value in case there\n  // is not possibility to display a proper label\n  /**\n   * Method to set the aria label.\n   * This is required if you use the input outside of a formfield\n   * where you don't have a label connected.\n   */\n  setAriaLabel(value: string) {\n    this._ariaLabel = value;\n  }\n\n  protected _isBadInput() {\n    // The `validity` property won't be present on platform-server.\n    const validity = (this._elementRef.nativeElement as HTMLInputElement).validity;\n    return validity && validity.badInput;\n  }\n\n  /** @docs-private */\n  get empty(): boolean {\n    return !this._isNeverEmpty() && !this._elementRef.nativeElement.value && !this._isBadInput() && !this.autofilled;\n  }\n\n  protected _isNeverEmpty() {\n    return NEVER_EMPTY.indexOf(this._type) > -1;\n  }\n\n  protected _isTextarea() {\n    const nativeElement = this._elementRef.nativeElement;\n    return nativeElement.nodeName ? nativeElement.nodeName.toLowerCase() === 'textarea' : false;\n  }\n\n  protected _validateType() {\n    if (INVALID_TYPES.indexOf(this._type) > -1) {\n      throw new Error(`Input of type '${this._type}' is not supported`);\n    }\n  }\n\n  /** @docs-private */\n  get shouldLabelFloat(): boolean {\n    return this.focused || !this.empty || (this.placeholder && this.placeholder.length > 0);\n  }\n\n  protected _dirtyCheckNativeValue() {\n    const newValue = this.value;\n\n    if (this._previousNativeValue !== newValue) {\n      this._previousNativeValue = newValue;\n      this.stateChanges.next();\n    }\n  }\n}\n","import { Input, Component, AfterViewInit, ChangeDetectorRef, ChangeDetectionStrategy } from '@angular/core';\nimport { ENTER, SPACE } from '@angular/cdk/keycodes';\n\nconst visibilityIcons = {\n  show: 'password-show-o',\n  hide: 'password-hide-o'\n};\n\n@Component({\n  selector: 'nx-password-toggle',\n  template:\n    `<nx-icon\n      aria-hidden=\"true\"\n      [name]=\"_currentIcon\">\n    </nx-icon>`,\n  styleUrls: ['./password-toggle.component.scss'],\n  host: {\n    '[attr.aria-label]': 'ariaLabel',\n    '[attr.tabindex]': 'tabindex',\n    '[attr.aria-pressed]': '_pressed',\n    'role': 'button',\n    '(click)': 'toggleInputType()',\n    '(keydown)': '_onKeydown($event)'\n  },\n  changeDetection: ChangeDetectionStrategy.OnPush\n})\nexport class NxPasswordToggleComponent implements AfterViewInit {\n\n  /** Input element using the toggle functionality. */\n  @Input() control: HTMLInputElement;\n\n  /**@docs-private */\n  _currentIcon: string = visibilityIcons['show'];\n  /**@docs-private */\n  _pressed: boolean = false;\n  private _ariaLabel: string = 'Show password';\n\n  /** Sets the aria-label needed for accessibility.\n   * Notice that this `aria-label` should describe the initial action according to the status of the visibility.\n   * E.g if you have an `input[type=password]` at the beginning then the\n   * password will be hidden and the correct aria-label would be 'Show password.'\n   */\n  @Input()\n  set ariaLabel(value: string) {\n    if (value !== this._ariaLabel) {\n      this._ariaLabel = value;\n      this._changeDetectorRef.markForCheck();\n    }\n  }\n  get ariaLabel(): string {\n    return this._ariaLabel;\n  }\n\n  constructor (private _changeDetectorRef: ChangeDetectorRef) { }\n\n  ngAfterViewInit() {\n    if (!this.control) {\n      console.warn('You need to pass an input as a control to the password toggle.');\n    } else {\n      // show the right icon according to the initial type of the input\n      this._currentIcon = this.control.type === 'password' ? visibilityIcons['show'] : visibilityIcons['hide'];\n    }\n  }\n\n  /** Toggles the type of the input. */\n  toggleInputType(): void {\n    if (this.control) {\n      this.control.type = this.control.type === 'password' ? 'text' : 'password';\n      this._pressed = !this._pressed;\n      this.toggleIcon();\n      this._changeDetectorRef.markForCheck();\n    }\n  }\n\n  /**@docs-private */\n  toggleIcon(): void {\n    this._currentIcon = this._currentIcon === visibilityIcons['show'] ? visibilityIcons['hide'] : visibilityIcons['show'];\n  }\n\n  /**@docs-private */\n  _onKeydown($event) {\n    if ($event && ($event.keyCode === ENTER || $event.keyCode === SPACE)) {\n      this.toggleInputType();\n    }\n  }\n\n  /**@docs-private */\n  get tabindex(): number {\n    if (this.control) {\n      return this.control.disabled ? -1 : 0;\n    }\n    return null;\n  }\n }\n","import { CommonModule } from '@angular/common';\nimport { NgModule } from '@angular/core';\n\nimport {NxFormfieldModule} from '@allianz/ngx-ndbx/formfield';\nimport { NxInputDirective } from './input.directive';\nimport { NxPasswordToggleComponent } from './password-toggle.component';\nimport { NxIconModule } from '@allianz/ngx-ndbx/icon';\n\n@NgModule({\n  imports: [\n    CommonModule,\n    NxFormfieldModule,\n    NxIconModule\n  ],\n  declarations: [\n    NxInputDirective,\n    NxPasswordToggleComponent\n  ],\n  exports: [\n    NxFormfieldModule,\n    NxInputDirective,\n    NxPasswordToggleComponent\n  ]\n})\nexport class NxInputModule { }\n"]}