(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@angular/common'), require('@angular/core'), require('@allianz/ngx-ndbx/formfield'), require('@angular/forms'), require('@angular/cdk/coercion'), require('@allianz/ngx-ndbx/input'), require('@angular/cdk/keycodes'), require('rxjs'), require('iban')) :
    typeof define === 'function' && define.amd ? define('@allianz/ngx-ndbx/mask', ['exports', '@angular/common', '@angular/core', '@allianz/ngx-ndbx/formfield', '@angular/forms', '@angular/cdk/coercion', '@allianz/ngx-ndbx/input', '@angular/cdk/keycodes', 'rxjs', 'iban'], factory) :
    (global = global || self, factory((global.allianz = global.allianz || {}, global.allianz['ngx-ndbx'] = global.allianz['ngx-ndbx'] || {}, global.allianz['ngx-ndbx'].mask = {}), global.ng.common, global.ng.core, global.allianz['ngx-ndbx'].formfield, global.ng.forms, global.ng.cdk.coercion, global.allianz['ngx-ndbx'].input, global.ng.cdk.keycodes, global.rxjs, global.iban));
}(this, (function (exports, common, core, formfield, forms, coercion, input, keycodes, rxjs, iban) { 'use strict';

    /**
     * @fileoverview added by tsickle
     * Generated from: mask.directive.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /** @type {?} */
    var NX_MASK_VALUE_ACCESSOR = {
        provide: forms.NG_VALUE_ACCESSOR,
        useExisting: core.forwardRef((/**
         * @return {?}
         */
        function () { return NxMaskDirective; })),
        multi: true
    };
    /** @type {?} */
    var NX_MASK_VALIDATORS = {
        provide: forms.NG_VALIDATORS,
        useExisting: core.forwardRef((/**
         * @return {?}
         */
        function () { return NxMaskDirective; })),
        multi: true
    };
    /**
     * Interface for saving the cursor information.
     * @record
     */
    function CursorInfo() { }
    if (false) {
        /** @type {?|undefined} */
        CursorInfo.prototype.selectionStart;
        /** @type {?|undefined} */
        CursorInfo.prototype.selectionEnd;
        /** @type {?|undefined} */
        CursorInfo.prototype.position;
    }
    var NxMaskDirective = /** @class */ (function () {
        function NxMaskDirective(_elementRef) {
            this._elementRef = _elementRef;
            this._separators = ['/', '(', ')', '.', ':', '-', ' ', '+', ','];
            this._dropSpecialCharacters = false;
            this._validateMask = true;
            /**
             * Emits the unmasked value before the value changes.
             */
            this.cvaModelChange = new rxjs.Subject();
            this._onChangeCallback = (/**
             * @param {?} _
             * @return {?}
             */
            function (_) { });
            this._onTouchedCallback = (/**
             * @return {?}
             */
            function () { });
            this._validatorOnChange = (/**
             * @return {?}
             */
            function () { });
            this._afterInputHook = (/**
             * @param {?} event
             * @return {?}
             */
            function (event) { });
            this._beforePasteHook = (/**
             * @param {?} event
             * @return {?}
             */
            function (event) { });
        }
        /**
         * @private
         * @return {?}
         */
        NxMaskDirective.prototype._callOnChangeCallback = /**
         * @private
         * @return {?}
         */
        function () {
            if (!this.dropSpecialCharacters) {
                this._onChangeCallback(this._elementRef.nativeElement.value);
            }
            else {
                this._onChangeCallback(this.getUnmaskedValue());
            }
        };
        /**
         * Registers a function to be executed after the onInput handler.
         * The registered hook receives a `KeyboardEvent` from the onInput event handler as a parameter.
         *
         * **Note:** If you register a `afterInputHook`, you may also register a `beforePasteHook`
         * to perform similar changes for pasting.
         */
        /**
         * Registers a function to be executed after the onInput handler.
         * The registered hook receives a `KeyboardEvent` from the onInput event handler as a parameter.
         *
         * **Note:** If you register a `afterInputHook`, you may also register a `beforePasteHook`
         * to perform similar changes for pasting.
         * @param {?} afterInput
         * @return {?}
         */
        NxMaskDirective.prototype.registerAfterInputHook = /**
         * Registers a function to be executed after the onInput handler.
         * The registered hook receives a `KeyboardEvent` from the onInput event handler as a parameter.
         *
         * **Note:** If you register a `afterInputHook`, you may also register a `beforePasteHook`
         * to perform similar changes for pasting.
         * @param {?} afterInput
         * @return {?}
         */
        function (afterInput) {
            this._afterInputHook = afterInput;
        };
        /**
         * Registers a function to be executed before the onPaste handler.
         * The registered hook receives a `ClipboardEvent` from the onPaste event handler as a parameter.
         */
        /**
         * Registers a function to be executed before the onPaste handler.
         * The registered hook receives a `ClipboardEvent` from the onPaste event handler as a parameter.
         * @param {?} beforePaste
         * @return {?}
         */
        NxMaskDirective.prototype.registerBeforePasteHook = /**
         * Registers a function to be executed before the onPaste handler.
         * The registered hook receives a `ClipboardEvent` from the onPaste event handler as a parameter.
         * @param {?} beforePaste
         * @return {?}
         */
        function (beforePaste) {
            this._beforePasteHook = beforePaste;
        };
        Object.defineProperty(NxMaskDirective.prototype, "mask", {
            get: /**
             * @return {?}
             */
            function () {
                return this._mask;
            },
            /** Sets the mask. */
            set: /**
             * Sets the mask.
             * @param {?} value
             * @return {?}
             */
            function (value) {
                if (!value) {
                    value = '';
                }
                if (value !== this._mask) {
                    this._mask = value;
                    this.updateValue(this.getMaskedString(this._elementRef.nativeElement.value));
                    this._callOnChangeCallback();
                    this._validatorOnChange();
                }
            },
            enumerable: true,
            configurable: true
        });
        /**
         * Sets the mask (for programmatical use).
         *
         * No `_onChangeCallback()` will be called!
         */
        /**
         * Sets the mask (for programmatical use).
         *
         * No `_onChangeCallback()` will be called!
         * @param {?} value
         * @return {?}
         */
        NxMaskDirective.prototype.setMask = /**
         * Sets the mask (for programmatical use).
         *
         * No `_onChangeCallback()` will be called!
         * @param {?} value
         * @return {?}
         */
        function (value) {
            if (!value) {
                value = '';
            }
            if (value !== this._mask) {
                this._mask = value;
                this.updateValue(this.getMaskedString(this._elementRef.nativeElement.value));
                this._validatorOnChange();
            }
        };
        Object.defineProperty(NxMaskDirective.prototype, "convertTo", {
            get: /**
             * @return {?}
             */
            function () {
                return this._convertTo;
            },
            /** Sets the case sensitivity of the mask. */
            set: /**
             * Sets the case sensitivity of the mask.
             * @param {?} value
             * @return {?}
             */
            function (value) {
                this._convertTo = value;
                this.updateValue(this.getMaskedString(this._elementRef.nativeElement.value));
                this._callOnChangeCallback();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NxMaskDirective.prototype, "separators", {
            get: /**
             * @return {?}
             */
            function () {
                return this._separators;
            },
            /**
             * Sets the keys that are recognized as separators.
             * Default separators: / ( ) . : - + , and space.
             */
            set: /**
             * Sets the keys that are recognized as separators.
             * Default separators: / ( ) . : - + , and space.
             * @param {?} values
             * @return {?}
             */
            function (values) {
                this._separators = values;
                this.updateValue(this.getMaskedString(this._elementRef.nativeElement.value));
                this._validatorOnChange();
                this._callOnChangeCallback();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NxMaskDirective.prototype, "dropSpecialCharacters", {
            get: /**
             * @return {?}
             */
            function () {
                return this._dropSpecialCharacters;
            },
            /** Whether the separators should be dropped in the control value accessor. */
            set: /**
             * Whether the separators should be dropped in the control value accessor.
             * @param {?} value
             * @return {?}
             */
            function (value) {
                /** @type {?} */
                var newValue = coercion.coerceBooleanProperty(value);
                if (newValue !== this._dropSpecialCharacters) {
                    this._dropSpecialCharacters = newValue;
                    this.updateValue(this.getMaskedString(this._elementRef.nativeElement.value));
                    this._callOnChangeCallback();
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NxMaskDirective.prototype, "validateMask", {
            get: /**
             * @return {?}
             */
            function () {
                return this._validateMask;
            },
            /** Whether the mask validation should be applied on the input. Default: true. */
            set: /**
             * Whether the mask validation should be applied on the input. Default: true.
             * @param {?} value
             * @return {?}
             */
            function (value) {
                /** @type {?} */
                var newValue = coercion.coerceBooleanProperty(value);
                if (newValue !== this._validateMask) {
                    this._validateMask = newValue;
                    this._validatorOnChange();
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NxMaskDirective.prototype, "elementRefValue", {
            /** @docs-private */
            get: /**
             * \@docs-private
             * @return {?}
             */
            function () {
                return this._elementRef.nativeElement.value;
            },
            enumerable: true,
            configurable: true
        });
        /** Returns the unmasked value. */
        /**
         * Returns the unmasked value.
         * @return {?}
         */
        NxMaskDirective.prototype.getUnmaskedValue = /**
         * Returns the unmasked value.
         * @return {?}
         */
        function () {
            /** @type {?} */
            var unmaskedValue = this.separators.reduce((/**
             * @param {?} unmasked
             * @param {?} separator
             * @return {?}
             */
            function (unmasked, separator) {
                return unmasked.split(separator).join('');
            }), this._elementRef.nativeElement.value);
            return unmaskedValue;
        };
        /**
         * this._cursor can be set to a new value in this function;
         * in _onInputChange() it is then used to set the cursor position.
         */
        /**
         * this._cursor can be set to a new value in this function;
         * in _onInputChange() it is then used to set the cursor position.
         * @param {?} event
         * @return {?}
         */
        NxMaskDirective.prototype._onKeydown = /**
         * this._cursor can be set to a new value in this function;
         * in _onInputChange() it is then used to set the cursor position.
         * @param {?} event
         * @return {?}
         */
        function (event) {
            /** @type {?} */
            var keyCode = event.keyCode;
            /** @type {?} */
            var input = (/** @type {?} */ (event.target));
            /** @type {?} */
            var currentValue = this._elementRef.nativeElement.value;
            if (keyCode === keycodes.BACKSPACE || keyCode === keycodes.DELETE) {
                // if backspace pressed, cursor has to move one character to start
                /** @type {?} */
                var backspaceShift = keyCode === keycodes.BACKSPACE ? 1 : 0;
                /** @type {?} */
                var lastCharacter = currentValue.substring(input.selectionStart - backspaceShift, input.selectionEnd - backspaceShift + 1);
                /** @type {?} */
                var selectionAtLastCharacter = (input.selectionStart === currentValue.length - 1 + backspaceShift);
                if (input.selectionStart !== input.selectionEnd) {
                    /** @type {?} */
                    var newPosition = input.selectionStart;
                    // jump behind separators, but do not shift after the next character (=> don't use _calculateCursorShift())
                    while (this.isSeparator(this.mask[newPosition])) {
                        newPosition++;
                    }
                    this._cursor = { position: newPosition };
                }
                else if (selectionAtLastCharacter) {
                    // if last character is deleted: only delete last character, do not trigger input event again
                    // (here the separator would be added again)
                    this.updateValue(currentValue.substring(0, currentValue.length - 1));
                    this._callOnChangeCallback();
                    event.preventDefault();
                }
                else if (this.isSeparator(lastCharacter)) {
                    // do not delete a separator, only set cursor position
                    input.setSelectionRange(input.selectionStart - backspaceShift, input.selectionEnd - backspaceShift);
                    event.preventDefault();
                }
                else {
                    // for any other character: decrease cursor position by one (backspaceShift).
                    // the input is modified and will be validated in _onInputChange().
                    this._cursor = { position: input.selectionStart - backspaceShift };
                }
            }
            else {
                this._cursor = { selectionStart: input.selectionStart, selectionEnd: input.selectionEnd };
            }
        };
        /**
         * Returns the cursor position after a letter is entered at `selectionStart` position in the mask.
         * There are two cases to consider ('|' => cursor position where the character is entered, mask: 00:00:00):
         * - before the separators there is space for entering the letter: '12:3|4:5' => '12:30:|45'
         * - the letter has to be shifted and is entered after the separators: '12:34|:5' => '12:34:0|5'
         */
        /**
         * Returns the cursor position after a letter is entered at `selectionStart` position in the mask.
         * There are two cases to consider ('|' => cursor position where the character is entered, mask: 00:00:00):
         * - before the separators there is space for entering the letter: '12:3|4:5' => '12:30:|45'
         * - the letter has to be shifted and is entered after the separators: '12:34|:5' => '12:34:0|5'
         * @private
         * @param {?} position
         * @return {?}
         */
        NxMaskDirective.prototype._calculateCursorShift = /**
         * Returns the cursor position after a letter is entered at `selectionStart` position in the mask.
         * There are two cases to consider ('|' => cursor position where the character is entered, mask: 00:00:00):
         * - before the separators there is space for entering the letter: '12:3|4:5' => '12:30:|45'
         * - the letter has to be shifted and is entered after the separators: '12:34|:5' => '12:34:0|5'
         * @private
         * @param {?} position
         * @return {?}
         */
        function (position) {
            /** @type {?} */
            var shift = 0;
            // tracks if the entered letter was already placed in the current mask
            // and therefor was considered in the cursor calculation.
            /** @type {?} */
            var characterWasEntered = false;
            if (!this.isSeparator(this.mask[position + shift])) {
                shift++;
                characterWasEntered = true;
            }
            while (this.isSeparator(this.mask[position + shift])) {
                shift++;
            }
            if (!characterWasEntered) {
                shift++;
            }
            return shift;
        };
        /**
         * @private
         * @param {?} value
         * @param {?} maskedValue
         * @return {?}
         */
        NxMaskDirective.prototype._isStringAllowed = /**
         * @private
         * @param {?} value
         * @param {?} maskedValue
         * @return {?}
         */
        function (value, maskedValue) {
            if ((maskedValue === '0' && /^[0-9]{1}$/.test(value))
                || (maskedValue === 'A' && /^[a-zA-Z0-9]{1}$/.test(value))
                || (maskedValue === 'S' && /^[a-zA-Z]{1}$/.test(value))) {
                return true;
            }
            return false;
        };
        /**
         * Handles the onInput event.
         * `_beforeInputHook()` is called before the actual execution.
         *
         */
        /**
         * Handles the onInput event.
         * `_beforeInputHook()` is called before the actual execution.
         *
         * @param {?} event
         * @return {?}
         */
        NxMaskDirective.prototype._onInputChange = /**
         * Handles the onInput event.
         * `_beforeInputHook()` is called before the actual execution.
         *
         * @param {?} event
         * @return {?}
         */
        function (event) {
            // _inputValue is updated in updateValue(), so I need to pick it up here to compare it to a new value
            /** @type {?} */
            var oldVal = this._inputValue;
            /** @type {?} */
            var input = (/** @type {?} */ (event.target));
            /** @type {?} */
            var newVal = this.getMaskedString(input.value);
            // if _pastedData was set in _onPaste(), use this value
            if (this._pastedData) {
                this.updateValue(this._pastedData);
                input.setSelectionRange(this._cursor.position, this._cursor.position);
                this._pastedData = null;
                this._cursor = null;
                this._callOnChangeCallback();
                return;
            }
            // do nothing if mask is already filled up
            if (oldVal.length === this._mask.length
                && newVal.length === this._mask.length
                && oldVal !== newVal
                && (this._cursor
                    && this._cursor.selectionStart !== undefined
                    && this._cursor.selectionStart === this._cursor.selectionEnd)) {
                this._elementRef.nativeElement.value = this.getMaskedString(oldVal);
                input.setSelectionRange(this._cursor.selectionStart, this._cursor.selectionEnd);
                this._cursor = null;
                return;
            }
            this.updateValue(newVal);
            // set new cursor position
            if (this._cursor && this._cursor.position !== undefined) {
                input.setSelectionRange(this._cursor.position, this._cursor.position);
                this._cursor = null;
            }
            else if (this._cursor && this._cursor.selectionStart !== undefined) {
                // only one character can be entered (except pasting, this is calculated in _onPaste())
                if (oldVal !== input.value) {
                    /** @type {?} */
                    var newPosition = this._cursor.selectionStart + this._calculateCursorShift(this._cursor.selectionStart);
                    input.setSelectionRange(newPosition, newPosition);
                    this._cursor = null;
                }
                else {
                    // we always have to set the cursor position here even if nothing changed
                    // because otherwise the cursor would jump to the end of the input.
                    // if the cursor is placed in front of a separator and the user types a non-allowed character,
                    // the cursor is supposed to jump over the separator.
                    /** @type {?} */
                    var currentPosition = this._cursor.selectionStart;
                    while (this.isSeparator(this.mask[currentPosition])) {
                        currentPosition++;
                    }
                    input.setSelectionRange(currentPosition, currentPosition);
                    this._cursor = null;
                }
            }
            this._afterInputHook(event);
            this._callOnChangeCallback();
        };
        /**
         * this._cursor and this._pastedData can be set to a new value in this function;
         * _cursor is used to set the cursor position after checking the masked input in _onInputChange().
         * _pastedData carries the valid part of the pasted value to _inInputChange();
         *
         *`_beforePasteHook()` is called before the actual execution.
         */
        /**
         * this._cursor and this._pastedData can be set to a new value in this function;
         * _cursor is used to set the cursor position after checking the masked input in _onInputChange().
         * _pastedData carries the valid part of the pasted value to _inInputChange();
         *
         * `_beforePasteHook()` is called before the actual execution.
         * @param {?} event
         * @return {?}
         */
        NxMaskDirective.prototype._onPaste = /**
         * this._cursor and this._pastedData can be set to a new value in this function;
         * _cursor is used to set the cursor position after checking the masked input in _onInputChange().
         * _pastedData carries the valid part of the pasted value to _inInputChange();
         *
         * `_beforePasteHook()` is called before the actual execution.
         * @param {?} event
         * @return {?}
         */
        function (event) {
            /** @type {?} */
            var input = (/** @type {?} */ (event.target));
            /** @type {?} */
            var pastedData = (event.clipboardData || ((/** @type {?} */ (window))).clipboardData).getData('text');
            // saving these three values as if something is changed in the _beforePasteHook()
            // which causes the input value to be updated, this values will get lost.
            /** @type {?} */
            var selectionStart = input.selectionStart;
            /** @type {?} */
            var selectionEnd = input.selectionEnd;
            /** @type {?} */
            var oldValue = input.value;
            this._beforePasteHook(event);
            /** @type {?} */
            var maskedString = this.getMaskedString(pastedData, selectionStart);
            // if mask is already filled up (and no characters are selected with the cursor), do nothing
            if (input.value.length === this._mask.length
                && maskedString.length > 0
                && selectionStart === selectionEnd) {
                input.setSelectionRange(selectionStart, selectionEnd);
                this._cursor = null; // was set in _onKeydown(), but will not be used in this case; so reset it
                event.preventDefault();
                return;
            }
            // if length of newValue is >= mask: allow only to enter characters from a pasted value until mask is filled up
            // example: 12:|34: ("|" cursor position, mask: 00:00:00) => when pasting '567', only '56' fits in until input is filled up => 12:56:|34
            // get the pasted unmasked value from the pasted string (to cut all the invalid characters and separators)
            /** @type {?} */
            var pastedUnmaskedValue = this.separators.reduce((/**
             * @param {?} unmasked
             * @param {?} separator
             * @return {?}
             */
            function (unmasked, separator) { return unmasked.split(separator).join(''); }), maskedString);
            /** @type {?} */
            var newValue = this.getMaskedString(oldValue.substring(0, selectionStart)
                + pastedUnmaskedValue
                + oldValue.substring(selectionEnd, oldValue.length));
            if (newValue.length >= this._mask.length) {
                /** @type {?} */
                var newPosition = selectionStart;
                /** @type {?} */
                var i = 1;
                do {
                    newValue = this.getMaskedString(oldValue.substring(0, selectionStart)
                        + pastedUnmaskedValue.substring(0, i)
                        + oldValue.substring(selectionEnd, oldValue.length));
                    newPosition += this._calculateCursorShift(newPosition);
                    i++;
                } while (newValue.length < this._mask.length);
                // save value for using it in _onInputChange()
                this._pastedData = newValue;
                this._cursor = {
                    position: newPosition
                };
                return;
            }
            // if pasting is fine: save the cursor position for using them in _onInputChange()
            this._cursor = {
                position: selectionStart + maskedString.length
            };
        };
        /**
         * @private
         * @param {?} value
         * @return {?}
         */
        NxMaskDirective.prototype.updateValue = /**
         * @private
         * @param {?} value
         * @return {?}
         */
        function (value) {
            // Write UpperCase
            if (this._convertTo === 'upper') {
                value = value.toUpperCase();
            }
            else if (this._convertTo === 'lower') {
                value = value.toLowerCase();
            }
            this._elementRef.nativeElement.value = value;
            // _inputValue is needed for calculating the cursor shift in onInput()
            this._inputValue = value;
        };
        /** @docs-private */
        /**
         * \@docs-private
         * @param {?} inputValue
         * @param {?=} maskStartIndex
         * @return {?}
         */
        NxMaskDirective.prototype.getMaskedString = /**
         * \@docs-private
         * @param {?} inputValue
         * @param {?=} maskStartIndex
         * @return {?}
         */
        function (inputValue, maskStartIndex) {
            if (maskStartIndex === void 0) { maskStartIndex = 0; }
            /** @type {?} */
            var formattedValue = '';
            /** @type {?} */
            var maskIndex = maskStartIndex;
            /** @type {?} */
            var inputIndex = 0;
            // insert if next in mask is separator
            while (this.isSeparator(this.mask[maskIndex])) {
                formattedValue += this.mask[maskIndex];
                maskIndex++;
            }
            while (inputIndex < inputValue.length) {
                // test if letters are valid
                if (this._isStringAllowed(inputValue[inputIndex], (/** @type {?} */ (this.mask[maskIndex])))) {
                    formattedValue += inputValue[inputIndex];
                    inputIndex++;
                    maskIndex++;
                }
                else {
                    inputIndex++;
                }
                // insert if next in mask is separator
                while (this.isSeparator(this.mask[maskIndex])) {
                    formattedValue += this.mask[maskIndex];
                    maskIndex++;
                }
            }
            return formattedValue;
        };
        /**
         * @private
         * @param {?} value
         * @return {?}
         */
        NxMaskDirective.prototype.isSeparator = /**
         * @private
         * @param {?} value
         * @return {?}
         */
        function (value) {
            return (this._separators.indexOf(value) !== -1);
        };
        // control value accessor
        // control value accessor
        /**
         * @param {?} value
         * @return {?}
         */
        NxMaskDirective.prototype.writeValue = 
        // control value accessor
        /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            if (!value) {
                value = '';
            }
            this.cvaModelChange.next(value);
            this.updateValue(this.getMaskedString(value));
        };
        /**
         * @param {?} onChange
         * @return {?}
         */
        NxMaskDirective.prototype.registerOnChange = /**
         * @param {?} onChange
         * @return {?}
         */
        function (onChange) {
            this._onChangeCallback = onChange;
        };
        /**
         * @param {?} onTouched
         * @return {?}
         */
        NxMaskDirective.prototype.registerOnTouched = /**
         * @param {?} onTouched
         * @return {?}
         */
        function (onTouched) {
            this._onTouchedCallback = onTouched;
        };
        /** @docs-private */
        /**
         * \@docs-private
         * @param {?} fn
         * @return {?}
         */
        NxMaskDirective.prototype.registerOnValidatorChange = /**
         * \@docs-private
         * @param {?} fn
         * @return {?}
         */
        function (fn) {
            this._validatorOnChange = fn;
        };
        /**
         * @return {?}
         */
        NxMaskDirective.prototype._validateFn = /**
         * @return {?}
         */
        function () {
            /** @type {?} */
            var inputLength = this._elementRef.nativeElement.value.length;
            /** @type {?} */
            var maskLength = this._mask.length;
            if (inputLength !== maskLength) {
                return { nxMaskLengthError: { 'length': maskLength, 'actual': inputLength } };
            }
            return null;
        };
        /** @docs-private */
        /**
         * \@docs-private
         * @return {?}
         */
        NxMaskDirective.prototype.validate = /**
         * \@docs-private
         * @return {?}
         */
        function () {
            return this.validateMask ? this._validateFn() : null;
        };
        /**
         * @return {?}
         */
        NxMaskDirective.prototype._touch = /**
         * @return {?}
         */
        function () {
            this._onTouchedCallback();
        };
        NxMaskDirective.decorators = [
            { type: core.Directive, args: [{
                        selector: 'input[nxMask]',
                        host: {
                            '(input)': '_onInputChange($event)',
                            '(keydown)': '_onKeydown($event)',
                            '(paste)': '_onPaste($event)',
                            '(blur)': '_touch()'
                        },
                        exportAs: 'nxMaskDirective',
                        providers: [
                            NX_MASK_VALUE_ACCESSOR,
                            { provide: input.NX_INPUT_VALUE_ACCESSOR, useExisting: NxMaskDirective },
                            NX_MASK_VALIDATORS
                        ]
                    },] }
        ];
        /** @nocollapse */
        NxMaskDirective.ctorParameters = function () { return [
            { type: core.ElementRef }
        ]; };
        NxMaskDirective.propDecorators = {
            mask: [{ type: core.Input, args: ['nxMask',] }],
            convertTo: [{ type: core.Input, args: ['nxConvertTo',] }],
            separators: [{ type: core.Input }],
            dropSpecialCharacters: [{ type: core.Input }],
            validateMask: [{ type: core.Input }]
        };
        return NxMaskDirective;
    }());
    if (false) {
        /**
         * @type {?}
         * @private
         */
        NxMaskDirective.prototype._mask;
        /**
         * @type {?}
         * @private
         */
        NxMaskDirective.prototype._separators;
        /**
         * @type {?}
         * @private
         */
        NxMaskDirective.prototype._dropSpecialCharacters;
        /**
         * @type {?}
         * @private
         */
        NxMaskDirective.prototype._validateMask;
        /**
         * @type {?}
         * @private
         */
        NxMaskDirective.prototype._convertTo;
        /**
         * _cursor is a helper for saving a position or a selectionRange (selectionStart + selectionEnd)
         * and then apply it later on (in _onInputChange()).
         *
         * _cursor.position is used for saving a position that is then applied without any changes.
         * if the position is saved, selectionStart and selectionEnd will be ignored in _onInputChange().
         * _cursor.selectionStart and selectionEnd is used for saving the current cursor position,
         * and a new cursor position is then calculated with this data.
         * @type {?}
         * @private
         */
        NxMaskDirective.prototype._cursor;
        /**
         * helper variable for saving the current value of the input element to compare it then with a new value.
         * @type {?}
         * @private
         */
        NxMaskDirective.prototype._inputValue;
        /**
         * helper variable for saving the masked string of a pasted value and then applying it in _onInputChange().
         * @type {?}
         * @private
         */
        NxMaskDirective.prototype._pastedData;
        /**
         * Emits the unmasked value before the value changes.
         * @type {?}
         */
        NxMaskDirective.prototype.cvaModelChange;
        /**
         * @type {?}
         * @private
         */
        NxMaskDirective.prototype._onChangeCallback;
        /**
         * @type {?}
         * @private
         */
        NxMaskDirective.prototype._onTouchedCallback;
        /**
         * @type {?}
         * @private
         */
        NxMaskDirective.prototype._validatorOnChange;
        /**
         * @type {?}
         * @private
         */
        NxMaskDirective.prototype._afterInputHook;
        /**
         * @type {?}
         * @private
         */
        NxMaskDirective.prototype._beforePasteHook;
        /**
         * @type {?}
         * @private
         */
        NxMaskDirective.prototype._elementRef;
    }

    /**
     * @fileoverview added by tsickle
     * Generated from: iban-mask.directive.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /** @type {?} */
    var NX_IBAN_MASK_VALIDATORS = {
        provide: forms.NG_VALIDATORS,
        useExisting: core.forwardRef((/**
         * @return {?}
         */
        function () { return NxIbanMaskDirective; })),
        multi: true
    };
    /**
     * To use the `NxIbanMaskDirective`, you have to install the **peer dependency** `iban.js`.
     */
    var NxIbanMaskDirective = /** @class */ (function () {
        function NxIbanMaskDirective(_elementRef, maskDirective) {
            var _this = this;
            this._elementRef = _elementRef;
            this.maskDirective = maskDirective;
            this._afterInputHook = (/**
             * @param {?} event
             * @return {?}
             */
            function (event) {
                /** @type {?} */
                var input = (/** @type {?} */ (event.target));
                _this._setCountryCode(input.value.substr(0, 2));
            });
            this._beforePasteHook = (/**
             * @param {?} event
             * @return {?}
             */
            function (event) {
                // change the country code here if necessary
                /** @type {?} */
                var input = (/** @type {?} */ (event.target));
                /** @type {?} */
                var pastedData = (event.clipboardData || ((/** @type {?} */ (window))).clipboardData).getData('text');
                /** @type {?} */
                var enteredCountryCode = (_this.maskDirective.elementRefValue.substr(0, input.selectionStart)
                    + _this.maskDirective.getMaskedString(pastedData, input.selectionStart)).substr(0, 2);
                _this._setCountryCode(enteredCountryCode);
            });
            this.maskDirective.registerAfterInputHook(this._afterInputHook);
            this.maskDirective.registerBeforePasteHook(this._beforePasteHook);
            this.maskDirective.cvaModelChange.subscribe((/**
             * @param {?} value
             * @return {?}
             */
            function (value) {
                /** @type {?} */
                var enteredCountryCode = _this.maskDirective.getMaskedString(value).substr(0, 2);
                _this._setCountryCode(enteredCountryCode);
            }));
        }
        /**
         * @private
         * @param {?} code
         * @return {?}
         */
        NxIbanMaskDirective.prototype._setCountryCode = /**
         * @private
         * @param {?} code
         * @return {?}
         */
        function (code) {
            code = code.toUpperCase();
            if (code.length === 2 && this._countryCode !== code) {
                if (this._countryCodeExists(code)) {
                    this._countryCode = code;
                    this.maskDirective.setMask(this._getMask(this._countryCode));
                }
                else {
                    this._countryCode = null;
                    this.maskDirective.setMask('SS');
                }
            }
        };
        /**
         * @return {?}
         */
        NxIbanMaskDirective.prototype.ngOnInit = /**
         * @return {?}
         */
        function () {
            // set only first two letters as I don't know a country yet
            this.maskDirective.mask = 'SS';
            this.maskDirective.convertTo = 'upper';
        };
        /**
         * @private
         * @param {?} countryCode
         * @return {?}
         */
        NxIbanMaskDirective.prototype._getMask = /**
         * @private
         * @param {?} countryCode
         * @return {?}
         */
        function (countryCode) {
            // the countrySpecs of a country contain: countryCode ("DE"), length (22), structure ("F08F10")
            // and an example belonging to each country
            /** @type {?} */
            var countrySpecs = iban.countries[countryCode];
            // 'SS' for country code + '00' for IBAN checksum
            /** @type {?} */
            var mask = 'SS00';
            // split up after every third character
            /** @type {?} */
            var characterDefs = countrySpecs['structure'].match(/.{1,3}/g);
            characterDefs.forEach((/**
             * @param {?} charDef
             * @return {?}
             */
            function (charDef) {
                /** @type {?} */
                var character = charDef[0];
                /** @type {?} */
                var count = Number(charDef.substring(1, 3));
                switch (character) {
                    // [0-9]
                    case 'F':
                        mask = mask + '0'.repeat(count);
                        break;
                    // [0-9A-Za-z]
                    case 'A':
                        mask = mask + 'A'.repeat(count);
                        break;
                    // [A-Z]
                    // 'S' in nxMask does accept also [a-z].
                    // There is no option for only accepting capital letters at the moment.
                    case 'U':
                        mask = mask + 'S'.repeat(count);
                        break;
                }
            }));
            // insert whitespaces after every 4 characters
            mask = mask.match(/.{1,4}/g).join(' ');
            return mask;
        };
        /**
         * @private
         * @param {?} countryCode
         * @return {?}
         */
        NxIbanMaskDirective.prototype._countryCodeExists = /**
         * @private
         * @param {?} countryCode
         * @return {?}
         */
        function (countryCode) {
            return (!!iban.countries[countryCode]);
        };
        /**
         * @private
         * @return {?}
         */
        NxIbanMaskDirective.prototype._validateFn = /**
         * @private
         * @return {?}
         */
        function () {
            /** @type {?} */
            var enteredCountryCode = this._elementRef.nativeElement.value.substr(0, 2);
            if (enteredCountryCode.length === 2 && !this._countryCodeExists(enteredCountryCode)) {
                // immediately show error to user
                this.maskDirective._touch();
                return { nxIbanInvalidCountryError: 'no valid country code' };
            }
            if (!iban.isValid(this.maskDirective.getUnmaskedValue())) {
                return { nxIbanParseError: 'no valid iban' };
            }
            return null;
        };
        /** @docs-private */
        /**
         * \@docs-private
         * @return {?}
         */
        NxIbanMaskDirective.prototype.validate = /**
         * \@docs-private
         * @return {?}
         */
        function () {
            return this.maskDirective.validateMask ? this._validateFn() : null;
        };
        NxIbanMaskDirective.decorators = [
            { type: core.Directive, args: [{
                        selector: 'input[nxIbanMask]',
                        exportAs: 'nxIbanMaskDirective',
                        providers: [
                            NX_IBAN_MASK_VALIDATORS
                        ]
                    },] }
        ];
        /** @nocollapse */
        NxIbanMaskDirective.ctorParameters = function () { return [
            { type: core.ElementRef },
            { type: NxMaskDirective, decorators: [{ type: core.Inject, args: [core.forwardRef((/**
                             * @return {?}
                             */
                            function () { return NxMaskDirective; })),] }] }
        ]; };
        return NxIbanMaskDirective;
    }());
    if (false) {
        /**
         * @type {?}
         * @private
         */
        NxIbanMaskDirective.prototype._countryCode;
        /**
         * @type {?}
         * @private
         */
        NxIbanMaskDirective.prototype._afterInputHook;
        /**
         * @type {?}
         * @private
         */
        NxIbanMaskDirective.prototype._beforePasteHook;
        /**
         * @type {?}
         * @private
         */
        NxIbanMaskDirective.prototype._elementRef;
        /**
         * @type {?}
         * @private
         */
        NxIbanMaskDirective.prototype.maskDirective;
    }

    /**
     * @fileoverview added by tsickle
     * Generated from: mask.module.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var NxMaskModule = /** @class */ (function () {
        function NxMaskModule() {
        }
        NxMaskModule.decorators = [
            { type: core.NgModule, args: [{
                        imports: [
                            common.CommonModule,
                            formfield.NxFormfieldModule
                        ],
                        declarations: [
                            NxMaskDirective,
                            NxIbanMaskDirective
                        ],
                        exports: [
                            formfield.NxFormfieldModule,
                            NxMaskDirective,
                            NxIbanMaskDirective
                        ]
                    },] }
        ];
        return NxMaskModule;
    }());

    exports.NX_IBAN_MASK_VALIDATORS = NX_IBAN_MASK_VALIDATORS;
    exports.NX_MASK_VALIDATORS = NX_MASK_VALIDATORS;
    exports.NX_MASK_VALUE_ACCESSOR = NX_MASK_VALUE_ACCESSOR;
    exports.NxIbanMaskDirective = NxIbanMaskDirective;
    exports.NxMaskDirective = NxMaskDirective;
    exports.NxMaskModule = NxMaskModule;

    Object.defineProperty(exports, '__esModule', { value: true });

})));
//# sourceMappingURL=allianz-ngx-ndbx-mask.umd.js.map
